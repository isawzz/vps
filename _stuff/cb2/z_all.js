const DOMCATS = { rect: 'g', g: 'g', circle: 'g', text: 'g', polygon: 'g', line: 'g', body: 'd', svg: 'h', div: 'd', p: 'd', table: 'd', button: 'd', a: 'd', span: 'd', image: 'd', paragraph: 'd', anchor: 'd' };
const IS_MIRROR = false;
const FLASK = true;
const NGROK = false; //'http://849aec381695.ngrok.io/'; // MUSS / am ende!!!
const SERVER_URL = IS_MIRROR ? 'http://localhost:5555/' : FLASK ? (NGROK ? NGROK : 'http://localhost:' + PORT + '/') : 'http://localhost:5005/';
const clientData = {};
const defaultGameplayerAreaName = 'gameplayerArea';
const defaultTabletopCardsAreaName = 'tabletopCardsArea';
const defaultDeckAreaName = 'deckArea';
const MIN_CARD_HEIGHT = 60;
const MAX_CARD_HEIGHT = 100;
const CARD_SZ = 80;
const LABEL_SZ = 40;
const FIELD_SZ = 40;
const THEMES = ['#c9af98', '#2F4F4F', '#6B7A8F', '#00303F', 'rgb(3, 74, 166)', '#458766', '#7A9D96'];
const overwriteMerge = (destinationArray, sourceArray, options) => sourceArray
const fieldSorter = fields => (a, b) =>
  fields
    .map(o => {
      let dir = 1;
      if (o[0] === '-') {
        dir = -1;
        o = o.substring(1);
      }
      return a[o] > b[o] ? dir : a[o] < b[o] ? -dir : 0;
    })
    .reduce((p, n) => (p ? p : n), 0);
const INTERACTION = { none: 0, selected: 1, stop: 2, saveLoad: 3, route: 4 };
const MAX_PLAYERS_AVAILABLE = 8;
const soloTypes = ['me', 'AI regular', 'AI random', 'AI pass'];
const allPlayerTypes = ['me', 'human', 'AI regular', 'AI random', 'AI pass'];
const PLAYER_CONFIG_FOR_MULTIPLAYER = ['me', 'human', 'human'];
const CACHE_INITDATA = true;
const RUNTEST = false;
const USE_NON_TESTING_DATA = true;
const DSPEC_VERSION = 3;
const USPEC_VERSION = '2a';
const SERVERDATA_VERSION = 1;
const TEST_PATH = '/zdata/';
const INIT_CLEAR_LOCALSTORAGE = true;
const USE_MAX_PLAYER_NUM = false;
const STARTING_TAB_OPEN = 'bPlayers';
const TIMIT_SHOW = false;
const SHOW_SERVER_ROUTE = false;
const SHOW_SERVER_RETURN = false;
const USE_OLD_GRID_FUNCTIONS = false;
const USE_ALL_GAMES_ROUTE = false;
const USE_SOCKETIO = false;
const USE_BACKEND_AI = true;
const names = ['felix', 'amanda', 'sabine', 'tom', 'taka', 'microbe', 'dwight', 'jim', 'michael', 'pam', 'kevin', 'darryl', 'lauren', 'anuj', 'david', 'holly'];
const TEST_VERSION = '17';
const INCREMENTAL_UPDATE = true;
const VERBOSE = true;
const SHOW_SERVERDATA = false;
const USER_SERVERDATA_STUB = false;
const DEF_ORIENTATION = 'v';
const DEF_SPLIT = 0.5;
const RUPDATE = {
  info: mNodeChangeContent,
};
const MAX_RECURSIONS = 200;
const RCREATE = {
  card52: mCard52,
  card: mCard,
  hand: mHand,
  grid: mGrid,
  info: mInfo,
  invisible: mInvisible,
  panel: mPanel,
  picto: mPicto,
  manual00: mManual00,
}
const RCONTAINERPROP = {
  list: 'elm',
  hand: 'elm',
  panel: 'sub',
}
const PARAMCSS = {
  bg: 'background-color',
  fg: 'color',
  align: 'text-align',
  rounding: 'border-radius',
};
const PARAMRSG_T = {
  defaultType: false,
  show: false,
  overlap: true,
  orientation: true,
  split: true,
  shape: true,
  field_spacing: true,
  size: true,
  rounding: true,
};
const SHOW_TRACE = false;
const SHOW_DEFS = false;
const MarkerText = ['✔️', '❌'];
const MarkerId = { SUCCESS: 0, FAIL: 1 };
const GENERATE_EMPTY_MESSAGES = true;
const SEND_MOUSE_MOVE_EVERY = 200;
const MOUSED = 15;
const MASTERVOLUME = 0.1;
const germanNumbers = {
  ein: 1, eins: 1, zwei: 2, 1: 'eins', 2: 'zwei', 3: 'drei', drei: 3, vier: 4, 4: 'vier', 5: 'fuenf', fuenf: 5, sechs: 6, 6: 'sechs', sex: 6,
  sieben: 7, 7: 'sieben', 8: 'acht', acht: 8, 9: 'neun', neun: 9, zehn: 10, elf: 11, zwoelf: 12, zwanzig: 20, dreissig: 30,
  10: 'zehn', 11: 'elf', 12: 'zwoelf', 20: 'zwanzig', 30: 'dreissig', vierzig: 40, fuenfzig: 50, 40: 'vierzig', 50: 'fuenfzig'
};
const _overwriteMerge = (destinationArray, sourceArray, options) => sourceArray
const messageTypes = { LEFT: 'left', RIGHT: 'right', LOGIN: 'login' };
const messages = [];
const VerboseSocket = false;
const createMessageHTML = message => {
  if (isString(message)) {
    return `
      <p class="secondary-text text-center mb-2">${message}</p>
    `;
  } else if (isString(message)) {
    return `
    <div>
      <p style="color:red" class="message-content">${message}</p>
    </div>
    `;
  }
  return `
  <div class="message ${message.type === messageTypes.LEFT ? 'message-left' : 'message-right'
    }">
    <div class="message-details flex">
      <p class="flex-grow-1 message-author">${message.author}</p>
      <p class="message-date">${message.date}</p>
    </div>
    <p class="message-content">${message.content}</p>
  </div>
  `;
};
const displayMessages = () => {
  const messagesHTML = messages
    .map(message => createMessageHTML(message))
    .join('');
  messagesList.innerHTML = messagesHTML;
};
const BLUE = '#4363d8';
const BROWN = '#96613d';
const GREEN = '#3cb44b';
const BLUEGREEN = '#004054';
const FIREBRICK = '#800000';
const LIGHTGREEN = '#afff45'; //'#bfef45';
const LIGHTBLUE = '#42d4f4';
const OLIVE = '#808000';
const ORANGE = '#f58231';
const PURPLE = '#911eb4';
const RED = '#e6194B';
const TEAL = '#469990';
const YELLOW = '#ffe119';
const YELLOW2 = '#fff620';
const YELLOW3 = '#ffed01';
const wamber = '#ffc107';
const waqua = '#00ffff';
const wblack = '#000000';
const wblue = '#2196f3';
const wbluegrey = '#607d8b';
const wbluegray = '#607d8b';
const wbrown = '#795548';
const wcyan = '#00bcd4';
const wdarkgrey = '#616161';
const wdeeporange = '#ff5722';
const wdeeppurple = '#673ab7';
const wgreen = '#4caf50';
const wgrey = '#9e9e9e';
const windigo = '#3f51b5';
const wkhaki = '#f0e68c';
const wlight = '#f1f1f1';
const wlightblue = '#87ceeb';
const wlightgreen = '#8bc34a';
const wlime = '#cddc39';
const worange = '#ff9800';
const wpaleblue = '#ddffff';
const wpalegreen = '#ddffdd';
const wpalered = '#ffdddd';
const wpaleyellow = '#ffffcc';
const wpink = '#e91e63';
const wpurple = '#9c27b0';
const wred = '#f44336';
const wsand = '#fdf5e6';
const wteal = '#009688';
const wwhite = '#ffffff';
const wyellow = '#ffeb3b';
const ColorList = ['lightgreen', 'lightblue', 'yellow', 'red', 'green', 'blue', 'purple', 'violet', 'lightyellow',
  'teal', 'orange', 'brown', 'olive', 'deepskyblue', 'deeppink', 'gold', 'black', 'white', 'grey'];
const levelColors = [LIGHTGREEN, LIGHTBLUE, YELLOW, 'orange', RED,
  GREEN, BLUE, PURPLE, YELLOW2, 'deepskyblue',
  'deeppink', TEAL, ORANGE, 'seagreen', FIREBRICK, OLIVE,
  '#ffd8b1', '#000075', '#a9a9a9', '#ffffff', '#000000', 'gold', 'orangered', 'skyblue', 'pink', 'deeppink',
  'palegreen', '#e6194B'];
const DD = {
  yellow: 'gelb', green: 'grün', blue: 'blau', red: 'rot', pink: 'rosa', orange: 'orange', black: 'schwarz',
  white: 'weiss', violet: 'violett', '1st': 'erste', '2nd': 'zweite', '3rd': 'dritte', '4th': 'vierte', '5th': 'fünfte',
  add: 'addiere', subtract: 'subtrahiere', multiply: 'mutipliziere', plus: 'plus', minus: 'minus', times: 'mal',
  'divided by': 'dividiert durch', excellent: 'sehr gut', very: 'sehr', good: 'gut',
  'to the previous number': 'zur vorhergehenden zahl',
  'from the previous number': 'von der vorhergehenden zahl',
  'multiply the previous number by': 'multipliziere die vorhergehende zahl mit',
  'divide the previous number by': 'dividiere die vorhergehende zahl durch',
  'the previous number': 'die vorhergehende zahl', is: 'ist', what: 'was', equals: 'ist gleich', enter: "tippe",
  'to the power of': 'hoch', or: 'oder', less: 'kleiner', greater: 'grösser', than: 'als', equal: 'gleich', and: 'und',
  not: 'nicht', click: 'click', press: 'tippe', quite: 'ziemlich', 'not quite': 'nicht ganz',
  say: 'sage', write: 'schreibe', complete: 'ergänze', 'unequal': 'ungleich', except: 'ausser', EXCEPT: 'AUSSER',
  number: 'Zahl', color: 'farbe', eliminate: 'eliminiere', all: 'alle', with: 'mit', true: 'wahr', false: 'falsch',
  build: 'bilde', count: 'zähle', 'the red dots': 'die roten Punkte',
};
const playerColors = {
  red: '#D01013',
  blue: '#003399',
  green: '#58A813',
  orange: '#FF6600',
  yellow: '#FAD302',
  violet: '#55038C',
  pink: '#ED527A',
  beige: '#D99559',
  sky: '#049DD9',
  brown: '#A65F46',
  white: '#FFFFFF',
};
const PlayerColors = {
  red: '#D01013',
  blue: '#003399',
  green: '#58A813',
  orange: '#FF6600',
  yellow: '#FAD302',
  violet: '#55038C',
  pink: '#ED527A',
  beige: '#D99559',
  sky: '#049DD9',
  brown: '#A65F46',
  white: '#FFFFFF',
  lightblue: '#42d4f4',
  lightgreen: '#afff45',
};
const OPS = {
  'first': { cmd: 'add', link: 'to', wr: '+', sp: 'plus', f: (a, b) => (a + b), min: 20, max: 100 },
  'plus': { cmd: 'add', link: 'to', wr: '+', sp: 'plus', f: (a, b) => (a + b), min: 3, max: 30 },
  'minus': { cmd: 'subtract', link: 'from', wr: '-', sp: 'minus', f: (a, b) => (a - b), min: 1, max: 10 },
  'div': { cmd: 'divide', link: 'by', wr: ':', sp: 'divided by', f: (a, b) => (a / b), min: 2, max: 10 },
  'intdiv': { cmd: 'divide', link: 'by', wr: 'div', sp: 'divided by', f: (a, b) => (Math.floor(a / b)), min: 1, max: 10 },
  'mult': { cmd: 'multiply', link: 'by', wr: 'x', sp: 'times', f: (a, b) => (a * b), min: 2, max: 10 },
  'pow': { cmd: 'build', link: 'to the power of', wr: '^', sp: 'to the power of', f: (a, b) => (Math.pow(a, b)), min: 0, max: 20 },
  'mod': { cmd: 'build', link: 'modulo', wr: '%', sp: 'modulo', f: (a, b) => (a % b), min: 0, max: 20 },
  'l': { cmd: 'true or false?', link: 'less than', wr: '<', sp: 'less than', f: (a, b) => (a < b) },
  'g': { cmd: 'true or false?', link: 'greater than', wr: '>', sp: 'greater than', f: (a, b) => (a > b) },
  'leq': { cmd: 'true or false?', link: 'less or equal', wr: '<=', sp: 'less or equal', f: (a, b) => (a <= b) },
  'geq': { cmd: 'true or false?', link: 'greater or equal', wr: '>=', sp: 'greater or equal', f: (a, b) => (a >= b) },
  'eq': { cmd: 'true or false?', link: 'equal', wr: '=', sp: 'equal', f: (a, b) => (a == b) },
  'neq': { cmd: 'true or false?', link: 'unequal', wr: '#', sp: 'unequal', f: (a, b) => (a != b) },
  'and': { cmd: 'true or false?', link: 'and', wr: '&&', sp: 'and', f: (a, b) => (a && b) },
  'or': { cmd: 'true or false?', link: 'or', wr: '||', sp: 'or', f: (a, b) => (a || b) },
  'nand': { cmd: 'true or false?', link: 'nand', wr: 'nand', sp: 'nand', f: (a, b) => (!(a && b)) },
  'nor': { cmd: 'true or false?', link: 'nor', wr: 'nor', sp: 'nor', f: (a, b) => (!(a || b)) },
  'xor': { cmd: 'true or false?', link: 'xor', wr: 'xor', sp: 'xor', f: (a, b) => (a && !b || !a && b) },
}
const GirlNames = ['afia', 'ally', 'amanda', 'angela', 'anna', 'annabel', 'birgit', 'bona', 'carmen', 'cassandra',
  'charlene', 'erin', 'hanna', 'holly', 'jan', 'karen', 'kelly', 'lauren', 'malta', 'maria', 'maurita', 'minnow', 'meredith',
  'milda', 'mimi', 'minna', 'minnow', 'mitra', 'nasi', 'nil', 'nimble', 'nonna', 'pam', 'phyllis', 'poppa', 'rhi', 'sarah',
  'sheeba', 'valerie', 'viola', 'wala'];
const BoyNames = ['aaron', 'andy', 'bill', 'blade', 'bob', 'buddy', 'creed', 'dan', 'darryl', 'dagobert', 'david', 'donald', 'dwight', 'felix',
  'gilbert', 'gul', 'jim', 'john', 'kevin', 'leo', 'luis', 'mac', 'max', 'michael', 'mike', 'oscar', 'peter', 'robert', 'ryan',
  'sebastian', 'stanley', 'stitch', 'toby', 'tom', 'vladimir', 'wolf', 'wolfgang'];
const UnicodeSymbols = {
  menu: '☰',
};
const STYLE_PARAMS = {
  align: 'text-align',
  acontent: 'align-content',
  aitems: 'align-items',
  aspectRatio: 'aspect-ratio',
  bg: 'background-color',
  dir: 'flex-direction',
  fg: 'color',
  hgap: 'column-gap',
  vgap: 'row-gap',
  jcontent: 'justify-content',
  jitems: 'justify-items',
  justify: 'justify-content',
  matop: 'margin-top',
  maleft: 'margin-left',
  mabottom: 'margin-bottom',
  maright: 'margin-right',
  origin: 'transform-origin',
  overx: 'overflow-x',
  overy: 'overflow-y',
  patop: 'padding-top',
  paleft: 'padding-left',
  pabottom: 'padding-bottom',
  paright: 'padding-right',
  place: 'place-items',
  rounding: 'border-radius',
  w: 'width',
  h: 'height',
  wmin: 'min-width',
  hmin: 'min-height',
  hline: 'line-height',
  wmax: 'max-width',
  hmax: 'max-height',
  fontSize: 'font-size',
  fz: 'font-size',
  family: 'font-family',
  weight: 'font-weight',
  x: 'left',
  y: 'top',
  z: 'z-index'
};
const NEONORANGE = '#ff6700';
const NEONYELLOW = '#efff04';
const rgbToHexCOOL = (pixel) => {
  const componentToHex = (c) => {
    const hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
  };
  return (
    "#" +
    componentToHex(pixel.r) +
    componentToHex(pixel.g) +
    componentToHex(pixel.b)
  ).toUpperCase();
};
const hslToHexCOOL = (hslColor) => {
  const hslColorCopy = { ...hslColor };
  hslColorCopy.l /= 100;
  const a =
    (hslColorCopy.s * Math.min(hslColorCopy.l, 1 - hslColorCopy.l)) / 100;
  const f = (n) => {
    const k = (n + hslColorCopy.h / 30) % 12;
    const color = hslColorCopy.l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return Math.round(255 * color)
      .toString(16)
      .padStart(2, "0");
  };
  return `#${f(0)}${f(8)}${f(4)}`.toUpperCase();
};
const convertRGBtoHSL = (rgbValues) => {
  return rgbValues.map((pixel) => {
    let hue,
      saturation,
      luminance = 0;
    let redOpposite = pixel.r / 255;
    let greenOpposite = pixel.g / 255;
    let blueOpposite = pixel.b / 255;
    const Cmax = Math.max(redOpposite, greenOpposite, blueOpposite);
    const Cmin = Math.min(redOpposite, greenOpposite, blueOpposite);
    const difference = Cmax - Cmin;
    luminance = (Cmax + Cmin) / 2.0;
    if (luminance <= 0.5) {
      saturation = difference / (Cmax + Cmin);
    } else if (luminance >= 0.5) {
      saturation = difference / (2.0 - Cmax - Cmin);
    }
    const maxColorValue = Math.max(pixel.r, pixel.g, pixel.b);
    if (maxColorValue === pixel.r) {
      hue = (greenOpposite - blueOpposite) / difference;
    } else if (maxColorValue === pixel.g) {
      hue = 2.0 + (blueOpposite - redOpposite) / difference;
    } else {
      hue = 4.0 + (greenOpposite - blueOpposite) / difference;
    }
    hue = hue * 60;
    if (hue < 0) {
      hue = hue + 360;
    }
    if (difference === 0) {
      return false;
    }
    return {
      h: Math.round(hue) + 180,
      s: parseFloat(saturation * 100).toFixed(2),
      l: parseFloat(luminance * 100).toFixed(2),
    };
  });
};
const orderByLuminance = (rgbValues) => {
  const calculateLuminance = (p) => {
    return 0.2126 * p.r + 0.7152 * p.g + 0.0722 * p.b;
  };
  return rgbValues.sort((p1, p2) => {
    return calculateLuminance(p2) - calculateLuminance(p1);
  });
};
const buildRgb = (imageData) => {
  const rgbValues = [];
  for (let i = 0; i < imageData.length; i += 4) {
    const rgb = {
      r: imageData[i],
      g: imageData[i + 1],
      b: imageData[i + 2],
    };
    rgbValues.push(rgb);
  }
  return rgbValues;
};
const calculateColorDifference = (color1, color2) => {
  const rDifference = Math.pow(color2.r - color1.r, 2);
  const gDifference = Math.pow(color2.g - color1.g, 2);
  const bDifference = Math.pow(color2.b - color1.b, 2);
  return rDifference + gDifference + bDifference;
};
const buildPalette = (colorsList) => {
  const paletteContainer = document.getElementById("palette");
  const complementaryContainer = document.getElementById("complementary");
  paletteContainer.innerHTML = "";
  complementaryContainer.innerHTML = "";
  const orderedByColor = orderByLuminance(colorsList);
  const hslColors = convertRGBtoHSL(orderedByColor);
  for (let i = 0; i < orderedByColor.length; i++) {
    const hexColor = rgbToHexCOOL(orderedByColor[i]);
    const hexColorComplementary = hslToHexCOOL(hslColors[i]);
    if (i > 0) {
      const difference = calculateColorDifference(
        orderedByColor[i],
        orderedByColor[i - 1]
      );
      if (difference < 120) {
        continue;
      }
    }
    const colorElement = document.createElement("div");
    colorElement.style.backgroundColor = hexColor;
    colorElement.appendChild(document.createTextNode(hexColor));
    paletteContainer.appendChild(colorElement);
    if (hslColors[i].h) {
      const complementaryElement = document.createElement("div");
      complementaryElement.style.backgroundColor = `hsl(${hslColors[i].h},${hslColors[i].s}%,${hslColors[i].l}%)`;
      complementaryElement.appendChild(
        document.createTextNode(hexColorComplementary)
      );
      complementaryContainer.appendChild(complementaryElement);
    }
  }
};
const findBiggestColorRange = (rgbValues) => {
  let rMin = Number.MAX_VALUE;
  let gMin = Number.MAX_VALUE;
  let bMin = Number.MAX_VALUE;
  let rMax = Number.MIN_VALUE;
  let gMax = Number.MIN_VALUE;
  let bMax = Number.MIN_VALUE;
  rgbValues.forEach((pixel) => {
    rMin = Math.min(rMin, pixel.r);
    gMin = Math.min(gMin, pixel.g);
    bMin = Math.min(bMin, pixel.b);
    rMax = Math.max(rMax, pixel.r);
    gMax = Math.max(gMax, pixel.g);
    bMax = Math.max(bMax, pixel.b);
  });
  const rRange = rMax - rMin;
  const gRange = gMax - gMin;
  const bRange = bMax - bMin;
  const biggestRange = Math.max(rRange, gRange, bRange);
  if (biggestRange === rRange) {
    return "r";
  } else if (biggestRange === gRange) {
    return "g";
  } else {
    return "b";
  }
};
const quantization = (rgbValues, depth) => {
  const MAX_DEPTH = 4;
  if (depth === MAX_DEPTH || rgbValues.length === 0) {
    const color = rgbValues.reduce(
      (prev, curr) => {
        prev.r += curr.r;
        prev.g += curr.g;
        prev.b += curr.b;
        return prev;
      },
      {
        r: 0,
        g: 0,
        b: 0,
      }
    );
    color.r = Math.round(color.r / rgbValues.length);
    color.g = Math.round(color.g / rgbValues.length);
    color.b = Math.round(color.b / rgbValues.length);
    return [color];
  }
  const componentToSortBy = findBiggestColorRange(rgbValues);
  rgbValues.sort((p1, p2) => {
    return p1[componentToSortBy] - p2[componentToSortBy];
  });
  const mid = rgbValues.length / 2;
  return [
    ...quantization(rgbValues.slice(0, mid), depth + 1),
    ...quantization(rgbValues.slice(mid + 1), depth + 1),
  ];
};
const GT = {};
const RSGTYPES = { board: 1, hand: 2, field: 101, edge: 102, corner: 103 };
const CORNERS = ['◢', '◣', '◤', '◥'];
const CORNERS0 = ['♠', '♡'];
const CORNERS2 = ['⬔', '⬕'];
const CORNERS3 = ['⮜', '⮝', '⮞', '⮟'];
const CORNERS4 = ['⭐', '⭑'];
const CORNERS5 = ['⬛', '⬜'];
const BLUFF = {
  torank: { _: '_', three: '3', four: '4', five: '5', six: '6', seven: '7', eight: '8', nine: '9', ten: 'T', jack: 'J', queen: 'Q', king: 'K', ace: 'A' },
  toword: { _: '_', '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine', T: 'ten', J: 'jack', Q: 'queen', K: 'king', A: 'ace' },
  rankstr: '3456789TJQKA',
};
const DEFAULTPICTYPE = 'all';
const LevelsML = {
  0: { NumPics: 1, NumLabels: 1, MinWordLength: 3, MaxWordLength: 3, NumMissingLetters: 1, MaxPosMissing: 0, MaxNumTrials: 3 },
  1: { NumPics: 1, NumLabels: 1, MinWordLength: 3, MaxWordLength: 4, NumMissingLetters: 1, MaxPosMissing: 0, MaxNumTrials: 3 },
  2: { NumPics: 1, NumLabels: 1, MinWordLength: 4, MaxWordLength: 5, NumMissingLetters: 2, MaxPosMissing: 1, MaxNumTrials: 3 },
  3: { NumPics: 1, NumLabels: 0, MinWordLength: 4, MaxWordLength: 6, NumMissingLetters: 1, MaxPosMissing: 0, MaxNumTrials: 3 },
  4: { NumPics: 1, NumLabels: 0, MinWordLength: 4, MaxWordLength: 7, NumMissingLetters: 2, MaxPosMissing: 1, MaxNumTrials: 3 },
  5: { NumPics: 1, NumLabels: 0, MinWordLength: 5, MaxWordLength: 8, NumMissingLetters: 1, MaxPosMissing: 1, MaxNumTrials: 3 },
  6: { NumPics: 1, NumLabels: 0, MinWordLength: 5, MaxWordLength: 9, NumMissingLetters: 2, MaxPosMissing: 2, MaxNumTrials: 3 },
  7: { NumPics: 1, NumLabels: 0, MinWordLength: 5, MaxWordLength: 10, NumMissingLetters: 3, MaxPosMissing: 4, MaxNumTrials: 3 },
  8: { NumPics: 1, NumLabels: 0, MinWordLength: 6, MaxWordLength: 11, NumMissingLetters: 4, MaxPosMissing: 12, MaxNumTrials: 3 },
  9: { NumPics: 1, NumLabels: 0, MinWordLength: 6, MaxWordLength: 12, NumMissingLetters: 5, MaxPosMissing: 12, MaxNumTrials: 3 },
  10: { NumPics: 1, NumLabels: 0, MinWordLength: 6, MaxWordLength: 12, NumMissingLetters: 6, MaxPosMissing: 12, MaxNumTrials: 3 },
}
const LevelsSP = {
  0: { NumPics: 1, NumLabels: 1, MinWordLength: 2, MaxWordLength: 21, MaxNumTrials: 3 },
  1: { NumPics: 1, NumLabels: 1, MinWordLength: 3, MaxWordLength: 21, MaxNumTrials: 3 },
  2: { NumPics: 1, NumLabels: 1, MinWordLength: 3, MaxWordLength: 21, MaxNumTrials: 3 },
  3: { NumPics: 1, NumLabels: 0, MinWordLength: 4, MaxWordLength: 21, MaxNumTrials: 3 },
  4: { NumPics: 1, NumLabels: 0, MinWordLength: 4, MaxWordLength: 21, MaxNumTrials: 3 },
  5: { NumPics: 1, NumLabels: 0, MinWordLength: 5, MaxWordLength: 21, MaxNumTrials: 3 },
  6: { NumPics: 1, NumLabels: 0, MinWordLength: 6, MaxWordLength: 21, MaxNumTrials: 3 },
  7: { NumPics: 1, NumLabels: 0, MinWordLength: 7, MaxWordLength: 21, MaxNumTrials: 3 },
  8: { NumPics: 1, NumLabels: 0, MinWordLength: 8, MaxWordLength: 21, MaxNumTrials: 3 },
  9: { NumPics: 1, NumLabels: 0, MinWordLength: 7, MaxWordLength: 21, MaxNumTrials: 3 },
  10: { NumPics: 1, NumLabels: 0, MinWordLength: 6, MaxWordLength: 21, MaxNumTrials: 3 },
}
const LevelsSPA = {
  0: { NumPics: 1, NumLabels: 1, MinWordLength: 2, MaxWordLength: 4, MaxNumTrials: 1 },
  1: { NumPics: 1, NumLabels: 1, MinWordLength: 3, MaxWordLength: 5, MaxNumTrials: 3 },
  2: { NumPics: 1, NumLabels: 1, MinWordLength: 3, MaxWordLength: 6, MaxNumTrials: 3 },
  3: { NumPics: 1, NumLabels: 0, MinWordLength: 4, MaxWordLength: 7, MaxNumTrials: 3 },
  4: { NumPics: 1, NumLabels: 0, MinWordLength: 4, MaxWordLength: 8, MaxNumTrials: 3 },
  5: { NumPics: 1, NumLabels: 0, MinWordLength: 5, MaxWordLength: 9, MaxNumTrials: 3 },
  6: { NumPics: 1, NumLabels: 0, MinWordLength: 6, MaxWordLength: 10, MaxNumTrials: 3 },
  7: { NumPics: 1, NumLabels: 0, MinWordLength: 7, MaxWordLength: 11, MaxNumTrials: 3 },
  8: { NumPics: 1, NumLabels: 0, MinWordLength: 8, MaxWordLength: 12, MaxNumTrials: 3 },
  9: { NumPics: 1, NumLabels: 0, MinWordLength: 7, MaxWordLength: 13, MaxNumTrials: 3 },
  10: { NumPics: 1, NumLabels: 0, MinWordLength: 6, MaxWordLength: 14, MaxNumTrials: 1 },
}
const SIMPLE_COLORS = ['red', 'green', 'yellow', 'blue'];
const EXTENDED_COLORS = ['red', 'green', 'yellow', 'blue', 'pink', 'indigo', 'gray', 'sienna', 'olive'];
const LevelsTC = {
  0: { NumColors: 2, NumPics: 2, NumLabels: 4, MinWordLength: 2, MaxWordLength: 5, MaxNumTrials: 1 },
  1: { NumColors: 2, NumPics: 3, NumLabels: 6, MinWordLength: 3, MaxWordLength: 6, MaxNumTrials: 1 },
  2: { NumColors: 3, NumPics: 2, NumLabels: 6, MinWordLength: 3, MaxWordLength: 7, MaxNumTrials: 1 },
  3: { NumColors: 3, NumPics: 3, NumLabels: 9, MinWordLength: 4, MaxWordLength: 7, MaxNumTrials: 1 },
  4: { NumColors: 3, NumPics: 3, NumLabels: 0, MinWordLength: 4, MaxWordLength: 14, MaxNumTrials: 2 },
  5: { NumColors: 2, NumPics: 2, NumLabels: 2, MinWordLength: 4, MaxWordLength: 8, MaxNumTrials: 1 },
  6: { NumColors: 2, NumPics: 2, NumLabels: 2, MinWordLength: 4, MaxWordLength: 9, MaxNumTrials: 1 },
  7: { NumColors: 2, NumPics: 2, NumLabels: 2, MinWordLength: 5, MaxWordLength: 10, MaxNumTrials: 2 },
  8: { NumColors: 3, NumPics: 3, NumLabels: 9, MinWordLength: 5, MaxWordLength: 11, MaxNumTrials: 2 },
  9: { NumColors: 3, NumPics: 3, NumLabels: 3, MinWordLength: 6, MaxWordLength: 12, MaxNumTrials: 2 },
  10: { NumColors: 3, NumPics: 3, NumLabels: 0, MinWordLength: 6, MaxWordLength: 13, MaxNumTrials: 3 },
}
const LevelsTP = {
  0: { NumPics: 2, NumLabels: 2, MinWordLength: 2, MaxWordLength: 4, MaxNumTrials: 1 },
  1: { NumPics: 3, NumLabels: 3, MinWordLength: 3, MaxWordLength: 5, MaxNumTrials: 1 },
  2: { NumPics: 2, NumLabels: 1, MinWordLength: 3, MaxWordLength: 6, MaxNumTrials: 1 },
  3: { NumPics: 3, NumLabels: 2, MinWordLength: 4, MaxWordLength: 7, MaxNumTrials: 1 },
  4: { NumPics: 2, NumLabels: 0, MinWordLength: 4, MaxWordLength: 8, MaxNumTrials: 1 },
  5: { NumPics: 4, NumLabels: 4, MinWordLength: 4, MaxWordLength: 9, MaxNumTrials: 1 },
  6: { NumPics: 3, NumLabels: 1, MinWordLength: 5, MaxWordLength: 10, MaxNumTrials: 2 },
  7: { NumPics: 4, NumLabels: 2, MinWordLength: 5, MaxWordLength: 11, MaxNumTrials: 1 },
  8: { NumPics: 5, NumLabels: 5, MinWordLength: 6, MaxWordLength: 12, MaxNumTrials: 1 },
  9: { NumPics: 3, NumLabels: 0, MinWordLength: 6, MaxWordLength: 13, MaxNumTrials: 2 },
  10: { NumPics: 4, NumLabels: 0, MinWordLength: 4, MaxWordLength: 14, MaxNumTrials: 2 },
}
const LevelsWP = {
  0: { NumPics: 1, NumLabels: 1, MinWordLength: 2, MaxWordLength: 3, MaxNumTrials: 3 },
  1: { NumPics: 1, NumLabels: 1, MinWordLength: 3, MaxWordLength: 4, MaxNumTrials: 3 },
  2: { NumPics: 1, NumLabels: 1, MinWordLength: 3, MaxWordLength: 5, MaxNumTrials: 3 },
  3: { NumPics: 1, NumLabels: 0, MinWordLength: 3, MaxWordLength: 6, MaxNumTrials: 3 },
  4: { NumPics: 1, NumLabels: 0, MinWordLength: 4, MaxWordLength: 7, MaxNumTrials: 3 },
  5: { NumPics: 1, NumLabels: 0, MinWordLength: 5, MaxWordLength: 8, MaxNumTrials: 3 },
  6: { NumPics: 1, NumLabels: 0, MinWordLength: 6, MaxWordLength: 9, MaxNumTrials: 3 },
  7: { NumPics: 1, NumLabels: 0, MinWordLength: 7, MaxWordLength: 11, MaxNumTrials: 3 },
  8: { NumPics: 1, NumLabels: 0, MinWordLength: 8, MaxWordLength: 12, MaxNumTrials: 3 },
  9: { NumPics: 1, NumLabels: 0, MinWordLength: 7, MaxWordLength: 13, MaxNumTrials: 3 },
  10: { NumPics: 1, NumLabels: 0, MinWordLength: 6, MaxWordLength: 14, MaxNumTrials: 3 },
}
const voiceNames = {
  david: 'Microsoft David Desktop - English',
  zira: 'Microsoft Zira Desktop - English',
  us: 'Google US English',
  ukFemale: 'Google UK English Female',
  ukMale: 'Google UK English Male',
  deutsch: 'Google Deutsch',
};
const GFUNC = {
  gTouchPic: {
    startGame: startGameTP, startLevel: startLevelTP, startRound: startRoundTP, trialPrompt: trialPromptTP, prompt: promptTP, activate: activateTP, eval: evalTP
  },
  gTouchColors: {
    startGame: startGameTC, startLevel: startLevelTC, startRound: startRoundTC, trialPrompt: trialPromptTC, prompt: promptTC, activate: activateTC, eval: evalTC
  },
  gWritePic: {
    startGame: startGameWP, startLevel: startLevelWP, startRound: startRoundWP, trialPrompt: trialPromptWP, prompt: promptWP, activate: activateWP, eval: evalWP
  },
  gMissingLetter: {
    startGame: startGameML, startLevel: startLevelML, startRound: startRoundML, trialPrompt: trialPromptML, prompt: promptML, activate: activateML, eval: evalML
  },
  gSayPic: {
    startGame: startGameSP, startLevel: startLevelSP, startRound: startRoundSP, trialPrompt: trialPromptSP, prompt: promptSP, activate: activateSP, eval: evalSP
  },
  gSayPicAuto: {
    startGame: startGameSPA, startLevel: startLevelSPA, startRound: startRoundSPA, trialPrompt: trialPromptSPA, prompt: promptSPA, activate: activateSPA, eval: evalSPA
  },
}
const CRIMSON = colorDarker('crimson', .25);
const ALLTESTS = {
  0: {
    0: {
      fStruct: makeRoot, options: {
        presentationStrategy: 'rec', autoType: 'cssEmpty',
        params: { _1: { width: 40, height: 40, color: 'red', 'background-color': 'blue' } }
      }
    },
  },
  1: {
    0: { fStruct: makeSimplestTree, options: { params: { '_1': { height: 120 } } } },
    1: { fStruct: makeSimplestTree, options: { params: { '_1': { width: 100, height: 120 } } } },
    2: { fStruct: makeSimpleTree, options: { params: { '_1': { width: 100, height: 120 } } } },
    3: { fStruct: makeSimpleTree, options: { params: { '_1': { orientation: 'v', width: 100, height: 120 } } } },
    4: { fStruct: makeTree33, options: { params: { '_1': { orientation: 'v' }, '_4': { orientation: 'v' } } } },
    5: { fStruct: makeTree332x2, options: { params: { '_1': { orientation: 'v' } } } },
    6: { fStruct: makeTree332x2, options: { params: { '_4': { orientation: 'v' } } } },
  },
  2: {
    0: { fStruct: makeTree33, options: { params: { '_4': { fg: 'red', orientation: 'v' } } } },
    1: { fStruct: makeTree33, options: { params: { '_4': { orientation: 'v' } } } },
    2: { fStruct: makeTree33, options: { params: { '_1': { orientation: 'v' } } } },
    3: { fStruct: makeTree33, options: { params: { '_1': { orientation: 'v' } } } },
    4: { fStruct: makeTree33, options: { params: { '_1': { orientation: 'v' }, '_4': { orientation: 'v' } } } },
    5: { fStruct: makeTree332x2, options: { params: { '_1': { orientation: 'v' } } } },
    6: { fStruct: makeTree332x2, options: { params: { '_4': { orientation: 'v' } } } },
    7: { fStruct: makeTree332x2, options: { params: { '_7': { orientation: 'v' } } } },
  },
  3: {
    0: { fStruct: makeTree33, options: { params: { '_4': { fg: 'red', orientation: 'v' } } } },
    1: { fStruct: makeTree33, options: { params: { '_4': { orientation: 'v' } } } },
    2: { fStruct: makeTree33, options: { params: { '_1': { orientation: 'v' } } } },
    3: { fStruct: makeTree33, options: { params: { '_1': { orientation: 'v' } } } },
    4: { fStruct: makeTree33, options: { params: { '_1': { orientation: 'v' }, '_4': { orientation: 'v' } } } },
    5: { fStruct: makeTree332x2, options: { params: { '_1': { orientation: 'v' } } } },
    6: { fStruct: makeTree332x2, options: { params: { '_4': { orientation: 'v' } } } },
    7: { fStruct: makeTree332x2, options: { params: { '_7': { orientation: 'v' } } } },
    8: { fStruct: makeTree332x2, options: { params: { '_4': { orientation: 'v' }, '_7': { orientation: 'v' } } } },
    9: { fStruct: makeSimplestTree, options: undefined },
    10: { fStruct: makeSimplestTree, options: { fContent: contentNoRootContent } },
    11: { fStruct: makeSimpleTree, options: undefined },
    12: { fStruct: makeSimpleTree, options: { params: { '_1': { orientation: 'v' } } } },
    13: { fStruct: makeSimpleTree, options: { fContent: contentNoRootContent } },
    14: { fStruct: makeTree33, options: { fContent: contentNoRootContent } },
    15: { fStruct: makeTree332x2, options: undefined },
    16: { fStruct: makeTree332x2, options: { fContent: contentNoRootContent } },
    17: { fStruct: () => makeSimpleTree(20), options: { fContent: contentNoRootContent } },
    18: { fStruct: makeSimplestTree, options: { fContent: contentRootExtralong } },
    19: { fStruct: makeTree33, options: { fContent: contentRootExtralong } },
    20: { fStruct: () => makeSimpleTree(3), options: { fContent: contentRootExtralong } },
    21: {
      fStruct: makeTree33, options: {
        params: {
          '_1': { bg: 'black', orientation: 'v' },
          '_4': { bg: 'inherit', orientation: 'v' }
        }
      }
    },
    22: { fStruct: makeTree33, options: { fContent: contentRootExtralong, params: { '_1': { orientation: 'v' } } } },
    23: { fStruct: makeTree33, options: { fContent: contentRootExtralong, params: { '_4': { orientation: 'v' } } } },
  },
  4: {
    0: { fStruct: makeSimplestTree, options: { fContent: n => n.uid == '_1' ? 'random' : n.uid, positioning: 'random' } },
    1: { fStruct: makeSimpleTree, options: { fContent: n => n.uid == '_1' ? 'random' : n.uid, positioning: 'random' } },
    2: { fStruct: () => makeSimpleTree(10), options: { fContent: n => n.uid == '_1' ? 'random' : n.uid, positioning: 'random' } },
    3: { fStruct: makeTree33, options: { fContent: n => n.uid == '_1' ? 'random' : n.uid, positioning: 'random' } },
  },
  5: {
    0: { fStruct: makeSimplestTree, options: { fContent: n => n.uid == '_1' ? 'hallo' : n.uid, params: { '_1': { height: 120 } } } },
    1: {
      fStruct: makeSimplestTree, options: {
        fContent: n => n.uid == '_1' ? { first: '1', uid: n.uid } : n.uid,
        params: { '_1': { bg: 'blue', 'text-align': 'center', width: 100, height: 120 } }
      }
    },
  },
  6: {
    41: {
      fStruct: () => makeTreeNNEach(2, 4), options: {
        params: {
          '_1': { orientation: 'h' },
          '_2': { orientation: 'w', rows: 2, cols: 2 },
          '_7': { orientation: 'w', rows: 2, cols: 2 }
        }
      }
    },
    40: {
      fStruct: () => makeTreeNNEach(1, 4),
      options: {
        params:
        {
          '_2': { orientation: 'w', rows: 2, cols: 2 }
        }
      }
    },
    39: {
      fStruct: () => makeTreeNNEach(2, 2), options: {
        params: {
          '_2': { orientation: 'w', rows: 1, cols: 2 },
          '_5': { orientation: 'w', rows: 1, cols: 2 }
        }
      }
    },
    38: {
      fStruct: () => makeTreeNNEach(2, 4), options: {
        params: {
          '_2': { orientation: 'w', rows: 2, cols: 2 },
          '_7': { orientation: 'w', rows: 2, cols: 2 }
        }
      }
    },
    37: { fStruct: makeSimpleTree, options: { fType: typePanelInfo, fContent: contentHallo } },
    36: { fStruct: makeSimpleTree, options: { fType: typePanelInfo, fContent: contentHallo, presentationStrategy: 'new' } },
    35: { fStruct: () => makeTreeNN(2, 2), options: { fType: typeEmpty, presentationStrategy: 'new' } },
    34: { fStruct: makeTree33, options: { fType: typeEmpty, presentationStrategy: 'new' } },
    33: { fStruct: makeTree33, options: { fType: typeEmpty, presentationStrategy: 'new', params: { '_1': { orientation: 'v' } } } },
    32: { fStruct: makeTree33, options: { presentationStrategy: 'orig', params: { '_1': { orientation: 'v' } } } },
    31: {
      fStruct: makeTree33, options: {
        fType: typePanelInfo,
        presentationStrategy: 'new',
        params: { '_1': { orientation: 'v' } }
      }
    },
    30: {
      fStruct: makeTree33, options: {
        fType: typeEmpty,
        presentationStrategy: 'rec',
        params: { '_1': { orientation: 'h' } }
      }
    },
    29: { fStruct: makeTree33, options: { params: { '_1': { orientation: 'v' } } } },
    28: { fStruct: () => makeSimpleTree(8), options: { presentationStrategy: 'new', fType: type00flex } },
    27: { fStruct: makeSimplestTree, options: { presentationStrategy: 'new', fType: type00flex } },
    26: { fStruct: makeSimplestTree, options: { presentationStrategy: 'new', fType: typeEmpty } },
    25: { fStruct: makeSimplestTree, options: { presentationStrategy: 'new' } },
    24: { fStruct: makeSimplestTree, options: undefined },
    23: { fStruct: makeSimplestTree, options: { presentationStrategy: 'orig' } },
    22: { fStruct: makeSimplestTree, options: { fType: typeEmpty } },
    21: { fStruct: () => makeHugeBoardInBoardOld(25, 5), options: { fContent: contentNoParentContent } },
    20: { fStruct: () => makeHugeBoardInBoard(25, 5), options: { fContent: contentNoParentContent } },
    19: { fStruct: () => makeHugeBoardInBoard(40, 5), options: { fContent: contentNoParentContent } },
    18: { fStruct: () => makeHugeBoardInBoard(4, 2), options: { fContent: contentNoParentContent } },
    17: { fStruct: () => makeTreeNNEach(2, 4), options: { fContent: contentNoParentContent, params: { '_1': { orientation: 'w', rows: 1, cols: 2 }, '_2': { contentwalign: 'center', contenthalign: 'center' }, '_7': { contentwalign: 'center', orientation: 'w', rows: 2, cols: 2 } } } },
    16: {
      fStruct: () => makeTreeNNEach(2, 4), options: {
        fContent: contentRootExtralong,
        params: {
          '_1': { orientation: 'w', rows: 1, cols: 2 },
          '_2': { contenthalign: 'center' },
          '_7': { contentwalign: 'center', orientation: 'w', rows: 2, cols: 2 }
        }
      }
    },
    15: {
      fStruct: () => makeTreeNNEach(2, 4), options: {
        params: {
          '_1': { orientation: 'w', rows: 1, cols: 2 },
          '_7': { orientation: 'w', rows: 2, cols: 2 }
        }
      }
    },
    14: { fStruct: () => makeTreeNN(2, 4), options: { fContent: contentNoParentContentRootExtralong, params: { '_1': { orientation: 'w', rows: 1, cols: 2 }, '_2': { orientation: 'w', rows: 2, cols: 2 } } } },
    13: { fStruct: () => makeTreeNN(2, 4), options: { params: { '_1': { orientation: 'w', rows: 1, cols: 2 }, '_2': { orientation: 'w', rows: 2, cols: 2 } } } },
    12: { fStruct: () => makeTreeNN(2, 4), options: { fContent: contentNoParentContent, params: { '_1': { orientation: 'w', rows: 1, cols: 2 }, '_2': { orientation: 'w', rows: 2, cols: 2 } } } },
    11: { fStruct: () => makeSimpleTree(3), options: { fContent: contentRootExtralong, params: { '_1': { orientation: 'w', rows: 3, cols: 1 } } } },
    10: { fStruct: () => makeSimpleTree(3), options: { params: { '_1': { orientation: 'w', rows: 3, cols: 1 } } } },
    9: { fStruct: () => makeSimpleTree(3), options: { fContent: contentNoParentContent, params: { '_1': { orientation: 'w', rows: 3, cols: 1 } } } },
    8: { fStruct: () => makeSimpleTree(2), options: { fContent: contentRootExtralong, params: { '_1': { orientation: 'w', rows: 2, cols: 1 } } } },
    7: { fStruct: () => makeSimpleTree(2), options: { params: { '_1': { orientation: 'w', rows: 2, cols: 1 } } } },
    6: { fStruct: () => makeSimpleTree(2), options: { fContent: contentNoParentContent, params: { '_1': { orientation: 'w', rows: 2, cols: 1 } } } },
    5: { fStruct: () => makeSimpleTree(4), options: { fContent: contentRootExtralong, params: { '_1': { orientation: 'w', rows: 2, cols: 2 } } } },
    4: { fStruct: () => makeSimpleTree(4), options: { params: { '_1': { orientation: 'w', rows: 2, cols: 2 } } } },
    3: { fStruct: () => makeSimpleTree(2), options: { fContent: contentRootExtralong } },
    2: { fStruct: () => makeSimpleTree(2), options: { positioning: 'regular', fContent: contentRootExtralong } },
    1: { fStruct: () => makeSimpleTree(20), options: { positioning: 'regular' } },
    0: { fStruct: () => makeSimpleTree(4), options: { fContent: n => n.uid == '_1' ? 'board' : n.uid, positioning: 'regular' } },
  },
  7: {
    0: { fStruct: makeSimpleTree, options: { autoType: 'cssEmpty', fContent: contentNoParentContent } },
  },
};
const ALLTESTSOLUTIONS = {
  0: {},
  1: { "0": { "_1": { "w": 23, "h": 120 }, "_2": { "w": 19, "h": 19 } }, "1": { "_1": { "w": 104, "h": 120 }, "_2": { "w": 19, "h": 19 } }, "2": { "_1": { "w": 104, "h": 120 }, "_2": { "w": 19, "h": 19 }, "_3": { "w": 19, "h": 19 } }, "3": { "_1": { "w": 104, "h": 120 }, "_2": { "w": 19, "h": 19 }, "_3": { "w": 19, "h": 19 } }, "4": { "_1": { "w": 27, "h": 145 }, "_2": { "w": 23, "h": 19 }, "_3": { "w": 23, "h": 19 }, "_4": { "w": 23, "h": 82 }, "_5": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 19 }, "_7": { "w": 19, "h": 19 } }, "5": { "_1": { "w": 130, "h": 124 }, "_2": { "w": 126, "h": 19 }, "_3": { "w": 126, "h": 19 }, "_4": { "w": 126, "h": 61 }, "_5": { "w": 44, "h": 40 }, "_8": { "w": 19, "h": 19 }, "_9": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 40 }, "_7": { "w": 54, "h": 40 }, "_10": { "w": 24, "h": 19 }, "_11": { "w": 23, "h": 19 } }, "6": { "_1": { "w": 104, "h": 145 }, "_2": { "w": 19, "h": 124 }, "_3": { "w": 19, "h": 124 }, "_4": { "w": 58, "h": 124 }, "_5": { "w": 54, "h": 40 }, "_8": { "w": 19, "h": 19 }, "_9": { "w": 19, "h": 19 }, "_6": { "w": 54, "h": 19 }, "_7": { "w": 54, "h": 40 }, "_10": { "w": 24, "h": 19 }, "_11": { "w": 23, "h": 19 } } },
  2: { "0": { "_1": { "w": 69, "h": 103 }, "_2": { "w": 19, "h": 82 }, "_3": { "w": 19, "h": 82 }, "_4": { "w": 23, "h": 82 }, "_5": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 19 }, "_7": { "w": 19, "h": 19 } }, "1": { "_1": { "w": 69, "h": 103 }, "_2": { "w": 19, "h": 82 }, "_3": { "w": 19, "h": 82 }, "_4": { "w": 23, "h": 82 }, "_5": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 19 }, "_7": { "w": 19, "h": 19 } }, "2": { "_1": { "w": 69, "h": 103 }, "_2": { "w": 65, "h": 19 }, "_3": { "w": 65, "h": 19 }, "_4": { "w": 65, "h": 40 }, "_5": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 19 }, "_7": { "w": 19, "h": 19 } }, "3": { "_1": { "w": 69, "h": 103 }, "_2": { "w": 65, "h": 19 }, "_3": { "w": 65, "h": 19 }, "_4": { "w": 65, "h": 40 }, "_5": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 19 }, "_7": { "w": 19, "h": 19 } }, "4": { "_1": { "w": 27, "h": 145 }, "_2": { "w": 23, "h": 19 }, "_3": { "w": 23, "h": 19 }, "_4": { "w": 23, "h": 82 }, "_5": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 19 }, "_7": { "w": 19, "h": 19 } }, "5": { "_1": { "w": 130, "h": 124 }, "_2": { "w": 126, "h": 19 }, "_3": { "w": 126, "h": 19 }, "_4": { "w": 126, "h": 61 }, "_5": { "w": 44, "h": 40 }, "_8": { "w": 19, "h": 19 }, "_9": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 40 }, "_7": { "w": 54, "h": 40 }, "_10": { "w": 24, "h": 19 }, "_11": { "w": 23, "h": 19 } }, "6": { "_1": { "w": 104, "h": 145 }, "_2": { "w": 19, "h": 124 }, "_3": { "w": 19, "h": 124 }, "_4": { "w": 58, "h": 124 }, "_5": { "w": 54, "h": 40 }, "_8": { "w": 19, "h": 19 }, "_9": { "w": 19, "h": 19 }, "_6": { "w": 54, "h": 19 }, "_7": { "w": 54, "h": 40 }, "_10": { "w": 24, "h": 19 }, "_11": { "w": 23, "h": 19 } }, "7": { "_1": { "w": 146, "h": 103 }, "_2": { "w": 19, "h": 82 }, "_3": { "w": 19, "h": 82 }, "_4": { "w": 100, "h": 82 }, "_5": { "w": 44, "h": 61 }, "_8": { "w": 19, "h": 19 }, "_9": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 61 }, "_7": { "w": 28, "h": 61 }, "_10": { "w": 24, "h": 19 }, "_11": { "w": 24, "h": 19 } } },
  3: { "0": { "_1": { "w": 69, "h": 103 }, "_2": { "w": 19, "h": 82 }, "_3": { "w": 19, "h": 82 }, "_4": { "w": 23, "h": 82 }, "_5": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 19 }, "_7": { "w": 19, "h": 19 } }, "1": { "_1": { "w": 69, "h": 103 }, "_2": { "w": 19, "h": 82 }, "_3": { "w": 19, "h": 82 }, "_4": { "w": 23, "h": 82 }, "_5": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 19 }, "_7": { "w": 19, "h": 19 } }, "2": { "_1": { "w": 69, "h": 103 }, "_2": { "w": 65, "h": 19 }, "_3": { "w": 65, "h": 19 }, "_4": { "w": 65, "h": 40 }, "_5": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 19 }, "_7": { "w": 19, "h": 19 } }, "3": { "_1": { "w": 69, "h": 103 }, "_2": { "w": 65, "h": 19 }, "_3": { "w": 65, "h": 19 }, "_4": { "w": 65, "h": 40 }, "_5": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 19 }, "_7": { "w": 19, "h": 19 } }, "4": { "_1": { "w": 27, "h": 145 }, "_2": { "w": 23, "h": 19 }, "_3": { "w": 23, "h": 19 }, "_4": { "w": 23, "h": 82 }, "_5": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 19 }, "_7": { "w": 19, "h": 19 } }, "5": { "_1": { "w": 130, "h": 124 }, "_2": { "w": 126, "h": 19 }, "_3": { "w": 126, "h": 19 }, "_4": { "w": 126, "h": 61 }, "_5": { "w": 44, "h": 40 }, "_8": { "w": 19, "h": 19 }, "_9": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 40 }, "_7": { "w": 54, "h": 40 }, "_10": { "w": 24, "h": 19 }, "_11": { "w": 23, "h": 19 } }, "6": { "_1": { "w": 104, "h": 145 }, "_2": { "w": 19, "h": 124 }, "_3": { "w": 19, "h": 124 }, "_4": { "w": 58, "h": 124 }, "_5": { "w": 54, "h": 40 }, "_8": { "w": 19, "h": 19 }, "_9": { "w": 19, "h": 19 }, "_6": { "w": 54, "h": 19 }, "_7": { "w": 54, "h": 40 }, "_10": { "w": 24, "h": 19 }, "_11": { "w": 23, "h": 19 } }, "7": { "_1": { "w": 146, "h": 103 }, "_2": { "w": 19, "h": 82 }, "_3": { "w": 19, "h": 82 }, "_4": { "w": 100, "h": 82 }, "_5": { "w": 44, "h": 61 }, "_8": { "w": 19, "h": 19 }, "_9": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 61 }, "_7": { "w": 28, "h": 61 }, "_10": { "w": 24, "h": 19 }, "_11": { "w": 24, "h": 19 } }, "8": { "_1": { "w": 94, "h": 166 }, "_2": { "w": 19, "h": 145 }, "_3": { "w": 19, "h": 145 }, "_4": { "w": 48, "h": 145 }, "_5": { "w": 44, "h": 40 }, "_8": { "w": 19, "h": 19 }, "_9": { "w": 19, "h": 19 }, "_6": { "w": 44, "h": 19 }, "_7": { "w": 44, "h": 61 }, "_10": { "w": 24, "h": 19 }, "_11": { "w": 24, "h": 19 } }, "9": { "_1": { "w": 23, "h": 40 }, "_2": { "w": 19, "h": 19 } }, "10": { "_1": { "w": 23, "h": 23 }, "_2": { "w": 19, "h": 19 } }, "11": { "_1": { "w": 44, "h": 40 }, "_2": { "w": 19, "h": 19 }, "_3": { "w": 19, "h": 19 } }, "12": { "_1": { "w": 23, "h": 61 }, "_2": { "w": 19, "h": 19 }, "_3": { "w": 19, "h": 19 } }, "13": { "_1": { "w": 44, "h": 23 }, "_2": { "w": 19, "h": 19 }, "_3": { "w": 19, "h": 19 } }, "14": { "_1": { "w": 111, "h": 44 }, "_2": { "w": 19, "h": 40 }, "_3": { "w": 19, "h": 40 }, "_4": { "w": 65, "h": 40 }, "_5": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 19 }, "_7": { "w": 19, "h": 19 } }, "15": { "_1": { "w": 172, "h": 82 }, "_2": { "w": 19, "h": 61 }, "_3": { "w": 19, "h": 61 }, "_4": { "w": 126, "h": 61 }, "_5": { "w": 44, "h": 40 }, "_8": { "w": 19, "h": 19 }, "_9": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 40 }, "_7": { "w": 54, "h": 40 }, "_10": { "w": 24, "h": 19 }, "_11": { "w": 23, "h": 19 } }, "16": { "_1": { "w": 172, "h": 65 }, "_2": { "w": 19, "h": 61 }, "_3": { "w": 19, "h": 61 }, "_4": { "w": 126, "h": 61 }, "_5": { "w": 44, "h": 40 }, "_8": { "w": 19, "h": 19 }, "_9": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 40 }, "_7": { "w": 54, "h": 40 }, "_10": { "w": 24, "h": 19 }, "_11": { "w": 23, "h": 19 } }, "17": { "_1": { "w": 490, "h": 23 }, "_2": { "w": 19, "h": 19 }, "_3": { "w": 19, "h": 19 }, "_4": { "w": 19, "h": 19 }, "_5": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 19 }, "_7": { "w": 19, "h": 19 }, "_8": { "w": 19, "h": 19 }, "_9": { "w": 19, "h": 19 }, "_10": { "w": 24, "h": 19 }, "_11": { "w": 23, "h": 19 }, "_12": { "w": 24, "h": 19 }, "_13": { "w": 24, "h": 19 }, "_14": { "w": 24, "h": 19 }, "_15": { "w": 24, "h": 19 }, "_16": { "w": 24, "h": 19 }, "_17": { "w": 24, "h": 19 }, "_18": { "w": 24, "h": 19 }, "_19": { "w": 24, "h": 19 }, "_20": { "w": 24, "h": 19 }, "_21": { "w": 24, "h": 19 } }, "18": { "_1": { "w": 196, "h": 40 }, "_2": { "w": 19, "h": 19 } }, "19": { "_1": { "w": 196, "h": 61 }, "_2": { "w": 19, "h": 40 }, "_3": { "w": 19, "h": 40 }, "_4": { "w": 65, "h": 40 }, "_5": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 19 }, "_7": { "w": 19, "h": 19 } }, "20": { "_1": { "w": 196, "h": 40 }, "_2": { "w": 19, "h": 19 }, "_3": { "w": 19, "h": 19 }, "_4": { "w": 19, "h": 19 } }, "21": { "_1": { "w": 27, "h": 145 }, "_2": { "w": 23, "h": 19 }, "_3": { "w": 23, "h": 19 }, "_4": { "w": 23, "h": 82 }, "_5": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 19 }, "_7": { "w": 19, "h": 19 } }, "22": { "_1": { "w": 196, "h": 103 }, "_2": { "w": 65, "h": 19 }, "_3": { "w": 65, "h": 19 }, "_4": { "w": 65, "h": 40 }, "_5": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 19 }, "_7": { "w": 19, "h": 19 } }, "23": { "_1": { "w": 196, "h": 103 }, "_2": { "w": 19, "h": 82 }, "_3": { "w": 19, "h": 82 }, "_4": { "w": 23, "h": 82 }, "_5": { "w": 19, "h": 19 }, "_6": { "w": 19, "h": 19 }, "_7": { "w": 19, "h": 19 } } },
  4: {},
  5: { "0": { "_1": { "w": 33, "h": 120 }, "_2": { "w": 19, "h": 19 } }, "1": { "_1": { "w": 104, "h": 120 }, "_2": { "w": 19, "h": 19 } } },
  6: {},
  7: { "0": { "_1": { "w": 22, "h": 46 }, "_2": { "w": 22, "h": 23 }, "_3": { "w": 22, "h": 23 } } },
};
const MAXNODES = 5;
const SHOW_FREEZER = false;
const ALLOW_CALIBRATION = false;
const KSKeys = ['action', 'actionPlus', 'all', 'best25', 'best50', 'best75', 'best100', 'emo', 'huge',
  'life', 'life50', 'lifePlus', 'nemo', 'nemo100', 'object', 'object50', 'objectPlus'];
const PERLEN_DATA_PATH = './public/PERLENDATA/';
const PERLENPATH_FRONT = './PERLENDATA/';
const HEROKU = false;
const USERNAME_SELECTION = 'random';
const UITEST = false;
const JUST_PERLEN_GAME = true;
const BRAUN = '#331606';
const ColorDict = {
  black: { c: 'black', E: 'black', D: 'schwarz' },
  blue: { c: 'blue', E: 'blue', D: 'blau' },
  BLUE: { c: '#4363d8', E: 'blue', D: 'blau' },
  BLUEGREEN: { c: BLUEGREEN, E: 'bluegreen', D: 'blaugrün' },
  blue1: { c: BLUE, E: 'blue', D: 'blau' },
  BRAUN: { c: BRAUN, E: 'brown', D: 'braun' },
  BROWN: { c: BROWN, E: 'brown', D: 'braun' },
  brown: { c: BRAUN, E: 'brown', D: 'braun' },
  deepyellow: { c: YELLOW3, E: 'yellow', D: 'gelb' },
  FIREBRICK: { c: '#800000', E: 'darkred', D: 'rotbraun' },
  gold: { c: 'gold', E: 'gold', D: 'golden' },
  green: { c: 'green', E: 'green', D: 'grün' },
  GREEN: { c: '#3cb44b', E: 'green', D: 'grün' },
  green1: { c: GREEN, E: 'green', D: 'grün' },
  grey: { c: 'grey', E: 'grey', D: 'grau' },
  lightblue: { c: LIGHTBLUE, E: 'lightblue', D: 'hellblau' },
  LIGHTBLUE: { c: '#42d4f4', E: 'lightblue', D: 'hellblau' },
  lightgreen: { c: LIGHTGREEN, E: 'lightgreen', D: 'hellgrün' },
  LIGHTGREEN: { c: '#afff45', E: 'lightgreen', D: 'hellgrün' },
  lightyellow: { c: YELLOW2, E: 'lightyellow', D: 'gelb' },
  olive: { c: OLIVE, E: 'olive', D: 'oliv' },
  OLIVE: { c: '#808000', E: 'olive', D: 'oliv' },
  orange: { c: ORANGE, E: 'orange', D: 'orange' },
  ORANGE: { c: '#f58231', E: 'orange', D: 'orange' },
  pink: { c: 'deeppink', E: 'pink', D: 'rosa' },
  purple: { c: PURPLE, E: 'purple', D: 'lila' },
  PURPLE: { c: '#911eb4', E: 'purple', D: 'lila' },
  red: { c: 'red', E: 'red', D: 'rot' },
  RED: { c: '#e6194B', E: 'red', D: 'rot' },
  red1: { c: RED, E: 'red', D: 'rot' },
  skyblue: { c: 'deepskyblue', E: 'skyblue', D: 'himmelblau' },
  teal: { c: TEAL, E: 'teal', D: 'blaugrün' },
  TEAL: { c: '#469990', E: 'teal', D: 'blaugrün' },
  violet: { c: 'indigo', E: 'violet', D: 'violett' },
  white: { c: 'white', E: 'white', D: 'weiss' },
  yellow: { c: 'yellow', E: 'yellow', D: 'gelb' },
  YELLOW: { c: '#ffe119', E: 'yellow', D: 'gelb' },
  YELLOW2: { c: YELLOW2, E: 'yellow', D: 'gelb' },
  YELLOW3: { c: YELLOW3, E: 'yellow', D: 'gelb' },
};
const GermanToEnglish = {
  rot: 'red', blau: 'blue', grün: 'green', gelb: 'yellow', violett: 'violet', lila: 'purple',
  braun: 'brown', schwarz: 'black', weiss: 'white', grau: 'grey', rosa: 'pink', orange: 'orange'
};
const DARKBLUE = '#04041b';
const NATURE = {
  depth: 6,
  branching: [-25, 5, 25],
  lsystems: [
    {
      axiom: 'A',
      rules: [
        { aus: 'A', wird: 'A+[+A-A]' },
      ],
      angle: 25,
      len: 500,
      dlen: .7,
      depth: 6
    },
    {
      axiom: 'F',
      rules: [
        { aus: 'F', wird: 'F[+F]F[-F]F' },
      ],
      angle: 26,
      len: 50,
    },
    {
      axiom: 'F',
      rules: [
        { aus: 'F', wird: 'F[+F]F[-F][F]' },
      ],
      angle: 20,
      len: 200,
    },
    {
      axiom: 'X',
      rules: [
        { aus: 'X', wird: 'F[+X][-X]FX' },
        { aus: 'F', wird: 'FF' },
      ],
      angle: 26,
      len: 200,
    },
    {
      axiom: 'A',
      rules: [{ aus: 'A', wird: 'AA+[+A-A-A]-[-A+A+A]' }],
      angle: 25,
    },
    {
      axiom: 'A',
      rules: [{ aus: 'F', wird: 'FF' }, { aus: 'A', wird: 'F-[[A]+A]+F[+FA]-A' }],
      angle: 23,
    },
    {
      axiom: 'Y',
      rules: [{ aus: 'X', wird: 'X[-FFF][+FFF]FX' }, { aus: 'Y', wird: 'YFX[+Y][-Y]' }, { aus: 'F', wird: 'X' }],
      angle: 25,
      len: 85,
    },
    {
      axiom: 'F',
      rules: [{ aus: 'F', wird: 'F[+FF][-FF]F[-F][+F]F' }],
      angle: 35,
      len: 70,
    },
    {
      axiom: 'VZFFF',
      rules: [{ aus: 'V', wird: '[+++W][---W]YV' },
      { aus: 'W', wird: '+X[-W]Z' },
      { aus: 'Y', wird: 'YZ' },
      { aus: 'F', wird: 'Y' },
      { aus: 'Z', wird: '[-FFF][+FFF]F' },
      { aus: 'X', wird: '-W[+X]Z' }],
      angle: 40,
      len: 100,
    },
    {
      axiom: 'F++F++F',
      rules: [{ aus: 'F', wird: 'F-F++F-F' }],
      angle: 60,
      len: 100,
      depth: 3,
      xstart: 3,
    },
    {
      axiom: 'F+F+F+F',
      rules: [{ aus: 'F', wird: 'FF+F+F+F+FF' }],
      angle: 90,
      len: 100,
      depth: 3,
      xstart: 6,
    },
    {
      axiom: 'F+F+F+F',
      rules: [{ aus: 'F', wird: 'F+F-F-FFF+F+F-F' }],
      angle: 90,
      len: 28,
      depth: 3,
    },
    {
      axiom: 'X',
      rules: [
        { aus: 'X', wird: '-YF+XFX+FY-' },
        { aus: 'Y', wird: '+XF-YFY-FX+' },
        { aus: 'F', wird: 'F' },
      ],
      angle: 90,
      len: 150,
      xstart: 1.3,
      depth: 4,
    },
    {
      axiom: 'X',
      rules: [{ aus: 'F', wird: 'FF' },
      { aus: 'X', wird: 'F[+X]F[-X]+X' }],
      angle: 20,
      len: 200,
    },
  ]
};
const sleep = m => new Promise(r => setTimeout(r, m))
const colorShadeX = (c, amt) => {
  let col = colorHex(c);
  col = col.replace(/^#/, '')
  if (col.length === 3) col = col[0] + col[0] + col[1] + col[1] + col[2] + col[2]
  let [r, g, b] = col.match(/.{2}/g);
  ([r, g, b] = [parseInt(r, 16) + amt, parseInt(g, 16) + amt, parseInt(b, 16) + amt])
  r = Math.max(Math.min(255, r), 0).toString(16)
  g = Math.max(Math.min(255, g), 0).toString(16)
  b = Math.max(Math.min(255, b), 0).toString(16)
  const rr = (r.length < 2 ? '0' : '') + r
  const gg = (g.length < 2 ? '0' : '') + g
  const bb = (b.length < 2 ? '0' : '') + b
  return `#${rr}${gg}${bb}`
}
const COLORPARAMNAMES = {
  bg: true,
  fg: true,
  color: true,
  'font-color': true,
  border: true,
  highlight: true,
  highlight1: true,
  highlight1: true,
}
const config = {
  src: 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/175711/open-peeps-sheet.png',
  rows: 15,
  cols: 7
}
const randomRange = (min, max) => min + Math.random() * (max - min)
const randomIndex = (array) => randomRange(0, array.length) | 0
const removeFromArray = (array, i) => array.splice(i, 1)[0]
const removeItemFromArray = (array, item) => removeFromArray(array, array.indexOf(item))
const removeRandomFromArray = (array) => removeFromArray(array, randomIndex(array))
const getRandomFromArray = (array) => (array[randomIndex(array) | 0])
const normalWalk = ({ peep, props }) => {
  const {
    startX,
    startY,
    endX
  } = props
  const xDuration = 10
  const yDuration = 0.25
  const tl = gsap.timeline()
  tl.timeScale(randomRange(0.5, 1.5))
  tl.to(peep, {
    duration: xDuration,
    x: endX,
    ease: 'none'
  }, 0)
  tl.to(peep, {
    duration: yDuration,
    repeat: xDuration / yDuration,
    yoyo: true,
    y: startY - 10
  }, 0)
  return tl
}
const walks = [
  normalWalk,
]
const img = document.createElement('img')
const INNO = {
  color: { blue: '#89aad7', red: '#da7887', green: '#72b964', yellow: '#e2e57a', purple: '#9b58ba' },
  sym: {
    tower: { key: 'white-tower', fg: 'silver', bg: 'dimgray' },
    leaf: { key: 'leaf', fg: '#96D6BE', bg: '#275D45' },
    tree: { key: 'leaf', fg: '#96D6BE', bg: '#275D45' },
    bulb: { key: 'lightbulb', fg: 'white', bg: '#69224C' },
    crown: { key: 'queen-crown', fg: '#FEE593', bg: '#A27E44' },
    factory: { key: 'i_factory', fg: '#CD5147', bg: '#6D1A12' },
    clock: { key: 'clock', fg: '#3E84B5', bg: '#0B5884' },
    none: { key: 'flamer', fg: 'silver', bg: 'dimgrey' },
    plus: { key: 'plus', fg: 'silver', bg: '#00000020' },
    fountain: { key: 'fountain', fg: 'silver', bg: '#00000020' },
    flag: { key: 'flying-flag', fg: 'silver', bg: '#00000020' },
    up: { key: 'arrow-up', fg: 'silver', bg: '#00000020' },
    left: { key: 'arrow-left', fg: 'silver', bg: '#00000020' },
    right: { key: 'arrow-right', fg: 'silver', bg: '#00000020' },
  },
  symNames: ['tower', 'tree', 'bulb', 'crown', 'factory', 'clock'],
  phases: [
    { key: 'init', message: 'select initial card to meld!' },
    { key: 'just_one_turn', message: 'take your first turn!' },
    { key: 'two_turns', message: 'take your turn!' },
  ],
  special_achievements: {
    MONUMENT: "Claim immediately if you tuck six cards or score six cards during a single turn (May also be claimed via Masonry from Age 1)",
    EMPIRE: "Claim immediately if you have three  or more icons of all six types (May also be claimed via Construction from Age 2)",
    WORLD: "Claim immediately if you have twelve or more clocks on your board (May also be claimed via Translation from Age 3)",
    WONDER: "Claim immediately if you have all five colors on your board, and each is splayed either up or right (May also be claimed via Invention from Age 4)",
    UNIVERSE: "Claim immediately if you have five top cards, and each is of value 8 or higher (May also be claimed via Astronomy from Age 5)",
    LEGEND: "Claim if you meld a city with a left arrow on a color already splayed left",
    REPUTE: "Claim if you meld a city with a right arrow on a color already splayed right",
    FAME: "Claim if you meld a city with a up arrow on a color already splayed up",
    GLORY: "Claim immediately tuck a city with a flag",
    VICTORY: "Claim immediately tuck a city with a fountain",
    SUPREMACY: "Claim immediately if you have 3 or more of one icon in 4 different colors (May also be claimed via Novel from Age 3)",
    DESTINY: "Claim immediately if you have 7 or more cards in your forecast (May also be claimed via Barometer from Age 4)",
    WEALTH: "Claim immediately if you have 8 or more bonuses (May also be claimed via Palampore from Age 5)",
    HERITAGE: "Claim immediately if you have 8 or more numbers in one color (May also be claimed via Loom from Age 6)",
    HISTORY: "Claim immediately if you have 4 or more echoes in one color (May also be claimed via Photography from Age 7)",
  },
};
const mainCOOL = () => {
  const imgFile = document.getElementById("imgfile");
  const image = new Image();
  const file = imgFile.files[0];
  const fileReader = new FileReader();
  fileReader.onload = () => {
    image.onload = () => {
      const canvas = document.getElementById("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(image, 0, 0);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const rgbArray = buildRgb(imageData.data);
      const quantColors = quantization(rgbArray, 0);
      buildPalette(quantColors);
    };
    image.src = fileReader.result;
  };
  fileReader.readAsDataURL(file);
};
const DIBOA = {
  home: { link: "../rechnung/index.html", img: 'home.png', align: 'left', pop: false },
  bill: { link: "../rechnung/index.html", img: 'bill.png', align: 'left', pop: false },
  boa: { link: "", img: 'boa.png', align: 'left', pop: false },
  bw: { link: "../rechnung/bwindex.html", img: 'bwicon.png', align: 'right', pop: true },
  authenticator: { link: "../rechnung/boaa.html", img: 'authenticator.png', align: 'right', pop: true },
  authy: { link: "../rechnung/boaa.html", img: 'authy.png', align: 'right', pop: true },
  onedrive: { link: "../rechnung/boaa.html", img: 'onedrive.png', align: 'right', pop: true },
  skype: {
    link: "../rechnung/boaa.html", img: 'skype.png', align: 'right', pop: false,
    contacts: {
      'Julia Oasis': { date: 'Wed', msg: 'Wow', color: BLUEGREEN },
      '+14778991960': { date: 'Thu', msg: 'Missed Call', color: ORANGE },
    }
  },
  bw_info: {
    boa: { userid: 'gleem@gmail.com', pwd: rPassword(20) },
    authy: { userid: 'gleem@gmail.com', pwd: rPassword(20) },
  },
  boa_data: {
    'AAA-MBNA 5464 3332 3333 5555': { sub: '*5555', logo: 'boa.png' },
    'AMERICAN EXPRESS': { sub: '*4554', logo: 'amex.png' },
    'AT&T Mobility': { sub: '*1331', logo: 'att.png' },
    'AT&T Mobility{AT&T WA}': { sub: '*7575', logo: 'att.png' },
    'AT&T Mobility': { sub: '*8585', logo: 'att.png' },
    'Bank Of Amerika Credit Card': { sub: '*1212', logo: 'boa.png', 'Last Payment': '5-25 $1150.41', brand: 'BofA_rgb' },
    'Bank Of Amerika': { sub: '*0898', logo: 'boa.png' },
    'Bank Of Amerika Mail-in1': { sub: '*6565', logo: 'boa.png' },
    'Bel-Red Oral': { sub: '*2432' },
    'Bellevue Kendo Club': { sub: '*hallo' },
    'CapitalOne': { sub: '*1324', logo: 'capitalOne.png' },
    'CapitalOneVenture': { sub: '*6456', logo: 'capitalOne.png' },
    'CapitalOneVentureF': { sub: '*9789', logo: 'capitalOne.png' },
    'Chase': { sub: '*3131', logo: 'chase.png' },
    'Chase Amazon': { sub: '*0898', 'Last Payment': '5-25 $1150.41', logo: 'chase.png', brand: 'prime' },
    'Chase Card': { sub: '*1432', logo: 'chase.png' },
    'CHASE MANHATTAN BANK-MC': { sub: '*0797', 'Last Payment': '5-25 $110.99', logo: 'chase.png', brand: 'chase_bank' },
    'Chase Sapphire': { sub: '*5132', logo: 'chase.png' },
    'Chase Sapphire': { sub: '*8679', logo: 'chase.png' },
    'City Cards': { sub: '*3124', logo: 'citi.png' },
    'City Cards Divident': { sub: '*9678', logo: 'citi.png' },
    'CITY CARDS Points': { sub: '*7678', logo: 'citi.png' },
    'Citi Costco': { sub: '*8768', 'Last Payment': '6-17 $506.14', logo: 'citi.png', brand: 'citibank' },
    'Citi Costco gu': { sub: '*0890', 'Last Payment': '6-6 $228.92', logo: 'citi.png', brand: 'citibank' },
    'CITI DIVIDENT Platinum': { sub: '*3454', logo: 'citi.png' },
    'CITIBANK VISA NV': { sub: '*7566', logo: 'citi.png' },
    'City of Redmond': { sub: '*4998' },
    'City of Redmond WA': { sub: '*2887', 'Last Payment': '5-17 $214.94', brand: 'redmond' },
    'Comcast': { sub: '*7676', logo: 'comcast.png' },
    'Comcast Perrigo': { sub: '*1324', 'Last Payment': '6-21 $89.44', logo: 'comcast.png', brand: 'comcast' },
    'ComCast WA': { sub: '*6456', logo: 'comcast.png' },
    'DISCOVER CARD SERVICES': { sub: '*8678' },
    'Dr. Ellie Tabaraie': { sub: '*hallo' },
    'Fastenerz.com': { sub: '*000' },
    'Fibonacci': { sub: '*6666' },
    'Fleet Credit Card Service': { sub: '*8798' },
    'FLEET CREDIT CARD0MC/VS (32)': { sub: '*8799' },
    'Frontier': { sub: '*05-5' },
    'Frontier2': { sub: '*5366' },
    'GoodToGo': { sub: '*7767' },
    'Hardford Mutual Funds Inc.': { sub: '*8878' },
    'King County Treasury': { sub: '*0-02' },
    'King County Treasury': { sub: '*0-03' },
    'LabCorp': { sub: '*8899' },
    'Landover Mortgage': { sub: '*hallo' },
    'Lauren Magada': { sub: 'Lauren boa' },
    'Lederman&Pulman': { sub: '*9988' },
    'Liberty Mutual Group': { sub: '*-660' },
    'Liberty Mutual Group': { sub: '*-768' },
    'Liberty Mutual Group': { sub: '*-760' },
    "Macy's Star Rewards": { sub: '*23-0', logo: 'macys.png' },
    'MBNA': { sub: '*3444' },
    'MBNA 6455 6677 7924 5555': { sub: '*5555' },
    'Oachita': { sub: '*6556' },
    'Oasis Condominium CA': { sub: '*889' },
    'Oasis Condominium CA': { sub: '*1889', 'Last Payment': '5-31 $581.54', brand: 'oasis' },
    'Orthodontics Roos': { sub: '*1111' },
    'Overcast Law Office, PS': { sub: '*4423' },
    'Overlake Medical Center': { sub: '*hallo' },
    'Pediatric Associates Inc': { sub: '*8383' },
    'Perrigo Heights HOA': { sub: '*t#98' },
    'Premier Periodontics': { sub: '*9494' },
    'PreventionMD': { sub: '*9566' },
    'Prime Trust LLC': { sub: '*8788' },
    'ProSport': { sub: '*1233' },
    'PSE - Puget Sound Energy': { sub: '*3444', 'Last Payment': '5-25 $70.59', brand: 'PSE' },
    'Puget Sound Energy': { sub: '*66-9' },
    'Real Property Management Eclipse': { sub: '*asss' },
    'Remadina Ridge Family Dentistry': { sub: '*6656' },
    'Sewage Capacity Charge': { sub: '*7575' },
    'Silkroad': { sub: '*788-1' },
    'Suhrco': { sub: '*899' },
    'Target': { sub: '*9789' },
    'Target National Bank': { sub: '*1432' },
    'Univerity Of WA Medical Center': { sub: '*1543' },
    'US Bank Credit Card FlexPerks': { sub: '*0789', 'Last Payment': '5-20 $11.13', brand: 'usbank' },
    'USBank': { sub: '*7567' },
    'USBank-CashPlus': { sub: '*3123' },
    'USBank-FlexPerks': { sub: '*1321' },
    'Verizon': { sub: '*7567' },
    'Waste Management': { sub: '*87-1' },
    'Waste Management': { sub: '*23-9' },
    'Wells Fargo Home Mortgage': { sub: '*1333', 'Last Payment': '6-10 $1625.06', logo: 'wellsfargo.png', brand: 'wellsfargo' },
    'Wells Fargo Mortgage': { sub: '*2444', logo: 'wellsfargo.png' },
    'Williams-Sonoma': { sub: '*9888' },
    'WINDERMERE PROPERTY MGMT/EASTSID': { sub: '*8766' },
    'Windermere Real Estate/East': { sub: '*ntal' },
  }
};
const stage = {
  width: 0,
  height: 0,
}
const ARI = {
  sz_hand: 7,
  stage: {
    1: 'journey',
    2: 'tax',
    3: 'auto market',
    4: 'stall selection',
    1004: 'TEST_starts_in_stall_selection_complete',
    5: 'action: command',
    6: 'action step 2',
    7: 'action 3',
    8: 'action 4',
    9: 'action 5',
    10: 'end game?',
    11: 'ball',
    12: 'auction: bid',
    13: 'auction: buy',
    14: 'complementing_market_after_church',
    15: 'commission',
    16: 'commission new',
    17: 'church',
    18: 'church_minplayer_tithe',
    19: 'church_newcards',
    20: 'payment action',
    21: 'church_minplayer_tithe_add',
    22: 'church_minplayer_tithe_downgrade',
    23: 'comm_weitergeben',
    24: 'rumors_weitergeben',
    25: 'rumor',
    26: 'blackmail',
    blackmail: 26,
    27: 'inspect',
    rumor: 25,
    28: 'buy rumor',
    'buy rumor': 28,
    29: 'rumor discard',
    30: 'pick luxury or journey cards',
    31: 'add new journey',
    32: 'rumor_both',
    33: 'blackmail_owner',
    34: 'accept_blackmail',
    35: 'blackmail_complete',
    36: 'reject_blackmail',
    37: 'commission_stall',
    38: 'pick_schwein',
    40: 'trade',
    41: 'build',
    42: 'visit',
    43: 'buy',
    44: 'upgrade',
    45: 'downgrade',
    46: 'visit destroy',
    build: 41,
    upgrade: 44,
    downgrade: 45,
    visit: 42,
    buy: 43,
    100: 'pickup end',
    101: 'build end',
    102: 'select building to upgrade',
    103: 'select downgrade cards',
    104: 'next_comm_setup_stage',
    105: 'next_rumor_setup_stage',
  }
};
const SHERIFF = {
  color: {
    legal: GREEN, //'lime',
    contraband: 'crimson',
    royal: 'orangered'
  },
  cards: {
    apples: { ksym: 'green apple', kcenter: 'red apple', label: 'apple', type: 'legal', value: 2, penalty: 2 },
    cheese: { ksym: 'cheese wedge', kcenter: 'cheese wedge', label: 'cheese', type: 'legal', value: 3, penalty: 2 },
    pineapple: { ksym: 'pineapple', kcenter: 'pineapple', label: 'pineapple', type: 'legal', value: 4, penalty: 2 },
    chicken: { ksym: 'poultry leg', kcenter: 'poultry leg', label: 'chicken', type: 'legal', value: 4, penalty: 2 },
    bread: { ksym: 'bread', kcenter: 'bread', label: 'bread', type: 'legal', value: 3, penalty: 2 },
    pepper: { ksym: 'hot pepper', kcenter: 'hot pepper', label: 'pepper', type: 'contraband', value: 6, penalty: 4 },
    mead: { ksym: 'beer mug', kcenter: 'beer mug', label: 'mead', type: 'contraband', value: 7, penalty: 4 },
    silk: { ksym: 'sari', kcenter: 'kimono', label: 'silk', type: 'contraband', value: 8, penalty: 4 },
    crossbow: { ksym: 'crossbow', kcenter: 'crossbow', label: 'crossbow', type: 'contraband', value: 9, penalty: 4 },
    chestnut: { ksym: 'chestnut', kcenter: 'chestnut', label: 'chestnut', type: 'royal', value: 4, penalty: 3 },
    pear: { ksym: 'pear', kcenter: 'pear', label: 'pear', type: 'royal', value: 6, penalty: 4 },
    pie: { ksym: 'pie', kcenter: 'pie', label: 'pie', type: 'royal', value: 6, penalty: 4 },
    squid: { ksym: 'squid', kcenter: 'squid', label: 'squid', type: 'royal', value: 9, penalty: 5 },
    shortcake: { ksym: 'shortcake', kcenter: 'shortcake', label: 'shortcake', type: 'royal', value: 9, penalty: 5 },
    grapes: { ksym: 'grapes', kcenter: 'grapes', label: 'grapes', type: 'royal', value: 9, penalty: 5 },
    pretzel: { ksym: 'pretzel', kcenter: 'pretzel', label: 'pretzel', type: 'royal', value: 9, penalty: 5 },
    baguette: { ksym: 'baguette bread', kcenter: 'baguette bread', label: 'bread', type: 'royal', value: 6, penalty: 4 },
    cherries: { ksym: 'cherries', kcenter: 'cherries', label: 'cherries', type: 'royal', value: 8, penalty: 4 },
  },
  cardtypes: {
    legal: ['apples', 'cheese', 'pineapple', 'bread'],
    contraband: ['pepper', 'mead', 'silk', 'crossbow'],
    royal: ['chestnut', 'pear', 'pie', 'shortcake', 'pretzel', 'grapes', 'baguette', 'cherries']
  },
  stage: {
    1: 'exchange',
  }
}
const EMO = {
  emoscale: {
    freedom: { list: 'joyful, empowered, loving, free', key: 'smiling face with hearts', n: 4, color: 'violet', E: 'joy', D: 'freiheit', stage: 'open heart', danger: 'arrogance', advice: 'be quiet', loc: 'airport', locd: 'flughafen', syn: 'joy,appreciation,empowerment,love', rem: 'let go' },
    zone: { list: "energetic, creative, enthusiastic, in the zone", key: 'nerd face', n: 3, color: 'indigo', E: 'energy', D: 'energie', stage: 'constant flow', danger: 'greed', advice: 'now', loc: 'airport', locd: 'flughafen', syn: 'passion', rem: 'remain watchful' },
    grateful: { list: 'peaceful, grateful, happy, playful', key: 'smiling face with halo', n: 2, color: 'blue', syn: 'eagerness,happiness', rem: 'stick to plan', E: 'energy', D: 'energie', stage: 'energy', danger: 'planlos verpuffen lassen, being overly confident', advice: 'make a plan, stick to the plan', loc: 'airport', locd: 'flughafen' },
    contentment: { list: 'calm, centered, content, trusting', key: 'relieved face', n: 1, color: 'green', rem: 'abide', E: 'serene', D: 'zufriedenheit', stage: 'gelassenheit', danger: 'passivity', advice: 'stay active', loc: 'airport', locd: 'flughafen' },
    boredom: { list: 'tired, bored, aimless, empty', key: 'slightly frowning face', n: 0, color: 'sienna', rem: 'oracle', E: 'bored', D: 'langeweile', stage: 'gelassenheit', danger: 'passivity', advice: 'stay active', loc: 'airport', locd: 'flughafen' },
    pessimism: { list: 'indecisive, confused, doubting, worried', key: 'worried face', n: -1, color: 'yellow', rem: 'last day', E: 'serene', D: 'langeweile', stage: 'gelassenheit', danger: 'passivity', advice: 'stay active', loc: 'airport', locd: 'flughafen' },
    overwhelm: { list: 'irritated, anxious, stressed, overwhelmed', key: 'anxious face with sweat', n: -2, color: 'orange', rem: 'pause', E: 'irritated', D: 'irritiert', stage: 'damage control', danger: 'losing contenance', advice: 'retreat', loc: 'airport', locd: 'flughafen' },
    blame: { list: 'impatient, resentful, blaming, angry', key: 'face with symbols on mouth', n: -3, color: 'red', syn: 'discouragement,anger,revenge', rem: 'robot', E: 'blaming', D: 'schuld zuweisend', stage: 'damage control', danger: 'toxicity', advice: 'surrender', loc: 'airport', locd: 'flughafen' },
    hatred: { list: 'ruthless, aggressive, jealous, hateful', key: 'black heart', n: -4, color: 'black', syn: 'rage,jealousy', rem: 'robot', E: 'hateful', D: 'hass', stage: 'damage control', danger: 'toxicity', advice: 'surrender', loc: 'airport', locd: 'flughafen' },
    guilt: { list: 'guilty, powerless, frozen, suicidal', key: 'cold face', n: -5, color: 'grey', syn: 'insecurity,unworthiness', rem: 'robot', E: 'guilty', D: 'wertlos', stage: 'damage control', danger: 'toxicity', advice: 'surrender', loc: 'airport', locd: 'flughafen' },
  },
  remedy: {
    sleep: { list: 'rest, close your eyes, deep breath' },
    distraction: { list: 'read, movie, docu, audiobook' },
    walk: { list: 'music, tm, library, walk' },
    babystep: { list: 'veggies, fruit, haushalt, wae, wasser, tee' },
    work: { list: 'post, box, shelf, people, todolist' },
    action: { list: 'piano, violin, game' },
    choices: { list: 'dice, todolist, openlist, choices' },
    retreat: { list: 'flight, dimension change' },
    cafe: { list: 'renew, plan' },
    inside: { list: 'watch, freeze, meditate' }
  },
  attitude: {
    disziplin: { max: 1 },
    gelassenheit: { min: 1, max: 4 },
    energie: { min: 3, max: 5 },
    ausgelassenheit: { min: 5, max: 7 },
    friede: { min: 5, max: 7 },
    freude: { min: 5, max: 7 },
    freiheit: { min: 5, max: 7 },
    liebe: { min: 5, max: 7 },
  }
};
const EMOFONTLIST = ['emoOpen', 'openmoBlack', 'segoe ui emoji', 'segoe ui symbol'];
const resetPeep = ({ stage, peep }) => {
  const direction = Math.random() > 0.5 ? 1 : -1
  const offsetY = 100 - 250 * gsap.parseEase('power2.in')(Math.random())
  const startY = stage.height - peep.height + offsetY
  let startX
  let endX
  if (direction === 1) {
    startX = -peep.width
    endX = stage.width
    peep.scaleX = 1
  } else {
    startX = stage.width + peep.width
    endX = 0
    peep.scaleX = -1
  }
  peep.x = startX
  peep.y = startY
  peep.anchorY = startY
  return {
    startX,
    startY,
    endX
  }
}
const allPeeps = []
const availablePeeps = []
const crowd = []
const CODE = {};
const CODE_VERSION = 1;
const SHOW_CODE = false;
const SHOW_CODE_DATA = false;
const Perlin = {
  PERLIN_YWRAPB: 4,
  PERLIN_YWRAP: 1 << 4,
  PERLIN_ZWRAPB: 8,
  PERLIN_ZWRAP: 1 << 8,
  PERLIN_SIZE: 4095,
  perlin_octaves: 4,
  perlin_amp_falloff: 0.5,
  scaled_cosine: i => 0.5 * (1.0 - Math.cos(i * Math.PI)),
  perlin: null,
  lastx: 0,
  speed: 0.02,
  channels: {},
}
const MyNames = ['amanda', 'angela', 'erin', 'holly', 'jan', 'karen', 'kelly', 'pam', 'phyllis', 'andy', 'creed', 'darryl', 'david', 'dwight', 'felix', 'gul', 'jim', 'kevin', 'luis', 'michael', 'nil', 'oscar', 'ryan', 'stanley', 'toby', 'wolfgang'];
const MARGIN_S = '3px 6px';
const MARGIN_M = '4px 10px';
const MARGIN_XS = '2px 4px';
const complementaryColor = color => {
  const hexColor = color.replace('#', '0x');
  return `#${('000000' + ('0xffffff' ^ hexColor).toString(16)).slice(-6)}`;
};
const immediateStart = true;
const uiHaltedMask = 1 << 0;
const beforeActivationMask = 1 << 1;
const hasClickedMask = 1 << 2;
const myDom = {
  points: {
    text: document.getElementById('points-text'),
    align: document.getElementById('points-align'),
    baseline: document.getElementById('points-baseline'),
    rotation: document.getElementById('points-rotation'),
    font: document.getElementById('points-font'),
    weight: document.getElementById('points-weight'),
    size: document.getElementById('points-size'),
    height: document.getElementById('points-height'),
    offsetX: document.getElementById('points-offset-x'),
    offsetY: document.getElementById('points-offset-y'),
    color: document.getElementById('points-color'),
    outline: document.getElementById('points-outline'),
    outlineWidth: document.getElementById('points-outline-width'),
    maxreso: document.getElementById('points-maxreso'),
  },
  lines: {
    text: document.getElementById('lines-text'),
    align: document.getElementById('lines-align'),
    baseline: document.getElementById('lines-baseline'),
    rotation: document.getElementById('lines-rotation'),
    font: document.getElementById('lines-font'),
    weight: document.getElementById('lines-weight'),
    placement: document.getElementById('lines-placement'),
    maxangle: document.getElementById('lines-maxangle'),
    overflow: document.getElementById('lines-overflow'),
    size: document.getElementById('lines-size'),
    height: document.getElementById('lines-height'),
    offsetX: document.getElementById('lines-offset-x'),
    offsetY: document.getElementById('lines-offset-y'),
    color: document.getElementById('lines-color'),
    outline: document.getElementById('lines-outline'),
    outlineWidth: document.getElementById('lines-outline-width'),
    maxreso: document.getElementById('lines-maxreso'),
  },
  polygons: {
    text: document.getElementById('polygons-text'),
    align: document.getElementById('polygons-align'),
    baseline: document.getElementById('polygons-baseline'),
    rotation: document.getElementById('polygons-rotation'),
    font: document.getElementById('polygons-font'),
    weight: document.getElementById('polygons-weight'),
    placement: document.getElementById('polygons-placement'),
    maxangle: document.getElementById('polygons-maxangle'),
    overflow: document.getElementById('polygons-overflow'),
    size: document.getElementById('polygons-size'),
    height: document.getElementById('polygons-height'),
    offsetX: document.getElementById('polygons-offset-x'),
    offsetY: document.getElementById('polygons-offset-y'),
    color: document.getElementById('polygons-color'),
    outline: document.getElementById('polygons-outline'),
    outlineWidth: document.getElementById('polygons-outline-width'),
    maxreso: document.getElementById('polygons-maxreso'),
  },
};
const getText = function (feature, resolution, dom) {
  const type = dom.text.value;
  const maxResolution = dom.maxreso.value;
  let text = feature.get('name');
  if (resolution > maxResolution) {
    text = '';
  } else if (type == 'hide') {
    text = '';
  } else if (type == 'shorten') {
    text = text.trunc(12);
  } else if (
    type == 'wrap' &&
    (!dom.placement || dom.placement.value != 'line')
  ) {
    text = stringDivider(text, 16, '\n');
  }
  return text;
};
const createTextStyle = function (feature, resolution, dom) {
  const align = dom.align.value;
  const baseline = dom.baseline.value;
  const size = dom.size.value;
  const height = dom.height.value;
  const offsetX = parseInt(dom.offsetX.value, 10);
  const offsetY = parseInt(dom.offsetY.value, 10);
  const weight = dom.weight.value;
  const placement = dom.placement ? dom.placement.value : undefined;
  const maxAngle = dom.maxangle ? parseFloat(dom.maxangle.value) : undefined;
  const overflow = dom.overflow ? dom.overflow.value == 'true' : undefined;
  const rotation = parseFloat(dom.rotation.value);
  if (dom.font.value == "'Open Sans'" && !openSansAdded) {
    const openSans = document.createElement('link');
    openSans.href = 'https://fonts.googleapis.com/css?family=Open+Sans';
    openSans.rel = 'stylesheet';
    document.head.appendChild(openSans);
    openSansAdded = true;
  }
  const font = weight + ' ' + size + '/' + height + ' ' + dom.font.value;
  const fillColor = dom.color.value;
  const outlineColor = dom.outline.value;
  const outlineWidth = parseInt(dom.outlineWidth.value, 10);
  return new Text({
    textAlign: align == '' ? undefined : align,
    textBaseline: baseline,
    font: font,
    text: getText(feature, resolution, dom),
    fill: new Fill({ color: fillColor }),
    stroke: new Stroke({ color: outlineColor, width: outlineWidth }),
    offsetX: offsetX,
    offsetY: offsetY,
    placement: placement,
    maxAngle: maxAngle,
    overflow: overflow,
    rotation: rotation,
  });
};
var currentKey = null;
var keysDown = new Array(256);
var virtKeys = false;
var AnimTimer = function () {
  this.date = new Date();
  this.lastTime = 0;
  this.currentTime = 0;
  this.start = function () {
    this.currentTime = Date.now();
  }
  this.reset = function () {
    this.currentTime = Date.now();
  }
  this.getTimeElapsed = function () {
    this.lastTime = this.currentTime;
    this.currentTime = Date.now();
    return (this.currentTime - this.lastTime);
  }
}
var ObjetoSolitario = function () {
  this.CartaDrag = new Array();
  this.ImagenDrag = new Array();
  this.Movimiento = 0;
  this.Movimientos = new Array();
  this.MovimientosAuyda = new Array();
  this.MovimientosAuydaActual = 0;
  this.Iniciar = function () {
    $("body").on("keydown", function (e) {
      if (e.ctrlKey && (String.fromCharCode(e.which) === 'z' || String.fromCharCode(e.which) === 'Z')) {
        Solitario.Deshacer(e);
      } else if (e.ctrlKey && (String.fromCharCode(e.which) === 'y' || String.fromCharCode(e.which) === 'Y')) {
        Solitario.Rehacer(e);
      } else if (String.fromCharCode(e.which) === 'n' || String.fromCharCode(e.which) === 'N') {
        Solitario.NuevoJuego();
      } else if (String.fromCharCode(e.which) === ' ') {
        Solitario.MostrarAyuda();
      }
    });
    $("ventanamenu > button:nth-child(1)").on("click", this.NuevoJuego.bind(this));
    $("ventanamenu > button:nth-child(2)").on("click", this.Deshacer.bind(this));
    $("ventanamenu > button:nth-child(3)").on("click", this.Rehacer.bind(this));
    $("ventanamenu > button:nth-child(4)").on("click", this.MostrarAyuda.bind(this));
    this.NuevoJuego();
  };
  this.MostrarAyuda = function () {
    $("Carta, Solucion, Baraja, Columna").removeAttr("ayuda1").removeAttr("ayuda2");
    var Mov = this.MovimientosAuyda[this.MovimientosAuydaActual];
    if (this.MovimientosAuydaActual === this.MovimientosAuyda.length - 1) {
      this.MovimientosAuydaActual = 0;
    } else {
      this.MovimientosAuydaActual++;
    }
    Mov.origen.attr({
      "ayuda1": "true"
    });
    Mov.destino.attr({
      "ayuda2": "true"
    });
  }
  this.NuevoJuego = function () {
    var Orden = new Array(4 * 13);
    var Baraja = Array();
    for (i = 0; i < 4; i++) {
      Baraja[i] = $("Baraja[num='" + (i + 1) + "']");
      Baraja[i].html("");
    }
    var Solucion = Array();
    for (i = 0; i < 4; i++) {
      Solucion[i] = $("Solucion[num='" + (i + 1) + "']");
      Solucion[i].html("");
    }
    var Columna = Array();
    for (i = 0; i < 7; i++) {
      Columna[i] = $("Columna[num='" + (i + 1) + "']");
      Columna[i].html("");
    }
    this.Movimiento = 0;
    this.Movimientos = [];
    var Cartas = Array();
    Contador = 0;
    for (p = 1; p < 5; p++) {
      for (v = 0; v < 13; v++) {
        Orden[Contador] = Contador;
        Cartas[Contador] = $("<Carta></Carta>")
        Cartas[Contador++].attr({
          "Palo": p,
          "Valor": v,
          "Tapada": "true"
        });
      }
    }
    for (var Rand, Tmp, i = Orden.length; i; Rand = Math.floor(Math.random() * i), Tmp = Orden[--i], Orden[i] = Orden[Rand], Orden[Rand] = Tmp);
    Contador = 0;
    for (Cols = 0; Cols < 7; Cols++) {
      Carta = Columna[Cols];
      for (i = 0; i < Cols + 1; i++) {
        Carta = Cartas[Orden[Contador++]].appendTo(Carta);
        if (i == Cols) {
          Carta.attr({
            "Tapada": "false",
            "draggable": "true"
          });
        }
        Carta.css({
          "z-index": i
        });
      }
    }
    Carta = Baraja[0];
    for (var i = Contador; i < 52; i++) {
      Carta = Cartas[Orden[i]].appendTo(Carta);
      Carta.css({
        "z-index": i - Contador
      });
    }
    Baraja[0].off("click").on("click", this.Baraja1_EventoClick.bind(this));
    $("Carta").off("mouseover").on('mouseover', this.Carta_EventoMouseOver.bind(this));
    $("Carta").off("mouseout").on('mouseout', this.Carta_EventoMouseOut.bind(this));
    $("Carta").off("dragstart").on('dragstart', this.Carta_EventoDragStart.bind(this));
    $("Carta").off("dragend").on('dragend', this.Carta_EventoDragEnd.bind(this));
    $("Carta").off("dblclick").on('dblclick', this.Carta_EventoDblClick.bind(this));
    $("Columna").off("drop").on('drop', this.Columna_EventoDrop.bind(this));
    $("Columna").off("dragover").on('dragover', this.Columna_EventoDragOver.bind(this));
    $("Solucion").off("drop").on('drop', this.Solucion_EventoDrop.bind(this));
    $("Solucion").off("dragover").on('dragover', this.Solucion_EventoDragOver.bind(this));
    this.UltimoHijo($("Columna[num=7]"));
    $("Victoria").css({
      "display": "none"
    });
    $("Derrota").css({
      "display": "none"
    });
    this.GuardarMovimiento();
  };
  this.Carta_EventoMouseOver = function (e) {
    Carta = $(e.originalEvent.currentTarget);
    if (Carta.attr("tapada") !== "true" && Carta.attr("draggable") === "true") {
      $(e.originalEvent.currentTarget).attr({
        "hover": "true"
      });
    }
    e.stopPropagation();
  };
  this.Carta_EventoMouseOut = function (e) {
    $(e.originalEvent.currentTarget).removeAttr("hover");
    e.stopPropagation();
  };
  this.Carta_EventoDblClick = function (e) {
    Carta = this.UltimoHijo($(e.originalEvent.currentTarget));
    Palo = 0;
    Valor = 0;
    for (i = 1; i < 5; i++) {
      if (this.UltimoHijo($("Solucion[num='" + i + "']")).attr("palo") == Carta.attr("palo")) {
        Valor = parseInt(this.UltimoHijo($("Solucion[num='" + i + "']")).attr("valor")) + 1;
        Palo = this.UltimoHijo($("Solucion[num='" + i + "']"));
      }
    }
    if (Palo == 0) {
      for (i = 1; i < 5; i++) {
        if (this.UltimoHijo($("Solucion[num='" + i + "']")).attr("num") == i) {
          Palo = this.UltimoHijo($("Solucion[num='" + i + "']"));
          break;
        }
      }
    }
    if (parseInt(Carta.attr("valor")) == Valor) {
      if (typeof (Carta.parent().attr("num")) === "undefined") {
        Carta.parent().attr({
          "tapada": "false",
          "draggable": "true"
        });
      }
      Carta.appendTo(this.UltimoHijo(Palo));
      Carta.removeAttr("draggable");
      this.GuardarMovimiento();
    }
    e.stopPropagation();
  };
  this.Carta_EventoDragStart = function (e) {
    this.CartaDrag = $(e.originalEvent.currentTarget);
    this.ImagenDrag = $("#ImgDrag");
    this.ImagenDrag.attr({
      "palo": this.CartaDrag.attr("palo"),
      "valor": this.CartaDrag.attr("valor")
    }).html(this.CartaDrag.html());
    this.CartaDrag.css({
      opacity: 0
    });
    OffSet = this.CartaDrag.offset();
    e.originalEvent.dataTransfer.setDragImage(this.ImagenDrag[0], e.originalEvent.clientX - OffSet.left, (e.originalEvent.clientY - OffSet.top) + $(window).scrollTop());
    e.originalEvent.dataTransfer.effectAllowed = 'move';
    e.originalEvent.dataTransfer.setData('text/html', e.originalEvent.currentTarget);
    e.stopPropagation();
  }
  this.Carta_EventoDragEnd = function (e) {
    this.CartaDrag.css({
      opacity: 1
    });
  };
  this.Baraja1_EventoClick = function (e) {
    Baraja1 = $("Baraja[num='1']");
    Baraja2 = $("Baraja[num='2']");
    if (this.UltimoHijo(Baraja1) !== Baraja1) {
      $("Baraja[num='2'] Carta[draggable]").removeAttr("draggable");
      Carta = this.UltimoHijo(Baraja1).appendTo(this.UltimoHijo(Baraja2));
      Carta.css({
        "z-index": (Cartas.length + 1)
      }).attr({
        "Tapada": "false",
        "draggable": "true"
      });
      this.GuardarMovimiento();
    } else {
      if (this.UltimoHijo(Baraja2) === Baraja2) return;
      Carta = this.UltimoHijo(Baraja2);
      while (Carta !== Baraja2) {
        Carta.appendTo(this.UltimoHijo(Baraja1)).attr({
          "Tapada": "true",
          "draggable": "false"
        });
        Carta = this.UltimoHijo(Baraja2);
      }
      this.Baraja1_EventoClick();
    }
  };
  this.Solucion_EventoDragOver = function (e) {
    e.preventDefault();
    e.stopPropagation();
    e.originalEvent.dataTransfer.dropEffect = 'move';
    return false;
  };
  this.Solucion_EventoDrop = function (e) {
    if (this.UltimoHijo(this.CartaDrag) === this.CartaDrag) {
      Solucion = this.UltimoHijo($(e.originalEvent.target));
      Valor = 0;
      if (typeof (Solucion.attr("num")) === "undefined") {
        if (Solucion.attr("palo") === this.CartaDrag.attr("palo")) {
          Valor = (parseInt(Solucion.attr("valor")) + 1);
        } else {
          Valor = -1;
        }
      }
      if (parseInt(this.CartaDrag.attr("valor")) === Valor) {
        if (typeof (this.CartaDrag.parent().attr("num")) === "undefined") {
          this.CartaDrag.parent().attr({
            "tapada": "false",
            "draggable": "true"
          });
        }
        this.CartaDrag.appendTo(Solucion);
        this.CartaDrag.removeAttr("draggable");
        this.GuardarMovimiento();
      }
    }
  };
  this.Columna_EventoDragOver = function (e) {
    e.preventDefault();
    e.stopPropagation();
    e.originalEvent.dataTransfer.dropEffect = 'move';
    return false;
  };
  this.Columna_EventoDrop = function (e) {
    var GM = false;
    if (this.CartaValida(this.CartaDrag, $(e.originalEvent.target)) == true) {
      if (this.UltimoHijo(this.CartaDrag) != this.UltimoHijo($(e.originalEvent.target))) {
        if (typeof (this.CartaDrag.parent().attr("num")) === "undefined") {
          this.CartaDrag.parent().attr({
            "tapada": "false",
            "draggable": "true"
          });
        }
        this.CartaDrag.appendTo(this.UltimoHijo($(e.originalEvent.target)));
        GM = true;
      }
      UH = this.UltimoHijo($("Baraja[num='2']"));
      $("Baraja[num='2'] Carta[draggable]").removeAttr("draggable");
      if (typeof (UH.attr("num")) === "undefined") {
        this.UltimoHijo($("Baraja[num='2']")).attr({
          "draggable": "true"
        });
      }
      if (GM === true) {
        this.GuardarMovimiento();
      }
    }
    e.preventDefault();
    e.stopPropagation();
    return false;
  };
  this.CartaValida = function (Carta, Destino) {
    if (typeof (Destino.attr("num")) !== "undefined" && parseInt(Carta.attr("valor")) === 12) {
      return true;
    }
    if (Destino.attr("tapada") === true) {
      return false;
    }
    if (parseInt(Carta.attr("valor")) === parseInt(Destino.attr("valor")) - 1) {
      if (parseInt(Carta.attr("palo")) > 2) {
        if (parseInt(Destino.attr("palo")) < 3) {
          return true;
        }
      }
      else {
        if (parseInt(Destino.attr("palo")) > 2) {
          return true;
        }
      }
    }
    return false;
  };
  this.UltimoHijo = function (nPadre) {
    Cartas = nPadre.find(":last-child");
    if (Cartas.length == 0) return nPadre;
    return $(Cartas[Cartas.length - 1]);
  };
  this.Victoria = function () {
    return ($("Columna Carta[tapada='true']").length > 0) ? false : true;
  }
  this.GuardarMovimiento = function () {
    $("Carta, Solucion, Baraja, Columna").removeAttr("ayuda1").removeAttr("ayuda2");
    var DH = [];
    DH["Baraja1"] = $("Baraja[num='1']").html();
    DH["Baraja2"] = $("Baraja[num='2']").html();
    DH["Solucion1"] = $("Solucion[num='1']").html();
    DH["Solucion2"] = $("Solucion[num='2']").html();
    DH["Solucion3"] = $("Solucion[num='3']").html();
    DH["Solucion4"] = $("Solucion[num='4']").html();
    DH["Columna1"] = $("Columna[num='1']").html();
    DH["Columna2"] = $("Columna[num='2']").html();
    DH["Columna3"] = $("Columna[num='3']").html();
    DH["Columna4"] = $("Columna[num='4']").html();
    DH["Columna5"] = $("Columna[num='5']").html();
    DH["Columna6"] = $("Columna[num='6']").html();
    DH["Columna7"] = $("Columna[num='7']").html();
    this.Movimientos[this.Movimiento++] = DH;
    $("movimientos").html(this.Movimiento - 1);
    var V = this.Victoria();
    $("Derrota").css({
      "display": (this.Ayuda() === false && V !== true) ? "block" : "none"
    });
    $("Victoria").css({
      "display": (V === true) ? "block" : "none"
    });
  };
  this.Rehacer = function (e) {
    if (this.Movimiento < this.Movimientos.length) {
      var DH = this.Movimientos[this.Movimiento++];
      $("Baraja[num='1']").html(DH["Baraja1"]);
      $("Baraja[num='2']").html(DH["Baraja2"]);
      $("Solucion[num='1']").html(DH["Solucion1"]);
      $("Solucion[num='2']").html(DH["Solucion2"]);
      $("Solucion[num='3']").html(DH["Solucion3"]);
      $("Solucion[num='4']").html(DH["Solucion4"]);
      $("Columna[num='1']").html(DH["Columna1"]);
      $("Columna[num='2']").html(DH["Columna2"]);
      $("Columna[num='3']").html(DH["Columna3"]);
      $("Columna[num='4']").html(DH["Columna4"]);
      $("Columna[num='5']").html(DH["Columna5"]);
      $("Columna[num='6']").html(DH["Columna6"]);
      $("Columna[num='7']").html(DH["Columna7"]);
      $("Carta").css({
        opacity: 1
      }).removeAttr("hover");
      $("Carta").off("mouseover").on('mouseover', this.Carta_EventoMouseOver.bind(this));
      $("Carta").off("mouseout").on('mouseout', this.Carta_EventoMouseOut.bind(this));
      $("Carta").off("dragstart").on('dragstart', this.Carta_EventoDragStart.bind(this));
      $("Carta").off("dragend").on('dragend', this.Carta_EventoDragEnd.bind(this));
      $("Carta").off("dblclick").on('dblclick', this.Carta_EventoDblClick.bind(this));
    }
    $("movimientos").html(this.Movimiento - 1);
    $("Derrota").css({
      "display": (this.Ayuda() === false) ? "block" : "none"
    });
    $("Victoria").css({
      "display": (this.Victoria() === true) ? "block" : "none"
    });
  };
  this.Deshacer = function (e) {
    if (this.Movimiento !== 1) {
      var DH = this.Movimientos[--this.Movimiento - 1];
      $("Baraja[num='1']").html(DH["Baraja1"]);
      $("Baraja[num='2']").html(DH["Baraja2"]);
      $("Solucion[num='1']").html(DH["Solucion1"]);
      $("Solucion[num='2']").html(DH["Solucion2"]);
      $("Solucion[num='3']").html(DH["Solucion3"]);
      $("Solucion[num='4']").html(DH["Solucion4"]);
      $("Columna[num='1']").html(DH["Columna1"]);
      $("Columna[num='2']").html(DH["Columna2"]);
      $("Columna[num='3']").html(DH["Columna3"]);
      $("Columna[num='4']").html(DH["Columna4"]);
      $("Columna[num='5']").html(DH["Columna5"]);
      $("Columna[num='6']").html(DH["Columna6"]);
      $("Columna[num='7']").html(DH["Columna7"]);
      $("Carta").css({
        opacity: 1
      }).removeAttr("hover");
      $("Carta").off("mouseover").on('mouseover', this.Carta_EventoMouseOver.bind(this));
      $("Carta").off("mouseout").on('mouseout', this.Carta_EventoMouseOut.bind(this));
      $("Carta").off("dragstart").on('dragstart', this.Carta_EventoDragStart.bind(this));
      $("Carta").off("dragend").on('dragend', this.Carta_EventoDragEnd.bind(this));
      $("Carta").off("dblclick").on('dblclick', this.Carta_EventoDblClick.bind(this));
      $("movimientos").html(this.Movimiento - 1);
    }
    $("Derrota").css({
      "display": (this.Ayuda() === false) ? "block" : "none"
    });
    $("Victoria").css({
      "display": (this.Victoria() === true) ? "block" : "none"
    });
  };
  this.Ayuda = function (e) {
    var Solucion = [];
    var Baraja = [];
    var Columna = [];
    Solucion[1] = this.UltimoHijo($("Solucion[num='1']"));
    Solucion[2] = this.UltimoHijo($("Solucion[num='2']"));
    Solucion[3] = this.UltimoHijo($("Solucion[num='3']"));
    Solucion[4] = this.UltimoHijo($("Solucion[num='4']"));
    Baraja[1] = this.UltimoHijo($("Baraja[num='1']"));
    Baraja[2] = this.UltimoHijo($("Baraja[num='2']"));
    Columna[1] = this.UltimoHijo($("Columna[num='1']"));
    Columna[2] = this.UltimoHijo($("Columna[num='2']"));
    Columna[3] = this.UltimoHijo($("Columna[num='3']"));
    Columna[4] = this.UltimoHijo($("Columna[num='4']"));
    Columna[5] = this.UltimoHijo($("Columna[num='5']"));
    Columna[6] = this.UltimoHijo($("Columna[num='6']"));
    Columna[7] = this.UltimoHijo($("Columna[num='7']"));
    this.MovimientosAuyda = new Array();
    this.MovimientosAuydaActual = 0;
    this.MovimientosAuyda.push({
      origen: $("Baraja[num='1']"),
      destino: $("Baraja[num='2']"),
      valor: 0
    });
    if (Baraja[2].prop("tagName") === "CARTA") {
      for (i = 1; i < 5; i++) {
        Valor = (Solucion[i].prop("tagName") === "CARTA") ? parseInt(Solucion[i].attr("valor")) : -1;
        Palo = (Solucion[i].prop("tagName") === "CARTA") ? Solucion[i].attr("palo") : Baraja[2].attr("palo");
        if (Valor + 1 === parseInt(Baraja[2].attr("valor")) && Palo === Baraja[2].attr("palo")) {
          this.MovimientosAuyda.push({
            origen: Baraja[2],
            destino: Solucion[i],
            valor: 150 - ((Valor + 1) * 10)
          });
        }
      }
    }
    for (c = 7; c > 0; c--) {
      for (i = 1; i < 5; i++) {
        Valor = (Solucion[i].prop("tagName") === "CARTA") ? parseInt(Solucion[i].attr("valor")) : -1;
        Palo = (Solucion[i].prop("tagName") === "CARTA") ? Solucion[i].attr("palo") : Columna[c].attr("palo");
        if (Valor + 1 === parseInt(Columna[c].attr("valor")) && Palo === Columna[c].attr("palo")) {
          this.MovimientosAuyda.push({
            origen: Columna[c],
            destino: Solucion[i],
            valor: 150 - ((Valor + 1) * 10)
          });
        }
      }
    }
    for (c = 7; c > 0; c--) {
      Carta = this.UltimoHijo(Columna[c]);
      if (Carta.prop("tagName") === "CARTA") {
        Padres = 1;
        do {
          for (c2 = 7; c2 > 0; c2--) {
            CC = this.UltimoHijo(Columna[c2]);
            Valor = (CC.prop("tagName") === "CARTA") ? parseInt(CC.attr("valor")) : -1;
            Palo = (CC.prop("tagName") === "CARTA") ? CC.attr("palo") : Carta.attr("palo");
            if (this.CartaValida(Carta, CC)) {
              if (Carta.parent().attr("tapada") === "true" || Carta.parent().prop("tagName") !== "CARTA") {
                if (parseInt(Carta.attr("valor")) === 12 && CC.prop("tagName") === "COLUMNA" && Carta.parent().prop("tagName") === "COLUMNA") { } else {
                  this.MovimientosAuyda.push({
                    origen: Carta,
                    destino: CC,
                    valor: 10 * Padres
                  });
                }
              }
            }
          }
          Carta = Carta.parent();
          Padres++;
        } while (Carta.attr("tapada") !== "true" && Carta.prop("tagName") === "CARTA");
      }
    }
    if (Baraja[2].prop("tagName") === "CARTA") {
      for (c = 7; c > 0; c--) {
        CC = this.UltimoHijo(Columna[c]);
        Valor = (CC.prop("tagName") === "CARTA") ? CC.attr("valor") : -1;
        Palo = (CC.prop("tagName") === "CARTA") ? CC.attr("palo") : Baraja[2].attr("palo");
        if (this.CartaValida(Baraja[2], CC)) {
          this.MovimientosAuyda.push({
            origen: Baraja[2],
            destino: CC,
            valor: 10
          });
        }
      }
    }
    this.MovimientosAuyda.sort(function (a, b) {
      var a1 = a.valor,
        b1 = b.valor;
      if (a1 === b1) return 0;
      return (a1 < b1) ? 1 : -1;
    });
    var DebugIA = $("DebugIA");
    var DebugHTML = "<ul>";
    var ValoresCartas = Array("A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K")
    for (d = 0; d < this.MovimientosAuyda.length; d++) {
      var OrigenPalo = this.MovimientosAuyda[d].origen.attr("palo");
      var OrigenValor = this.MovimientosAuyda[d].origen.attr("valor");
      var DestinoPalo = this.MovimientosAuyda[d].destino.attr("palo");
      var DestinoValor = this.MovimientosAuyda[d].destino.attr("valor");
      DebugHTML += "<li>" + "<palo num= '" + OrigenPalo + "'> " + ValoresCartas[OrigenValor] + " -&gt; " + DestinoPalo + "'> " + ValoresCartas[DestinoValor] + "</li>"
    }
    DebugHTML += "</ul>"
    DebugIA.html(DebugHTML);
    if (this.MovimientosAuyda.length === 1) {
      for (b = 1; b < 3; b++) {
        Carta = Baraja[b];
        do {
          for (c = 7; c > 0; c--) {
            if (this.CartaValida(Carta, Columna[c])) {
              return true;
            }
          }
          Carta = Carta.parent();
        } while (Carta.prop("tagName") === "CARTA");
      }
      for (b = 1; b < 3; b++) {
        Carta = Baraja[b];
        do {
          for (s = 1; s < 5; s++) {
            Valor = (Solucion[s].prop("tagName") === "CARTA") ? parseInt(Solucion[s].attr("valor")) : -1;
            Palo = (Solucion[s].prop("tagName") === "CARTA") ? Solucion[s].attr("palo") : Carta.attr("palo");
            if (Valor + 1 === parseInt(Carta.attr("valor")) && Palo === Carta.attr("palo")) {
              return true;
            }
          }
          Carta = Carta.parent();
        } while (Carta.prop("tagName") === "CARTA");
      }
      return false;
    }
    return true;
  };
};
var unitTestId = 0;
var visualStructures = {};
var UID = 0;
var PLAYER_UPDATE_BEHAVIOR = [];
var PLAYER_UPDATE_VISUALIZATION = [];
var TABLE_UPDATE_BEHAVIOR = [];
var TABLE_UPDATE_VISUALIZATION = [];
var TABLE_UPDATE = {};
var PLAYER_UPDATE = {};
const AREAS = {};
const MSCATS = { rect: 'g', g: 'g', circle: 'g', text: 'g', polygon: 'g', line: 'g', body: 'd', svg: 'd', div: 'd', p: 'd', table: 'd', button: 'd', a: 'd', span: 'd', image: 'd', paragraph: 'd', anchor: 'd' };
var UIS;
var DEFAULT_OBJECT_AREA = 'area_objects';
var DEFAULT_PLAYER_AREA = 'area_players';
var dHelp;
var TT_JUST_UPDATED = -1;
var maxZIndex = 110;
var USERNAME = 'felix';
var GAME = 'ttt';
var S = {};
var M = {};
var IdOwner;
var G = null;
var DELETED_IDS = [];
var DELETED_THIS_ROUND = [];
var ROOT = null;
var choiceCompleted = false;
var boatFilters = [];
var boatHighlighted = null;
var S_startGame = GAME;
var S_username = USERNAME;
var S_playMode = PLAYMODE;
var S_tooltips = 'OFF';
var S_openTab = 'CodeTab';
var S_useSpec = false;
var S_useBehaviors = true;
var S_boardDetection = true;
var S_defaultObjectArea = 'a_d_objects';
var S_defaultPlayerArea = 'a_d_players';
var S_autoplay = false;
var S_showEvents = false;
var S_AIThinkingTime = 30;
var S_autoplayFunction = (_g) => false;
var loggedIn = false;
var scenarioQ = [];
var scenarioRunning = false;
var symbolColors = {
  knight: 'red',
  victory_point: 'gold',
  road_building: 'dimgray',
  monopoly: 'violet',
  year_of_plenty: 'green',
};
var COND = {};
var FUNCS = {};
var colorPalette;
var allAreas = {};
var areaSubTypes = {};
var vidCache;
var mkMan = null
var allGamesC = null;
var playerConfigC = null;
var iconCharsC = null;
var c52C = null;
var testCardsC = null
var allGames = null;
var playerConfig = null;
var iconChars = null;
var c52;
var testCards = null
var defaultSpecC = null;
var userSpecC = null;
var userCodeC = null;
var initialDataC = {};
var serverDataC = null;
var defaultSpec = null
var userSpec = null;
var userCode = null;
var serverData = null;
var mappingsInitialized;
var mappingTypes;
var LOG = {};
var LOGDIVS = [];
var tupleGroups;
var prevGamePlid = null;
var prevWaitingFor = null;
var PREFERRED_CARD_HEIGHT = 0;
var magCounter = 0;
var evAddCounter = 0;
var TABLE_CREATE = {};
var PLAYER_CREATE = {};
var V = {};
var BINDINGS = {}
var logCounter = 0;
var testCounter = 100;
var bodyZoom = 1.0;
var browserZoom = Math.round(window.devicePixelRatio * 100);
var iTHEME = 0;
var WAITINGFORPLAYER = null;
var UPD = {};
var PRES = {};
var DONE = {};
var justExpand = false;
var colorDict = null;
var dragStartOffset;
var draggedElement;
var dropPosition = 'none';
var UIDCounter = 0;
var startBoats = ['93', '99', '109', '121', '124', '116', '106', '111', '116', '129'];
var allGames1 = {
  ttt: {
    name: 'TicTacToe',
    long_name: 'Tic-Tac-Toe',
    short_name: 'ttt',
    num_players: [2],
    player_names: ['Player1', 'Player2'],
  },
  s1: {
    name: 's1',
    long_name: 's1',
    short_name: 's1',
    num_players: [2, 3, 4, 5],
    player_names: ['Player1', 'Player2', 'Player3', 'Player4', 'Player5'],
  },
  starter: {
    name: 'Starter',
    long_name: 'Starter',
    short_name: 'starter',
    num_players: [2],
    player_names: ['Player1', 'Player2'],
  },
  catan: {
    name: 'Catan',
    long_name: 'The Settlers of Catan',
    short_name: 'catan',
    num_players: [3, 4],
    player_names: ['White', 'Red', 'Blue', 'Orange'],
  },
  aristocracy: {
    name: 'Aristocracy',
    long_name: 'Aristocracy',
    short_name: 'aristocracy',
    num_players: [2, 3, 4, 5],
    player_names: ['Player1', 'Player2', 'Player3', 'Player4', 'Player5'],
  }
};
var numPlayersMin = 0;
var numPlayersMax = 8;
var currentSeed;
var currentGamename;
var currentPlaymode;
var currentNumPlayers;
var joinCandidate = null;
var commandChain = [];
var firstDomLoad = null;
var gaChars;
var faKeys;
var faChars;
var DEF_LIST_TYPE = 'dom';
var DEF_ITEM_TYPE = 'dom';
var DEF_DOM_TAG = 'div';
var path2mainIds;
var PLAYMODE = 'hotseat';
var SEED = 1;
var S_useSimpleCode = false;
var S_userSettings = true;
var S_userStructures = true;
var S_userBehaviors = true;
var S_deckDetection = true;
var S_useColorHintForProperties = true;
var S_useColorHintForObjects = true;
var isPlaying = false;
var isReallyMultiplayer = false;
var prevServerData;
const VERSION = '_ui';
const CACHE_DEFAULTSPEC = false;
const CACHE_USERSPEC = false;
const CACHE_CODE = false;
var SPEC = null;
var GAMEPLID = null;
var PGAMEPLID = null;
var autoplayFunction = () => false;
var AIThinkingTime = 30;
var CLICK_TO_SELECT = true;
var USE_SETTINGS = true;
var USE_STRUCTURES = true;
var USE_BEHAVIORS = true;
var divPlayer;
var divOpps;
var iColor;
var divMain;
var FUNCTIONS = {
  instanceof: 'instanceOf',
  prop: (o, v) => isdef(o[v]),
  no_prop: (o, v) => nundef(o[v]),
  no_spec: (o, v) => false,
}
var UIROOT;
var PROTO;
var POOLS = {};
var dynSpec;
var INFO = {};
var B = {};
var serverDataUpdated;
var isTraceOn = true;
var ___enteredRecursion = 0;
var DEFS = null;
var DSPEC_PATH = '/DATA/defaultSpec';
var TEST_DIR = '01mini';
var SPEC_PATH = '/DATA/' + TEST_DIR + '/_spec';
var SERVERDATA_PATH = '/DATA/' + TEST_DIR + '/server';
const SHOW_SPEC = true;
var SHOW_RTREE = false;
var SHOW_UITREE = false;
var SHOW_OIDNODES = true;
var SHOW_DICTIONARIES = false;
var SHOW_IDS_REFS = false;
var MAX_CYCLES = 500;
var CYCLES = 0;
var sData;
var WR = {};
var T;
var TV = {};
var _audioSources = {
  incorrect1: '../base/assets/sounds/incorrect1.wav',
  incorrect3: '../base/assets/sounds/incorrect3.mp3',
  goodBye: "../base/assets/sounds/level1.wav",
  down: "../base/assets/sounds/down.mp3",
  levelComplete: "../base/assets/sounds/sound1.wav",
  rubberBand: "../base/assets/sounds/sound2.wav",
  hit: "../base/assets/sounds/hit.wav",
  mozart: "../base/assets/music/mozart_s39_4.mp3",
};
var _sndPlayer;
var _qSound;
var _idleSound = true;
var _sndCounter = 0;
var TOSound;
var _AUDIOCONTEXT;
var Markers = [];
var BlockServerSend = false;
var DragElem = null;
var DropZones = [];
var DropZoneItem = null;
var DropZoneItems = [];
var DragSource = null;
var DragSourceItem = null;
var DragSourceItems = [];
var TOFleetingMessage;
var StateDict = {};
var EmptyFunc = x => nundef(x) || x == ' ';
var Avatars = [];
var AvatarTimeout;
var LastPositionY = 0;
var LastPositionX = 0;
var MouseMoveCounter = 0;
var IsCanvasActive = false;
var StepCounter = 0;
var Toolbar;
var RecogOutput = false;
var RecogOutputError = true;
var RecogHighPriorityOutput = true;
var SpeakerOutput = false;
var MicrophoneUi;
var SessionId;
var ZMax = 0;
const MyEasing = 'cubic-bezier(1,-0.03,.86,.68)';
var DDInfo = null;
var FRUIDCounter = -1;
var ActiveButton = null;
var HistoryOfStates = {};
var PIECES = { EMPTY: 0, wP: 1, wN: 2, wB: 3, wR: 4, wQ: 5, wK: 6, bP: 7, bN: 8, bB: 9, bR: 10, bQ: 11, bK: 12 };
var BRD_SQ_NUM = 120;
var FILES = { FILE_A: 0, FILE_B: 1, FILE_C: 2, FILE_D: 3, FILE_E: 4, FILE_F: 5, FILE_G: 6, FILE_H: 7, FILE_NONE: 8 };
var RANKS = { RANK_1: 0, RANK_2: 1, RANK_3: 2, RANK_4: 3, RANK_5: 4, RANK_6: 5, RANK_7: 6, RANK_8: 7, RANK_NONE: 8 };
var COLOURS = { WHITE: 0, BLACK: 1, BOTH: 2 };
var CASTLEBIT = { WKCA: 1, WQCA: 2, BKCA: 4, BQCA: 8 };
var SQUARES = {
  A1: 21, B1: 22, C1: 23, D1: 24, E1: 25, F1: 26, G1: 27, H1: 28,
  A8: 91, B8: 92, C8: 93, D8: 94, E8: 95, F8: 96, G8: 97, H8: 98, NO_SQ: 99, OFFBOARD: 100
};
var BOOL = { FALSE: 0, TRUE: 1 };
var MAXGAMEMOVES = 2048;
var MAXPOSITIONMOVES = 256;
var MAXDEPTH = 64;
var INFINITE = 30000;
var MATE = 29000;
var PVENTRIES = 10000;
var FilesBrd = new Array(BRD_SQ_NUM);
var RanksBrd = new Array(BRD_SQ_NUM);
var START_FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
var PceChar = ".PNBRQKpnbrqk";
var SideChar = "wb-";
var RankChar = "12345678";
var FileChar = "abcdefgh";
var PieceBig = [BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE];
var PieceMaj = [BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE];
var PieceMin = [BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE];
var PieceVal = [0, 100, 325, 325, 550, 1000, 50000, 100, 325, 325, 550, 1000, 50000];
var PieceCol = [COLOURS.BOTH, COLOURS.WHITE, COLOURS.WHITE, COLOURS.WHITE, COLOURS.WHITE, COLOURS.WHITE, COLOURS.WHITE, COLOURS.BLACK, COLOURS.BLACK, COLOURS.BLACK, COLOURS.BLACK, COLOURS.BLACK, COLOURS.BLACK];
var PiecePawn = [BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE];
var PieceKnight = [BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE];
var PieceKing = [BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE];
var PieceRookQueen = [BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE];
var PieceBishopQueen = [BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE, BOOL.TRUE, BOOL.FALSE];
var PieceSlides = [BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE, BOOL.FALSE, BOOL.FALSE, BOOL.TRUE, BOOL.TRUE, BOOL.TRUE, BOOL.FALSE];
var KnDir = [-8, -19, -21, -12, 8, 19, 21, 12];
var RkDir = [-1, -10, 1, 10];
var BiDir = [-9, -11, 11, 9];
var KiDir = [-1, -10, 1, 10, -9, -11, 11, 9];
var DirNum = [0, 0, 8, 4, 4, 8, 8, 0, 8, 4, 4, 8, 8];
var PceDir = [0, 0, KnDir, BiDir, RkDir, KiDir, KiDir, 0, KnDir, BiDir, RkDir, KiDir, KiDir];
var LoopNonSlidePce = [PIECES.wN, PIECES.wK, 0, PIECES.bN, PIECES.bK, 0];
var LoopNonSlideIndex = [0, 3];
var LoopSlidePce = [PIECES.wB, PIECES.wR, PIECES.wQ, 0, PIECES.bB, PIECES.bR, PIECES.bQ, 0];
var LoopSlideIndex = [0, 4];
var PieceKeys = new Array(14 * 120);
var SideKey;
var CastleKeys = new Array(16);
var Sq120ToSq64 = new Array(BRD_SQ_NUM);
var Sq64ToSq120 = new Array(64);
var Mirror64 = [
  56, 57, 58, 59, 60, 61, 62, 63,
  48, 49, 50, 51, 52, 53, 54, 55,
  40, 41, 42, 43, 44, 45, 46, 47,
  32, 33, 34, 35, 36, 37, 38, 39,
  24, 25, 26, 27, 28, 29, 30, 31,
  16, 17, 18, 19, 20, 21, 22, 23,
  8, 9, 10, 11, 12, 13, 14, 15,
  0, 1, 2, 3, 4, 5, 6, 7
];
var Kings = [PIECES.wK, PIECES.bK];
var CastlePerm = [
  15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
  15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
  15, 13, 15, 15, 15, 12, 15, 15, 14, 15,
  15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
  15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
  15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
  15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
  15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
  15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
  15, 7, 15, 15, 15, 3, 15, 15, 11, 15,
  15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
  15, 15, 15, 15, 15, 15, 15, 15, 15, 15
];
var MFLAGEP = 0x40000
var MFLAGPS = 0x80000
var MFLAGCA = 0x1000000
var MFLAGCAP = 0x7C000
var MFLAGPROM = 0xF00000
var NOMOVE = 0
var BFGameContr = {};
var BFUserMove = {};
var BFBoard = {};
var MvvLvaValue = [0, 100, 200, 300, 400, 500, 600, 100, 200, 300, 400, 500, 600];
var MvvLvaScores = new Array(14 * 14);
var PawnTable = [
  0, 0, 0, 0, 0, 0, 0, 0,
  10, 10, 0, -10, -10, 0, 10, 10,
  5, 0, 0, 5, 5, 0, 0, 5,
  0, 0, 10, 20, 20, 10, 0, 0,
  5, 5, 5, 10, 10, 5, 5, 5,
  10, 10, 10, 20, 20, 10, 10, 10,
  20, 20, 20, 30, 30, 20, 20, 20,
  0, 0, 0, 0, 0, 0, 0, 0
];
var KnightTable = [
  0, -10, 0, 0, 0, 0, -10, 0,
  0, 0, 0, 5, 5, 0, 0, 0,
  0, 0, 10, 10, 10, 10, 0, 0,
  0, 0, 10, 20, 20, 10, 5, 0,
  5, 10, 15, 20, 20, 15, 10, 5,
  5, 10, 10, 20, 20, 10, 10, 5,
  0, 0, 5, 10, 10, 5, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0
];
var BishopTable = [
  0, 0, -10, 0, 0, -10, 0, 0,
  0, 0, 0, 10, 10, 0, 0, 0,
  0, 0, 10, 15, 15, 10, 0, 0,
  0, 10, 15, 20, 20, 15, 10, 0,
  0, 10, 15, 20, 20, 15, 10, 0,
  0, 0, 10, 15, 15, 10, 0, 0,
  0, 0, 0, 10, 10, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0
];
var RookTable = [
  0, 0, 5, 10, 10, 5, 0, 0,
  0, 0, 5, 10, 10, 5, 0, 0,
  0, 0, 5, 10, 10, 5, 0, 0,
  0, 0, 5, 10, 10, 5, 0, 0,
  0, 0, 5, 10, 10, 5, 0, 0,
  0, 0, 5, 10, 10, 5, 0, 0,
  25, 25, 25, 25, 25, 25, 25, 25,
  0, 0, 5, 10, 10, 5, 0, 0
];
var BishopPair = 30;
var SearchController = {};
var perft_leafNodes;
var BG_CARD_BACK = randomColor();
var GAME_PLAY_UI = null;
var PROJECTNAME = 'basinno';
var USELIVESERVER = false;
var START_IN_MENU = false;
var DEFAULTUSERNAME = 'gul';
var USE_LOCAL_STORAGE = true;
const CLEAR_LOCAL_STORAGE = false;
var USE_ADDONS = false;
var CURRENT_CHAT_USER = "";
var CURRENT_GAME = "";
var CURRENT_FEN = "";
var SEEN_STATUS = false;
var DA = {};
var Items = {};
var Session = {};
var Daat = {};
var FenPositionList;
var Cinno;
var Syms;
var SymKeys;
var KeySets;
var Categories;
var ByGroupSubgroup;
var Dictionary;
var WordP;
var C52;
var U = null;
var Userdata;
var Username;
var Serverdata = {};
var Live;
var DB;
var Goal;
var Selected;
var Score;
var TO = {};
var TOMain;
var TOTrial;
var TOList;
var IsAnswerCorrect;
var QContextCounter = 0;
var Pictures = [];
var aiActivated;
var auxOpen;
var GameTimer;
var STOPAUS = false;
var uiActivated = false;
var SettingsList;
var SettingsChanged;
var SelectedMenuKey;
var Settings;
var PlayerOnTurn;
var GC;
var GameCounter;
var Players;
var BestMinusState;
var BestPlusScore = -Infinity;
var BestPlusState;
var BestMinusScore = Infinity;
var F_MOVES;
var F_APPLYMOVE;
var F_UNDOMOVE;
var F_EVAL;
var DMAX;
var MAXIMIZER;
var MINIMIZER;
var SelectedMove;
var CANCEL_AI;
var F_END;
var DMM = {};
var ShapeKeys = ['hex', 'hexF', 'tri', 'triDown', 'triLeft', 'triRight'];
var PolyClips = {
  hex: 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)',
  test1: 'inset(50% 0% 100% 25% 100% 75% 50% 100% 0% 75% 0% 25% round 10px)',
  test0: 'inset(45% 0% 33% 10% round 10px)',
  hexagon: 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)',
  hexF: 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)',
  hexFlat: 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)',
  hexflat: 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)',
  tri: 'polygon(50% 0%, 100% 100%, 0% 100%)',
  triangle: 'polygon(50% 0%, 100% 100%, 0% 100%)',
  triUp: 'polygon(50% 0%, 100% 100%, 0% 100%)',
  triup: 'polygon(50% 0%, 100% 100%, 0% 100%)',
  triDown: 'polygon(0% 0%, 100% 0%, 50% 100%)',
  tridown: 'polygon(0% 0%, 100% 0%, 50% 100%)',
  triright: 'polygon(0% 0%, 100% 50%, 0% 100%)',
  triRight: 'polygon(0% 0%, 100% 50%, 0% 100%)',
  trileft: 'polygon(0% 50%, 100% 0%, 100% 100%)',
  triLeft: 'polygon(0% 50%, 100% 0%, 100% 100%)',
  splayup: 'polygon(0% 70%, 100% 70%, 100% 100%, 0% 100%)',
}
var ColorNames;
var levelKeys = ['island', 'justice star', 'materials science', 'mayan pyramid', 'medieval gate',
  'great pyramid', 'meeple', 'smart', 'stone tower', 'trophy cup', 'viking helmet',
  'flower star', 'island', 'justice star', 'materials science', 'mayan pyramid',];
var TOTicker;
var TCount;
var dScore;
var dGameTitle;
var dTable;
var dTitle;
var dLeiste;
var TESTING = false;
var TOMan;
var Speech;
var Tid;
var Tables;
var BotTicker;
var Badges = [];
var R;
var Qu;
var A;
var Fen;
var TOAnim;
var POLL_COUNTER = 0;
var Waiting_for = null;
var Autoreload = false;
var KeepSessionUser = false;
var TestList;
var TestRunning;
var TestSuiteRunning;
var TestNumber;
var CSZ = 300;
var CHEIGHT = CSZ;
var CWIDTH = CSZ * .7
var CGAP = CSZ * .05;
var OVW = 14;
var OVH = 20;
var OVD = .25;
var SUITS = 'SHDC';
var DECKS = 'br';
var NUMJOKERS = 0;
var NUMDECKS = 2;
var Aristocards;
var Dinno;
var InnoById;
var InnoByName;
var dTableShield;
var dLinks;
var dRechts;
var dOben;
var dUnten;
var dPlayerStats;
var dMessage;
var dStatus;
var dActions0;
var dActions1;
var dActions2;
var dActions3;
var dActions4;
var dActions5;
var dError;
var dActions;
const SHAPEFUNCS = { 'circle': agCircle, 'hex': agHex, 'rect': agRect, };
var ITER = 0;
var MAXITER = 200;
var FLAG_HINT_ONLY = false;
var FLAG_AI_CANCELED = false;
var GameController = {};
var VictimScore = [0, 100, 200, 300, 400, 500, 600, 100, 200, 300, 400, 500, 600];
var RookOpenFile = 10;
var RookSemiOpenFile = 5;
var QueenOpenFile = 5;
var QueenSemiOpenFile = 3;
var PawnRanksWhite = new Array(10);
var PawnRanksBlack = new Array(10);
var PawnIsolated = -10;
var PawnPassed = [0, 5, 10, 20, 35, 60, 100, 200];
var KingE = [
  -50, -10, 0, 0, 0, 0, -10, -50,
  -10, 0, 10, 10, 10, 10, 0, -10,
  0, 10, 20, 20, 20, 20, 10, 0,
  0, 10, 20, 40, 40, 20, 10, 0,
  0, 10, 20, 40, 40, 20, 10, 0,
  0, 10, 20, 20, 20, 20, 10, 0,
  -10, 0, 10, 10, 10, 10, 0, -10,
  -50, -10, 0, 0, 0, 0, -10, -50
];
var KingO = [
  0, 5, 5, -10, -10, 0, 10, 5,
  -30, -30, -30, -30, -30, -30, -30, -30,
  -50, -50, -50, -50, -50, -50, -50, -50,
  -70, -70, -70, -70, -70, -70, -70, -70,
  -70, -70, -70, -70, -70, -70, -70, -70,
  -70, -70, -70, -70, -70, -70, -70, -70,
  -70, -70, -70, -70, -70, -70, -70, -70,
  -70, -70, -70, -70, -70, -70, -70, -70
];
var ENDGAME_MAT = 1 * PieceVal[PIECES.wR] + 2 * PieceVal[PIECES.wN] + 2 * PieceVal[PIECES.wP] + PieceVal[PIECES.wK];
var domUpdate_depth;
var domUpdate_move;
var domUpdate_score;
var domUpdate_nodes;
var domUpdate_ordering;
var UserMove = {};
var MirrorFiles = [FILES.FILE_H, FILES.FILE_G, FILES.FILE_F, FILES.FILE_E, FILES.FILE_D, FILES.FILE_C, FILES.FILE_B, FILES.FILE_A];
var MirrorRanks = [RANKS.RANK_8, RANKS.RANK_7, RANKS.RANK_6, RANKS.RANK_5, RANKS.RANK_4, RANKS.RANK_3, RANKS.RANK_2, RANKS.RANK_1];
var lastIndex;
var IconSet;
var CCC = 0;
var dMain;
var ActiveChats = {};
var Step = 0;
var dCurrent = null;
var paneOpen = false;
var DELAY_PANE = 100;
var DELAY_DISAPPEAR = 100;
var DELAY_APPEAR = 100;
var Card = {};
var TestInfo = {};
var SOCKETSERVER = 'http://localhost:5000'; //geht im spital
var SERVER = 'localhost';
var Pollmode = 'auto';
var ColorDi;
var Counter = { server: 0 };
var Socket = null;
var Info;
var Turn;
var Prevturn;
var UI = {};
var Users;
var Basepath;
var dUsers;
var dGames;
var dTables;
var dLogo;
var dLoggedIn;
var dPlayerNames;
var dInstruction;
var dTableName;
var dGameControls;
var dUserControls;
var dMoveControls;
var dSubmitMove;
var C52Cards;
var Config;
var dFleetingMessage;
var Animation1;
var PrevUser = null;
var User;
var Table;
var PL;
var Z;
var FORCE_REDRAW = false;
var SelectedItem;
var SelectedColor;
var ColorThiefObject;
var FirstLoad = true;
var Clientdata = {};
var AGAME = {
  stage: {
  }
};
var WhichCorner = 0;
var W_init = 10;
var DeckA = (function () {
  //#region variables  
  var ____fontSize;
  var ___fontSize;
  var __fontSize;
  var _fontSize;
  var ticking;
  var animations = [];
  var style = document.createElement('p').style;
  var memoized = {};
  var has3d;
  var maxZ = 52;
  var displacement = 4;
  window.requestAnimationFrame || (window.requestAnimationFrame = function (cb) { setTimeout(cb, 0); });
  //#endregion
  //#region modules
  var ease = {
    linear: function linear(t) {
      return t;
    },
    quadIn: function quadIn(t) {
      return t * t;
    },
    quadOut: function quadOut(t) {
      return t * (2 - t);
    },
    quadInOut: function quadInOut(t) {
      return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    },
    cubicIn: function cubicIn(t) {
      return t * t * t;
    },
    cubicOut: function cubicOut(t) {
      return --t * t * t + 1;
    },
    cubicInOut: function cubicInOut(t) {
      return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    },
    quartIn: function quartIn(t) {
      return t * t * t * t;
    },
    quartOut: function quartOut(t) {
      return 1 - --t * t * t * t;
    },
    quartInOut: function quartInOut(t) {
      return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
    },
    quintIn: function quintIn(t) {
      return t * t * t * t * t;
    },
    quintOut: function quintOut(t) {
      return 1 + --t * t * t * t * t;
    },
    quintInOut: function quintInOut(t) {
      return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
    }
  };
  var flip = {
    deck: function deck(_deck) {
      _deck.flip = _deck.queued(flip);
      function flip(next, side) {
        var flipped = _deck.cards.filter(function (card) {
          return card.side === 'front';
        }).length / _deck.cards.length;
        _deck.cards.forEach(function (card, i) {
          card.setSide(side ? side : flipped > 0.5 ? 'back' : 'front');
        });
        next();
      }
    }
  };
  var sort = {
    deck: function deck(_deck2) {
      _deck2.sort = _deck2.queued(sort);
      function sort(next, reverse) {
        var cards = _deck2.cards;
        cards.sort(function (a, b) {
          if (reverse) {
            return a.i - b.i;
          } else {
            return b.i - a.i;
          }
        });
        cards.forEach(function (card, i) {
          card.sort(i, cards.length, function (i) {
            if (i === cards.length - 1) {
              next();
            }
          }, reverse);
        });
      }
    },
    card: function card(_card2) {
      var cardElem = _card2.elem;
      _card2.sort = function (i, len, cb, reverse) {
        var z = i / 4;
        var delay = i * 10;
        _card2.animateTo({
          delay: delay,
          duration: 400,
          x: -z,
          y: -150,
          rot: 0,
          onComplete: function onComplete() {
            cardElem.style.zIndex = i;
          }
        });
        _card2.animateTo({
          delay: delay + 500,
          duration: 400,
          x: -z,
          y: -z,
          rot: 0,
          onComplete: function onComplete() {
            cb(i);
          }
        });
      };
    }
  };
  var shuffle = {
    deck: function deck(_deck3) {
      _deck3.shuffle = _deck3.queued(shuffle);
      function shuffle(next) {
        var cards = _deck3.cards;
        ____fontSize = fontSize();
        fisherYates(cards);
        cards.forEach(function (card, i) {
          card.pos = i;
          card.shuffle(function (i) {
            if (i === cards.length - 1) {
              next();
            }
          });
        });
        return;
      }
    },
    card: function card(_card3) {
      var cardElem = _card3.elem;
      _card3.shuffle = function (cb) {
        var i = _card3.pos;
        var z = i / 4;
        var delay = i * 2;
        _card3.animateTo({
          delay: delay,
          duration: 200,
          x: plusminus(Math.random() * 40 + 20) * ____fontSize / 16,
          y: -z,
          rot: 0
        });
        _card3.animateTo({
          delay: 200 + delay,
          duration: 200,
          x: -z,
          y: -z,
          rot: 0,
          onStart: function onStart() {
            cardElem.style.zIndex = i;
          },
          onComplete: function onComplete() {
            cb(i);
          }
        });
      };
    }
  };
  var poker = {
    deck: function deck(_deck4) {
      _deck4.poker = _deck4.queued(poker);
      function poker(next) {
        var cards = _deck4.cards;
        var len = cards.length;
        __fontSize = fontSize();
        cards.slice(-5).reverse().forEach(function (card, i) {
          card.poker(i, len, function (i) {
            card.setSide('front');
            if (i === 4) {
              next();
            }
          });
        });
      }
    },
    card: function card(_card4) {
      var cardElem = _card4.elem;
      _card4.poker = function (i, len, cb) {
        var delay = i * 250;
        _card4.animateTo({
          delay: delay,
          duration: 250,
          x: Math.round((i - 2.05) * 70 * __fontSize / 16),
          y: Math.round(-110 * __fontSize / 16),
          rot: 0,
          onStart: function onStart() {
            cardElem.style.zIndex = len - 1 + i;
          },
          onComplete: function onComplete() {
            cb(i);
          }
        });
      };
    }
  };
  var pokerN = {
    deck: function deck(_deck4) {
      _deck4.pokerN = _deck4.queued(pokerN);
      function pokerN(next, num) {
        var cards = _deck4.cards;
        var len = cards.length;
        __fontSize = fontSize();
        console.log()
        cards.slice(-num).reverse().forEach(function (card, i) {
          card.pokerN(num, i, len, function (i) {
            card.setSide('front');
            if (i === num - 1) {
              next();
            }
          });
        });
      }
    },
    card: function card(_card4) {
      var cardElem = _card4.elem;
      _card4.pokerN = function (num, i, len, cb) {
        var delay = i * 250;
        _card4.animateTo({
          delay: delay,
          duration: 250,
          x: Math.round((i - (num - .8) / 2) * 70 * __fontSize / 16),
          y: Math.round(-110 * __fontSize / 16),
          rot: 0,
          onStart: function onStart() {
            cardElem.style.zIndex = len - 1 + i;
          },
          onComplete: function onComplete() {
            cb(i);
          }
        });
      };
    }
  };
  var intro = {
    deck: function deck(_deck5) {
      _deck5.intro = _deck5.queued(intro);
      function intro(next) {
        var cards = _deck5.cards;
        cards.forEach(function (card, i) {
          card.setSide('front');
          card.intro(i, function (i) {
            animationFrames(250, 0).start(function () {
              card.setSide('back');
            });
            if (i === cards.length - 1) {
              next();
            }
          });
        });
      }
    },
    card: function card(_card5) {
      var transform = prefix('transform');
      var cardElem = _card5.elem;
      _card5.intro = function (i, cb) {
        var delay = 500 + i * 10;
        var z = i / 4;
        cardElem.style[transform] = translate(-z + 'px', '-250px');
        cardElem.style.opacity = 0;
        _card5.x = -z;
        _card5.y = -250 - z;
        _card5.rot = 0;
        _card5.animateTo({
          delay: delay,
          duration: 1000,
          x: -z,
          y: -z,
          onStart: function onStart() {
            cardElem.style.zIndex = i;
          },
          onProgress: function onProgress(t) {
            cardElem.style.opacity = t;
          },
          onComplete: function onComplete() {
            cardElem.style.opacity = '';
            cb && cb(i);
          }
        });
      };
    }
  };
  var fan = {
    deck: function deck(_deck6) {
      _deck6.fan = _deck6.queued(fan);
      function fan(next) {
        var cards = _deck6.cards;
        var len = cards.length;
        _fontSize = fontSize();
        cards.forEach(function (card, i) {
          card.fan(i, len, function (i) {
            if (i === cards.length - 1) {
              next();
            }
          });
        });
      }
    },
    card: function card(_card6) {
      var cardElem = _card6.elem;
      _card6.fan = function (i, len, cb) {
        var z = i / 4;
        var delay = i * 10;
        var rot = i / (len - 1) * 260 - 130;
        _card6.animateTo({
          delay: delay,
          duration: 300,
          x: -z,
          y: -z,
          rot: 0
        });
        _card6.animateTo({
          delay: 300 + delay,
          duration: 300,
          x: Math.cos(deg2rad(rot - 90)) * 55 * _fontSize / 16,
          y: Math.sin(deg2rad(rot - 90)) * 55 * _fontSize / 16,
          rot: rot,
          onStart: function onStart() {
            cardElem.style.zIndex = i;
          },
          onComplete: function onComplete() {
            cb(i);
          }
        });
      };
    }
  };
  var bysuit = {
    deck: function deck(_deck7) {
      _deck7.bysuit = _deck7.queued(bysuit);
      function bysuit(next) {
        var cards = _deck7.cards;
        ___fontSize = fontSize();
        cards.forEach(function (card) {
          card.bysuit(function (i) {
            if (i === cards.length - 1) {
              next();
            }
          });
        });
      }
    },
    card: function card(_card7) {
      var rank = _card7.rank;
      var suit = _card7.suit;
      _card7.bysuit = function (cb) {
        var i = _card7.i;
        var delay = i * 10;
        _card7.animateTo({
          delay: delay,
          duration: 400,
          x: -Math.round((6.75 - rank) * 8 * ___fontSize / 16),
          y: -Math.round((1.5 - suit) * 92 * ___fontSize / 16),
          rot: 0,
          onComplete: function onComplete() {
            cb(i);
          }
        });
      };
    }
  };
  //#endregion
  //#region helpers
  function createElement(type) {
    return document.createElement(type);
  }
  function addListener(target, name, listener) {
    target.addEventListener(name, listener);
  }
  function removeListener(target, name, listener) {
    target.removeEventListener(name, listener);
  }
  function plusminus(value) {
    var plusminus = Math.round(Math.random()) ? -1 : 1;
    return plusminus * value;
  }
  function fisherYates(array) {
    var rnd, temp;
    for (var i = array.length - 1; i; i--) {
      rnd = Math.random() * i | 0;
      temp = array[i];
      array[i] = array[rnd];
      array[rnd] = temp;
    }
    return array;
  }
  function fontSize() {
    return window.getComputedStyle(document.body).getPropertyValue('font-size').slice(0, -2);
  }
  function deg2rad(degrees) {
    return degrees * Math.PI / 180;
  }
  function queue(target) {
    var array = Array.prototype;
    var queueing = [];
    target.queue = queue;
    target.queued = queued;
    return target;
    function queued(action) {
      return function () {
        var self = this;
        var args = arguments;
        queue(function (next) {
          action.apply(self, array.concat.apply(next, args));
        });
      };
    }
    function queue(action) {
      if (!action) {
        return;
      }
      queueing.push(action);
      if (queueing.length === 1) {
        next();
      }
    }
    function next() {
      queueing[0](function (err) {
        if (err) {
          throw err;
        }
        queueing = queueing.slice(1);
        if (queueing.length) {
          next();
        }
      });
    }
  }
  function observable(target) {
    target || (target = {});
    var listeners = {};
    target.on = on;
    target.one = one;
    target.off = off;
    target.trigger = trigger;
    return target;
    function on(name, cb, ctx) {
      listeners[name] || (listeners[name] = []);
      listeners[name].push({ cb: cb, ctx: ctx });
    }
    function one(name, cb, ctx) {
      listeners[name] || (listeners[name] = []);
      listeners[name].push({
        cb: cb, ctx: ctx, once: true
      });
    }
    function trigger(name) {
      var self = this;
      var args = Array.prototype.slice(arguments, 1);
      var currentListeners = listeners[name] || [];
      currentListeners.filter(function (listener) {
        listener.cb.apply(self, args);
        return !listener.once;
      });
    }
    function off(name, cb) {
      if (!name) {
        listeners = {};
        return;
      }
      if (!cb) {
        listeners[name] = [];
        return;
      }
      listeners[name] = listeners[name].filter(function (listener) {
        return listener.cb !== cb;
      });
    }
  }
  function animationFrames(delay, duration) {
    var now = Date.now();
    var start = now + delay;
    var end = start + duration;
    var animation = {
      start: start,
      end: end
    };
    animations.push(animation);
    if (!ticking) {
      ticking = true;
      requestAnimationFrame(tick);
    }
    var self = {
      start: function start(cb) {
        animation.startcb = cb;
        return self;
      },
      progress: function progress(cb) {
        animation.progresscb = cb;
        return self;
      },
      end: function end(cb) {
        animation.endcb = cb;
        return self;
      }
    };
    return self;
  }
  function tick() {
    var now = Date.now();
    if (!animations.length) {
      ticking = false;
      return;
    }
    for (var i = 0, animation; i < animations.length; i++) {
      animation = animations[i];
      if (now < animation.start) {
        continue;
      }
      if (!animation.started) {
        animation.started = true;
        animation.startcb && animation.startcb();
      }
      var t = (now - animation.start) / (animation.end - animation.start);
      animation.progresscb && animation.progresscb(t < 1 ? t : 1);
      if (now > animation.end) {
        animation.endcb && animation.endcb();
        animations.splice(i--, 1);
        continue;
      }
    }
    requestAnimationFrame(tick);
  }
  function prefix(param) {
    if (typeof memoized[param] !== 'undefined') {
      return memoized[param];
    }
    if (typeof style[param] !== 'undefined') {
      memoized[param] = param;
      return param;
    }
    var camelCase = param[0].toUpperCase() + param.slice(1);
    var prefixes = ['webkit', 'moz', 'Moz', 'ms', 'o'];
    var test;
    for (var i = 0, len = prefixes.length; i < len; i++) {
      test = prefixes[i] + camelCase;
      if (typeof style[test] !== 'undefined') {
        memoized[param] = test;
        return test;
      }
    }
  }
  function translate(a, b, c) {
    typeof has3d !== 'undefined' || (has3d = check3d());
    c = c || 0;
    if (has3d) {
      return 'translate3d(' + a + ', ' + b + ', ' + c + ')';
    } else {
      return 'translate(' + a + ', ' + b + ')';
    }
  }
  function check3d() {
    // http://julian.com/research/velocity/
    var isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    if (!isMobile) {
      return false;
    }
    var transform = prefix('transform');
    var $p = document.createElement('p');
    document.body.appendChild($p);
    $p.style[transform] = 'translate3d(1px,1px,1px)';
    has3d = $p.style[transform];
    has3d = has3d != null && has3d.length && has3d !== 'none';
    document.body.removeChild($p);
    return has3d;
  }
  function iToSuit52(suit) {
    return suit === 0 ? 'spades' : suit === 1 ? 'hearts' : suit === 2 ? 'clubs' : suit === 3 ? 'diamonds' : 'joker';
  }
  //#endregion
  function _card(i, text = '') {
    var transform = prefix('transform');
    var rank = i % 13 + 1;
    var suit = i / 13 | 0;
    var z = (52 - i) / displacement;
    var elem = createElement('div');
    var faceElem = createElement('div');
    var backElem = createElement('div');
    var isDraggable = false;
    var isFlippable = false;
    var self = {
      text: text, i: i, rank: rank, suit: suit, pos: i, elem: elem,
      mount: mount, unmount: unmount, setSide: setSide
    };
    var modules = DeckA.modules;
    var module;
    faceElem.classList.add('face');
    backElem.classList.add('back');
    elem.style[transform] = translate(-z + 'px', -z + 'px');
    self.x = -z;
    self.y = -z;
    self.z = z;
    self.rot = 0;
    self.setSide('back');
    addListener(elem, 'mousedown', onMousedown);
    addListener(elem, 'touchstart', onMousedown);
    for (module in modules) {
      addModule(modules[module]);
    }
    self.animateTo = function (params) {
      var delay = params.delay;
      var duration = params.duration;
      var _params$x = params.x;
      var x = _params$x === undefined ? self.x : _params$x;
      var _params$y = params.y;
      var y = _params$y === undefined ? self.y : _params$y;
      var _params$rot = params.rot;
      var rot = _params$rot === undefined ? self.rot : _params$rot;
      var ease$$ = params.ease;
      var onStart = params.onStart;
      var onProgress = params.onProgress;
      var onComplete = params.onComplete;
      var startX, startY, startRot;
      var diffX, diffY, diffRot;
      animationFrames(delay, duration).start(function () {
        startX = self.x || 0;
        startY = self.y || 0;
        startRot = self.rot || 0;
        onStart && onStart();
      }).progress(function (t) {
        var et = ease[ease$$ || 'cubicInOut'](t);
        diffX = x - startX;
        diffY = y - startY;
        diffRot = rot - startRot;
        onProgress && onProgress(t, et);
        self.x = startX + diffX * et;
        self.y = startY + diffY * et;
        self.rot = startRot + diffRot * et;
        elem.style[transform] = translate(self.x + 'px', self.y + 'px') + (diffRot ? 'rotate(' + self.rot + 'deg)' : '');
      }).end(function () {
        onComplete && onComplete();
      });
    };
    self.setRankSuit = function (rank, suit) {
      elem.setAttribute('class', 'card blank')
      faceElem.style.fontSize = '8px';
      faceElem.innerHTML = 'hallo das ist eine wundeschoene catan karte!';
    };
    self.setText = function (text = 'hallo das ist eine wundeschoene catan karte!') {
      elem.setAttribute('class', 'card blank')
      faceElem.innerHTML = text;
    };
    self.setRankSuit(rank, suit);
    self.enableDragging = function () {
      if (isDraggable) {
        return;
      }
      isDraggable = true;
      elem.style.cursor = 'move';
    };
    self.enableFlipping = function () {
      if (isFlippable) {
        return;
      }
      isFlippable = true;
    };
    self.disableFlipping = function () {
      if (!isFlippable) {
        return;
      }
      isFlippable = false;
    };
    self.disableDragging = function () {
      if (!isDraggable) {
        return;
      }
      isDraggable = false;
      elem.style.cursor = '';
    };
    return self;
    function addModule(module) {
      module.card && module.card(self);
    }
    function onMousedown(e) {
      var startPos = {};
      var pos = {};
      var starttime = Date.now();
      e.preventDefault();
      if (e.type === 'mousedown') {
        startPos.x = pos.x = e.clientX;
        startPos.y = pos.y = e.clientY;
        addListener(window, 'mousemove', onMousemove);
        addListener(window, 'mouseup', onMouseup);
      } else {
        startPos.x = pos.x = e.touches[0].clientX;
        startPos.y = pos.y = e.touches[0].clientY;
        addListener(window, 'touchmove', onMousemove);
        addListener(window, 'touchend', onMouseup);
      }
      if (!isDraggable) {
        return;
      }
      elem.style[transform] = translate(self.x + 'px', self.y + 'px') + (self.rot ? ' rotate(' + self.rot + 'deg)' : '');
      elem.style.zIndex = maxZ++;
      function onMousemove(e) {
        if (!isDraggable) {
          return;
        }
        if (e.type === 'mousemove') {
          pos.x = e.clientX;
          pos.y = e.clientY;
        } else {
          pos.x = e.touches[0].clientX;
          pos.y = e.touches[0].clientY;
        }
        elem.style[transform] = translate(Math.round(self.x + pos.x - startPos.x) + 'px', Math.round(self.y + pos.y - startPos.y) + 'px') + (self.rot ? ' rotate(' + self.rot + 'deg)' : '');
      }
      function onMouseup(e) {
        if (isFlippable && Date.now() - starttime < 200) {
          self.setSide(self.side === 'front' ? 'back' : 'front');
        }
        if (e.type === 'mouseup') {
          removeListener(window, 'mousemove', onMousemove);
          removeListener(window, 'mouseup', onMouseup);
        } else {
          removeListener(window, 'touchmove', onMousemove);
          removeListener(window, 'touchend', onMouseup);
        }
        if (!isDraggable) {
          return;
        }
        self.x = self.x + pos.x - startPos.x;
        self.y = self.y + pos.y - startPos.y;
      }
    }
    function mount(target) {
      target.appendChild(elem);
      self.dCard = target;
    }
    function unmount() {
      self.dCard && self.dCard.removeChild(elem);
      self.dCard = null;
    }
    function setSide(newSide) {
      if (newSide === 'front') {
        if (self.side === 'back') {
          elem.removeChild(backElem);
        }
        self.side = 'front';
        elem.appendChild(faceElem);
        self.setRankSuit(self.rank, self.suit);
      } else {
        if (self.side === 'front') {
          elem.removeChild(faceElem);
        }
        self.side = 'back';
        elem.appendChild(backElem);
        elem.setAttribute('class', 'card');
      }
    }
  }
  function DeckA(jokers) {
    var cards = new Array(jokers ? 55 : 52);
    var deckElem = createElement('div');
    var self = observable({ mount: mount, unmount: unmount, cards: cards, elem: deckElem });
    var dDeck;
    var modules = DeckA.modules;
    var module;
    queue(self);
    for (module in modules) {
      addModule(modules[module]);
    }
    deckElem.classList.add('deck');
    var card;
    for (var i = cards.length; i; i--) {
      card = cards[i - 1] = _card(i - 1);
      card.setSide('back');
      card.mount(deckElem);
    }
    return self;
    function mount(root) {
      dDeck = root;
      dDeck.appendChild(deckElem);
    }
    function unmount() {
      dDeck.removeChild(deckElem);
    }
    function addModule(module) {
      module.deck && module.deck(self);
    }
  }
  DeckA.animationFrames = animationFrames;
  DeckA.ease = ease;
  DeckA.modules = { bysuit: bysuit, fan: fan, intro: intro, poker: poker, pokerN: pokerN, shuffle: shuffle, sort: sort, flip: flip };
  DeckA.Card = _card;
  DeckA.prefix = prefix;
  DeckA.translate = translate;
  return DeckA;
})();
var bSort = document.createElement('button')
var bShuffle = document.createElement('button')
var bBySuit = document.createElement('button')
var bFan = document.createElement('button')
var bPoker = document.createElement('button')
var bFlip = document.createElement('button')
var bDeal = document.createElement('button')
var currentDeck;
var dummyString = "translateX(-50%) scale(1.2)";
var DeckB = (function () {
  //#region variables  
  let ____fontSize;
  let ___fontSize;
  let __fontSize;
  let _fontSize;
  let ticking;
  let animations = [];
  let style = document.createElement('p').style;
  let memoized = {};
  let has3d;
  let maxZ = 52;
  let displacement = 4;
  let _deckParams = {};
  window.requestAnimationFrame || (window.requestAnimationFrame = function (cb) { setTimeout(cb, 0); });
  //#endregion
  //#region modules
  var ease = {
    linear: function linear(t) {
      return t;
    },
    quadIn: function quadIn(t) {
      return t * t;
    },
    quadOut: function quadOut(t) {
      return t * (2 - t);
    },
    quadInOut: function quadInOut(t) {
      return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    },
    cubicIn: function cubicIn(t) {
      return t * t * t;
    },
    cubicOut: function cubicOut(t) {
      return --t * t * t + 1;
    },
    cubicInOut: function cubicInOut(t) {
      return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    },
    quartIn: function quartIn(t) {
      return t * t * t * t;
    },
    quartOut: function quartOut(t) {
      return 1 - --t * t * t * t;
    },
    quartInOut: function quartInOut(t) {
      return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
    },
    quintIn: function quintIn(t) {
      return t * t * t * t * t;
    },
    quintOut: function quintOut(t) {
      return 1 + --t * t * t * t * t;
    },
    quintInOut: function quintInOut(t) {
      return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
    }
  };
  var flip = {
    deck: function deck(_deck) {
      _deck.flip = _deck.queued(flip);
      function flip(next, side) {
        var flipped = _deck.cards.filter(function (card) {
          return card.side === 'front';
        }).length / _deck.cards.length;
        _deck.cards.forEach(function (card, i) {
          card.setSide(side ? side : flipped > 0.5 ? 'back' : 'front');
        });
        next();
      }
    }
  };
  var sort = {
    deck: function deck(_deck2) {
      _deck2.sort = _deck2.queued(sort);
      function sort(next, reverse) {
        var cards = _deck2.cards;
        cards.sort(function (a, b) {
          if (reverse) {
            return a.i - b.i;
          } else {
            return b.i - a.i;
          }
        });
        cards.forEach(function (card, i) {
          card.sort(i, cards.length, function (i) {
            if (i === cards.length - 1) {
              next();
            }
          }, reverse);
        });
      }
    },
    card: function card(_card2) {
      var cardElem = _card2.elem;
      _card2.sort = function (i, len, cb, reverse) {
        var z = i / 4;
        var delay = i * 10;
        _card2.animateTo({
          delay: delay,
          duration: 400,
          x: -z,
          y: -150,
          rot: 0,
          onComplete: function onComplete() {
            cardElem.style.zIndex = i;
          }
        });
        _card2.animateTo({
          delay: delay + 500,
          duration: 400,
          x: -z,
          y: -z,
          rot: 0,
          onComplete: function onComplete() {
            cb(i);
          }
        });
      };
    }
  };
  var shuffle = {
    deck: function deck(_deck3) {
      _deck3.shuffle = _deck3.queued(shuffle);
      function shuffle(next) {
        var cards = _deck3.cards;
        ____fontSize = fontSize();
        fisherYates(cards);
        cards.forEach(function (card, i) {
          card.pos = i;
          card.shuffle(function (i) {
            if (i === cards.length - 1) {
              next();
            }
          });
        });
        return;
      }
    },
    card: function card(_card3) {
      var cardElem = _card3.elem;
      _card3.shuffle = function (cb) {
        var i = _card3.pos;
        var z = i / 4;
        var delay = i * 2;
        _card3.animateTo({
          delay: delay,
          duration: 200,
          x: plusminus(Math.random() * 40 + 20) * ____fontSize / 16,
          y: -z,
          rot: 0
        });
        _card3.animateTo({
          delay: 200 + delay,
          duration: 200,
          x: -z,
          y: -z,
          rot: 0,
          onStart: function onStart() {
            cardElem.style.zIndex = i;
          },
          onComplete: function onComplete() {
            cb(i);
          }
        });
      };
    }
  };
  var poker = {
    deck: function deck(_deck4) {
      _deck4.poker = _deck4.queued(poker);
      function poker(next) {
        var cards = _deck4.cards;
        var len = cards.length;
        __fontSize = fontSize();
        cards.slice(-5).reverse().forEach(function (card, i) {
          card.poker(i, len, function (i) {
            card.setSide('front');
            if (i === 4) {
              next();
            }
          });
        });
      }
    },
    card: function card(_card4) {
      var cardElem = _card4.elem;
      _card4.poker = function (i, len, cb) {
        var delay = i * 250;
        _card4.animateTo({
          delay: delay,
          duration: 250,
          x: Math.round((i - 2.05) * 70 * __fontSize / 16),
          y: Math.round(-110 * __fontSize / 16),
          rot: 0,
          onStart: function onStart() {
            cardElem.style.zIndex = len - 1 + i;
          },
          onComplete: function onComplete() {
            cb(i);
          }
        });
      };
    }
  };
  var intro = {
    deck: function deck(_deck5) {
      _deck5.intro = _deck5.queued(intro);
      function intro(next) {
        var cards = _deck5.cards;
        cards.forEach(function (card, i) {
          card.setSide('front');
          card.intro(i, function (i) {
            animationFrames(250, 0).start(function () {
              card.setSide('back');
            });
            if (i === cards.length - 1) {
              next();
            }
          });
        });
      }
    },
    card: function card(_card5) {
      var transform = prefix('transform');
      var cardElem = _card5.elem;
      _card5.intro = function (i, cb) {
        var delay = 500 + i * 10;
        var z = i / 4;
        cardElem.style[transform] = translate(-z + 'px', '-250px');
        cardElem.style.opacity = 0;
        _card5.x = -z;
        _card5.y = -250 - z;
        _card5.rot = 0;
        _card5.animateTo({
          delay: delay,
          duration: 1000,
          x: -z,
          y: -z,
          onStart: function onStart() {
            cardElem.style.zIndex = i;
          },
          onProgress: function onProgress(t) {
            cardElem.style.opacity = t;
          },
          onComplete: function onComplete() {
            cardElem.style.opacity = '';
            cb && cb(i);
          }
        });
      };
    }
  };
  var fan = {
    deck: function deck(_deck6) {
      _deck6.fan = _deck6.queued(fan);
      function fan(next) {
        var cards = _deck6.cards;
        var len = cards.length;
        _fontSize = fontSize();
        cards.forEach(function (card, i) {
          card.fan(i, len, function (i) {
            if (i === cards.length - 1) {
              next();
            }
          });
        });
      }
    },
    card: function card(_card6) {
      var cardElem = _card6.elem;
      _card6.fan = function (i, len, cb) {
        var z = i / 4;
        var delay = i * 10;
        var rot = i / (len - 1) * 260 - 130;
        _card6.animateTo({
          delay: delay,
          duration: 300,
          x: -z,
          y: -z,
          rot: 0
        });
        _card6.animateTo({
          delay: 300 + delay,
          duration: 300,
          x: Math.cos(deg2rad(rot - 90)) * 55 * _fontSize / 16,
          y: Math.sin(deg2rad(rot - 90)) * 55 * _fontSize / 16,
          rot: rot,
          onStart: function onStart() {
            cardElem.style.zIndex = i;
          },
          onComplete: function onComplete() {
            cb(i);
          }
        });
      };
    }
  };
  var bysuit = {
    deck: function deck(_deck7) {
      _deck7.bysuit = _deck7.queued(bysuit);
      function bysuit(next) {
        var cards = _deck7.cards;
        ___fontSize = fontSize();
        cards.forEach(function (card) {
          card.bysuit(function (i) {
            if (i === cards.length - 1) {
              next();
            }
          });
        });
      }
    },
    card: function card(_card7) {
      var rank = _card7.rank;
      var suit = _card7.suit;
      _card7.bysuit = function (cb) {
        var i = _card7.i;
        var delay = i * 10;
        _card7.animateTo({
          delay: delay,
          duration: 400,
          x: -Math.round((6.75 - rank) * 8 * ___fontSize / 16),
          y: -Math.round((1.5 - suit) * 92 * ___fontSize / 16),
          rot: 0,
          onComplete: function onComplete() {
            cb(i);
          }
        });
      };
    }
  };
  //#endregion
  //#region helpers
  function createElement(type) {
    return document.createElement(type);
  }
  function addListener(target, name, listener) {
    target.addEventListener(name, listener);
  }
  function removeListener(target, name, listener) {
    target.removeEventListener(name, listener);
  }
  function plusminus(value) {
    var plusminus = Math.round(Math.random()) ? -1 : 1;
    return plusminus * value;
  }
  function fisherYates(array) {
    var rnd, temp;
    for (var i = array.length - 1; i; i--) {
      rnd = Math.random() * i | 0;
      temp = array[i];
      array[i] = array[rnd];
      array[rnd] = temp;
    }
    return array;
  }
  function fontSize() {
    return window.getComputedStyle(document.body).getPropertyValue('font-size').slice(0, -2);
  }
  function deg2rad(degrees) {
    return degrees * Math.PI / 180;
  }
  function queue(target) {
    var array = Array.prototype;
    var queueing = [];
    target.queue = queue;
    target.queued = queued;
    return target;
    function queued(action) {
      return function () {
        var self = this;
        var args = arguments;
        queue(function (next) {
          action.apply(self, array.concat.apply(next, args));
        });
      };
    }
    function queue(action) {
      if (!action) {
        return;
      }
      queueing.push(action);
      if (queueing.length === 1) {
        next();
      }
    }
    function next() {
      queueing[0](function (err) {
        if (err) {
          throw err;
        }
        queueing = queueing.slice(1);
        if (queueing.length) {
          next();
        }
      });
    }
  }
  function observable(target) {
    target || (target = {});
    var listeners = {};
    target.on = on;
    target.one = one;
    target.off = off;
    target.trigger = trigger;
    return target;
    function on(name, cb, ctx) {
      listeners[name] || (listeners[name] = []);
      listeners[name].push({ cb: cb, ctx: ctx });
    }
    function one(name, cb, ctx) {
      listeners[name] || (listeners[name] = []);
      listeners[name].push({
        cb: cb, ctx: ctx, once: true
      });
    }
    function trigger(name) {
      var self = this;
      var args = Array.prototype.slice(arguments, 1);
      var currentListeners = listeners[name] || [];
      currentListeners.filter(function (listener) {
        listener.cb.apply(self, args);
        return !listener.once;
      });
    }
    function off(name, cb) {
      if (!name) {
        listeners = {};
        return;
      }
      if (!cb) {
        listeners[name] = [];
        return;
      }
      listeners[name] = listeners[name].filter(function (listener) {
        return listener.cb !== cb;
      });
    }
  }
  function animationFrames(delay, duration) {
    var now = Date.now();
    var start = now + delay;
    var end = start + duration;
    var animation = {
      start: start,
      end: end
    };
    animations.push(animation);
    if (!ticking) {
      ticking = true;
      requestAnimationFrame(tick);
    }
    var self = {
      start: function start(cb) {
        animation.startcb = cb;
        return self;
      },
      progress: function progress(cb) {
        animation.progresscb = cb;
        return self;
      },
      end: function end(cb) {
        animation.endcb = cb;
        return self;
      }
    };
    return self;
  }
  function tick() {
    var now = Date.now();
    if (!animations.length) {
      ticking = false;
      return;
    }
    for (var i = 0, animation; i < animations.length; i++) {
      animation = animations[i];
      if (now < animation.start) {
        continue;
      }
      if (!animation.started) {
        animation.started = true;
        animation.startcb && animation.startcb();
      }
      var t = (now - animation.start) / (animation.end - animation.start);
      animation.progresscb && animation.progresscb(t < 1 ? t : 1);
      if (now > animation.end) {
        animation.endcb && animation.endcb();
        animations.splice(i--, 1);
        continue;
      }
    }
    requestAnimationFrame(tick);
  }
  function prefix(param) {
    if (typeof memoized[param] !== 'undefined') {
      return memoized[param];
    }
    if (typeof style[param] !== 'undefined') {
      memoized[param] = param;
      return param;
    }
    var camelCase = param[0].toUpperCase() + param.slice(1);
    var prefixes = ['webkit', 'moz', 'Moz', 'ms', 'o'];
    var test;
    for (var i = 0, len = prefixes.length; i < len; i++) {
      test = prefixes[i] + camelCase;
      if (typeof style[test] !== 'undefined') {
        memoized[param] = test;
        return test;
      }
    }
  }
  function translate(a, b, c) {
    typeof has3d !== 'undefined' || (has3d = check3d());
    c = c || 0;
    if (has3d) {
      return 'translate3d(' + a + ', ' + b + ', ' + c + ')';
    } else {
      return 'translate(' + a + ', ' + b + ')';
    }
  }
  function check3d() {
    // http://julian.com/research/velocity/
    var isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    if (!isMobile) {
      return false;
    }
    var transform = prefix('transform');
    var $p = document.createElement('p');
    document.body.appendChild($p);
    $p.style[transform] = 'translate3d(1px,1px,1px)';
    has3d = $p.style[transform];
    has3d = has3d != null && has3d.length && has3d !== 'none';
    document.body.removeChild($p);
    return has3d;
  }
  //#endregion
  function fCard(i) {
    let transform = prefix('transform');
    let rank = i % 13 + 1;
    let suit = i / 13 | 0;
    let z = (_deckParams.N - i) / displacement;
    let elem = createElement('div');
    let faceElem = createElement('div');
    let backElem = createElement('div');
    let isDraggable = false;
    let isFlippable = false;
    let text = 'hallo';
    let self = { params: _deckParams, text: text, i: i, rank: rank, suit: suit, pos: i, elem: elem, mount: mount, unmount: unmount, setSide: setSide };
    let modules = DeckB.modules;
    let module;
    faceElem.classList.add('face');
    backElem.classList.add('back');
    elem.style[transform] = translate(-z + 'px', -z + 'px');
    self.x = -z;
    self.y = -z;
    self.z = z;
    self.rot = 0;
    addListener(elem, 'mousedown', onMousedown);
    addListener(elem, 'touchstart', onMousedown);
    for (module in modules) {
      addModule(modules[module]);
    }
    self.animateTo = function (_params) {
      var delay = _params.delay;
      var duration = _params.duration;
      var _params$x = _params.x;
      var x = _params$x === undefined ? self.x : _params$x;
      var _params$y = _params.y;
      var y = _params$y === undefined ? self.y : _params$y;
      var _params$rot = _params.rot;
      var rot = _params$rot === undefined ? self.rot : _params$rot;
      var ease$$ = _params.ease;
      var onStart = _params.onStart;
      var onProgress = _params.onProgress;
      var onComplete = _params.onComplete;
      var startX, startY, startRot;
      var diffX, diffY, diffRot;
      animationFrames(delay, duration).start(function () {
        startX = self.x || 0;
        startY = self.y || 0;
        startRot = self.rot || 0;
        onStart && onStart();
      }).progress(function (t) {
        var et = ease[ease$$ || 'cubicInOut'](t);
        diffX = x - startX;
        diffY = y - startY;
        diffRot = rot - startRot;
        onProgress && onProgress(t, et);
        self.x = startX + diffX * et;
        self.y = startY + diffY * et;
        self.rot = startRot + diffRot * et;
        elem.style[transform] = translate(self.x + 'px', self.y + 'px') + (diffRot ? 'rotate(' + self.rot + 'deg)' : '');
      }).end(function () {
        onComplete && onComplete();
      });
    };
    self.eraseFace = function () {
      clearElement(faceElem);
    }
    self.prepFace = function () {
      self.params.fPrepFace(self, self.params);
    }
    self.updateFace = function () {
      self.params.fUpdateFace(self, self.params);
    }
    self.updateBack = function () {
      self.params.fUpdateBack(self, self.params);
    }
    self.prepFace();
    self.setSide('back');
    self.enableDragging = function () {
      if (isDraggable) {
        return;
      }
      isDraggable = true;
      elem.style.cursor = 'move';
    };
    self.enableFlipping = function () {
      if (isFlippable) {
        return;
      }
      isFlippable = true;
    };
    self.disableFlipping = function () {
      if (!isFlippable) {
        return;
      }
      isFlippable = false;
    };
    self.disableDragging = function () {
      if (!isDraggable) {
        return;
      }
      isDraggable = false;
      elem.style.cursor = '';
    };
    return self;
    function addModule(module) {
      module.card && module.card(self);
    }
    function onMousedown(e) {
      var startPos = {};
      var pos = {};
      var starttime = Date.now();
      e.preventDefault();
      if (e.type === 'mousedown') {
        startPos.x = pos.x = e.clientX;
        startPos.y = pos.y = e.clientY;
        addListener(window, 'mousemove', onMousemove);
        addListener(window, 'mouseup', onMouseup);
      } else {
        startPos.x = pos.x = e.touches[0].clientX;
        startPos.y = pos.y = e.touches[0].clientY;
        addListener(window, 'touchmove', onMousemove);
        addListener(window, 'touchend', onMouseup);
      }
      if (!isDraggable) {
        return;
      }
      elem.style[transform] = translate(self.x + 'px', self.y + 'px') + (self.rot ? ' rotate(' + self.rot + 'deg)' : '');
      elem.style.zIndex = maxZ++;
      function onMousemove(e) {
        if (!isDraggable) {
          return;
        }
        if (e.type === 'mousemove') {
          pos.x = e.clientX;
          pos.y = e.clientY;
        } else {
          pos.x = e.touches[0].clientX;
          pos.y = e.touches[0].clientY;
        }
        elem.style[transform] = translate(Math.round(self.x + pos.x - startPos.x) + 'px', Math.round(self.y + pos.y - startPos.y) + 'px') + (self.rot ? ' rotate(' + self.rot + 'deg)' : '');
      }
      function onMouseup(e) {
        if (isFlippable && Date.now() - starttime < 200) {
          self.setSide(self.side === 'front' ? 'back' : 'front');
        }
        if (e.type === 'mouseup') {
          removeListener(window, 'mousemove', onMousemove);
          removeListener(window, 'mouseup', onMouseup);
        } else {
          removeListener(window, 'touchmove', onMousemove);
          removeListener(window, 'touchend', onMouseup);
        }
        if (!isDraggable) {
          return;
        }
        self.x = self.x + pos.x - startPos.x;
        self.y = self.y + pos.y - startPos.y;
      }
    }
    function mount(target) {
      target.appendChild(elem);
      self.dParent = target;
    }
    function unmount() {
      self.dParent && self.dParent.removeChild(elem);
      self.dParent = null;
    }
    function setSide(newSide) {
      if (newSide === 'front') {
        if (self.side === 'back') {
          elem.removeChild(backElem);
        }
        self.side = 'front';
        elem.appendChild(faceElem);
        self.updateFace();
      } else {
        if (self.side === 'front') {
          elem.removeChild(faceElem);
        }
        self.side = 'back';
        elem.appendChild(backElem);
        self.updateBack();
      }
    }
  }
  function fDeck(deckParams) {
    _deckParams = deckParams;
    let w = deckParams.size.w;
    let h = deckParams.size.h;
    if (deckParams.orientation == 'landscape' && w < h || w > h) {
      deckParams.size = { w: h, h: w };
      w = deckParams.size.w;
      h = deckParams.size.h;
    }
    setCSSVariable('--wCard', w + 'px');
    setCSSVariable('--hCard', h + 'px');
    let cards = new Array(_deckParams.NTotal);
    let deckElem = createElement('div');
    let self = observable({ mount: mount, unmount: unmount, cards: cards, elem: deckElem });
    let dParent;
    let modules = DeckB.modules;
    let module;
    queue(self);
    for (module in modules) {
      addModule(modules[module]);
    }
    deckElem.classList.add('deck');
    let card;
    for (let i = cards.length; i; i--) {
      card = cards[i - 1] = fCard(i - 1);
      card.setSide('back');
      card.mount(deckElem);
    }
    return self;
    function mount(root) {
      dParent = root;
      dParent.appendChild(deckElem);
    }
    function unmount() {
      dParent.removeChild(deckElem);
    }
    function addModule(module) {
      module.deck && module.deck(self);
    }
  }
  fDeck.animationFrames = animationFrames;
  fDeck.ease = ease;
  fDeck.modules = { bysuit: bysuit, fan: fan, intro: intro, poker: poker, shuffle: shuffle, sort: sort, flip: flip };
  fDeck.Card = fCard;
  fDeck.prefix = prefix;
  fDeck.translate = translate;
  fDeck.params = _deckParams;
  return { fDeck: fDeck };
})();
var Script = {
  _loadedScripts: [],
  include: function (script) {
    if (this._loadedScripts.include(script)) {
      return false;
    }
    var code = new Ajax.Request(script, {
      asynchronous: false,
      method: "GET",
      evalJS: false,
      evalJSON: false
    }).transport.responseText;
    if (Prototype.Browser.IE) {
      window.execScript(code);
    } else if (Prototype.Browser.WebKit) {
      $$("head").first().insert(Object.extend(
        new Element("script", {
          type: "text/javascript"
        }), {
        text: code
      }
      ));
    } else {
      window.eval(code);
    }
    this._loadedScripts.push(script);
  }
};
var symbolKeys;
var symbolList;
var symbolDict;
var svgKeys;
var svgList;
var svgDict;
var symBySet;
var symByType;
var symKeysBySet;
var symKeysByType;
var symListBySet;
var symListByType;
var CorrectWordsExact;
var CorrectWordsCorrect;
var CorrectWordsFailed;
var CorrectWords;
var selectedEmoSetNames = ['all', 'animal', 'body', 'drink', 'emotion', 'food', 'fruit', 'game', 'gesture', 'kitchen', 'object', 'person', 'place', 'plant', 'sports', 'time', 'transport', 'vegetable'];
var primitiveSetNames = ['all', 'activity', 'animal', 'body', 'drink',
  'emotion', 'family', 'fantasy', 'food', 'fruit', 'game', 'gesture',
  'kitchen', 'object', 'place', 'plant', 'person',
  'role', 'shapes', 'sport', 'sports',
  'time', 'transport', 'vegetable',
  'toolbar', 'math', 'punctuation', 'misc'];
var higherOrderEmoSetNames = {
  animals: ['animal'],
  animalplantfood: ['animal', 'plant', 'drink', 'food', 'fruit', 'vegetable'],
  life: ['animal', 'plant', 'drink', 'food', 'fruit', 'vegetable', 'kitchen', 'game', 'sport'],
  more: ['animal', 'plant', 'drink', 'food', 'fruit', 'kitchen', 'vegetable', 'game', 'sport', 'transport', 'object'],
};
var higherOrderEmoSetNames1 = { all: ['all'], select: selectedEmoSetNames, abstract: ['time', 'symbols'], action: ['game', 'sports'], food: ['drink', 'food', 'fruit', 'kitchen', 'vegetable'], human: ['body', 'gesture', 'emotion', 'person', 'role'], life: ['animal', 'plant'], mood: ['emotion'], object: ['object'], places: ['place', 'transport'] };
var emoSets = {
  nosymbols: { name: 'nosymbols', f: o => o.group != 'symbols' && o.group != 'flags' && o.group != 'clock' },
  nosymemo: { name: 'nosymemo', f: o => o.group != 'smileys-emotion' && o.group != 'symbols' && o.group != 'flags' && o.group != 'clock' },
  all: { name: 'all', f: _ => true },
  activity: { name: 'activity', f: o => o.group == 'people-body' && (o.subgroups == 'person-activity' || o.subgroups == 'person-resting') },
  animal: { name: 'animal', f: o => startsWith(o.group, 'animal') && startsWith(o.subgroups, 'animal') },
  body: { name: 'body', f: o => o.group == 'people-body' && o.subgroups == 'body-parts' },
  clock: { name: 'clock', f: o => o.group == 'clock' },
  drink: { name: 'drink', f: o => o.group == 'food-drink' && o.subgroups == 'drink' },
  emotion: { name: 'emotion', f: o => o.group == 'smileys-emotion' },
  family: { name: 'family', f: o => o.group == 'people-body' && o.subgroups == 'family' },
  fantasy: { name: 'fantasy', f: o => o.group == 'people-body' && o.subgroups == 'person-fantasy' },
  food: { name: 'food', f: o => o.group == 'food-drink' && startsWith(o.subgroups, 'food') },
  fruit: { name: 'fruit', f: o => o.group == 'food-drink' && o.subgroups == 'food-fruit' },
  game: { name: 'game', f: o => (o.group == 'activities' && o.subgroups == 'game') },
  gesture: { name: 'gesture', f: o => o.group == 'people-body' && (o.subgroups == 'person-gesture' || o.subgroups.includes('hand')) },
  kitchen: { name: 'kitchen', f: o => o.group == 'food-drink' && o.subgroups == 'dishware' },
  math: { name: 'math', f: o => o.group == 'symbols' && o.subgroups == 'math' },
  misc: { name: 'misc', f: o => o.group == 'symbols' && o.subgroups == 'other-symbol' },
  object: {
    name: 'object', f: o =>
      (o.group == 'food-drink' && o.subgroups == 'dishware')
      || (o.group == 'travel-places' && o.subgroups == 'time')
      || (o.group == 'activities' && o.subgroups == 'event')
      || (o.group == 'activities' && o.subgroups == 'award-medal')
      || (o.group == 'activities' && o.subgroups == 'arts-crafts')
      || (o.group == 'activities' && o.subgroups == 'sport')
      || (o.group == 'activities' && o.subgroups == 'game')
      || (o.group == 'objects')
      || (o.group == 'activities' && o.subgroups == 'event')
      || (o.group == 'travel-places' && o.subgroups == 'sky-weather')
  },
  person: { name: 'person', f: o => o.group == 'people-body' && o.subgroups == 'person' },
  place: { name: 'place', f: o => startsWith(o.subgroups, 'place') },
  plant: { name: 'plant', f: o => startsWith(o.group, 'animal') && startsWith(o.subgroups, 'plant') },
  punctuation: { name: 'punctuation', f: o => o.group == 'symbols' && o.subgroups == 'punctuation' },
  role: { name: 'role', f: o => o.group == 'people-body' && o.subgroups == 'person-role' },
  shapes: { name: 'shapes', f: o => o.group == 'symbols' && o.subgroups == 'geometric' },
  sport: { name: 'sport', f: o => o.group == 'people-body' && o.subgroups == 'person-sport' },
  sports: { name: 'sports', f: o => (o.group == 'activities' && o.subgroups == 'sport') },
  sternzeichen: { name: 'sternzeichen', f: o => o.group == 'symbols' && o.subgroups == 'zodiac' },
  symbols: { name: 'symbols', f: o => o.group == 'symbols' },
  time: { name: 'time', f: o => (o.group == 'travel-places' && o.subgroups == 'time') },
  toolbar: {
    name: 'toolbar', f: o => (o.group == 'symbols' && o.subgroups == 'warning')
      || (o.group == 'symbols' && o.subgroups == 'arrow')
      || (o.group == 'symbols' && o.subgroups == 'av-symbol')
      || (o.group == 'symbols' && o.subgroups == 'other-symbol')
      || (o.group == 'symbols' && o.subgroups == 'keycap')
  },
  transport: { name: 'transport', f: o => startsWith(o.subgroups, 'transport') && o.subgroups != 'transport-sign' },
  vegetable: { name: 'vegetable', f: o => o.group == 'food-drink' && o.subgroups == 'food-vegetable' },
};
var symbolDictC = null;
var svgDictC = null;
var emoCharsC = null;
var SIGI;
var pictureSize;
var nMissing;
var MaxPosMissing;
var NumMissingLetters;
var uiActivatedTC;
var NumColors;
var isRunning = false;
var hasGotFinalResult;
var hasGotResult;
var nextIndex = -1;
var BestKeysE;
var BestKeySets;
var BestKeysD;
var EdDict;
var DeDict;
var symKeysByGroupSub;
var MenuItems;
var TimeElapsed;
var OnTimeOver = null;
var TimeElem;
var TimeLeft;
var TimestampStarted;
var Gamename;
var Tablename;
var I;
var P;
var ADS;
var AD;
var App;
var Zones = {};
var Options = {};
var DOC_UIS;
var DOC_vault;
var DOC_dvIndex;
var DOC_CURRENT_PATH_INDEX;
var DOC_CURRENT_FUNC;
var SpeechRecognition = SpeechRecognition || webkitSpeechRecognition
var SpeechGrammarList = SpeechGrammarList || webkitSpeechGrammarList
var SpeechRecognitionEvent = SpeechRecognitionEvent || webkitSpeechRecognitionEvent
var matchingWords;
var speechRecognitionList;
var hintMessage;
var resultMessage;
var TESTVAR = 0;
var testDict = {};
var QuestionCounter = 0;
var lastPosition = 0;
var WordProblems;
var SERVER_DATA = null;
var SettingTypesCommon = {
  samplesPerGame: true,
  minutesPerUnit: true,
  incrementLevelOnPositiveStreak: true,
  decrementLevelOnNegativeStreak: true,
  showLabels: true,
  language: true,
  vocab: true,
  showTime: true,
  spokenFeedback: true,
  silentMode: true,
  switchGame: true,
  trials: false,
  showHint: false,
}
var FASTSTART = false && EXPERIMENTAL;
var MSTimeDiff;
var MSTimeStart;
var MSTimeCallback;
var MSTimeTO;
var MSTimeClock;
var ClientId;
var MessageCounter = 0;
var ItemsByKey;
var BaseColor;
var HeaderColor;
var SidebarColor;
var IsControlKeyDown = false;
var PerlenDict;
var dAux;
var dAuxContent;
var STARTED;
var NiceBaseColors = ['#791900']
var MAGNIFIER_IMAGE;
var globalSum = 0
var positionCount;
var BlockServerSend1 = false;
var F;
var dParent;
var UBEF = null;
var GBEF = null;
var EBEF = null;
var PI = Math.pi, interval_id, angle, factor = .67, tree = [], leaves = [], jittering = false;
var requestAnimFrame = (function () {
  return window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function (callback) {
      window.setTimeout(callback, 1000 / 60);
    };
})();
var lineWidth = 4;
var mousePullStrength = 0.005;
var Gaussian = function (mean, variance) {
  if (variance <= 0) {
    throw new Error('Variance must be > 0 (but was ' + variance + ')');
  }
  this.mean = mean;
  this.variance = variance;
  this.standardDeviation = Math.sqrt(variance);
}
var Emicons = {
  msmaus: "https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/microsoft/319/mouse-face_1f42d.png",
  gmaus: "https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/google/346/mouse-face_1f42d.png",
  smaus: "https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/softbank/145/mouse-face_1f42d.png",
  twmaus: "https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/twitter/322/mouse-face_1f42d.png",
  maus: "https://emojipedia-us.s3.dualstack.us-west-1.amazonaws.com/thumbs/120/whatsapp/326/mouse-face_1f42d.png",
};
var SICHERER = 100;
var freeBus = {
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "geometry": {
        "type": "LineString",
        "coordinates": [
          [-105.00341892242432, 39.75383843460583],
          [-105.0008225440979, 39.751891803969535]
        ]
      },
      "properties": {
        "popupContent": "This is a free bus line that will take you across downtown.",
        "underConstruction": false
      },
      "id": 1
    },
    {
      "type": "Feature",
      "geometry": {
        "type": "LineString",
        "coordinates": [
          [-105.0008225440979, 39.751891803969535],
          [-104.99820470809937, 39.74979664004068]
        ]
      },
      "properties": {
        "popupContent": "This is a free bus line that will take you across downtown.",
        "underConstruction": true
      },
      "id": 2
    },
    {
      "type": "Feature",
      "geometry": {
        "type": "LineString",
        "coordinates": [
          [-104.99820470809937, 39.74979664004068],
          [-104.98689651489258, 39.741052354709055]
        ]
      },
      "properties": {
        "popupContent": "This is a free bus line that will take you across downtown.",
        "underConstruction": false
      },
      "id": 3
    }
  ]
};
var lightRailStop = {
  "type": "FeatureCollection",
  "features": [
    {
      "type": "Feature",
      "properties": {
        "popupContent": "18th & California Light Rail Stop"
      },
      "geometry": {
        "type": "Point",
        "coordinates": [-104.98999178409576, 39.74683938093904]
      }
    }, {
      "type": "Feature",
      "properties": {
        "popupContent": "20th & Welton Light Rail Stop"
      },
      "geometry": {
        "type": "Point",
        "coordinates": [-104.98689115047453, 39.747924136466565]
      }
    }
  ]
};
var bicycleRental = {
  "type": "FeatureCollection",
  "features": [
    {
      "geometry": {
        "type": "Point",
        "coordinates": [
          -104.9998241,
          39.7471494
        ]
      },
      "type": "Feature",
      "properties": {
        "popupContent": "This is a B-Cycle Station. Come pick up a bike and pay by the hour. What a deal!"
      },
      "id": 51
    },
    {
      "geometry": {
        "type": "Point",
        "coordinates": [
          -104.9983545,
          39.7502833
        ]
      },
      "type": "Feature",
      "properties": {
        "popupContent": "This is a B-Cycle Station. Come pick up a bike and pay by the hour. What a deal!"
      },
      "id": 52
    },
    {
      "geometry": {
        "type": "Point",
        "coordinates": [
          -104.9963919,
          39.7444271
        ]
      },
      "type": "Feature",
      "properties": {
        "popupContent": "This is a B-Cycle Station. Come pick up a bike and pay by the hour. What a deal!"
      },
      "id": 54
    },
    {
      "geometry": {
        "type": "Point",
        "coordinates": [
          -104.9960754,
          39.7498956
        ]
      },
      "type": "Feature",
      "properties": {
        "popupContent": "This is a B-Cycle Station. Come pick up a bike and pay by the hour. What a deal!"
      },
      "id": 55
    },
    {
      "geometry": {
        "type": "Point",
        "coordinates": [
          -104.9933717,
          39.7477264
        ]
      },
      "type": "Feature",
      "properties": {
        "popupContent": "This is a B-Cycle Station. Come pick up a bike and pay by the hour. What a deal!"
      },
      "id": 57
    },
    {
      "geometry": {
        "type": "Point",
        "coordinates": [
          -104.9913392,
          39.7432392
        ]
      },
      "type": "Feature",
      "properties": {
        "popupContent": "This is a B-Cycle Station. Come pick up a bike and pay by the hour. What a deal!"
      },
      "id": 58
    },
    {
      "geometry": {
        "type": "Point",
        "coordinates": [
          -104.9788452,
          39.6933755
        ]
      },
      "type": "Feature",
      "properties": {
        "popupContent": "This is a B-Cycle Station. Come pick up a bike and pay by the hour. What a deal!"
      },
      "id": 74
    }
  ]
};
var coorsField = {
  "type": "Feature",
  "properties": {
    "popupContent": "Coors Field"
  },
  "geometry": {
    "type": "Point",
    "coordinates": [-104.99404191970824, 39.756213909328125]
  }
};
const Geo = {
  layerInfo: {
    empty: {
      url: '',
      options: { maxZoom: 22 }
    },
    ru: {
      url: 'https:/' + '/core-sat.maps.yandex.net/tiles?l=sat&v=3.1025.0&x={x}&y={y}&z={z}&scale=1&lang=ru_RU',
      options: { minZoom: 0, maxZoom: 19, }
    },
    satellite: {
      url: 'http:/' + '/server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      options: { maxZoom: 19, attribution: '&copy; <a href="http:/"+"www.esri.com/">Esri</a>, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community' }
    },
    gsatellite: {
      url: 'http:/' + '/{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
      options: { maxZoom: 22, subdomains: ['mt0', 'mt1', 'mt2', 'mt3'] }
    },
    gstreets: {
      url: 'http:/' + '/{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',
      options: { maxZoom: 22, subdomains: ['mt0', 'mt1', 'mt2', 'mt3'] }
    },
    ghybrid: {
      url: 'http:/' + '/{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}',
      options: { maxZoom: 22, subdomains: ['mt0', 'mt1', 'mt2', 'mt3'] }
    },
    gterrain: {
      url: 'http:/' + '/{s}.google.com/vt/lyrs=p&x={x}&y={y}&z={z}',
      options: { maxZoom: 22, subdomains: ['mt0', 'mt1', 'mt2', 'mt3'] }
    },
    mbsat: {
      url: 'https:/' + '/api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw',
      options: { attribution: 'Map data &copy; <a href="https:/"+"/www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Imagery © <a href="https:/"+"/www.mapbox.com/">Mapbox</a>', id: 'mapbox/satellite-v9', tileSize: 512, zoomOffset: -1 }
    },
    mbstreets: {
      url: 'https:/' + '/api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw',
      options: { attribution: 'Map data &copy; <a href="https:/"+"/www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Imagery © <a href="https:/"+"/www.mapbox.com/">Mapbox</a>', id: 'mapbox/streets-v11', tileSize: 512, zoomOffset: -1 }
    },
    mb1: {
      url: 'https:/' + '/api.mapbox.com/styles/v1/mapbox-map-design/cl4whev1w002w16s9mgoliotw/static/-90,35,2.5,0/840x464?access_token=pk.eyJ1IjoibWFwYm94LW1hcC1kZXNpZ24iLCJhIjoiY2syeHpiaHlrMDJvODNidDR5azU5NWcwdiJ9.x0uSqSWGXdoFKuHZC5Eo_Q',
      options: { attribution: 'Map data &copy; <a href="https:/"+"/www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Imagery © <a href="https:/"+"/www.mapbox.com/">Mapbox</a>', tileSize: 512, zoomOffset: -1 }
    },
    cartolabels: {
      url: 'https:/' + '/{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png',
      options: {
        attribution: '&copy; <a href="https:/"+"/www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https:/"+"/carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 20
      }
    },
    cartonolabels: {
      url: 'https:/' + '/{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png',
      options: {
        attribution: '&copy; <a href="https:/"+"/www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https:/"+"/carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 20
      }
    },
    cartodark: {
      url: 'https:/' + '/{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png',
      options: {
        attribution: '&copy; <a href="https:/"+"/www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https:/"+"/carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 20
      }
    },
    osm: {
      url: 'https:/' + '/tile.openstreetmap.org/{z}/{x}/{y}.png',
      options: { attribution: '&copy; <a href="https:/"+"/www.openstreetmap.org/copyright">OpenStreetMap</a>', subdomains: ['a', 'b', 'c'] }
    },
    osmg: {
      url: 'https:/' + '/{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png',
      options: { attribution: '&copy; <a href="https:/"+"/www.openstreetmap.org/copyright">OpenStreetMap</a>', subdomains: ['a', 'b', 'c'] }
    },
    watercolor: {
      url: 'http:/' + '/{s}.tile.stamen.com/watercolor/{z}/{x}/{y}.jpg',
      options: { attribution: 'Map tiles by <a href="http:/"+"stamen.com">Stamen Design</a>, under <a href="http:/"+"creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http:/"+"openstreetmap.org">OpenStreetMap</a>, under <a href="http:/"+"creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.', maxZoom: 18, subdomains: 'abcd', }
    },
    labels: {
      url: "http:/" + "tile.stamen.com/toner-labels/{z}/{x}/{y}.png",
      options: { attribution: 'Map tiles by <a href="http:/"+"stamen.com">Stamen Design</a>, under <a href="http:/"+"creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http:/"+"openstreetmap.org">OpenStreetMap</a>, under <a href="http:/"+"www.openstreetmap.org/copyright">ODbL</a>.', maxZoom: 18 }
    },
    terrain: {
      url: 'http:/' + '/{s}.tile.stamen.com/terrain/{z}/{x}/{y}.jpg',
      options: { attribution: 'Map tiles by <a href="http:/"+"stamen.com">Stamen Design</a>, under <a href="http:/"+"creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http:/"+"openstreetmap.org">OpenStreetMap</a>, under <a href="http:/"+"creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.', maxZoom: 18, }
    },
    terrainbg: {
      url: 'http:/' + '/{s}.tile.stamen.com/terrain-background/{z}/{x}/{y}.jpg',
      options: { attribution: 'Map tiles by <a href="http:/"+"stamen.com">Stamen Design</a>, under <a href="http:/"+"creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http:/"+"openstreetmap.org">OpenStreetMap</a>, under <a href="http:/"+"creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.', maxZoom: 18, }
    },
    topo: {
      url: 'https:/' + '/{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
      options: {
        maxZoom: 17,
        attribution: 'Map data: &copy; <a href="https:/"+"/www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http:/"+"viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https:/"+"/opentopomap.org">OpenTopoMap</a> (<a href="https:/"+"/creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
      }
    }
  },
  places: {
    tuerkenschanzpark: [48.23562171298636, 16.337871551513675],
    sievering: [48.245368124489204, 16.342549324035648],
    zehenthofgasse: [48.24522522864384, 16.34572505950928],
    vegagasse: [48.23413529351023, 16.346755027771],
  },
  continents: {
    Africa: ['Algeria', 'Angola', 'Benin', 'Botswana', 'Burkina Faso', 'Burundi', 'Cameroon', 'Cape Verde', 'Central African Republic', 'Chad', 'Comoros', 'Congo', 'Democratic Republic of the Congo', 'Djibouti', 'Egypt', 'Equatorial Guinea', 'Eritrea', 'Ethiopia', 'Gabon', 'Gambia', 'Ghana', 'Guinea', 'Guinea-Bissau', 'Ivory Coast', 'Kenya', 'Lesotho', 'Liberia', 'Libya', 'Madagascar', 'Malawi', 'Mali', 'Mauritania', 'Mauritius', 'Mayotte', 'Morocco', 'Mozambique', 'Namibia', 'Niger', 'Nigeria', 'Reunion', 'Rwanda', 'Sao Tome And Principe', 'Senegal', 'Seychelles', 'Sierra Leone', 'Somalia', 'South Africa', 'South Sudan', 'Saint Helena', 'Sudan', 'Swaziland', 'Tanzania', 'Togo', 'Tunisia', 'Uganda', 'Zambia', 'Zimbabwe'],
    Asia: ['Afghanistan', 'Bahrain', 'Bangladesh', 'Bhutan', 'Brunei', 'Myanmar', 'Cambodia', 'China', 'East Timor', 'Hong Kong', 'India', 'Indonesia', 'Iran', 'Iraq', 'Israel', 'Japan', 'Jordan', 'Kazakhstan', 'Macau', 'North Korea', 'South Korea', 'Kuwait', 'Kyrgyzstan', 'Laos', 'Lebanon', 'Malaysia', 'Maldives', 'Mongolia', 'Nepal', 'Oman', 'Pakistan', 'Philippines', 'Qatar', 'Russia', 'Saudi Arabia', 'Singapore', 'Sri Lanka', 'Syria', 'Taiwan', 'Tajikistan', 'Thailand', 'Turkey', 'Turkmenistan', 'United Arab Emirates', 'Uzbekistan', 'Vietnam', 'Yemen'],
    Europe: ['Albania', 'Andorra', 'Armenia', 'Austria', 'Azerbaijan', 'Belarus', 'Belgium', 'Bosnia And Herzegovina', 'Bulgaria', 'Croatia', 'Cyprus', 'Czechia', 'Denmark', 'Estonia', 'Finland', 'France', 'Georgia', 'Germany', 'Gibraltar', 'Greece', 'Hungary', 'Iceland', 'Ireland', 'Isle Of Man', 'Italy', 'Jersey', 'Kosovo', 'Latvia', 'Liechtenstein', 'Lithuania', 'Luxembourg', 'Macedonia', 'Malta', 'Moldova', 'Monaco', 'Montenegro', 'Netherlands', 'Norway', 'Poland', 'Portugal', 'Romania', 'San Marino', 'Serbia', 'Slovakia', 'Slovenia', 'Spain', 'Sweden', 'Switzerland', 'Ukraine', 'United Kingdom', 'Vatican City'],
    'North America': ['Antigua and Barbuda', 'Bahamas', 'Barbados', 'Belize', 'Bermuda', 'Cayman Islands', 'Canada', 'Costa Rica', 'Cuba', 'Dominica', 'Dominican Republic', 'El Salvador', 'Grenada', 'Guadeloupe', 'Guatemala', 'Haiti', 'Honduras', 'Jamaica', 'Martinique', 'Mexico', 'Nicaragua', 'Panama', 'Puerto Rico', 'Saint Kitts and Nevis', 'Saint Lucia', 'Saint Vincent And The Grenadines', 'Trinidad And Tobago', 'United States'],
    Oceania: ['Australia', 'Fiji', 'French Polynesia', 'Kiribati', 'Marshall Islands', 'Micronesia', 'Nauru', 'New Caledonia', 'New Zealand', 'Palau', 'Papua New Guinea', 'Samoa', 'Solomon Islands', 'Tonga', 'Tuvalu', 'Vanuatu'],
    'South America': ['Argentina', 'Aruba', 'Bolivia', 'Brazil', 'Chile', 'Colombia', 'Curacao', 'Ecuador', 'French Guiana', 'Guam', 'Guyana', 'Paraguay', 'Peru', 'Suriname', 'Uruguay', 'Venezuela']
  }
};
var myGameArea = {
  canvas: document.createElement('canvas'),
  start: function () {
    this.canvas.width = 480;
    this.canvas.height = 270;
    this.context = this.canvas.getContext('2d');
    document.body.insertBefore(this.canvas, document.body.childNodes[0]);
    this.frameNo = 0;
    this.interval = setInterval(updateGameArea, 20);
  },
  clear: function () {
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  },
};
var C = null;
var dPage;
var dMap;
var dHeader;
var dFooter;
var dPuppet;
var dMenu;
var dLeft;
var dCenter;
var dRight;
var dTop;
var dBottom;
var CX;
var CV;
var FR = 50;
var _TOSound;
var Sayings;
var SCENEWIDTH = 900;
var SCENEHEIGHT = 600;
var FRAMERATE = 30;
var Timer = function () {
  this.date = new Date();
  this.lastTime = 0;
  this.currentTime = 0;
  this.start = function () {
    this.currentTime = Date.now();
  }
  this.reset = function () {
    this.currentTime = Date.now();
  }
  this.getTimeElapsed = function () {
    this.lastTime = this.currentTime;
    this.currentTime = Date.now();
    return (this.currentTime - this.lastTime);
  }
}
var EC = {};
var EID = {};
var ET = {};
var ENN = {};
var TOQ;
var AkQ;
var Q;
var QCounter = 0;
var TOQRunner;
var QRunnerRunning = false;
var QRunning = false;
var QCancelAutoreset;
var resizeObserver = new ResizeObserver(entries => {
  for (let entry of entries) {
    let cs = window.getComputedStyle(entry.target);
    console.log('watching element:', entry.target);
    console.log(entry.contentRect.top, ' is ', cs.paddingTop);
    console.log(entry.contentRect.left, ' is ', cs.paddingLeft);
    console.log(entry.borderBoxSize[0].inlineSize, ' is ', cs.width);
    console.log(entry.borderBoxSize[0].blockSize, ' is ', cs.height);
    if (entry.target.handleResize)
      entry.target.handleResize(entry);
  }
});
var PORT = 3000;
var Globals;
var LIVE_SERVER;
var NODEJS;
var SINGLECLIENT;
var SERVERURL;
var dButtons;
var dCode;
var dContent;
var dFiddle;
var dSidebar;
var AU = {};
var CONTEXT = null;
var UIDHelpers = 0;
var NAMED_UIDS = {};
var palDict = {};
var activatedTests = [];
var Epsilon = 1e-10;
var lastUpdate = 0;
var Ball = function () {
  var velocity = [0, 0];
  var position = [0, 0];
  var element = $('#ball');
  var owner;
  var halfTile = 32;
  var paused = false;
  function move(t) {
    if (owner !== undefined) {
      var ownerPosition = owner.getPosition();
      position[1] = ownerPosition[1] + owner.getSize() / 2;
      if (owner.getSide() === 'left') {
        position[0] = ownerPosition[0] + owner.getSize();
      } else {
        position[0] = ownerPosition[0];
      }
    } else {
      if (position[1] - halfTile <= 0 ||
        position[1] + halfTile >= innerHeight) {
        velocity[1] = -velocity[1];
      }
      position[0] += velocity[0] * t;
      position[1] += velocity[1] * t;
    }
    element.css('left', (position[0] - halfTile) + 'px');
    element.css('top', (position[1] - halfTile) + 'px');
  };
  function checkScored() {
    if (position[0] <= 0) {
      pause();
      $(document).trigger('ping:opponentScored');
    }
    if (position[0] >= innerWidth) {
      pause();
      $(document).trigger('ping:playerScored');
    }
  }
  function update(t) {
    if (!paused) {
      move(t);
    }
    if (owner !== undefined) {
      return;
    }
    var playerPosition = player.getPosition();
    if (position[0] <= player.getSize() &&
      position[1] >= playerPosition[1] &&
      position[1] <= playerPosition[1] + player.getSize()) {
      console.log("Grabbed by player!");
      owner = player;
    }
    var opponentPosition = opponent.getPosition();
    if (position[0] >= innerWidth - opponent.getSize() &&
      position[1] >= opponentPosition[1] &&
      position[1] <= opponentPosition[1] + opponent.getSize()) {
      console.log("Grabbed by opponent!");
      owner = opponent;
    }
    checkScored();
  }
  function pause() {
    paused = true;
  }
  function start() {
    paused = false;
  }
  return {
    update: update,
    pause: pause,
    start: start,
    getOwner: function () { return owner; },
    setOwner: function (o) { owner = o; },
    getVelocity: function () { return velocity },
    setVelocity: function (v) { velocity = v; },
    getPosition: function (p) { return position; },
  }
};
var BallPlayer = function (elementName, side) {
  var position = [0, 0];
  var aim = 0;
  var tileSize = 128;
  var element = $('#' + elementName);
  var move = function (y) {
    position[1] += y;
    if (position[1] <= 0) {
      position[1] = 0;
    }
    if (position[1] >= innerHeight - tileSize) {
      position[1] = innerHeight - tileSize;
    }
    if (side == 'right') {
      position[0] = innerWidth - tileSize;
    }
    element.css('left', position[0] + 'px');
    element.css('top', position[1] + 'px');
  }
  var fire = function () {
    if (ball.getOwner() !== this) {
      return;
    }
    var v = [0, 0];
    if (side == 'left') {
      switch (aim) {
        case -1:
          v = [.707, -.707];
          break;
        case 0:
          v = [1, 0];
          break;
        case 1:
          v = [.707, .707];
      }
    } else {
      switch (aim) {
        case -1:
          v = [-.707, -.707];
          break;
        case 0:
          v = [-1, 0];
          break;
        case 1:
          v = [-.707, .707];
      }
    }
    ball.setVelocity(v);
    ball.setOwner(undefined);
  }
  return {
    move: move,
    fire: fire,
    getSide: function () { return side; },
    setAim: function (a) { aim = a; },
    getPosition: function () { return position; },
    getSize: function () { return tileSize; }
  }
};
var IS_TESTING = true;
var currentGame = IS_TESTING ? 'gTouchPic' : 'sequence';
var currentUser = 'Gunter';
var currentLanguage = 'E';
var currentCategories = ['nosymbols'];
var startAtLevel = IS_TESTING ? { gSayPicAuto: 10, gTouchPic: 3, gTouchColors: 6, gWritePic: 10, gMissingLetter: 10, gSayPic: 0 }
  : { gMissingLetter: 3, gTouchPic: 7, gTouchColors: 8, gWritePic: 10, gSayPic: 0 };
var gameSequence = IS_TESTING ? ['gSayPicAuto', 'gTouchPic', 'gTouchColors', 'gWritePic', 'gMissingLetter', 'gSayPic']
  : ['gSayPic', 'gTouchColors', 'gWritePic'];//'gMissingLetter','gTouchPic',
var currentLevel;
var currentKeys;
var OnMicrophoneGotResult;
var OnMicrophoneProblem;
var OnMicrophoneReady;
var skipAnimations = IS_TESTING;
var skipBadgeAnimation = true;
var StepByStepMode = false;
var DELAY = 1000;
var ROUND_DELAY = 500;
var DELAY_BETWEEN_MIKE_AND_SPEECH = 2000;
var ROUND_OUTPUT = true;
var PICS_PER_LEVEL = IS_TESTING ? 1 : 3;
var SAMPLES_PER_LEVEL = new Array(20).fill(PICS_PER_LEVEL);
var MAXLEVEL = 10;
var fleetingMessageTimeout;
var MaxNumTrials = 1;
var MinWordLength = 1;
var MaxWordLength = 100;
var NumPics;
var NumLabels;
var NextPictureIndex = 0;
var DefaultScoringMode = 'n';
var scoringMode;
var maxIncrement = 5;
var levelDonePoints = 5;
var minIncrement = 1;
var numTotalAnswers;
var percentageCorrect;
var numCorrectAnswers;
var levelPoints;
var levelIncrement;
var CurrentGameData;
var CurrentLevelData;
var CurrentSessionData;
var SessionScore = 0;
var LevelChange = true;
var trialNumber;
var isINTERRUPT;
var isSpeakerRunning;
var uiPausedStack = [];
var uiPaused = 0;
var dLineTop;
var dLineTopLeft;
var dLineTopRight;
var dLineTopMiddle;
var dLineTopOuter;
var dLineTitle;
var dLineTitleLeft;
var dLineTitleRight;
var dLineTitleMiddle;
var dLineTitleOuter;
var dLineTable;
var dLineTableLeft;
var dLineTableRight;
var dLineTableMiddle;
var dLineTableOuter;
var dLineBottom;
var dLineBottomLeft;
var dLineBottomRight;
var dLineBottomMiddle;
var dLineBottomOuter;
var dFeedback;
var dLevel;
var dHint;
var inputBox;
var defaultFocusElement;
var dSettings = mBy('dSettings');
var inputForm;
var inputTxt;
var voiceSelect;
var pitchValue;
var rateValue;
var hintWord;
var bestWord;
var answerCorrect;
var currentInfo;
var Simple = {
  axiom: 'A',
  rules: [
    { aus: 'A', mach: 'AB' },
    { aus: 'B', mach: 'A' }
  ],
};
var Algae = {
  axiom: 'A',
  rules: [
    { aus: 'A', mach: 'A+[B]-[A]' },
    { aus: 'B', mach: 'AA' }
  ],
  angle: 25,
  factor: .9,
  max: 5,
};
var Complex = {
  axiom: 'F',
  rules: [
    { aus: 'F', mach: 'FF+[+F-F-F]-[-F+F+F]' }
  ],
  angle: 25,
  factor: .5,
  max: 6,
};
var dConsole;
var COLUMNS = { COL_A: 0, COL_B: 1, COL_C: 2, COL_D: 3, COL_E: 4, COL_F: 5, COL_G: 6, COL_H: 7, COL_NONE: 8 };
var ROWS = { ROW_1: 0, ROW_2: 1, ROW_3: 2, ROW_4: 3, ROW_5: 4, ROW_6: 5, ROW_7: 6, ROW_8: 7, ROW_NONE: 8 };
var ColBrd = new Array(BRD_SQ_NUM);
var RowBrd = new Array(BRD_SQ_NUM);
var RowChar = "12345678";
var ColChar = "abcdefgh";
var RookOpenCol = 10;
var RookSemiOpenCol = 5;
var QueenOpenCol = 5;
var QueenSemiOpenCol = 3;
var PawnRowsWhite = new Array(10);
var PawnRowsBlack = new Array(10);
var MirrorCols = [COLUMNS.COL_H, COLUMNS.COL_G, COLUMNS.COL_F, COLUMNS.COL_E, COLUMNS.COL_D, COLUMNS.COL_C, COLUMNS.COL_B, COLUMNS.COL_A];
var MirrorRows = [ROWS.ROW_8, ROWS.ROW_7, ROWS.ROW_6, ROWS.ROW_5, ROWS.ROW_4, ROWS.ROW_3, ROWS.ROW_2, ROWS.ROW_1];
var dTest;
var dTestButtons;
var brd_side = COLOURS.WHITE;
var brd_pieces = new Array(BRD_SQ_NUM);
var brd_enPas = SQUARES.NO_SQ;
var brd_fiftyMove;
var brd_ply;
var brd_hisPly;
var brd_castlePerm;
var brd_posKey;
var brd_pceNum = new Array(13);
var brd_material = new Array(2);
var brd_pList = new Array(14 * 10);
var brd_history = [];
var brd_bookLines = [];
var brd_moveList = new Array(MAXDEPTH * MAXPOSITIONMOVES);
var brd_moveScores = new Array(MAXDEPTH * MAXPOSITIONMOVES);
var brd_moveListStart = new Array(MAXDEPTH);
var brd_PvTable = [];
var brd_PvArray = new Array(MAXDEPTH);
var brd_searchHistory = new Array(14 * BRD_SQ_NUM);
var brd_searchKillers = new Array(3 * MAXDEPTH);

class _grid {
  constructor(o, pool, boardInfo, fieldInfo) {
    this.boardInfo = boardInfo;
    this.fieldInfo = fieldInfo;
    let { board, fields, corners, edges } = this.skeleton = this.gridSkeleton(o, pool, this.boardInfo, this.fieldInfo);
    board.oid = o.oid;
  }
  gridSkeleton(omap, pool, gridInfoFunc, fieldInfoFunc) {
    let board = { o: omap, info: gridInfoFunc(omap.rows, omap.cols) };
    let fields = {};
    for (const fid of getElements(omap.fields)) {
      let o = pool[fid];
      fields[fid] = { oid: fid, o: pool[fid], info: fieldInfoFunc(board.info, o.row, o.col) };
    }
    board.info.vertices = correctPolys(Object.values(fields).map(x => x.info.poly), 1);
    let dhelp = {};
    let corners = {};
    for (const fid in fields) {
      let f = fields[fid];
      let i = 0;
      for (const cid of getElements(f.o.corners)) {
        if (cid && nundef(dhelp[cid])) {
          let pt = f.info.poly[i];
          corners[cid] = { oid: cid, o: pool[cid], info: { shape: 'circle', memType: 'corner', x: pt.x, y: pt.y, w: 1, h: 1 } };
          dhelp[cid] = true;
        }
        i += 1;
      }
    }
    dhelp = {};
    let edges = {};
    for (const fid in fields) {
      let f = fields[fid];
      for (const eid of getElements(f.o.edges)) {
        if (eid && nundef(dhelp[eid])) {
          let el = pool[eid];
          let n1 = corners[el.corners[0]._obj];
          let n2 = corners[el.corners[1]._obj];
          let [x1, y1, x2, y2] = [n1.info.x, n1.info.y, n2.info.x, n2.info.y];
          edges[eid] = { oid: eid, o: el, info: { shape: 'line', memType: 'edge', x1: x1, y1: y1, x2: x2, y2: y2, x: (x1 + x2) / 2, y: (y1 + y2) / 2, thickness: 1, w: 1, h: 1 } };
          dhelp[eid] = true;
        }
      }
    }
    return { board: board, fields: fields, corners: corners, edges: edges };
  }
}
class ABattle {
  constructor(assets, loc, b, stage) {
    this.assets = assets;
    this.location = loc;
    this.b = b;
    this.stage = stage;
    this.roundCounter = 0;
    this.factions = [b.attacker, b.defender];
    this.allUnitTypes = Array.from(new Set(b.fire_order.map(x => x.unit.type)));
    this.ms = {};
    this.selected = false;
    this.msFire = null;
    this.nColsPerFaction = this.calcMaxUnitTypePerFaction();
    let hTitle = 25 * 2;
    let usz = assets.SZ.cadreDetail;
    let hGap = 4;
    let hRow = usz + hGap;
    let hTotal = hRow * this.allUnitTypes.length + hTitle + 2 * hGap;
    if (b.isSeaBattle) {
      hTotal += 30;
    }
    let wGap = hGap;
    let wFactionGap = 10 * hGap;
    let wCol = usz + wGap;
    let wColTotal = Object.values(this.nColsPerFaction).reduce((a, b) => a + b, 0);
    let wColsPerFaction = {};
    let xStartPerFaction = {};
    let xAkku = wGap;
    for (const f of this.factions) {
      wColsPerFaction[f] = this.nColsPerFaction[f] * wCol;
      xStartPerFaction[f] = xAkku;
      xAkku += wColsPerFaction[f] + wFactionGap;
    }
    let yStartPerUnitType = {};
    let yAkku = hGap + 25;
    for (const t of this.allUnitTypes) {
      yStartPerUnitType[t] = yAkku;
      yAkku += hRow;
    }
    this.xStartPerFaction = xStartPerFaction;
    this.yStartPerUnitType = yStartPerUnitType;
    this.wColsPerFaction = wColsPerFaction;
    let wTotal = wGap + wColTotal * wCol + wFactionGap * this.factions.length + wGap;
    this.size = { w: wTotal, h: hTotal };
    this.unitSize = { w: wCol, h: hRow };
    this.gap = { w: wGap, h: hGap, col: wFactionGap };
  }
  highlightBattleGroups(b) {
    let units = b.fire_order;
    let battleGroups = b.battle_groups;
    for (const u of units) {
      let bgIndex = battleGroups.indexOf(u.battle_group);
      if (bgIndex >= 0) {
        let c = getpal(2, 0, 'b', this.battleGroupPalette);
        let ms = this.ms[u.id];
        ms.selKeyColor(c, 'bg' + bgIndex, 0.2);
      }
    }
  }
  coverBattleGroup(bg, b) {
    for (const u of b.fire_order) {
      if (u.battle_group == bg) {
        let ms = this.ms[u.id];
        let sz = this.assets.SZ.cadreDetail;
        ms.cover('grey');
      }
    }
  }
  uncoverBattleGroup(bg, b) {
    for (const u of b.fire_order) {
      if (u.battle_group == b.battle_group) {
        let ms = this.ms[u.id];
        ms.uncover();
      }
    }
  }
  selectBattle() {
    this.battleDiv.style.border = '4px solid yellow';
  }
  unselectBattle() {
    this.battleDiv.style.border = '1px solid ' + getpal(6);
  }
  selectFireUnit() {
    if (this.msFire) this.msFire.unhighlight();
    this.msFire = this.ms[this.b.fire.id];
    this.msFire.highlight();
  }
  unhighlightUnits() {
    for (const id in this.ms) {
      let ms = this.ms[id];
      if (ms.getTag('dead') || ms.getTag('removed')) continue;
      ms.unhighlight();
      ms.unselKeyColor();
    }
  }
  highlightANS(pl) {
    for (const id in this.ms) {
      let ms = this.ms[id];
      let type = ms.getTag('type');
      let owner = ms.getTag('owner');
      if (owner == pl && isANS(type)) {
        if (!ms.getTag('dead') && !ms.getTag('removed')) {
          ms.highlight();
        }
      }
    }
  }
  highlightTargetClass() {
    for (const u of this.b.target_units) {
      let ms = this.ms[u.id];
      ms.highlight();
    }
  }
  unhighlightTargetClass() {
    for (const u of this.b.target_units) {
      let ms = this.ms[u.id];
      ms.unhighlight();
    }
  }
  markMandatoryRebased(b_old, b) {
    for (const u of b_old.fire_order) {
      let id = u.id;
      let unitInB = firstCond(b.fire_order, x => x.id == id);
      if (!unitInB) {
        this.markAsRetreated(id);
      }
    }
  }
  markAsRetreated(id) {
    let ms = this.ms[id];
    ms.unhighlight();
    ms.selKeyColor('darkSlateGrey', 'retreated', 0.7);
    ms.tag('removed', true);
  }
  selectTheDead(b_old, b_new) {
    let degraded = '';
    let removed = '';
    let message = '';
    for (const u of b_old.fire_order) {
      let id = u.id;
      let ms = this.ms[id];
      let uNew = firstCond(b_new.fire_order, x => x.id == id);
      if (uNew) {
        let cv_old = u.unit.cv;
        let cv_new = uNew.unit.cv;
        if (cv_old != cv_new) {
          this.updateCv(ms, cv_new);
          degraded += ' ' + id.toString();
        }
      } else {
        this.updateCv(ms, 0);
        ms.selColor('black', 0.8);
        ms.tag('dead', true);
        removed += ' ' + id.toString();
      }
    }
    if (!empty(degraded)) message += degraded + ' degraded. ';
    if (!empty(removed)) message += removed + ' removed. ';
    message += 'Please accept!';
    return message;
  }
  selectUnitsHit(b) {
    for (const u of b.units_hit) {
      let id = u.id;
      let ms = this.ms[id];
      ms.selKeyColor('red');
    }
  }
  startDiceAnimation(fire) {
    this.fire = fire;
    let dDice = fire.owner == this.b.attacker ? this.attackerDiceDiv : this.defenderDiceDiv;
    this.diceRolling = true;
    dDice.classList.add('pulseOn');
  }
  stopDiceAnimation(fire) {
    let dDice = fire.owner == this.b.attacker ? this.attackerDiceDiv : this.defenderDiceDiv;
    dDice.classList.remove('pulseOn');
    this.diceRolling = false;
  }
  showHits(hits) {
    let dDice = this.b.fire.owner == this.b.attacker ? this.attackerDiceDiv : this.defenderDiceDiv;
    let html = dDice.innerHTML;
    dDice.innerHTML = html + '<br>' + hits;
    divscrolldown(dDice.id);
  }
  createUnit(u, id, gName, type, nationality) {
    let owner = getUnitOwner(nationality);
    let imagePath = '/a/assets/images/' + type + '.svg';
    let isMinorColor = !(nationality in this.assets.troopColors);
    let color = isMinorColor ? this.assets.troopColors['Minor'] : this.assets.troopColors[nationality];
    let darker = darkerColor(color[0], color[1], color[2]);
    if (this.b.isSeaBattle) {
      let bgroup = u.battle_group;
      if (bgroup) {
        let ibg = this.battleGroups.indexOf(bgroup);
        darker = getpal(ibg, 0, 'b', this.battleGroupPalette);
      }
    }
    let sz = this.assets.SZ.cadreDetail;
    let sz80 = sz * 0.86;
    let szImage = sz / 1.5;
    let y = szImage / 6;
    let ms = new MS(id, gName)
      .roundedRect({ className: 'ground', w: sz, h: sz, fill: color, rounding: sz * 0.1 })
      .roundedRect({ w: sz80, h: sz80, fill: darker, rounding: sz * 0.1 })
      .image({ path: imagePath, y: y, w: szImage, h: szImage })
      .roundedRect({ className: 'unit overlay', w: sz, h: sz, fill: darker, rounding: sz * 0.1 });
    ms.tag('type', type);
    ms.tag('owner', owner);
    ms.tag('nationality', nationality);
    return ms;
  }
  calcMaxUnitTypePerFaction() {
    let unitTypeCountPerFaction = {};
    let byTypeAndFaction = new CounterClass(this.b.fire_order, x => x.unit.type + '_' + x.owner);
    for (let g of cartesian(this.allUnitTypes, this.factions)) {
      let type = stringBefore(g, '_');
      let faction = stringAfter(g, '_');
      if (!(faction in unitTypeCountPerFaction)) unitTypeCountPerFaction[faction] = {};
      let count = byTypeAndFaction.get(g);
      unitTypeCountPerFaction[faction][type] = count ? count : 0;
    }
    let nColsPerFaction = {};
    for (const f of this.factions) {
      nColsPerFaction[f] = getItemWithMaxValue(unitTypeCountPerFaction[f])[1];
    }
    return nColsPerFaction;
  }
  mirror_units(data, H) {
    unitTestMirrorBattle('new data:', data);
    unitTestMirrorBattle('H:', H);
    for (const u of data.battle.fire_order) {
      let o = H.objects[u.id];
      if (u.unit.cv != o.cv) {
        this.updateCv(this.ms[u.id], o.cv);
      }
    }
    if ('dead' in data.battle) {
      for (const u of data.battle.dead) {
        if (u.id in H.objects) {
          unitTestMirrorBattle('H still contains dead unit', u.id);
        } else {
          unitTestMirrorBattle('dead unit', u.id, 'has been removed from H');
          if (u.id in this.ms) {
            let ms = this.ms[u.id];
            if (!ms.getTag('dead')) {
              this.updateCv(ms, 0);
              ms.unhighlight();
              ms.select();
              ms.tag('dead', true);
            } else {
              unitTestMirrorBattle('unit', u.id, 'has already been marked dead!!!');
            }
          } else {
            unitTestMirrorBattle('ERROR!!! dead unit', u.id, 'not in ms!!!!');
          }
        }
      }
    }
  }
  populate(dBattleOuter, gid, bg, fg) {
    let dBattleLeft = addDivClass(dBattleOuter, 'dBattleLeft', 'battleLeft');
    let dBattleRight = addDivClass(dBattleOuter, 'dBattleRight', 'battleRight');
    let dBattleMiddle = addDivClass(dBattleOuter, 'dBattleMiddle', 'battleMiddle');
    let dBattleTitle = addDivClass(dBattleMiddle, 'dBattleTitle', 'battleTitle');
    dBattleTitle.innerHTML = this.location;
    let dBattleFactions = addDivClass(dBattleMiddle, 'dBattleFactions', 'battleFactions');
    dBattleFactions.style.width = this.size.w + 'px';
    let topBottom = 25 + this.b.isSeaBattle ? 30 : 0;
    dBattleFactions.style.height = this.size.h - topBottom + 'px';
    let g1 = addSvgg(dBattleFactions, gid);
    if (this.b.isSeaBattle) {
      this.battleGroups = this.b.battle_groups;
      let dBattleGroups = addDivClass(dBattleMiddle, 'dBattleGroups', 'battleGroups');
      let n = this.battleGroups.length;
      this.battleGroupPalette = paletteFromRGBArray(assets.troopColors[this.b.attacker]);
      for (const gr of this.battleGroups) {
        let i = this.battleGroups.indexOf(gr);
        let bg = getpal(i, 0, 'b', this.battleGroupPalette);
        let fg = getpal(i, 0, 'f', this.battleGroupPalette);
        let sp = addSpanColor(dBattleGroups, 'sp' + gr, bg, fg);
        sp.innerHTML = gr;
      }
    }
    this.gid = gid;
    this.battleDiv = dBattleOuter;
    this.attackerDiceDiv = dBattleLeft;
    this.defenderDiceDiv = dBattleRight;
    let i = 0;
    for (const f of this.factions) {
      let id = 't' + i;
      i += 1;
      let x = this.xStartPerFaction[f] + this.wColsPerFaction[f] / 2;
      let msTitle = new MS(id, gid)
        .text({ txt: f, fill: fg })
        .setPos(x, 15)
        .draw();
    }
    let xStart = this.gap.w;
    let yStart = this.gap.h;
    let x = xStart;
    let y = yStart;
    let curFaction = null;
    let curType = null;
    for (const u of this.b.fire_order) {
      let type = u.unit.type;
      let faction = u.owner;
      if (faction != curFaction) {
        x = this.xStartPerFaction[faction];
      }
      if (type != curType) {
        y = this.yStartPerUnitType[type];
        x = this.xStartPerFaction[faction];
      }
      let usz = this.unitSize.w / 2;
      let ms = this.createUnit(u, 'u' + u.id, gid, type, u.unit.nationality);
      ms.setPos(x + usz, y + usz).draw();
      this.updateCv(ms, u.unit.cv);
      this.ms[u.id] = ms;
      curType = type;
      curFaction = faction;
      x += this.unitSize.w + this.gap.w;
    }
  }
  roundEnding() {
    unitTestCombatStage('roundEnding!!!');
    for (const id in this.ms) {
      this.ms[id].unhighlight();
    }
  }
  update(data, H) {
    let c = data.temp.combat;
    let b_old = this.b;
    this.b = c.battle;
    let b = this.b;
    unitTestBattle('_______b.stage:', b.stage, b);
    console.log('b.stage', b.stage);
    let message = '';
    if (b.stage == 'battle_start_ack') {
      message = 'Battle starting in ' + b.tilename.toUpperCase() + ': please accept!';
      this.selectBattle();
    } else if (b.stage == 'battle_round_start_ack') {
      message = b.attacker + ', please select active battle group!';
      this.unhighlightUnits();
      if (b.isSeaBattle) {
        for (const bg of b.battle_groups) {
          this.coverBattleGroup(bg, b);
        }
        this.battleGroupsCovered = true;
      }
    } else if (b.stage == 'select_combat_action_ack') {
      this.unhighlightUnits();
      message = b.fire.owner + ', please select combat action!';
      if (b.isSeaBattle && this.battleGroupsCovered) {
        this.uncoverBattleGroup(b.battle_group, b);
        this.battleGroupsCovered = false;
      }
      this.selectFireUnit(b);
    } else if (b.stage == 'hit_ack') {
      message = b.fire.owner + ' targeting class ' + b.target_class + ': PLEASE ACCEPT!';
      this.highlightTargetClass();
      this.startDiceAnimation(b.fire);
    } else if (b.stage == 'have_hits_ack' || b.stage == 'no_hits_ack') {
      message = b.hits + ' hits left! (accept or select type)';
      this.stopDiceAnimation(b.fire);
      if (b.hits == b.outcome) this.showHits(b.outcome);
    } else if (b.stage == 'damage_ack') {
      this.unhighlightTargetClass(b_old);
      this.selectUnitsHit(b);
      message = this.selectTheDead(b_old, b);
    } else if (b.stage == 'battle_ends_ack') {
      this.unhighlightUnits();
      this.selectTheDead(b_old, b);
      this.markMandatoryRebased(b_old, b);
      message = 'Battle ends!!';
    } else if (b.stage == 'mandatory_rebase_ack') {
      this.unhighlightUnits();
      this.highlightANS(H.player);
      message = 'Select mandatory rebase option!!';
    } else if (b.stage == 'retreat_ack') {
      message = b.selectedRetreatUnit + ' HAS RETREATED TO ' + b.selectedRetreatTile;
      this.markAsRetreated(b.fire.id);
    } else {
      return 'NOT IMPLEMENTED!!!!!';
    }
    unitTestBattle('____________');
    return message;
  }
  update_dep(data, H) {
    let c = data.temp.combat;
    if (c.battle.isSeaBattle) return this.updateSeaBattle(data, H);
    let b_old = this.b;
    let b = (this.b = c.battle);
    unitTestBattle('_______b.stage:', b.stage, b);
    let message = '';
    if (b.stage == 'battle_start_ack') {
      message = 'BATTLE STARTING IN ' + b.tilename.toUpperCase() + ': PLEASE ACCEPT!';
      this.selectBattle();
    } else if (b.stage == 'select_command') {
      message = 'SELECT TARGET CLASS OR RETREAT OPTIONS OR ACCEPT!!!';
      this.selectFireUnit();
    } else if (b.stage == 'ack_combat_action') {
      this.selectFireUnit();
      if (b.combat_action == 'hit') {
        message = b.fire.owner + ' TARGETING CLASS ' + b.target_class + ': PLEASE ACCEPT!';
        this.highlightTargetClass();
        this.startDiceAnimation(b.fire);
      } else {
        message = b.fire.owner + ' RETREATING TO ' + b.retreat_options[0][1] + ': PLEASE ACCEPT!';
      }
    } else if (b.stage == 'select_hit_type') {
      message = b.outcome + ' HITS, PLEASE SELECT TYPE TO HIT FIRST!';
      this.stopDiceAnimation(b.fire);
      this.showHits(b.outcome);
    } else if (b.stage == 'ack_retreat') {
      message = b.selectedRetreatUnit + ' HAS RETREATED TO ' + b.selectedRetreatTile;
      this.markAsRetreated(b.fire.id);
    } else if (b.stage == 'select_mandatory_rebase') {
      this.markMandatoryRebased(b_old, b);
      message = H.player + ', SELECT MANDATORY REBASE OPTION';
      this.unhighlightUnits();
      this.highlightANS(H.player);
    } else if (b.stage == 'accept_outcome') {
      if (this.diceRolling) {
        message = b.outcome + ' HITS HITTING ' + b.units_hit.map(u => u.id + '(' + u.type + ')').join(' ') + ': PLEASE ACCEPT!';
        this.stopDiceAnimation(b.fire);
        this.showHits(b.outcome);
        let f = b.fire_order[b.idx];
      } else {
        message = this.selectTheDead(b_old, b);
      }
    } else if (b.stage == 'ack_combat_action_done') {
      this.unhighlightTargetClass(b_old);
      if (b.combat_action == 'hit') {
        message = this.selectTheDead(b_old, b);
      } else {
        message = b.fire.id + ' has retreated. Please accept!';
      }
    } else if (b.stage == 'ack_battle_interrupted_no_enemy_units_left') {
      if (b.combat_action == 'hit') {
        this.selectTheDead(b_old, b);
      }
      message = 'BATTLE ENDS HERE: NO ENEMY UNITS LEFT!!!';
    } else if (b.stage == 'ack_battle_decided') {
      if (b.winner == b.owner) {
        message = b.winner + ' has defended his territory! please accept!';
      } else {
        message = b.winner + ' has conquered new territory!!! please accept!';
      }
      this.selectTheDead(b_old, b);
    } else if (b.stage == 'ack_cleanup_battle') {
      message = 'battle in ' + b.tilename + ' is ending! please accept!';
      this.unhighlightUnits();
      this.markMandatoryRebased(b_old, b);
      this.unselectBattle();
    }
    if (b.stage == 'battle_round_start_ack') {
      message = b.attacker + ', please select active battle group!';
      this.highlightBattleGroups(b);
    }
    unitTestBattle('____________');
    return message;
  }
  updateSeaBattle(data, H) {
    let c = data.temp.combat;
    let b_old = this.b;
    this.b = c.battle;
    let b = this.b;
    unitTestBattle('_______b.stage:', b.stage, b);
    let message = '';
    if (b.stage == 'battle_start_ack') {
      message = 'BATTLE STARTING IN ' + b.tilename.toUpperCase() + ': PLEASE ACCEPT!';
      this.selectBattle();
    } else if (b.stage == 'battle_round_start_ack') {
      message = b.attacker + ', please select active battle group!';
      this.highlightBattleGroups(b);
    } else if (b.stage == 'select_combat_action_ack') {
      message = b.attacker + ', please select combat action!';
      this.coverOtherBattleGroups(b);
      this.selectFireUnit(b);
    }
    if (b.stage == 'ack_combat_action') {
      this.selectFireUnit();
      if (b.combat_action == 'hit') {
        message = b.fire.owner + ' TARGETING CLASS ' + b.target_class + ': PLEASE ACCEPT!';
        this.highlightTargetClass();
        this.startDiceAnimation(b.fire);
      } else {
        message = b.fire.owner + ' RETREATING TO ' + b.retreat_options[0][1] + ': PLEASE ACCEPT!';
      }
    } else if (b.stage == 'select_hit_type') {
      message = b.outcome + ' HITS, PLEASE SELECT TYPE TO HIT FIRST!';
      this.stopDiceAnimation(b.fire);
      this.showHits(b.outcome);
    } else if (b.stage == 'ack_retreat') {
      message = b.selectedRetreatUnit + ' HAS RETREATED TO ' + b.selectedRetreatTile;
      this.markAsRetreated(b.fire.id);
    } else if (b.stage == 'select_mandatory_rebase') {
      this.markMandatoryRebased(b_old, b);
      message = H.player + ', SELECT MANDATORY REBASE OPTION';
      this.unhighlightUnits();
      this.highlightANS(H.player);
    } else if (b.stage == 'accept_outcome') {
      if (this.diceRolling) {
        message = b.outcome + ' HITS HITTING ' + b.units_hit.map(u => u.id + '(' + u.type + ')').join(' ') + ': PLEASE ACCEPT!';
        this.stopDiceAnimation(b.fire);
        this.showHits(b.outcome);
        let f = b.fire_order[b.idx];
      } else {
        message = this.selectTheDead(b_old, b);
      }
    } else if (b.stage == 'ack_combat_action_done') {
      this.unhighlightTargetClass(b_old);
      if (b.combat_action == 'hit') {
        message = this.selectTheDead(b_old, b);
      } else {
        message = b.fire.id + ' has retreated. Please accept!';
      }
    } else if (b.stage == 'ack_battle_interrupted_no_enemy_units_left') {
      if (b.combat_action == 'hit') {
        this.selectTheDead(b_old, b);
      }
      message = 'BATTLE ENDS HERE: NO ENEMY UNITS LEFT!!!';
    } else if (b.stage == 'ack_battle_decided') {
      if (b.winner == b.owner) {
        message = b.winner + ' has defended his territory! please accept!';
      } else {
        message = b.winner + ' has conquered new territory!!! please accept!';
      }
      this.selectTheDead(b_old, b);
    } else if (b.stage == 'ack_cleanup_battle') {
      message = 'battle in ' + b.tilename + ' is ending! please accept!';
      this.unhighlightUnits();
      this.markMandatoryRebased(b_old, b);
      this.unselectBattle();
    }
    unitTestBattle('____________');
    return message;
  }
  updateCv(ms, cv) {
    ms.removeFromChildIndex(5);
    let sz = this.assets.SZ.cadreDetail;
    let dx = sz / (cv + 1);
    let xStart = -sz / 2;
    let y = -sz / 3.2;
    let diam = Math.min(dx / 1.5, sz / 5);
    let x = dx + xStart;
    for (let i = 0; i < cv; i++) {
      ms.circle({ sz: diam, x: x, y: y, fill: 'white' });
      x += dx;
    }
    ms.tag('cv', cv);
  }
}
class ABattleSea {
  constructor(assets, loc, b, stage) {
    this.assets = assets;
    this.location = loc;
    this.b = b;
    this.stage = stage;
    this.roundCounter = 0;
    this.factions = [b.attacker, b.defender];
    this.allUnitTypes = Array.from(new Set(b.fire_order.map(x => x.unit.type)));
    this.battle_groups = b.battle_groups;
    console.log('battle_groups', this.battle_groups)
    this.ms = {};
    this.selected = false;
    this.msFire = null;
    this.nColsPerFaction = this.calcMaxUnitTypePerFaction();
    let hTitle = 25 * 2;
    let usz = assets.SZ.cadreDetail;
    let hGap = 4;
    let hRow = usz + hGap;
    let hTotal = hRow * this.allUnitTypes.length + hTitle + 2 * hGap;
    let wGap = hGap;
    let wFactionGap = 10 * hGap;
    let wCol = usz + wGap;
    let wColTotal = Object.values(this.nColsPerFaction).reduce((a, b) => a + b, 0);
    let wColsPerFaction = {};
    let xStartPerFaction = {};
    let xAkku = wGap;
    for (const f of this.factions) {
      wColsPerFaction[f] = this.nColsPerFaction[f] * wCol;
      xStartPerFaction[f] = xAkku;
      xAkku += wColsPerFaction[f] + wFactionGap;
    }
    let yStartPerUnitType = {};
    let yAkku = hGap + 25;
    for (const t of this.allUnitTypes) {
      yStartPerUnitType[t] = yAkku;
      yAkku += hRow;
    }
    this.xStartPerFaction = xStartPerFaction;
    this.yStartPerUnitType = yStartPerUnitType;
    this.wColsPerFaction = wColsPerFaction;
    let wTotal = wGap + wColTotal * wCol + wFactionGap * this.factions.length + wGap;
    this.size = { w: wTotal, h: hTotal };
    this.unitSize = { w: wCol, h: hRow };
    this.gap = { w: wGap, h: hGap, col: wFactionGap };
  }
  selectBattle() {
    this.battleDiv.style.border = '4px solid yellow';
  }
  unselectBattle() {
    this.battleDiv.style.border = '1px solid ' + getpal(6);
  }
  selectFireUnit() {
    if (this.msFire) this.msFire.unhighlight();
    this.msFire = this.ms[this.b.fire.id];
    this.msFire.highlight();
  }
  unhightlightUnits() {
    for (const id in this.ms) {
      let ms = this.ms[id];
      console.log('unhighlighting', ms.getTag('owner'), ms.getTag('type'));
      ms.unhighlight();
    }
  }
  highlightANS(pl) {
    for (const id in this.ms) {
      let ms = this.ms[id];
      let type = ms.getTag('type');
      let owner = ms.getTag('owner');
      if (owner == pl && isANS(type)) {
        if (!ms.getTag('dead') && !ms.getTag('removed')) {
          ms.highlight();
        }
      }
    }
  }
  highlightTargetClass() {
    for (const id in this.b.target_units) {
      let ms = this.ms[id];
      ms.highlight();
    }
  }
  unhighlightTargetClass() {
    for (const id in this.b.target_units) {
      let ms = this.ms[id];
      ms.unhighlight();
    }
  }
  markMandatoryRebased(b_old, b) {
    for (const u of b_old.fire_order) {
      let id = u.id;
      let unitInB = firstCond(b.fire_order, x => x.id == id);
      if (!unitInB) {
        this.markAsRetreated(id);
      }
    }
  }
  markAsRetreated(id) {
    let ms = this.ms[id];
    ms.unhighlight();
    ms.selKeyColor('darkSlateGrey', 'retreated', 0.7);
    ms.tag('removed', true);
  }
  selectTheDead(b_old, b_new) {
    let degraded = '';
    let removed = '';
    let message = '';
    for (const u of b_old.fire_order) {
      let id = u.id;
      let ms = this.ms[id];
      let uNew = firstCond(b_new.fire_order, x => x.id == id);
      if (uNew) {
        let cv_old = u.unit.cv;
        let cv_new = uNew.unit.cv;
        if (cv_old != cv_new) {
          this.updateCv(ms, cv_new);
          degraded += ' ' + id.toString();
        }
      } else {
        this.updateCv(ms, 0);
        ms.selColor('black', 0.8);
        ms.tag('dead', true);
        removed += ' ' + id.toString();
      }
    }
    if (!empty(degraded)) message += degraded + ' degraded. ';
    if (!empty(removed)) message += removed + ' removed. ';
    message += 'Please accept!';
    return message;
  }
  startDiceAnimation(fire) {
    this.fire = fire;
    let dDice = fire.owner == this.b.attacker ? this.attackerDiceDiv : this.defenderDiceDiv;
    this.diceRolling = true;
    dDice.classList.add('pulseOn');
  }
  stopDiceAnimation(fire) {
    let dDice = fire.owner == this.b.attacker ? this.attackerDiceDiv : this.defenderDiceDiv;
    dDice.classList.remove('pulseOn');
    this.diceRolling = false;
  }
  showHits(hits) {
    let dDice = this.b.fire.owner == this.b.attacker ? this.attackerDiceDiv : this.defenderDiceDiv;
    let html = dDice.innerHTML;
    dDice.innerHTML = html + '<br>' + hits;
  }
  addUnit(id, gName, type, nationality, cv, x, y) {
    let ms = this.createUnit(id, gName, type, nationality);
    ms.setPos(x, y).draw();
    this.updateCv(ms, cv);
    return ms;
  }
  createUnit(id, gName, type, nationality) {
    let owner = getUnitOwner(nationality);
    let imagePath = '/a/assets/images/' + type + '.svg';
    let isMinorColor = !(nationality in this.assets.troopColors);
    let color = isMinorColor ? this.assets.troopColors['Minor'] : this.assets.troopColors[nationality];
    let darker = darkerColor(color[0], color[1], color[2]);
    let sz = this.assets.SZ.cadreDetail;
    let sz80 = sz * 0.86;
    let szImage = sz / 1.5;
    let y = szImage / 6;
    let ms = new MS(id, gName)
      .roundedRect({ className: 'ground', w: sz, h: sz, fill: color, rounding: sz * 0.1 })
      .roundedRect({ w: sz80, h: sz80, fill: darker, rounding: sz * 0.1 })
      .image({ path: imagePath, y: y, w: szImage, h: szImage })
      .roundedRect({ className: 'unit overlay', w: sz, h: sz, fill: darker, rounding: sz * 0.1 });
    ms.tag('type', type);
    ms.tag('owner', owner);
    ms.tag('nationality', nationality);
    return ms;
  }
  calcMaxUnitTypePerFaction() {
    let unitTypeCountPerFaction = {};
    let byTypeAndFaction = new CounterClass(this.b.fire_order, x => x.unit.type + '_' + x.owner);
    for (let g of cartesian(this.allUnitTypes, this.factions)) {
      let type = stringBefore(g, '_');
      let faction = stringAfter(g, '_');
      if (!(faction in unitTypeCountPerFaction)) unitTypeCountPerFaction[faction] = {};
      let count = byTypeAndFaction.get(g);
      unitTypeCountPerFaction[faction][type] = count ? count : 0;
    }
    let nColsPerFaction = {};
    for (const f of this.factions) {
      nColsPerFaction[f] = getItemWithMaxValue(unitTypeCountPerFaction[f])[1];
    }
    return nColsPerFaction;
  }
  mirror_units(data, H) {
    unitTestMirrorBattle('new data:', data);
    unitTestMirrorBattle('H:', H);
    for (const u of data.battle.fire_order) {
      let o = H.objects[u.id];
      if (u.unit.cv != o.cv) {
        this.updateCv(this.ms[u.id], o.cv);
      }
    }
    if ('dead' in data.battle) {
      for (const u of data.battle.dead) {
        if (u.id in H.objects) {
          unitTestMirrorBattle('H still contains dead unit', u.id);
        } else {
          unitTestMirrorBattle('dead unit', u.id, 'has been removed from H');
          if (u.id in this.ms) {
            let ms = this.ms[u.id];
            if (!ms.getTag('dead')) {
              this.updateCv(ms, 0);
              ms.unhighlight();
              ms.select();
              ms.tag('dead', true);
            } else {
              unitTestMirrorBattle('unit', u.id, 'has already been marked dead!!!');
            }
          } else {
            unitTestMirrorBattle('ERROR!!! dead unit', u.id, 'not in ms!!!!');
          }
        }
      }
    }
  }
  populate(dBattleOuter, gid, bg, fg) {
    let dBattleLeft = addDivClass(dBattleOuter, 'dBattleLeft', 'battleLeft');
    let dBattleRight = addDivClass(dBattleOuter, 'dBattleRight', 'battleRight');
    let dBattleMiddle = addDivClass(dBattleOuter, 'dBattleMiddle', 'battleMiddle');
    let dBattleTitle = addDivClass(dBattleMiddle, 'dBattleTitle', 'battleTitle');
    dBattleTitle.innerHTML = this.location;
    let dBattleFactions = addDivClass(dBattleMiddle, 'dBattleFactions', 'battleFactions');
    dBattleFactions.style.width = this.size.w + 'px';
    dBattleFactions.style.height = this.size.h - 25 + 'px';
    let g1 = addSvgg(dBattleFactions, gid);
    this.gid = gid;
    this.battleDiv = dBattleOuter;
    this.attackerDiceDiv = dBattleLeft;
    this.defenderDiceDiv = dBattleRight;
    let i = 0;
    for (const f of this.factions) {
      let id = 't' + i;
      i += 1;
      let x = this.xStartPerFaction[f] + this.wColsPerFaction[f] / 2;
      let msTitle = new MS(id, gid)
        .text({ txt: f, fill: fg })
        .setPos(x, 15)
        .draw();
    }
    let xStart = this.gap.w;
    let yStart = this.gap.h;
    let x = xStart;
    let y = yStart;
    let curFaction = null;
    let curType = null;
    for (const u of this.b.fire_order) {
      let type = u.unit.type;
      let faction = u.owner;
      if (faction != curFaction) {
        x = this.xStartPerFaction[faction];
      }
      if (type != curType) {
        y = this.yStartPerUnitType[type];
        x = this.xStartPerFaction[faction];
      }
      let usz = this.unitSize.w / 2;
      let ms = this.createUnit('u' + u.id, gid, type, u.unit.nationality);
      ms.setPos(x + usz, y + usz).draw();
      this.updateCv(ms, u.unit.cv);
      this.ms[u.id] = ms;
      curType = type;
      curFaction = faction;
      x += this.unitSize.w + this.gap.w;
    }
  }
  roundEnding() {
    unitTestCombatStage('roundEnding!!!');
    for (const id in this.ms) {
      this.ms[id].unhighlight();
    }
  }
  update(data, H) {
    let c = data.temp.combat;
    let b_old = this.b;
    let b = (this.b = c.battle);
    unitTestBattle('_______b.stage:', b.stage, b);
    let message = '';
    if (b.stage == 'battle_start_ack') {
      message = 'BATTLE STARTING IN ' + b.tilename.toUpperCase() + ': PLEASE ACCEPT!';
      this.selectBattle();
    } else if (b.stage == 'select_command') {
      message = 'SELECT TARGET CLASS OR RETREAT OPTIONS OR ACCEPT!!!';
      this.selectFireUnit();
    } else if (b.stage == 'ack_combat_action') {
      this.selectFireUnit();
      if (b.combat_action == 'hit') {
        message = b.fire.owner + ' TARGETING CLASS ' + b.target_class + ': PLEASE ACCEPT!';
        this.highlightTargetClass();
        this.startDiceAnimation(b.fire);
      } else {
        message = b.fire.owner + ' RETREATING TO ' + b.retreat_options[0][1] + ': PLEASE ACCEPT!';
      }
    } else if (b.stage == 'select_hit_type') {
      message = b.outcome + ' HITS, PLEASE SELECT TYPE TO HIT FIRST!';
      this.stopDiceAnimation(b.fire);
      this.showHits(b.outcome);
    } else if (b.stage == 'ack_retreat') {
      message = b.selectedRetreatUnit + ' HAS RETREATED TO ' + b.selectedRetreatTile;
      this.markAsRetreated(b.fire.id);
    } else if (b.stage == 'select_mandatory_rebase') {
      this.markMandatoryRebased(b_old, b);
      message = H.player + ', SELECT MANDATORY REBASE OPTION';
      this.unhightlightUnits();
      this.highlightANS(H.player);
    } else if (b.stage == 'accept_outcome') {
      if (this.diceRolling) {
        message = b.outcome + ' HITS HITTING ' + b.units_hit.map(u => u.id + '(' + u.type + ')').join(' ') + ': PLEASE ACCEPT!';
        this.stopDiceAnimation(b.fire);
        this.showHits(b.outcome);
        let f = b.fire_order[b.idx];
      } else {
        message = this.selectTheDead(b_old, b);
      }
    } else if (b.stage == 'ack_combat_action_done') {
      this.unhighlightTargetClass(b_old);
      if (b.combat_action == 'hit') {
        message = this.selectTheDead(b_old, b);
      } else {
        message = b.fire.id + ' has retreated. Please accept!';
      }
    } else if (b.stage == 'ack_battle_interrupted_no_enemy_units_left') {
      if (b.combat_action == 'hit') {
        this.selectTheDead(b_old, b);
      }
      message = 'BATTLE ENDS HERE: NO ENEMY UNITS LEFT!!!';
    } else if (b.stage == 'ack_battle_decided') {
      if (b.winner == b.owner) {
        message = b.winner + ' has defended his territory! please accept!';
      } else {
        message = b.winner + ' has conquered new territory!!! please accept!';
      }
      this.selectTheDead(b_old, b);
    } else if (b.stage == 'ack_cleanup_battle') {
      message = 'battle in ' + b.tilename + ' is ending! please accept!';
      this.unhightlightUnits();
      this.markMandatoryRebased(b_old, b)
      this.unselectBattle();
    }
    unitTestBattle('____________');
    return message;
  }
  updateCv(ms, cv) {
    ms.removeFromChildIndex(5);
    let sz = this.assets.SZ.cadreDetail;
    let dx = sz / (cv + 1);
    let xStart = -sz / 2;
    let y = -sz / 3.2;
    let diam = Math.min(dx / 1.5, sz / 5);
    let x = dx + xStart;
    for (let i = 0; i < cv; i++) {
      ms.circle({ sz: diam, x: x, y: y, fill: 'white' });
      x += dx;
    }
    ms.tag('cv', cv);
  }
}
class AbsGraph1 {
  constructor() {
    let defOptions = {
      maxZoom: 1,
      minZoom: .001,
      motionBlur: false,
      wheelSensitivity: 0.05,
      zoomingEnabled: false,
      userZoomingEnabled: false,
      panningEnabled: false,
      userPanningEnabled: false,
      boxSelectionEnabled: false,
      layout: { name: 'preset' },
      elements: [],
    };
    this.cy = cytoscape(defOptions);
  }
  clear() { this.cy.destroy(); }
  //#region access and algos
  getComponents() { return this.cy.elements().components(); }
  getComponentIds() { return this.cy.elements().components().map(x => x.id()); }
  getCommonEdgeId(nid1, nid2) { return nid1 + '_' + nid2; }
  getNumComponents() { return this.cy.elements().components().length; }
  getNode(id) { return this.cy.getElementById(id); }
  getNodes() { return this.cy.nodes(); }
  getNodeIds() { return this.cy.nodes().map(x => x.id()); }
  getNodeData() { return this.cy.nodes().map(x => x.data()); }
  getNodePositions() { return this.cy.nodes.map(x => x.position()); }
  getEdges() { return this.cy.edges(); }
  getEdgeIds() { return this.cy.edges().map(x => x.id()); }
  getPosition(id) {
    let node = this.getNode(id);
    let pos = node.renderedPosition();
    return pos;
  }
  setPosition(id, x, y) { this.cy.getElementById(id).position({ x: x, y: y }); }
  setProp(id, prop, val) { this.cy.getElementById(id).data()[prop] = val; }
  getProp(id, prop) { return this.cy.getElementById(id).data()[prop]; }
  getDegree(id) { return this.cy.nodes('#' + id).degree(); }
  getNodeWithMaxDegree(idlist) {
    if (nundef(idlist)) idlist = this.cy.elements().filter('node').map(x => x.data().id);
    let imax = arrMinMax(idlist, x => this.getDegree(x)).imax;
    let id = idlist[imax];
    return id;
  }
  getShortestPathsFrom(id) { let res = this.cy.elements().dijkstra('#' + id); return res; }
  getShortestPathFromTo(nid1, nid2) {
    let funcs = this.dijkstra = this.getShortestPathsFrom(nid1);
    let path = funcs.pathTo('#' + nid2);
    return path;
  }
  getLengthOfShortestPath(nid1, nid2) {
    let funcs = this.dijkstra = this.getShortestPathsFrom(nid1);
    let len = funcs.distanceTo('#' + nid2);
    return len;
  }
  storeCurrentPositions(prop = 'center') {
    for (const n of this.getNodes()) {
      let id = n.id();
      let pos = this.getPosition(id);
      this.setProp(id, prop, pos);
    }
  }
  setPositionData(prop = 'center') {
    let ids = this.getNodeIds();
    for (const id of ids) {
      let pos = this.getProp(id, prop);
      if (isdef(pos)) this.setPosition(id, pos.x, pos.y);
      else return false;
    }
    return true;
  }
  sortNodesByDegree(idlist, descending = true) {
    if (nundef(idlist)) idlist = this.cy.nodes.map(x => x.data().id);
    let nodes = idlist.map(x => this.getNode(x));
    for (const n of nodes) {
      n.degree = this.getDegree(n.id());
    }
    if (descending) sortByDescending(nodes, 'degree'); else sortBy(nodes, 'degree');
    return nodes;
  }
  //#endregion
  //#region modify nodes, edges
  addNode(data, coords) {
    if (nundef(data)) data = {};
    if (nundef(data.id)) data.id = getFruid();
    if (isdef(coords)) {
      coords.x -= this.cy.pan().x;
      coords.y -= this.cy.pan().y;
    } else { coords = { x: 0, y: 0 }; }
    var ele = this.cy.add({
      group: 'nodes',
      data: data,
      position: coords
    });
    return ele.id();
  }
  addNodes(n, datalist, coordlist) {
    let ids = [];
    if (nundef(datalist)) datalist = new Array(n).map(x => ({ id: getFruid() }));
    if (nundef(coordlist)) coordlist = new Array(n).map(x => ({ coords: { x: 0, y: 0 } }));
    for (let i = 0; i < n; i++) {
      let id = this.addNode(datalist[i], coordlist[i]);
      ids.push(id);
    }
    return ids;
  }
  addEdge(nid1, nid2, data) {
    if (nundef(data)) data = {};
    data.id = this.getCommonEdgeId(nid1, nid2);
    data.source = nid1;
    data.target = nid2;
    var ele = this.cy.add({
      group: 'edges',
      data: data,
    });
    return ele.id();
  }
  addEdges(nOrNodePairList) {
    if (isNumber(nOrNodePairList)) {
      let nids = this.getNodeIds();
      let prod = arrPairs(nids);
      nOrNodePairList = choose(prod, nOrNodePairList);
    }
    let res = [];
    for (const pair of nOrNodePairList) {
      res.push(this.addEdge(pair[0], pair[1]));
    }
    return res;
  }
  removeNode(node) { this.removeElement(node); return this.getNodeIds(); }
  removeEdge(edge) { this.removeElement(edge); return this.getEdgeIds(); }
  removeElement(ne) { if (!isString(ne)) ne = ne.id(); this.cy.getElementById(ne).remove(); }
  //#endregion
  //#region layouts
  breadthfirst() { this.cy.layout({ name: 'breadthfirst', animate: true }).run(); }
  circle() { this.cy.layout({ name: 'circle', animate: 'end' }).run(); }
  concentric() { this.cy.layout({ name: 'concentric', animate: true }).run(); }
  comcola() {
    let defaults = {
      name: 'cola',
      animate: true,
      refresh: 1,
      maxSimulationTime: 4000,
      ungrabifyWhileSimulating: false,
      fit: true,
      padding: 30,
      boundingBox: undefined,
      nodeDimensionsIncludeLabels: false,
      ready: function () { },
      stop: function () { },
      randomize: false,
      avoidOverlap: true,
      handleDisconnected: true,
      convergenceThreshold: 0.01,
      nodeSpacing: function (node) { return 10; },
      flow: undefined,
      alignment: undefined,
      gapInequalities: undefined,
      edgeLength: undefined,
      edgeSymDiffLength: undefined,
      edgeJaccardLength: undefined,
      unconstrIter: undefined,
      userConstIter: undefined,
      allConstIter: undefined,
      infinite: false
    };
    let options = {
      name: 'cola',
      convergenceThreshold: 100,
      boundingBox: { x1: 20, y1: 20, w: 200, h: 200 },
    };
    copyKeys(options, defaults);
    console.log(defaults.boundingBox)
    this.cy.layout(defaults).run();
  }
  cose() { this.cy.layout({ name: 'cose', animate: 'end' }).run(); }
  euler() { this.cy.layout({ name: 'euler', fit: true, padding: 25, animate: 'end' }).run(); }
  fcose() {
    var defaultOptions = {
      quality: "default",
      randomize: true,
      animate: true,
      animationDuration: 500,
      animationEasing: undefined,
      fit: true,
      padding: 30,
      nodeDimensionsIncludeLabels: false,
      uniformNodeDimensions: false,
      packComponents: true,
      step: "all",
      samplingType: true,
      sampleSize: 25,
      nodeSeparation: 75,
      piTol: 0.0000001,
      nodeRepulsion: node => 4500,
      idealEdgeLength: edge => 50,
      edgeElasticity: edge => 0.45,
      nestingFactor: 0.1,
      numIter: 2500,
      tile: true,
      tilingPaddingVertical: 10,
      tilingPaddingHorizontal: 10,
      gravity: 0.25,
      gravityRangeCompound: 1.5,
      gravityCompound: 1.0,
      gravityRange: 3.8,
      initialEnergyOnIncremental: 0.3,
      fixedNodeConstraint: undefined,
      alignmentConstraint: undefined,
      relativePlacementConstraint: undefined,
      ready: () => { },
      stop: () => { },
      name: 'fcose',
    };
    this.cy.layout(defaultOptions).run();
  }
  gridLayout() { this.cy.layout({ name: 'grid', animate: true }).run(); }
  presetLayout() {
    let hasCenterProp = this.setPositionData();
    if (!hasCenterProp) {
      console.log('no positions are preset: store first!');
    } else {
      let options = {
        name: 'preset',
        positions: undefined,
        zoom: undefined,
        pan: undefined,
        fit: true,
        padding: 30,
        animate: true,
        animationDuration: 500,
        animationEasing: undefined,
        animateFilter: function (node, i) { return true; },
        ready: undefined,
        stop: undefined,
        transform: function (node, position) { return position; }
      };
      this.cy.layout(options);
      this.reset();
    }
  }
  randomLayout() { this.cy.layout({ name: 'random', animate: 'true' }).run(); }
  klay() {
    let klayDefaults = {
      // Following descriptions taken from http://layout.rtsys.informatik.uni-kiel.de:9444/Providedlayout.html?algorithm=de.cau.cs.kieler.klay.layered
      addUnnecessaryBendpoints: false,
      aspectRatio: 1.6,
      borderSpacing: 20,
      compactComponents: false,
      crossingMinimization: 'LAYER_SWEEP',
      cycleBreaking: 'GREEDY',
      direction: 'UNDEFINED',
      edgeRouting: 'ORTHOGONAL',
      edgeSpacingFactor: 0.5,
      feedbackEdges: false,
      fixedAlignment: 'NONE',
      inLayerSpacingFactor: 1.0,
      layoutHierarchy: false,
      linearSegmentsDeflectionDampening: 0.3,
      mergeEdges: false,
      mergeHierarchyCrossingEdges: true,
      nodeLayering: 'NETWORK_SIMPLEX',
      nodePlacement: 'BRANDES_KOEPF',
      randomizationSeed: 1,
      routeSelfLoopInside: false,
      separateConnectedComponents: true,
      spacing: 20,
      thoroughness: 7
    };
    var options = {
      nodeDimensionsIncludeLabels: false,
      fit: true,
      padding: 20,
      animate: true,
      animateFilter: function (node, i) { return true; },
      animationDuration: 500,
      animationEasing: undefined,
      transform: function (node, pos) { return pos; },
      ready: this.reset.bind(this),
      stop: undefined,
      klay: {
        addUnnecessaryBendpoints: false,
        aspectRatio: 1.6,
        borderSpacing: 20,
        compactComponents: false,
        crossingMinimization: 'LAYER_SWEEP',
        cycleBreaking: 'GREEDY',
        direction: 'UNDEFINED',
        edgeRouting: 'ORTHOGONAL',
        edgeSpacingFactor: 0.5,
        feedbackEdges: false,
        fixedAlignment: 'NONE',
        inLayerSpacingFactor: 1.0,
        layoutHierarchy: false,
        linearSegmentsDeflectionDampening: 0.3,
        mergeEdges: false,
        mergeHierarchyCrossingEdges: true,
        nodeLayering: 'NETWORK_SIMPLEX',
        nodePlacement: 'INTERACTIVE',
        randomizationSeed: 1,
        routeSelfLoopInside: false,
        separateConnectedComponents: true,
        spacing: 20,
        thoroughness: 3
      },
      name: 'klay',
      priority: function (edge) { return null; },
    };
    this.cy.layout(options).run();
  }
  //#endregion
  //#region ui functions
  fit() { this.cy.fit(); }
  center() { this.cy.center(); this.cy.fit(); }
  reset() { this.pan0(); this.zoom1(); this.center(); }
  pan0() { this.cy.pan({ x: 0, y: 0 }); }
  zoom1() { this.cy.zoom(1); }
  isPan() { return this.cy.panningEnabled(); }
  isZoom() { return this.cy.zoomingEnabled(); }
  enablePanZoom() { this.pan(true); this.zoom(true); }
  pan(isOn, reset = true) {
    this.cy.panningEnabled(isOn);
    this.cy.userPanningEnabled(isOn);
    if (!isOn && reset) { this.pan0(); this.center(); }
  }
  zoom(isOn, minZoom = .25, maxZoom = 1, reset = true) {
    this.cy.zoomingEnabled(isOn);
    this.cy.userZoomingEnabled(isOn);
    if (!isOn && reset) { this.zoom1(); this.center(); }
    else if (isOn) { this.cy.minZoom(minZoom); this.cy.maxZoom(maxZoom); }
  }
  closeLayoutControls() { if (isdef(this.sb)) hide(this.sb); }
  addLayoutControls(sb, buttonlist) {
    let buttons = {
      BFS: mButton('BFS', () => this.breadthfirst(), sb, {}, ['tbb']),
      circle: mButton('circle', () => this.circle(), sb, {}, ['tbb']),
      CC: mButton('CC', () => this.concentric(), sb, {}, ['tbb']),
      cola: mButton('cola', () => this.comcola(), sb, {}, ['tbb']),
      cose: mButton('cose', () => this.cose(), sb, {}, ['tbb']),
      euler: mButton('euler', () => this.euler(), sb, {}, ['tbb']),
      fcose: mButton('fcose', () => this.fcose(), sb, {}, ['tbb']),
      grid: mButton('grid', () => this.gridLayout(), sb, {}, ['tbb']),
      klay: mButton('klay', () => this.klay(), sb, {}, ['tbb']),
      prest: mButton('prest', () => this.presetLayout(), sb, {}, ['tbb']),
      rand: mButton('rand', () => this.randomLayout(), sb, {}, ['tbb']),
      reset: mButton('reset', () => this.reset(), sb, {}, ['tbb']),
      fit: mButton('fit', () => this.fit(), sb, {}, ['tbb']),
      show: mButton('show', () => this.showGraph(), sb, {}, ['tbb']),
      hide: mButton('hide', () => this.hideGraph(), sb, {}, ['tbb']),
      store: mButton('store', () => this.storeCurrentPositions(), sb, {}, ['tbb']),
    };
    for (const b in buttons) {
      if (isdef(buttonlist) && !buttonlist.includes(b)) hide(buttons[b]);
    }
    return buttons;
  }
  addVisual(dParent, styles = {}) {
    if (this.hasVisual) return;
    this.hasVisual = true;
    this.id = nundef(dParent.id) ? getUID() : dParent.id;
    let styleDict = {
      node: { 'width': 25, 'height': 25, 'background-color': 'red', "color": "#fff", 'label': 'data(id)', "text-valign": "center", "text-halign": "center", },
      edge: { 'width': 2, 'line-color': 'silver', 'curve-style': 'haystack', },
      'node.highlight': { 'background-color': 'yellow' },
      'node.trans': { 'opacity': '0.5' },
    }
    for (const ks of ['node', 'edge', 'node.highlight', 'node.trans']) {
      if (isdef(styles[ks])) {
        for (const k in styles[ks]) {
          let [prop, val] = translateToCssStyle(k, styles[ks][k], false);
          styleDict[ks][prop] = val;
        }
      }
    }
    let cyStyle = [];
    for (const k in styleDict) { cyStyle.push({ selector: k, style: styleDict[k] }); }
    let size = getSize(dParent);
    let d1 = mDiv(dParent, { position: 'relative', bg: 'green', w: size.w, left: 0, top: 0, h: size.h, align: 'left' });
    this.cy.mount(d1);
    this.cy.style(cyStyle);
    this.enablePanZoom();
    iAdd(this, { div: dParent, dCy: d1 });
  }
  //#endregion
}
class ACards {
  constructor(assets) {
    this.assets = assets;
    this.hands = {};
    this.player = null;
    for (const f of ['Axis', 'West', 'USSR']) {
      let hand = new AHand(this.assets, 'handG_' + f, 'hand_area', f);
      this.hands[f] = hand;
    }
    this.hands['openCards'] = new AHand(this.assets, 'openCardG', 'cards2_area', 'open');
    this.visibleHand = null;
  }
  createCard(id, o) {
    let hand = this.findCardHand(o);
    if (hand) {
      let ms = hand.addNew(id, o);
    }
  }
  findCardHand(o) {
    let vis = getVisibleSet(o);
    if (!vis || (!('owner' in o) && vis.length < 3)) return null;
    if (vis.length < 3) {
      return this.hands[o.owner];
    } else {
      return this.hands['openCards'];
    }
  }
  getCardMs(id) {
    if (this.inVisibleHand(id)) {
      return this.visibleHand.cards[id].ms;
    } else return null;
  }
  inVisibleHand(id) {
    return this.visibleHand == null ? false : id in this.visibleHand.cards;
  }
  updateHandView(player) {
    for (const pl of ['Axis', 'USSR', 'West']) {
      let hand = this.hands[pl];
      if (pl == player) {
        hand.show();
      } else hand.hide();
    }
  }
  update(player, data, G) {
    if (player != this.player) {
      this.updateHandView(player);
      this.player = player;
      this.visibleHand = this.hands[player];
    }
    if (!('created' in data)) {
      unitTestCards('cards update: no created in data: nothing to create or update!');
      return;
    }
    for (const id in data.created) {
      const o_new = data.created[id];
      if (!isCardType(o_new)) {
        unitTestCards('o_new not cardType:', o_new.obj_type);
        continue;
      }
      if (!(id in G)) {
        if (!isVisibleToPlayer(o_new, player) && !('owner' in o_new)) {
          unitTestCards('not visible and no owner', o_new);
          continue;
        }
        let hand = this.findCardHand(o_new);
        hand.addNew(id, o_new);
        G[id] = o_new;
        unitTestCards('created card', id, 'for hand', hand.id, o_new);
      } else {
        let o_old = G[id];
        let d = propDiff(o_old, o_new);
        if (!d.hasChanged) continue;
        unitTestCards('card change', id, d.summary.toString());
        if (d.summary.includes('visible')) {
          let hand_new = this.findCardHand(o_new);
          let hand_old = this.findCardHand(o_old);
          let ms = hand_old.remove(id);
          let title = ms.getTag('title');
          unitTestCards('removed card', id, title, 'from hand', hand_old.id);
          if (hand_new) {
            hand_new.addExisting(id, o_new, ms);
            G[id] = o_new;
            unitTestCards('added card', id, title, 'to hand', hand_new.id);
          } else {
            delete G[id];
            unitTestCards('DELETED card', id, title);
          }
        } else {
        }
      }
    }
  }
}
class ACombat {
  constructor(page, assets, data, repDivName) {
    this.page = page;
    this.assets = assets;
    this.c = data;
    this.dArea = repDivName;
    this.pal = set_palette(199, 1);
    this.battles = null;
    if (Object.keys(data.battles).length > 0) {
      this.initBattles(data)
    }
  }
  initBattles(cData) {
    let c = this.c = cData;
    this.page.battleView();
    this.locations = Object.keys(cData.battles);
    this.battleCounter = 0;
    this.battles = {};
    this.battle = null;
    for (const loc of this.locations) {
      this.battles[loc] = new ABattle(this.assets, loc, this.c.battles[loc], this.c.stage);
    }
    let sizes = this.locations.map(loc => this.battles[loc].size);
    this.containerSize = { w: getItemWithMax(sizes, 'w')[2], h: getItemWithMax(sizes, 'h')[2] + 12 };
    let dCombatArea = document.getElementById(this.dArea);
    clearElement(dCombatArea);
    let dCombat = addDivFullClass(dCombatArea, 'dCombat', 'combatContainer');
    let dCombatTitles = addDivClass(dCombat, 'dCombatTitles', 'combatTitles');
    let dCombatTitle = addDivClass(dCombatTitles, 'dCombatTitle', 'combatTitle');
    let title = 'COMBAT!!! Battle' + (this.locations.length > 1 ? 's' : '') + ' in ' + this.locations.join(', ');
    dCombatTitle.innerHTML = title;
    this.dCombatSubtitle = addDivClass(dCombatTitles, 'dCombatSubtitle', 'combatSubtitle');
    let dBattleGrid = addDivClass(dCombat, 'dBattleOverview', 'battleGrid');
    let ipal = 0,
      bg,
      fg,
      d;
    for (const loc of this.locations) {
      [bg, fg, d] = this.makeDBattleOuter(dBattleGrid, ipal);
      ipal += 1;
      this.battles[loc].populate(d, 'g' + loc, bg, fg);
    }
  }
  clear_area() {
    let d = document.getElementById(this.dArea);
    clearElement(d);
  }
  makeDBattleOuter(dBattleGrid, ipal) {
    let dBattleOuter = addDivClass(dBattleGrid, 'dBattleOuter', 'battleOuterOverview');
    let wSides = 80;
    let bg = getpal(ipal, 0, 'b');
    let fg = getpal(ipal, 0, 'f');
    dBattleOuter.style.backgroundColor = bg;
    dBattleOuter.style.color = fg;
    ipal += 1;
    dBattleOuter.style.width = 2 * wSides + this.containerSize.w + 'px';
    dBattleOuter.style.height = this.containerSize.h + 'px';
    dBattleOuter.style.border = '1px solid ' + getpal(6);
    dBattleOuter.style.margin = '10px';
    dBattleOuter.style.textAlign = 'center';
    return [bg, fg, dBattleOuter];
  }
  update(data, H) {
    let c = data.temp.combat;
    unitTestCombat('_______________combat update');
    unitTestCombatStage('Combat stage=' + c.stage, c, this.battles);
    if (c.stage == 'opt') {
      return;
    } else if (!this.battles && c.stage == 'battle') {
      this.initBattles(c);
    }
    let message = '';
    if (c.stage == 'opt') {
      return;
    } else if (c.stage == 'next') {
      message = 'SELECT NEXT BATTLE!';
    } else if (c.stage == 'battle') {
      if (c.battle.stage == 'battle_start_ack') {
        if (this.battle) {
          this.battle.unselectBattle();
        }
        this.battle = this.battles[c.battle.tilename];
      }
      message = this.battle.update(data, H);
    } else if (c.stage == 'ack_combat_end') {
      message = 'COMBAT ENDS!!!'
    }
    this.dCombatSubtitle.innerHTML = message;
    unitTestCombat('_____________________');
  }
}
class Activator {
  static maxZIndex = 0;
  constructor(n, ui, R) {
    this.n = n;
    this.ui = isdef(n.uiActive) ? n.uiActive : ui;
    this.uid = n.uid;
    this.R = R;
    this.hoverActive = false;
    this.clickActive = false;
  }
  activate(fEnter, fLeave, fClick) {
    this.activateHover(fEnter, fLeave); this.activateClick(fClick);
  }
  activateHover(fEnter, fLeave) {
    if (this.hoverActive) return;
    this.hoverActive = true;
    this.ui.onmouseenter = (ev) => { ev.stopPropagation(); fEnter(this.uid, this.R); }
    this.ui.onmouseleave = (ev) => { ev.stopPropagation(); fLeave(this.uid, this.R); }
  }
  activateClick(fClick) {
    if (this.clickActive) return;
    this.clickActive = true;
    this.ui.onclick = (ev) => { ev.stopPropagation(); fClick(this.uid, this.R); }
  }
  deactivate() {
    if (!this.hoverActive && !this.clickActive) return;
    this.deactivateHover();
    this.deactivateClick();
  }
  deactivateHover() {
    if (!this.hoverActive) return;
    this.hoverActive = false;
    removeEvents(this.ui, 'mouseenter', 'mouseleave');
  }
  deactivateClick() {
    if (!this.clickActive) return;
    this.clickActive = false;
    removeEvents(this.ui, 'click');
  }
}
class ADecisiongen {
  constructor(assets, map, cards, units, sender) {
    this.assets = assets;
    this.autoplay = true;
    this.decisionMode = 'server';
    this.priorityDecisions = [];
    this.scenario = null;
    this.seed = null;
    this.player = null;
    this.phase = null;
    this.callback = null;
    this.tuple = null;
    this.tuples = [];
    this.choiceCompleted = false;
    this.choiceList = {};
    this.UI = new ADecisionUI(assets, map, cards, units);
    this.playerStrategy = {};
    this.playerStrategy['Axis'] = new AStrategy(this.assets);
    this.playerStrategy['West'] = new AStrategy(this.assets);
    this.playerStrategy['USSR'] = new AStrategy(this.assets);
  }
  decideAutoplay(G) {
    unitTestDecision('decideAutoplay', G, this.decisionMode);
    this.player = G.player;
    if (!this.choiceCompleted) {
      this.choiceCompleted = true;
      if (this.decisionMode == 'scenario' && this.scenario != null) {
        this.tuple = this.scenario.findMatch(G);
        if (!this.tuple) {
          this.tuple = this.tuples[0];
        }
      } else if (this.decisionMode == 'priority') {
        let found = false;
        for (const keyword of this.priorityDecisions) {
          let t = firstCond(this.tuples, t => t.includes(keyword));
          if (t) {
            this.tuple = t;
            found = true;
            break;
          }
        }
        if (!found) this.tuple = this.tuples[0];
      } else if (this.decisionMode == 'server') {
        let info = G.serverData.choice;
        if (info.count != this.tuples.length) {
          alert('decideAutoplay: wrong tuple count!!!! ' + this.tuples.length + ' should be ' + info.count);
        }
        let n = info.random;
        this.tuple = this.tuples[n];
        if (!sameList(this.tuple, info.tuple)) {
          alert('decideAutoplay: tuple incorrect!!! ' + this.tuple.toString() + ' should be ' + info.tuples.toString());
        }
      } else if (this.decisionMode == 'seed') {
        let n = this.nextRandom(this.tuples.length);
        this.tuple = this.tuples[n];
        unitTestChoice('decideAutoplay seed decision:', n, this.tuple);
      } else {
        this.tuple = this.playerStrategy[G.player].chooseTuple(G);
      }
      this.UI.restoreNoFilterHighlightType(false);
      this.highlightChosenTuple(this.tuple);
      setTimeout(() => this.callback(this.tuple), 10);
    } else {
      alert('decideAutoplay: already selected!!!');
    }
  }
  genMove(G, callback, autoplay = true) {
    unitTestDecision('new genMove call!!! phase:', G.phase, 'autoplay:', autoplay);
    this.callback = callback;
    this.tuples = G.tuples;
    this.tuple = null;
    if (this.seed == null) {
      this.seed = G.start.seed;
    }
    if (autoplay != this.autoplay) {
      this.autoplay = autoplay;
    }
    if (G.phase != this.phase) {
      this.phase = G.phase;
    }
    this.UI.clearHoverTuple();
    let container = this.presentTuples(this.tuples);
    this.choiceCompleted = false;
    if (autoplay) {
      this.UI.hideUI();
      this.decideAutoplay(G);
    } else {
      this.UI.startManualSelection(this.phase, this.tuples, container, this.onSelected.bind(this));
    }
  }
  highlightChosenTuple(tuple, msecs = 30) {
    let index = this.tuples.indexOf(tuple);
    let i = Object.keys(this.choiceList).length;
    let s = '' + index + ':' + tuple.toString();
    unitTestChoicemin('' + i + ': ' + this.player + '(' + index + '/' + this.tuples.length + '): ' + this.tuple.toString());
    this.choiceList[i] = { index: index, tuple: tuple };
    let d = document.getElementById('divSelect');
    let els = document.getElementsByTagName('a');
    let el = els[index];
    el.classList.add('selected');
    ensureInView(d, el);
  }
  loadScenario(data, G) {
    this.scenario = new Scenario(this.assets, data, G, this);
    this.decisionMode = 'scenario';
  }
  nextRandom(max) {
    unitTestRandom('nextRandom max =', max, ', this.seed =', this.seed);
    var x = Math.sin(this.seed++) * 10000;
    let res = Math.floor((x - Math.floor(x)) * max);
    return res;
  }
  onClickStep(G) {
    if (!this.choiceCompleted) {
      if (!sameList(this.tuples, G.tuples)) {
        alert('onClickStep: this.tuples not same as G.tuples!');
      }
      this.decideAutoplay(G);
    }
  }
  onSelected(ev) {
    if (!this.choiceCompleted) {
      this.choiceCompleted = true;
      let id = evToIdTNT(ev);
      let idx = firstNumber(id);
      this.tuple = this.tuples[idx];
      unitTestHover('select', this.tuple);
      this.highlightChosenTuple(this.tuple);
      this.UI.restoreNoFilterHighlightType(false);
      this.callback(this.tuple);
    }
  }
  presentTuples(tuples) {
    let d = document.getElementById('divSelect');
    clearElement(d);
    d.scrollTop = 0;
    let i = 0;
    for (const t of tuples) {
      let el = document.createElement('a');
      el.id = 'aaa' + i;
      i += 1;
      el.textContent = t;
      d.appendChild(el);
    }
    return d;
  }
}
class ADecisionUI {
  constructor(assets, map, cards, units) {
    this.map = map;
    this.cards = cards;
    this.units = units;
    this.assets = assets;
    this.buttons = {};
    this.types = ['tile', 'unit', 'nation', 'other'];
    for (const type of this.types) {
      let b = document.getElementById('b' + type);
      this.unselectButton(b);
      this.buttons[type] = b;
    }
    this.extraTypes = [];
    this.highlightType = null;
    this.phase = null;
    this.tuples;
    this.elTuples;
    this.byS = {};
    this.byType = {};
    this.ituplesByS = {};
    this.ihideByS = {};
    this.ituplesByType = {};
    this.sInTuples = [];
    this.msSelected = null;
    this.hoverTuple = null;
  }
  clearHoverTuple() {
    unitTestHover('clearHoverTuple');
    if (this.hoverTuple) {
      unitTestHover('clearHoverTuple', this.hoverTuple.id);
      for (const s of this.hoverTuple.tuple) {
        let ms = this.get(s).ms;
        if (ms) ms.stopSelGreen();
      }
      this.hoverTuple = null;
    }
  }
  filterByS(ev) {
    let idElem = evToIdTNT(ev);
    let clickedOnSelected = this.msSelected && this.msSelected.elem.id == idElem;
    this.restoreNoFilterHighlightType();
    if (clickedOnSelected) return;
    let id = idElem in this.assets.uid2id ? this.assets.uid2id[idElem] : idElem;
    let ms = this.byS[id].ms;
    this.msSelected = ms;
    unitTestFilter('filterByS', idElem, id);
    for (let i = 0; i < this.tuples.length; i++) {
      const t = this.tuples[i];
      const el = this.elTuples[i];
      if (!t.includes(id)) {
        el.style = 'display:none';
      } else if (this.phase == 'Movement' && t.length > 1 && this.get(id).type == 'tile' && t[1] != id) {
        el.style = 'display:none';
      } else {
        for (const s of t) {
          if (this.phase == 'Setup' && this.get(s).type == 'nation') continue;
          let ms = this.get(s).ms;
          if (ms) ms.select();
        }
      }
    }
  }
  filterByType() {
    let type = this.highlightType;
    unitTestFilterByType('filterByType', type, this.tuples.length, this.ituplesByType[type].toString());
    for (let i = 0; i < this.tuples.length; i++) {
      if (!this.ituplesByType[type].includes(i)) {
        this.elTuples[i].style = 'display:none';
      }
    }
  }
  get(s) {
    if (s in this.byS) {
      return this.byS[s];
    }
    let type = null;
    let ms = null;
    if (s in this.units.uis) {
      ms = this.units.uis[s].ms;
      type = 'unit';
    } else if (s in this.map.tiles) {
      ms = this.map.tiles[s];
      type = 'tile';
    } else if (s in this.map.nations) {
      ms = this.map.nations[s];
      type = 'nation';
    } else if (s in this.map.influences) {
      ms = this.map.influences[s];
      unitTestFilterNation('ms', ms);
      type = 'nation';
    } else if (this.cards.inVisibleHand(s)) {
      ms = this.cards.getCardMs(s);
      type = 'card';
    } else {
      type = 'other';
    }
    this.byS[s] = { ms: ms, type: type };
    return this.byS[s];
  }
  hideUI() {
    Object.values(this.buttons).map(x => hide(x));
  }
  highlightObjects() {
    let ids = this.byType[this.highlightType];
    if (this.highlightType == 'other') {
      this.extraTypes.map(t => this.byType[t].map(s => ids.push(s)));
    }
    unitTestFilterByType('highlightType:', this.highlightType, 'ids', ids);
    for (const s of ids) {
      let ms = this.byS[s].ms;
      if (ms) {
        ms.makeSelectable(this.filterByS.bind(this));
      }
    }
    let tilesVisible = this.map.tiles['London'].isVisible;
    let nationsVisible = this.map.nations['Britain'].isVisible;
    if (this.highlightType == 'nation') {
      if (tilesVisible) Object.values(this.map.tiles).map(o => o.hide());
    } else if (!tilesVisible) {
      Object.values(this.map.tiles).map(o => o.show());
    }
    if (this.highlightType == 'tile') {
      if (nationsVisible) Object.values(this.map.nations).map(o => o.hide());
    } else if (!nationsVisible) {
      Object.values(this.map.nations).map(o => o.show());
    }
    unitTestFilterByType('ids.length', ids.length);
    if (this.tuples.length > 24) {
      this.filterByType();
    }
  }
  onExitTuple(ev) {
    if (this.hoverTuple) {
      unitTestHover('exit', this.hoverTuple.id);
    } else {
      unitTestHover('exit null');
    }
    this.clearHoverTuple();
  }
  onEnterTuple(ev) {
    let idTuple = evToIdTNT(ev);
    unitTestHover('enter', idTuple);
    if (this.hoverTuple != null && this.hoverTuple.id == idTuple) return;
    let idx = firstNumber(idTuple);
    let tuple = this.tuples[idx];
    this.hoverTuple = { id: idTuple, idx: idx, tuple: tuple };
    for (const s of tuple) {
      let ms = this.get(s).ms;
      if (ms) ms.selGreen();
    }
  }
  restoreNoFilterHighlightType(highlight = true) {
    this.elTuples.map(el => (el.style = ''));
    this.clearHoverTuple();
    for (const s of this.sInTuples) {
      let ms = this.get(s).ms;
      if (ms) {
        ms.stopSelGreen();
        ms.makeUnselectable();
      }
    }
    this.msSelected = null;
    if (highlight) this.highlightObjects();
    else {
      let tilesVisible = this.map.tiles['London'].isVisible;
      let nationsVisible = this.map.nations['Britain'].isVisible;
      if (!tilesVisible) {
        Object.values(this.map.tiles).map(o => o.show());
      }
      if (!nationsVisible) {
        Object.values(this.map.nations).map(o => o.show());
      }
    }
  }
  startManualSelection(phase, tuples, container, onSelectedHandler) {
    this.tuples = tuples;
    this.elTuples = arrChildren(container);
    for (const el of this.elTuples) {
      el.addEventListener('click', onSelectedHandler);
      el.addEventListener('mouseenter', this.onEnterTuple.bind(this));
      el.addEventListener('mouseleave', this.onExitTuple.bind(this));
    }
    this.sInTuples = [];
    this.byType = {};
    this.ituplesByType = {};
    this.ihideByType = {};
    this.ituplesByS = {};
    for (const [i, t] of this.tuples.entries()) {
      for (const s of t) {
        if (this.assets.nationalityNames.includes(s) || this.assets.unitTypeNames.includes(s)) {
          if (t.length > 1) continue;
        }
        addIf_dep(s, this.sInTuples);
        let o = this.get(s);
        if (['Albania', 'Malta', 'Gibraltar'].includes(s)) {
          if (this.phase == 'Movement') {
            if (t.length == 1) {
              o.type = 'nation';
            } else {
              o.type = 'tile';
            }
          } else if (this.phase == 'Government') {
            if (any(t, x => startsWith(x, 'action_'))) {
              o.type = 'nation';
            } else {
              o.type = 'tile';
            }
          }
        }
        addIf_depDict(o.type, s, this.byType);
        addIf_depDict(o.type, i, this.ituplesByType);
        addIf_depDict(s, i, this.ituplesByS);
      }
    }
    let types = Object.keys(this.byType);
    for (const t of this.types) {
      if (!types.includes(t)) {
        hide(this.buttons[t]);
      } else {
        show(this.buttons[t]);
      }
    }
    this.extraTypes = [];
    for (const t of types) {
      if (!this.types.includes(t)) {
        this.extraTypes.push(t);
      }
    }
    let recommendedHighlightType = this.checkPhaseChange(phase);
    unitTestFilterByType('270: ', recommendedHighlightType);
    if (!types.includes(recommendedHighlightType)) {
      recommendedHighlightType = types[0];
      unitTestFilterByType('273: ', recommendedHighlightType, types);
    }
    this.highlightType = recommendedHighlightType;
    unitTestFilterByType('nach setting highlightType 277: ', recommendedHighlightType, this.highlightType);
    for (const t in this.buttons) {
      if (t == this.highlightType) {
        this.selectButton(this.buttons[t]);
      } else {
        this.unselectButton(this.buttons[t]);
      }
    }
    this.highlightObjects();
  }
  setHighlightType(button) {
    if (this.highlightType != null) {
      this.unselectButton(this.buttons[this.highlightType]);
    }
    this.highlightType = button.id.substring(1);
    unitTestFilterByType('setting new highlightType 292:', this.highlightType);
    this.selectButton(button);
    this.restoreNoFilterHighlightType();
  }
  selectButton(b) {
    b.style.backgroundColor = '#2196f3';
    b.style.color = 'white';
  }
  unselectButton(b) {
    b.style.backgroundColor = 'white';
    b.style.color = '#2196f3';
  }
  checkPhaseChange(newPhase) {
    if (this.phase == newPhase) return this.highlightType;
    this.phase = newPhase;
    switch (this.phase) {
      case 'Government':
        return 'nation';
      case 'Movement':
      case 'Battle':
      case 'Land_Battle':
      case 'Sea_Battle':
        return 'unit';
      case 'Spring':
      case 'Summer':
      case 'Fall':
        return 'other';
      case 'Setup':
      case 'Production':
      default:
        return 'tile';
    }
  }
}
class AFilterList {
  constructor() {
  }
}
class Agent {
  constructor(home, speed, zackig, aussehen, startpos) {
    this.home = home;
    this.isMap = is_map(home);
    console.log('is_map?', this.isMap);
    this.pos = isdef(startpos) ? startpos : this.isMap ? home.options.center : null;
    this.speed = speed;
    this.rGen = zackig ? rFloat : rGaussian;
    this.ui = create_agent(home, aussehen);
    if (isdef(startpos)) this.moveto(startpos);
  }
  moveto(coords) {
    if (this.isMap) map_moveto(this.ui, coords); else mPos(this.ui, coords[0], coords[1]);
    this.pos = coords;
  }
  movefor(secs) {
    let f = x => x + this.rGen(-this.speed, this.speed);
    run_for_seconds(secs, () => { map_moveby(this.ui, f, f); })
  }
  move() {
    let f = x => x + rGen(-speed, speed);
    this.interval = setInterval(() => map_moveby(this.ui, f, f), 50);
  }
  stop_moving() { clearInterval(this.interval); }
}
class AGraph {
  constructor() {
    this.init(...arguments);
    this.posDict = {};
  }
  init() {
    let defOptions = {
      maxZoom: 1,
      minZoom: .001,
      motionBlur: false,
      zoomingEnabled: false,
      userZoomingEnabled: false,
      panningEnabled: false,
      userPanningEnabled: false,
      boxSelectionEnabled: false,
      layout: { name: 'preset' },
      elements: [],
    };
    this.cy = cytoscape(defOptions);
  }
  clear() { this.cy.destroy(); }
  //#region access and algos
  getComponents() { return this.cy.elements().components(); }
  getComponentIds() { return this.cy.elements().components().map(x => x.id()); }
  getCommonEdgeId(nid1, nid2) { return nid1 + '_' + nid2; }
  getNumComponents() { return this.cy.elements().components().length; }
  getNode(id) { return this.cy.getElementById(id); }
  getEdge(id) { return this.cy.getElementById(id); }
  getNodes() { return this.cy.nodes(); }
  getNodeIds() { return this.cy.nodes().map(x => x.id()); }
  getNodeData() { return this.cy.nodes().map(x => x.data()); }
  getNodePositions() { return this.cy.nodes.map(x => x.position()); }
  getEdges() { return this.cy.edges(); }
  getEdgeIds() { return this.cy.edges().map(x => x.id()); }
  getPosition(id) {
    let node = this.getNode(id);
    let pos = node.renderedPosition();
    return pos;
  }
  getSize(id) {
    let node = this.getNode(id);
    let pos = node.bb();
    return pos;
  }
  getProp(id, prop) { return this.cy.getElementById(id).data(prop); }
  getDegree(id) { return this.cy.getElementById(id).degree(); }
  getNodeWithMaxDegree(idlist) {
    if (nundef(idlist)) idlist = this.cy.elements().filter('node').map(x => x.data().id);
    let imax = arrMinMax(idlist, x => this.getDegree(x)).imax;
    let id = idlist[imax];
    return id;
  }
  getShortestPathsFrom(id) { let res = this.cy.elements().dijkstra('#' + id); return res; }
  getShortestPathFromTo(nid1, nid2) {
    let funcs = this.dijkstra = this.getShortestPathsFrom(nid1);
    let path = funcs.pathTo('#' + nid2);
    return path;
  }
  getLengthOfShortestPath(nid1, nid2) {
    let funcs = this.dijkstra = this.getShortestPathsFrom(nid1);
    let len = funcs.distanceTo('#' + nid2);
    return len;
  }
  setPositionData(prop = 'center') {
    let ids = this.getNodeIds();
    for (const id of ids) {
      let pos = this.getProp(id, prop);
      if (isdef(pos)) this.setPosition(id, pos.x, pos.y);
      else return false;
    }
    return true;
  }
  sortNodesByDegree(idlist, descending = true) {
    if (nundef(idlist)) idlist = this.cy.nodes.map(x => x.data().id);
    let nodes = idlist.map(x => this.getNode(x));
    for (const n of nodes) {
      n.degree = this.getDegree(n.id());
    }
    if (descending) sortByDescending(nodes, 'degree'); else sortBy(nodes, 'degree');
    return nodes;
  }
  storeCurrentPositions(prop = 'center') {
    for (const n of this.getNodes()) {
      let id = n.id();
      let pos = this.getPosition(id);
      this.setProp(id, prop, pos);
    }
  }
  //#endregion
  //#region add/remove nodes, edges
  addNode(data, coords) {
    if (nundef(data)) data = {};
    if (nundef(data.id)) data.id = getFruid();
    if (isdef(coords)) {
      coords.x -= this.cy.pan().x;
      coords.y -= this.cy.pan().y;
    } else { coords = { x: 0, y: 0 }; }
    var ele = this.cy.add({
      group: 'nodes',
      data: data,
      position: coords
    });
    return ele.id();
  }
  addNodes(n, datalist, coordlist) {
    let ids = [];
    if (nundef(datalist)) datalist = new Array(n).map(x => ({ id: getFruid() }));
    if (nundef(coordlist)) coordlist = new Array(n).map(x => ({ coords: { x: 0, y: 0 } }));
    for (let i = 0; i < n; i++) {
      let id = this.addNode(datalist[i], coordlist[i]);
      ids.push(id);
    }
    return ids;
  }
  addEdge(nid1, nid2, data) {
    if (nundef(data)) data = {};
    data.id = this.getCommonEdgeId(nid1, nid2);
    data.source = nid1;
    data.target = nid2;
    var ele = this.cy.add({
      group: 'edges',
      data: data,
    });
    return ele.id();
  }
  addEdges(nOrNodePairList) {
    if (isNumber(nOrNodePairList)) {
      let nids = this.getNodeIds();
      let prod = arrPairs(nids);
      nOrNodePairList = choose(prod, nOrNodePairList);
    }
    let res = [];
    for (const pair of nOrNodePairList) {
      res.push(this.addEdge(pair[0], pair[1]));
    }
    return res;
  }
  removeNode(node) { this.removeElement(node); return this.getNodeIds(); }
  removeEdge(edge) { this.removeElement(edge); return this.getEdgeIds(); }
  removeElement(ne) { if (!isString(ne)) ne = ne.id(); this.cy.getElementById(ne).remove(); }
  //#endregion
  //#region modify nodes, edges (data, position...)
  setPosition(id, x, y) { this.cy.getElementById(id).position({ x: x, y: y }); }
  setProp(id, prop, val) { this.cy.getElementById(id).data(prop, val); }
  //#endregion
}
class AHand {
  constructor(assets, gName, divName, ownerOrOpen) {
    this.id = ownerOrOpen;
    this.cards = {};
    this.cardWidth = assets.SZ.cardWidth;
    this.cardHeight = assets.SZ.cardHeight;
    this.gap = assets.SZ.gap;
    this.startPos = { x: 80 + this.gap + this.cardWidth / 2, y: this.gap + this.cardHeight / 2 };
    this.div = document.getElementById(divName);
    this.g = document.getElementById(gName);
    this.wDiv = this.div.offsetWidth;
    this.hDiv = firstNumber(this.div.style.height);
    this.xNext = this.startPos.x;
    this.yNext = this.startPos.y;
  }
  addExisting(id, o, ms) {
    ms.parent = this.g;
    this.positionAndAdd(id, ms, o);
    return ms;
  }
  addNew(id, o) {
    let parentName = this.g.id;
    let ms = new MS(id, parentName);
    this.setCardContent(ms, o);
    this.positionAndAdd(id, ms, o);
    return ms;
  }
  getNextPosition() {
    let x = this.xNext;
    let y = this.yNext;
    if (x + this.cardWidth / 2 + this.gap > this.wDiv) {
      x = this.startPos.x;
      y += this.cardHeight + this.gap;
      let sizeNeeded = y + this.cardHeight / 2 + this.gap;
      if (this.hDiv < sizeNeeded) {
        this.hDiv = sizeNeeded;
        this.div.style.height = this.hDiv + "px";
      }
    }
    this.xNext = x + this.gap + this.cardWidth;
    this.yNext = y;
    let pos = { x: x, y: y };
    return pos;
  }
  hide() {
    hide(this.g);
  }
  getTitle(id) {
    if (id in this.cards) {
      return this.cards[id].ms.getTag('title');
    } else { return 'unknown' }
  }
  positionAndAdd(id, ms, o) {
    let pos = this.getNextPosition();
    ms.setPos(pos.x, pos.y).draw();
    this.cards[id] = { ms: ms, o: jsCopy(o) };
  }
  relayout() {
    this.xNext = this.startPos.x;
    this.yNext = this.startPos.y;
    for (const id in this.cards) {
      const ms = this.cards[id].ms;
      let pos = this.getNextPosition();
      ms.setPos(pos.x, pos.y).draw();
    }
  }
  relayoutExcept(id) {
    this.xNext = this.startPos.x;
    this.yNext = this.startPos.y;
    for (const id1 in this.cards) {
      if (id1 == id) continue;
      const ms = this.cards[id1].ms;
      let pos = this.getNextPosition();
      ms.setPos(pos.x, pos.y).draw();
    }
  }
  remove(id) {
    if (!(id in this.cards)) {
      return null;
    }
    let ms = this.cards[id].ms;
    ms.removeFromUI();
    this.relayoutExcept(id);
    let chLast = this.g.lastChild;
    if ("id" in chLast) {
      let idLast = chLast.id;
      if (idLast in this.cards) {
        let msLast = this.cards[idLast].ms;
        let posLast = msLast.getPos();
        let hNeeded = posLast.y + this.cardHeight / 2 + this.gap;
        let otherHNeeded = msLast.bounds.b + this.gap;
        if (hNeeded != otherHNeeded) {
        }
        if (hNeeded < 200) hNeeded = 200;
        if (this.hDiv > hNeeded && isVisible(this.g)) {
          this.hDiv = hNeeded;
          this.div.style.height = this.hDiv + "px";
        }
      }
    }
    delete this.cards[id];
    return ms;
  }
  setCardContent(ms, o) {
    let txt = [];
    let title = "";
    if ("top" in o) {
      if (o.obj_type == "action_card") {
        txt = [o.top, " ", o.season, o.priority + o.value, " ", o.bottom];
      } else {
        txt = [o.top, " ", " ", o.value ? o.value.toString() : " ", " ", " ", o.bottom];
      }
      title = o.top;
    } else if ("wildcard" in o) {
      txt = [o.wildcard, " ", o.season, o.priority + o.value, " ", " "];
      title = o.wildcard;
    } else if ("intelligence" in o) {
      txt = [o.intelligence, " ", " ", o.value ? o.value.toString() : " ", " ", " ", " "];
      title = o.intelligence;
    } else if ("science" in o) {
      txt = [o.value + "   (" + o.year.toString() + ")"];
      o.science.map(x => txt.push(x));
      title = o.year;
    }
    if (txt.length > 0) {
      txt = txt.map(x => x.replace(/_/g, " "));
    }
    let cardWidth = this.cardWidth;
    let cardHeight = this.cardHeight;
    let testText = ms.id;
    if ("owner" in o) {
      testText += " " + o.owner;
    }
    ms.roundedRect({ className: 'ground', w: cardWidth, h: cardHeight, fill: "white" })
      .text({ txt: testText, fill: "red", y: cardHeight / 2, fz: cardWidth / 7 })
      .textMultiline({ txt: txt, maxWidth: cardWidth, fz: cardWidth / 7 })
      .roundedRect({ className: "overlay", w: cardWidth, h: cardHeight });
    ms.tag("content", txt);
    ms.tag("type", o.obj_type);
    ms.tag("title", title);
    ms.tag("json", JSON.stringify(o));
    return ms;
  }
  show() {
    show(this.g);
    let divHeight = firstNumber(this.div.style.height);
    if (this.hDiv != divHeight) {
      this.div.style.height = this.hDiv + "px";
    }
  }
  sort(prop) { }
  update(id, o_new) {
  }
}
class AIPlayer {
  constructor(max_depth = -1) {
    this.id = getUID('AI');
    this.color = randomColor();
    this.type = 'ai';
    this.score = 0;
  }
  setData(o) { copyKeys(o, this); }
}
class AMap {
  constructor(assets) {
    this.assets = assets;
    this.tiles = {};
    this.chips = {};
    this.influences = {};
    this.vpts = { Axis: [], West: [], USSR: [] };
    this.calculateStatsPositions();
    this.dowPositions = this.calculateDowPositions();
    this.nations = this.assets.drawNationPositions();
  }
  calculateDowPositions() {
    let dp = {};
    dp[this.dowKey('West', 'USSR')] = { x: 1244, y: 142 };
    dp[this.dowKey('West', 'Axis')] = { x: 1178, y: 142 };
    dp[this.dowKey('Axis', 'West')] = { x: 613, y: 2054 };
    dp[this.dowKey('Axis', 'USSR')] = { x: 679, y: 2054 };
    dp[this.dowKey('USSR', 'West')] = { x: 3332, y: 268 };
    dp[this.dowKey('USSR', 'Axis')] = { x: 3332, y: 334 };
    return dp;
  }
  calculateStatsPositions() {
    let arr = [];
    let x = 580;
    let y = 2120;
    for (let i = 0; i < 25; i++) {
      arr.push({ x: x, y: y });
      x += 66;
    }
    this.vpts.Axis = arr;
    arr = [];
    x = 1310;
    y = 76;
    for (let i = 0; i < 20; i++) {
      arr.push({ x: x, y: y });
      x -= 66;
    }
    for (let i = 20; i < 25; i++) {
      arr.push({ x: x, y: y });
      y += 66;
    }
    this.vpts.West = arr;
    arr = [];
    x = 2210;
    y = 76;
    for (let i = 0; i < 18; i++) {
      arr.push({ x: x, y: y });
      x += 66;
    }
    for (let i = 18; i < 25; i++) {
      arr.push({ x: x, y: y });
      y += 66;
    }
    this.vpts.USSR = arr;
  }
  createChip(id, { text = '', filename = '', prefix = '', faction = '', color = 'beige' } = {}) {
    let sz = this.assets.SZ.chip;
    let pts = this.vpts[faction];
    let pos = pts[0];
    let ms = new MS(id, 'mapG', assets.getUniqueId(id))
      .roundedRect({ w: sz, h: sz, fill: color })
      .text({ txt: text, fill: 'white', weight: 'bold' })
      .setPos(pos.x + sz / 2, pos.y + sz / 2)
      .draw();
    return ms;
  }
  createInfluence(id, nation, faction, value) {
    unitTestMap('createInfluence', id, nation, faction, value);
    let ms = new MS(id, 'mapG', assets.getUniqueId(id));
    this.drawInfluence(ms, nation, faction, value);
    let pos = this.assets.nationPositions[nation];
    let x = pos.x;
    let y = pos.y;
    ms.setPos(x, y).draw();
    return ms;
  }
  createTile(id, o) {
    let pos = this.assets.tilePositions[id];
    let sz = this.assets.SZ.tile;
    let ms = new MS(id, 'mapG', this.assets.getUniqueId(id))
      .circle({ className: 'ground', fill: 'transparent', sz: sz })
      .circle({ className: 'overlay region', sz: sz })
      .setPos(pos.x, pos.y)
      .draw();
    if ('owner' in o) {
      ms.tag('owner', o.owner);
    }
    return ms;
  }
  dowKey(declarer, other) {
    return declarer + 'DoW' + other;
  }
  drawInfluence(ms, nation, faction, level) {
    if (faction === undefined) {
      alert('drawInfluence faction undefined!!!');
    }
    let imagePath = '/a/assets/images/' + faction + '.svg';
    let color = colorArrToString(...this.assets.troopColors[faction]);
    let darker = pSBC(-0.4, color);
    let lighter = pSBC(0.4, color);
    let sz = this.assets.SZ.influence + 10 * level;
    let szOuter = sz + 10;
    let szFrame = szOuter + 10;
    let szImage = sz;
    let y = szImage / 6;
    let text = level;
    let rd = dlColor(0.5, 255, 0, 0);
    let fontColor = level != 2 ? 'black' : rd;
    ms.circle({ className: 'ground', fill: darker, alpha: 1, sz: szFrame })
      .circle({ fill: color, alpha: 1, sz: szOuter })
      .image({ path: imagePath, w: szImage, h: sz })
      .text({ txt: text, fill: fontColor, fz: szImage - 5, weight: 'bold' })
      .circle({ className: 'overlay', sz: szOuter });
    ms.tag('nation', nation);
    ms.tag('faction', faction);
    ms.tag('level', level);
    ms.tag('type', 'influence');
    return ms;
  }
  setPopulation(faction, n) {
    this.setChip('pop', 'P', faction, n, 'sienna');
  }
  setIndustry(faction, n) {
    this.setChip('ind', 'I', faction, n, 'red');
  }
  setResource(faction, n) {
    this.setChip('res', 'R', faction, n, 'green');
  }
  setChip(prefix, text, faction, n, color) {
    n -= 1;
    let pts = this.vpts[faction];
    if (n < 0 || (n >= pts.length && !GLOBAL_ALERT)) {
      alert(text + 'setChip!!!! ' + (n + 1) + ', ' + prefix + ', ' + text + ', ' + faction);
      GLOBAL_ALERT = true;
      STOP = true;
    }
    let id = prefix + faction;
    if (!(id in this.chips)) {
      this.chips[id] = this.createChip(id, { text: text, prefix: prefix, faction: faction, color: color });
    }
    let ms = this.chips[id];
    if (n >= 0 && n < pts.length) {
      let pos = pts[n];
      let offset = 7;
      let yOffset = text == 'P' ? -offset : text == 'I' ? 0 : offset;
      let xOffset = text == 'P' ? -offset : text == 'I' ? 0 : offset;
      pos = { x: pos.x + xOffset, y: pos.y + yOffset };
      ms.setPos(pos.x, pos.y);
    } else {
      ms.hide();
    }
  }
  updateInfluence(id, nation, faction, value) {
    unitTestMap('updateInfluence', id, nation, faction, value);
    let ms = this.influences[id];
    ms.show();
    ms.removeFromChildIndex(1);
    this.drawInfluence(ms, nation, faction, value);
  }
  update(data, gameObjs) {
    if ('created' in data) {
      for (const id in data.created) {
        let o_new = data.created[id];
        if (o_new.obj_type == 'tile') {
          if (id in this.tiles) {
            let ms = this.tiles[id];
            let owner_old = ms.getTag('owner');
            if ('owner' in o_new && owner_old != o_new.owner) {
              ms.tag('owner', o_new.owner);
            }
            let blockaded_old = ms.getTag('blockaded');
            if ('blockaded' in o_new && o_new.blockaded && !blockaded_old) {
              ms.addBorder('black');
              ms.tag('blockaded', true);
            } else if (blockaded_old) {
              ms.tag('blockaded', false);
              ms.removeBorder();
            }
            let blockaded_afr_old = ms.getTag('blockaded_afr');
            if ('blockaded_afr' in o_new && o_new.blockaded_afr && !blockaded_afr_old) {
              ms.addBorder('red');
              ms.tag('blockaded_afr', true);
            } else if (blockaded_afr_old) {
              ms.tag('blockaded_afr', false);
              ms.removeBorder();
            }
            continue;
          }
          this.tiles[id] = this.createTile(id, o_new);
          gameObjs[id] = o_new;
        } else if (o_new.obj_type == 'influence' && 'nation' in o_new && 'faction' in o_new) {
          unitTestMap('map update', id, this.influences);
          if (id in this.influences) {
            unitTestMap(id, 'is in this.influences');
            let o_old = gameObjs[id];
            unitTestMap('vor propDiff', o_old, o_new);
            let d = propDiff(o_old, o_new);
            if (d.hasChanged) {
              unitTestMap('influence has changed props:', d.summary.toString());
              this.updateInfluence(id, o_new.nation, o_new.faction, o_new.value);
            }
          } else {
            this.influences[id] = this.createInfluence(id, o_new.nation, o_new.faction, o_new.value);
          }
          gameObjs[id] = o_new;
        }
      }
    }
    if ('removed' in data) {
      for (const id in data.removed) {
        if (id in gameObjs) {
          let o = gameObjs[id];
          if (o.obj_type == 'influence') {
            let ms = this.influences[id];
            ms.removeFromUI();
            delete gameObjs[id];
            delete this.influences[id];
          }
        }
      }
    }
    if ('players' in data.info) {
      for (const faction in data.info.players) {
        let pl = data.info.players[faction];
        this.setPopulation(faction, pl.tracks.POP);
        this.setResource(faction, pl.tracks.RES);
        this.setIndustry(faction, pl.tracks.IND);
        for (const other in pl.DoW) {
          if (pl.DoW[other]) {
            let dowId = this.dowKey(faction, other);
            if (!(dowId in this.chips)) {
              let pos = this.dowPositions[dowId];
              this.chips[dowId] = new MS(dowId, 'mapG', this.assets.getUniqueId(dowId))
                .circle({ className: 'dowChip', fill: 'transparent', sz: 60 })
                .setPos(pos.x, pos.y)
                .draw();
            }
          }
        }
      }
    }
  }
}
class Anim {
  constructor(id, gid) {
    this.timer = null;
  }
  start() {
  }
  end() {
  }
}
class AnimationQueue {
  constructor() {
    this.anilist = {};
  }
  end() {
  }
  enqueue(anim) {
  }
  start() {
  }
}
class ASender {
  constructor(options) {
    this.serverData = {};
    this.akku = {};
    this.msgCounter = 0;
    this.stepCounter = 0;
    this.callback = null;
    this.options = options;
    this.backendUrl = 'http://localhost:5001/';
  }
  augment(data) {
    this.stepCounter += 1;
    this.akku = extend(true, this.akku, data);
    if (this.options.output == 'fine') {
      logFormattedData(this.serverData, this.stepCounter);
    } else if (this.options.output == 'raw') {
    }
  }
  chainSend(msgChain, player, callback) {
    this.stepCounter = 0;
    this.akku = { game: { player: player } };
    this.callback = callback;
    this.chainSendRec({}, msgChain, callback);
  }
  chainSendRec(data, msgChain, callback) {
    this.augment(data);
    if (msgChain.length > 0) {
      this.send(msgChain[0], d => this.chainSendRec(d, msgChain.slice(1), callback));
    } else {
      testOutput({ 3: ['sender akku:', this.akku] });
      callback(this.akku);
    }
  }
  send(url, callback) {
    url = this.backendUrl + url;
    this.msgCounter += 1;
    unitTestRequest(this.msgCounter + ': request sent: ' + url);
    $.ajax({
      url: url,
      type: 'GET',
      success: response => {
        unitTestResponse('server:', response.substring(0, 200));
        if (response[0] != '{') {
          unitTestResponse(response);
          callback(JSON.parse('{"response":"' + response + '"}'));
        } else {
          this.serverData = JSON.parse(response);
          unitTestResponse(this.serverData);
          if ('removed' in this.serverData) {
            for (const id in this.serverData.removed) {
              unitTestRemoved(this.serverData.removed.toString());
              break;
            }
          }
          if ('error' in this.serverData) {
            error(this.serverData);
            error(this.serverData.error);
          } else {
            callback(this.serverData);
          }
        }
      },
      error: err => {
        error(err);
      }
    });
  }
}
class AStrategy {
  constructor(assets, initialStrategy = {}) {
    this.choiceIndex = 0;
    this.choiceModulo = 5;
    this.assets = assets;
    this.phasePred = initialStrategy;
    this.deterministic = true;
  }
  chooseTuple(G) {
    let n = -1;
    if (this.deterministic) {
      n = this.choiceIndex;
      this.choiceIndex = (this.choiceIndex + 1) % this.choiceModulo;
    }
    unitTestStrategy("chooseTuple:", G.player, G.phase, this.phasePred);
    let tuples = G.tuples;
    if (G.phase in this.phasePred) {
      unitTestStrategy("found strategy!", this.phasePred[G.phase]);
      return chooseDeterministicOrRandom(n, tuples, this.phasePred[G.phase]);
    } else {
      unitTestStrategy("no strategy available!!");
      return chooseDeterministicOrRandom(n, tuples, t => !t.includes("pass"));
    }
  }
  chooseFavIfPossible(tuples, fav) {
    if (tuples.length == 1) return tuples[0];
    else {
      let favTuples = tuples.filter(t => t.includes(fav));
      let tuple = empty(favTuples) ? chooseRandomElement(tuples, t => !t.includes("pass")) : favTuples[0];
      return tuple;
    }
  }
  getChooser(phase) {
    switch (phase) {
      case "spring":
      case "summer":
      case "fall":
      case "winter":
      case "season":
        return this.phase.season.favAction;
        break;
      default:
        return this.phase[phase].favAction;
        break;
    }
  }
  setFav(phase, cond) {
    switch (phase) {
      case "spring":
      case "summer":
      case "fall":
      case "winter":
      case "season":
        this.phase.season.favAction = cond;
        break;
      default:
        this.phase[phase].favAction = cond;
        break;
    }
  }
}
class AUnits {
  constructor(assets) {
    this.assets = assets;
    this.SZ = this.assets.SZ;
    this.snailPos = calcSnailPositions(0, 0, this.SZ.cadreDetail, 25);
    this.units = { Axis: {}, West: {}, USSR: {}, Minor: {} };
    this.uis = {};
    this.hiddenUnits = { Axis: {}, West: {}, USSR: {} };
    this.previousPlayer = null;
  }
  addUnit(id, ms, o) {
    let tile = o.tile;
    let owner = ms.getTag('owner');
    let neutral = ms.getTag('neutral');
    if (!(tile in this.units[owner])) {
      this.units[owner][tile] = [id];
    } else {
      addIf_dep(id, this.units[owner][tile]);
    }
    this.uis[id] = { o: jsCopy(o), ms: ms };
    if (o.type == 'Convoy') {
      unitTestConvoy('addUnit of type CONVOY!!!', o, ms)
    }
    unitTestUnits('added', id, ms, o, owner, tile);
    unitTestMoving('added', id, ms, o, owner, tile, this.units[owner]);
  }
  addHiddenUnit(msHidden) {
    console.assert(msHidden != null, 'addHiddenUnit ms == NULL!!!!!!!!!!');
    let idHidden = msHidden.id;
    if (idHidden in this.uis) {
      unitTestUnits('addHiddenUnit ERROR!!!!, already have hidden unit', idHidden);
    }
    let tile = msHidden.getTag('tile');
    let owner = msHidden.getTag('owner');
    this.hiddenUnits[owner][tile] = idHidden;
    let o = { obj_type: 'hidden_unit', owner: owner, tile: tile, count: 1 };
    this.uis[idHidden] = { o: o, ms: msHidden };
    unitTestUnits('addHiddenUnit', idHidden, msHidden, o, owner, tile);
  }
  calcStartPos(tile, faction) {
    let pTile = this.getPosition(tile);
    if (faction == 'Minor') return { x: pTile.x, y: pTile.y };
    let pFaction = this.SZ['p' + faction];
    return { x: pTile.x + pFaction.x, y: pTile.y + pFaction.y };
  }
  createHiddenUnit(id, owner, tile) {
    unitTestUnits('create HIDDEN unit', id, owner, tile, '.........');
    let color = this.assets.troopColors[owner];
    let darker = darkerColor(color[0], color[1], color[2]);
    let sz = this.SZ.sumCadre;
    let sz80 = sz * 0.86;
    let szImage = sz / 1.5;
    let y = szImage / 6;
    let ms = new MS(id, 'mapG')
      .roundedRect({ w: sz, h: sz, fill: color, rounding: sz * 0.1 })
      .roundedRect({ w: sz80, h: sz80, fill: darker, rounding: sz * 0.1 })
      .text({ txt: 1, fz: sz / 2, fill: 'white' })
      .roundedRect({ className: 'unit overlay', w: sz, h: sz, fill: darker, rounding: sz * 0.1 });
    ms.tag('type', 'hidden_unit');
    ms.tag('count', 1);
    ms.tag('owner', owner);
    ms.tag('tile', tile);
    this.placeHiddenUnit(ms, owner, tile);
    this.addHiddenUnit(ms);
    return ms;
  }
  createUnit(id, o, player) {
    let nationality = o.nationality;
    let owner = getUnitOwner(nationality);
    let isNeutral = owner == 'Minor';
    unitTestUnits('__________', id, o, nationality, owner, isNeutral);
    let type = o.type;
    if (type === undefined) {
      unitTestUnits('CANNOT CREATE UNIT BECAUSE TYPE UNKNOWN!!!', player, owner);
      unitTestUnits(';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;');
    } else {
      unitTestUnits('create unit', id, o, '...player is', player);
      if (type == 'Convoy') {
        type = o.carrying;
      }
      let imagePath = '/a/assets/images/' + type + '.svg';
      let color = isNeutral ? this.assets.troopColors['Minor'] : this.assets.troopColors[nationality];
      let darker = darkerColor(color[0], color[1], color[2]);
      let sz = this.SZ.cadreDetail;
      let sz80 = sz * 0.86;
      let szImage = sz / 1.5;
      let y = szImage / 6;
      let ms = new MS(id, 'mapG')
        .roundedRect({ className: 'ground', w: sz, h: sz, fill: color, rounding: sz * 0.1 })
        .roundedRect({ w: sz80, h: sz80, fill: darker, rounding: sz * 0.1 })
        .image({ path: imagePath, y: y, w: szImage, h: szImage })
        .roundedRect({ className: 'unit overlay', w: sz, h: sz, fill: darker, rounding: sz * 0.1 });
      ms.tag('type', 'unit');
      ms.tag('owner', owner);
      ms.tag('nationality', nationality);
      ms.tag('neutral', isNeutral);
      unitTestUnits('vor placeUnit call', ms, o.tile);
      this.placeUnit(ms, o.tile);
      o.owner = owner;
      this.addUnit(id, ms, o);
      if ('cv' in o) {
        unitTestUnits('vor updateCv call', ms, o.cv);
        this.updateCv(ms, o.cv);
      }
      if (o.type == 'Convoy') {
        this.markAsConvoy(id, ms, null, o);
      }
    }
    if (isNeutral) return;
    let idHidden = this.getHiddenId(owner, o.tile);
    if (!(idHidden in this.uis)) {
      this.createHiddenUnit(idHidden, owner, o.tile);
    } else {
      unitTestUnits('hidden unit already there!!!!!!!!!!!!!', idHidden, owner, o.tile);
      this.updateUnitCounter(owner, o.tile);
    }
    this.updateVisibility(id, o, player);
  }
  getHiddenId(faction, tile) {
    return comp_(faction, tile);
  }
  getPosition(idTile) {
    let pos = this.assets.tilePositions[idTile];
    return pos;
  }
  getUnit(id) {
    return id in this.uis ? this.uis[id] : null;
  }
  markAsConvoy(id, ms, o_old, o_new) {
    if (o_new.type == 'Convoy') {
      ms.tag('isConvoy', true);
      this.uis[id].o = jsCopy(o_new);
      unitTestConvoy('unit', id, 'becomes convoy', o_new)
      ms.addBorder('blue')
    } else {
      ms.tag('isConvoy', false);
      this.uis[id].o = jsCopy(o_new);
      unitTestConvoy('going back from convoy: unit', id, 'becomes', o_new.type, o_new)
      ms.removeBorder();
    }
  }
  moveUnit(id, tile_old, o_new) {
    if (o_new.type == 'Convoy') {
      unitTestConvoy('move unit', id, 'is a CONVOY!!!!!!!!')
    }
    if (!(id in this.uis)) {
      unitTestUnits('PROBLEM: moveUnit', id, ' NOT in uis!');
      alert('PROBLEM: moveUnit ' + id + ' NOT in uis!');
    }
    let ms = this.uis[id].ms;
    let owner = ms.getTag('owner');
    let tile = ms.getTag('tile')
    this.removeUnitFromUnitsOwnerTile(id, owner, tile);
    let tile_new = o_new.tile;
    this.addUnit(id, ms, o_new);
    this.placeUnit(ms, tile_new);
    this.updateUnitCounter(owner, tile_old);
    let idHiddenNew = this.getHiddenId(owner, tile_new);
    if (!(idHiddenNew in this.uis)) {
      let msHidden_new = this.createHiddenUnit(idHiddenNew, owner, tile_new);
      this.addHiddenUnit(msHidden_new);
      unitTestUnits('moveUnit: created hidden unit', idHiddenNew);
    } else {
      this.updateUnitCounter(owner, tile_new);
    }
  }
  placeUnit(ms, tile) {
    let owner = ms.getTag('owner');
    let isNeutral = ms.getTag('neutral');
    let pStart = this.calcStartPos(tile, owner);
    let x = pStart.x;
    let y = pStart.y;
    if (!isNeutral) {
      let iUnit = tile in this.units[owner] ? this.units[owner][tile].length : 0;
      let pSnailOffset = this.snailPos[iUnit];
      x = pStart.x + pSnailOffset.x;
      y = pStart.y + pSnailOffset.y;
      unitTestUnits('index of this unit', iUnit, 'pos', x, y);
    }
    ms.setPos(x, y).draw();
    ms.tag('tile', tile);
  }
  placeHiddenUnit(msHidden, faction, tile) {
    let p = this.calcStartPos(tile, faction);
    msHidden.setPos(p.x, p.y).draw();
  }
  removeUnitFromUnitsOwnerTile(id, owner, tile) {
    unitTestMoving('vor removeUnit', id, owner, tile, this.units[owner]);
    unitTestRemove('vor removeUnit', id, owner, tile, this.units[owner]);
    removeInPlace(this.units[owner][tile], id);
  }
  resnail(owner, tile) {
    unitTestResnail('in resnail:', this.units[owner][tile]);
    let pStart = this.calcStartPos(tile, owner);
    let x = pStart.x;
    let y = pStart.y;
    let iUnit = 0;
    for (const id of this.units[owner][tile]) {
      unitTestResnail('in resnail:', id, owner, tile, x, y);
      let ms = this.uis[id].ms;
      ms.setPos(x, y);
      iUnit += 1;
      let pSnailOffset = this.snailPos[iUnit];
      x = pStart.x + pSnailOffset.x;
      y = pStart.y + pSnailOffset.y;
      unitTestResnail('in resnail:', id, owner, tile, x, y);
    }
  }
  updateUnitCounter(owner, tile) {
    unitTestUnits('updateUnitCounter', owner, tile);
    unitTestRemove('updateUnitCounter', owner, tile);
    if (!(tile in this.units[owner])) {
      unitTestRemove('nothing to update because no unit of', owner, 'has been created!');
      return;
    }
    let n = this.units[owner][tile].length;
    unitTestRemove('updateUnitCounter: units[', owner, '][', tile, '].length', n);
    let idHidden = this.getHiddenId(owner, tile);
    let msHidden = this.uis[idHidden].ms;
    let oHidden = this.uis[idHidden].o;
    if (n == 0) {
      oHidden.count = n;
      msHidden.tag('count', n);
      unitTestRemove('!!!!!!!!!!!!!!SUCCESS!!!!!!!!!!!!!!!!');
    } else {
      oHidden.count = n;
      let color = this.assets.troopColors[owner];
      let darker = darkerColor(color[0], color[1], color[2]);
      let sz = this.SZ.sumCadre;
      msHidden.removeFromChildIndex(3);
      msHidden.text({ txt: n, fz: sz / 2, fill: 'white' }).roundedRect({
        className: 'unit overlay',
        w: sz,
        h: sz,
        fill: darker,
        rounding: sz * 0.1
      });
      msHidden.tag('count', n);
      unitTestUnits('updateUnitCounter', owner, tile, 'to', n, oHidden, msHidden);
    }
  }
  updateCv(ms, cv) {
    ms.removeFromChildIndex(5);
    let sz = this.SZ.cadreDetail;
    let dx = sz / (cv + 1);
    let xStart = -sz / 2;
    let y = -sz / 3.2;
    let diam = Math.min(dx / 1.5, sz / 5);
    let x = dx + xStart;
    for (let i = 0; i < cv; i++) {
      ms.circle({ sz: diam, x: x, y: y, fill: 'white' });
      x += dx;
    }
    ms.tag('cv', cv);
    this.uis[ms.id].o.cv = cv;
    unitTestUnits('updateCv', ms.id, ms.getTag('owner'), ms.getTag('tile'), 'to', cv);
  }
  updateVisibility(id, o, player) {
    unitTestUnitVisibility('update Visibility', 'id', id, 'o', o, 'player', player);
    let ms = id in this.uis ? this.uis[id].ms : null;
    unitTestUnitVisibility('update Visibility ms=', ms);
    let tile = o.tile;
    let owner = getUnitOwner(o.nationality);
    unitTestRemove('updating Visibility of', id, owner, tile)
    let idHidden = this.getHiddenId(owner, tile);
    let vis = isVisibleToPlayer(o, player);
    unitTestRemove('-------------vis', vis, 'idHidden', idHidden)
    if (idHidden in this.uis) {
      let msHidden = this.uis[idHidden].ms;
      unitTestRemove('-------------msHidden', msHidden)
      if (vis) {
        msHidden.hide();
      } else {
        if (msHidden.getTag('count') > 0) msHidden.show(); else msHidden.hide();
      }
    }
    if (ms) {
      if (vis) {
        ms.show();
      } else {
        ms.hide();
      }
    }
  }
  update(data, gObjects, player) {
    if ('created' in data) {
      for (const id in data.created) {
        let o_new = data.created[id];
        if (o_new.obj_type != 'unit') continue;
        if (!(id in gObjects)) {
          unitTestUnits('about to create unit', id, o_new);
          this.createUnit(id, o_new, player);
          if (id in this.uis) {
            gObjects[id] = o_new;
          } else {
            unitTestUnits(':::::::UNIT WAS NOT CREATED!!!');
          }
        } else {
          let o_old = gObjects[id];
          console.assert(id in this.uis, 'unit in G but not in uis', id, o_new);
          let d = propDiff(o_old, o_new);
          if (d.hasChanged) {
            let owner = getUnitOwner(o_old.nationality);
            if (d.summary.includes('type')) {
              console.assert(player != owner || o_old.type == 'Convoy' || o_new.type == 'Convoy', 'type change other than convoy!!!!');
              if ('type' in o_new) {
                console.assert(o_old.type == 'Convoy' || o_new.type == 'Convoy', 'type change other than convoy!!!!');
                unitTestUnits('!!!!!!! for not this temp type change NOT reflected in G!!!!');
                this.markAsConvoy(id, this.uis[id].ms, o_old, o_new);
                unitTestUnits('>>>>>MARK AS CONVOY!!!!!!!!!!!!');
                unitTestUnits(id, 'type was ' + o_old.type + ' new=' + o_new.type);
              }
            }
            if (d.summary.includes('cv') && o_new.cv != undefined) {
              unitTestUnits('cv change!!!!! ' + o_old.cv + ' ' + o_new.cv);
              this.updateCv(this.uis[id].ms, o_new.cv);
              gObjects[id] = o_new;
            }
            if (d.summary.includes('tile')) {
              let oldTile = o_old.tile;
              gObjects[id].tile = o_new.tile;
              this.moveUnit(id, oldTile, gObjects[id]);
              unitTestResnail('vor resnail: unit', id, o_new.nationality, o_new.type, 'moved to', o_new.tile)
              this.resnail(owner, oldTile);
              unitTestUnits('unit', id, 'has moved from', oldTile, 'to', gObjects[id].tile);
              unitTestMoving('unit', id, 'has moved from', oldTile, 'to', gObjects[id].tile);
            }
            if (d.summary.includes('visible')) {
              gObjects[id].visible = o_new.visible;
              this.uis[id].o.visible = o_new.visible;
            }
          }
        }
      }
    }
    if ('removed' in data) {
      for (const id in data.removed) {
        if (id in gObjects) {
          let o = gObjects[id];
          if (o.obj_type == 'unit') {
            let ms = this.uis[id].ms;
            let owner = ms.getTag('owner');
            let tile = ms.getTag('tile');
            this.removeUnitFromUnitsOwnerTile(id, owner, tile);
            let neutral = ms.getTag('neutral');
            unitTestRemove('vor aufruf UpdateUnitCounter', o, id, data.removed[id]);
            if (!neutral) this.updateUnitCounter(owner, tile);
            ms.removeFromUI();
            delete this.uis[id];
            delete gObjects[id];
            unitTestRemove('nach remove unit', id, gObjects, this.units, this.uis)
            unitTestResnail('vor resnail: unit', id, o.nationality, o.type, 'removed from', tile)
            this.resnail(owner, tile);
          }
        }
      }
    }
    unitTestUnits('...visibility is updated for all units!');
    for (const id in this.uis) {
      const ms = this.uis[id].ms;
      const owner = ms.getTag('owner');
      const o = this.uis[id].o;
      const isHidden = o.obj_type == 'hidden_unit';
      if (isHidden) {
        let cnt = ms.getTag('count');
        if (cnt == 0) ms.hide();
        unitTestRemove('HIDING HIDDEN UNIT WITH COUNT 0', id)
      } else {
        this.updateVisibility(id, o, player);
      }
    }
    unitTestUnits('player', player, 'previousPlayer:', this.previousPlayer);
    this.previousPlayer = player;
  }
}
class Banner {
  constructor(pos, dParent) { this.pos = pos; this.dParent = isdef(dParent) ? dParent : dBanner; this.init(); }
  clear() { clearElement(this.dParent); this.dParent.onclick = null; hide(this.dParent); }
  _createDivs() {
    this.dInstruction = mDiv(this.dContent);
    this.dMain = mDiv(this.dContent);
    this.dHint = mDiv(this.dContent); this.dHint.innerHTML = 'hallo'; this.dHint.style.opacity = 0;
  }
  _createScreen() {
    show(this.dParent);
    let bg = colorTrans('silver', .25);
    let d = mScreen(this.dParent, { bg: bg, display: 'flex', layout: 'fvcc' });
    let dContent = mDiv(d, { display: 'flex', layout: 'fvcs', fg: 'contrast', fz: 24, bg: 'silver', patop: 50, pabottom: 50, matop: -50, w: '100vw' });
    if (isdef(this.pos)) mStyleX(dContent, { matop: this.pos });
    return [d, dContent];
  }
  init() {
    [this.div, this.dContent] = this._createScreen();
    this.dParent.onclick = () => this.clear();
    this._createDivs();
  }
  message(arr, callback) {
    this.dInstruction.innerHTML = arr.join(' ');
    if (isdef(callback)) this.dParent.onclick = () => { this.clear(); callback(); };
  }
}
class Board {
  constructor(rows, cols, handler, cellStyle) {
    let styles = isdef(cellStyle) ? cellStyle : { margin: 4, w: 150, h: 150, bg: 'white', fg: 'black' };
    this.rows = rows;
    this.cols = cols;
    let items = this.items = iGrid(this.rows, this.cols, dTable, styles);
    items.map(x => {
      let d = iDiv(x);
      mCenterFlex(d);
      d.onclick = handler;
    });
  }
  get(ir, c) {
    if (isdef(c)) {
      let idx = ir * this.cols + c;
      return this.items[idx];
    } else {
      return this.items[ir];
    }
  }
  getState() {
    return this.items.map(x => x.label);
  }
  setState(arr, colors) {
    if (isEmpty(arr)) return;
    if (isList(arr[0])) { arr = arrFlatten(arr); }
    for (let i = 0; i < arr.length; i++) {
      let item = this.items[i];
      let val = arr[i];
      if (!EmptyFunc(val)) {
        addLabel(item, val, { fz: 60, fg: colors[val] });
      } else item.label = val;
    }
  }
  clear() {
    for (const item of this.items) {
      let dLabel = iLabel(item);
      if (isdef(dLabel)) { removeLabel(item); item.label = null; }
    }
  }
}
class Board2D {
  constructor(rows, cols, dParent, cellStyles, boardStyles, handler) {
    cellStyles = this.cellStyles = isdef(cellStyles) ? cellStyles : { margin: 4, w: 150, h: 150, bg: 'white', fg: 'black' };
    boardStyles = this.boardStyles = isdef(boardStyles) ? boardStyles : { bg: 'silver', fg: 'black' };
    this.rows = rows;
    this.cols = cols;
    this.dParent = dParent;
    let dBoard = this.dBoard = mDiv(dParent);
    let items = this.items = this.fill(dBoard, this.rows, this.cols, null, cellStyles);
  }
  fill(d, rows, cols, items, cellStyles) {
    if (nundef(items)) items = [];
    clearElement(d);
    mStyle(d, { display: 'grid', 'grid-template-columns': cols });
    for (let i = 0; i < rows * cols; i++) {
      let item = items[i];
      if (isdef(item)) {
        let d1 = iDiv(item);
        if (isdef(d1)) mAppend(d, iDiv(item));
        else {
          d1 = mDiv(d, cellStyles); iAdd(item, { div: d1 }); mAppend(d, d1);
        }
      } else {
        let [r, c] = iToRowCol(i);
        item = { row: r, col: c, index: i };
        let d1 = mDiv(d, cellStyles); iAdd(item, { div: d1 }); mAppend(d, d1);
      }
      mStyle(iDiv(item), cellStyles);
      items.push(item)
    }
    return items;
  }
  get(ir, c) {
    if (isdef(c)) {
      let idx = ir * this.cols + c;
      return this.items[idx];
    } else {
      return this.items[ir];
    }
  }
  getState() {
    return this.items.map(x => x.label);
  }
  setState(arr, colors) {
    if (isEmpty(arr)) return;
    if (isList(arr[0])) { arr = arrFlatten(arr); }
    for (let i = 0; i < arr.length; i++) {
      let item = this.items[i];
      let val = arr[i];
      if (!EmptyFunc(val)) {
        addLabel(item, val, { fz: 60, fg: colors[val] });
      } else item.label = val;
    }
  }
  clear() {
    for (const item of this.items) {
      let dLabel = iLabel(item);
      if (isdef(dLabel)) { removeLabel(item); item.label = null; }
    }
  }
}
class CacheDict {
  constructor(primKey, { func = null } = {}, useLocal = true) {
    this.primKey = primKey;
    this.func = func;
    this.live = null;
    this.useLocal = useLocal;
  }
  async load() {
    if (this.live) return this;
    return this._local() || await this._server();
  }
  invalidate() {
    localStorage.removeItem(this.primKey);
    this.live = null;
  }
  async reload() { this.invalidate(); return await this.load(); }
  _local() {
    if (!this.useLocal) return null;
    let res = localStorage.getItem(this.primKey);
    if (res) this.live = JSON.parse(res);
    return res;
  }
  async _server() {
    if (this.func) {
      this.live = await this.func();
      if (this.useLocal) localStorage.setItem(this.primKey, JSON.stringify(this.live));
    }
    return this.func;
  }
}
class Calculus {
  limRightOf(x, func) {
    if (this.canPlugin(x, func)) {
      return func(x);
    }
    if (Math.abs(x) == Infinity) {
      return this.toInfinty(x, func);
    }
    var right1 = func(x + 0.000000000000001);
    var right2 = func(x + 0.00000000000001);
    var right3 = func(x + 0.0000000000001);
    var rightDif1 = right2 - right1;
    var rightDif2 = right3 - right2;
    if (rightDif1 < rightDif2 && rightDif2 < 0) {
      return Infinity;
    }
    if (rightDif1 > rightDif2 && rightDif2 > 0) {
      return -1 * Infinity;
    }
    return this.round(right1);
  }
  limLeftOf(x, func) {
    if (this.canPlugin(x, func)) {
      return func(x);
    }
    if (Math.abs(x) == Infinity) {
      return this.toInfinty(x, func);
    }
    var left1 = func(x - 0.000000000000001);
    var left2 = func(x - 0.00000000000001);
    var left3 = func(x - 0.0000000000001);
    var leftDif1 = left2 - left3;
    var leftDif2 = left1 - left2;
    if (leftDif2 > leftDif1 && leftDif2 > 0) {
      return Infinity;
    }
    if (leftDif2 < leftDif1 && leftDif2 < 0) {
      return -1 * Infinity;
    }
    return this.round(left1);
  }
  limAt(x, func) {
    if (this.canPlugin(x, func)) {
      return func(x);
    }
    if (Math.abs(x) == Infinity) {
      return this.toInfinty(x, func);
    }
    var left1 = func(x - 0.000000000000001);
    var right1 = func(x + 0.000000000000001);
    if (Math.abs(left1 - right1) < 0.00001) {
      return this.round((left1 + right1) / 2);
    }
    return NaN;
  }
  canPlugin(x, func) {
    var at = func(x);
    return at === at && Math.abs(at) != Infinity;
  }
  toInfinty(x, func) {
    if (x > 0) {
      var pos1 = Number.MAX_VALUE * 0.99999;
      var pos2 = Number.MAX_VALUE;
      var dif = pos2 - pos1;
      if (dif > 0) {
        return Infinity;
      } else {
        return -1 * Infinity;
      }
    } else {
      var pos1 = Number.MIN_VALUE;
      var pos2 = Number.MIN_VALUE * 0.99999;
      var dif = pos2 - pos1;
      if (dif < 0) {
        return Infinity;
      } else {
        return -1 * Infinity;
      }
    }
  }
  deriv(x1, func) {
    var at = func(x1);
    if (Math.abs(at) == Infinity || at !== at) {
      return NaN;
    }
    var y1 = func(x1);
    var x0 = x1 - 0.000000000000001;
    var y0 = func(x0);
    var x2 = x1 + 0.000000000000001;
    var y2 = func(x2);
    var slope1 = this.slope(x0, y0, x1, y1);
    var slope2 = this.slope(x1, y1, x2, y2);
    if (Math.abs(slope1 - slope2) > 0.1) {
      return NaN;
    }
    return (slope1 + slope2) / 2;
  }
  nthDeriv(n, x1, func) {
    var vals = [];
    var start = -1 * Math.round(n / 2);
    for (var i = start; i <= n + start + 1; i++) {
      var newX = x1 + i * 0.000000000000001;
      var newY = func(newX);
      vals.push(newY);
    }
    for (var i = 0; i < n; i++) {
      var diffs = [];
      for (var j = 1; j < vals.length; j++) {
        diffs.push(vals[j] - vals[j - 1]);
      }
      vals = diffs;
    }
    var out = (vals[0] + vals[1]) / 0.000000000000002;
    return out;
  }
  integral(min, max, func, num) {
    var sum = 0;
    var dx = (max - min) / num;
    var currentX = min + dx / 2;
    for (var i = 0; i < num; i++) {
      var currentY = func(currentX);
      sum += dx * currentY;
      currentX += dx;
    }
    return sum;
  }
  averageValue(min, max, func, num) {
    return this.integral(min, max, func, num) / (max - min);
  }
  distance(x1, y1, x2, y2) {
    return Math.sqrt((x1 - x2) * (x1 - x2) - (y1 - y2) * (y1 - y2));
  }
  slope(x1, y1, x2, y2) {
    return (y1 - y2) / (x1 - x2);
  }
  round(num) {
    var factor = 100000000000000;
    return Math.round(num * factor) / factor;
  }
}
class Card52 {
  static toString(c) { return c.rank + ' of ' + c.suit; }
  static _getKey(i) {
    if (i >= 52) return 'card_J1';
    let rank = Card52.getRank(i);
    let suit = Card52.getSuit(i);
    return 'card_' + rank + suit;
  }
  static _fromKey(k) {
    let ranks = 'A23456789TJQK';
    let suits = 'SHDC';
    let ir = ranks.indexOf(k[0]);
    let is = suits.indexOf(k[1]);
    return is * 13 + ir;
  }
  static getRankValue(i) { if (nundef(i)) return null; let r = i % 13; return r == 0 ? 12 : r - 1; }
  static getRank(i) {
    let rank = (i % 13);
    if (rank == 0) rank = 'A';
    else if (rank >= 9) rank = ['T', 'J', 'Q', 'K'][rank - 9];
    else rank = rank + 1;
    return rank;
  }
  static getSuit(i) {
    let s = ['S', 'H', 'D', 'C'][divInt(i, 13)];
    return s;
  }
  static getShortString(c) { return c.suit + c.rank; }
  static turnFaceDown(c, color) {
    if (!c.faceUp) return;
    let svgCode = C52.card_2B;
    c.div.innerHTML = svgCode;
    if (isdef(color)) c.div.children[0].children[1].setAttribute('fill', color);
    c.faceUp = false;
  }
  static turnFaceUp(c) {
    if (c.faceUp) return;
    c.div.innerHTML = C52[c.key];
    c.faceUp = true;
  }
  static fromSR(sr, h) { return Card52.fromShortString(sr, h); }
  static fromShortString(sr, h) {
    let key = sr[1].toUpperCase() + sr[0].toUpperCase();
    let i = Card52._fromKey(key);
    console.log('card from ', sr, 'is', key, 'i', i)
    return Card52.getItem(i, h);
  }
  static get(sr, h) { return Card52.fromSR(sr, h); }
  static getItem(i, h = 110, w) {
    if (nundef(w)) w = h * .7;
    if (nundef(i)) i = randomNumber(0, 51);
    if (isString(i) && i.length == 2) { i = Card52._fromKey(i[1].toUpperCase() + i[0].toUpperCase()); }
    let c = Card52._createUi(i, undefined, w, h);
    c.i = c.val = i;
    return c;
  }
  static _createUi(irankey, suit, w, h) {
    //#region set rank and suit from inputs
    let rank = irankey;
    if (nundef(irankey) && nundef(suit)) {
      [rank, suit] = Card52.randomRankSuit();
    } else if (nundef(irankey)) {
      irankey = '2';
      suit = 'B';
    } else if (nundef(suit)) {
      if (isNumber(irankey)) irankey = Card52._getKey(irankey);
      rank = irankey[5];
      suit = irankey[6];
    }
    if (rank == '10') rank = 'T';
    if (rank == '1') rank = 'A';
    if (nundef(suit)) suit = 'H'; else suit = suit[0].toUpperCase();
    //#endregion
    //#region load svg for card_[rank][suit] (eg. card_2H)
    let cardKey = 'card_' + rank + suit;
    let svgCode = C52[cardKey];
    svgCode = '<div>' + svgCode + '</div>';
    let el = mCreateFrom(svgCode);
    if (isdef(h) || isdef(w)) { mSize(el, w, h); }
    //#endregion
    return { rank: rank, suit: suit, key: cardKey, div: el, w: w, h: h, faceUp: true };
  }
  static random() { return Card52.getItem(randomNumber(0, 51)); }
  static randomRankSuit() {
    let c = Card52.random();
    return [c.rank, c.suit];
  }
  static show(icard, dParent, h = 110, w = undefined) {
    if (isNumber(icard)) {
      if (nundef(w)) w = h * .7;
      icard = Card52.getItem(icard, h, w);
    }
    mAppend(dParent, icard.div);
  }
}
class Cardz {
  static toString(c) { return c.rank + ' of ' + c.suit; }
  static _getKey(i) {
    if (i >= 52) return 'card_J1';
    let rank = Card52.getRank(i);
    let suit = Card52.getSuit(i);
    return 'card_' + rank + suit;
  }
  static _fromKey(k) {
    let ranks = 'A23456789TJQK';
    let suits = 'SHDC';
    let i_rank = ranks.indexOf(k[0]);
    let i_suit = suits.indexOf(k[1]);
    return i_suit * ranks.length + i_rank;
  }
  static getRankValue(i) { if (nundef(i)) return null; let r = i % 13; return r == 0 ? 12 : r - 1; }
  static getRank(i) {
    let rank = (i % 13);
    if (rank == 0) rank = 'A';
    else if (rank >= 9) rank = ['T', 'J', 'Q', 'K'][rank - 9];
    else rank = rank + 1;
    return rank;
  }
  static getSuit(i) {
    let s = ['S', 'H', 'D', 'C'][divInt(i, 13)];
    return s;
  }
  static getShortString(c) { return c.suit + c.rank; }
  static turnFaceDown(c, color) {
    if (!c.faceUp) return;
    let svgCode = C52.card_2B;
    c.div.innerHTML = svgCode;
    if (isdef(color)) c.div.children[0].children[1].setAttribute('fill', color);
    c.faceUp = false;
  }
  static turnFaceUp(c) {
    if (c.faceUp) return;
    c.div.innerHTML = C52[c.key];
    c.faceUp = true;
  }
  static fromSR(sr) { return Card52.fromShortString(sr); }
  static fromShortString(sr) {
    let key = sr[1].toUpperCase() + sr[0].toUpperCase();
    let i = Card52._fromKey(key);
    console.log(key, 'i', i)
    return Card52.getItem(i);
  }
  static getItem(i, h = 110, w) {
    if (nundef(w)) w = h * .7;
    if (nundef(i)) i = randomNumber(0, 51);
    if (isString(i) && i.length == 2) { i = Card52._fromKey(i[1].toUpperCase() + i[0].toUpperCase()); }
    let c = Card52._createUi(i, undefined, w, h);
    c.i = c.val = i;
    return c;
  }
  static _createUi(irankey, suit, w, h) {
    //#region set rank and suit from inputs
    let rank = irankey;
    if (nundef(irankey) && nundef(suit)) {
      [rank, suit] = Card52.randomRankSuit();
    } else if (nundef(irankey)) {
      irankey = '2';
      suit = 'B';
    } else if (nundef(suit)) {
      if (isNumber(irankey)) irankey = Card52._getKey(irankey);
      rank = irankey[5];
      suit = irankey[6];
    }
    if (rank == '10') rank = 'T';
    if (rank == '1') rank = 'A';
    if (nundef(suit)) suit = 'H'; else suit = suit[0].toUpperCase();
    //#endregion
    //#region load svg for card_[rank][suit] (eg. card_2H)
    let cardKey = 'card_' + rank + suit;
    let svgCode = C52[cardKey];
    svgCode = '<div>' + svgCode + '</div>';
    let el = mCreateFrom(svgCode);
    if (isdef(h) || isdef(w)) { mSize(el, w, h); }
    //#endregion
    return { rank: rank, suit: suit, key: cardKey, div: el, w: w, h: h, faceUp: true };
  }
  static random() { return Card52.getItem(randomNumber(0, 51)); }
  static randomRankSuit() {
    let c = Card52.random();
    return [c.rank, c.suit];
  }
  static show(icard, dParent, h = 110, w = undefined) {
    if (isNumber(icard)) {
      if (nundef(w)) w = h * .7;
      icard = Card52.getItem(icard, h, w);
    }
    mAppend(dParent, icard.div);
  }
}
class CCanvas {
  constructor(dParent, styles, bstyles, play, pause, origin = 'cc') {
    let o = mCanvas(dParent, styles, bstyles, play, pause);
    [this.cv, this.cx, this.play, this.pause] = [o.cv, o.cx, o.play, o.pause];
    let [w, h] = [this.w, this.h] = [this.cv.width, this.cv.height];
    this.defaultsize = 20;
    this.origin = this.init_origin(origin);
    this.cx.translate(this.origin.x, this.origin.y);
    this.maxx = w - this.origin.x; this.minx = this.maxx - w;
    this.maxy = h - this.origin.y; this.miny = this.maxy - h;
    this.items = [];
  }
  add(o = {}) {
    addKeys({ canvas: this, x: 0, y: 0, color: rColor(50), w: this.defaultsize, h: this.defaultsize, a: 0, draw: null }, o);
    this.items.push(o);
    return o;
  }
  clear() { cClear(this.cv, this.cx); }
  clamp(item) { item.x = clamp(item.x, this.minx + item.w / 2, this.maxx - item.x / 2); item.y = clamp(item.y, this.miny + item.h / 2, this.maxy - item.h / 2) }
  cycle(item) { item.x = cycle(item.x, this.minx, this.maxx); item.y = cycle(item.y, this.miny, this.maxy) }
  draw() {
    this.clear();
    for (const item of this.items) {
      this.draw_item(item);
    }
  }
  draw_item(item) {
    let cx = this.cx;
    cx.save();
    cx.translate(item.x, item.y);
    cx.rotate(toRadian(item.a));
    if (isdef(item.draw)) { item.draw(this, item); }
    else cEllipse(0, 0, item.w, item.h, { bg: item.color }, 0, cx);
    cx.restore();
  }
  init_origin(origin) {
    if (nundef(origin)) origin = 'cc';
    let pt = origin;
    if (isString(origin)) {
      let v = origin[0], h = origin[1];
      let y = v == 't' ? 0 : v == 'c' ? this.cv.height / 2 : this.cv.height;
      let x = h == 'l' ? 0 : h == 'c' ? this.cv.width / 2 : this.cv.width;
      pt = { x: x, y: y };
    }
    return pt;
  }
  update() {
    let n = 0;
    for (const item of this.items) { if (isdef(item.update)) { n += item.update(this, item) ? 1 : 0; } }
    return n > 0;
  }
}
class CItemWalker {
  constructor(name, options = {}) {
    options.label = name;
    addKeys({ x: 0, y: 0, color: rColor(60) }, options);
    if (isdef(options.sz)) options.w = options.h = options.sz;
    addKeys(options, this);
  }
  update() { move_random(this, this.canvas); }
  draw() { draw_label(this.canvas, this); }
}
class ControllerSolitaire {
  constructor(g, user) { this.g = g; this.player = user; }
  stopGame() { resetState(); }
  startGame() {
    resetState();
    this.g.successFunc = successPictureGoal;
    this.g.failFunc = failPictureGoal;
    this.g.correctionFunc = showCorrectWord;
    this.g.startGame();
    this.startLevel();
  }
  startLevel() {
    Settings.updateGameValues(this.player, this.g);
    this.g.start_Level();
    this.startRound();
  }
  startRound() {
    resetRound();
    uiActivated = false;
    this.g.startRound();
    TOMain = setTimeout(() => this.prompt(), 300);
  }
  prompt() {
    QContextCounter += 1;
    showStats();
    this.g.trialNumber = 0;
    this.g.prompt();
  }
  promptNextTrial() {
    QContextCounter += 1;
    clearTimeout(TOTrial);
    uiActivated = false;
    let delay = this.g.trialPrompt(this.g.trialNumber);
    TOMain = setTimeout(() => this.activateUi(), delay);
  }
  activateUi() {
    Selected = null;
    uiActivated = true;
    this.g.activate();
  }
  evaluate() {
    if (!canAct()) return;
    uiActivated = false; clearTimeouts();
    IsAnswerCorrect = this.g.eval(...arguments);
    if (IsAnswerCorrect === undefined) { this.promptNextTrial(); return; }
    this.g.trialNumber += 1;
    if (!IsAnswerCorrect && this.g.trialNumber < this.g.trials) { this.promptNextTrial(); return; }
    if (IsAnswerCorrect) { DELAY = isdef(Selected.delay) ? Selected.delay : this.g.spokenFeedback ? 1500 : 300; this.g.successFunc(); }
    else { DELAY = this.g.correctionFunc(); this.g.failFunc(); }
    let nextLevel = scoring(IsAnswerCorrect);
    if (DELAY > 2000) showActiveMessage('click to continue...', () => this.gotoNext(nextLevel));
    TOMain = setTimeout(() => this.gotoNext(nextLevel), DELAY);
  }
  gotoNext(nextLevel) {
    onclick = null;
    removeMarkers();
    clearTimeouts();
    if (Score.gameChange) {
      setNextGame();
      if (GameTimer.unitTimeUp()) { gameOver('Great job! Time for a break!'); } else { GC.startGame(); }
    } else if (Score.levelChange && nextLevel <= this.g.maxLevel) {
      this.g.level = nextLevel;
      setBadgeLevel(this.g.level);
      this.startLevel();
    } else { this.startRound(); }
  }
}
class ControllerTTT {
  constructor(g, user) {
    this.g = g;
    this.createPlayers(user);
    GameCounter = 0;
  }
  write() { write('gc', ...arguments); }
  createPlayers(user) {
    this.write('create players')
    let players = this.players = this.g.players = [];
    let h = this.human = this.g.human = new SoloPlayer(user);
    let a = this.ai = this.g.ai = new AIPlayer();
    players.push(this.human);
    players.push(this.ai);
    this.ai.color = RED;
  }
  startGame() {
    this.write('start game')
    GameCounter += 1;
    resetState();
    this.g.startGame();
    this.startRound();
  }
  startRound() {
    this.write('start round')
    this.deactivateUi();
    this.g.startRound();
    showStats();
    this.prompt();
  }
  prompt() {
    this.write('prompt')
    this.g.prompt();
  }
  uiInteract(ev) { if (canHumanAct()) this.g.interact(ev); }
  activateUi() {
    this.write('activate');
    if (this.g.plTurn == this.g.ai) aiActivated = true; else uiActivated = true;
    this.g.activate();
  }
  deactivateUi() { aiActivated = uiActivated = false; }
  evaluate() {
    this.write('evaluate')
    this.deactivateUi();
    this.g.eval(...arguments);
    this.write('gameOver', this.g.gameOver)
    if (this.g.gameOver) {
      let msg, sp;
      if (this.g.winner && this.g.winner == this.ai) { msg = 'AI wins!'; sp = 'A.I. wins!'; this.ai.score += 1; }
      else if (this.g.winner) { msg = sp = 'You win!!!'; this.human.score += 1; }
      else { msg = "It's a tie"; sp = 'tie: no one wins'; if (nundef(this.tie)) this.tie = 1; else this.tie += 1; }
      if (this.g.info) msg += ' ' + this.g.info;
      Score.nTotal += 1;
      Score.nCorrect = Score.nWins = this.human.score;
      Score.nLoses = this.ai.score;
      Score.nTied = this.tie;
      showScore();
      showInstruction('', msg, dTitle, !this.g.silentMode, sp);
      TOMain = setTimeout(() => {
        if (GameCounter <= 3) this.bPlay = mButton('play again', () => { resetRound(); this.startGame(); }, dTable, { fz: 28, margin: 20, rounding: 10, vpadding: 6, hpadding: 12, border: 8 }, ['buttonClass']);
        this.bPlay = mButton('next game', () => { setNextGame(); GC.startGame(); }, dTable, { fz: 28, margin: 20, rounding: 10, vpadding: 6, hpadding: 12, border: 8 }, ['buttonClass']);
      }, 1500);
    } else {
      this.g.changePlayer();
      this.startRound();
    }
  }
}
class CountdownTimer {
  constructor(ms, elem) {
    this.timeLeft = ms;
    this.msStart = Daat.now();
    this.elem = elem;
    this.tick();
  }
  msElapsed() { return Date.now() - this.msStart; }
  tick() {
    this.timeLeft -= this.msElapsed;
    this.elem.innerHTML = this.timeLeft;
    if (this.timeLeft > 1000) {
      setTimeout(this.tick.bind(this), 500);
    } else this.elem.innerHTML = 'timeover';
  }
}
class CTimer {
  constructor(elem, msTick, onTick, msTotal, onElapsed) {
    this.elem = elem;
    this.msTotal = this.msLeft = msTotal;
    this.onTick = onTick;
    this.onElapsed = onElapsed;
    this.interval = msTick;
    this.running = false;
    this.paused = false;
    this.game = G.name;
    this.button = mButton('click', this.togglePause.bind(this), this.elem, { transition: 'all 1s ease', display: 'inline-block', fz: 20, rounding: 12, bg: GREEN, w: 260 }, 'mybutton');
    this.TO = null;
  }
  togglePause() { if (this.paused) this.continue(); else this.pause(); }
  clear() { this.stop(); clearElement(this.elem); }
  continue() {
    if (!this.running) this.start();
    else if (!this.paused) return;
    else { this.paused = false; this.TO = setInterval(this.tickHandler.bind(this), this.interval); }
  }
  tickHandler() {
    this.msLeft -= this.interval;
    let [ms, unit] = [this.msLeft, this.msTotal / 6];
    this.msElapsed = this.msTotal - this.msLeft;
    this.button.innerHTML = timeConversion(Math.max(this.msLeft, 0), 'sh');
    let bg = ms > unit * 4 ? GREEN : ms > unit * 2 ? YELLOW : ms > unit ? 'orange' : RED;
    this.button.style.background = bg;
    if (isdef(this.onTick)) this.onTick();
    if (this.msLeft <= 0) {
      this.stop();
      if (isdef(this.onElapsed)) {
        console.assert(G.name == this.game, 'game not the same!!! ' + G.name + ' ' + this.game);
        this.onElapsed();
      }
    }
  }
  start() {
    if (this.running) this.stop();
    this.started = new Date().now;
    this.msLeft = this.msTotal;
    this.msElapsed = 0;
    this.running = true;
    this.TO = setInterval(this.tickHandler.bind(this), this.interval);
  }
  stop() {
    if (!this.running) return;
    clearInterval(this.TO);
    this.running = false;
  }
  pause() {
    if (this.paused || !this.running) return;
    clearInterval(this.TO);
    this.paused = true;
  }
}
class CTimer_dep {
  constructor(elem, msTick, onTick, msTotal, onElapsed) {
    this.elem = elem;
    this.msTotal = this.msLeft = msTotal;
    this.onTick = onTick;
    this.onElapsed = onElapsed;
    this.interval = msTick;
    this.running = false;
    this.paused = false;
    this.game = G.name;
    this.button = mButton('click', this.togglePause.bind(this), this.elem, { transition: 'all 1s ease', display: 'inline-block', fz: 20, rounding: 12, bg: GREEN, w: 260 }, 'mybutton');
    this.TO = null;
  }
  togglePause() { if (this.paused) this.continue(); else this.pause(); }
  clear() { this.stop(); clearElement(this.elem); }
  continue() {
    if (!this.running) this.start();
    else if (!this.paused) return;
    else { this.paused = false; this.TO = setInterval(this.tickHandler.bind(this), this.interval); }
  }
  tickHandler() {
    this.msLeft -= this.interval;
    let [ms, unit] = [this.msLeft, this.msTotal / 6];
    this.msElapsed = this.msTotal - this.msLeft;
    this.button.innerHTML = timeConversion(Math.max(this.msLeft, 0), 'sh');
    let bg = ms > unit * 4 ? GREEN : ms > unit * 2 ? YELLOW : ms > unit ? 'orange' : RED;
    this.button.style.background = bg;
    if (isdef(this.onTick)) this.onTick();
    if (this.msLeft <= 0) {
      this.stop();
      if (isdef(this.onElapsed)) {
        console.assert(G.name == this.game, 'game not the same!!! ' + G.name + ' ' + this.game);
        this.onElapsed();
      }
    }
  }
  start() {
    if (this.running) this.stop();
    this.started = new Date / 1e3 | 0;
    this.msLeft = this.msTotal;
    this.msElapsed = 0;
    this.running = true;
    this.TO = setInterval(this.tickHandler.bind(this), this.interval);
  }
  stop() {
    if (!this.running) return;
    clearInterval(this.TO);
    this.running = false;
  }
  pause() {
    if (this.paused || !this.running) return;
    clearInterval(this.TO);
    this.paused = true;
  }
}
class DeckClass {
  constructor(f) { this.data = []; if (isdef(f)) if (isString(f)) this['init' + f](); else if (isList(f)) this.init(f); }
  init(arr) { this.data = arr; }
  initEmpty() { this.data = []; }
  initNumber(n, shuffled = true) { this.initTest(n, shuffled); }
  initTest(n, shuffled = true) { this.data = range(0, n - 1); if (shuffled) this.shuffle(); }
  init52(shuffled = true, jokers = 0) { this.data = range(0, 51 + jokers); if (shuffled) this.shuffle(); }
  init52_double(shuffled = true, jokers = 0) { this.data = range(0, 103 + jokers); if (shuffled) this.shuffle(); }
  init52_no_suits(n = 4, shuffled = true, jokers = 0) { this.data = range(0, 13 * n + jokers - 1); if (shuffled) this.shuffle(); }
  initRandomHand52(n) { this.data = choose(range(0, 51), n); }
  addTop(i) { this.data.push(i); return this; }
  addBottom(i) { this.data.unshift(i); return this; }
  bottom() { return this.data[0]; }
  cards() { return this.data; }
  count() { return this.data.length; }
  clear() { this.data = []; }
  deal(n) { return this.data.splice(0, n); }
  dealDeck(n) { let d1 = new DeckClass(); d1.init(this.data.splice(0, n)); return d1; }
  popTop() { return this.data.pop(); }
  popBottom() { return this.data.shift(); }
  remTop() { this.data.pop(); return this; }
  remBottom() { this.data.shift(); return this; }
  remove(i) { removeInPlace(this.data, i); return this; }
  removeAtIndex(i) { return this.data.splice(i, 1)[0]; }
  removeFromIndex(i, n) { return this.data.splice(i, n); }
  setData(arr, shuffled = false) { this.data = arr; if (shuffled) this.shuffle(); }
  sort() {
    this.data.sort((a, b) => Number(a) - Number(b));
    return this;
  }
  shuffle() { shuffle(this.data); return this; }
  top() { return arrLast(this.data); }
  toString() { return this.data.toString(); }
}
class DeckMS {
  constructor(oid, o) {
    this.o = o;
    this.oid = this.id = oid;
    this.elem = document.createElement('div');
    this.elem.id = oid;
    o.mount(this.elem);
    registerElement(this);
  }
  detach() {
    if (this.parent) {
      this.parent.removeChild(this.elem);
      this.parent = null;
    }
  }
  attachTo(div, { placeInCenter = true } = {}) {
    this.detach();
    this.parent = div;
    div.appendChild(this.elem);
    if (placeInCenter) this.center();
  }
  center() {
    if (this.parent) {
      let d = this.elem;
      let wParent = this.parent.offsetWidth;
      let wElem = this.o.cards.length > 0 ? this.o.cards[0].elem.offsetWidth : 78;
      let hParent = this.parent.offsetHeight;
      let hElem = this.o.cards.length > 0 ? this.o.cards[0].elem.offsetHeight : 110;
      d.style.position = 'relative';
      this.centerX = (wParent - wElem) / 2;
      this.centerY = (hParent - hElem) / 2;
      this.w = wElem;
      this.h = hElem;
      d.style.left = '' + this.centerX + 'px';
      d.style.top = '' + this.centerY + 'px';
    }
  }
  setPos(x, y) {
    this.elem.style.left = '' + (this.centerX + x) + 'px';
    this.elem.style.top = '' + (this.centerY + y) + 'px';
  }
}
class Engine {
  constructor() {
    this.examples = { a: 5, b: 0 };
    this.sDataExamples = ['a00', 'b00'];
    this.urls = [];
    let serverDataName = null;
    this.iTest = 0;
    for (const [k, v] of Object.entries(this.examples)) {
      let urlServerData = '/EXAMPLES/' + k + '00/serverData.yaml';
      for (let i = 0; i <= v; i++) {
        let fdName = k + '0' + i;
        let testInfo = {
          urlSpec: '/EXAMPLES/spec/' + fdName + '.yaml',
          urlServerData: urlServerData,
        }
        this.urls.push(testInfo);
      }
    }
    console.log(this.urls);
  }
  loadNextExample() {
  }
}
class FakeServerClass {
  constructor(io, perlenDict, settings, state) {
    this.io = io;
    this.perlenDict = perlenDict;
    this.settings = {};
    this.state = {};
    this.initState(state, settings);
    this.players = {};
  }
  initState(state, settings) {
    base.copyKeys(state, this.state);
    base.copyKeys(settings, this.settings);
    this.maxPoolIndex = base.initServerPool(this.settings, this.state, this.perlenDict);
  }
  initStateOld(settings, state) {
    if (isdef(settings)) copyKeys(settings, this.settings);
    let byIndex = this.byIndex = {}; this.maxIndex = 0; this.State = state;
    if (nundef(state)) {
      state = this.State = {};
      let board = state.board = createServerBoard();
      state.boardArr = [];
      state.pool = byIndex;
      state.poolArr = [];
      let keys = createServerPoolKeys();
      keys.map(x => this.addToPool(this.perlenDict[x]));
    }
    this.initPlayers();
  }
  addPlayer(client, x) {
    let username = x;
    let id = client.id;
    let pl = { id: id, client: client, name: username, username: username, arr: [] };
    this.players[id] = pl;
    this.initPlayerState(pl.id);
    return pl;
  }
  addToPool(perle) {
    let index = this.maxIndex;
    this.maxIndex += 1;
    let p = this.byIndex[index] = { key: perle.path, index: index };
    if (isdef(this.State.poolArr)) this.State.poolArr.push(index);
    return p;
  }
  boardLayoutChange(client, x) {
    let state = this.State;
    state.boardArr = x.boardArr;
    state.poolArr = x.poolArr;
    state.board = { rows: x.rows, cols: x.cols };
    this.safeEmitState(false, false, false, true);
  }
  safeEmitState(emitSettings, emitPool, emitPerlenDict, emitBoardLayout, client, moreData) {
    let o = { state: { boardArr: this.State.boardArr, poolArr: this.State.poolArr } };
    if (emitSettings) o.settings = this.settings;
    if (emitPool) o.state.pool = this.State.pool;
    if (emitPerlenDict) o.perlenDict = this.perlenDict;
    if (emitBoardLayout) o.state.board = this.board;
    DB.tables.perlen = this.State;
    utils.toYamlFile({ settings: this.settings, state: this.State }, './lastState.yaml');
    if (isdef(moreData)) copyKeys(modeData, o);
    if (isdef(client)) client.emit('gameState', o); else this.io.emit('gameState', o);
  }
  getNumActivePlayers() { return this.state.players.length; }
  getNumPlayers() { return Object.keys(this.players).length; }
  getPlayerNames() { return this.State.players.map(x => x.name).join(','); }
  getPlayerState(plid) { return firstCond(this.State.players, x => x.id == plid); }
  getPerleByFilename(filename) {
    for (const k in this.byIndex) {
      let p = this.byIndex[k];
      if (p.path == filename) return p;
    }
    return null;
  }
  getPerlenName(iPerle) { return this.byIndex[iPerle].text; }
  getTurn() { return this.state.turn; }
  initPlayerState(plid) {
    let pl = this.players[plid];
    pl.arr = [];
    pl.isInitialized = false;
    let plState = { id: pl.id, name: pl.name, username: pl.username, arr: pl.arr, isInitialized: pl.isInitializes };
    if (nundef(this.State.players)) this.State.players = [];
    this.State.players.push(plState);
    return pl;
  }
  initPlayers() { this.State.players = []; for (const plid in this.players) { this.initPlayerState(plid); } }
  initBoardTraditional(settings) {
    let [rows, cols] = [valf(settings.rows, 4), valf(settings.cols, 4)];
    return { rows: rows, cols: cols, nFields: rows * cols };
  }
  initBoardImage(settings) {
    let filename = settings.filename; //'brett02cropped.png'; // [valf(settings.rows, 4), valf(settings.cols, 4)];
    let name = stringBefore(filename, '.');
    let info = settings.bretter[name];
    let nums = allNumbers(info);
    let algo = stringAfter(info, ' ');
    return { filename: filename, algo: algo, nFields: nums[0] };
  }
  initialPoolDone(client, x) {
    let pl = this.players[client.id];
    pl.isInitialized = true;
    this.updatePlayerState(pl);
  }
  sendInitialOrState(client) {
    if (this.settings.individualSelection) {
      let data = { state: this.State, perlenDict: this.perlenDict, instruction: 'pick your set of pearls!' };
      client.emit('initialPool', data);
    } else {
      logSend('gameState');
      this.safeEmitState(true, true, true, true, client);
    }
  }
  playerJoins(client, x) {
    let pl = this.addPlayer(client, x);
    this.sendInitialOrState(client);
    this.io.emit('userMessage', {
      username: x,
      msg: `user ${pl.name} joined! (players:${this.getPlayerNames()})`,
    });
  }
  playerLeft(client, data) {
    let id = client.id;
    let players = this.players;
    delete players[id];
    let plState = this.getPlayerState(id);
    if (plState) removeInPlace(this.State.players, plState);
  }
  playerMovesPerle(client, x) {
    let iPerle = x.iPerle;
    let iFrom = x.iFrom;
    let iTo = x.iTo;
    let username = x.username;
    let perle = this.byIndex[iPerle];
    let boardArr = this.State.boardArr;
    boardArr[iFrom] = null;
    boardArr[iTo] = iPerle;
    this.State.boardArr = boardArr;
    if (isdef(x.displaced)) {
      this.State.poolArr.unshift(x.displaced);
    }
    this.safeEmitState(false, false, false, false);
  }
  playerPlacesPerle(client, x) {
    let iPerle = x.iPerle;
    let iField = x.iField;
    let username = x.username;
    let state = this.State;
    let perle = state.pool[iPerle];
    removeInPlace(state.poolArr, iPerle);
    if (isdef(x.displaced)) { state.poolArr.unshift(x.displaced); }
    state.boardArr[iField] = iPerle;
    this.safeEmitState(false, false, false, false);
  }
  playerRemovesPerle(client, x) {
    let iPerle = x.iPerle;
    let iFrom = x.iFrom;
    let state = this.State;
    state.boardArr[iFrom] = null;
    state.poolArr.unshift(iPerle);
    let pl = this.players[client.id];
    this.safeEmitState(false, false, false, false);
  }
  playerReset(client, x) {
    this.initState(x.settings);
    let username = x.username;
    this.sendInitialOrState(client);
  }
  updatePlayerState(pl) {
    let plState = firstCond(this.State.players, x => x.id == pl.id);
    plState.isInitialized = pl.isInitialized;
  }
}
class FakeSocketClass {
  constructor() {
    if (VerboseSocket) console.log('FAKE SOCKET!!!');
  }
  emit() { if (VerboseSocket) console.log('client emits', ...arguments); }
}
class FileUploadForm {
  constructor(dParent, title, route, onSubmit) {
    this.dParent = dParent;
    this.title = title;
    this.route = route;
    this.onSubmit = onSubmit;
    let id = this.id = getUID();
    this.uploadUrl = SERVERURL + route;
    this.createHtml(route)
  }
  bretter() { this.createHtml('bretter'); }
  perlen() { this.createHtml('perlen'); }
  createHtml(route) {
    let elem = createElementFromHTML(`
    <div>
      <form action="/${route}" enctype="multipart/form-data" method="post">
        <input type="file" name="${route}" accept='image/*' multiple>
        <input type="submit" value="Upload">
      </form>  
    </div>
    `);
    mAppend(this.dParent, elem);
  }
}
class FixedWidthWrapGrid {
  constructor(ms, cols, { wGrid, hGrid, hField, margin = 10, gap = 4 } = {}) {
    this.cont = ms;
    this.g = ms.elem;
    setOrigin(this.g, false);
    this.cols = cols;
    this.margin = margin;
    this.gap = gap;
    if (isdef(wGrid) && isdef(hGrid)) { this.wCont = wGrid; this.hCont = hGrid; }
    else[this.wCont, this.hCont] = ms.getSize();
    this.iNext = 0;
    this.bounds = [];
    this.w = this.wCont - 2 * margin;
    this.h = this.hCont - 2 * margin;
    this.origin = { x: margin, y: margin };
    this.wField = this.w / this.cols;
    this.hField = isdef(hField) ? hField : this.wField;
  }
  nextBounds() {
    let i = this.iNext;
    let irow = Math.floor(i / this.cols);
    let icol = i % this.cols;
    let x = this.origin.x + this.wField / 2 + icol * this.wField;
    let y = this.origin.y + this.hField / 2 + irow * this.hField;
    let w = this.wField - this.gap;
    let h = this.hField - this.gap;
    this.iNext += 1;
    return [x, y, w, h];
  }
}
class G2Player {
  constructor(name, o) {
    this.name = name;
    copyKeys(o, this);
    this.maxLevel = isdef(this.levels) ? Object.keys(this.levels).length - 1 : 0;
    this.id = name;
    this.color = getColorDictColor(this.color);
    this.moveCounter = 0;
  }
  startGame() {
    this.moveCounter = 0;
    this.winner = this.gameOver = null;
    this.setStartPlayer();
  }
  clear() { clearTimeout(this.TO); }
  changePlayer() {
    let idx = this.iPlayer = (this.iPlayer + 1) % this.players.length;
    this.setPlayers();
  }
  heuristic(state) { return 1; }
  setPlayers() {
    this.plTurn = this.playerOrder[this.iPlayer];
    this.plOpp = this.plTurn == this.ai ? this.human : this.ai;
  }
  setStartPlayer() {
    if (this.startPlayer == 'human') this.playerOrder = [this.human, this.ai];
    else if (this.startPlayer == 'ai') this.playerOrder = [this.ai, this.human];
    else this.playerOrder = chooseRandom([[this.human, this.ai], [this.ai, this.human]]);
    this.iPlayer = 0;
    this.setPlayers();
  }
  startRound() { }
  prompt() { }
  eval() { }
  activate() { }
}
class Game {
  constructor(name, o) {
    this.name = name;
    copyKeys(o, this);
    this.maxLevel = isdef(this.levels) ? Object.keys(this.levels).length - 1 : 0;
    this.id = name;
    this.color = getColorDictColor(this.color);
  }
  clear() { clearTimeout(this.TO); clearFleetingMessage(); }
  startGame() { }
  start_Level() {
    this.keys = setKeysG(this, filterWordByLengthG, 25);
    console.assert(nundef(this.numPics) || this.keys.length >= this.numPics, 'WAAAAAAAAAAAS? nMin in setKeys nicht richtig!!!!! ' + this.numPics + ' ' + this.keys.length)
  }
  startRound() { }
  prompt() {
    myShowPics(this.controller.evaluate.bind(this.controller));
    setGoal();
    show_instruction(`click <b>${Goal.label.toUpperCase()}</b>`, dTitle, `click ${Goal.label}`);
    this.controller.activateUi.bind(this.controller)();
  }
  trialPrompt() {
    sayTryAgain();
    if (this.showHint) shortHintPic();
    return 10;
  }
  activate() { }
  interact() { }
  eval(ev) {
    ev.cancelBubble = true;
    let item = findItemFromEvent(Pictures, ev);
    Selected = { pic: item, feedbackUI: iDiv(item), sz: getRect(iDiv(item)).h };
    Selected.reqAnswer = Goal.label;
    Selected.answer = item.label;
    if (item.label == Goal.label) { return true; } else { return false; }
  }
}
class GAristo { }
class GKriegBack {
  load(state) {
    this.history = [];
    let deck = this.deck = new Deck('52');
    let n = 4;
    this.pl1 = { hand: deck.deal(n), trick: [], index: 0 }; if (isdef(state) && isdef(state.pl1)) addKeys(state.pl1, this.pl1);
    this.pl2 = { hand: deck.deal(n), trick: [], index: 1 }; if (isdef(state) && isdef(state.pl2)) addKeys(state.pl2, this.pl2);
    this.players = [this.pl1, this.pl2];
    this.iturn = 0;
    if (nundef(state)) return;
    if (isdef(state.pl1.hand)) this.pl1.hand = parseHand(state.pl1.hand, deck);
    if (isdef(state.pl2.hand)) this.pl2.hand = parseHand(state.pl2.hand, deck);
    if (isdef(state.pl1.trick)) state.pl1.trick.map(x => this.pl1.trick.push(parseHand(x, deck)));
    if (isdef(state.pl2.trick)) state.pl2.trick.map(x => this.pl2.trick.push(parseHand(x, deck)));
    if (isdef(state.deck)) this.deck.setData(parseHand(state.deck));
    if (!isEmpty(this.pl1.trick)) {
      let len1 = this.pl1.trick.length;
      let len2 = this.pl2.trick.length;
      if (len1 > len2) this.iturn = 1;
      else {
        this.resolve();
        this.iturn = 0;
      }
    }
  }
  get_state() { return { pl1: this.pl1, pl2: this.pl2, deck: this.deck } };
  turn() { return this.iturn; }
  top(pl) {
    return Card52.getRankValue(arrFirstOfLast(pl.trick));
  }
  get_moves() {
    let pl = this.player();
    let x = pl.trick.length > 0 ? arrTakeFromEnd(pl.hand, 3) : [arrLast(pl.hand)];
    x.reverse();
    return [x];
  }
  make_random_move() {
    let moves = this.get_moves();
    let move = chooseRandom(moves);
    this.make_move(move);
  }
  make_move(move) {
    let pl = this.player();
    pl.trick.push(move);
    move.map(x => removeInPlace(pl.hand, x));
    this.lastMove = move;
  }
  resolve() {
    let result = this._resolve();
    this.push_history(this.iturn, this.lastMove, result);
    return result ? result.iWinner : null;
  }
  swap_turn() { this.iturn = this.iturn == 0 ? 1 : 0; }
  make_random_moveX() {
    let moves = this.get_moves();
    let move = chooseRandom(moves);
    this.make_moveX(move);
  }
  make_moveX(move) {
    this.make_move(move);
    let result = this._resolve();
    this.push_history(this.iturn, move, result);
    this.swap_turn();
  }
  _resolve() {
    let pl = this.player(), opp = this.opponent();
    console.log('...resolve', pl.trick, opp.trick)
    if (opp.trick.length != pl.trick.length) return null;
    let t1 = this.top(pl); let t2 = this.top(opp);
    console.log('resolve: compare t1', t1, 't2', t2);
    if (isdef(t1) && isdef(t2)) {
      if (t1 > t2) { return this.add_trick_from_to(opp, pl); }
      else if (t2 > t1) { return this.add_trick_from_to(pl, opp); }
      else if (isEmpty(pl.hand)) { return this.add_trick_from_to(pl, opp); }
      else if (isEmpty(opp.hand)) { return this.add_trick_from_to(opp, pl); }
      else return null;
    }
    return null;
  }
  add_trick_from_to(plFrom, plTo) {
    let t1 = plFrom.trick;
    let t2 = plTo.trick;
    let iLoser = plFrom.index;
    let iWinner = plTo.index;
    let cards1 = arrFlatten(plFrom.trick);
    let cards2 = arrFlatten(plTo.trick);
    let cards = cards1.concat(cards2);
    plTo.hand = cards.concat(plTo.hand);
    plFrom.trick = [];
    plTo.trick = [];
    return { iWinner: iWinner, winnerTrick: t2, iLoser: iLoser, loserTrick: t1, cards: cards };
  }
  undo() {
    let hist = this.pop_history();
    if (hist == null) { return null; }
    let move = hist.move;
    this.iturn = hist.iturn;
    let pl = this.player();
    pl.hand.push(move);
    move.map(x => removeInPlace(pl.trick, x));
    if (isdef(hist.result)) {
      let plWin = this.players[hist.iWinner];
      let plLose = this.players[hist.iLoser];
      plWin.trick = hist.winnerTrick;
      plLose.trick = hist.loserTrick;
      plWin.hand = arrTake(plWin.hand, plWin.hand.length - hist.cards.length);
    }
  }
  print_state(comment = '') {
    if (nundef(this.history)) this.history = [];
    let state = jsCopy(this.get_state());
    console.log('____' + comment + ' #' + this.history.length, 'turn=' + this.iturn);
    console.log('pl1: hand:' + arrString(this.pl1.hand, iToValue), 'trick', arrString(this.pl1.trick, iToValue), 'top', this.top(this.pl1));
    console.log('pl2: hand:' + arrString(this.pl2.hand, iToValue), 'trick', arrString(this.pl2.trick, iToValue), 'top', this.top(this.pl2));
  }
  player() { return this.players[this.iturn]; }
  opponent() { return this.players[(this.iturn + 1) % this.players.length]; }
  push_history(iturn, move, result) { if (nundef(this.history)) this.history = []; this.history.push({ iturn: iturn, move: move, result: result }); return this.history; }
  pop_history() { if (nundef(this.history)) this.history = []; return this.history.pop(); }
  is_war() { let pl = this.player(), opp = this.opponent(); return pl.trick.length > 0 && pl.trick.length == opp.trick.length && this.top(pl) == this.top(opp); }
  in_war() { let pl = this.player(), opp = this.opponent(); return pl.trick.length != opp.trick.length && pl.trick.length > 1; }
  in_trick() { let pl = this.player(), opp = this.opponent(); return pl.trick.length == 0 && opp.trick.length == 1; }
  is_out_of_cards() { return this._is_out_of_cards(this.player()) || this._is_out_of_cards(this.opponent()); }
  player_is_out_of_cards() { return this._is_out_of_cards(this.player()); }
  _is_out_of_cards(pl) { return (isEmpty(pl.trick) && isEmpty(pl.hand)); }
  winner() { return firstCond(this.players, x => !isEmpty(x.hand) || !isEmpty(x.trick)); }
}
class GKriegFront {
  constructor(hPlayer, dParent) { this.hPlayer = hPlayer; this.dParent = dParent; this.setup(); }
  write() { write('front', ...arguments); }
  setup() { this.areas = makeAreasKrieg(this.dParent); }
  clear() { this.areas.map(x => clearElement(diContent(x))); }
  clearZones() { for (const k of ['t0', 't1', 'h0', 'h1']) this.clearZones(k); }
  clearZone(k) { clearElement(this.getZoneDiv(k)); }
  getZoneDiv(k) { return this.hands[k].zone; }
  getTrickZoneDiv(iPlayer) { return this.getZoneDiv('t' + iPlayer); }
  getHandZoneDiv(iPlayer) { return this.getZoneDiv('h' + iPlayer); }
  getPlayerCards(iPlayer) { return this.hands['h' + iPlayer].iHand.items; }
  getTrickCards() {
    let res = [];
    let t0 = this.hands.t0;
    if (isdef(t0.iHand.items)) {
      res = res.concat(t0.iHand.items);
    }
    let t1 = this.hands.t1;
    if (isdef(t1.iHand.items)) {
      res = res.concat(t1.iHand.items);
    }
    return res;
  }
  animatePlayerMove(iPlayer, callback) {
    let cards = this.getPlayerCards(iPlayer);
    let c = arrLast(cards);
    let dSource = this.hands['h' + iPlayer].zone;
    let key = 't' + iPlayer;
    let trick = this.hands[key];
    let pos1 = lookup(this, ['pos1', key]);
    let dTarget, offset;
    if (isdef(pos1)) {
      dTarget = trick.zone;
      offset = { x: pos1.x - 10, y: pos1.y - 10 };
    } else {
      dTarget = trick.zone;
      let empty = nundef(trick.iHand.items);
      offset = { x: empty ? 0 : 0, y: 0 };
    }
    aMove(iDiv(c), dSource, dTarget, callback, offset, 500, 'EASE', 1);
  }
  animateResolve(iWinner, callback) {
    let cards = this.getTrickCards();
    let dSource = this.hands.t0.zone;
    let dTarget = this.hands['h' + iWinner].zone;
    let offset = { x: 0, y: 0 };
    let trickCards = this.getTrickCards();
    let iLast = trickCards.length, i = 0;
    for (const c of trickCards) {
      dSource = iDiv(c);
      i++; let f;
      if (i == iLast) {
        f = callback;
      } else {
        f = null;
      }
      iMoveFromToPure(c, dSource, dTarget, f, offset);
    }
  }
  presentState(state) {
    this.write('present', jsCopy(state))
    this.clear();
    let trick1 = arrFlatten(state.pl1.trick)
    let trick2 = arrFlatten(state.pl2.trick);
    let pl1Hand = state.pl1.hand;
    let pl2Hand = state.pl2.hand;
    let arrs = [[trick1, trick2], [pl1Hand], [pl2Hand]];
    let hands = [];
    for (let i = 0; i < 3; i++) {
      let area = this.areas[i];
      let d = diContent(area);
      iMessage(area, '');
      for (let j = 0; j < arrs[i].length; j++) {
        let arr = arrs[i][j];
        let id = 'a' + i + '_h' + j;
        let what = iH01(arr, d, {}, id, i == 0 ? 20 : 0);
        hands.push(what);
      }
    }
    for (let i = 0; i < 2; i++) {
      let cards = hands[i].iHand.items;
      if (isEmpty(hands[i].arr)) continue;
      for (let j = 0; j < cards.length - 1; j++) {
        Card52.turnFaceDown(cards[j]);
      }
    }
    this.hands = {};
    let handNames = ['t0', 't1', 'h0', 'h1'];
    if (nundef(this.pos1)) { this.pos1 = {}; }
    for (let i = 0; i < 4; i++) {
      let hi = hands[i];
      this.hands[handNames[i]] = hi;
      hi.key = handNames[i];
      if (!isEmpty(hi.arr)) {
        let hih = hi.iHand;
        this.pos1[handNames[i]] = getRect(iDiv(hih), hi.zone);
      }
    }
  }
}
class GMinimalGame {
  constructor(name, o) {
    this.name = name;
    copyKeys(o, this);
    this.id = name;
    this.color = getColorDictColor(this.color);
  }
  clear() { clearTimeout(this.TO); clearFleetingMessage(); }
  startGame() { clearElement(dTable); }
  clear() { }
  prompt() { }
  activate() { }
}
class gridY {
  constructor({
    bid = 'gridY',
    rows = 4,
    cols = 4,
    w = 100,
    h = 100,
    gName = 'g',
    x = 0,
    y = 0,
    margin = 10,
    gap = 10,
    board = { level: 1, ipal: 2, bg: undefined, fg: undefined, shape: undefined, border: undefined, thickness: undefined },
    fields = { level: 6, ipal: 3, bg: undefined, fg: undefined, shape: undefined, border: undefined, thickness: undefined },
    cities = { level: 6, ipal: 2, bg: undefined, fg: undefined, shape: 'circle', border: undefined, thickness: undefined },
    streets = { level: 6, ipal: 4, bg: undefined, fg: 'yellow', shape: 'line', border: 'blue', thickness: 10 }
  }) {
    this.prelim(bid, rows, cols, w, h, x, y, margin);
    this.createBoard(gName, x, y, board);
    this.createFields(bid, gName, rows, cols, gap, fields);
    addNodes(this, bid, gName, cities);
    addEdges(this, bid, gName, streets);
    drawElems(this.fields);
    drawElems(this.edges);
    drawElems(this.nodes);
  }
  prelim(id, rows, cols, w, h, x, y, margin) {
    this.id = id;
    this.rows = rows;
    this.cols = cols;
    this.w = w;
    this.h = h;
    this.x = x;
    this.y = y;
    let wFieldMax = (w - 2 * margin) / cols;
    let hFieldMax = (h - 2 * margin) / rows;
    let szField = Math.min(wFieldMax, hFieldMax);
    this.wBoard = roundEven(szField * cols);
    this.hBoard = roundEven(szField * rows);
    this.wField = this.hField = roundEven(szField);
  }
  createBoard(gName, x, y, board) {
    this.board = makeElemY('board', null, gName, board.level, {
      w: this.wBoard,
      h: this.hBoard,
      x: x,
      y: y,
      ipal: board.ipal,
      bg: board.bg,
      fg: board.fg,
      shape: board.shape,
      border: board.border,
      thickness: board.thickness
    });
  }
  createFields(bid, gName, rows, cols, gap, fields) {
    this.fields = [];
    this.fieldsByRowCol = [];
    for (let i = 1; i <= rows; i++) {
      this.fieldsByRowCol[i] = [];
      for (let j = 1; j <= cols; j++) {
        let field = makeElemY('field', bid, gName, fields.level, {
          row: i,
          col: j,
          w: this.wField,
          h: this.hField,
          gap: gap,
          x: (j - 1) * this.wField - this.wBoard / 2 + this.wField / 2 + this.x,
          y: (i - 1) * this.hField - this.hBoard / 2 + this.hField / 2 + this.y,
          ipal: fields.ipal,
          bg: fields.bg,
          fg: fields.fg,
          shape: fields.shape,
          border: fields.border,
          thickness: fields.thickness
        });
        this.fields.push(field.id);
        this.fieldsByRowCol[i][j] = field.id;
        field.edges = [];
        field.fields = [];
        field.nodes = [];
        let q = [[-0.5, -0.5], [0.5, -0.5], [0.5, 0.5], [-0.5, 0.5]];
        field.poly = getPoly(q, field.x, field.y, field.w, field.h);
      }
    }
  }
  isValid(r, c) {
    return r in this.fields && c in this.fields[r];
  }
}
class gText {
  constructor(g) {
    this.elem = g;
    this.texts = [];
    this.textBackground = null;
  }
  //#region text
  computeTextColors(fill, alpha = 1, textBg = null) {
    fill = fill ? fill : this.fg ? this.fg : textBg ? colorIdealText(textBg) : this.bg ? colorIdealText(this.bg) : null;
    if (!fill) {
      fill = 'white';
      textBg = 'gray';
    }
    fill = colorFrom(fill, alpha);
    return { fill: fill, bg: textBg ? textBg : this.bg };
  }
  setTextFill(r, fill, alpha = 1, textBg = null) {
    let textColors = this.computeTextColors(fill, alpha, textBg);
    r.setAttribute('fill', textColors.fill);
    r.setAttribute('stroke', 'none');
    r.setAttribute('stroke-width', 0);
    return textColors.bg;
  }
  setTextBorder(color, thickness = 0) {
    let c = colorFrom(color);
    let children = arrChildren(this.elem);
    unitTestMS('setTextBorder', children);
    for (const ch of children) {
      let t = getTypeOf(ch);
      if (t == 'text' || t == 'line') {
        ch.setAttribute('stroke-width', thickness);
        ch.setAttribute('stroke', c);
      }
    }
  }
  calcTextWidth(txt, fz, family, weight) {
    let sFont = weight + ' ' + fz + 'px ' + family;
    sFont = sFont.trim();
    let wText = getTextWidth(txt, sFont);
    return wText;
  }
  addFrame(color) {
    if (this.cat == 'd') {
      this.body.style.boxSizing = 'border-box';
      this.body.style.border = '5px solid ' + color;
    }
  }
  addFlexTitleBody() {
    let content = this.elem.innerHTML;
    clearElement(this.elem);
    let d = this.elem;
    d.style.display = 'flex';
    d.style.flexDirection = 'column';
    let dTitle = document.createElement('div');
    this.title = dTitle;
    this.title.style.padding = '6px';
    this.title.style.textAlign = 'center';
    let dBody = document.createElement('div');
    dBody.style.flexGrow = 1;
    dBody.style = "flex-grow:1;overflow:auto;padding:0px 6px"
    this.body = dBody;
    this.body.innerHTML = content;
    this.elem.appendChild(this.title);
    this.elem.appendChild(this.body);
  }
  setTitle({
    txt,
    className = null,
    isOverlay = false,
    isMultiText = false,
    replaceFirst = true,
    fill = null,
    textBg = null,
    alpha = 1,
    x = 0,
    y = 0,
    fz = 20,
    family = 'Arial, Helvetica, sans-serif',
    weight = ''
  } = {}) {
    if (this.cat == 'd') {
      if (nundef(this.body) || nundef(this.title)) {
        this.addFlexTitleBody();
      }
      clearElement(this.title);
      if (isdef(textBg)) this.title.style.backgroundColor = textBg;
      if (isdef(fill)) this.title.style.color = fill;
      this.title.innerHTML = txt;
      return this;
    }
    let isFirstChild = this.elem.childNodes.length == 0;
    let r = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    if (isFirstChild) {
      this.ground = r;
    }
    r.setAttribute('font-family', family);
    r.setAttribute('font-weight', weight);
    if (isOverlay) {
      r.classList.add('overlay');
      this.overlay = r;
    }
    r.classList.add('msText');
    if (className) {
      r.classList.add(className);
    }
    textBg = this.setTextFill(r, fill, alpha, textBg);
    if (isFirstChild) {
      this.bgs.ground = textBg;
      this.fgs.ground = fill;
    }
    let wText = this.calcTextWidth(txt, fz, family, weight);
    if (this.isLine && !isMultiText) {
      x += this.x;
      y += this.y;
      if (this.textBackground) {
        this.elem.removeChild(this.textBackground);
      }
      this.textBackground = this.getRect({ w: wText + 10, h: fz * 1.5, fill: textBg });
      this.textBackground.setAttribute('rx', 6);
      this.textBackground.setAttribute('ry', 6);
    }
    r.setAttribute('font-size', '' + fz + 'px');
    r.setAttribute('x', x);
    r.setAttribute('y', y + fz / 2.8);
    r.setAttribute('text-anchor', 'middle');
    r.textContent = txt;
    r.setAttribute('pointer-events', 'none');
    if (replaceFirst && this.texts.length > 0) {
      let ch = this.texts[0].el;
      this.elem.insertBefore(r, ch);
      if (this.isLine) {
        this.elem.insertBefore(this.textBackground, r);
      }
      this.removeTexts();
    } else {
      if (this.isLine && !isMultiText) {
        this.elem.appendChild(this.textBackground);
      }
      this.elem.appendChild(r);
    }
    let res = { el: r, w: wText };
    this.texts.push(res);
    return res;
  }
  text({
    txt,
    className = null,
    isOverlay = false,
    isMultiText = false,
    replaceFirst = true,
    fill = null,
    bgText = null,
    alpha = 1,
    x = 0,
    y = 0,
    fz = 20,
    family = 'Arial, Helvetica, sans-serif',
    weight = '',
    font
  } = {}) {
    if (isdef(txt) && !isString(txt)) txt = txt.toString();
    if (isEmpty(txt)) {
      this.removeTexts(); return this;
    }
    let isFirstChild = this.elem.childNodes.length == 0;
    let r = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    if (isFirstChild) { this.ground = r; }
    if (isdef(font)) { r.style.font = font; }
    else {
      r.setAttribute('font-family', family);
      r.setAttribute('font-weight', weight);
      r.setAttribute('font-size', '' + fz + 'px');
    }
    if (isOverlay) { r.classList.add('overlay'); this.overlay = r; }
    r.classList.add('msText');
    if (className) { r.classList.add(className); }
    bgText = this.setTextFill(r, fill, alpha, bgText);
    let wText = isdef(font) ? getTextWidth(txt, font) : this.calcTextWidth(txt, fz, family, weight);
    if (this.elem.children[0]) {
      let bParent = getBounds(this.elem.children[0]);
      if (!this.textBackground && (wText > bParent.width || isdef(bgText))) {
        if (nundef(bgText)) {
          bgText = this.elem.children[0].getAttribute('background-color');
        }
        this.textBackground = agRect(this.elem, wText + 18, fz)
        gBg(this.textBackground, bgText);
        gRounding(this.textBackground, 4);
      }
    }
    if (this.isLine && !isMultiText) {
      x += this.x;
      y += this.y;
      if (this.textBackground) {
        this.elem.removeChild(this.textBackground);
      }
      this.textBackground = this.getRect({ w: wText + 10, h: fz * 1.5, fill: bgText });
      this.textBackground.setAttribute('rx', 6);
      this.textBackground.setAttribute('ry', 6);
    }
    r.setAttribute('x', x);
    if (isdef(font)) fz = firstNumber(font);
    r.setAttribute('y', y + fz / 2.8);
    r.setAttribute('text-anchor', 'middle');
    r.textContent = txt;
    r.setAttribute('pointer-events', 'none');
    if (replaceFirst && this.texts.length > 0) {
      let ch = this.texts[0].el;
      this.elem.insertBefore(r, ch);
      if (this.isLine) {
        this.elem.insertBefore(this.textBackground, r);
      }
      this.removeTexts();
    } else {
      if (this.isLine && !isMultiText) {
        this.elem.appendChild(this.textBackground);
      }
      this.elem.appendChild(r);
    }
    let res = { txt: txt, ui: r, w: wText };
    this.texts.push(res);
    return res;
  }
  reduceFontSize(el, n) {
    let fz = el.getAttribute('font-size');
    fz = firstNumber(fz);
    if (fz > n) fz -= n;
    el.setAttribute('font-size', '' + fz + 'px');
  }
  clearText() { this.removeTexts(); }
  removeTexts() {
    for (const t of this.texts) {
      this.elem.removeChild(t.el);
      if (this.textBackground) this.elem.removeChild(this.textBackground);
    }
    this.texts = [];
  }
  multitext({
    replacePrevious = true,
    className = '',
    maxWidth = 1000,
    txt = ['one', 'two', 'three'],
    fz = 20,
    fill = null,
    textBg = null,
    padding = 1,
    alpha = 1,
    x = 0,
    y = 0,
    family = 'Arial, Helvetica, sans-serif',
    weight = 'lighter'
  }) {
    let nChar = 0;
    for (const s of txt) { nChar = Math.max(nChar, s.length); }
    let maxFH = Math.round(this.h / txt.length);
    let maxFW = Math.round((this.w / nChar) * 2);
    let fzFit = Math.min(maxFH, maxFW) - 2 * padding;
    if (fzFit < fz) fz = fzFit;
    if (fzFit > 5 * fz) fz *= 5;
    if (replacePrevious) this.removeTexts();
    let h = txt.length * (fz + padding);
    let textColors = this.computeTextColors(fill, alpha, textBg);
    if (this.isLine) {
      x += this.x;
      y += this.y;
      let tbg = this.textBackground ? this.textBackground : this.getRect();
      tbg.setAttribute('height', h);
      tbg.setAttribute('fill', textColors.bg);
      if (!this.textBackground) {
        this.textBackground = tbg;
        this.elem.appendChild(this.textBackground);
      }
      this.textBackground.setAttribute('rx', 6);
      this.textBackground.setAttribute('ry', 6);
    }
    let yStart = y - h / 2 + fz / 2;
    let maxW = 0;
    let akku = [];
    for (const t of txt) {
      let tel = this.text({
        isMultiText: true,
        replaceFirst: false,
        className: className,
        maxWidth: maxWidth,
        txt: t,
        fz: fz,
        fill: fill,
        padding: padding,
        alpha: alpha,
        x: x,
        y: yStart,
        family: family,
        weight: weight
      });
      maxW = Math.max(maxW, tel.w);
      akku.push(tel);
      yStart += fz + padding;
    }
    let isFirstChild = this.elem.childNodes.length == 0;
    if (isFirstChild || this.isLine) {
      this.ground = this.textBackground;
      this.w = maxW + 2 * padding;
      this.h = h;
    }
    if (this.isLine) {
      this.textBackground.setAttribute('width', this.w);
      this.textBackground.setAttribute('x', x - this.w / 2);
      this.textBackground.setAttribute('y', y - this.h / 2);
    }
    if (isFirstChild) { this.bgs.ground = textColors.bg; this.fg.ground = fill; }
    return this;
  }
}
class hexgridY {
  constructor({
    bid = 'gridY',
    rows = 4,
    cols = 4,
    w = 100,
    h = 100,
    gName = 'g',
    x = 0,
    y = 0,
    margin = 10,
    gap = 10,
    board = { level: 1, ipal: 2, bg: undefined, fg: undefined, shape: undefined, border: undefined, thickness: undefined },
    fields = { level: 6, ipal: 3, bg: undefined, fg: undefined, shape: 'hex', border: undefined, thickness: undefined },
    cities = { level: 6, ipal: 2, bg: undefined, fg: undefined, shape: 'circle', border: undefined, thickness: undefined },
    streets = { level: 6, ipal: 4, bg: undefined, fg: undefined, shape: 'line', border: 'blue', thickness: 10 }
  }) {
    this.prelim(bid, rows, cols, w, h, x, y, margin);
    this.createBoard(gName, x, y, board);
    this.createFields(bid, gName, rows, cols, gap, fields);
    addNodes(this, bid, gName, cities);
    addEdges(this, bid, gName, streets);
    drawElems(this.fields);
    drawElems(this.edges);
    drawElems(this.nodes);
  }
  prelim(bid, rows, cols, w, h, x, y, margin) {
    this.id = bid;
    rows = rows % 2 != 0 ? rows : rows + 1;
    this.topcols = cols;
    this.colarr = calc_hex_col_array(rows, this.topcols);
    this.maxcols = Math.max(...this.colarr);
    this.rows = rows;
    this.cols = cols;
    this.w = w;
    this.h = h;
    this.x = x;
    this.y = y;
    let wFieldMax = (w - 2 * margin) / this.maxcols;
    let hFieldMax = (h - 2 * margin) / rows;
    hFieldMax /= 0.75;
    let hField = (2 * this.wFieldMax) / 1.73;
    let hBoard = hField * 0.75 * rows;
    if (hBoard > h - 2 * margin) {
      this.hField = roundEven(hFieldMax);
      this.wField = roundEven((1.73 * hField) / 2);
    } else {
      this.wField = roundEven(wFieldMax);
      this.hField = roundEven((2 * this.wField) / 1.73);
    }
    this.wBoard = roundEven(this.wField * this.maxcols);
    this.hBoard = roundEven(this.hField * 0.75 * rows + this.hField / 4);
  }
  createBoard(gName, x, y, board) {
    this.board = makeElemY('board', null, gName, board.level, {
      w: this.wBoard,
      h: this.hBoard,
      x: x,
      y: y,
      ipal: board.ipal,
      bg: board.bg,
      fg: board.fg,
      shape: board.shape,
      border: board.border,
      thickness: board.thickness
    });
  }
  createFields(bid, gName, rows, cols, gap, fields) {
    this.fields = [];
    this.fieldsByRowCol = [];
    let imiddleRow = (rows - 1) / 2;
    for (let irow = 0; irow < this.colarr.length; irow++) {
      this.fieldsByRowCol[irow + 1] = [];
      let colstart = this.maxcols - this.colarr[irow];
      let y = this.hField * 0.75 * (irow - imiddleRow);
      for (let j = 0; j < this.colarr[irow]; j++) {
        var icol = colstart + 2 * j;
        let x = (icol * this.wField) / 2 + this.wField / 2 - this.wBoard / 2;
        let approx = 12;
        let field = makeElemY('field', bid, gName, fields.level, {
          row: irow + 1,
          col: icol + 1,
          w: this.wField,
          h: this.hField,
          gap: gap,
          x: x,
          y: y,
          ipal: fields.ipal,
          bg: fields.bg,
          fg: fields.fg,
          shape: fields.shape,
          border: fields.border,
          thickness: fields.thickness
        });
        this.fields.push(field.id);
        this.fieldsByRowCol[irow + 1][icol + 1] = field.id;
        field.edges = [];
        field.fields = [];
        field.nodes = [];
        let hex = [[0, -0.5], [0.5, -0.25], [0.5, 0.25], [0, 0.5], [-0.5, 0.25], [-0.5, -0.25]];
        field.poly = getPoly(hex, field.x, field.y, field.w, field.h);
        x += this.wField;
      }
    }
  }
  isValid(r, c) {
    return r in this.fields && c in this.fields[r];
  }
}
class ItemViewerClass {
  constructor(dParent, dButtons, keys) {
    this.options = {
      n: 100, dParent: dParent,
      wper: 100, hper: 100,
      szPic: { w: 80, h: 80 }, padding: 0, fzPic: 40,
      showLabels: true, showPic: true, fixTextFont: true,
      isUniform: true, fillArea: true, isRegular: false, hugeFont: true,
      handler: _standardHandler(this.handSelectSpecialKeys.bind(this)),
    };
    _extendOptions(this.options);
    this.options.wLongest = 'alabama';
    let items = this.allItems = genItemsFromKeys(isdef(keys) ? keys : SymKeys, this.options);
    console.log(this.allItems.length);
    this.iStart = 0;
    dButtons = mDiv(dButtons, { display: 'flex', 'flex-direction': 'column', matop: -12 });
    mButton('download', this.saveSpecialKeys.bind(this), dButtons, { outline: 'none' });
    if (this.allItems.length > 100) mButton('next', this.itemViewerNext.bind(this), dButtons, { outline: 'none', mabottom: 6, matop: 10 });
    this.itemViewerNext();
  }
  itemViewerNext() {
    let i = this.iStart;
    let options = this.options;
    let items = arrFromTo(this.allItems, i, i + options.n);
    options.n = options.N = items.length;
    this.iStart += options.n;
    clearElement(options.dArea);
    options.fzText = 20;
    items.map(x => x.label = x.key);
    items.map(x => makeItemDiv(x, options));
    items.map(x => mAppend(options.dArea, iDiv(x)));
  }
  handSelectSpecialKeys(item) {
    if (nundef(this.specialKeys)) this.specialKeys = [];
    toggleItemSelection(item, this.specialKeys);
    return this.specialKeys.map(x => x.key);
  }
  saveSpecialKeys() {
    let items = this.specialKeys;
    let dict = {};
    for (const item of items) {
      dict[item.key] = item.info;
    }
    downloadAsYaml(dict, 'specialKeys');
  }
}
class Karte {
  static random(sym = 'bee', h = 220) {
    return Karte.get(sym, h);
    return Card52.random();
  }
  static c1(info, n, fg, h, w) {
    let d = mDiv();
    let svg = mgTag('svg', d, { class: 'card', face: '2C', height: '100%', width: '100%', preserveAspectRatio: 'none', viewBox: "-120 -168 240 336" });
    let g = mgTag('g', svg);
    let rect = mgTag('rect', g, { width: 239, height: 335, x: -120, y: 168, rx: 12, ry: 12, fill: "white", stroke: "black" });
    let t = mgTag('text', g, { 'text-anchor': "middle", 'dominant-baseline': "middle", x: 0, y: 0, fill: fg }, { fz: 1000 }, 'HALLO');
    if (nundef(w)) w = h * .7;
    if (isdef(h) || isdef(w)) { mSize(d, w, h); }
    console.log('d', d)
    return { key: getUID(), div: d, w: w, h: h, faceUp: true };
  }
  static card(info, n, fg, h, w) {
    let x = `
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="card" 
      face="2C" height="100%" preserveAspectRatio="none" viewBox="-120 -168 240 336" width="100%">
      <symbol id="${fg}${n}" viewBox="-500 -500 1000 1000" preserveAspectRatio="xMinYMid">
        <text text-anchor="middle" dominant-baseline="middle" x="0" y="0" fill="${fg}" style="font-size:1000px;font-weight:bold;">${n}</text>        
      </symbol>
      <symbol id="${info.E}" viewBox="-500 -500 1000 1000" preserveAspectRatio="xMinYMid">
        <text text-anchor="middle" dominant-baseline="middle" x="0" y="-150" fill="red" style="font-size:750px;font-family:${info.family};">${info.text}</text>        
      </symbol>
      <rect width="239" height="335" x="-119.5" y="-167.5" rx="12" ry="12" fill="white" stroke="black"></rect>`;
    let h1 = { xs: 24, s: 27, m: 42, l: 60, xl: 70, xxl: 100 };
    let left = [0, 50, 100, 120];
    let upperLeftNumber = `<use xlink:href="#${fg}${n}" height="42" x="-120" y="-156"></use>`
      `<use xlink:href="#${info.E}" height="26.769" x="-111.784" y="-119"></use>
      <use xlink:href="#${info.E}" height="70" x="-35" y="-135.588"></use>
      <g transform="rotate(180)">
        <use xlink:href="#${fg}${n}" height="42" x="-120" y="-156"></use>
        <use xlink:href="#${info.E}" height="26.769" x="-111.784" y="-119"></use>
        <use xlink:href="#${info.E}" height="70" x="-35" y="-135.588"></use>
      </g>
    </svg>`;
    let svgCode = x;
    svgCode = '<div>' + svgCode + '</div>';
    let el = mCreateFrom(svgCode);
    if (nundef(w)) w = h * .7;
    if (isdef(h) || isdef(w)) { mSize(el, w, h); }
    return { key: getUID(), div: el, w: w, h: h, faceUp: true };
  }
  static get52(suit, rank, fg, bg, h, w, faceUp) {
    let key = suit.toLowerCase();
    let di = {
      h: 'hearts', s: 'spades', p: 'spades', c: 'clubs', t: 'clubs', d: 'diamonds', k: 'diamonds',
      j: 'joker', '*': 'joker'
    };
    if (isdef(di[key])) key = di[key];
    let di2 = { spades: 'spade suit', hearts: 'heart suit', diamonds: 'diamond suit', clubs: 'club suit' };
    if (isdef(di2[key])) key = di2[key];
    let info = Syms[key];
    return Karte.get(key, 300, rank, fg);
    let fz = info.family == 'emoNoto' ? 750 : 1000;
  }
  static get(sym = 'bee', h = 110, n = 2, fg = 'indigo', w) {
    let info = Syms[sym];
    n = 2;
    ensureColorNames();
    if (nundef(fg)) fg = sym == 'spades' || sym == 'clubs' ? 'black' : sym == 'hearts' || sym == 'diamonds' ? 'red' : chooseRandom(Object.keys(ColorNames));
    let cardKey = info.family == 'emoNoto' ? 'card0' : 'card52';
    let basic = {
      card0: `
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="card" 
        face="2C" height="100%" preserveAspectRatio="none" viewBox="-120 -168 240 336" width="100%">
          <symbol id="${fg}${n}" viewBox="-500 -500 1000 1000" preserveAspectRatio="xMinYMid">
            <text text-anchor="middle" dominant-baseline="middle" x="0" y="0" fill="${fg}" style="font-size:1000px;font-weight:bold;">${n}</text>        
          </symbol>
          <symbol id="${info.E}" viewBox="-500 -500 1000 1000" preserveAspectRatio="xMinYMid">
            <text text-anchor="middle" dominant-baseline="middle" x="0" y="-150" fill="red" style="font-size:750px;font-family:${info.family};">${info.text}</text>        
          </symbol>
          <rect width="239" height="335" x="-119.5" y="-167.5" rx="12" ry="12" fill="white" stroke="black"></rect>
          <use xlink:href="#${fg}${n}" height="42" x="-118" y="-156"></use>
          <use xlink:href="#${info.E}" height="26.769" x="-111.784" y="-119"></use>
          <use xlink:href="#${info.E}" height="70" x="-35" y="-135.588"></use>
          <g transform="rotate(180)">
            <use xlink:href="#${fg}${n}" height="42" x="-118" y="-156"></use>
            <use xlink:href="#${info.E}" height="26.769" x="-111.784" y="-119"></use>
            <use xlink:href="#${info.E}" height="70" x="-35" y="-135.588"></use>
          </g>
        </svg>`,
      card52: `
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="card" 
        face="2C" height="100%" preserveAspectRatio="none" viewBox="-120 -168 240 336" width="100%">
          <symbol id="${fg}${n}" viewBox="-500 -500 1000 1000" preserveAspectRatio="xMinYMid">
            <text text-anchor="middle" dominant-baseline="middle" x="0" y="0" fill="${fg}" style="font-size:1000px;font-family:opensans;">${n}</text>        
          </symbol>
          <symbol id="${info.E}" viewBox="-500 -500 1000 1000" preserveAspectRatio="xMinYMid">
            <text text-anchor="middle" dominant-baseline="middle" x="0" y="50" fill="${fg}" style="font-size:800px;font-family:${info.family};">${info.text}</text>        
          </symbol>
          <rect width="239" height="335" x="-119.5" y="-167.5" rx="12" ry="12" fill="white" stroke="black"></rect>
          <use xlink:href="#${fg}${n}" height="40" x="-116.4" y="-156"></use>
          <use xlink:href="#${info.E}" height="26.769" x="-111.784" y="-119"></use>
          <use xlink:href="#${info.E}" height="70" x="-35" y="-135.588"></use>
          <g transform="rotate(180)">
            <use xlink:href="#${fg}${n}" height="40" x="-116.4" y="-156"></use>
            <use xlink:href="#${info.E}" height="26.769" x="-111.784" y="-119"></use>
            <use xlink:href="#${info.E}" height="70" x="-35" y="-135.588"></use>
          </g>
        </svg>`,
      card7: `
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="card" 
        face="2C" height="100%" preserveAspectRatio="none" viewBox="-120 -168 240 336" width="100%">
          <symbol id="VC2" viewBox="-500 -500 1000 1000" preserveAspectRatio="xMinYMid">
            <text text-anchor="middle" dominant-baseline="middle" x="0" y="0" fill="red" style="font-size:750px;font-family:opensans;">A</text>        
          </symbol>
          <rect width="239" height="335" x="-119.5" y="-167.5" rx="12" ry="12" fill="white" stroke="black"></rect>
          <use xlink:href="#VC2" height="32" x="-114.4" y="-156"></use>
          <use xlink:href="#VC2" height="26.769" x="-111.784" y="-119"></use>
          <use xlink:href="#VC2" height="70" x="-35" y="-135.588"></use>
          <g transform="rotate(180)">
            <use xlink:href="#VC2" height="32" x="-114.4" y="-156"></use>
            <use xlink:href="#VC2" height="26.769" x="-111.784" y="-119"></use>
            <use xlink:href="#VC2" height="70" x="-35" y="-135.588"></use>
          </g>
        </svg>`,
      card6: `
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="card" 
        face="2C" height="100%" preserveAspectRatio="none" viewBox="-120 -168 240 336" width="100%">
          <symbol id="VC2" viewBox="-500 -500 1000 1000" preserveAspectRatio="xMinYMid">
            <text text-anchor="middle" dominant-baseline="middle" x="0" y="0" fill="red" style="font-size:750px;font-family:opensans;">A</text>        
          </symbol>
          <rect width="239" height="335" x="-119.5" y="-167.5" rx="12" ry="12" fill="white" stroke="black"></rect>
          <use xlink:href="#VC2" height="32" x="-114.4" y="-156"></use>
        </svg>`,
      card5: `
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="card" 
        face="2C" height="100%" preserveAspectRatio="none" viewBox="-120 -168 240 336" width="100%">
          <symbol id="SC2" viewBox="-600 -600 1200 1200" preserveAspectRatio="xMinYMid">
            <path d="M30 150C35 385 85 400 130 500L-130 500C-85 400 -35 385 -30 150A10 10 0 0 0 -50 150A210 210 0 1 1 -124 -51A10 10 0 0 0 -110 -65A230 230 0 1 1 110 -65A10 10 0 0 0 124 -51A210 210 0 1 1 50 150A10 10 0 0 0 30 150Z" 
              fill="black">
            </path>
          </symbol>
          <symbol id="VC2" viewBox="-500 -500 1000 1000" preserveAspectRatio="xMinYMid">
            <path d="M-225 -225C-245 -265 -200 -460 0 -460C 200 -460 225 -325 225 -225C225 -25 -225 160 -225 460L225 460L225 300" 
              stroke="black" stroke-width="80" stroke-linecap="square" stroke-miterlimit="1.5" fill="none">
            </path>
          </symbol>
          <rect width="239" height="335" x="-119.5" y="-167.5" rx="12" ry="12" fill="white" stroke="black"></rect>
          <use xlink:href="#VC2" height="32" x="-114.4" y="-156"></use>
          <use xlink:href="#SC2" height="26.769" x="-111.784" y="-119"></use>
          <use xlink:href="#SC2" height="70" x="-35" y="-135.588"></use>
          <g transform="rotate(180)">
            <use xlink:href="#VC2" height="32" x="-114.4" y="-156"></use>
            <use xlink:href="#SC2" height="26.769" x="-111.784" y="-119"></use>
            <use xlink:href="#SC2" height="70" x="-35" y="-135.588"></use>
          </g>
          <text text-anchor="middle" dominant-baseline="middle" x="0" y="0" fill="red" style="font-size:16px;font-family:opensans;">I love SVG!</text>        
          <text text-anchor="middle" dominant-baseline="hanging" x="0" y="-156" fill="blue" style="font-size:16px;font-family:opensans;">YES</text>        
          <text text-anchor="middle" dominant-baseline="hanging" x="0" y="-156" fill="green" transform="rotate(180)" style="font-size:16px;font-family:opensans;">YES</text>        
        </svg>`,
      card4: `
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="card" 
        face="2C" height="100%" preserveAspectRatio="none" viewBox="-120 -168 240 336" width="100%">
          <symbol id="VC2" viewBox="-500 -500 1000 1000" preserveAspectRatio="xMinYMid">
            <text dominant-baseline="hanging" text-anchor="middle" x="0" y="0" fill="red" style="font-size:600px;font-family:${info.family};">${info.text}</text>        
          </symbol>
          <rect width="239" height="335" x="-119.5" y="-167.5" rx="12" ry="12" fill="white" stroke="black"></rect>
          <use xlink:href="#VC2" height="32" x="-114.4" y="-156" dominant-baseline="hanging" text-anchor="middle" ></use>
          <g transform="rotate(180)">
            <use xlink:href="#VC2" height="32" x="-114.4" y="-156" dominant-baseline="hanging" text-anchor="middle" ></use>
          </g>
          <text dominant-baseline="hanging" text-anchor="middle" x="0" y="0" fill="red" style="font-size:600px;font-family:${info.family};">${info.text}</text>        
          <text text-anchor="middle" dominant-baseline="middle" x="0" y="0" fill="red" style="font-size:16px;font-family:opensans;">I love SVG!</text>        
          <text text-anchor="middle" dominant-baseline="hanging" x="0" y="-156" fill="blue" style="font-size:16px;font-family:opensans;">YES</text>        
          <text text-anchor="middle" dominant-baseline="hanging" x="0" y="-156" fill="green" transform="rotate(180)" style="font-size:16px;font-family:opensans;">YES</text>        
        </svg>`,
      card3: `
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="card" 
        face="2C" height="100%" preserveAspectRatio="none" viewBox="-120 -168 240 336" width="100%">
          <rect width="239" height="335" x="-119.5" y="-167.5" rx="12" ry="12" fill="white" stroke="black"></rect>
          <text dominant-baseline="hanging" x="-114" y="-156" fill="red" style="font-size:30px;font-family:${info.family};">${info.text}</text>        
          <text  text-anchor="end" dominant-baseline="hanging" x="114" y="-156" fill="red" style="font-size:30px;font-family:${info.family};">${info.text}</text>        
          <text text-anchor="middle" dominant-baseline="hanging" x="0" y="-156" fill="blue" style="font-size:16px;font-family:opensans;">YES</text>        
          <text text-anchor="middle" dominant-baseline="middle" x="0" y="0" fill="red" style="font-size:16px;font-family:opensans;">I love SVG!</text>        
          <g transform="rotate(180)">
            <text dominant-baseline="hanging" x="-114" y="-156" fill="red" style="font-size:30px;font-family:${info.family};">${info.text}</text>        
            <text  text-anchor="end" dominant-baseline="hanging" x="114" y="-156" fill="red" style="font-size:30px;font-family:${info.family};">${info.text}</text>        
            <text text-anchor="middle" dominant-baseline="hanging" x="0" y="-156" fill="blue" style="font-size:16px;font-family:opensans;">YES</text>        
          </g>
        </svg>`,
      card2: `
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="card" 
        face="2C" height="100%" preserveAspectRatio="none" viewBox="-120 -168 240 336" width="100%">
          <symbol id="VC2" viewBox="-500 -500 1000 1000" preserveAspectRatio="xMinYMid">
            <text text-anchor="middle" dominant-baseline="middle" x="0" y="0" fill="red" style="font-size:500px;font-family:${info.family};">${info.text}</text>        
          </symbol>
          <rect width="239" height="335" x="-119.5" y="-167.5" rx="12" ry="12" fill="white" stroke="black"></rect>
          <text dominant-baseline="hanging" x="-114" y="-156" fill="red" style="font-size:30px;font-family:${info.family};">${info.text}</text>        
          <text  text-anchor="end" dominant-baseline="hanging" x="114" y="-156" fill="red" style="font-size:30px;font-family:${info.family};">${info.text}</text>        
          <text text-anchor="middle" dominant-baseline="hanging" x="0" y="-156" fill="blue" style="font-size:16px;font-family:opensans;">YES</text>        
          <text text-anchor="middle" dominant-baseline="middle" x="0" y="0" fill="red" style="font-size:16px;font-family:opensans;">I love SVG!</text>        
          <g transform="rotate(180)">
            <text dominant-baseline="hanging" x="-114" y="-156" fill="red" style="font-size:30px;font-family:${info.family};">${info.text}</text>        
            <text  text-anchor="end" dominant-baseline="hanging" x="114" y="-156" fill="red" style="font-size:30px;font-family:${info.family};">${info.text}</text>        
            <text text-anchor="middle" dominant-baseline="hanging" x="0" y="-156" fill="blue" style="font-size:16px;font-family:opensans;">YES</text>        
          </g>
        </svg>`,
      card1: `
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="card" 
        face="2C" height="100%" preserveAspectRatio="none" viewBox="-120 -168 240 336" width="100%">
          <symbol id="VC2">
          </symbol>
          <rect width="239" height="335" x="-119.5" y="-167.5" rx="12" ry="12" fill="white" stroke="black"></rect>
          <use xlink:href="#VC2" height="32" x="-114.4" y="-156"></use>
          <use xlink:href="#VC2" height="32" x="0" y="0"></use>
          <text text-anchor="middle" dominant-baseline="middle" x="0" y="0" fill="red" style="font-size:16px;font-family:opensans;">I love SVG!</text>        
          <g transform="rotate(180)">
            <text dominant-baseline="hanging" x="-114" y="-156" fill="red" style="font-size:30px;font-family:${info.family};">${info.text}</text>        
            <text text-anchor="end" dominant-baseline="hanging" x="114" y="-156" fill="red" style="font-size:30px;font-family:${info.family};">${info.text}</text>        
            <text text-anchor="middle" dominant-baseline="hanging" x="0" y="-156" fill="blue" style="font-size:16px;font-family:opensans;">YES</text>        
          </g>
        </svg>`
    };
    let svgCode = basic[cardKey];
    svgCode = '<div>' + svgCode + '</div>';
    let el = mCreateFrom(svgCode);
    if (nundef(w)) w = h * .7;
    if (isdef(h) || isdef(w)) { mSize(el, w, h); }
    return { key: getUID(), div: el, w: w, h: h, faceUp: true };
  }
}
class KeySelection {
}
class LazyCache {
  constructor(resetStorage = false) {
    this.caches = {};
    if (resetStorage) localStorage.clear();
  }
  get(key) { return this.caches[key]; }
  asDict(key) { return this.caches[key].live; }
  getRandom(key) { let d = this.asDict(key); return chooseRandom(Object.values(d)); }
  getRandomKey(key) { return getRandomKey(this.asDict(key)); }
  getFirstKey(key, cond) { return firstCondDictKeys(this.asDict(key), cond); }
  invalidate(...keys) { for (const k of keys) if (this.caches[k]) this.caches[k].invalidate(); }
  async load(primKey, loaderFunc, reload = false, useLocal = true) {
    let cd = new CacheDict(primKey, { func: loaderFunc }, useLocal);
    this.caches[primKey] = cd;
    if (reload) await cd.reload(); else await cd.load();
    let handler = {
      get: function (target, name) { return target.live[name]; },
      set: function (target, name, val) { target.live[name] = val; return true; },
      has: function (target, name) { return name in target.live; },
      delete: function (target, name) { return delete target.live[name]; },
    };
    let proxy = new Proxy(cd, handler);
    return proxy;
  }
}
class LiveObject {
  static States = { none: 0, gettingReady: 1, ready: 2, running: 3, on: 3, off: 4 }
  constructor(k) {
    this.key = k;
    let id = this.id = getUID();
    Live[id] = this;
    this.TOList = [];
    this.UIS = [];
    this.uiActivated = false;
    this.uiState = LiveObject.States.none;
  }
  //#region hidden API
  _clearTO() { this.TOList.map(x => clearTimeout(x)); this.TOList = []; }
  _clearUI() { }
  //#endregion
  activate() { this.uiActivated = true; }
  clear() { this._clearTO(); }
  deactivate() { this.uiActivated = false; }
  die() { this._clearTO(); console.assert(isdef(this.div)); this.div.remove(); Live[this.id] = null; }
  run() { console.log('object', this.id, 'is running...') }
  setGettingReady() { this.running = false; this.uiState = LiveObject.States.gettingReady; console.log('...getting ready!'); }
  setRunning() { this.running = true; this.uiState = LiveObject.States.running; }
  setReady() { this.running = false; this.uiState = LiveObject.States.ready; console.log('ready!'); }
  getReady(ms) {
    if (isdef(ms)) { this.setGettingReady(); setTimeout(this.setReady.bind(this), ms); }
    else this.setReady();
  }
}
class MaxWidthPreserver {
  constructor() {
    this.entries = {};
    this.resizeObserver = new ResizeObserver(this.handler.bind(this));
  }
  handler(entries) {
    for (let entry of entries) {
      let domel = entry.target;
      let cs = window.getComputedStyle(entry.target);
      let w = firstNumber(cs.width);
      let id = domel.id;
      let x = this.entries[id];
      if (isdef(x)) {
        if (w < x.minWidth && Math.abs(w - x.minWidth) > 1) {
          w = x.minWidth;
          domel.style.minWidth = w + 'px';
        }
        x.minWidth = w;
      }
    }
  }
  add(id) {
    let entry = this.entries[id] = { elem: mBy(id) };
    let cs = window.getComputedStyle(entry.elem);
    this.resizeObserver.observe(mBy(id));
    entry.minWidth = firstNumber(cs.width);
  }
  reset(id) { this.entries[id].elem.styles.minWidth = this.entries[id].minWidth = 0; }
}
class MK { }
class MKManager {
  clear() { this.clearUIS(); this.clearDONE(); }
  clearUIS() {
    UIS = {};
    IdOwner = {};
    id2oids = {};
    oid2ids = {};
    id2uids = {};
    UIDCounter = 0;
  }
  getDone(oid) { return DONE[oid]; }
  setDone(oid) { DONE[oid] = true; }
  clearDONE() { DONE = {}; }
}
class MOBJ {
  constructor() {
    this.children = [];
    this.parts = {};
    this.handlers = { click: {}, mouseenter: {}, mouseleave: {} };
    this.isAttached = false;
    this.texts = [];
    this.refs = {};
    this.isa = {};
    this.orig = {};
    this.bgs = {};
    this.fgs = {};
  }
  //#region picto
  pictoImage(key, fg, sz) {
    this._picto(key, 0, 0, sz, sz, fg);
    this.isPicto = true;
    this.picto = this.elem.children[1];
    this.texts = [];
  }
  _picto(key, x, y, w, h, fg, bg) {
    let ch = getTypeOf(iconChars) == 'Object' ? iconChars[key] : iconChars.get(key);
    if (!ch) ch = iconChars.get('crow');
    return this._pictoFromChar(ch, x, y, w, h, fg, bg);
  }
  _pictoFromChar(ch, x, y, w, h, fg, bg) {
    let family = (ch[0] == 'f' || ch[0] == 'F') ? 'pictoFa' : 'pictoGame';
    let text = String.fromCharCode('0x' + ch);
    return this._pictoFromHexString(text, family, x, y, w, h, fg, bg);
  }
  _pictoFromHexString(text, family, x, y, w, h, fg, bg) {
    if (this.cat == 'g') {
      if (isdef(bg)) this.rect({ w: w, h: h, fill: bg, x: x, y: y });
      this.text({ txt: text, family: family, weight: 900, x: x, y: y, fz: h, fill: fg });
      this.orig.fg = fg;
      return this;
    } else {
    }
  }
  //#endregion
  //#region text
  computeTextColors(fill, alpha = 1, textBg = null) {
    fill = fill ? fill : this.fg ? this.fg : textBg ? colorIdealText(textBg) : this.bg ? colorIdealText(this.bg) : null;
    if (!fill) {
      fill = 'white';
      textBg = 'gray';
    }
    fill = colorFrom(fill, alpha);
    return { fill: fill, bg: textBg ? textBg : this.bg };
  }
  setTextFill(r, fill, alpha = 1, textBg = null) {
    let textColors = this.computeTextColors(fill, alpha, textBg);
    r.setAttribute('fill', textColors.fill);
    r.setAttribute('stroke', 'none');
    r.setAttribute('stroke-width', 0);
    return textColors.bg;
  }
  setTextBorder(color, thickness = 0) {
    let c = colorFrom(color);
    let children = arrChildren(this.elem);
    unitTestMS('setTextBorder', children);
    for (const ch of children) {
      let t = getTypeOf(ch);
      if (t == 'text' || t == 'line') {
        ch.setAttribute('stroke-width', thickness);
        ch.setAttribute('stroke', c);
      }
    }
  }
  calcTextWidth(txt, fz, family, weight) {
    let sFont = weight + ' ' + fz + 'px ' + family;
    sFont = sFont.trim();
    let wText = getTextWidth(txt, sFont);
    return wText;
  }
  addFrame(color) {
    if (this.cat == 'd') {
      this.body.style.boxSizing = 'border-box';
      this.body.style.border = '5px solid ' + color;
    }
  }
  addFlexTitleBody() {
    let content = this.elem.innerHTML;
    clearElement(this.elem);
    let d = this.elem;
    d.style.display = 'flex';
    d.style.flexDirection = 'column';
    let dTitle = document.createElement('div');
    this.title = dTitle;
    this.title.style.padding = '6px';
    this.title.style.textAlign = 'center';
    let dBody = document.createElement('div');
    dBody.style.flexGrow = 1;
    dBody.style = "flex-grow:1;overflow:auto;padding:0px 6px"
    this.body = dBody;
    this.body.innerHTML = content;
    this.elem.appendChild(this.title);
    this.elem.appendChild(this.body);
  }
  setTitle({
    txt,
    className = null,
    isOverlay = false,
    isMultiText = false,
    replaceFirst = true,
    fill = null,
    textBg = null,
    alpha = 1,
    x = 0,
    y = 0,
    fz = 20,
    family = 'Arial, Helvetica, sans-serif',
    weight = ''
  } = {}) {
    if (this.cat == 'd') {
      if (nundef(this.body) || nundef(this.title)) {
        this.addFlexTitleBody();
      }
      clearElement(this.title);
      if (isdef(textBg)) this.title.style.backgroundColor = textBg;
      if (isdef(fill)) this.title.style.color = fill;
      this.title.innerHTML = txt;
      return this;
    }
    let isFirstChild = this.elem.childNodes.length == 0;
    let r = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    if (isFirstChild) {
      this.ground = r;
    }
    r.setAttribute('font-family', family);
    r.setAttribute('font-weight', weight);
    if (isOverlay) {
      r.classList.add('overlay');
      this.overlay = r;
    }
    r.classList.add('msText');
    if (className) {
      r.classList.add(className);
    }
    textBg = this.setTextFill(r, fill, alpha, textBg);
    if (isFirstChild) {
      this.bgs.ground = textBg;
      this.fgs.ground = fill;
    }
    let wText = this.calcTextWidth(txt, fz, family, weight);
    if (this.isLine && !isMultiText) {
      x += this.x;
      y += this.y;
      if (this.textBackground) {
        this.elem.removeChild(this.textBackground);
      }
      this.textBackground = this.getRect({ w: wText + 10, h: fz * 1.5, fill: textBg });
      this.textBackground.setAttribute('rx', 6);
      this.textBackground.setAttribute('ry', 6);
    }
    r.setAttribute('font-size', '' + fz + 'px');
    r.setAttribute('x', x);
    r.setAttribute('y', y + fz / 2.8);
    r.setAttribute('text-anchor', 'middle');
    r.textContent = txt;
    r.setAttribute('pointer-events', 'none');
    if (replaceFirst && this.texts.length > 0) {
      let ch = this.texts[0].el;
      this.elem.insertBefore(r, ch);
      if (this.isLine) {
        this.elem.insertBefore(this.textBackground, r);
      }
      this.removeTexts();
    } else {
      if (this.isLine && !isMultiText) {
        this.elem.appendChild(this.textBackground);
      }
      this.elem.appendChild(r);
    }
    let res = { el: r, w: wText };
    this.texts.push(res);
    return res;
  }
  text({
    txt,
    className = null,
    isOverlay = false,
    isMultiText = false,
    replaceFirst = true,
    fill = null,
    textBg = null,
    alpha = 1,
    x = 0,
    y = 0,
    fz = 20,
    family = 'Arial, Helvetica, sans-serif',
    weight = ''
  } = {}) {
    if (this.cat == 'd') {
      if (isEmpty(txt)) {
        this.elem.innerHTML = ''; return this;
      }
      this.elem.style.textAlign = 'center';
      this.elem.style.color = fill ? fill : this.fg ? this.fg : 'white';
      let margin = this.h / 2 - fz / 2;
      this.elem.innerHTML = `<div style='margin-top:${margin}px;font-size:${fz}px;'>${txt}</div>`;
      this.elem.boxSizing = 'border-box';
      return this;
    }
    if (isdef(txt) && !isString(txt)) txt = txt.toString();
    if (isEmpty(txt)) {
      this.removeTexts(); return this;
    }
    let isFirstChild = this.elem.childNodes.length == 0;
    let r = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    if (isFirstChild) {
      this.ground = r;
    }
    r.setAttribute('font-family', family);
    r.setAttribute('font-weight', weight);
    if (isOverlay) {
      r.classList.add('overlay');
      this.overlay = r;
    }
    r.classList.add('msText');
    if (className) {
      r.classList.add(className);
    }
    textBg = this.setTextFill(r, fill, alpha, textBg);
    if (isFirstChild) {
      this.bgs.ground = textBg;
      this.fgs.ground = fill;
    }
    let wText = this.calcTextWidth(txt, fz, family, weight);
    if (this.isLine && !isMultiText) {
      x += this.x;
      y += this.y;
      if (this.textBackground) {
        this.elem.removeChild(this.textBackground);
      }
      this.textBackground = this.getRect({ w: wText + 10, h: fz * 1.5, fill: textBg });
      this.textBackground.setAttribute('rx', 6);
      this.textBackground.setAttribute('ry', 6);
    }
    r.setAttribute('font-size', '' + fz + 'px');
    r.setAttribute('x', x);
    r.setAttribute('y', y + fz / 2.8);
    r.setAttribute('text-anchor', 'middle');
    r.textContent = txt;
    r.setAttribute('pointer-events', 'none');
    if (replaceFirst && this.texts.length > 0) {
      let ch = this.texts[0].el;
      this.elem.insertBefore(r, ch);
      if (this.isLine) {
        this.elem.insertBefore(this.textBackground, r);
      }
      this.removeTexts();
    } else {
      if (this.isLine && !isMultiText) {
        this.elem.appendChild(this.textBackground);
      }
      this.elem.appendChild(r);
    }
    let res = { el: r, w: wText };
    this.texts.push(res);
    return res;
  }
  reduceFontSize(el, n) {
    let fz = el.getAttribute('font-size');
    fz = firstNumber(fz);
    if (fz > n) fz -= n;
    el.setAttribute('font-size', '' + fz + 'px');
  }
  clearText() { this.removeTexts(); }
  removeTexts() {
    for (const t of this.texts) {
      this.elem.removeChild(t.el);
    }
    this.texts = [];
  }
  multitext({
    replacePrevious = true,
    className = '',
    maxWidth = 1000,
    txt = ['one', 'two', 'three'],
    fz = 20,
    fill = null,
    textBg = null,
    padding = 1,
    alpha = 1,
    x = 0,
    y = 0,
    family = 'Arial, Helvetica, sans-serif',
    weight = 'lighter'
  }) {
    let nChar = 0;
    for (const s of txt) { nChar = Math.max(nChar, s.length); }
    let maxFH = Math.round(this.h / txt.length);
    let maxFW = Math.round((this.w / nChar) * 2);
    let fzFit = Math.min(maxFH, maxFW) - 2 * padding;
    if (fzFit < fz) fz = fzFit;
    if (fzFit > 5 * fz) fz *= 5;
    if (replacePrevious) this.removeTexts();
    let h = txt.length * (fz + padding);
    let textColors = this.computeTextColors(fill, alpha, textBg);
    if (this.isLine) {
      x += this.x;
      y += this.y;
      let tbg = this.textBackground ? this.textBackground : this.getRect();
      tbg.setAttribute('height', h);
      tbg.setAttribute('fill', textColors.bg);
      if (!this.textBackground) {
        this.textBackground = tbg;
        this.elem.appendChild(this.textBackground);
      }
      this.textBackground.setAttribute('rx', 6);
      this.textBackground.setAttribute('ry', 6);
    }
    let yStart = y - h / 2 + fz / 2;
    let maxW = 0;
    let akku = [];
    for (const t of txt) {
      let tel = this.text({
        isMultiText: true,
        replaceFirst: false,
        className: className,
        maxWidth: maxWidth,
        txt: t,
        fz: fz,
        fill: fill,
        padding: padding,
        alpha: alpha,
        x: x,
        y: yStart,
        family: family,
        weight: weight
      });
      maxW = Math.max(maxW, tel.w);
      akku.push(tel);
      yStart += fz + padding;
    }
    let isFirstChild = this.elem.childNodes.length == 0;
    if (isFirstChild || this.isLine) {
      this.ground = this.textBackground;
      this.w = maxW + 2 * padding;
      this.h = h;
    }
    if (this.isLine) {
      this.textBackground.setAttribute('width', this.w);
      this.textBackground.setAttribute('x', x - this.w / 2);
      this.textBackground.setAttribute('y', y - this.h / 2);
    }
    if (isFirstChild) { this.bgs.ground = textColors.bg; this.fg.ground = fill; }
    return this;
  }
  //#endregion
  //#region internal
  _setFill(el, fill, alpha) {
    if (fill != null && fill !== undefined) {
      fill = colorFrom(fill, alpha);
      el.setAttribute('fill', fill);
      return fill;
    }
    return null;
  }
  //#endregion
  //#region primitive shapes
  _ellipse() { return document.createElementNS('http://www.w3.org/2000/svg', 'ellipse'); }
  _circle() { return document.createElementNS('http://www.w3.org/2000/svg', 'ellipse'); }
  _rect() { return document.createElementNS('http://www.w3.org/2000/svg', 'rect'); }
  _square() { return document.createElementNS('http://www.w3.org/2000/svg', 'rect'); }
  _quad() { return document.createElementNS('http://www.w3.org/2000/svg', 'rect'); }
  _roundedRect() { return document.createElementNS('http://www.w3.org/2000/svg', 'rect'); }
  _hex() { return document.createElementNS('http://www.w3.org/2000/svg', 'polygon'); }
  _triangle() { return document.createElementNS('http://www.w3.org/2000/svg', 'polygon'); }
  _triangleDown() { return document.createElementNS('http://www.w3.org/2000/svg', 'polygon'); }
  _star() { return document.createElementNS('http://www.w3.org/2000/svg', 'polygon'); }
  _line() { return document.createElementNS('http://www.w3.org/2000/svg', 'line'); }
  _image() { return document.createElementNS('http://www.w3.org/2000/svg', 'image'); }
  _text() { return document.createElementNS('http://www.w3.org/2000/svg', 'text'); }
  //#endregion
  //#region geo: TODO: update!
  ellipse({ idx, border, thickness = 0, className = '', w = 50, h = 25, fill, alpha = 1, x = 0, y = 0 } = {}) {
    let r = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
    if (this.isLine) {
      x += this.x;
      y += this.y;
    }
    let bg = this._setFill(r, fill, alpha);
    r.setAttribute('stroke-width', thickness);
    if (thickness > 0) {
      border = colorFrom(border, alpha);
      r.setAttribute('stroke', border);
    }
    if (this.elem.childNodes.length == 0 || className.includes('ground')) {
      this.ground = r;
      this.bgs.ground = bg;
      this.fgs.ground = r.getAttribute('stroke');
      this.w = w;
      this.h = h;
    }
    r.setAttribute('rx', w / 2);
    r.setAttribute('ry', h / 2);
    r.setAttribute('cx', x);
    r.setAttribute('cy', y);
    if (className !== '') {
      r.setAttribute('class', className);
      if (className.includes('overlay')) {
        this.overlay = r;
      }
    }
    if (isdef(idx) && this.elem.childNodes.length > idx) {
      this.elem.insertBefore(r, this.elem.childNodes[idx]);
    } else {
      this.elem.appendChild(r);
    }
    return this;
  }
  getRect({ border, thickness = 0, className = '', w = 50, h = 25, fill, alpha = 1, x = 0, y = 0, rounding } = {}) {
    let r = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    if (this.isLine) {
      x += this.x;
      y += this.y;
    }
    r.setAttribute('width', w);
    r.setAttribute('height', h);
    r.setAttribute('x', -w / 2 + x);
    r.setAttribute('y', -h / 2 + y);
    let bg = this._setFill(r, fill, alpha);
    if (this.elem.childNodes.length == 0 || className.includes('ground')) {
      this.ground = r;
      this.bgs.ground = bg; this.fgs.ground = r.getAttribute('stroke');
      this.w = w;
      this.h = h;
    }
    r.setAttribute('stroke-width', thickness);
    if (thickness > 0) {
      border = colorFrom(border, alpha);
      r.setAttribute('stroke', border);
    }
    if (className !== '') {
      r.setAttribute('class', className);
      if (className.includes('overlay')) {
        this.overlay = r;
      }
    }
    return r;
  }
  circle({ idx, border, thickness = 0, className = '', sz = 25, fill, alpha = 1, x = 0, y = 0 } = {}) {
    return this.ellipse({
      idx: idx,
      className: className,
      w: sz,
      h: sz,
      fill: fill,
      border: border,
      thickness: thickness,
      alpha: alpha,
      x: x,
      y: y
    });
  }
  hex({ idx, className = '', x = 0, y = 0, w, h = 0, fill, alpha = 1, border = 'white', thickness = 0, flat = false }) {
    let r = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    if (h <= 0) { h = (2 * w) / 1.73; }
    let pts = size2hex(w, h, x, y);
    r.setAttribute('points', pts);
    let bg = this._setFill(r, fill, alpha);
    if (this.elem.childNodes.length == 0 || className.includes('ground')) {
      this.ground = r;
      this.bgs.ground = bg; this.fgs.ground = r.getAttribute('stroke');
      this.w = w;
      this.h = h;
    }
    if (thickness > 0) {
      border = convertToRgba(border, alpha);
      r.setAttribute('stroke', border);
      r.setAttribute('stroke-width', thickness);
    }
    if (className !== '') {
      r.setAttribute('class', className);
      if (className.includes('overlay')) {
        this.overlay = r;
      }
    }
    this.elem.appendChild(r);
    if (className.includes('ground')) { this.w = w; this.h = h; this.x = x; this.y = y; }
    return this;
  }
  triangle({ idx, className = '', x = 0, y = 0, w, h = 0, fill, alpha = 1, border = 'white', thickness = 0 }) {
    let pts = size2triup(w, h, x, y);
    if (this.elem.childNodes.length == 0 || className.includes('ground')) { this.w = w; this.h = h; this.x = x; this.y = y; }
    this.poly({ idx: idx, className: className, pts: pts, fill: fill, alpha: alpha, border: border, thickness: thickness });
    return this;
  }
  triangleDown({ idx, className = '', x = 0, y = 0, w, h = 0, fill, alpha = 1, border = 'white', thickness = 0 }) {
    let pts = size2tridown(w, h, x, y);
    this.poly({ idx: idx, className: className, pts: pts, fill: fill, alpha: alpha, border: border, thickness: thickness });
    if (this.elem.childNodes.length == 1 || className.includes('ground')) { this.w = w; this.h = h; this.x = x; this.y = y; }
    return this;
  }
  star({ idx, className = '', n = 6, w, h = 0, x = 0, y = 0, fill, alpha = 1, border = 'white', thickness = 0 }) {
    h = h == 0 ? w : h;
    let rad = w / 2;
    let pOuter = getCirclePoints(rad, n);
    let pInner = getCirclePoints(rad / 2, n, 180 / n);
    let pts = [];
    for (let i = 0; i < n; i++) {
      pts.push(pOuter[i]);
      pts.push(pInner[i]);
    }
    for (let i = 0; i < pts.length; i++) {
      pts[i].X = (pts[i].X + w / 2) / w;
      pts[i].Y = (pts[i].Y + h / 2) / h;
    }
    let sPoints = polyPointsFrom(w, h, x, y, pts);
    this.poly({ idx: idx, className: className, pts: sPoints, fill: fill, alpha: alpha, border: border, thickness: thickness });
    if (this.elem.childNodes.length == 1 || className.includes('ground')) { this.w = w; this.h = h; this.x = x; this.y = y; }
    return this;
  }
  image({ idx, className = '', path = '', w = 50, h = 50, x = 0, y = 0 } = {}) {
    let r = document.createElementNS('http://www.w3.org/2000/svg', 'image');
    r.setAttribute('href', path);
    r.setAttribute('width', w);
    r.setAttribute('height', h);
    r.setAttribute('x', -w / 2 + x);
    r.setAttribute('y', -h / 2 + y);
    if (className !== '') {
      r.setAttribute('class', className);
      if (className.includes('overlay')) {
        this.overlay = r;
      }
    }
    if (this.elem.childNodes.length == 0) {
      this.w = w;
      this.h = h;
    }
    this.elem.appendChild(r);
    return this;
  }
  getEndPointsOfLineSegmentOfLength(d) {
    if (!this.isLine) return null;
    let x1 = this.x1;
    let y1 = this.y1;
    let x2 = this.x2;
    let y2 = this.y2;
    let dx = x2 - x1;
    let dy = y2 - y1;
    let mx = dx / 2;
    let my = dy / 2;
    let sx = x1;
    let sy = y1;
    let factor = d / this.distance;
    let ex = x1 + factor * dx;
    let ey = y1 + factor * dy;
    let addx = (1 - factor) * dx / 2;
    let addy = (1 - factor) * dy / 2;
    return [sx + addx, sy + addy, ex + addx, ey + addy];
  }
  line({ idx, cap, className = '', x1 = 0, y1 = 0, x2 = 100, y2 = 100, fill, alpha = 1, length, thickness = 2 } = {}) {
    let r = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    r.setAttribute('x1', x1);
    r.setAttribute('y1', y1);
    r.setAttribute('x2', x2);
    r.setAttribute('y2', y2);
    if (isdef(cap)) r.setAttribute('stroke-linecap', cap);
    let isFirstChild = this.elem.childNodes.length == 0;
    let stroke = colorFrom(fill, alpha);
    if (thickness > 0) {
      r.setAttribute('stroke', stroke);
      r.setAttribute('stroke-width', thickness);
    }
    if (className !== '') {
      r.setAttribute('class', className);
    }
    if (className.includes('overlay')) {
      r.setAttribute('class', 'overlay_line');
      this.overlay = r;
    }
    if (isFirstChild || className.includes('ground')) {
      this.ground = r;
      this.bgs.ground = stroke; this.fgs.ground = stroke;
      this.isLine = true;
      this.x = Math.round((x1 + x2) / 2);
      this.y = Math.round((y1 + y2) / 2);
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
      this.center = { x: (x1 + x2) / 2, y: (y1 + y2) / 2 };
      this.distance = distance(x1, y1, x2, y2);
      if (length) {
        this.length = this.h = length;
      } else {
        this.length = this.h = this.distance;
      }
      this.thickness = thickness;
      this.w = thickness;
    }
    this.elem.appendChild(r);
    return this;
  }
  poly({ idx, className = '', pts = '0,0 100,0 50,80', fill, alpha = 1, border = 'white', thickness = 0 }) {
    let r = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    r.setAttribute('points', pts);
    let isFirstChild = this.elem.childNodes.length == 0;
    let bg = this._setFill(r, fill, alpha);
    if (isFirstChild || className.includes('ground')) {
      this.ground = r;
      this.bgs.ground = bg; this.fgs.ground = r.getAttribute('stroke');
    }
    if (thickness > 0) {
      border = colorFrom(border, alpha);
      r.setAttribute('stroke', border);
      r.setAttribute('stroke-width', thickness);
    }
    if (className !== '') {
      r.setAttribute('class', className);
      if (className.includes('overlay')) {
        this.overlay = r;
      }
    }
    this.elem.appendChild(r);
    return this;
  }
  rect({ idx, border, thickness = 0, className = '', w = 50, h = 25, fill, alpha = 1, x = 0, y = 0, rounding } = {}) {
    let r = this.getRect({ border: border, thickness: thickness, className: className, w: w, h: h, fill: fill, alpha: alpha, x: x, y: y, rounding: rounding });
    if (isdef(idx) && this.elem.childNodes.length > idx) {
      this.elem.insertBefore(r, this.elem.childNodes[idx]);
    } else {
      this.elem.appendChild(r);
    }
    return this;
  }
  roundedRect({ idx, border, thickness = 0, className = '', w = 150, h = 125, fill = 'darkviolet', rounding = 10, alpha = 1, x = 0, y = 0 } = {}) {
    return this.rect({ idx: idx, border: border, thickness: thickness, className: className, w: w, h: h, fill: fill, alpha: alpha, x: x, y: y, rounding: rounding })
  }
  square({ idx, className = '', sz = 50, fill = 'yellow', alpha = 1, x = 0, y = 0, border, thickness = 0, rounding } = {}) {
    return this.rect({
      idx: idx,
      className: className,
      w: sz,
      h: sz,
      fill: fill,
      alpha: alpha,
      x: x,
      y: y,
      border: border,
      thickness: thickness,
      rounding: rounding
    });
  }
  //#endregion
  //#region css classes
  addClass(el, clName) {
    if (nundef(el)) el = this.overlay ? this.overlay : this.ground;
    if (!el) return;
    el.classList.add(clName);
  }
  getClass() {
    if (this.overlay) {
      return getClass(this.overlay);
    } else if (this.ground) {
      return this.getClass(this.ground);
    }
    return null;
  }
  removeClass(el, clName) {
    if (nundef(el)) el = this.overlay ? this.overlay : this.ground;
    if (!el) return;
    el.classList.remove(clName);
  }
  //#endregion
  //#region tooltips
  calcCenterPos(ev) {
    let x, y;
    if (isdef(this.w)) {
      let rect = ev.target.getBoundingClientRect();
      let dx = ev.clientX - rect.left;
      let dy = ev.clientY - rect.top;
      x = ev.clientX - dx + this.w / 2;
      y = ev.clientY - dy + this.h / 2;
    } else {
      x = ev.pageX;
      y = ev.pageY;
    }
    return { x: x, y: y };
  }
  showTT(ev) {
    let d = document.getElementById('tooltip');
    clearElement(d);
    let oid = getOidForMainId(this.id);
    let oUpdated = oid in G.table ? G.table[oid] : G.playersAugmented[oid];
    let titleDomel = document.createElement('div');
    titleDomel.style.width = '100%';
    titleDomel.style.textAlign = 'center';
    titleDomel.innerHTML = ('obj_type' in oUpdated ? oUpdated.obj_type : 'player') + ('name' in oUpdated ? ':' + oUpdated.name : 'id' in oUpdated ? ':' + oUpdated.id : ' ' + oid);
    d.appendChild(titleDomel);
    let t = tableElemX(oUpdated);
    d.appendChild(t.table);
    let pos = this.calcCenterPos(ev);
    $('div#tooltip').css({
      display: 'inline-block',
      left: pos.x,
      top: pos.y,
    });
  }
  ttHandling(ev, eventName) {
    if (!this.o) return;
    let oid = getOidForMainId(this.id);
    if (!oid) return;
    if (eventName == 'mouseenter') {
      this.TTTT = setTimeout(() => this.showTT(ev), 500);
    }
    else if (eventName == 'mouseleave') {
      clearTimeout(this.TTTT); hideTooltip();
    }
  }
  //#endregion
  //#region events
  _handler(ev) {
    ev.stopPropagation();
    let eventName = ev.handleObj.origType;
    if (S.settings.tooltips) this.ttHandling(ev, eventName);
    if (!this.isEnabled) return;
    let part = $(ev.currentTarget);
    let partName;
    if (this.isa.deck && this.parts.topmost) partName = 'topmost';
    else if (part.id == this.elem.id) partName = 'elem';
    else { let props = $(part).attrs(); let name = props.name; if (nundef(name)) name = 'elem'; partName = name; }
    let handler = this.handlers[eventName][partName];
    if (isdef(handler)) { handler(ev, this, partName); }
  }
  addHandler(evName, partName = 'elem', handler = null, autoEnable = true) {
    let part = this._getPart(partName);
    if (nundef(part) || part == this.elem) { part = this.elem; partName = 'elem'; }
    else if (this.isa.deck) partName = 'topmost';
    if (isdef(handler)) {
      this.handlers[evName][partName] = handler;
    }
    $(part).off(evName).on(evName, this._handler.bind(this));
    if (autoEnable) this.enable();
  }
  addClickHandler(partName = 'elem', handler = null, autoEnable = true) { this.addHandler('click', partName, handler, autoEnable); }
  addMouseEnterHandler(partName = 'elem', handler = null, autoEnable = true) { this.addHandler('mouseenter', partName, handler, autoEnable); }
  addMouseLeaveHandler(partName = 'elem', handler = null, autoEnable = true) { this.addHandler('mouseleave', partName, handler, autoEnable); }
  removeClickHandler() { for (const partName in this.parts) { $(this.parts[partName]).off('click'); } this.handlers.click = {} }
  removeHoverHandlers() { for (const partName in this.parts) { $(this.parts[partName]).off('mouseenter mouseleave'); } this.handlers.mouseenter = {}; this.handlers.mouseleave = {} }
  removeHandlers() { this.removeEvents(); }
  removeEvents() {
    for (const partName in this.parts) { $(this.parts[partName]).off(); }
    this.handlers = { click: {}, mouseenter: {}, mouseleave: {} };
  }
  enable() { this.isEnabled = true; }
  disable() { this.isEnabled = false; }
  //#endregion
  //#region high
  getTopCardElemOfDeck() {
    return this.topmost;
  }
  _getPart(partName, elemIfMissing = true) {
    let part = this.parts[partName];
    if (this.isa.deck) {
      let tm = this.getTopCardElemOfDeck();
      return this.getTopCardElemOfDeck();
    } else {
      return isdef(part) ? part : elemIfMissing ? this.elem : null;
    }
  }
  highC(c, pname = 'elem', elIfMiss = true) {
    let part = this._getPart(pname, elIfMiss);
    if (!part) return;
    if (this.cat == 'g') {
      if (this.isPicto) {
        this.setTextFill(this.picto, '#ccff00', 1);
      } else {
        this.ground.setAttribute('fill', c);
        this.ground.setAttribute('stroke', c);
      }
    } else { part.style.backgroundColor = c; part.style.color = colorIdealText(c); }
  }
  unhighC(pname = 'elem', elIfMiss = true) {
    let part = this._getPart(pname, elIfMiss);
    if (!part) return;
    if (this.cat == 'g') {
      if (nundef(this.ground)) return;
      this.ground.setAttribute('fill', this.bgs.ground);
      if (this.fgs.ground) this.ground.setAttribute('stroke', this.fgs.ground);
    }
    else { let bg = part.bg; if (nundef(bg)) bg = null; part.style.backgroundColor = bg; if (isdef(bg)) part.style.color = colorIdealText(bg); }
  }
  high(pname = 'elem', elIfMiss = true) {
    let part = this._getPart(pname, elIfMiss);
    if (!part) return;
    if (this.cat == 'g') {
      if (this.isPicto) {
        this.setTextFill(this.picto, '#ccff00', 1);
      } else addClass(this.overlay, 'high');
    } else part.style.backgroundColor = '#ccff00';
  }
  unhigh(pname = 'elem', elIfMiss = true) {
    let part = this._getPart(pname, elIfMiss);
    if (!part) return;
    if (this.cat == 'g') {
      if (this.isPicto) {
        this.setTextFill(this.picto, this.orig.fg, 1);
      } else {
        removeClass(this.overlay, 'high');
      }
    } else { let bg = part.bg; if (nundef(bg)) bg = null; part.style.backgroundColor = bg; }
  }
  highFrame(pname = 'elem', elIfMiss = true) {
    let part = this._getPart(pname, elIfMiss);
    if (!part) return;
    if (this.isLine) this.addClass(this.overlay, 'lineHighFrame');
    else if (this.isPicto) {
      this.addClass(this.ground, 'high');
    } else if (this.isa.field) {
      this.addClass(this.overlay, 'fieldHighFrame');
    }
    else addClass(this.cat == 'g' ? this.overlay : this.parts['title'], 'highFrame')
  }
  unhighFrame(pname = 'elem', elIfMiss = true) {
    let part = this._getPart(pname, elIfMiss);
    if (!part) return;
    if (this.isLine) this.removeClass(this.overlay, 'lineHighFrame');
    else if (this.isPicto) {
      this.removeClass(this.ground, 'high');
    } else if (this.isa.field) {
      this.removeClass(this.overlay, 'fieldHighFrame');
    } else removeClass(this.cat == 'g' ? this.overlay : this.parts['title'], 'highFrame')
  }
  unhighAll() { for (const k in this.parts) { this.unhigh(k); this.unhighFrame(k); this.unhighC(k); } }
  sel() { }
  unsel() { }
  frame() { }
  unframe() { }
  hide(pname = 'elem', elIfMiss = false) { let part = this._getPart(pname, elIfMiss); if (part) hide(part); }
  show(pname = 'elem', elIfMiss = false) { let part = this._getPart(pname, elIfMiss); if (part) show(part); }
  minimize() {
    if ('title' in this.parts) {
      for (const k in this.parts) {
        if (k == 'elem' || k == 'title') continue;
        this.hide(k)
      }
      this.isMinimized = true;
    }
  }
  maximize() {
    if (this.isMinimized) {
      for (const k in this.parts) {
        if (k == 'elem' || k == 'title') continue;
        this.show(k)
      }
    }
  }
  //#endregion
  //#region basic properties x,y,w,h,bg,fg
  resetBg() {
    if (this.orig.bg) {
      this.setBg(this.orig.bg);
    }
  }
  resetShape() {
    this.setShape(this.orig.shape);
  }
  resetSize() {
    this.setSize(this.originalSize.w, this.originalSize.h);
  }
  setBg(c, { updateFg = false, partName = 'elem' } = {}) {
    if (this.isLine) {
      this.bg = c;
      let el = this.elem;
      el.setAttribute('fill', c)
      el.setAttribute('stroke', c)
      el.style.stroke = c;
      for (const e of el.children) {
        e.setAttribute('stroke', c)
        e.setAttribute('fill', c);
        e.style.stroke = c;
        return this;
      }
    }
    let part = this.parts[partName];
    if (partName == 'elem') { this.bg = c; }
    part.bg = c;
    if (this.cat == 'g') {
      if (this.type == 'text') {
        if (!this.textBackground) {
        }
      } else {
        this.elem.setAttribute('fill', c);
      }
    } else {
      part.style.backgroundColor = c;
    }
    if (updateFg) {
      this.setFg(colorIdealText(c), { partName: partName });
    }
    return this;
  }
  setFg(c, { updateBg = false, partName = 'elem' } = {}) {
    let part = this.parts[partName];
    if (partName == 'elem') { this.fg = c; }
    part.fg = c;
    if (this.cat == 'g') {
      if (this.type == 'text') {
        this.elem.setAttribute('fill', c);
      } else {
        this.elem.setAttribute('stroke', c);
      }
    } else {
      part.style.color = c;
    }
    return this;
  }
  setFullSize() {
    let parent = UIS[this.idParent]; if (nundef(parent)) return;
    this.setSize(parent.w, parent.h);
    this.setPos(0, 0);
  }
  setBounds(x, y, w, h, unit = '%') {
    let el = this.elem;
    this.setSize(w, h);
    this.setPos(x, y);
  }
  setColor(c) {
    this.setBg(c);
  }
  setHeight(h) {
    this.elem.style.height = h + 'px'; this.h = h;
  }
  setSize(w, h) {
    this.w = w; this.h = h;
    if (this.cat == 'g') {
      if (this.ground) {
        this.ground.setAttribute('width', w);
        this.ground.setAttribute('height', h);
      } else {
        this.elem.setAttribute('width', w);
        this.elem.setAttribute('height', h);
      }
      if (this.overlay) {
        this.overlay.setAttribute('width', w);
        this.overlay.setAttribute('height', h);
      }
    } else {
      this.elem.style.width = w + 'px';
      this.elem.style.height = h + 'px';
    }
    return this;
  }
  centerInDiv() {
    this.parent = UIS[this.idParent];
    if (isdef(this.parent)) {
      let d = this.elem;
      let divParent = this.parent.elem;
      let wParent = divParent.offsetWidth;
      let cards = this.deck.cards;
      let wElem = cards.length > 0 ? cards[0].elem.offsetWidth : 78;
      let hParent = divParent.offsetHeight;
      let hElem = cards.length > 0 ? cards[0].elem.offsetHeight : 110;
      d.style.position = 'relative';
      this.centerX = (wParent - wElem) / 2;
      this.centerY = (hParent - hElem) / 2;
      this.w = wElem;
      this.h = hElem;
      d.style.left = '' + this.centerX + 'px';
      d.style.top = '' + this.centerY + 'px';
    }
  }
  setPos(x, y) {
    this.x = x;
    this.y = y;
    if (this.cat == 'g') {
      this.elem.setAttribute('transform', `translate(${x},${y})`);
    } else {
      if (isdef(this.centerX)) {
        this.elem.style.left = '' + (this.centerX + x) + 'px';
        this.elem.style.top = '' + (this.centerY + y) + 'px';
      } else {
        this.elem.style.position = 'absolute';
        this.elem.style.left = x + 'px';
        this.elem.style.top = y + 'px';
      }
    }
    return this;
  }
  _modTransformBy(el, { x, y, scaleX, scaleY, rotDeg } = {}) {
    let info = getTransformInfo(el);
    console.log(info)
    let xNew, yNew, scaleXNew, scaleYNew, rotNew;
    if (isdef(x)) xNew = info.translateX + x; else xNew = info.translateX;
    if (isdef(y)) yNew = info.translateY + y; else yNew = info.translateY;
    if (isdef(scaleX)) scaleXNew = info.scaleX + scaleX; else scaleXNew = info.scaleX;
    if (isdef(scaleY)) scaleYNew = info.scaleY + scaleY; else scaleYNew = info.scaleY;
    if (isdef(rotDeg)) rotNew = info.rotation + rotDeg; else rotNew = info.rotation;
    let sTrans = ''; let sScale = ''; let sRot = '';
    if (xNew != 0 || yNew != 0) sTrans = `translate(${xNew},${yNew})`;
    if (scaleXNew != 1 || scaleYNew != 1) sScale = `scale(${scaleXNew},${scaleYNew})`;
    if (rotNew != 0) sRot = `rotation(${rotNew}deg)`;
    let s = (sTrans + ' ' + sScale + ' ' + sRot).trim();
    el.setAttribute("transform", s);
  }
  _setTransform(el, { x, y, scaleX, scaleY, rotDeg } = {}) {
    let info = getTransformInfo(el);
    let xNew, yNew, scaleXNew, scaleYNew, rotNew;
    if (isdef(x)) xNew = x; else xNew = info.translateX;
    if (isdef(y)) yNew = y; else yNew = info.translateY;
    if (isdef(scaleX)) scaleXNew = scaleX; else scaleXNew = info.scaleX;
    if (isdef(scaleY)) scaleYNew = scaleY; else scaleYNew = info.scaleY;
    if (isdef(rotDeg)) rotNew = rotDeg; else rotNew = info.rotation;
    let sTrans = ''; let sScale = ''; let sRot = '';
    if (xNew != 0 || yNew != 0) sTrans = `translate(${xNew} ${yNew})`;
    if (scaleXNew != 1 || scaleYNew != 1) sScale = `scale(${scaleXNew} ${scaleYNew})`;
    if (rotNew != 0) sRot = `rotate(${rotNew})`;
    let s = (sTrans + ' ' + sScale + ' ' + sRot).trim();
    el.setAttribute("transform", s);
  }
  setScale(scale, partName = 'elem') {
    let el = this.parts[partName];
    if (!el) return;
    if (this.cat == 'd') el.style.transform = `scale(${scale})`;
    else this._setTransform(el, { x: this.x, y: this.y, scaleX: scale, scaleY: scale });
  }
  setShape(shape) {
    if (nundef(this.ground)) {
      console.log('cannot replace shape because no this.ground');
      return;
    }
    let curShape = getTypeOf(this.ground);
    if (shape == 'circle') shape = 'ellipse';
    if (shape == 'square') shape = 'rect';
    if (curShape != shape) {
      let childNodes = [...this.elem.children];
      let iGround = childNodes.indexOf(this.ground);
      let iOverlay = childNodes.indexOf(this.overlay);
      let fill = this.ground.getAttribute('fill');
      this.overlay = null;
      this.ground = null;
      this[shape]({ className: 'ground', w: this.w, h: this.h, fill: fill });
      let newGround = this.elem.children[this.len() - 1];
      this[shape]({ className: 'overlay', w: this.w, h: this.h });
      let newOverlay = this.elem.children[this.len() - 1];
      this.replaceChild(this.elem.childNodes[iGround], newGround);
      this.ground = newGround;
      this.replaceChild(this.elem.childNodes[iOverlay], newOverlay);
    }
  }
  //#endregion
  //#region parts
  body(key = 'body', color) {
    if (this.parts[key]) return;
    let t = document.createElement('div');
    t.style.padding = '4px 8px';
    let bg = color;
    this.elem.appendChild(t);
    this.parts[key] = t;
    $(t).attrs({ name: key });
    if (isdef(bg)) this.setBg(bg, { updateFg: (color != 'dimgray'), partName: key });
    return this;
  }
  title(s, key = 'title', color = 'dimgray') {
    if (this.parts[key]) {
      this.parts[key].style.backgroundColor = randomColor();
      return;
    }
    let t = document.createElement('div');
    t.style.borderRadius = '6px';
    t.style.padding = '4px 8px';
    let bg = color;
    t.classList.add('tttitle');
    t.innerHTML = s;
    this.elem.appendChild(t);
    this.parts[key] = t;
    $(t).attrs({ name: key });
    this.setBg(bg, { updateFg: (color != 'dimgray'), partName: key });
    return this;
  }
  table(o, keys, key = 'table') {
    if (this.parts[key]) {
      let oldTable = this.parts[key];
      let t = tableElem(o, keys);
      let t2 = t.innerHTML;
      oldTable.innerHTML = t2;
    } else {
      let t = tableElem(o, keys);
      this.elem.appendChild(t);
      this.attach();
      this.parts[key] = t;
      t.name = key;
    }
    return this;
  }
  tableX(o, keys, key = 'table') {
    let replace = isdef(this.parts[key]);
    let res = tableElemX(o, keys);
    let tNew = res.table;
    let rNew = res.refs.map(x => x.id);
    tNew.name = key;
    if (replace) {
      let oldTable = this.parts[key];
      let oldRefs = this.refs[key];
      if (isdef(oldRefs)) {
        oldRefs.map(x => {
          deleteRSG(x);
        });
        delete this.refs[key];
      }
      oldTable.innerHTML = tNew.innerHTML;
    } else {
      this.elem.appendChild(tNew);
      this.attach();
      this.parts[key] = tNew;
    }
    if (!isEmpty(res)) {
      makeRefs(this.id, res.refs);
      this.refs[key] = rNew;
    }
    return this;
  }
  tableY(o, keys, key = 'table') {
    let replace = isdef(this.parts[key]);
    let res = tableElemY(o, keys);
    let tNew = res.table;
    let rNew = res.refs.map(x => x.id);
    tNew.name = key;
    if (replace) {
      let oldTable = this.parts[key];
      let oldRefs = this.refs[key];
      if (isdef(oldRefs)) { oldRefs.map(x => deleteRSG(x)); delete this.refs[key]; }
      oldTable.innerHTML = tNew.innerHTML;
    } else {
      this.elem.appendChild(tNew);
      this.attach();
      this.parts[key] = tNew;
    }
    if (!isEmpty(res)) {
      makeRefs(this.id, res.refs);
      this.refs[key] = rNew;
    }
    return this;
  }
  //#endregion
  //#region admin/general
  attach(partName) {
    if (!this.isAttached) {
      this.isAttached = true;
      let parentMS = UIS[this.idParent];
      let parentElem = isdef(partName) && isdef(parentMS.parts[partName]) ? parentMS.parts[partName] : parentMS.elem;
      parentElem.appendChild(this.elem);
    }
    return this;
  }
  detach(partName) {
    if (this.isAttached) {
      this.isAttached = false;
      let parentMS = UIS[this.idParent];
      let parentElem = isdef(partName) && isdef(parentMS.parts[partName]) ? parentMS.parts[partName] : parentMS.elem;
      parentElem.removeChild(this.elem);
    }
    return this;
  }
  clear(startProps = {}) {
    let ids = this.children.map(x => x);
    for (const id of ids) {
      deleteRSG(id);
    }
    clearElement(this.elem);
    for (const k in startProps) {
      this.elem[k] = startProps[k];
    }
    this.children = [];
  }
  destroy() {
    this.clear();
    $(this.elem).remove();
    this.elem = null;
    this.isAttached = false;
    let parent = UIS[this.idParent];
    removeInPlace(parent.children, this.id);
  }
  len() { return this.elem.children.length; }
  replaceChild(oldChild, newChild) {
    this.elem.insertBefore(newChild, oldChild);
    this.elem.removeChild(oldChild);
  }
  toString() { return 'id: ' + this.id + ', ' + this.domType + ', ' + this.x + ', ' + this.y + ', ' + this.w + ', ' + this.h + ', ' + this.bg + ', ' + this.fg + ', ' + this.children; }
  //#endregion
}
class MS {
  constructor({ parent, id, type = 'g', domel = null, isa = {} } = {}) {
    if (domel) {
      if (domel.id == 'R_d_root') {
        this.handlers = { click: {}, mouseenter: {}, mouseleave: {} }; this.parent = null; this.id = 'R_d_root'; this.type = 'div'; this.cat = 'd'; this.elem = domel; this.parts = { _: this.elem }; this.children = []; return;
      }
      this.id = domel.id;
      this.type = getTypeOf(domel);
      this.parent = UIS[domel.parentNode.id];
    } else {
      this.id = nundef(id) ? getUID() : id;
      this.type = type;
      this.parent = parent;
    }
    UIS[this.id] = this;
    this.cat = MSCATS[this.type]; //'d' for dom els and 'g' for svg els
    this.elem = domel ? domel
      : this.cat == 'g' || this.type == 'svg' ? document.createElementNS('http://www.w3.org/2000/svg', this.type)
        : document.createElement(this.type);
    this.elem.ms = this;
    this.elem.id = this.id;
    if (nundef(this.parent)) this.parent = ROOT;
    this.children = [];
    this.posRef = this.parent;
    if (this.cat == 'd' && this.parent.cat == 'g') {
      let ancestor = closestParent(parent.elem, 'div');
      console.log('FOUND domParent:', ancestor);
      this.posRef = this.parent;
      this.parent = ancestor.ms;
    } else if (this.parent.cat == 'd' && this.parent.type != 'svg' && this.cat == 'g') {
      let msSvg = new MMS({ parent: this.parent, type: 'svg' }).setDefaults().attach();
      this.parent = msSvg;
      this.posRef = msSvg;
    }
    if (domel) { addIf(this.parent.children, this); }
    this.x = 0; this.y = 0; this.w = 0; this.h = 0;
    for (const d in isa) {
      if (d == 'id') { continue; }
      this[d] = isa[d];
    }
    this.isa = Object.keys(isa);
    this.parts = { _: this.elem };
    this.uis = [];
    this.handlers = { click: {}, mouseenter: {}, mouseleave: {} };
  }
  //#region events
  _handler(ev) {
    ev.stopPropagation();
    if (!this.isEnabled) return;
    let part = ev.currentTarget;
    let partName = isdef(part.name) ? part.name : '_';
    let eventName = ev.handleObj.origType;
    let handler = this.handlers[eventName][partName];
    if (isdef(handler)) { counters[eventName] += 1; counters.events += 1; handler(this, part); }
  }
  addHandler(evName, partName = '_', handler = null, autoEnable = true) {
    let part = this.parts[partName];
    if (nundef(part)) { part = this.elem; partName = '_'; }
    if (isdef(handler)) { this.handlers[evName][partName] = handler; }
    $(part).off(evName).on(evName, this._handler.bind(this));
    if (autoEnable) this.enable();
  }
  addClickHandler(partName = '_', handler = null, autoEnable = true) { this.addHandler('click', partName, handler, autoEnable); }
  addMouseEnterHandler(partName = '_', handler = null, autoEnable = true) { this.addHandler('mouseenter', partName, handler, autoEnable); }
  addMouseLeaveHandler(partName = '_', handler = null, autoEnable = true) { this.addHandler('mouseleave', partName, handler, autoEnable); }
  removeEvents() {
    $(this.elem).off();
    if (S_showEvents) this.showEvents(this.elem);
    for (const partName in this.parts) {
      $(this.parts[partName]).off();
      if (S_showEvents) this.showEvents(this.parts[partName]);
    }
  }
  //#endregion
  //#region done
  clear(startProps = {}) {
    let ids = this.children.map(x => x.id);
    for (const id of ids) UIS[id].destroy();
    for (const k in startProps) {
      this.elem[k] = startProps[k];
    }
    console.log('children after clear', this.children);
  }
  destroy() {
    $(this.elem).remove();
    this.elem = null;
    removeInPlace(this.parent.children, this);
    delete UIS[this.id];
  }
  //#endregion
  //#region work
  title(s, key = 'title') {
    if (this.parts[key]) {
      this.parts[key].style.backgroundColor = randomColor();
      return;
    }
    let t = document.createElement('div');
    t.style.backgroundColor = 'dimgray';
    this.titleColor = t.style.backgroundColor;
    t.classList.add('tttitle');
    t.innerHTML = s;
    this.elem.appendChild(t);
    this.parts[key] = t;
    t.name = key;
    this.attach();
    return this;
  }
  table(o, keys, key = 'table') {
    if (this.parts[key]) {
      let oldTable = this.parts[key];
      let t = tableElem(o, keys);
      let t2 = t.innerHTML;
      oldTable.innerHTML = t2;
    } else {
      let t = tableElem(o, keys);
      this.elem.appendChild(t);
      this.attach();
      this.parts[key] = t;
      t.name = key;
    }
    return this;
  }
  //#endregion
  //#region TODO
  attach() { if (!this.isAttached) { addIf(this.parent.children, this); this.parent.elem.appendChild(this.elem); } return this; }
  detach() { if (this.isAttached) { removeIf(this.parent.children, this); this.parent.elem.removeChild(this.elem); } return this; }
  _onMouseEnter(ev) {
    if (!this.isEnabled) return;
    let partName = evToId(ev);
    if (S_showEvents) {
      counters.events += 1;
    }
    if (typeof this.mouseEnterHandler == 'function') {
      if (S_showEvents)
        this.mouseEnterHandler(ev);
    }
  }
  _onMouseLeave(ev) {
    if (!this.isEnabled) return;
    let partName = evToId(ev);
    if (S_showEvents) {
      counters.events += 1;
    }
    if (typeof this.mouseLeaveHandler == 'function') {
      if (S_showEvents)
        this.mouseLeaveHandler(ev);
    }
  }
  _getRect(x = 0, y = 0, w = 50, h = 25, bg, fg) {
    let r = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    r.setAttribute('width', w);
    r.setAttribute('height', h);
    r.setAttribute('x', x);
    r.setAttribute('y', y);
    if (isdef(bg)) r.setAttribute('fill', bg);
    if (isdef(fg)) r.setAttribute('stroke', bg);
    return r;
  }
  _getDiv(x, y, w, h, bg, fg) {
    let r = document.createElement('div');
    if (this.w < w || this.h < h) { this.setSize(w, h); }
    if (isdef(x)) {
      r.style.position = 'absolute';
      r.style.left = x + 'px';
      r.style.top = y + 'px';
    }
    if (isdef(w)) {
      r.style.width = w + 'px';
      r.style.height = h + 'px';
    }
    if (isdef(bg)) r.style.backgroundColor = bg;
    if (isdef(fg)) r.style.color = fg;
    return r;
  }
  addInteractivity(partName, hover = true, click = true) {
    let part = this.parts[partName];
    if (nundef(part)) { part = this.elem; }
    if (this.part.isInteractive) return;
    this.part.isInteractive = true;
    if (click) this.part.clickHandler = null;
    if (hover) { this.part.mouseEnterHandler = null; this.part.mouseLeaveHandler = null; }
    this.isEnabled = false;
    this.enable = () => this.isEnabled = true;
    this.disable = () => this.isEnabled = false;
    this.elem.addEventListener('click', this._onClick.bind(this));
    this.elem.addEventListener('mouseenter', this._onMouseEnter.bind(this));
    this.elem.addEventListener('mouseleave', this._onMouseLeave.bind(this));
    return this;
  }
  enable() {
    this.isEnabled = true;
  }
  disable() {
    this.isEnabled = false;
  }
  high() {
    if (isdef(this.parts) && isdef(this.parts.title)) this.parts['title'].style.backgroundColor = '#ccff00';
    else {
      this.elem.classList.add('selected');
      this.elem.backgroundColor = '#ccff00';
    }
  }
  unhigh() {
    if (isdef(this.parts) && isdef(this.parts.title)) this.parts['title'].style.backgroundColor = this.titleColor;
    else {
      this.elem.classList.remove('selected');
      this.elem.backgroundColor = this.titleColor;
    }
  }
  sel() { }
  unsel() { }
  frame() { }
  unframe() { }
  setDefaults({ x, y, w, h, bg, fg } = {}) {
    if (this.parent.type == 'svg' && isdef(bg) && nundef(w) && nundef(h) && this.domType == 'g') {
      this.parent.setBg(bg);
    } else {
      if (isdef(bg) || this.cat == 'd') {
        bg = nundef(bg) ? 'transparent' : bg;
        this.setBg(bg);
        fg = nundef(fg) ? bg == 'transparent' ? this.parent.fg : colorIdealText(bg) : fg;
        this.setFg(fg);
      }
    }
    if (this.cat == 'd' && (nundef(this.x) || nundef(this.w))) return this;
    w = nundef(w) ? this.posRef.w : w;
    h = nundef(h) ? this.posRef.h : h;
    this.setSize(w, h);
    x = nundef(x) ? 0 : this.posRef.x + x;
    y = nundef(y) ? 0 : this.posRef.y + y;
    if (this.parent.cat == 'd') { this.parent.elem.style.position = 'absolute'; }
    this.setPos(x, y);
    return this;
  }
  setBg(c, updateFg = false) {
    this.bg = c;
    if (this.cat == 'g') {
      if (this.domType == 'text') {
        if (!this.textBackground) {
        }
      } else {
        this.elem.setAttribute('fill', c);
      }
    } else {
      this.elem.style.backgroundColor = c;
    }
    if (updateFg) {
      this.setFg(colorIdealText(c), true);
    }
    return this;
  }
  setFg(c) {
    this.fg = c;
    if (this.cat == 'g') {
      if (this.domType == 'text') {
        this.elem.setAttribute('fill', c);
      } else {
        this.elem.setAttribute('stroke', c);
      }
    } else {
      this.elem.style.color = c;
    }
    return this;
  }
  setFullSize() {
    this.setSize(this.posRef.w, this.posRef.h);
    this.setPos(0, 0);
  }
  setSize(w, h) {
    this.w = w; this.h = h;
    if (this.cat == 'g') {
      if (this.ground) {
        this.ground.setAttribute('width', w);
        this.ground.setAttribute('height', h);
      } else {
        this.elem.setAttribute('width', w);
        this.elem.setAttribute('height', h);
      }
      if (this.overlay) {
        this.overlay.setAttribute('width', w);
        this.overlay.setAttribute('height', h);
      }
    } else {
      this.elem.style.position = 'absolute';
      this.elem.style.width = w + 'px';
      this.elem.style.height = h + 'px';
    }
    return this;
  }
  setPos(x, y) {
    this.x = x;
    this.y = y;
    if (this.cat == 'g') {
      this.elem.setAttribute('transform', `translate(${x},${y})`);
    } else {
      this.elem.style.position = 'absolute'
      this.elem.style.left = x + 'px';
      this.elem.style.top = y + 'px';
    }
    return this;
  }
  center() {
    this.setPos(-this.w / 2, -this.h / 2)
  }
  centerOrigin() {
    this.setPos(this.w / 2, this.h / 2);
  }
  rect({ x = 0, y = 0, w = 50, h = 25, bg, fg } = {}) {
    let pa = this.domType == 'g' ? this._getRect(x, y, w, h, bg, fg) : this._getDiv(x, y, w, h, bg, fg);
    this.elem.appendChild(pa);
    this.attach();
    return this;
  }
  addBorder(c) {
    if (this.cat == 'd') {
      this.elem.style.border = '1px solid ' + c;
    }
  }
  removeBorder() {
    if (this.cat == 'd') {
      this.elem.style.border = null;
    }
  }
  selBlack() {
    if (this.isSelBlack) return;
    this.elem.classList.add('selBlack');
    this.isSelBlack = true;
  }
  unselBlack() {
    if (!this.isSelBlack) return;
    this.elem.classList.remove('selBlack');
    this.isSelBlack = false;
  }
  selRed() { }
  unselAll() { this.removeBorder(); }
  //#endregion
}
class MS_dep {
  constructor({ rsgType, parent, id, oid, o, domType = 'g', domel = null } = {}) {
    this.rsgType = rsgType;
    if (rsgType == 'b') {
      this.oid = oid;
      _setIsa(this, o);
      this.id = 'b@' + o.iTuple;
      if (isdef(domel)) { this.parent = UIS[domel.id]; this.domType = getTypeOf(domel); this.cat = MSCAT(this.domType); this.elem = domel; this.elem.id = this.id; }
      else { this.parent = parent; this.domType = domType; this.cat = MSCAT(this.domType); this.elem = _createDom(this.cat, domType); this.elem.id = this.id; }
    }
    if (domel) {
      if (domel.id == 'R_d_root') {
        this.handlers = { click: {}, mouseenter: {}, mouseleave: {} }; this.parent = null; this.id = 'R_d_root'; this.domType = 'div'; this.cat = 'd'; this.elem = domel; this.parts = { _: this.elem }; this.children = []; return;
      }
      this.id = domel.id;
      this.domType = getTypeOf(domel);
      this.parent = UIS[domel.parentNode.id];
    } else {
      this.id = nundef(id) ? getUID() : id;
      this.domType = domType;
      this.parent = parent;
    }
    UIS[this.id] = this;
    this.cat = MSCATS[this.domType]; //'d' for dom els and 'g' for svg els
    this.elem = domel ? domel
      : this.cat == 'g' || this.domType == 'svg' ? document.createElementNS('http://www.w3.org/2000/svg', this.domType)
        : document.createElement(this.domType);
    this.elem.ms = this;
    this.elem.id = this.id;
    if (nundef(this.parent)) this.parent = ROOT;
    this.children = [];
    this.posRef = this.parent;
    if (this.cat == 'd' && this.parent.cat == 'g') {
      let ancestor = closestParent(parent.elem, 'div');
      this.posRef = this.parent;
      this.parent = ancestor.ms;
    } else if (this.parent.cat == 'd' && this.parent.type != 'svg' && this.cat == 'g') {
      let msSvg = new MMS({ parent: this.parent, type: 'svg' }).setDefaults().attach();
      this.parent = msSvg;
      this.posRef = msSvg;
    }
    if (domel) { addIf(this.parent.children, this); this.isAttached = true; }
    this.x = 0; this.y = 0; this.w = 0; this.h = 0;
    this.parts = { _: this.elem };
    this.uis = [];
    this.handlers = { click: {}, mouseenter: {}, mouseleave: {} };
  }
  //#region events
  _handler(ev) {
    ev.stopPropagation();
    if (!this.isEnabled) return;
    let part = ev.currentTarget;
    let partName = isdef(part.name) ? part.name : '_';
    let eventName = ev.handleObj.origType;
    let handler = this.handlers[eventName][partName];
    if (isdef(handler)) { counters[eventName] += 1; counters.events += 1; handler(this, part); }
  }
  addHandler(evName, partName = '_', handler = null, autoEnable = true) {
    let part = this.parts[partName];
    if (nundef(part)) { part = this.elem; partName = '_'; }
    if (isdef(handler)) { this.handlers[evName][partName] = handler; }
    $(part).off(evName).on(evName, this._handler.bind(this));
    if (autoEnable) this.enable();
  }
  addClickHandler(partName = '_', handler = null, autoEnable = true) { this.addHandler('click', partName, handler, autoEnable); }
  addMouseEnterHandler(partName = '_', handler = null, autoEnable = true) { this.addHandler('mouseenter', partName, handler, autoEnable); }
  addMouseLeaveHandler(partName = '_', handler = null, autoEnable = true) { this.addHandler('mouseleave', partName, handler, autoEnable); }
  removeEvents() {
    $(this.elem).off();
    if (S_showEvents) this.showEvents(this.elem);
    for (const partName in this.parts) {
      $(this.parts[partName]).off();
      if (S_showEvents) this.showEvents(this.parts[partName]);
    }
  }
  //#endregion
  //#region done
  clear(startProps = {}) {
    let ids = this.children.map(x => x.id);
    for (const id of ids) UIS[id].destroy();
    for (const k in startProps) {
      this.elem[k] = startProps[k];
    }
    console.log('children after clear', this.children);
  }
  destroy() {
    $(this.elem).remove();
    this.elem = null;
    removeInPlace(this.parent.children, this);
    delete UIS[this.id];
  }
  //#endregion
  //#region work
  title(s, key = 'title') {
    if (this.parts[key]) {
      this.parts[key].style.backgroundColor = randomColor();
      return;
    }
    let t = document.createElement('div');
    t.style.backgroundColor = 'dimgray';
    this.titleColor = t.style.backgroundColor;
    t.classList.add('tttitle');
    t.innerHTML = s;
    this.elem.appendChild(t);
    this.parts[key] = t;
    t.name = key;
    this.attach();
    return this;
  }
  table(o, keys, key = 'table') {
    if (this.parts[key]) {
      let oldTable = this.parts[key];
      let t = tableElem(o, keys);
      let t2 = t.innerHTML;
      oldTable.innerHTML = t2;
    } else {
      let t = tableElem(o, keys);
      this.elem.appendChild(t);
      this.attach();
      this.parts[key] = t;
      t.name = key;
    }
    return this;
  }
  //#endregion
  //#region TODO
  attach() { if (!this.isAttached) { addIf(this.parent.children, this); this.parent.elem.appendChild(this.elem); } return this; }
  detach() { if (this.isAttached) { removeIf(this.parent.children, this); this.parent.elem.removeChild(this.elem); } return this; }
  _onMouseEnter(ev) {
    if (!this.isEnabled) return;
    let partName = evToId(ev);
    if (S_showEvents) {
      counters.events += 1;
    }
    if (typeof this.mouseEnterHandler == 'function') {
      if (S_showEvents)
        this.mouseEnterHandler(ev);
    }
  }
  _onMouseLeave(ev) {
    if (!this.isEnabled) return;
    let partName = evToId(ev);
    if (S_showEvents) {
      counters.events += 1;
    }
    if (typeof this.mouseLeaveHandler == 'function') {
      if (S_showEvents)
        this.mouseLeaveHandler(ev);
    }
  }
  _getRect(x = 0, y = 0, w = 50, h = 25, bg, fg) {
    let r = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    r.setAttribute('width', w);
    r.setAttribute('height', h);
    r.setAttribute('x', x);
    r.setAttribute('y', y);
    if (isdef(bg)) r.setAttribute('fill', bg);
    if (isdef(fg)) r.setAttribute('stroke', bg);
    return r;
  }
  _getDiv(x, y, w, h, bg, fg) {
    let r = document.createElement('div');
    if (this.w < w || this.h < h) { this.setSize(w, h); }
    if (isdef(x)) {
      r.style.position = 'absolute';
      r.style.left = x + 'px';
      r.style.top = y + 'px';
    }
    if (isdef(w)) {
      r.style.width = w + 'px';
      r.style.height = h + 'px';
    }
    if (isdef(bg)) r.style.backgroundColor = bg;
    if (isdef(fg)) r.style.color = fg;
    return r;
  }
  addInteractivity(partName, hover = true, click = true) {
    let part = this.parts[partName];
    if (nundef(part)) { part = this.elem; }
    if (this.part.isInteractive) return;
    this.part.isInteractive = true;
    if (click) this.part.clickHandler = null;
    if (hover) { this.part.mouseEnterHandler = null; this.part.mouseLeaveHandler = null; }
    this.isEnabled = false;
    this.enable = () => this.isEnabled = true;
    this.disable = () => this.isEnabled = false;
    this.elem.addEventListener('click', this._onClick.bind(this));
    this.elem.addEventListener('mouseenter', this._onMouseEnter.bind(this));
    this.elem.addEventListener('mouseleave', this._onMouseLeave.bind(this));
    return this;
  }
  enable() {
    this.isEnabled = true;
  }
  disable() {
    this.isEnabled = false;
  }
  high() {
    if (isdef(this.parts) && isdef(this.parts.title)) this.parts['title'].style.backgroundColor = '#ccff00';
    else {
      this.elem.classList.add('selected');
      this.elem.backgroundColor = '#ccff00';
    }
  }
  unhigh() {
    if (isdef(this.parts) && isdef(this.parts.title)) this.parts['title'].style.backgroundColor = this.titleColor;
    else {
      this.elem.classList.remove('selected');
      this.elem.backgroundColor = this.titleColor;
    }
  }
  sel() { }
  unsel() { }
  frame() { }
  unframe() { }
  setDefaults({ x, y, w, h, bg, fg } = {}) {
    if (this.parent.type == 'svg' && isdef(bg) && nundef(w) && nundef(h) && this.domType == 'g') {
      this.parent.setBg(bg);
    } else {
      if (isdef(bg) || this.cat == 'd') {
        bg = nundef(bg) ? 'transparent' : bg;
        this.setBg(bg);
        fg = nundef(fg) ? bg == 'transparent' ? this.parent.fg : colorIdealText(bg) : fg;
        this.setFg(fg);
      }
    }
    if (this.cat == 'd' && (nundef(this.x) || nundef(this.w))) return this;
    w = nundef(w) ? this.posRef.w : w;
    h = nundef(h) ? this.posRef.h : h;
    this.setSize(w, h);
    x = nundef(x) ? 0 : this.posRef.x + x;
    y = nundef(y) ? 0 : this.posRef.y + y;
    if (this.parent.cat == 'd') { this.parent.elem.style.position = 'absolute'; }
    this.setPos(x, y);
    return this;
  }
  setBg(c, updateFg = false) {
    this.bg = c;
    if (this.cat == 'g') {
      if (this.domType == 'text') {
        if (!this.textBackground) {
        }
      } else {
        this.elem.setAttribute('fill', c);
      }
    } else {
      this.elem.style.backgroundColor = c;
    }
    if (updateFg) {
      this.setFg(colorIdealText(c), true);
    }
    return this;
  }
  setFg(c) {
    this.fg = c;
    if (this.cat == 'g') {
      if (this.domType == 'text') {
        this.elem.setAttribute('fill', c);
      } else {
        this.elem.setAttribute('stroke', c);
      }
    } else {
      this.elem.style.color = c;
    }
    return this;
  }
  setFullSize() {
    this.setSize(this.posRef.w, this.posRef.h);
    this.setPos(0, 0);
  }
  setSize(w, h) {
    this.w = w; this.h = h;
    if (this.cat == 'g') {
      if (this.ground) {
        this.ground.setAttribute('width', w);
        this.ground.setAttribute('height', h);
      } else {
        this.elem.setAttribute('width', w);
        this.elem.setAttribute('height', h);
      }
      if (this.overlay) {
        this.overlay.setAttribute('width', w);
        this.overlay.setAttribute('height', h);
      }
    } else {
      this.elem.style.position = 'absolute';
      this.elem.style.width = w + 'px';
      this.elem.style.height = h + 'px';
    }
    return this;
  }
  setPos(x, y) {
    this.x = x;
    this.y = y;
    if (this.cat == 'g') {
      this.elem.setAttribute('transform', `translate(${x},${y})`);
    } else {
      this.elem.style.position = 'absolute'
      this.elem.style.left = x + 'px';
      this.elem.style.top = y + 'px';
    }
    return this;
  }
  center() {
    this.setPos(-this.w / 2, -this.h / 2)
  }
  centerOrigin() {
    this.setPos(this.w / 2, this.h / 2);
  }
  rect({ x = 0, y = 0, w = 50, h = 25, bg, fg } = {}) {
    let pa = this.domType == 'g' ? this._getRect(x, y, w, h, bg, fg) : this._getDiv(x, y, w, h, bg, fg);
    this.elem.appendChild(pa);
    this.attach();
    return this;
  }
  addBorder(c) {
    if (this.cat == 'd') {
      this.elem.style.border = '1px solid ' + c;
    }
  }
  removeBorder() {
    if (this.cat == 'd') {
      this.elem.style.border = null;
    }
  }
  selBlack() {
    if (this.isSelBlack) return;
    this.elem.classList.add('selBlack');
    this.isSelBlack = true;
  }
  unselBlack() {
    if (!this.isSelBlack) return;
    this.elem.classList.remove('selBlack');
    this.isSelBlack = false;
  }
  selRed() { }
  unselAll() { this.removeBorder(); }
  //#endregion
}
class NAssets {
  constructor() {
    this.tilePositions = {};
    this.tileNames;
    this.trackPositions = {};
    this.nationPositions = {};
    this.nationNames;
    this.unitCountInfo;
    this.nationalityNames;
    this.unitTypeNames;
    this.factionSetup;
    this.factionNames;
    this.uniqueIdCounter = 0;
    let neutralColor = [230, 230, 120];
    this.troopColors = {
      Germany: [174, 174, 176],
      Britain: [86, 182, 222],
      France: [121, 200, 205],
      USSR: [233, 138, 134],
      USA: [145, 186, 130],
      Italy: [174, 172, 131],
      Neutral: neutralColor,
      Minor: neutralColor,
      Major: neutralColor,
      Axis: [174, 174, 176],
      West: [86, 182, 222]
    };
    this.SZ = {
      tile: 180,
      pAxis: { x: 0, y: 50 },
      pWest: { x: -50, y: -30 },
      pUSSR: { x: +50, y: -30 },
      cadrePrototype: 60,
      sumCadre: 60,
      cadreDetail: 44,
      cardWidth: 100,
      cardHeight: 150,
      gap: 10,
      chip: 40,
      nation: 130,
      influence: 40
    };
    this.uid2id = {};
    this.id2uid = {};
    this.phaseNames = [
      "Setup",
      "New_Year",
      "Production",
      "Government",
      "Spring",
      "Summer",
      "Blockade",
      "Fall",
      "Winter",
      "Satellite",
      "Movement",
      "Combat",
      "Supply",
      "Retreat",
      "Land_Battle",
      "Sea_Battle",
      "Scoring"
    ];
  }
  distanceBetweenTiles(tilename1, tilename2) {
    let pos1 = this.tilePositions[tilename1];
    let pos2 = this.tilePositions[tilename2];
    return dSquare(pos1, pos2);
  }
  initAssets(map, callback) {
    this.calculateTrackPositions();
    loadYML("/a/assets/config/map_pos.yml", data => {
      this.tilePositions = {};
      for (const idTile in data) {
        let id = replaceAll(idTile, " ", "_");
        this.tilePositions[id] = data[idTile];
      }
      this.tileNames = Object.keys(this.tilePositions);
      loadYML("/a/assets/config/nations.yml", data => {
        this.nationPositions = {};
        for (const idNation in data) {
          let id = replaceAll(idNation, " ", "_");
          this.nationPositions[id] = data[idNation];
        }
        this.nationNames = Object.keys(this.nationPositions);
        loadYML("/a/assets/config/unit_count.yml", data => {
          this.unitCountInfo = data;
          this.nationalityNames = Object.keys(data);
          this.unitTypeNames = Object.keys(data["Germany"]);
          loadYML("/a/assets/config/faction_setup.yml", data => {
            this.factionSetup = data;
            this.factionNames = Object.keys(data);
            callback();
          });
        });
      });
    });
  }
  calculateTrackPositions() {
    let arr = [];
    let x = 580;
    let y = 2120;
    for (let i = 0; i < 25; i++) {
      arr.push({ x: x, y: y });
      x += 66;
    }
    this.trackPositions.Axis = arr;
    arr = [];
    x = 1310;
    y = 76;
    for (let i = 0; i < 20; i++) {
      arr.push({ x: x, y: y });
      x -= 66;
    }
    for (let i = 20; i < 25; i++) {
      arr.push({ x: x, y: y });
      y += 66;
    }
    this.trackPositions.West = arr;
    arr = [];
    x = 2210;
    y = 76;
    for (let i = 0; i < 18; i++) {
      arr.push({ x: x, y: y });
      x += 66;
    }
    for (let i = 18; i < 25; i++) {
      arr.push({ x: x, y: y });
      y += 66;
    }
    this.trackPositions.USSR = arr;
  }
  clear() {
    this.uid2id = {};
    this.id2uid = {};
    this.uniqueIdCounter = 0;
  }
  drawNationPositions() {
    unitTestFilterNation('drawNationPositions starting');
    let nationDict = {};
    for (const id in this.nationPositions) {
      let pos = this.nationPositions[id];
      let sz = this.SZ.nation;
      let ms = new MS(id, "mapG", this.getUniqueId(id))
        .circle({ className: "overlay nation", sz: sz })
        .setPos(pos.x, pos.y)
        .draw();
      nationDict[id] = ms;
    }
    unitTestFilterNation(nationDict);
    return nationDict;
  }
  getUniqueId(id) {
    let uid = this.uniqueIdCounter + "_" + id;
    this.uniqueIdCounter += 1;
    this.uid2id[uid] = id;
    this.id2uid[id] = uid;
    return uid;
  }
}
class NDataProcessor {
  constructor(backendUrl) {
    this.callback = null;
    this.serverData = null;
    this.player = "";
    this.tuplesInAction = [];
    this.gameObjects = {};
    this.backendUrl = backendUrl;
    this.msgCounter = 0;
    this.sender = new NBackendCommunicator("http://localhost:5000/");
  }
  action(player, tuple, callback) {
    this.player = player;
    this.callback = callback;
    this.sender.send("action/" + this.player + "/" + tuple.join("+"), this.actionStep1.bind(this));
  }
  actionStep1(data) {
    this.serverData = data;
    this.sender.send("info/" + this.player, this.actionStep2.bind(this));
  }
  actionStep2(data) {
    this.augmentServerData(data, 2);
    if ("waiting_for" in this.serverData) {
      let plNext = this.serverData.waiting_for.set[0];
      this.serverData.game.playerChangedTo = plNext;
      this.sender.send("status/" + plNext, this.actionStep3.bind(this));
    } else {
      this.processServerData();
    }
  }
  actionStep3(data) {
    this.augmentServerData(data, 3);
    this.processServerData();
  }
  augmentServerData(data, step) {
    jQuery.extend(true, this.serverData, data);
  }
  initGame(player, callback) {
    this.callback = callback;
    this.player = player;
    this.sender.send("init/hotseat/" + player, this.actionStep1.bind(this));
  }
  loadGame(player, filename, callback) {
    this.callback = callback;
    this.filename = filename;
    this.player = player;
    this.sender.send("myload/" + this.filename + '.json', this.loadStep3.bind(this), this.player);
  }
  loadStep1(data) {
    this.serverData = data;
    this.sender.send("myload/" + this.filename + '.json', this.loadStep2.bind(this), this.player);
  }
  loadStep2(data) {
    if (!this.serverData) this.serverData = {}
    this.serverData.created = data;
    this.sender.send("info/" + this.player, this.actionStep2.bind(this));
  }
  loadStep3(data) {
    if (!this.serverData) this.serverData = {}
    this.serverData.created = data;
    this.sender.send("info/" + this.player, this.loadStep4.bind(this));
  }
  loadStep4(data) {
    this.augmentServerData(data, 3);
    this.sender.send("status/" + this.player, this.loadStep5.bind(this));
  }
  loadStep5(data) {
    this.augmentServerData(data, 3);
  }
  processActions() {
    let data = this.serverData;
    if (!"actions" in data) {
      this.tuplesInAction = [];
    } else {
      let tuples = expand(data.actions);
      if (!empty(tuples) && tuples.length == 1 && !Array.isArray(tuples[0])) {
        tuples = [tuples];
      }
      this.tuplesInAction = tuples;
    }
  }
  processLog() {
    if ("log" in this.serverData) {
      this.serverData.log = toHTMLString(this.serverData.log);
    }
  }
  processGameObjects() {
    let data = this.serverData;
    let g = {};
    if ("created" in data) {
      for (const id in data.created) {
        let sid = id.toString();
        g[sid] = data.created[id];
      }
    }
    if ("updated" in data) {
      for (const id in data.updated) {
        let sid = id.toString();
        g[sid] = data.updated[id];
      }
    }
    this.gameObjects = g;
    return;
  }
  processMessage(jsonData, callback = null) {
    this.serverData = jsonData;
    processLog();
    if (callback) callback(this.serverData);
  }
  processServerData() {
    this.processLog();
    this.processGameObjects();
    this.serverData.game.player = this.player;
    this.processActions();
    this.callback(this.tuplesInAction, this.gameObjects, this.serverData.game, this.serverData);
  }
}
class nn1 {
  constructor() {
    this.l1Size = 2;
    this.l2Size = 3;
    this.l3Size = 1;
  }
}
class NPage {
  constructor() {
    this.view = null;
  }
  clearAllObjects() {
    clearElementFromChildIndex(document.getElementById("mapG"), 1);
    clearElementFromChildIndex(document.getElementById("handG_West"), 1);
    clearElementFromChildIndex(document.getElementById("handG_Axis"), 1);
    clearElementFromChildIndex(document.getElementById("handG_USSR"), 1);
    clearElementFromChildIndex(document.getElementById("openCardG"), 1);
    clearElement(document.getElementById("divSelect"));
    clearElement(this.battle_area);
  }
  selectView() {
    if (this.view == 'select') return;
    this.view = 'select';
    hide(this.battle_area);
    show(this.status_area);
    show(this.edit_area);
    show(this.command_area);
    show(this.command2_area);
    show(this.map_area);
    show(this.log_area);
    show(this.hand_area);
    show(this.cards2_area);
    hideSvg(this.actionDeckG);
    showSvg(this.openCardG);
    hide(this.cards3_area);
    hideSvg(this.investmentDeckG);
    showSvg(this.discardedG);
    this.mainDiv.className = "grid_game_may";
    return this;
  }
  battleView() {
    if (this.view == 'battle') return;
    this.view = 'battle';
    show(this.battle_area);
    show(this.status_area);
    show(this.edit_area);
    show(this.command_area);
    show(this.command2_area);
    show(this.map_area);
    show(this.log_area);
    show(this.hand_area);
    hide(this.cards2_area);
    hideSvg(this.actionDeckG);
    hideSvg(this.openCardG);
    hide(this.cards3_area);
    hideSvg(this.investmentDeckG);
    hideSvg(this.discardedG);
    this.mainDiv.className = "grid_game_battle";
    return this;
  }
  initView() {
    this.mainDiv = document.getElementById("mainDiv");
    this.status_area = document.getElementById("status_area");
    this.edit_area = document.getElementById("edit_area");
    this.map_area = document.getElementById("map_area");
    this.log_area = document.getElementById("log_area");
    this.command_area = document.getElementById("command_area");
    this.command2_area = document.getElementById("command2_area");
    this.hand_area = document.getElementById("hand_area");
    this.battle_area = document.getElementById("battle_area");
    this.cards2_area = document.getElementById("cards2_area");
    this.cards3_area = document.getElementById("cards3_area");
    this.openCardG = document.getElementById("openCardG");
    this.actionDeckG = document.getElementById("actionDeckG");
    this.discardedG = document.getElementById("discardedG");
    this.investmentDeckG = document.getElementById("investmentDeckG");
    return this;
  }
}
class NSettings {
  constructor() {
  }
}
class Peep {
  constructor({
    image,
    rect,
  }) {
    this.image = image
    this.setRect(rect)
    this.x = 0
    this.y = 0
    this.anchorY = 0
    this.scaleX = 1
    this.walk = null
  }
  setRect(rect) {
    this.rect = rect
    this.width = rect[2]
    this.height = rect[3]
    this.drawArgs = [
      this.image,
      ...rect,
      0, 0, this.width, this.height
    ]
  }
  render(ctx) {
    ctx.save()
    ctx.translate(this.x, this.y)
    ctx.scale(this.scaleX, 1)
    ctx.drawImage(...this.drawArgs)
    ctx.restore()
  }
}
class Player {
  constructor(id, color) {
    this.id = id;
    this.color = getColorDictColor(color);
  }
}
class Recorder {
  constructor(lang) {
    let rec = this.rec = new webkitSpeechRecognition();
    rec.continuous = true;
    rec.interimResults = true;
    rec.maxAlternatives = 5;
    this.setLanguage(lang);
    this.isRunning = false;
    this.isCancelled = false;
    this.result = null;
    this.isFinal = null;
    this.confidence = null;
    this.callback = null;
    let genHandler = (ev, name) => {
      console.log('genHandler', name)
      if (RecogOutput) console.log('recorder', name, 'isCancelled', this.isCancelled, 'isRunning', this.isRunning);
    }
    rec.onerror = ev => {
      genHandler(ev, 'error');
      if (ev.error == 'network') {
        alert('no internet connection: speech recognition is not available! (error:' + ev.error + ')');
        RecognitionAvailable = false;
      }
      if (RecogOutputError) console.error(ev);
      this.stop();
    };
    rec.onstart = ev => {
      genHandler(ev, 'started');
      if (!this.isCancelled) this.isRunning = true;
    };
    rec.onresult = ev => {
      genHandler(ev, 'result!');
      if (!this.isCancelled) this.processResult(ev);
    };
    rec.onend = ev => {
      genHandler(ev, 'ended');
      if (!this.isCancelled && this.callback) {
        this.callback(this.isFinal, this.result, this.confidence, SessionId);
      }
      this.isCancelled = this.isRunning = false;
      this.callback = null;
    };
  }
  processResult(ev) {
    let res = ev.results[0];
    this.isFinal = res.isFinal;
    this.result = res[0].transcript;
    this.confidence = res[0].confidence;
    if (this.isFinal) console.log('....result', this.result, 'FINAL?', this.isFinal)
    if (this.isFinal) {
      this.stop();
    }
  }
  setLanguage(lang) { this.rec.lang = (lang == 'E' ? 'en-US' : 'de-DE'); }
  start() {
    MicrophoneShow();
    setTimeout(() => this.rec.start(), 10);
  }
  stop() {
    MicrophoneHide();
    setTimeout(() => this.rec.stop(), 10);
  }
  getLastResult() {
    return { isFinal: this.isFinal, result: this.result, confidence: this.confidence };
  }
}
class RSG {
  constructor() {
    this.nodes = {};
    this.uiNodes = {};
    this.isUiActive = false;
    this.uid2oids = {};
    this.oid2uids = {};
    this.path2oid = {};
  }
  add_node(n, oid) {
    this.nodes[oid] = n;
    if (isEmpty(n.path)) this.root = n;
    if (isList(n.content) && n.content.length == 0) {
      n.type = 'empty_list';
    }
    this.path2oid[n.path] = n.oid;
    console.assert(nundef(Items[n.path]), 'duplicate path in Items!!! ' + n.path);
    console.assert(nundef(Items[oid]), 'duplicate oid in Items!!! ' + oid);
    Items[n.oid] = Items[n.path] = n;
  }
  add_ui_node(ui, uid, oid) {
    this.uiNodes[uid] = ui;
    lookupAddIfToList(this.uid2oids, [uid], oid);
    lookupAddIfToList(this.oid2uids, [oid], uid);
    if (Items[oid].type != 'card') console.assert(nundef(Items[uid]), 'duplicate uid in Items!!! ' + uid);
    Items[uid] = ui;
    let o = Items[oid];
    ui.setAttribute('oid', oid);
    iAdd(o, { div: ui });
  }
  getUI(uid) { return this.uiNodes[uid]; }
  get_item_from_path(path) { return Items[path]; }
  get_item(id) {
    if (id[0] == '_') {
      let oid = Items[id].getAttribute('oid');
      return Items[oid];
    } else return Items[id];
  }
}
class Scenario {
  constructor(assets, data, G, decider) {
    this.decider = decider;
    this.data = data;
    this.assets = assets;
    this.done = false;
    this.player = null;
    this.phase = null;
    this.items = {};
    this.openRequest = {};
    this.lockedIds = {};
    this.missingUnitItems = {};
    this.wrongLocationItems = {};
    this.cvTooLowItems = {};
    this.perfectItems = {};
    this.initUnitItems(G);
    this.conflictItems = [];
    this.newConflict = null;
    this.openDeclaration = null;
    this.atWar = false;
    this.initConflictItems(G);
    this.diplItems = {};
    this.diplItemsTodo = {};
    this.openDiplRequest = {};
    this.satellites = {};
    this.diplDone = false;
    this.updateDiplomacy(G);
    unitTestConflict('conflicts:', this.conflictItems);
  }
  initConflictItems(G) {
    if ('conflicts' in this.data) {
      for (const tile in this.data.conflicts) {
        let aggressor = this.data.conflicts[tile][0];
        let defender = this.data.conflicts[tile][1];
        let cItem = {};
        cItem.tile = tile;
        cItem.aggressor = aggressor;
        cItem.defender = defender;
        cItem.stage = null;
        this.conflictItems.push(cItem);
      }
    }
  }
  initDiplItems_dep(G) {
    for (const pl in this.data) {
      if (!lookup(this.data, [pl, 'diplomacy'])) {
        continue;
      }
      for (const nation in this.data[pl].diplomacy) {
        addIf_depKeys(this.diplItemsTodo, [pl, nation], 0);
      }
    }
    for (const id in G.objects) {
      let o = G.objects[id];
      if (o.obj_type != 'influence') continue;
    }
  }
  initUnitItems(G) {
    for (const pl in this.data) {
      if (!lookup(this.data, [pl, 'units'])) {
        continue;
      }
      for (const tile in this.data[pl].units) {
        for (const type in this.data[pl].units[tile]) {
          for (const cv of this.data[pl].units[tile][type]) {
            let items = addIf_depKeys(this.items, [pl], []);
            items.push({
              owner: pl,
              goalTile: tile,
              type: type,
              goalCv: cv,
              tile: null,
              id: null,
              unit: null
            });
          }
        }
      }
    }
    unitTestMatch('items:', this.items);
    let availableUnits = matchUnits(G.objects, 'all');
    for (const pl in this.items) {
      let playerUnits = matchUnits(availableUnits, 'all', pl);
      unitTestMatch('player units', playerUnits);
      for (const item of this.items[pl]) {
        let m = this.findBestMatchingUnit(playerUnits, item);
        if (m) {
          item.id = m.id;
          item.unit = m;
          item.cv = m.cv;
          item.tile = m.tile;
          this.lockedIds[m.id] = item;
          removeInPlace(playerUnits, m);
        }
      }
    }
  }
  activateConflict(G) {
    if (this.newConflict) {
      unitTestScenarioWar('conflict already activated', this.newConflict);
      return;
    }
    let cNext = firstCond(this.conflictItems, x => !x.stage && x.aggressor == G.player);
    if (cNext) {
      unitTestScenarioWar('activateConflict!!!!!!!!!!!!!! found conflict in stage null');
      cNext.stage = 'tbd';
      this.newConflict = cNext;
      unitTestConflict('activateConflict: found', cNext);
    } else {
      unitTestConflict('activateConflict: no new conflict found for', G.player);
    }
  }
  updateDiplomacy(G) {
    this.diplItems = {};
    this.diplItemsTodo = {};
    for (const pl in this.data) {
      if (!lookup(this.data, [pl, 'diplomacy'])) {
        continue;
      }
      for (const nation in this.data[pl].diplomacy) {
        let sat = lookup(this.satellites, [nation]);
        if (sat == pl) continue;
        addIf_depKeys(this.diplItemsTodo, [pl, nation], this.data[pl].diplomacy[nation]);
      }
    }
    unitTestDiplomacy('vor G check:', this.diplItemsTodo);
    let created = lookup(G.serverData, ['created']);
    let removed = lookup(G.serverData, ['removed']);
    let newCreated = !empty(created);
    let newRemoved = !empty(removed);
    for (const id in G.objects) {
      let o = G.objects[id];
      if (o.obj_type == 'influence') {
        addIf_depKeys(this.diplItems, [o.faction, o.nation], o.value);
        let req = lookup(this.data, [o.faction, 'diplomacy', o.nation]);
        unitTestDiplomacy('req for', o.nation, 'is', req, ' o.value is', o.value);
        if (req && req > o.value) {
          let lst = addIf_depKeys(this.diplItemsTodo, [o.faction], {});
          lst[o.nation] = req;
        } else if (req && req <= o.value) {
          delete this.diplItemsTodo[o.faction][o.nation];
          if (empty(this.diplItemsTodo[o.faction])) {
            delete this.diplItemsTodo[o.faction];
          }
        }
      }
    }
    this.diplDone = empty(this.diplItemsTodo);
    unitTestDiplomacy('checkDiplomacy:');
    unitTestDiplomacy('G', G);
    unitTestDiplomacy(this.diplItems, this.diplItemsTodo, this.diplDone);
    return;
    if (newRemoved && newCreated) {
      let lCreated = dict2list(created, 'id');
      for (const id in removed) {
        if (removed[id].obj_type != 'influence') continue;
        let v = removed[id].value;
        if (v >= 3) {
          let o = removed[id];
          let nation = o.nation;
          let faction = o.faction;
          let matchingTile = firstCond(lCreated, x => x.obj_type == 'tile' && x.alligence == nation);
          if (matchingTile) {
            if (matchingTile.owner != faction) {
              unitTestDiplomacy('RIESEN PROBLEM!!!! INCONSISTENT SATELLITE!!!!');
            }
            this.satellites[nation] = faction;
            let todoItem = lookup(this.diplItemsTodo, [faction, nation]);
            if (todoItem) {
              delete this.diplItemsTodo[faction][nation];
              if (empty(this.diplItemsTodo[faction])) {
                delete this.diplItemsTodo[faction];
              }
            }
            unitTestDiplomacy(nation, 'became satellite!');
          }
        }
      }
    }
    this.diplDone = empty(this.diplItemsTodo);
    unitTestDiplomacy('checkDiplomacy:');
    unitTestDiplomacy('G', G);
    unitTestDiplomacy(this.diplItems, this.diplItemsTodo, this.diplDone);
  }
  checkOpenItems() {
    let done = true;
    this.missingUnitItems = {};
    this.wrongLocationItems = {};
    this.cvTooLowItems = {};
    this.perfectItems = {};
    for (const pl in this.items) {
      for (const item of this.items[pl]) {
        if (!item.unit) {
          done = false;
          let l = addIf_depKeys(this.missingUnitItems, [pl], []);
          l.push(item);
        } else if (item.unit.cv < item.goalCv) {
          done = false;
          let l = addIf_depKeys(this.cvTooLowItems, [pl], []);
          l.push(item);
        } else if (item.goalTile != item.tile) {
          done = false;
          let l = addIf_depKeys(this.wrongLocationItems, [pl], []);
          l.push(item);
        } else {
          let l = addIf_depKeys(this.perfectItems, [pl], []);
          l.push(item);
        }
      }
    }
    if (this.data.options.done == 'diplomacy') {
      done = done && this.diplDone;
    }
    return done;
  }
  checkOpenUnitRequest(G, pl, created, removed) {
    let openReq = lookup(this.openRequest, [pl]);
    if (!openReq) return;
    removeInPlaceKeys(created, Object.keys(this.lockedIds));
    let id = openReq.id;
    let u = id ? G.objects[id] : matchUnits(created, 'first', pl, openReq.tile, openReq.type);
    if (u) {
      openReq.id = id ? id : u.id;
      openReq.unit = u;
      openReq.tile = u.tile;
      delete this.openRequest[pl];
      unitTestMatch('checkOpenRequest: ITEM UPDATED!');
    }
  }
  checkOpenDiplomacyRequest(G, pl, created, removed) {
    let newCreated = !empty(created);
    if (!newCreated) return;
    let newRemoved = !empty(removed);
    let openDiplReq = lookup(this.openDiplRequest, [pl]);
    if (!openDiplReq) return;
    unitTestDiplomacy('check if influences have changed:\ncreated:', created);
    let influencesChanged = false;
    for (const id in created) {
      let o = created[id];
      if (o.obj_type == 'influence') {
        influencesChanged = true;
        break;
      }
    }
    if (!influencesChanged && newRemoved) {
      for (const id in removed) {
        let o = removed[id];
        if (o.obj_type == 'influence') {
          influencesChanged = true;
          break;
        }
      }
    }
    if (influencesChanged) {
      unitTestDiplomacy('YES!');
      this.updateDiplomacy(G);
      delete this.openDiplRequest[pl];
    }
  }
  checkOpenDeclarationRequest(G, pl) {
    let openDecl = this.openDeclaration;
    unitTestScenarioWar('checkOpenDeclarationRequest openDecl', openDecl);
    if (!openDecl) return;
    alert('OPEN WAR DECLARATION!!!')
    let item = firstCond(this.conflictItems, x => x.tile == this.openDeclaration.tile);
    unitTestScenarioWar('SETTING DECLARED: vorher:', jsCopy(item));
    openDecl.stage = 'declared';
    unitTestScenarioWar('nachher:', jsCopy(item));
    this.atWar = true;
    this.openDeclaration = null;
    unitTestScenarioWar('end of checkOpenDeclarationRequest', this.openDeclaration);
  }
  checkOpenRequest(G) {
    let pl = G.player;
    let created = lookup(G.serverData, ['created']);
    let removed = lookup(G.serverData, ['removed']);
    if (empty(created)) {
      unitTestMatch('checkOpenRequest: NO CHANGES IN DATA (no created!)!');
    } else {
      this.checkOpenUnitRequest(G, pl, jsCopy(created), removed);
      this.checkOpenDiplomacyRequest(G, pl, created, removed);
    }
    this.checkOpenDeclarationRequest(G, pl);
  }
  defaultSetup(G) {
    let tuple = null;
    let fav_types = lookup(this.data.options, ['unit_types']);
    let type = fav_types ? chooseRandom(fav_types) : chooseRandom(this.assets.unitTypeNames);
    tuple = firstCond(G.tuples, x => x.includes(type));
    return tuple;
  }
  defaultSatellite(G) {
    let tuple = null;
    let fav_unit_type = lookup(this.data.options, ['garrison_type']);
    if (!fav_unit_type) fav_unit_type = 'Infantry';
    tuple = firstCond(G.tuples, x => x.includes(fav_unit_type));
    if (!tuple) {
      tuple = firstCond(G.tuples, x => x.includes('Tank'));
    }
    return tuple;
  }
  defaultProduction(G) {
    let tuple = null;
    if (this.data.options.priority == 'movement' || this.data.options.priority == 'diplomacy') {
      tuple = firstCond(G.tuples, x => x.includes('action_card'));
    }
    return tuple;
  }
  defaultGovernment(G) {
    let tuple = null;
    if (this.data.options.priority == 'movement') {
      tuple = firstCond(G.tuples, x => x.includes('pass'));
      if (!tuple) {
        tuple = firstCond(G.tuples, x => x.includes('accept'));
        if (!tuple) {
          tuple = firstCond(G.tuples, x => x.length == 1 && startsWith(x[0], 'action'));
        }
      }
    }
    return tuple;
  }
  defaultMovement(G) {
    let tuple = null;
    if (this.data.options.priority == 'movement') {
      tuple = firstCond(G.tuples, x => x.includes('pass'));
    }
    return tuple;
  }
  findBestMatchingUnit(playerUnits, item) {
    let m = matchUnits(playerUnits, 'first', null, item.goalTile, item.type, item.cv);
    if (!m) {
      m = matchUnits(playerUnits, 'first', null, item.goalTile, item.type);
      if (!m) {
        let mEveryWhere = matchUnits(playerUnits, 'all', null, null, item.type);
        if (mEveryWhere.length > 0) {
          unitTestMatch('partial matches:', mEveryWhere, 'for item', item);
          m = findClosestUnit((a, b) => this.assets.distanceBetweenTiles(a, b), item.goalTile, mEveryWhere);
        } else {
          unitTestMatch('NO MATCH for item', item);
        }
      } else {
        unitTestMatch('correctly located match:', m, 'for item', item);
      }
    } else {
      unitTestMatch('exact match:', m, 'for item', item);
    }
    return m;
  }
  tryBuildUnit(G) {
    let items = lookup(this.missingUnitItems, [G.player]);
    if (!items) return null;
    for (const item of items) {
      let m = firstCond(G.tuples, t => t.includes(item.type) && t.includes(item.goalTile));
      if (m) {
        this.openRequest[G.player] = item;
        return m;
      }
    }
    for (const item of items) {
      if (item.id) continue;
      let mTuples = G.tuples.filter(t => t.includes(item.type));
      if (mTuples.length > 0) {
        let tilenames = filterStringFromTuples(this.assets.tileNames, mTuples);
        let m = findClosestTile((a, b) => this.assets.distanceBetweenTiles(a, b), item.goalTile, tilenames);
        if (m) {
          this.openRequest[G.player] = item;
          return firstCond(mTuples, t => t.includes(m));
        }
      }
    }
    return null;
  }
  tryDeclaration(G) {
    unitTestScenarioWar('tryDeclaration newConflict:', this.newConflict);
    if (this.newConflict) {
      let c = this.newConflict;
      let t = firstCond(G.tuples, x => x.length == 1 && x[0] == c.defender);
      if (t) {
        if (this.assets.factionNames.includes(c.defender)) {
          unitTestScenarioMin(G.player, 'is declaring war on', c.defender);
        } else {
          unitTestScenarioMin(G.player, 'is violating neutrality of', c.defender);
        }
        this.openDeclaration = c;
        this.newConflict = null;
        return t;
      }
    }
    return null;
  }
  tryWarMovement(G) {
    unitTestScenarioWar('tryWarMovement');
    let goal = firstCond(this.conflictItems, x => x.stage == 'declared');
    if (!goal) {
      return this.tryMoveUnit(G);
    }
    let tile = goal.tile;
    let t = firstCond(G.tuples, x => x.length >= 2 && x[1] == tile);
    if (!t) {
      unitTestScenarioWar('cannot move more units to', tile, '!');
      return this.tryMoveUnit(G);
    }
    let id = t[0];
    if (id in this.lockedIds) {
      let item = this.lockedIds[id];
      this.openRequest[G.player] = item;
      unitTestScenarioWar('locked unit', item, 'moved to', tile)
    } else {
      unitTestScenarioWar('free unit:', id, 'moved to', tile);
    }
    return t;
  }
  tryDiplomacy(G) {
    let diplReqs = lookup(this.diplItemsTodo, [G.player]);
    if (diplReqs) {
      let t = firstCond(G.tuples, x => x.length == 2 && startsWith(x[0], 'action_') && x[1] in diplReqs);
      unitTestDiplomacy('tuple found:', t);
      if (t) {
        let lst = addIf_depKeys(this.openDiplRequest, [G.player], []);
        lst.push(t[1]);
      }
      return t;
    }
    return null;
  }
  tryMoveUnit(G) {
    let items = lookup(this.wrongLocationItems, [G.player]);
    if (!items) return null;
    for (const item of items) {
      let tuple = firstCond(G.tuples, t => t.length > 1 && t[0] == item.id && t[1] == item.goalTile);
      if (!tuple) tuple = findClosestTupleForItem(G.tuples, item, this.assets);
      if (!tuple) continue;
      this.openRequest[G.player] = item;
      return tuple;
    }
    return null;
  }
  trySeasonCard(G) {
    let tuple = null;
    let actionTuples = G.tuples.filter(x => startsWith(x[0], 'action'));
    if (empty(actionTuples)) return null;
    let actionCards = actionTuples.map(x => x[0]);
    let cards = actionCards.map(x => [x, G.objects[x]]);
    let seasonCards = cards.filter(x => 'season' in x[1] && x[1].season == G.phase);
    if (empty(seasonCards)) {
      tuple = actionTuples[0];
      unitTestMatch(G.player, 'playing emergency card!!!');
    } else {
      tuple = firstCond(actionTuples, x => x.includes(seasonCards[0][0]));
    }
    return tuple;
  }
  tryUpgradeUnit(G) {
    let items = lookup(this.cvTooLowItems, [G.player]);
    if (!items) return null;
    for (const item of items) {
      let m = firstCond(G.tuples, t => t.length == 1 && t.includes(item.id));
      if (m) {
        this.openRequest[G.player] = item;
        return m;
      }
    }
    return null;
  }
  findMatch(G) {
    unitTestScenario('______________________findMatch');
    let isNewRound = this.player != G.player || this.phase != G.phase;
    if (isNewRound) {
      for (const ci of this.conflictItems) {
        if (ci.stage == 'declared') {
          ci.stage = 'active';
        }
      }
      if (this.done && 'after_wars_mode' in this.data.options) {
        if (!any(this.conflictItems, x => x.stage != 'active')) {
          this.decider.decisionMode = this.data.options.after_wars_mode;
        }
      }
      this.atWar = false;
    }
    this.player = G.player;
    this.phase = G.phase;
    this.checkOpenRequest(G);
    this.done = this.checkOpenItems(G);
    if (this.done) {
      unitTestScenario('Scenario is complete!!!');
      if (isNewRound && this.phase == 'Movement') {
        this.activateConflict(G);
      }
    }
    let tuple = null;
    if (G.phase == 'Setup') {
      if (!tuple) tuple = this.tryBuildUnit(G);
      if (!tuple) tuple = this.defaultSetup(G);
    }
    if (G.phase == 'Production') {
      if (!tuple) tuple = this.tryUpgradeUnit(G);
      if (!tuple) tuple = this.tryBuildUnit(G);
      if (!tuple) tuple = this.defaultProduction(G);
    }
    if (G.phase == 'Government') {
      if (!tuple) tuple = this.tryDiplomacy(G);
      if (!tuple) tuple = this.defaultGovernment(G);
    }
    if (G.phase == 'Satellite') {
      if (!tuple) tuple = this.defaultSatellite(G);
    }
    if (['Spring', 'Summer', 'Fall', 'Winter'].includes(G.phase)) {
      if (!tuple) tuple = this.trySeasonCard(G);
    }
    if (G.phase == 'Movement') {
      if (!tuple) tuple = this.tryDeclaration(G);
      if (!tuple) tuple = this.atWar ? this.tryWarMovement(G) : this.tryMoveUnit(G);
      if (!tuple) tuple = this.defaultMovement(G);
    }
    if (G.phase.includes('Battle')) {
      tuple = firstCond(G.tuples, t => t[0].length == 1);
    }
    unitTestScenario('\t>>>', G.phase, G.player, tuple);
    unitTestScenarioMin('findmatch:', G.phase, G.player, tuple, this.done ? '(completed!)' : '...');
    return tuple;
  }
}
class ScriptLoader {
  constructor(options) {
    this.protocol = document.location.protocol;
    this.global = 'Segment';
    this.isLoaded = false;
  }
  loadScript() {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.type = 'text/javascript';
      script.async = true;
      script.src = `${this.protocol}/` + `/${this.src}`;
      const el = document.getElementsByTagName('script')[0];
      el.parentNode.insertBefore(script, el);
      script.addEventListener('load', () => {
        this.isLoaded = true;
        resolve(script);
      })
      script.addEventListener('error', () => {
        reject(new Error(`${this.src} failed to load.`));
      })
    })
  }
  load(src) {
    if (startsWith(src, 'http')) src = stringAfter(src, '://');
    this.src = src;
    return new Promise(async (resolve, reject) => {
      if (!this.isLoaded) {
        try {
          await this.loadScript();
          resolve(window[this.global]);
        } catch (e) {
          reject(e);
        }
      } else {
        resolve(window[this.global]);
      }
    })
  }
}
class SettingsClass {
  constructor(settingsObject, userObject, dParent) {
    this.o = settingsObject;
    this.u = userObject;
    this.dParent = dParent;
  }
  //#region settings ui
  createSettingsUi(dParent) {
    dParent = valf(dParent, this.dParent);
    clearElement(dParent);
    this.list = [];
    let ttag = 'h2';
    mAppend(dParent, createElementFromHTML(`<${ttag}>Settings for ${this.u.id}:</${ttag}>`));
    let nGroupNumCommonAllGames = this.mInputGroup(dParent);
    this.setzeEineZahl(nGroupNumCommonAllGames, 'samples', 25, ['samplesPerGame']);
    this.setzeEineZahl(nGroupNumCommonAllGames, 'minutes', 1, ['minutesPerUnit']);
    this.setzeEineZahl(nGroupNumCommonAllGames, 'correct streak', 5, ['incrementLevelOnPositiveStreak']);
    this.setzeEineZahl(nGroupNumCommonAllGames, 'fail streak', 2, ['decrementLevelOnNegativeStreak']);
    this.setzeEinOptions(nGroupNumCommonAllGames, 'show labels', ['toggle', 'always', 'never'], ['toggle', 'always', 'never'], 'toggle', ['pictureLabels']);
    this.setzeEinOptions(nGroupNumCommonAllGames, 'language', ['E', 'D', 'S', 'F', 'C'], ['English', 'German', 'Spanish', 'French', 'Chinese'], 'E', ['language']);
    this.setzeEinOptions(nGroupNumCommonAllGames, 'vocabulary', Object.keys(KeySets), Object.keys(KeySets), 'best25', ['vocab']);
    this.setzeEineCheckbox(nGroupNumCommonAllGames, 'show time', false, ['showTime']);
    this.setzeEineCheckbox(nGroupNumCommonAllGames, 'spoken feedback', true, ['spokenFeedback']);
    this.setzeEineCheckbox(nGroupNumCommonAllGames, 'silent', false, ['silentMode']);
    this.setzeEineCheckbox(nGroupNumCommonAllGames, 'switch game after level', false, ['switchGame']);
    this.setzeEineZahl(nGroupNumCommonAllGames, 'trials', 3, ['trials']);
    this.setzeEineCheckbox(nGroupNumCommonAllGames, 'show hint', true, ['showHint']);
  }
  setSettingsKeys(elem) {
    let val = elem.type == 'number' ? Number(elem.value) : elem.type == 'checkbox' ? elem.checked : elem.value;
    lookupSetOverride(this.o, elem.keyList, val);
    this.hasChanged = true;
  }
  setSettingsKeysSelect(elem) {
    let val;
    for (const opt of elem.children) {
      if (opt.selected) val = opt.value;
    }
    this.hasChanged = true;
    lookupSetOverride(this.o, elem.keyList, val);
  }
  setzeEineZahl(dParent, label, init, skeys) {
    let d = mDiv(dParent);
    let val = lookup(this.o, skeys);
    if (nundef(val)) val = init;
    let inp = createElementFromHTML(
      `<input type="number" class="input" value="${val}" onfocusout="Settings.setSettingsKeys(this)" />`);
    let labelui = createElementFromHTML(`<label>${label}</label>`);
    mAppend(d, labelui);
    mAppend(labelui, inp);
    mStyleX(inp, { maleft: 12, mabottom: 4 });
    mClass(inp, 'input');
    inp.keyList = skeys;
    this.addSetting(skeys[0]);
  }
  setzeEineCheckbox(dParent, label, init, skeys) {
    let d = mDiv(dParent);
    let val = lookup(this.o, skeys);
    if (nundef(val)) val = init;
    let inp = createElementFromHTML(
      `<input type="checkbox" class="checkbox" ` + (val === true ? 'checked=true' : '') + ` onfocusout="Settings.setSettingsKeys(this)" >`
    );
    let labelui = createElementFromHTML(`<label>${label}</label>`);
    mAppend(d, labelui);
    mAppend(labelui, inp);
    mStyleX(inp, { maleft: 12, mabottom: 4 });
    mClass(inp, 'input');
    inp.keyList = skeys;
    this.addSetting(skeys[0]);
  }
  setzeEinOptions(dParent, label, optionList, friendlyList, init, skeys) {
    let d = mDiv(dParent);
    let val = lookup(this.o, skeys);
    if (nundef(val)) val = init;
    let inp = createElementFromHTML(`<select class="options" onfocusout="Settings.setSettingsKeysSelect(this)"></select>`);
    for (let i = 0; i < optionList.length; i++) {
      let opt = optionList[i];
      let friendly = friendlyList[i];
      let optElem = createElementFromHTML(`<option value="${opt}">${friendly}</option>`);
      mAppend(inp, optElem);
      if (opt == val) optElem.selected = true;
    }
    let labelui = createElementFromHTML(`<label>${label}</label>`);
    mAppend(d, labelui);
    mAppend(labelui, inp);
    mStyleX(inp, { maleft: 12, mabottom: 4 });
    inp.keyList = skeys;
    this.addSetting(skeys[0]);
  }
  //#endregion
  //#region helpers 
  mInputGroup(dParent, styles) {
    let baseStyles = { display: 'inline-block', align: 'right', bg: '#00000080', rounding: 10, padding: 20, margin: 12 };
    if (isdef(styles)) styles = mergeOverride(baseStyles, styles); else styles = baseStyles;
    return mDiv(dParent, styles);
  }
  addSetting(keylist) { if (nundef(this.list)) this.list = []; this.list.push(keylist); }
  updateSettings() {
    this.updateLabelSettings();
    this.updateTimeSettings();
    this.updateSpeakmodeSettings();
    let scope = 'user';//'game' 'level','temp','all'
    if (scope == 'temp' || nundef(this.list)) return;
    for (const k of this.list) {
      if (scope == 'user') lookupSetOverride(U, ['settings', k], this.o[k]);
      else if (scope == 'game') lookupSetOverride(U, ['games', this.o.id, k], this.o[k]);
      else if (scope == 'level') lookupSetOverride(U, ['games', this.o.id, 'levels', this.o.level, k], this.o[k]);
      else if (scope == 'all') lookupSetOverride(DB, ['settings', k], this.o[k]);
    }
  }
  updateSpeakmodeSettings() { if (this.o.silentMode && this.o.spokenFeedback) this.o.spokenFeedback = false; }
  updateTimeSettings() { checkTimer(this.o); }
  updateLabelSettings() {
    if (this.o.pictureLabels == 'toggle') this.o.showLabels = true;
    else this.o.showLabels = (this.o.pictureLabels == 'always');
  }
  updateGameValues(U) {
    let game = this.o.id;
    let level = this.o.level;
    let settings = { numColors: 1, numRepeat: 1, numPics: 1, numSteps: 1, colors: ColorList };
    settings = mergeOverride(settings, DB.settings);
    if (isdef(U.settings)) settings = mergeOverride(settings, U.settings);
    if (isdef(DB.games[game])) settings = mergeOverride(settings, DB.games[game]);
    let next = lookup(DB.games, [game, 'levels', level]); if (next) settings = mergeOverride(settings, next);
    next = lookup(U, ['games', game]); if (next) settings = mergeOverride(settings, next);
    next = lookup(U, ['games', game, 'levels', level]); if (next) settings = mergeOverride(settings, next);
    delete settings.levels;
    delete settings.colors;
    Speech.setLanguage(settings.language);
    copyKeys(settings, this.o);
    this.updateSettings();
  }
}
class SimpleClass7 {
  constructor() {
    this.dParent = dTable;
    this.initialPoolSelected = false;
    this.settings = {};
    this.randomIndices = [];
    openToolbar();
  }
  presentGameState(data) {
    console.log('_________________________gs', StepCounter); StepCounter += 1;
    mStyleX(dTable, { h: window.innerHeight });
    let [settings, state] = this.processData(data);
    console.assert(state.poolArr.map(x => !isList(x)), 'BUGBUGBUGBUGBUGBUGBUG!!!')
    let needToLoadBoard = nundef(this.clientBoard) || this.clientBoard.boardFilename != settings.boardFilename;
    if (needToLoadBoard) {
      clearElement(this.dParent);
      this.dPool = null;
      this.clientBoard = applyStandard(this.dParent, this.settings);
      if (!this.inSyncWithServer()) return;
    }
    else if (isdef(data.settings)) { this.clientBoard = applySettings(this.clientBoard, this.settings); }
    if (nundef(this.dPool)) {
      mLinebreak(this.dParent, 30);
      let dPool = this.dPool = mDiv(this.dParent);
    } else {
      this.clearBoardUI();
      this.clearPoolUI();
    }
    this.presentPerlen();
    this.activateDD();
  }
  clearBoardUI() {
    let b = this.clientBoard;
    let [perlen, fields] = [[], []];
    for (const f of b.fields) {
      let p = f.item;
      if (isList(p)) {
        continue;
      }
      if (isdef(p)) {
        if (isdef(p.dxy)) { this.resetCenter(f); }
        iDiv(p).remove();
        f.item = null;
        perlen.push(p);
        fields.push(f);
      }
    }
    return [perlen, fields];
  }
  clearPoolUI() { clearElement(this.dPool); }
  presentPerlen() {
    let [b, s, perlenByIndex, boardArr, poolArr] = [this.clientBoard, this.settings, this.poolEnriched, this.state.boardArr, this.state.poolArr];
    let dParent = this.dPool;
    for (let i = 0; i < poolArr.length; i++) {
      let iPerle = poolArr[i];
      console.assert(!isList(iPerle), 'BUGBUGBUGBUGBUG!!!!!!')
      let perle = perlenByIndex[iPerle];
      if (nundef(perle)) {
        console.log('BUG!', perlenByIndex, perlenByIndex, 'perlenDict', this.perlenDict, '\nboardArr', boardArr, '\npoolArr', poolArr)
      }
      perle.field = null;
      let ui = createPerle(perle, dParent, 64, 1.3, .4);
    }
    for (let i = 0; i < boardArr.length; i++) {
      let pin = boardArr[i];
      let iPerle = isList(pin) ? pin[0] : pin;
      if (iPerle == null) continue;
      let perle = perlenByIndex[iPerle];
      let field = b.fields[i];
      perle.field = field;
      field.item = perle;
      let ui = createPerle(perle, iDiv(field), 64, 1.3, .4);
      if (isList(pin)) {
        this.moveCenter(field, perle, pin[1], pin[2]);
      }
      if (isFarbPerle(perle)) {
        let bg = GermanToEnglish[perle.key];
        if (nundef(bg)) bg = perle.key;
        let d = perle.live.dImg;
        d.style.boxShadow = `0px 0px 200px 200px ${bg}`;
        ui.style.zIndex = 10;
      } else {
        ui.style.zIndex = 11;
      }
    }
  }
  activateDD() {
    let fields = this.clientBoard.fields;
    enableDD(this.perlenListeImSpiel, fields.map(x => x), this.onDropPerleSimplest.bind(this), false, false, dragStartPreventionOnSidebarOpen);
    addDDTarget({ item: this.state.poolArr, div: this.dParent }, false, false);
  }
  onDropOrig(source, target) {
    if (target.item == this.state.poolArr) {
      let f = source.field;
      if (isdef(f)) sendRemovePerle(source, f);
    } else {
      let displaced = null;
      if (isdef(target.item)) {
        let p = target.item;
        if (p == source) return;
        displaced = p;
      }
      if (isdef(source.field)) {
        let f = source.field;
        sendMovePerle(source, f, target, displaced);
      } else {
        sendPlacePerle(source, target, displaced);
      }
    }
  }
  onDropPerleSimplest(source, target, isCopy, clearTarget, dx, dy, ev, clone) {
    if (!this.settings.freeForm) {
      this.onDropOrig(source, target);
    } else if (target.item == this.state.poolArr) {
      let f = source.field;
      if (isdef(f)) sendRemovePerle(source, f);
    } else {
      this.onDropFreeForm(source, target, ev, clone);
    }
  }
  onDropFreeForm(source, target, ev, clone) {
    let perle = source;
    let dField = iDiv(target);
    let dPerle = iDiv(source);
    let rField = getRect(dField);
    let rPerle = getRect(dPerle);
    let d = iDiv(perle);
    let drop = { x: ev.clientX, y: ev.clientY };
    let [dx, dy] = [DDInfo.dragOffset.offsetX, DDInfo.dragOffset.offsetY];
    let [x, y, w, h] = [drop.x, drop.y, rField.w, rField.h];
    let dw = Math.abs(rPerle.w - rField.w);
    let dh = Math.abs(rPerle.h - rField.h);
    dw /= 2, dh /= 2;
    let [xFinal, yFinal] = [x - dx - dw, y - dy - dh];
    let dFieldParent = dField.parentNode;
    let rParent = getRect(dFieldParent);
    let xField = xFinal - rParent.x;
    let yField = yFinal - rParent.y;
    let [cxFinal, cyFinal] = [xField + w / 2, yField + h / 2];
    let dxy = { x: cxFinal - target.center.x, y: cyFinal - target.center.y };
    mStyleX(dField, { left: xField, top: yField });
    target.dxy = source.dxy = dxy;
    let displaced = null;
    if (target.item == source) sendMoveField(target);
    else if (isdef(target.item)) displaced = target.item;
    if (isdef(source.field)) {
      let f = source.field;
      sendMovePerle(source, f, target, displaced);
    } else {
      sendPlacePerle(source, target, displaced);
    }
    return;
  }
  moveCenter(target, source, dx, dy) {
    let dTarget = iDiv(target);
    let center = target.center;
    let newCenter = { x: center.x + dx, y: center.y + dy };
    target.dxy = { x: dx, y: dy };
    let rect = getRect(dTarget);
    mStyleX(dTarget, { left: newCenter.x - rect.w / 2, top: newCenter.y - rect.h / 2 });
    source.dxy = { x: dx, y: dy };
  }
  resetCenter(target) {
    let dTarget = iDiv(target);
    let center = target.center;
    let rect = getRect(dTarget);
    mStyleX(dTarget, { left: center.x - rect.w / 2, top: center.y - rect.h / 2 });
    delete target.dxy;
    if (isdef(target.item)) delete target.item.dxy;
  }
  processData(data) {
    console.assert(isdef(data), 'NO DATA IN PROCESSDATA!!!!!');
    if (nundef(this.state)) this.state = {};
    copyKeys(data.state, this.state);
    if (isdef(data.settings)) {
      console.assert(isdef(this.settings), 'processData G.settings is NOT defined after constructor!!!!!')
      copyKeys(data.settings, this.settings);
    }
    if (isdef(data.perlenDict)) { PerlenDict = this.perlenDict = data.perlenDict; }
    if (isdef(data.state.pool)) {
      this.perlenListeImSpiel = Object.values(this.state.pool);
      this.randomIndices = data.randomIndices;
      this.poolEnriched = this.state.pool;
      for (const idx in this.state.pool) {
        let p = this.state.pool[idx];
        let key = p.key;
        copyKeys(this.perlenDict[key], p);
        p.path = mPath(p);
      }
    }
    return [this.settings, this.state];
  }
  setInitialPoolSelected() { this.initialPoolSelected = true; setTitle('Glasperlenspiel'); }
  inSyncWithServer() {
    let [b, s, st] = [this.clientBoard, this.settings, this.state];
    let corr = {};
    if (st.boardArr.length != b.nFields) { corr.nFields = s.nFields = b.nFields; }
    if (s.rows != b.rows || s.cols != b.cols) { corr.rows = s.rows = b.rows; corr.cols = s.cols = b.cols; }
    if (!isEmpty(Object.keys(corr))) {
      console.log('sending syncBoardLayout!!! corr', corr)
      Socket.emit('settings', { settings: this.settings });
      return false;
    }
    else { return true; }
  }
}
class SimpleGrid {
  constructor(id, { mapData, shape = 'hex', rows = 3, cols = 2, idPrefix, hasNodes = false, hasEdges = false, randomizeIds = false } = {}) {
    this.randomizeIds = randomizeIds;
    this.mapData = mapData;
    this.dhelp = {};
    this.idCounters = { field: 0, corner: 0, edge: 0, other: 0 };
    this.shape = shape;
    this.sides = shape == 'hex' ? 6 : shape == 'quad' ? 4 : 3;
    this.degree = shape == 'hex' ? 3 : shape == 'quad' ? 4 : 6;
    this.idPrefix = idPrefix;
    this.objects = {};
    this.obj_type = shape + 'grid';
    this.id = id;
    if (rows == undefined) return;
    if (shape == 'hex') {
      rows = rows % 2 != 0 ? rows : rows + 1;
      this.topcols = cols;
      this.colarr = this._calc_hex_col_array(rows, this.topcols);
    } else if (shape == 'quad') {
      this.topcols = cols;
      this.colarr = new Array(rows).fill(cols);
    }
    this.maxcols = arrMax(this.colarr);
    this.rows = rows;
    this.cols = cols;
    this.fields = [];
    this.corners = [];
    this.edges = [];
    if (this.shape == 'hex') {
      this._hexFromScratch();
    } else if (this.shape == 'quad') {
      this._quadFromScratch();
    }
    this._calcMetrics();
    this._verifyMetrics();
    this.hasNodes = hasNodes;
    this.hasEdges = hasEdges;
    this._addPositions();
    if (!this.hasNodes) {
      for (const id of this.fields) {
        delete this.objects[id].corners;
      }
      for (const id of this.edges) {
        delete this.objects[id].corners;
      }
      for (const id of this.corners) {
        delete this.objects[id];
      }
      delete this.corners;
    }
    if (!this.hasEdges) {
      for (const id of this.fields) {
        delete this.objects[id].edges;
      }
      if (isdef(this.corners)) {
        for (const id of this.corners) {
          delete this.objects[id].edges;
        }
      }
      for (const id of this.edges) {
        delete this.objects[id];
      }
      delete this.edges;
    }
  }
  scaleToFit(w, h) {
    let f2nRatio = this.hasNodes ? 4 : 10000;
    let maintainRatio = false;
    let ew1 = 10;
    let gName = null;
    let margin = 10;
    let [fw, fh, nw, nh, ew] = this._bestFitScaleFactors(this.wBoard, this.wdef, this.hBoard, this.hdef, f2nRatio, ew1, {
      gName: gName,
      w: w,
      h: h,
      margin: margin,
      maintainRatio: maintainRatio
    });
    let gap = 4;
    for (const id of this.fields) {
      let o = this.objects[id];
      o.bounds = [o.x * fw, o.y * fh, o.w * fw - gap, o.h * fh - gap];
    }
    return Object.values(this.objects).map(x => x.bounds);
  }
  //#region internal
  _addPositions({ wdef = null, hdef = null } = {}) {
    this.wdef = 4;
    this.hdef = 4;
    let fields = Object.values(this.objects).filter(x => x.obj_type == 'field');
    this._recurseFields(this.fields[0]);
    let left = indexOfMin(fields, 'x').val;
    let right = indexOfMax(fields, 'x').val;
    let top = indexOfMin(fields, 'y').val;
    let bottom = indexOfMax(fields, 'y').val;
    this.wBoard = right - left + this.wdef;
    this.hBoard = bottom - top + this.hdef;
    let dx = (left + right) / 2;
    let dy = (top + bottom) / 2;
    for (const f of fields) {
      f.x -= dx;
      f.y -= dy;
    }
    let q = [[0.5, -0.5], [0.5, 0.5], [-0.5, 0.5], [-0.5, -0.5]];
    let hex = [[0, -0.5], [0.5, -0.25], [0.5, 0.25], [0, 0.5], [-0.5, 0.25], [-0.5, -0.25]];
    let triup = [[0, -0.5], [0.5, 0.5], [-0.5, 0.5]];
    let tridown = [[-0.5, 0.5], [0.5, 0.5], [-0.5, 0.5]];
    let pts = this.shape == 'hex' ? hex : this.shape == 'quad' ? q : this.shape == 'triup' ? triup : tridown;
    for (const f of fields) {
      f.poly = getPoly(pts, f.x, f.y, this.wdef, this.hdef);
    }
    this.vertices = correctPolys(this.fields.map(fid => this.objects[fid].poly), 1, 1);
    if (!this.hasNodes) return;
    for (const f of fields) {
      for (let i = 0; i < f.poly.length; i++) {
        let nid = f.corners[i];
        if (!nid) continue;
        let el = this.objects[nid];
        let pt = f.poly[i];
        el.h = 1;
        el.w = 1;
        el.x = pt.x;
        el.y = pt.y;
      }
    }
    if (!this.hasEdges) return;
    for (const f of fields) {
      for (let i = 0; i < f.edges.length; i++) {
        let eid = f.edges[i];
        if (!eid) continue;
        let el = this.objects[eid];
        let n1 = this.objects[el.corners[0]];
        let n2 = this.objects[el.corners[1]];
        el.x1 = n1.x;
        el.y1 = n1.y;
        el.x2 = n2.x;
        el.y2 = n2.y;
        el.x = (n1.x + n2.x) / 2;
        el.y = (n1.y + n2.y) / 2;
        el.thickness = 1;
      }
    }
  }
  _bestFitScaleFactors(wBoard, wField, hBoard, hField, f2nRatio = 4, edgeWidth = 10, { gName, w, h, margin = 4, maintainRatio = false } = {}) {
    if (w == undefined) {
      let g = document.getElementById(gName);
      let transinfo = getTransformInfo(g);
      w = transinfo.translateX * 2;
      h = transinfo.translateY * 2;
    }
    let fw = Math.floor((w - margin) / (wBoard + wField / 2));
    let fh = Math.floor((h - margin) / (hBoard + hField / 2));
    if (maintainRatio) {
      let ff = Math.min(fw, fh);
      fw = ff;
      fh = ff;
    }
    return [fw, fh, Math.floor(fw / f2nRatio), Math.floor(fh / f2nRatio), edgeWidth];
  }
  _hexFromScratch() {
    this.dhelp = {};
    this.idCounters = { field: 0, corner: 0, edge: 0, other: 0 };
    this.imiddleRow = (this.rows - 1) / 2;
    let offsetsHex = [[0, -0.5], [0.5, -0.25], [0.5, 0.25], [0, 0.5], [-0.5, 0.25], [-0.5, -0.25]];
    let offsetsQuad = [[-0.5, -0.5], [0.5, -0.5], [0.5, 0.5], [-0.5, 0.5]];
    this.offsets = this.shape == 'quad' ? offsetsQuad : offsetsHex;
    let idxQuadRow = [-1, 0, 0, -1];
    let idxQuadCol = [0, 0, -1, -1];
    let idxHexRow = [-1, -1, 0, 0, 0, -1];
    let idxHexCol = [0, 1, 1, 0, -1, -1];
    this.indexRow = this.shape == 'quad' ? idxQuadRow : idxHexRow;
    this.indexCol = this.shape == 'quad' ? idxQuadCol : idxHexCol;
    this.fieldsByRowCol = {};
    for (let irow = 0; irow < this.colarr.length; irow++) {
      this.fieldsByRowCol[irow] = {};
      let colstart = this.maxcols - this.colarr[irow];
      for (let j = 0; j < this.colarr[irow]; j++) {
        var icol = colstart + 2 * j;
        let field = {};
        field.obj_type = 'field';
        field.id = this._getId(field);
        field.row = irow;
        field.col = icol;
        field.edges = arrCreate(6, () => null);
        field.neighbors = arrCreate(6, () => null);
        field.corners = arrCreate(6, () => null);
        this.objects[field.id] = field;
        this.fields.push(field.id);
        this.fieldsByRowCol[irow][icol] = field.id;
      }
    }
    for (const fid of this.fields) {
      let field = this.objects[fid];
      for (let inode = 0; inode < this.sides; inode++) {
        let nrow = field.row + this.indexRow[inode];
        let ncol = field.col + this.indexCol[inode];
        let irc = 'n' + '-' + nrow + '_' + ncol;
        let node = null;
        if (irc in this.dhelp) {
          node = this.dhelp[irc];
        } else {
          node = {};
          node.obj_type = 'corner';
          node.id = this._getId(node);
          node.row = nrow;
          node.col = ncol;
          node.edges = arrCreate(3, () => null);
          node.fields = arrCreate(3, () => null);
          this.corners.push(node.id);
          this.dhelp[irc] = node;
          this.objects[node.id] = node;
        }
        if (inode == 0) {
          node.fields[1] = field.id;
        } else if (inode == 1) {
          node.fields[2] = field.id;
        } else if (inode == 2) {
          node.fields[2] = field.id;
        } else if (inode == 3) {
          node.fields[0] = field.id;
        } else if (inode == 4) {
          node.fields[0] = field.id;
        } else if (inode == 5) {
          node.fields[1] = field.id;
        }
        field.corners[inode] = node.id;
      }
    }
    for (const fid of this.fields) {
      let field = this.objects[fid];
      for (let inode = 0; inode < this.sides; inode++) {
        let in1 = inode;
        let in2 = (inode + 1) % 6;
        let n1 = this.objects[field.corners[in1]];
        let n2 = this.objects[field.corners[in2]];
        let startNode = n1;
        if (n1.row > n2.row) {
          startNode = n2;
        }
        if (n1.row == n2.row && n1.col > n2.col) {
          startNode = n2;
        }
        let endNode = startNode == n1 ? n2 : n1;
        let irc = 'e' + startNode.id + '_' + endNode.id;
        let edge = null;
        if (irc in this.dhelp) {
          edge = this.dhelp[irc];
        } else {
          edge = {};
          edge.obj_type = 'edge';
          edge.id = this._getId(edge);
          edge.row = startNode.row;
          edge.col = startNode.col;
          edge.fields = [null, null];
          edge.leftField = null;
          edge.rightField = null;
          edge.corners = [startNode.id, endNode.id];
          edge.startNode = startNode.id;
          edge.endNode = endNode.id;
          if (inode == 0) {
            n1.edges[1] = edge.id;
            n2.edges[2] = edge.id;
          } else if (inode == 1) {
            n1.edges[1] = edge.id;
            n2.edges[0] = edge.id;
          } else if (inode == 2) {
            n1.edges[2] = edge.id;
            n2.edges[0] = edge.id;
          } else if (inode == 3) {
            n1.edges[2] = edge.id;
            n2.edges[1] = edge.id;
          } else if (inode == 4) {
            n1.edges[0] = edge.id;
            n2.edges[1] = edge.id;
          } else if (inode == 5) {
            n1.edges[0] = edge.id;
            n2.edges[2] = edge.id;
          }
          this.edges.push(edge.id);
          this.dhelp[irc] = edge;
          this.objects[edge.id] = edge;
        }
        if (inode < 3) {
          edge.fields[1] = field.id;
          edge.leftField = field.id;
        } else {
          edge.fields[0] = field.id;
          edge.rightField = field.id;
        }
        field.edges[inode] = edge.id;
      }
    }
    for (const fid of this.fields) {
      let f = this.objects[fid];
      for (let i = 0; i < 6; i++) {
        let e = this.objects[f.edges[i]];
        for (const f1 of e.fields) {
          if (f1 && f1 != fid) {
            f.neighbors[i] = f1;
          }
        }
      }
    }
  }
  _quadFromScratch() {
    this.dhelp = {};
    this.idCounters = { field: 0, corner: 0, edge: 0, other: 0 };
    let offsetsHex = [[0, -0.5], [0.5, -0.25], [0.5, 0.25], [0, 0.5], [-0.5, 0.25], [-0.5, -0.25]];
    let offsetsQuad = [[0.5, -0.5], [0.5, 0.5], [-0.5, 0.5], [-0.5, -0.5]];
    this.offsets = this.shape == 'quad' ? offsetsQuad : offsetsHex;
    let idxQuadRow = [-1, 0, 0, -1];
    let idxQuadCol = [0, 0, -1, -1];
    let idxHexRow = [-1, -1, 0, 0, 0, -1];
    let idxHexCol = [0, 1, 1, 0, -1, -1];
    this.indexRow = this.shape == 'quad' ? idxQuadRow : idxHexRow;
    this.indexCol = this.shape == 'quad' ? idxQuadCol : idxHexCol;
    this.fieldsByRowCol = {};
    for (let irow = 0; irow < this.colarr.length; irow++) {
      this.fieldsByRowCol[irow] = {};
      for (let icol = 0; icol < this.colarr[irow]; icol++) {
        let field = {};
        field.obj_type = 'field';
        field.id = this._getId(field);
        field.row = irow;
        field.col = icol;
        field.edges = arrCreate(4, () => null);
        field.neighbors = arrCreate(4, () => null);
        field.corners = arrCreate(4, () => null);
        this.objects[field.id] = field;
        this.fields.push(field.id);
        this.fieldsByRowCol[irow][icol] = field.id;
      }
    }
    for (const fid of this.fields) {
      let field = this.objects[fid];
      for (let inode = 0; inode < this.sides; inode++) {
        let nrow = field.row + this.indexRow[inode];
        let ncol = field.col + this.indexCol[inode];
        let irc = 'n' + '-' + nrow + '_' + ncol;
        let node = null;
        if (irc in this.dhelp) {
          node = this.dhelp[irc];
        } else {
          node = {};
          node.obj_type = 'corner';
          node.id = this._getId(node);
          node.row = nrow;
          node.col = ncol;
          node.edges = arrCreate(4, () => null);
          node.fields = arrCreate(4, () => null);
          this.corners.push(node.id);
          this.dhelp[irc] = node;
          this.objects[node.id] = node;
        }
        if (inode == 0) {
          node.fields[2] = field.id;
        } else if (inode == 1) {
          node.fields[3] = field.id;
        } else if (inode == 2) {
          node.fields[0] = field.id;
        } else if (inode == 3) {
          node.fields[1] = field.id;
        }
        field.corners[inode] = node.id;
      }
    }
    for (const fid of this.fields) {
      let field = this.objects[fid];
      for (let i = 3; i < 7; i++) {
        let inode = i % 4;
        let in1 = inode;
        let in2 = (inode + 1) % this.sides;
        let n1 = this.objects[field.corners[in1]];
        let n2 = this.objects[field.corners[in2]];
        let startNode = n1;
        if (n1.row > n2.row) {
          startNode = n2;
        }
        if (n1.row == n2.row && n1.col > n2.col) {
          startNode = n2;
        }
        let endNode = startNode == n1 ? n2 : n1;
        let irc = 'e' + startNode.id + '_' + endNode.id;
        let edge = null;
        if (irc in this.dhelp) {
          edge = this.dhelp[irc];
        } else {
          edge = {};
          edge.obj_type = 'edge';
          edge.id = this._getId(edge);
          edge.row = startNode.row;
          edge.col = startNode.col;
          edge.fields = [null, null];
          edge.leftField = null;
          edge.rightField = null;
          edge.topField = null;
          edge.bottomField = null;
          edge.crossField = null;
          edge.corners = [startNode.id, endNode.id];
          edge.startNode = startNode.id;
          edge.endNode = endNode.id;
          if (inode == 0) {
            n1.edges[2] = edge.id;
            n2.edges[0] = edge.id;
          } else if (inode == 1) {
            n1.edges[3] = edge.id;
            n2.edges[1] = edge.id;
          } else if (inode == 2) {
            n1.edges[0] = edge.id;
            n2.edges[2] = edge.id;
          } else if (inode == 3) {
            n1.edges[1] = edge.id;
            n2.edges[3] = edge.id;
          }
          this.edges.push(edge.id);
          this.dhelp[irc] = edge;
          this.objects[edge.id] = edge;
        }
        if (inode == 0) {
          edge.fields[1] = field.id;
          edge.leftField = field.id;
        } else if (inode == 1) {
          edge.fields[0] = field.id;
          edge.topField = field.id;
        } else if (inode == 2) {
          edge.fields[0] = field.id;
          edge.rightField = field.id;
        } else if (inode == 3) {
          edge.fields[1] = field.id;
          edge.bottomField = field.id;
        }
        field.edges[(inode + 1) % 4] = edge.id;
      }
    }
    for (const fid of this.fields) {
      let f = this.objects[fid];
      for (let i = 0; i < 4; i++) {
        if (!f.edges[i]) continue;
        let e = this.objects[f.edges[i]];
        for (const f1 of e.fields) {
          if (f1 && f1 != fid) {
            f.neighbors[i] = f1;
          }
        }
      }
    }
    this._verifyMetrics();
  }
  _getId(o) {
    if (this.randomizeIds) return getUID();
    if ('obj_type' in o && o.obj_type in this.idCounters) {
      this.idCounters[o.obj_type] += 1;
      let prefix = o.obj_type[0];
      if (!isEmpty(this.idPrefix)) {
        prefix = this.idPrefix + prefix;
      }
      return prefix + this.idCounters[o.obj_type];
    } else {
      let prefix = 'o';
      if (!empty(this.idPrefix)) {
        prefix = this.idPrefix + prefix;
      }
      this.idCounters['other'] += 1;
      return prefix + this.idCounters['other'];
    }
  }
  _recurseFields(fid, { x = 0, y = 0 } = {}) {
    if (!fid) return;
    let f = this.objects[fid];
    if ('done' in f) return;
    f.done = true;
    f.h = this.hdef;
    f.w = this.wdef;
    f.x = x;
    f.y = y;
    for (let i = 0; i < this.sides; i++) {
      let sid_nei = f.neighbors[i];
      if (sid_nei != null) {
        let dx = 0;
        let dy = 0;
        if (this.shape == 'hex') {
          if (i == 0) {
            dx += this.wdef / 2;
            dy -= (3 * this.hdef) / 4;
          } else if (i == 1) {
            dx += this.wdef;
          } else if (i == 2) {
            dx += this.wdef / 2;
            dy += (3 * this.hdef) / 4;
          } else if (i == 3) {
            dx -= this.wdef / 2;
            dy += (3 * this.hdef) / 4;
          } else if (i == 4) {
            dx -= this.wdef;
          } else if (i == 5) {
            dx -= this.wdef / 2;
            dy -= (3 * this.hdef) / 4;
          }
        } else if (this.shape == 'quad') {
          if (i == 0) {
            dy -= this.hdef;
          } else if (i == 1) {
            dx += this.wdef;
          } else if (i == 2) {
            dy += this.hdef;
          } else if (i == 3) {
            dx -= this.wdef;
          }
        }
        this._recurseFields(sid_nei, { x: x + dx, y: y + dy });
      }
    }
  }
  _calc_hex_col_array(rows, cols) {
    let colarr = [];
    for (let i = 0; i < rows; i++) {
      colarr[i] = cols;
      if (i < (rows - 1) / 2) cols += 1;
      else cols -= 1;
    }
    return colarr;
  }
  _calcMetrics() {
    this.nNodes = 0;
    this.nEdges = 0;
    this.nFields = 0;
    if (this.shape == 'hex') {
      for (let i = 0; i < (this.rows - 1) / 2 + 1; i++) {
        let n = this.colarr[i];
        this.nFields += n == this.maxcols ? n : 2 * n;
        this.nNodes += 2 * (2 * n + 1);
        this.nEdges += n * 2 * 2 + (n == this.maxcols ? n + 1 : 2 * (n + 1));
      }
    } else if (this.shape == 'quad') {
      this.nNodes = (this.cols + 1) * (this.rows + 1);
      this.nFields = this.cols * this.rows;
      this.nEdges = this.cols * (this.rows + 1) + this.rows * (this.cols + 1);
    }
  }
  _verifyMetrics(verbose = false) {
    if (verbose) {
    }
    if (this.corners.length != this.nNodes || this.edges.length != this.nEdges || this.fields.length != this.nFields) {
    } else if (verbose) {
    }
  }
}
class SimpleTimer {
  constructor(elem, msTick, onTick, msTotal, onElapsed) {
    this.elem = elem;
    this.msTotal = this.msLeft = msTotal;
    this.onTick = onTick;
    this.onElapsed = onElapsed;
    this.interval = msTick;
    this.running = false;
    this.paused = false;
    this.TO = null;
  }
  togglePause() { if (this.paused) this.continue(); else this.pause(); }
  clear() { let elapsed = this.stop(); clearElement(this.elem); return elapsed; }
  continue() {
    if (!this.running) this.start();
    else if (!this.paused) return;
    else { this.paused = false; this.TO = setInterval(this.tickHandler.bind(this), this.interval); }
  }
  tickHandler() {
    this.msLeft -= this.interval;
    this.msElapsed = this.msTotal - this.msLeft;
    this.output();
    if (isdef(this.onTick)) this.onTick();
    if (this.msLeft <= 0) {
      this.stop();
      this.msLeft = 0;
      if (isdef(this.onElapsed)) {
        this.onElapsed(0);
      }
    }
  }
  start() {
    if (this.running) this.stop();
    this.started = new Date().now;
    this.msLeft = this.msTotal;
    this.msElapsed = 0;
    this.running = true;
    this.output();
    this.TO = setInterval(this.tickHandler.bind(this), this.interval);
  }
  output() {
    this.elem.innerHTML = timeConversion(Math.max(this.msLeft, 0), 'msh');
  }
  stop() {
    if (!this.running) return;
    clearInterval(this.TO);
    this.TO = null;
    this.running = false;
    return this.msLeft;
  }
  pause() {
    if (this.paused || !this.running) return;
    clearInterval(this.TO);
    this.paused = true;
  }
}
class SoloPlayer {
  constructor(user) {
    this.color = getColorDictColor(user.settings.userColor);
    this.id = user.id;
    this.score = 0;
  }
}
class Speaker {
  static get VOICES() {
    return {
      david: 'Microsoft David - English (United States)', //'Microsoft David Desktop - English',
      mark: 'Microsoft Mark - English (United States)',
      austria: 'Microsoft Michael - German (Austria)',
      zira: 'Microsoft Zira Desktop - English',
      us: 'Google US English',
      ukFemale: 'Google UK English Female',
      ukMale: 'Google UK English Male',
      deutsch: 'Google Deutsch',
      spanish: 'Google español',
      D: 'Google Deutsch',
      S: 'Google español',
      F: 'Google français',
      french: 'Google français',
      C: 'Google 日本語',
      E: 'Google US English',
      apple: 'Susan',
    };
  }
  constructor(lang) {
    this.lang = lang;
    this.q = [];
    this.isRunning = false;
    let awaitVoices = new Promise(resolve =>
      speechSynthesis.onvoiceschanged = resolve)
      .then(this.initVoices.bind(this));
  }
  initVoices() {
    this.voices = speechSynthesis.getVoices().sort(function (a, b) {
      const aname = a.name.toUpperCase(), bname = b.name.toUpperCase();
      if (aname < bname) return -1;
      else if (aname == bname) return 0;
      else return +1;
    });
    if (isdef(mBy('output'))) mBy('output').innerHTML = this.voices.map(x => x.name);
  }
  setLanguage(lang) { this.lang = lang; }
  enq(args) { this.q.push(args); }
  deq() {
    if (nundef(this.voices)) {
      setTimeout(this.deq.bind(this), 500);
    }
    else if (!isEmpty(this.q)) {
      let args = this.q.pop();
      this.utter(...args);
    } else {
      this.isRunning = false;
    }
  }
  clearq() {
    this.q = [];
  }
  output(text) { let d = mBy('output'); if (isdef(d)) d.innerHTML += `<br>${text}`; else console.log('DONE', text); }
  say(text, r = .5, p = .8, v = MASTERVOLUME, voicekey, callback, lang) {
    if (isdef(lang)) this.speaker.setLanguage(lang);
    this.enq([text, r, p, v, valf(voicekey, 'apple'), valf(callback, () => this.output(text))]);
    this.deq();
  }
  say_simple(text, vkey) {
    this.utter(text, .5, .8, 1, valf(vkey, 'apple'), () => this.output(text));
  }
  sayQ(text, vkey) {
    if (isdef(lang)) this.setLanguage(lang);
    this.enq([text, .5, .8, 1, valf(vkey, 'apple'), () => mBy('output').innerHTML = text]);
    this.deq();
  }
  utter(text, r = .5, p = .8, v = MASTERVOLUME, voicekey, callback = null) {
    speechSynthesis.cancel();
    var u = new SpeechSynthesisUtterance();
    let [vkey, voice] = this.findSuitableVoice(text, voicekey);
    u.text = text;
    u.rate = r;
    u.pitch = p;
    u.volume = v;
    u.voice = voice;
    u.onend = ev => {
      if (isdef(callback)) callback();
      this.deq();
    };
    this.isRunning = true;
    speechSynthesis.speak(u);
  }
  findSuitableVoice(text, k) {
    let voicenames = Speaker.VOICES;
    this.output('voices: ' + this.voices.map(x => x.name).join(','));
    k = this.lang;
    let voiceName = voicenames[k];
    let voice = firstCond(this.voices, x => startsWith(x.name, voiceName));
    this.output(`voice ${k} named ${voiceName} exists?${isdef(voice)}`);
    return [k, voice];
  }
  findSuitableVoice_orig(text, voicekey) {
    let voicenames = Speaker.VOICES;
    let vkey = 'zira';
    if (this.lang == 'D') {
      vkey = 'deutsch';
    } else if (text.includes('bad')) {
      vkey = 'zira';
    } else if (voicekey == 'random') {
      vkey = chooseRandom(['david', 'zira', 'us', 'ukFemale', 'ukMale']);
    } else if (isdef(voicenames[voicekey])) {
      vkey = voicekey;
    } else if (isdef(voicekey)) {
      let tryVoiceKey = firstCondDict(voicenames, x => startsWith(x, voicekey));
      if (tryVoiceKey) vkey = tryVoiceKey;
    }
    //vkey=this.lang;//'david';//'mark'
    let voiceName = voicenames[vkey];
    let voice = firstCond(this.voices, x => startsWith(x.name, voiceName));
    return [vkey, voice];
  }
}
class SpeechAPI {
  constructor(lang) {
    this.recorder = new Recorder(lang);
    this.speaker = new Speaker(lang);
    SessionId = Date.now();
  }
  testRecorder() {
    this.recorder.start();
  }
  train() {
  }
  setLanguage(lang) {
    this.speaker.setLanguage(lang);
    this.recorder.setLanguage(lang);
  }
  isSpeakerRunning() { return this.speaker.isRunning; }
  startRecording(lang, callback) {
    this.recorder.isCancelled = false;
    this.recorder.callback = callback;
    this.recorder.setLanguage(lang);
    this.recorder.start();
  }
  stopRecording() {
    this.recorder.isCancelled = true;
    this.recorder.stop();
  }
  say(text, r = .5, p = .8, v = MASTERVOLUME, voicekey, callback, lang) {
    if (isdef(lang)) this.speaker.setLanguage(lang);
    this.speaker.enq(arguments);
    this.speaker.deq();
  }
  stopSpeaking() {
    this.speaker.clearq();
  }
}
class TestEngine {
  constructor() {
    this.Dict = {};
    this.specs = null;
    this.solutions = null;
    this.series = null;
    this.index = 0;
    this.autosave = false;
    this.defs = null;
    this.spec = null;
    this.sdata = null;
  }
  async init(defs, sdata, series, index, ifrom, ito) {
    this.defs = defs;
    this.sdata = sdata;
    series = isdef(series) ? series : localStorage.getItem('testSeries');
    if (nundef(series)) series = TEST_SERIES;
    index = isdef(index) ? index : localStorage.getItem('testIndex');
    if (nundef(index)) index = '0';
    ifrom = isdef(ifrom) ? ifrom : localStorage.getItem('iTestCaseFrom');
    if (nundef(ifrom)) ifrom = '0'; mBy('iTestCaseFrom').value = ifrom;
    ito = isdef(ito) ? ito : localStorage.getItem('iTestCaseTo');
    if (nundef(ito)) ito = '2'; mBy('iTestCaseTo').value = ito;
    index = Number(index);
    await this.loadTestCase(series, index);
    updateTestInput(index);
  }
  async loadSeries(series) {
    let path = '/assetsTEST/' + series + '/';
    this.series = series;
    this.Dict[series] = {
      specs: await loadYamlDict(path + '_spec.yaml'),
      sdata: await loadServerDataForTestSeries(series),
      solutions: await loadSolutions(series),
    };
    if (nundef(this.Dict[series].solutions)) this.Dict[series].solutions = {};
    this.sdata = this.Dict[series].sdata;
    this.specs = this.Dict[series].specs;
    this.solutions = this.Dict[series].solutions;
    let numCases = Object.keys(this.specs).length;
    return numCases;
  }
  async loadNextTestCase() { await this.loadTestCase(this.series, this.index + 1); }
  async loadPrevTestCase() { await this.loadTestCase(this.series, this.index - 1); }
  async repeatTestCase() { await this.loadTestCase(this.series, this.index); }
  async loadTestCase(series, index) {
    if (CLEAR_BETWEEN_TESTS) await onClickClearTable();
    let di = this.Dict[series];
    if (nundef(di)) { await this.loadSeries(series); di = this.Dict[series]; }
    let numCases = Object.keys(di.specs).length;
    if (index < 0) index = numCases - 1;
    else if (index >= numCases) index = 0;
    let spec = di.specs[index];
    if (nundef(spec)) { index = 0; spec = di.specs[0]; }
    this.series = series;
    this.index = index;
    localStorage.setItem('testSeries', this.series);
    localStorage.setItem('testIndex', this.index);
    mBy('message').innerHTML = '(main) ' + series + ' case: ' + index;
    this.spec = spec;
    this.sdata = di.sdata;
    return numCases;
  }
  saveSolutions() { saveSolutions(this.series, this.solutions); }
  loadSolution() {
    let rTree = this.solutions[this.index];
    this.solution = { rTree: rTree };
    return this.solution;
  }
  saveSolution(R, download = false) {
    let r1 = normalizeRTree(R);
    this.solutions[this.index] = r1;
    if (download) this.saveSolutions();
  }
  invalidate() { delete this.solutions[this.index]; }
  verify(R) {
    let rTreeNow = normalizeRTree(R);
    let solution = this.loadSolution();
    if (!solution.rTree) {
      if (this.autosave) this.saveSolution(R);
      return;
    }
    let rTreeSolution = this.solution.rTree;
    let changes = propDiffSimple(rTreeNow, rTreeSolution);
    if (changes.hasChanged) {
      console.log('verifying test case', this.series, this.index, 'FAIL!!!!!!!');
      console.log('changes:', changes)
    } else {
      console.log('verifying test case', this.series, this.index, 'correct!');
    }
  }
}
class TimeIt {
  constructor(msg, showOutput = true) {
    this.showOutput = showOutput;
    this.init(msg);
  }
  getTotalTimeElapsed() {
    let tNew = new Date();
    let tDiffStart = tNew.getTime() - this.namedTimestamps.start.getTime();
    return tDiffStart;
  }
  tacit() { this.showOutput = false; }
  timeStamp(name) {
    let tNew = new Date();
    let tDiff = tNew.getTime() - this.namedTimestamps.start.getTime();
    if (this.showOutput) console.log('___', tDiff, 'msecs * to', name);
    this.t = tNew;
    this.namedTimestamps[name] = tNew;
  }
  reset() { this.init('timing start') }
  init(msg) {
    this.t = new Date();
    if (this.showOutput) console.log('___', msg);
    this.namedTimestamps = { start: this.t };
  }
  showSince(name, msg = 'now') {
    let tNew = new Date();
    let tNamed = this.namedTimestamps[name];
    if (this.showOutput) if (!tNamed) { console.log(name, 'is not a timestamp!'); return; }
    let tDiff = tNew.getTime() - tNamed.getTime();
    if (this.showOutput) console.log('___', tDiff, 'msecs', name, 'to', msg);
    this.t = tNew;
  }
  format(t) { return '___' + t.getSeconds() + ':' + t.getMilliseconds(); }
  show(msg) { this.showTime(msg); }
  showTime(msg) {
    let tNew = new Date();
    let tDiff = tNew.getTime() - this.t.getTime();
    let tDiffStart = tNew.getTime() - this.namedTimestamps.start.getTime();
    if (this.showOutput) console.log('___ ', tDiff, 'msecs to', msg, '(' + tDiffStart, 'total)');
    this.t = tNew;
  }
  start_of_cycle(msg) {
    this.init(msg);
  }
  end_of_cycle(msg) {
    let tNew = new Date();
    let tDiff = tNew.getTime() - this.t.getTime();
    let tDiffStart = tNew.getTime() - this.namedTimestamps.start.getTime();
    if (this.showOutput) console.log('___ ' + tDiff + ' msecs', msg, 'to EOC (total: ' + tDiffStart + ')');
  }
}
class TimeoutManager {
  constructor() {
    this.TO = {};
  }
  clear(key) {
    if (nundef(key)) key = Object.keys(this.TO);
    else if (isString(key)) key = [key];
    for (const k of key) {
      clearTimeout(this.TO[k]);
      delete this.TO[k];
    }
  }
  set(ms, callback, key) {
    if (nundef(key)) key = getUID();
    this.TO[key] = setTimeout(ms, callback);
  }
}
class TimerClass {
  constructor(g, elem) {
    this.started, this.elapsed, this.onTimeOver = null, this.elem, this.timeLeft, this.settings = g;
    if (isdef(elem)) this.setElem(elem);
  }
  setElem(elem) {
    if (nundef(elem) && isdef(this.elem)) { elem = this.elem; }
    else if (nundef(elem)) { let d = mBy('time'); if (isdef(d)) this.elem = d; }
    else if (isString(elem)) { elem = mBy(elem); this.elem = elem; }
  }
  check(g) { this.settings = g; if (g.showTime) { show(this.elem); this.start(); } else { hide(this.elem); } return g.showTime; }
  clear() { clearTimeout(this.TO); }
  restart(g, elem, onTimeOver = null) {
    this.clear();
    this.setElem(elem);
    let active = this.check(g);
    this.started = msNow();
    this.elapsed = 0;
    if (isdef(onTimeOver)) this.onTimeOver = onTimeOver;
    if (active) this.start();
  }
  start() {
    if (nundef(this.settings.showTime) || !this.settings.showTime) return;
    if (nundef(this.settings.minutesPerUnit)) this.settings.minutesPerUnit = 10;
    if (nundef(this.started)) { this.started = msNow(); this.elapsed = 0; }
    var timeLeft = this.timeLeft = this.settings.minutesPerUnit * 60000 - this.getTimeElapsed();
    if (timeLeft > 0) {
      let t = msToTime(timeLeft);
      let s = format2Digits(t.h) + ":" + format2Digits(t.m) + ":" + format2Digits(t.s);
      this.elem.innerHTML = s;
      this.TO = setTimeout(() => this.start(), 500);
    } else {
      this.elem.innerHTML = '00:00:00';
      if (this.onTimeOver) this.onTimeOver();
    }
  }
  unitTimeUp() {
    return (this.settings.minutesPerUnit * 60000 - this.getTimeElapsed()) <= 0;
  }
  startClock(elem) {
    if (nundef(this.settings.showTime) || !this.settings.showTime) return;
    var today = new Date(),
      h = format2Digits(today.getHours()),
      m = format2Digits(today.getMinutes()),
      s = format2Digits(today.getSeconds());
    if (isString(elem)) elem = mBy(elem); elem.innerHTML = h + ":" + m + ":" + s;
    this.TO = setTimeout(() => this.startClock(elem), 500);
  }
  getTimeElapsed() { return this.elapsed + msElapsedSince(this.started); }
}
class ToolbarClass {
  constructor(dParent) {
    this.dParent = dParent;
    clearElement(dParent);
    this.buttons = {};
    this.populate();
  }
  addButton(key, handler, caption) {
    if (nundef(caption)) caption = key;
    let styles = { w: 100 };
    let b = this.buttons[key] = mButton(caption, handler, this.dParent, styles, null, 'b_' + key);
  }
  removeButton() { }
  showButton() { }
  hideButton() { }
  populate() {
    this.addButton('uploadBoard', onClickUploadBoard, 'upload board');
    this.addButton('uploadPerlen', onClickUploadPerlen, 'upload perlen');
    mLinebreak(this.dParent)
    this.addButton('chooseBoard', onClickChooseBoard, 'choose board');
    this.addButton('prefabGallery', onClickPrefabGallery, 'prefab gallery');
    this.addButton('modifyLayout', onClickModifyLayout, 'modify layout');
    this.addButton('saveAsPrefab', onClickSaveAsPrefab, 'save as prefab');
    mLinebreak(this.dParent);
    let oldCode = false;
    if (oldCode) {
      this.addButton('clearBoard', onClickClearBoard, 'clear board');
      this.addButton('clearPerlenpool', onClickClearPerlenpool, 'clear perlenpool');
      this.addButton('remove5Random', onClickRemove5Random, 'remove 5 random');
      mLinebreak(this.dParent);
      this.addButton('addToPool', onClickAddToPool, 'add to pool');
      this.addButton('add5Random', onClickAdd5Random, 'add 5 random');
    } else {
      this.addButton('perlenPool', onClickPerlenPool, 'perlen pool');
    }
    mLinebreak(this.dParent);
    this.addButton('recovery', onClickRecovery, 'recovery!!!');
    this.addButton('recpoint', onClickRecpoint, 'recpoint!');
    mLinebreak(this.dParent);
    mLinebreak(this.dParent)
    this.addButton('saveSettings', onClickSaveSettings, 'save settings');
    this.addButton('retrieveSettings', onClickRetrieveSettings, 'retrieve settings');
    mLinebreak(this.dParent);
    this.addButton('saveState', onClickSaveState, 'save gamestate');
    this.addButton('retrieveState', onClickRetrieveState, 'retrieve gamestate');
  }
}
class UniqueIdEngine {
  constructor() {
    this.next = -1;
  }
  get() {
    this.next += 1;
    return 'a###' + this.next;
    this.next += 1;
  }
}
class UserManager { }
class VidCache_dep {
  constructor(resetStorage = false) {
    this.live = {};
    if (resetStorage) this.resetAll();
  }
  load(key) {
    let keys = null; let sKey = key;
    if (isList(key)) { skey = key.shift(); keys = key; }
    let res = this.live[sKey];
    if (res && keys) res = lookup(res, keys);
    if (res) return res;
    let sData = localStorage.getItem(sKey);
    if (sData) {
      let data = sData[0] == '{' || sData[0] == '[' ? JSON.parse(sData) : isNumber(sData) ? Number(sData) : sData;
      if (keys) { this.live[sKey] = data; return lookup(data, keys); }
      return data;
    } else {
      return null;
    }
  }
  reset() { this.live = {}; }
  resetAll() { localStorage.clear(); this.reset(); }
  saveComplexObject(keys, o) {
  }
  save(key, data) {
    this.live[key] = data;
    localStorage.setItem(key, JSON.stringify(data));
  }
}
class WeightedSampler {
  constructor(elements, weights) {
    this.total = 0;
    this.elements = Array.from(elements);
    this.cweights = weights.map(weight => this.total += weight);
  }
  get() {
    let random = Math.random() * this.total;
    return this.elements.find((element, index) => random < this.cweights[index]);
  }
}
class Layout1 extends Array {
  constructor(id, shape = 'grid', rows = 3, cols = 3, options = {}) {
    console.log(';;;;;;;;;', id, shape, rows, cols, options)
    var fields = Array(rows)
      .fill()
      .map(() => Array(cols).fill(0));
    super(...fields);
    this.options = options;
    this.msBase = null;
    this.id = id;
    this.rows = rows;
    this.cols = cols;
    this.shape = shape;
  }
  addRow(...values) {
    this.push(values);
  }
  addCol() {
    let i = 0; let val = arguments;
    for (const row of this) {
      row.push(val[i]);
    }
    for (let index = this.length; index < val.length; index++) {
      this.push([val[index]]);
    }
  }
  getPos(r, c) { return this.msBase.getPos; }
  setCols(c) { }
  setRows(r) { }
  setShape(shape) { }
  isValidIndex(r, c) { return this[r][c]; }
  render() { this.renderBase }
  renderField(r, c) { }
  setOption(key, value) { }
}
class PerlenSettingsClass extends SettingsClass {
  setOtherSettings(elem) {
    console.log('____________elem', elem);
    let val = elem.value;
    let key = elem.keyList[0];
    console.log('val', val, 'key', key, 'elem.value', elem.value)
    switch (key) {
      case 'boardStandard':
        let data = DB.standardSettings[val];
        if (nundef(data)) { console.log('NO! key', key); return; }
        for (const k in data) {
          console.log('k', k)
          this.o[k] = data[k];
        }
        this.o.boardStandard = val;
        console.log('settings sollen so geaendert werden:', data);
        this.createSettingsUi();
        break;
    }
  }
  setzeEinActiveOptions(dParent, label, optionList, friendlyList, init, skeys) {
    let d = mDiv(dParent);
    let val = init;
    let inp = createElementFromHTML(`<select class="options" onchange="Settings.setOtherSettings(this)"></select>`);
    for (let i = 0; i < optionList.length; i++) {
      let opt = optionList[i];
      let friendly = friendlyList[i];
      let optElem = createElementFromHTML(`<option value="${opt}">${friendly}</option>`);
      mAppend(inp, optElem);
      if (opt == val) optElem.selected = true;
    }
    inp.value = val;
    let labelui = createElementFromHTML(`<label>${label}</label>`);
    mAppend(d, labelui);
    mAppend(labelui, inp);
    mStyleX(inp, { maleft: 12, mabottom: 4 });
    inp.keyList = skeys;
  }
  setzeEinBrowseFile(dParent, label, init, skeys) {
    let d = mDiv(dParent);
    let val = lookup(this.o, skeys);
    if (nundef(val)) val = init;
    let inp = createElementFromHTML(
      `<input type="text" class="input" value="${val}"  />`);
    let labelui = createElementFromHTML(`<label>${label}</label>`);
    mAppend(d, labelui);
    mAppend(labelui, inp);
    var fakeInput = document.createElement("input");
    fakeInput.type = "file";
    fakeInput.accept = "image/*";
    fakeInput.multiple = false;
    inp.onclick = () => { fakeInput.click(); };
    fakeInput.onchange = () => {
      let imgFile = fakeInput.files[0];
      previewBrowsedFile(dTable, imgFile);
      let val = inp.value = getFilename(imgFile.name);
      this.hasChanged = true;
      this.haveChanged.push(skeys);
      this.o[skeys[0]] = val;
      this.imgFile = imgFile;
    };
    mStyleX(inp, { maleft: 12, mabottom: 4, cursor: 'pointer' });
    mClass(inp, 'input');
    inp.keyList = skeys;
    this.addSetting(skeys[0]);
  }
  createSettingsUi() {
    let dParent = mBy('dSettingsContent');
    mCenterFlex(dParent);
    clearElement(dParent);
    this.list = [];
    let fertigSets = DB.standardSettings;
    let fsNames = Object.keys(fertigSets); fsNames.unshift('none');
    let nGroupBoardSettings = this.mInputGroup(dParent);
    this.setzeEinOptions(nGroupBoardSettings, 'base on standard', fsNames, fsNames, 'shapeShifters', ['boardStandard']);
    this.setzeEinOptions(nGroupBoardSettings, 'board layout', ['hex1', 'hex', 'quad', 'circle'], ['hex1', 'hex', 'quad', 'circle'], 'hex1', ['boardLayout']);
    this.setzeEinBrowseFile(nGroupBoardSettings, 'board filename', 'shapeShifters', ['boardFilename']);
    this.setzeEineZahl(nGroupBoardSettings, 'board rotation', 0, ['boardRotation']);
    this.setzeEineZahl(nGroupBoardSettings, 'top margin', 10, ['boardMarginTop']);
    this.setzeEineZahl(nGroupBoardSettings, 'left margin', 20, ['boardMarginLeft']);
    this.setzeEinenString(nGroupBoardSettings, 'field color', 'transparent', ['fieldColor']);
    this.setzeEineZahl(nGroupBoardSettings, 'field width', 100, ['dxCenter']);
    this.setzeEineZahl(nGroupBoardSettings, 'field height', 120, ['dyCenter']);
    this.setzeEineZahl(nGroupBoardSettings, 'horizontal gap', 10, ['wGap']);
    this.setzeEineZahl(nGroupBoardSettings, 'vertical gap', 20, ['hGap']);
    this.setzeEineZahl(nGroupBoardSettings, 'rows', 7, ['rows']);
    this.setzeEineZahl(nGroupBoardSettings, 'columns', 6, ['cols']);
    this.setzeEineZahl(nGroupBoardSettings, 'max width', 800, ['wFieldArea']);
    this.setzeEineZahl(nGroupBoardSettings, 'max height', 800, ['hFieldArea']);
    let nGroupPerlenSettings = this.mInputGroup(dParent);
    this.setzeEinOptions(nGroupPerlenSettings, 'pool selection', ['random', 'mixed', 'player'], ['random', 'mixed', 'never'], 'random', ['poolSelection']);
    this.setzeEineZahl(nGroupPerlenSettings, 'random pool size', 25, ['numPool']);
  }
}
class UIGraph extends AGraph {
  init(dParent, styles = {}) {
    let defOptions = {
      maxZoom: 1,
      minZoom: .001,
      motionBlur: false,
      wheelSensitivity: 0.05,
      zoomingEnabled: true,
      userZoomingEnabled: true,
      panningEnabled: true,
      userPanningEnabled: true,
      boxSelectionEnabled: false,
      elements: [],
    };
    this.id = getUID();
    let dOuter = mDiv(dParent, styles.outer, this.id);
    let gStyles = valf(styles.inner, { w: 640, h: 420 });
    let dContainer = mDiv(dOuter, { position: 'relative', w: gStyles.w, h: gStyles.h, align: 'left' });
    let styleDict = {
      node: { 'label': 'data(label)', width: 25, height: 25, 'background-color': 'red', color: "#fff", "text-valign": "center", "text-halign": "center" },
      edge: { width: 2, 'line-color': 'silver', 'curve-style': 'haystack', },
      'node.high': { 'background-color': 'yellow' },
      'node.trans': { opacity: '0.5' },
    }
    for (const ks of ['node', 'edge', 'node.high', 'node.trans']) {
      if (isdef(styles[ks])) {
        let mStyles = styles[ks];
        let cyStyles = translateStylesToCy(mStyles, ks);
        copyKeys(cyStyles, styleDict[ks]);
      }
    }
    let cyStyle = [];
    for (const k in styleDict) { cyStyle.push({ selector: k, style: styleDict[k] }); }
    let options = { container: dContainer, style: cyStyle };
    copyKeys(options, defOptions);
    this.cy = cytoscape(defOptions);
    iAdd(this, { div: dOuter, dCy: dContainer });
  }
  //#region layouts
  hex(rows, cols, wCell, hCell) {
    let centers = this.hexPositions = getCentersFromRowsCols('hex', rows, cols, wCell, hCell)[0];
    this.storePositions('hex', centers);
    this.storePositions('preset', centers);
    this.retrievePositions('hex');
    this.cy.layout({ name: 'preset' }).run();
    this.center();
  }
  hex1(rows, cols, wCell, hCell) {
    let centers = this.hexPositions = getCentersFromRowsCols('hex1', rows, cols, wCell, hCell)[0];
    this.storePositions('hex1', centers);
    this.storePositions('preset', centers);
    let nodes = this.getNodes();
    for (let i = 0; i < nodes.length; i++) {
      let node = nodes[i];
      let center = centers[i];
      node.data('center', center);
    }
    this.retrievePositions('hex1');
    this.cy.layout({ name: 'preset' }).run();
    this.center();
  }
  breadthfirst() { this.cy.layout({ name: 'breadthfirst', animate: true }).run(); }
  circle() { this.cy.layout({ name: 'circle', animate: 'end' }).run(); }
  concentric() { this.cy.layout({ name: 'concentric', animate: true }).run(); }
  comcola() {
    let defaults = {
      name: 'cola',
      animate: true,
      refresh: 1,
      maxSimulationTime: 4000,
      ungrabifyWhileSimulating: false,
      fit: true,
      padding: 30,
      boundingBox: undefined,
      nodeDimensionsIncludeLabels: false,
      ready: function () { },
      stop: function () { },
      randomize: false,
      avoidOverlap: true,
      handleDisconnected: true,
      convergenceThreshold: 0.01,
      nodeSpacing: function (node) { return 10; },
      flow: undefined,
      alignment: undefined,
      gapInequalities: undefined,
      edgeLength: undefined,
      edgeSymDiffLength: undefined,
      edgeJaccardLength: undefined,
      unconstrIter: undefined,
      userConstIter: undefined,
      allConstIter: undefined,
      infinite: false
    };
    let options = {
      name: 'cola',
      convergenceThreshold: 100,
      boundingBox: { x1: 20, y1: 20, w: 200, h: 200 },
    };
    copyKeys(options, defaults);
    console.log(defaults.boundingBox)
    this.cy.layout(defaults).run();
  }
  cola() { this.cy.layout({ name: 'cola' }).run(); }
  cose() { this.cy.layout({ name: 'cose', animate: 'end' }).run(); }
  euler() { this.cy.layout({ name: 'euler', fit: true, padding: 25, animate: 'end' }).run(); }
  fcose() {
    var defaultOptions = {
      quality: "default",
      randomize: true,
      animate: true,
      animationDuration: 500,
      animationEasing: undefined,
      fit: true,
      padding: 30,
      nodeDimensionsIncludeLabels: false,
      uniformNodeDimensions: false,
      packComponents: true,
      step: "all",
      samplingType: true,
      sampleSize: 25,
      nodeSeparation: 75,
      piTol: 0.0000001,
      nodeRepulsion: node => 4500,
      idealEdgeLength: edge => 50,
      edgeElasticity: edge => 0.45,
      nestingFactor: 0.1,
      numIter: 2500,
      tile: true,
      tilingPaddingVertical: 10,
      tilingPaddingHorizontal: 10,
      gravity: 0.25,
      gravityRangeCompound: 1.5,
      gravityCompound: 1.0,
      gravityRange: 3.8,
      initialEnergyOnIncremental: 0.3,
      fixedNodeConstraint: undefined,
      alignmentConstraint: undefined,
      relativePlacementConstraint: undefined,
      ready: () => { },
      stop: () => { },
      name: 'fcose',
    };
    this.cy.layout(defaultOptions).run();
  }
  gridLayout() { this.cy.layout({ name: 'grid', animate: true }).run(); }
  presetLayout_dep() {
    let hasCenterProp = this.setPositionData();
    if (!hasCenterProp) {
      console.log('no positions are preset: store first!');
    } else {
      let options = {
        name: 'preset',
        positions: undefined,
        zoom: undefined,
        pan: undefined,
        fit: true,
        padding: 30,
        animate: true,
        animationDuration: 500,
        animationEasing: undefined,
        animateFilter: function (node, i) { return true; },
        ready: undefined,
        stop: undefined,
        transform: function (node, position) { return position; }
      };
      this.cy.layout(options);
      this.reset();
    }
  }
  presetLayout() {
    this.retrievePositions('prest');
    this.cy.layout({ name: 'preset' }).run();
    this.center();
  }
  randomLayout() { this.cy.layout({ name: 'random', animate: 'true' }).run(); }
  klay() {
    let klayDefaults = {
      // Following descriptions taken from http://layout.rtsys.informatik.uni-kiel.de:9444/Providedlayout.html?algorithm=de.cau.cs.kieler.klay.layered
      addUnnecessaryBendpoints: false,
      aspectRatio: 1.6,
      borderSpacing: 20,
      compactComponents: false,
      crossingMinimization: 'LAYER_SWEEP',
      cycleBreaking: 'GREEDY',
      direction: 'UNDEFINED',
      edgeRouting: 'ORTHOGONAL',
      edgeSpacingFactor: 0.5,
      feedbackEdges: false,
      fixedAlignment: 'NONE',
      inLayerSpacingFactor: 1.0,
      layoutHierarchy: false,
      linearSegmentsDeflectionDampening: 0.3,
      mergeEdges: false,
      mergeHierarchyCrossingEdges: true,
      nodeLayering: 'NETWORK_SIMPLEX',
      nodePlacement: 'BRANDES_KOEPF',
      randomizationSeed: 1,
      routeSelfLoopInside: false,
      separateConnectedComponents: true,
      spacing: 20,
      thoroughness: 7
    };
    var options = {
      nodeDimensionsIncludeLabels: false,
      fit: true,
      padding: 20,
      animate: true,
      animateFilter: function (node, i) { return true; },
      animationDuration: 500,
      animationEasing: undefined,
      transform: function (node, pos) { return pos; },
      ready: this.reset.bind(this),
      stop: undefined,
      klay: {
        addUnnecessaryBendpoints: false,
        aspectRatio: 1.6,
        borderSpacing: 20,
        compactComponents: false,
        crossingMinimization: 'LAYER_SWEEP',
        cycleBreaking: 'GREEDY',
        direction: 'UNDEFINED',
        edgeRouting: 'ORTHOGONAL',
        edgeSpacingFactor: 0.5,
        feedbackEdges: false,
        fixedAlignment: 'NONE',
        inLayerSpacingFactor: 1.0,
        layoutHierarchy: false,
        linearSegmentsDeflectionDampening: 0.3,
        mergeEdges: false,
        mergeHierarchyCrossingEdges: true,
        nodeLayering: 'NETWORK_SIMPLEX',
        nodePlacement: 'INTERACTIVE',
        randomizationSeed: 1,
        routeSelfLoopInside: false,
        separateConnectedComponents: true,
        spacing: 20,
        thoroughness: 3
      },
      name: 'klay',
      priority: function (edge) { return null; },
    };
    this.cy.layout(options).run();
  }
  retrievePositions(key) {
    if (nundef(key)) key = 'prest';
    let di = this.posDict[key];
    for (const n of this.getNodes()) {
      let id = n.id();
      let pos = di[id];
      if (isdef(pos)) this.setPosition(id, pos.x, pos.y);
    }
  }
  storePositions(key, poslist = []) {
    if (nundef(key)) key = 'prest';
    this.posDict[key] = {};
    let i = 0;
    for (const n of this.getNodes()) {
      let id = n.id();
      let pos = valf(poslist[i], this.getPosition(id));
      i += 1;
      this.posDict[key][id] = pos;
    }
  }
  storeSizes(key, poslist = []) {
    if (nundef(key)) key = 'size';
    this.posDict[key] = {};
    let i = 0;
    for (const n of this.getNodes()) {
      let id = n.id();
      let pos = valf(poslist[i], this.getSize(id));
      i += 1;
      this.posDict[key][id] = pos;
    }
  }
  //#endregion
  //#region zoom pan fit center
  fit() { this.cy.fit(); }
  center() { this.cy.center(); }
  reset() { this.pan0(); this.zoom1(); this.center(); this.fit(); }
  pan0() { this.cy.pan({ x: 0, y: 0 }); }
  zoom1() { this.cy.zoom(1); }
  isPan() { return this.cy.panningEnabled(); }
  isZoom() { return this.cy.zoomingEnabled(); }
  enablePanZoom() { this.pan(true); this.zoom(true); }
  pan(isOn, reset = true) {
    this.cy.panningEnabled(isOn);
    this.cy.userPanningEnabled(isOn);
    if (!isOn && reset) { this.pan0(); this.center(); }
  }
  zoom(isOn, minZoom = .25, maxZoom = 1, reset = true) {
    this.cy.zoomingEnabled(isOn);
    this.cy.userZoomingEnabled(isOn);
    if (!isOn && reset) { this.zoom1(); this.center(); }
    else if (isOn) { this.cy.minZoom(minZoom); this.cy.maxZoom(maxZoom); }
  }
  //#endregion
  setSizeToContent() {
    this.cy.zoomingEnabled(false);
    this.updateBounds();
  }
  updateBounds() {
    var bounds = this.cy.elements().boundingBox();
    let dContainer = this.live.dCy;
    dContainer.css('height', bounds.h + 100);
    dContainer.css('width', bounds.w + 100);
    this.cy.center();
    this.cy.resize();
    dContainer.cytoscapeEdgehandles('resize');
  }
  //#region ui functions
  enableDD() { this.enableDragging(); }
  disableDD() { this.disableDragging(); }
  enableDragging() { this.cy.nodes().grabify(); }
  disableDragging() { this.cy.nodes().ungrabify(); }
  showGraph() { }
  showControls(dWhere, lWhich) {
    if (!this.hasControls) this.addLayoutControls(dWhere, lWhich);
    if (nundef(dWhere)) dWhere = iDiv(this);
  }
  showExtent() { let bb = this.cy.elements().bb(); console.log('graph size:', bb.w, bb.h); }
  showSize() { this.showExtent(); }
  hideGraph() { }
  hideControls() { }
  mount() { }
  unmount() { }
  closeLayoutControls() { if (isdef(this.sb)) hide(this.sb); }
  addLayoutControls(dParent, buttonlist) {
    if (nundef(dParent)) dParent = iDiv(this);
    let buttons = {
      BFS: mButton('BFS', () => this.breadthfirst(), dParent, {}, ['tbb']),
      circle: mButton('circle', () => this.circle(), dParent, {}, ['tbb']),
      CC: mButton('CC', () => this.concentric(), dParent, {}, ['tbb']),
      cola: mButton('cola', () => this.comcola(), dParent, {}, ['tbb']),
      cose: mButton('cose', () => this.cose(), dParent, {}, ['tbb']),
      euler: mButton('euler', () => this.euler(), dParent, {}, ['tbb']),
      fcose: mButton('fcose', () => this.fcose(), dParent, {}, ['tbb']),
      grid: mButton('grid', () => this.gridLayout(), dParent, {}, ['tbb']),
      klay: mButton('klay', () => this.klay(), dParent, {}, ['tbb']),
      prest: mButton('prest', () => this.presetLayout(), dParent, {}, ['tbb']),
      rand: mButton('rand', () => this.randomLayout(), dParent, {}, ['tbb']),
      center: mButton('center', () => this.center(), dParent, {}, ['tbb']),
      fit: mButton('fit', () => this.fit(), dParent, {}, ['tbb']),
      reset: mButton('reset', () => this.reset(), dParent, {}, ['tbb']),
      show: mButton('show', () => this.showGraph(), dParent, {}, ['tbb']),
      hide: mButton('hide', () => this.hideGraph(), dParent, {}, ['tbb']),
      store: mButton('store', () => this.storeCurrentPositions(), dParent, {}, ['tbb']),
    };
    for (const b in buttons) {
      if (isdef(buttonlist) && !buttonlist.includes(b)) hide(buttons[b]);
    }
    return buttons;
  }
  addVisual(dParent, styles = {}) {
    if (this.hasVisual) return;
    this.hasVisual = true;
    this.id = nundef(dParent.id) ? getUID() : dParent.id;
    let styleDict = {
      node: { 'width': 25, 'height': 25, 'background-color': 'red', "color": "#fff", 'label': 'data(id)', "text-valign": "center", "text-halign": "center", },
      edge: { 'width': 2, 'line-color': 'silver', 'curve-style': 'haystack', },
      'node.highlight': { 'background-color': 'yellow' },
      'node.trans': { 'opacity': '0.5' },
    }
    for (const ks of ['node', 'edge', 'node.highlight', 'node.trans']) {
      if (isdef(styles[ks])) {
        for (const k in styles[ks]) {
          let [prop, val] = translateToCssStyle(k, styles[ks][k], false);
          styleDict[ks][prop] = val;
        }
      }
    }
    let cyStyle = [];
    for (const k in styleDict) { cyStyle.push({ selector: k, style: styleDict[k] }); }
    let size = getSize(dParent);
    let d1 = mDiv(dParent, { position: 'relative', bg: 'green', w: size.w, left: 0, top: 0, h: size.h, align: 'left' });
    this.cy.mount(d1);
    this.cy.style(cyStyle);
    this.enablePanZoom();
    iAdd(this, { div: dParent, dCy: d1 });
  }
  //#endregion
  //#region events
  nodeEvent(evname, handler) { this.cy.on(evname, 'node', ev => handler(ev.target)); }
  mStyle(elid, styles, group = 'node') {
    if (isString(elid)) elid = this.cy.getElementById(elid);
    let di = translateStylesToCy(styles, group);
    for (const k in di) {
      elid.style(k, di[k]);
    }
  }
  setLabel(id, label, styles) {
    let ele = this.cy.getElementById(id);
    ele.data('label', label);
    this.mStyle(id, styles, isdef(this.getNode(id)) ? 'node' : 'edge');
  }
  setStyle(elid, prop, val) {
    if (isString(elid)) elid = this.cy.getElementById(elid);
    elid.style(prop, val);
  }
  setClass(elid, className) {
    if (isString(elid)) elid = this.cy.getElementById(elid);
    elid.class(className);
  }
  //#endregion
}
class ControllerSolitaireMinimal extends ControllerSolitaire {
  clear() { if (isdef(this.timer)) this.timer.clear(); }
  startLevel() {
    Settings.updateGameValues(this.player, this.g);
    this.g.start_Level();
    this.startRound();
  }
  prompt() {
    QContextCounter += 1;
    showStats(false);
    this.g.trialNumber = 0;
    this.g.prompt();
  }
  activateUi() {
    Selected = null;
    uiActivated = true;
    if (isdef(this.timer)) this.timer.start();
    this.g.activate();
  }
  gotoNext(nextLevel) {
    onclick = null;
    removeMarkers();
    clearTimeouts();
    if (isdef(this.timer)) this.timer.clear();
    if (Score.levelChange && nextLevel <= this.g.maxLevel) {
      this.g.level = nextLevel;
      setBadgeLevel(this.g.level);
      this.startLevel();
    } else {
      this.startRound();
    }
  }
}
class MazeGraph extends AGraph {
  constructor(dParent, rows, cols, sz, gap = 4) {
    super();
    [this.cols, this.rows, this.sz, this.gap] = [cols, rows, sz, gap];
    let m = this.m = this.createMaze(cols, rows, sz, gap);
    let dMaze = this.dMaze = this.createDiv(dParent, cols, rows, sz, gap);
    let szMaze = getSize(dMaze);
    let dGraph = this.dGraph = mDiv(dParent, { align: 'left', w: szMaze.w, h: szMaze.h, bg: 'pink', maleft: 20 }, 'd_graph');
    this.mazeId = dGraph.id = getUID();
    let sb = this.sb = mDiv(dParent, { w: 40 }); mCenterCenterFlex(this.sb);
    hide(dGraph); hide(sb);
    this.items = this.createCellItems();
  }
  clear() { super.clear(); }
  getTopLeftCell() { return this.getCell(0, 0); }
  getTopRightCell() { return this.getCell(0, this.cols - 1); }
  getBottomLeftCell() { return this.getCell(this.rows - 1, 0); }
  getBottomRightCell() { return this.getCell(this.rows - 1, this.cols - 1); }
  getCell(row, col) { return this.matrix[row][col]; }
  getCommonId(row, col) { return '' + row + "-" + col; }
  getCommonIdTable(row, col) { return 'td_' + this.getCommonId(row, col); }
  getRCI(edgeId) {
    let [r1, c1, r2, c2] = allNumbers(edgeId).map(x => Math.abs(x));
    let i1, i2;
    i1 = r1 < r2 ? 2 : r1 > r2 ? 0 : c1 < c2 ? 1 : 3;
    i2 = i1 == 0 ? 2 : i1 == 1 ? 3 : i1 == 2 ? 0 : 1;
    return [r1, c1, i1, r2, c2, i2];
  }
  getRelativeDirections(item1, item2) {
    let [r1, c1, r2, c2] = [item1.row, item1.col, item2.row, item2.col];
    let i1, i2;
    i1 = r1 < r2 ? 2 : r1 > r2 ? 0 : c1 < c2 ? 1 : 3;
    i2 = i1 == 0 ? 2 : i1 == 1 ? 3 : i1 == 2 ? 0 : 1;
    return [i1, i2];
  }
  createCellItems() {
    let items = [];
    this.matrix = [];
    for (let r = 0; r < this.rows; r++) {
      this.matrix[r] = [];
      for (let c = 0; c < this.cols; c++) {
        let id = this.getCommonId(r, c);
        let item = { id: id, nid: id, nodeId: id, cellId: this.getCommonIdTable(r, c), row: r, col: c, sz: this.sz, marr: this.m[r, c] };
        delete Items[id];
        iAdd(item, { div: mBy(this.getCommonIdTable(r, c)) });
        items.push(item);
        this.matrix[r][c] = item;
      }
    }
    return items;
  }
  createDiv(dParent, cols, rows, sz, gap = 1) {
    let [wCell, hCell] = [sz, sz];
    let [wTotal, hTotal] = [cols * (wCell + gap) + gap, rows * (hCell + gap) + gap];
    let dGridOuter = this.dMaze = mDiv(dParent, { wmin: wTotal, hmin: hTotal, position: 'relative' });
    let m = this.m;
    let [x, y] = [0, 0];
    let sBorder = `${gap}px solid black`;
    let noBorder = `${gap}px solid transparent`;
    this.dCells = [];
    for (var r = 0; r < m.length; r++) {
      x = 0;
      this.dCells[r] = [];
      for (var c = 0; c < m[r].length; c++) {
        let info = m[r][c];
        let dCell = mDiv(dGridOuter, { w: wCell, h: hCell, position: 'absolute', top: y, left: x, bg: 'gray' });
        dCell.id = this.getCommonIdTable(r, c);
        dCell.style.borderTop = info[0] == 0 ? sBorder : noBorder;
        dCell.style.borderRight = info[1] == 0 ? sBorder : noBorder;
        dCell.style.borderBottom = info[2] == 0 ? sBorder : noBorder;
        dCell.style.borderLeft = info[3] == 0 ? sBorder : noBorder;
        x += wCell + gap;
        this.dCells[r].push(dCell);
      }
      y += hCell + gap;
    }
    return dGridOuter;
  }
  createDiv_orig(dParent, cols, rows, sz, gap) {
    let [wCell, hCell] = [sz, sz];
    let [wTotal, hTotal] = [cols * (wCell + gap), rows * (hCell + gap)];
    let dGridOuter = this.dMaze = mDiv(dParent, { wmin: wTotal, hmin: hTotal });
    let m = this.m;
    let id = 'tMaze';
    setCSSVariable('--wCell', `${wCell}px`);
    setCSSVariable('--hCell', `${hCell}px`);
    let tMaze = createElementFromHtml(`
      <table id="${id}">
      <tbody></tbody>
      </table>
    `);
    mAppend(dGridOuter, tMaze);
    let sBorder = `${1}px solid black`;
    for (var i = 0; i < m.length; i++) {
      $('#tMaze > tbody').append("<tr>");
      for (var j = 0; j < m[i].length; j++) {
        var selector = this.getCommonIdTable(i, j);
        $('#tMaze > tbody').append("<td id='" + selector + "'>&nbsp;</td>");
        if (m[i][j][0] == 0) { $('#' + selector).css('border-top', sBorder); }
        if (m[i][j][1] == 0) { $('#' + selector).css('border-right', sBorder); }
        if (m[i][j][2] == 0) { $('#' + selector).css('border-bottom', sBorder); }
        if (m[i][j][3] == 0) { $('#' + selector).css('border-left', sBorder); }
      }
      $('tMmaze > tbody').append("</tr>");
    }
    return dGridOuter;
  }
  createMaze(cols, rows, sz, gap) {
    var dxy = sz + 2 * gap;
    var offs = dxy / 2 + gap;
    var totalCells = cols * rows;
    var cells = new Array();
    var unvis = new Array();
    for (var i = 0; i < rows; i++) {
      cells[i] = new Array();
      unvis[i] = new Array();
      for (var j = 0; j < cols; j++) {
        cells[i][j] = [0, 0, 0, 0];
        let pos = { x: offs + dxy * j, y: offs + dxy * i };
        this.addNode({ id: this.getCommonId(i, j), row: i, col: j, center: pos }, pos);
        unvis[i][j] = true;
      }
    }
    var currentCell = [Math.floor(Math.random() * rows), Math.floor(Math.random() * cols)];
    var path = [currentCell];
    unvis[currentCell[0]][currentCell[1]] = false;
    var visited = 1;
    while (visited < totalCells) {
      var pot = [[currentCell[0] - 1, currentCell[1], 0, 2],
      [currentCell[0], currentCell[1] + 1, 1, 3],
      [currentCell[0] + 1, currentCell[1], 2, 0],
      [currentCell[0], currentCell[1] - 1, 3, 1]];
      var neighbors = new Array();
      for (var l = 0; l < 4; l++) {
        if (pot[l][0] > -1 && pot[l][0] < rows && pot[l][1] > -1 && pot[l][1] < cols && unvis[pot[l][0]][pot[l][1]]) { neighbors.push(pot[l]); }
      }
      if (neighbors.length) {
        let next = neighbors[Math.floor(Math.random() * neighbors.length)];
        cells[currentCell[0]][currentCell[1]][next[2]] = 1;
        cells[next[0]][next[1]][next[3]] = 1;
        let row = currentCell[0];
        let col = currentCell[1];
        let row2 = next[0];
        let col2 = next[1];
        this.addEdge(this.getCommonId(row, col), this.getCommonId(row2, col2), {});
        unvis[next[0]][next[1]] = false;
        visited++;
        currentCell = [next[0], next[1]];
        path.push(currentCell);
      }
      else {
        currentCell = path.pop();
      }
    }
    return cells;
  }
  setItemBorder(item, dir) {
    let prop = getBorderPropertyForDirection(dir);
    iDiv(item).style[prop] = `${this.gap}px solid black`;
  }
  setItemColor(item, color) { mStyle(iDiv(item), { bg: color }); }
  setItemContent(item, text) { iDiv(item).innerHTML = text; }
  removeItemContent(item) { iDiv(item).innerHTML = ''; }
  disconnectCells(nid1, nid2) {
    this.removeEdge(this.getCommonEdgeId(nid1, nid2));
    let [item1, item2] = [Items[nid1], Items[nid2]];
    let [dir1, dir2] = this.getRelativeDirections(item1, item2);
    this.setItemBorder(item1, dir1);
    this.setItemBorder(item2, dir2);
  }
  cutPath(path, min, max) {
    let edges = path.edges();
    let len = edges.length;
    let [imin, imax] = [Math.floor(len * min), Math.floor(len * max)];
    let i = randomNumber(imin, imax);
    let edge = edges[i];
    let [nid1, nid2] = edge.connectedNodes().map(x => x.id());
    this.disconnectCells(nid1, nid2);
  }
  breadCrumbs(path, color = 'sienna', sz = 10) {
    for (const cell of path.nodes().map(x => Items[x.id()])) {
      mCellContent(iDiv(cell), { w: sz, h: sz, bg: color, fg: 'white', rounding: '50%' });
    }
  }
  colorComponents() {
    let comps = this.getComponents();
    let wheel = getColorWheel('red', comps.length);
    let i = 0;
    for (const comp of comps) {
      this.breadCrumbs(comp, wheel[i]); i += 1;
    }
  }
  showGraph() {
    this.dGraph.style.opacity = 1;
    if (this.hasVisual) { show(this.dGraph); return; }
    this.addVisual(this.dGraph);
    this.storeCurrentPositions();
    this.addLayoutControls(this.sb, ['show', 'hide', 'prest', 'grid', 'klay', 'rand', 'euler', 'reset', 'store']);
  }
  hideGraph() {
    if (isdef(this.dGraph) && this.hasVisual) {
      this.dGraph.style.display = 'none';
    }
  }
}
class Deck1 extends Array {
  initTest(n, shuffled = true) { range(0, n).map(x => this.push(Card52.getItem(x))); if (shuffled) this.shuffle(); }
  initEmpty() { }
  init52(shuffled = true, jokers = 0) {
    range(0, 51 + jokers).map(x => this.push(Card52.getItem(x)));
    if (shuffled) this.shuffle();
  }
  add(otherDeck) { while (otherDeck.length > 0) { this.unshift(otherDeck.pop()); } return this; }
  count() { return this.length; }
  static transferTopFromToBottom(d1, d2) { let c = d1.pop(); d2.putUnderPile(c); return c; }
  deal(n) { return this.splice(0, n); }
  getIndices() { return this.map(x => x.i); }
  log() { console.log(this); }
  putUnderPile(x) { this.push(x); }
  putOnTop(x) { this.unshift(x); }
  showDeck(dParent, splay, ovPercent = 0, faceUp = undefined, contStyles = {}) {
    if (isdef(faceUp)) { if (faceUp == true) this.turnFaceUp(); else this.turnFaceDown(); }
    splayout(this, dParent, contStyles, ovPercent, splay);
  }
  shuffle() { shuffle(this); }
  topCard() { return this[this.length - 1]; }
  turnFaceUp() {
    if (isEmpty(this) || this[0].faceUp) return;
    this.map(x => Card52.turnFaceUp(x));
  }
  turnFaceDown() {
    if (isEmpty(this) || !this[0].faceUp) return;
    this.map(x => Card52.turnFaceDown(x));
  }
}
class SimpleGraph extends AbsGraph1 {
  constructor(dParent, styles = {}) {
    super();
    upgradeToSimpleGraph(this, dParent, styles);
  }
}
class GAbacus extends Game {
  constructor(name, o) { super(name, o); }
  startGame() { this.successFunc = successThumbsUp; this.failFunc = failThumbsDown; this.correctionFunc = this.showCorrectSequence.bind(this); }
  showCorrectSequence() { let t = correctBlanks(); if (this.level <= 1 && (this.step <= 3 || this.op != 'mult')) showSayHint(3); return t + 1000; }
  start_Level() { if (!isList(this.steps)) this.steps = [this.steps]; this.numPics = 2; }
  prompt() {
    mLinebreak(dTable, 2);
    showHiddenThumbsUpDown(110);
    mLinebreak(dTable);
    this.seq = makeExpSequence();
    let panel = mDiv(dTable, { bg: '#00000080', padding: 20, rounding: 10 });
    [this.words, this.letters] = showEquation(this.seq, panel);
    setNumberSequenceGoal();
    mLinebreak(dTable, 30);
    let wr = (this.language == 'E' ? 'calculate' : "rechne");
    let spOp = this.oop.sp; if (this.language == 'D') spOp = DD[spOp];
    let sp = this.operand + ' ' + spOp + ' ' + this.step + ' ?';
    show_instruction(wr, dTitle, sp);
    if (this.level <= 1 && this.showHint && (this.step <= 3 || this.op != 'mult'))
      hintEngineStart(getOperationHintString, [0, 1], 5000 + this.level * 1000);
    this.controller.activateUi.bind(this.controller)();
  }
  trialPrompt() {
    if (this.level <= 1 && this.showHint && (this.step <= 3 || this.op != 'mult')) hintEngineStart(getOperationHintString, [0, 1], 5000 + this.level * 1000);
    TOMain = setTimeout(() => getWrongChars().map(x => unfillChar(x)), 500);
    return 600;
  }
  activate() { addKeyup('G', this.interact.bind(this)); }
  interact(ev) {
    if (!isNumber(ev.key) && ev.key != '-') return;
    clearFleetingMessage();
    if (!canAct()) return;
    let sel = Selected = onKeyWordInput(ev);
    if (nundef(sel)) return;
    let lastInputCharFilled = sel.target;
    console.assert(sel.isMatch == (lastInputCharFilled.letter == sel.ch), lastInputCharFilled, sel.ch);
    if (sel.isMatch && sel.isVeryLast) {
      deactivateFocusGroup();
      this.controller.evaluate.bind(this.controller)(true);
    } else if (sel.isMatch && sel.isLastOfGroup) {
      sel.target.isBlank = false;
      sel.target.group.hasBlanks = false;
      removeInPlace(Goal.blankWords, sel.target.group);
      removeInPlace(Goal.blankChars, sel.target);
      deactivateFocusGroup();
      console.log('haaaaaaaaaaaalo', Goal.isFocus)
    } else if (sel.isMatch) {
      removeInPlace(Goal.blankChars, sel.target);
      sel.target.isBlank = false;
    } else if (sel.isVeryLast) {
      Selected.words = getInputWords();
      Selected.answer = getInputWordString();
      Selected.req = getCorrectWordString();
      deactivateFocusGroup();
      this.controller.evaluate.bind(this.controller)(false);
    } else if (sel.isLastOfGroup) {
      Selected.words = getInputWords();
      Selected.answer = getInputWordString();
      Selected.req = getCorrectWordString();
      deactivateFocusGroup();
      this.controller.evaluate.bind(this.controller)(false);
    } else {
      if (!this.silent) { writeSound(); playSound('incorrect1'); }
      deactivateFocusGroup();
      showFleetingMessage('does NOT fit: ' + Selected.ch, 0, { fz: 24 });
      setTimeout(() => unfillCharInput(Selected.target), 500);
    }
  }
  eval(isCorrect) { return isCorrect; }
}
class GAnagram extends Game {
  constructor(name, o) {
    super(name, o);
    if (this.language == 'C') {
      this.realLanguage = this.language;
      this.language = chooseRandom('E', 'S', 'F', 'D');
    }
  }
  clear() { super.clear(); if (isdef(this.language)) this.language = this.language; }
  start_Level() {
    this.keys = setKeysG(this, filterWordByLengthG, 10);
    if (this.keys.length < 10) { this.keys = setKeysG(this, filterWordByLengthG, 10, 'all'); }
  }
  prompt() {
    myShowPics(null, {}, {});
    if (this.hidden) {
      let d = iDiv(Pictures[0]);
      animate(d, 'aniAppearMinute', 100000);
    }
    setGoal();
    let w = this.showWord ? Goal.label : '';
    let wr = `drag letters to form ${w}`;
    let sp = `form ${w}`;
    show_instruction(wr, dTitle, sp);
    mLinebreak(dTable, 22);
    let word = Goal.label.toUpperCase();
    let wlen = word.length;
    let wTable = getRect(mBy('table')).w;
    let wmax = wTable / wlen;
    let gap = 4;
    let fzMax = wTable / wlen - 3 * gap;
    let fz = Math.min(70, fzMax);
    let dpEmpty = createLetterInputsX(word, dTable, { pabottom: 5, bg: 'grey', display: 'inline-block', fz: fz, w: fz, h: fz * 1.1, margin: gap });
    let inputs = blankInputs(dpEmpty, range(0, wlen - 1), false);
    for (let i = 0; i < inputs.length; i++) {
      let l = iDiv(inputs[i]);
      ipadd(l);
      mClass(l, 'dropzone');
      l.id = 'input' + i;
    }
    this.inputs = inputs;
    let x = mLinebreak(dTable, 35);
    fz = Math.min(60, fzMax);
    let dp = createLetterInputsX(word, dTable, { bg: 'silver', display: 'inline-block', fz: fz, w: fz, h: fz * 1.1, margin: 4 });
    scrambleInputs(dp);
    let letters = Array.from(dp.children);
    for (let i = 0; i < letters.length; i++) {
      let l = letters[i];
      l.setAttribute('draggable', true);
      ipadd(l);
      l.id = 'letter' + i;
    }
    this.letters = letters;
    mLinebreak(dTable, 35);
    this.bDone = mButton('Done!', this.controller.evaluate.bind(this.controller), dTable, { fz: 28, matop: 10, rounding: 10, padding: 16, border: 8 }, ['buttonClass']);
    if (this.hidden) showFleetingMessage('category: ' + Pictures[0].info.subgroup, 5000);
    else if (!this.showWord) { showLabelPercentHintAfter(50, 6000); }
    this.controller.activateUi.bind(this.controller)();
  }
  trialPrompt() {
    sayTryAgain();
    setTimeout(() => {
      this.inputs.map(x => iDiv(x).innerHTML = '_')
    }, 1500);
    return 10;
  }
  eval() {
    let s = this.inputs.map(x => iDiv(x).innerHTML);
    let w = s = s.join('');
    let word = Goal.label.toUpperCase();
    Selected = { answer: w, reqAnswer: word, feedbackUI: iDiv(Goal) };
    return w == word;
  }
  onTimeup() { this.controller.evaluate(); }
}
class GColoku extends Game {
  startGame() {
    this.correctionFunc = () => {
      if (this.qName == 'isThisSudokuCorrect') {
        mStyle(Goal.buttonCorrect, { bg: 'green' });
        animate(Goal.buttonCorrect, 'komisch', 1000);
        if (!Goal.correct) {
          animateColorScale(Goal.correctionFeedbackUI, Goal.item.color, 1.5, 1500);
          this.dComment.innerHTML = 'rule broken! duplicate in ' + Goal.err.type;
        } else {
          this.dComment.innerHTML = 'this coloku is correct!';
        }
      } else {
        this.dWordArea.remove();
        this.bDone.remove();
        if (Goal.err) {
          this.dComment.innerHTML = 'rule broken! duplicate in ' + Goal.err.type;
          animateColorScale(Goal.correctionFeedbackUI, Goal.item.color, 1.5, 1500);
        } else {
          this.dComment.innerHTML = 'Coloku is incomplete!!!!';
        }
      }
      return 20000;
    };
    this.failFunc = () => {
      if (this.qName == 'isThisSudokuCorrect') {
        if (Goal.choice == Goal.correctChoice) { mStyle(Goal.buttonClicked, { bg: 'green' }); mCheckit(Goal.feedbackUI, 100); }
        else { mXit(Goal.buttonClicked, 100); }
      } else {
        mXit(this.dGrid, 200);
      }
    }
    this.successFunc = () => {
      if (this.qName == 'isThisSudokuCorrect') {
        if (Goal.choice == Goal.correctChoice) { mStyle(Goal.buttonClicked, { bg: 'green' }); mCheckit(Goal.feedbackUI, 100); }
        else { mXit(Goal.buttonClicked, 100); }
      } else {
        mCheckit(this.dGrid, 200);
      }
    }
  }
  prompt() {
    this.trials = 1;
    let [rows, cols] = [this.rows, this.cols];
    this.dGrid = mGrid(rows, cols, dTable, { position: 'relative', w: 400, h: 400, gap: 8, bg: 'white' });
    let o = getSudokuPatternFromDB(rows, cols);
    let [pattern, minPuzzle] = [this.pattern, this.minPuzzle] = [o.pattern, o.puzzle];
    mLinebreak(dTable, 20);
    this.dChoices = mDiv(dTable);
    mLinebreak(dTable);
    this.dComment = mDiv(dTable);
    mLinebreak(dTable);
    let qName = this.qName = this.level == 0 && coin() && PROJECTNAME == 'belinda' ? 'isThisSudokuCorrect' : 'solve';
    this[qName]();
    this.controller.activateUi.bind(this.controller)();
  }
  fillGrid(pattern) {
    let items = this.items = [];
    let [rows, cols, dGrid] = [this.rows, this.cols, this.dGrid];
    let colors = this.colors = rows == 4 ? [RED, YELLOW, BLUE, GREEN]
      : rows == 6 ? [RED, YELLOW, BLUE, GREEN, PURPLE, ORANGE]
        : [BLUEGREEN, PURPLE, ORANGE, RED, YELLOW, BLUE, GREEN, LIGHTBLUE, OLIVE];
    shuffle(colors);
    for (let r = 0; r < rows; r++) {
      let arr = [];
      for (let c = 0; c < cols; c++) {
        let nch = pattern[r][c];
        let color = isNumber(nch) ? colors[pattern[r][c]] : null;
        let d = mDiv(dGrid, { bg: color }, getUID());
        let item = { row: r, col: c, id: d.id, color: color, val: nch };
        iAdd(item, { div: d });
        arr.push(item);
      }
      items.push(arr);
    }
    return items;
  }
  makeLines() {
    let [wline, dGrid, sz] = [2, this.dGrid, this.rows];
    let gSize = getSize(dGrid);
    let rh = sz != 9 ? makeRect((gSize.w - wline) / 2, 0, wline, gSize.h) : makeRect((gSize.w - wline) / 3, 0, wline, gSize.h);
    let rv = sz == 4 ? makeRect(0, (gSize.h - wline) / 2, gSize.w, wline) : makeRect(0, (gSize.h - wline) / 3, gSize.w, wline);
    let vLine = mDiv(dGrid, { bg: this.color, position: 'absolute', left: rh.l, top: rh.t, w: rh.w, h: rh.h });
    if (sz == 9) vLine = mDiv(dGrid, { bg: this.color, position: 'absolute', left: rh.l * 2, top: rh.t, w: rh.w, h: rh.h });
    let hLine = mDiv(dGrid, { bg: this.color, position: 'absolute', left: rv.l, top: rv.t, w: rv.w, h: rv.h });
    if (sz != 4) vLine = mDiv(dGrid, { bg: this.color, position: 'absolute', left: rv.l, top: 2 * rv.t, w: rv.w, h: rv.h });
  }
  setGoal(pattern) {
    let err = checkSudokuRule(pattern);
    let incomplete = false;
    for (const el of arrFlatten(pattern)) {
      if (!isNumber(el)) { incomplete = true; break; }
    }
    let answer = (err == null) && !incomplete;
    Goal = { correct: answer, err: err, incomplete: incomplete };
  }
  isThisSudokuCorrect() {
    this.trials = 1;
    let [pattern, rows, cols, dGrid] = [this.pattern, this.rows, this.cols, this.dGrid];
    destroySudokuRule(pattern, rows, cols);
    this.setGoal(pattern);
    let items = this.fillGrid(pattern);
    this.makeLines();
    let wsp = {
      D: 'ist dieses coloku korrekt?',
      E: 'is this coloku correct?',
      S: 'es este coloku correcto?',
      F: 'est ce que ce coloku est exacte?',
    };
    let sp = wsp[this.language];
    show_instruction(sp, dTitle, sp);
    showFleetingMessage('rule: each color must be unique in every row, column and quadrant!', 15000);
    let correct, incorrect;
    if (Goal.correct) { correct = { num: 1, text: 'yes' }; incorrect = [{ num: 0, text: 'no' }]; }
    else { correct = { num: 0, text: 'no' }; incorrect = [{ num: 1, text: 'yes' }]; }
    let feedbackUI = Goal.correctionFeedbackUI = Goal.correct ? this.dGrid : iDiv(this.items[Goal.err.row][Goal.err.col]);
    createMultipleChoiceElements(correct, incorrect, this.dChoices, feedbackUI, {});
    Goal.item = Goal.correct ? this.items[0] : this.items[Goal.err.row][Goal.err.col];
  }
  solve() {
    let [rrand, crand] = [randomNumber(0, this.rows - 1), randomNumber(0, this.cols - 1)];
    let puzzle = this.puzzle = jsCopy(this.pattern);
    let [min, rows, cols] = [this.minPuzzle, this.rows, this.cols];
    let combis = [];
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (min[r][c] === ' ') combis.push({ row: r, col: c });
      }
    }
    let combisToRemove = choose(combis, this.numMissing);
    for (const o of combisToRemove) {
      puzzle[o.row][o.col] = ' ';
    }
    this.fillGrid(puzzle);
    this.makeLines();
    let sp = 'solve this coloku!'
    show_instruction(sp, dTitle, sp);
    let itemlist = this.itemlist = arrFlatten(this.items);
    let containers = this.containers = itemlist.filter(x => x.val === ' ');
    let dWordArea = this.dWordArea = mDiv(dTable, { h: 70, display: 'flex', 'flex-wrap': 'wrap', layout: 'fhcc' });
    let colorItems = this.colorItems = [];
    for (const color of this.colors) {
      let colorItem = { id: getUID(), color: color };
      let d = mDiv(dWordArea, { w: 40, h: 40, bg: color, margin: 10, cursor: 'pointer' }, colorItem.id);
      iAdd(colorItem, { div: d });
      colorItems.push(colorItem);
    }
    enableDD(colorItems, containers, this.dropHandler.bind(this), true);
    mLinebreak(dTable, 50);
    this.bDone = mButton('Done!', this.controller.evaluate.bind(this.controller), dTable, { fz: 28, matop: 10, rounding: 10, padding: 16, border: 8 }, ['buttonClass']);
  }
  dropHandler(source, target, isCopy = true) {
    let dSource = iDiv(source);
    let dTarget = iDiv(target);
    mStyle(dTarget, { bg: source.color });
    target.color = source.color;
    target.val = this.colors.indexOf(source.color);
  }
  evalIsCorrect() {
    Selected = { feedbackUI: Goal.buttonClicked };
    return Goal.buttonClicked == Goal.buttonCorrect;
  }
  evalSolve() {
    let [items, pattern, rows, cols] = [this.items, this.pattern, this.rows, this.cols];
    let pat = items.map(x => x.map(y => y.val));
    this.setGoal(pat);
    if (Goal.err) {
      Goal.correctionFeedbackUI = iDiv(this.items[Goal.err.row][Goal.err.col]);
      Goal.item = this.items[Goal.err.row][Goal.err.col];
    }
    Selected = { feedbackUI: this.dGrid };
    return Goal.correct;
  }
  eval() {
    clearFleetingMessage();
    return this.qName == 'solve' ? this.evalSolve() : this.evalIsCorrect();
  }
  onTimeup() { this.controller.evaluate(); }
}
class GCats extends Game {
  constructor(name, o) { super(name, o); }
  startGame() { this.correctionFunc = showCorrectPictureLabels; this.failFunc = failSomePictures; }
  dropHandler(source, target, isCopy = true) {
    let dSource = iDiv(source);
    let dTarget = iDiv(target);
    if (!isCopy) {
      mAppend(dTarget, dSource);
    } else {
      let dNew = mText(dSource.innerHTML, dTarget, { wmin: 100, fz: 20, padding: 4, margin: 4, display: 'inline-block' });
      addDDSource(dNew, false);
    }
    if (isOverflown(dTarget)) {
      let d = dTarget.parentNode;
      let r = getRect(d);
      let w = r.w + 100;
      mSize(d, w, r.h);
      console.log('overflow!!!!', r.w, '=>', w)
    }
  }
  prompt() {
    let items;
    let data = this.keysByCat = genCats(this.numCats);
    this.keylists = [], this.catsByKey = {};
    for (const cat in data) {
      this.keylists.push({ keys: data[cat], cat: cat });
      for (const k of data[cat]) {
        this.catsByKey[k] = cat;
      }
    }
    this.cats = Object.keys(this.keysByCat);
    this.allKeys = Object.keys(this.catsByKey);
    this.options = {}; _extendOptions(this.options);
    if (this.pickRandom == false) {
      items = Pictures = getNItemsPerKeylist(this.numPics, this.keylists, this.options);
    } else {
      let keys = choose(this.allKeys, this.numPics * this.numCats);
      items = Pictures = genItemsFromKeys(keys, this.options);
      items.map(x => x.cat = this.catsByKey[x.key]);
    }
    shuffle(items);
    let wr = this.language == 'E' ? 'drag pictures to categories' : "ordne die bilder in kategorien";
    show_instruction(wr, dTitle, wr);
    mLinebreak(dTable);
    let dArea = mDiv(dTable, { display: 'flex', 'flex-wrap': 'wrap' });
    let containers, dWordArea;
    containers = this.containers = createContainers(this.cats, dArea, { w: 'auto', wmin: 150, wmax: 300, hmin: 250, fz: 24, fg: 'contrast' });
    mLinebreak(dTable);
    dWordArea = this.dWordArea = mDiv(dTable, { h: 70, display: 'flex', 'flex-wrap': 'wrap', layout: 'fhcc' });
    for (const item of items) { let d = miPic(item, dWordArea); iAdd(item, { div: d }); }
    enableDD(items, containers, this.dropHandler.bind(this), false);
    mLinebreak(dTable, 50);
    mButton('Done!', this.controller.evaluate.bind(this.controller), dTable, { fz: 28, matop: 10, rounding: 10, padding: 16, border: 8 }, ['buttonClass']);
    this.controller.activateUi.bind(this.controller)();
  }
  trialPrompt() {
    sayTryAgain();
    TOMain = setTimeout(() => {
      for (const p of Pictures) {
        if (!p.isCorrect) {
          mAppend(this.dWordArea, iDiv(p));
          if (this.trialNumber == 1) miAddLabel(p, { bg: '#00000080', margin: 4, fz: 20 });
        }
      }
    }, 1000);
    return 1200;
  }
  eval() {
    this.piclist = Pictures;
    Selected = { piclist: this.piclist, feedbackUI: this.piclist.map(x => iDiv(x)), sz: getRect(iDiv(this.piclist[0])).h };
    let isCorrect = true;
    for (const p of Pictures) {
      let label = p.label;
      let d = iDiv(p);
      let cont = d.parentNode;
      for (const c of this.containers) {
        if (iDiv(c) == cont) {
          p.classified = true;
          if (p.cat == c.label) p.isCorrect = true;
          else { p.isCorrect = isCorrect = false; }
          break;
        }
      }
      if (!p.classified) p.isCorrect = isCorrect = false;
    }
    return isCorrect;
  }
}
class GElim extends Game {
  constructor(name, o) { super(name, o); }
  startGame() {
    this.correctionFunc = () => { writeSound(); playSound('incorrect1'); return this.spokenFeedback ? 1800 : 300; };
    this.successFunc = () => { Goal.pics.map(x => iDiv(x).style.opacity = .3); successPictureGoal(); }
  }
  start_Level() {
    super.start_Level();
    this.keys = this.keys.filter(x => containsColorWord(x));
  }
  prompt() {
    this.piclist = [];
    let colorKeys = this.numColors > 1 ? choose(this.colors, this.numColors) : null;
    let showRepeat = this.numRepeat > 1;
    let rows = this.numColors > 1 ? this.numColors : undefined;
    myShowPics(this.interact.bind(this), { bg: 'white' },
      {
        showRepeat: showRepeat, colorKeys: colorKeys, numRepeat: this.numRepeat,
        contrast: this.contrast, rows: rows
      });
    let [sSpoken, sWritten, piclist] = logicMulti(Pictures);
    this.piclist = piclist;
    Goal = { pics: this.piclist, sammler: [] };
    show_instruction(sWritten, dTitle, sSpoken, { fz: 22, voice: 'zira' });
    this.controller.activateUi.bind(this.controller)();
  }
  trialPrompt() {
    sayTryAgain();
    let msg = this.language == 'D' ? 'noch einmal!' : 'try again!'
    showFleetingMessage(msg, 0, { margin: -8, fz: 22 }, true);
    return 1000;
  }
  activate() {
    for (const p of this.piclist) { if (p.isSelected) toggleSelectionOfPicture(p); }
    this.piclist = [];
  }
  interact(ev) {
    ev.cancelBubble = true;
    if (!canAct()) return;
    let pic = findItemFromEvent(Pictures, ev);
    writeSound(); playSound('hit');
    if (Goal.pics.includes(pic)) {
      removePicture(pic);
      Goal.sammler.push(pic);
    }
    if (Goal.pics.length == Goal.sammler.length) this.controller.evaluate.bind(this.controller)(true);
    else if (!Goal.pics.includes(pic)) { this.lastPic = pic; this.controller.evaluate.bind(this.controller)(false); }
  }
  eval(isCorrect) {
    Selected = { piclist: this.piclist, feedbackUI: isCorrect ? Goal.pics.map(x => iDiv(x)) : iDiv(this.lastPic) };
    return isCorrect;
  }
}
class GHouse extends Game {
  constructor(name, o) { super(name, o); }
  startGame() {
    this.correctionFunc = () => {
      mStyle(Goal.buttonCorrect, { bg: 'green' });
      animate(Goal.buttonCorrect, 'komisch', 1000);
      mStyle(this.dGraph, { opacity: 1 });
      return 20000;
    };
    this.failFunc = () => {
      if (Goal.choice == Goal.correctChoice) { mStyle(Goal.buttonClicked, { bg: 'green' }); mCheckit(Goal.feedbackUI, 100); }
      else { mXit(Goal.buttonClicked, 100); }
      mStyle(this.dGraph, { opacity: 1 });
    }
    this.successFunc = () => {
      if (Goal.choice == Goal.correctChoice) { mStyle(Goal.buttonClicked, { bg: 'green' }); mCheckit(Goal.feedbackUI, 100); }
      else { mXit(Goal.buttonClicked, 100); }
      mStyle(this.dGraph, { opacity: 1 });
    }
  }
  prompt() {
    if (isdef(this.graph)) this.graph.clear();
    this.trials = 1;
    let n = randomNumber(this.minRooms, this.maxRooms);
    //#region selectQuestion
    let qFuncs = [this.areRoomsConnected.bind(this)];
    if (n > 5) qFuncs.push(this.isThereAPath.bind(this));
    let q = this.q = this.level > 1 ? arrLast(qFuncs) : chooseRandom(qFuncs);
    //#endregion
    //#region make house
    let s = n;
    let wTotal = n < 4 || n > 12 ? 700 : n > 10 ? 600 : 500;
    let dGridOuter = mDiv(dTable, { wmin: wTotal, hmin: 400 });
    let house = this.house = iHouse(dGridOuter, s, { w: wTotal, h: 400 });
    let rooms = this.rooms = house.rooms.map(x => Items[x]);
    this.addLabelsToRooms();
    //#endregion
    //#region add doors
    let dirs = coin() ? ['n', 'w'] : ['s', 'e'];
    let doors = this.doors = [];
    for (const r of rooms) {
      let dir = coin() ? dirs[0] : dirs[1];
      let door = iDoor(r.id, dir);
      doors.push(door);
    }
    if (q.name.includes('Path')) hideOuterDoors(house);
    //#endregion
    //#region prep container for multiple choices
    mLinebreak(dTable, 20);
    this.dChoices = mDiv(dTable);
    mLinebreak(dTable);
    //#endregion
    //#region make graph container
    let r = getRect(dGridOuter);
    mStyle(dGridOuter, { position: 'relative' });
    let dGraph = this.dGraph = mDiv(dGridOuter, { box: true, align: 'left', position: 'absolute', bg: '#ffffff80', top: 0, left: 0, w: r.w, h: r.h });
    //#endregion
    let innerStyles = { box: true, align: 'left', position: 'absolute', bg: '#ffffff80', top: 0, left: 0, w: r.w, h: r.h };
    let g1 = this.graph = new UIGraph(dGraph, { edge: { bg: 'blue' }, outer: { align: 'left', w: wTotal, h: 400 }, inner: innerStyles });
    convertToGraphElements(g1, house);
    g1.presetLayout();
    g1.reset();
    mStyle(dGraph, { opacity: 0 });
    q();
    this.controller.activateUi.bind(this.controller)();
  }
  //#region qFuncs
  isThereAPath() {
    let house = this.house;
    let corners = getCornerRoomsDict(house);
    let clist = Object.values(corners);
    let g = this.graph;
    let id = g.getNodeWithMaxDegree(clist);
    let cornerRoomIds = g.sortNodesByDegree(clist).map(x => x.id());
    let [r1, r2] = [Items[cornerRoomIds[0]], Items[cornerRoomIds[1]]];
    if (r1 == r2 || areNeighbors(r1, r2) && cornerRoomIds.length > 2) r2 = Items[cornerRoomIds[2]];
    if (!r1.isW && (r2.isW || !r1.N)) [r1, r2] = [r2, r1];
    let roomFrom = r1.id;
    let funcs = this.dijkstra = g.getShortestPathsFrom(roomFrom);
    let roomTo = r2.id;
    for (const k in corners) {
      if (k != 'NW') {
        let dist = funcs.distanceTo('#' + corners[k]);
        if (dist != Infinity && dist >= 3) {
          roomTo = corners[k];
          break;
        }
      }
    }
    if (!roomTo) { roomTo = corners.SE; }
    //#region spoken and written instruction
    this.roomFrom = roomFrom;
    this.roomTo = roomTo;
    let sp1 = {
      D: ['gibt es einen weeg von', 'gibt es einen weg von'],
      E: ['is there a path from', 'is there a path from'],
      S: ['hay un camino de', 'hay un camino de'],
      F: ["y a 'til un chemin de", "y a 'til un chemin de"],
    };
    let sp2 = {
      D: ['zu', 'zu'],
      E: ['to', 'to'],
      S: ['a', 'a'],
      F: ['!. a! ', 'à'],
    };
    let fill1 = [`. "${Items[roomFrom].id.toUpperCase()}"! `, ` ${Items[roomFrom].id} `];
    let fill2 = [`. "${Items[roomTo].id.toUpperCase()}"`, ` ${Items[roomTo].id}`];
    let l = 'E';
    let sp = sp1[l][0] + fill1[0] + sp2[l][0] + fill2[0] + '?';
    let wr = sp1[l][1] + fill1[1] + sp2[l][1] + fill2[1] + '?';
    let voice = this.language == 'E' ? coin() ? 'ukMale' : 'zira' : this.language;
    //#endregion
    show_instruction(wr, dTitle, sp, { voice: voice });
    let answer = funcs.distanceTo('#' + roomTo) != Infinity;
    let correct, incorrect;
    if (answer) { correct = { num: 1, text: 'yes' }; incorrect = [{ num: 0, text: 'no' }]; }
    else { correct = { num: 0, text: 'no' }; incorrect = [{ num: 1, text: 'yes' }]; }
    createMultipleChoiceElements(correct, incorrect, this.dChoices, iDiv(this.house), {});
  }
  howMany() {
    let wr = this.language == 'E' ? 'how many units are there in this house?' : "wieviele wohneinheiten hat dieses haus?";
    show_instruction(wr, dTitle, wr);
    let numUnits = this.graph.getNumComponents();
    let otherChoices = [
      numUnits * 2,
      Math.round(numUnits / 2),
      numUnits + randomNumber(1, 10)
    ];
    let di = {};
    for (let i = 0; i < otherChoices.length; i++) {
      let n = otherChoices[i];
      while (n == numUnits || isdef(di[n])) { n += 1; }
      di[n] = true;
      otherChoices[i] = n;
    }
    createMultipleChoiceElements({ num: numUnits, text: numUnits },
      otherChoices.map(x => ({ num: x, text: x })), this.dChoices, iDiv(this.house), {});
  }
  areRoomsConnected() {
    let wr = this.language == 'E' ? 'are all rooms connected?' : "sind alle zimmer verbunden?";
    showInstruction(wr, dTitle, wr);
    let numUnits = this.graph.getNumComponents();
    let correct, incorrect;
    if (numUnits == 1) { correct = { num: 1, text: 'yes' }; incorrect = [{ num: 0, text: 'no' }]; }
    else { correct = { num: 0, text: 'no' }; incorrect = [{ num: 1, text: 'yes' }]; }
    createMultipleChoiceElements(correct, incorrect, this.dChoices, iDiv(this.house), {});
  }
  //#region helpers
  showPath() {
    mStyle(this.dGraph, { opacity: 1 });
  }
  //#region add stuff to house
  addLabelsToRooms() {
    let roomlist = ['bedroom', 'livingroom', 'bathroom', 'kitchen'];
    sortByFunc(this.rooms, x => x.rect.w * x.rect.h);
    this.rooms.map(x => addLabel(x, x.ch, {}));
  }
  addOneDoorPerRoom(directions) {
    for (const r of this.rooms) {
      let door = makeRandomDoor(r, this.house, directions); this.doors.push(door);
    }
  }
  addWallFinderByMouseClick() {
    dTable.onclick = ev => {
      console.log(ev.clientX, ev.clientY);
      let w = findWall(ev.clientX, ev.clientY, this.walls);
      console.log('found wall', w)
    }
  }
  addFurnitureItems() {
    let keys = ['bed', 'bathtub', 'chair', 'couch and lamp', 'toilet', 'door', 'table'];
    let items = Pictures = genItemsFromKeys(keys);
    console.assert(arrLast(items).key == 'table', 'NOOOOOOO');
    let itable = arrLast(items);
    shuffle(items);
    let dWordArea = this.dWordArea = mDiv(dTable, { h: 70, display: 'flex', 'flex-wrap': 'wrap', layout: 'fhcc' });
    for (const item of items) { let d = miPic(item, dWordArea); iAdd(item, { div: d }); }
    mStyle(iDiv(itable), { fg: BROWN });
    enableDD(items, rooms, this.dropHandler.bind(this), false);
  }
  //#endregion
  eval() {
    clearFleetingMessage();
    Selected = { reqAnswer: G.correctAnswer, answer: Goal.choice.text, feedbackUI: Goal.buttonClicked };
    return (Goal.buttonClicked == Goal.buttonCorrect);
  }
}
class GMaze extends Game {
  constructor(name, o) { super(name, o); }
  clear() { super.clear(); if (isdef(this.cy)) { this.cy.destroy(); } }
  startGame() {
    this.correctionFunc = () => {
      mStyle(Goal.buttonCorrect, { bg: 'green' });
      animate(Goal.buttonCorrect, 'komisch', 1000);
      if (Goal.correctChoice.text == 'yes') this.maze.breadCrumbs(this.path); else this.maze.colorComponents();
      return 20000;
    };
    this.failFunc = () => {
      if (Goal.choice == Goal.correctChoice) { mStyle(Goal.buttonClicked, { bg: 'green' }); mCheckit(Goal.feedbackUI, 100); }
      else { mXit(Goal.buttonClicked, 100); }
    }
    this.successFunc = () => {
      if (Goal.choice == Goal.correctChoice) { mStyle(Goal.buttonClicked, { bg: 'green' }); mCheckit(Goal.feedbackUI, 100); }
      else { mXit(Goal.buttonClicked, 100); }
    }
  }
  startRound() { if (isdef(this.cy)) this.cy.destroy(); clearElement(dTable); }
  prompt() {
    this.trials = 1;
    let maze = this.maze = new MazeGraph(dTable, this.rows, this.cols, this.sz, this.gap);
    this.cy = maze.cy;
    mLinebreak(dTable, 20);
    this.dChoices = mDiv(dTable);
    mLinebreak(dTable);
    this.isThereAPath(maze);
    this.controller.activateUi.bind(this.controller)();
  }
  isThereAPath(maze) {
    let cellStart = maze.getTopLeftCell();
    mCellContent(iDiv(cellStart), { w: '50%', h: '50%', fz: '60%', bg: 'green', fg: 'white', rounding: '50%' }, 'A');
    let cellGoal = maze.getBottomRightCell();
    mCellContent(iDiv(cellGoal), { w: '50%', h: '50%', fz: '60%', bg: 'red', fg: 'white', rounding: '50%' }, 'B');
    [this.roomFrom, this.roomTo] = [cellStart.nodeId, cellGoal.nodeId];
    //#region spoken and written instruction
    let sp1 = {
      D: ['gibt es einen weeg von', 'gibt es einen weg von'],
      E: ['is there a path from', 'is there a path from'],
      S: ['hay un camino de', 'hay un camino de'],
      F: ["y a 'til un chemin de", "y a 'til un chemin de"],
    };
    let sp2 = {
      D: ['zu', 'zu'],
      E: ['to', 'to'],
      S: ['a', 'a'],
      F: ['!. a! ', 'à'],
    };
    let fill1 = [`. "A"! `, ` A `];
    let fill2 = [`. "B"`, ` B`];
    let l = this.language;
    let sp = sp1[l][0] + fill1[0] + sp2[l][0] + fill2[0] + '?';
    let wr = sp1[l][1] + fill1[1] + sp2[l][1] + fill2[1] + '?';
    let voice = this.language == 'E' ? coin() ? 'ukMale' : 'zira' : this.language;
    show_instruction(wr, dTitle, sp, { voice: voice });
    //#endregion
    let path = this.path = maze.getShortestPathFromTo(this.roomFrom, this.roomTo);
    console.assert(path.length < Infinity, 'WAAAAAAAAAAAAAAS?');
    if (coin(this.level > 2 ? 50 : 40)) maze.cutPath(this.path, .5, .75);
    let len = maze.getLengthOfShortestPath(this.roomFrom, this.roomTo);
    let answer = len != Infinity;
    let correct, incorrect;
    if (answer) { correct = { num: 1, text: 'yes' }; incorrect = [{ num: 0, text: 'no' }]; }
    else { correct = { num: 0, text: 'no' }; incorrect = [{ num: 1, text: 'yes' }]; }
    createMultipleChoiceElements(correct, incorrect, this.dChoices, maze.dMaze, {});
  }
  eval() {
    clearFleetingMessage();
    Selected = { reqAnswer: G.correctAnswer, answer: Goal.choice.text, feedbackUI: Goal.buttonClicked };
    return (Goal.buttonClicked == Goal.buttonCorrect);
  }
}
class GMem extends Game {
  constructor(name, o) { super(name, o); }
  clear() { clearTimeout(this.TO); showMouse(); }
  prompt() {
    this.trials = 1;
    myShowPics(this.interact.bind(this),
      { border: '3px solid #ffffff80' },
      {});
    setGoal();
    let wr = (this.language == 'E' ? 'remember ' : 'merke dir ') + (this.level > 2 ? (this.language == 'E' ? 'all' : 'alle') : Goal.label);
    show_instruction(wr, dTitle, wr);
    let secs = calcMemorizingTime(this.numPics, this.level > 2);
    hideMouse();
    TOMain = setTimeout(() => turnCardsAfter(secs), 300, this.level >= 5);
  }
  interact(ev) {
    ev.cancelBubble = true;
    if (!canAct()) return;
    let pic = findItemFromEvent(Pictures, ev);
    turnFaceUpSimple(pic);
    if (this.trialNumber == this.trials - 1) turnFaceUpSimple(Goal);
    TOMain = setTimeout(() => this.controller.evaluate.bind(this.controller)(ev), 300);
  }
}
class GMissingLetter extends Game {
  constructor(name, o) { super(name, o); }
  start_Level() {
    super.start_Level();
    this.maxPosMissing = this.posMissing == 'start' ? this.numMissing - 1 : 100;
  }
  prompt() {
    myShowPics(() => fleetingMessage('just enter the missing letter!'));
    setGoal();
    if (this.instruction == 'all') {
      let wr = (this.language == 'E' ? 'complete ' : "ergänze ") + `<b>${Goal.label.toUpperCase()}</b>`;
      let sp = (this.language == 'E' ? 'complete ' : "ergänze ") + `${Goal.label}`;
      show_instruction(wr, dTitle, sp);
    } else if (this.instruction == 'spokenGoal') {
      let wr = this.language == 'E' ? 'complete the word' : "ergänze das wort";
      let sp = (this.language == 'E' ? 'complete' : "ergänze") + ' ' + Goal.label;
      show_instruction(wr, dTitle, sp);
    } else {
      let wr = this.language == 'E' ? 'complete the word' : "ergänze das wort";
      show_instruction(wr, dTitle, wr);
    }
    mLinebreak(dTable, 20);
    let style = { margin: 6, fg: 'white', display: 'inline', bg: 'transparent', align: 'center', border: 'transparent', outline: 'none', family: 'Consolas', fz: 80 };
    let d = createLetterInputs(Goal.label.toUpperCase(), dTable, style);
    let indices = getIndicesCondi(Goal.label, (x, i) => isAlphaNum(x) && i <= this.maxPosMissing);
    this.nMissing = Math.min(indices.length, this.numMissing);
    let ilist = choose(indices, this.nMissing); sortNumbers(ilist);
    this.inputs = [];
    for (const idx of ilist) {
      let inp = d.children[idx];
      inp.innerHTML = '_';
      mClass(inp, 'blink');
      this.inputs.push({ letter: Goal.label[idx].toUpperCase(), div: inp, index: idx });
    }
    mLinebreak(dTable);
    let msg = this.composeFleetingMessage();
    let ms = this.instruction == 'all' ? 3000 : this.instruction == 'spokenGoal' ? 9000 : 15000;
    showFleetingMessage(msg, ms);
    this.controller.activateUi.bind(this.controller)();
  }
  trialPrompt() {
    let selinp = Selected.inp;
    sayTryAgain();
    TOMain = setTimeout(() => {
      let d = selinp.div;
      d.innerHTML = '_';
      mClass(d, 'blink');
    }, 1200);
    showFleetingMessage(this.composeFleetingMessage(), 3000);
    return 1500;
  }
  activate() {
    addKeyup('G', ev => {
      if (!isLetter(ev.key)) return;
      clearFleetingMessage();
      if (!canAct()) return;
      let charEntered = ev.key.toString();
      if (!isAlphaNum(charEntered)) return;
      Selected = { lastLetterEntered: charEntered.toUpperCase() };
      if (this.nMissing == 1) {
        let d = Selected.feedbackUI = this.inputs[0].div;
        Selected.positiveFeedbackUI = iDiv(Goal);
        Selected.lastIndexEntered = this.inputs[0].index;
        Selected.inp = this.inputs[0];
        d.innerHTML = Selected.lastLetterEntered;
        mRemoveClass(d, 'blink');
        let result = buildWordFromLetters(mParent(d));
        this.controller.evaluate.bind(this.controller)(result);
      } else {
        let ch = charEntered.toUpperCase();
        for (const inp of this.inputs) {
          if (inp.letter == ch) {
            Selected.lastIndexEntered = inp.index;
            Selected.inp = inp;
            let d = Selected.feedbackUI = inp.div;
            d.innerHTML = ch;
            mRemoveClass(d, 'blink');
            removeInPlace(this.inputs, inp);
            this.nMissing -= 1;
            break;
          }
        }
        if (nundef(Selected.lastIndexEntered)) {
          showFleetingMessage('you entered ' + Selected.lastLetterEntered);
          sayRandomVoice('try a different letter!', 'anderer Buchstabe!')
        }
        showFleetingMessage(this.composeFleetingMessage(), 3000);
      }
    })
  }
  eval(word) {
    let answer = normalize(word, this.language);
    let reqAnswer = normalize(Goal.label, this.language);
    Selected.reqAnswer = reqAnswer;
    Selected.answer = answer;
    if (answer == reqAnswer) return true;
    else if (this.language == 'D' && fromUmlaut(answer) == fromUmlaut(reqAnswer)) {
      return true;
    } else {
      return false;
    }
  }
  composeFleetingMessage() {
    let lst = this.inputs;
    let msg = lst.map(x => x.letter).join(',');
    let edecl = lst.length > 1 ? 's ' : ' ';
    let ddecl = lst.length > 1 ? 'die' : 'den';
    let s = (this.language == 'E' ? 'Type the letter' + edecl : 'Tippe ' + ddecl + ' Buchstaben ');
    return s + msg;
  }
}
class GNamit extends Game {
  constructor(name, o) { super(name, o); }
  startGame() { this.correctionFunc = showCorrectPictureLabels; this.failFunc = failSomePictures; }
  prompt() {
    this.showLabels = false;
    myShowPics(null, {}, { rows: 1 });
    Pictures.map(x => x.correctLabel = x.label);
    Goal = { pics: Pictures };
    let wr = this.language == 'E' ? 'drag labels to pictures' : "ordne die texte den bildern zu";
    show_instruction(wr, dTitle, wr);
    mLinebreak(dTable);
    mLinebreak(dTable, 50);
    let keys = Pictures.map(x => x.key);
    shuffle(keys);
    G.showLabels = true;
    let titems = this.letters = myShowLabels(null, undefined, { rows: 1, showLabels: true }, keys);
    titems.map(x => iDiv(x).style.cursor = 'pointer');
    mLinebreak(dTable, 50);
    enableDD(this.letters, Pictures, this.dropHandler.bind(this), true, false, null);
    mButton('Done!', this.controller.evaluate.bind(this.controller), dTable, { fz: 32, matop: 10, rounding: 10, padding: 16, border: 8 }, ['buttonClass']);
    this.controller.activateUi.bind(this.controller)();
  }
  dropHandler(source, target, isCopy = true) {
    let dSource = iDiv(source);
    let dTarget = iDiv(target);
    console.log('dropped', source, 'onto', target);
    let label = iLabel(target);
    console.log('label', label);
    let div = iDiv(target);
    console.log('div', div);
    addLabel(target, source.label, {});
  }
  trialPrompt() {
    this.failFunc();
    sayTryAgain();
    TOMain = setTimeout(() => { removeMarkers(); Pictures.map(x => removeLabel(x)) }, 1200);
    return 1500;
  }
  eval() {
    console.log('eval in Namit!!!!!')
    this.piclist = Pictures;
    Selected = { piclist: this.piclist, feedbackUI: this.piclist.map(x => iDiv(x)), sz: getRect(iDiv(this.piclist[0])).h };
    let isCorrect = true;
    for (const p of Pictures) {
      let correctLabel = p.correctLabel;
      console.log('correctLabel', correctLabel, p.label);
      let dLabel = iLabel(p);
      console.log('dLabel', dLabel);
      if (nundef(dLabel) || p.label != correctLabel) p.isCorrect = isCorrect = false;
      else p.isCorrect = true;
    }
    return isCorrect;
  }
}
class GPremem extends Game {
  constructor(name, o) { super(name, o); this.piclist = []; }
  prompt() {
    this.piclist = [];
    this.showLabels = false;
    myShowPics(this.interact.bind(this), { border: '3px solid #ffffff80' }, {});
    let wr = this.language == 'E' ? 'click any picture' : 'click irgendein Bild';
    show_instruction(wr, dTitle, wr);
    this.controller.activateUi.bind(this.controller)();
  }
  trialPrompt() {
    for (const p of this.piclist) { toggleSelectionOfPicture(p); }
    this.piclist = [];
    show_instruction('try again: click any picture', dTitle, 'try again: click any picture');
    return 10;
  }
  interact(ev) {
    ev.cancelBubble = true;
    if (!canAct()) return;
    let pic = findItemFromEvent(Pictures, ev);
    if (!isEmpty(this.piclist) && this.piclist.length < this.numRepeat - 1 && this.piclist[0].label != pic.label) return;
    toggleSelectionOfPicture(pic, this.piclist);
    if (isEmpty(this.piclist)) {
      let wr = this.language == 'E' ? 'click any picture' : 'click irgendein Bild';
      show_instruction(wr, dTitle, wr);
    } else if (this.piclist.length < this.numRepeat - 1) {
      let wr = (this.language == 'E' ? 'click another ' : 'click ein andres Bild mit ');
      show_instruction(wr + `<b>${pic.label.toUpperCase()}</b>`, dTitle, wr + pic.label);
    } else if (this.piclist.length == this.numRepeat - 1) {
      let picGoal = firstCond(Pictures, x => x.label == pic.label && !x.isSelected);
      setGoal(picGoal.index);
      let wr = (this.language == 'E' ? 'click the ' + (this.numRepeat == 2 ? 'other ' : 'last ')
        : 'click das ' + (this.numRepeat == 2 ? 'andere ' : 'letzte ') + ' Bild mit')
      show_instruction(wr + `<b>${picGoal.label.toUpperCase()}</b>`, dTitle, wr + picGoal.label);
    } else {
      this.controller.evaluate.bind(this.controller)(this.piclist);
    }
  }
  eval(piclist) {
    Selected = { piclist: piclist, feedbackUI: piclist.map(x => iDiv(x)), sz: getRect(iDiv(piclist[0])).h };
    let req = Selected.reqAnswer = piclist[0].label;
    Selected.answer = piclist[piclist.length - 1].label;
    if (Selected.answer == req) { return true; } else { return false; }
  }
}
class GRiddle extends Game {
  constructor(name, o) { super(name, o); }
  startGame() {
    this.successFunc = successThumbsUp; this.failFunc = failThumbsDown;
    this.correctionFunc = () => {
      mStyle(Goal.buttonCorrect, { bg: 'green' });
      animate(Goal.buttonCorrect, 'komisch', 1000);
      return 20000;
    };
  }
  prompt() {
    this.trials = 1;
    show_instruction('Solve the Riddle:', dTitle, 'Solve the Riddle:');
    let wp = this.wp = getRandomWP(this.minIndex, this.maxIndex);
    let haveResult = wp.isTextResult = instantiateNames(wp);
    if (!haveResult) instantiateNumbers(wp);
    mLinebreak(dTable, 2);
    showHiddenThumbsUpDown(90);
    mLinebreak(dTable);
    let dArea = this.textArea = mDiv(dTable, { w: '70%' });
    let d = mText(wp.text, dArea, { fz: 28 });
    mLinebreak(dTable, 20);
    let dResult = this.dResult = mDiv(dTable);
    Goal = { label: wp.result.text };
    this.createMultipleChoiceElements();
    mLinebreak(dTable);
    this.controller.activateUi.bind(this.controller)();
  }
  createMultipleChoiceElements() {
    let wp = this.wp;
    let choices = [], nums = [], texts = [];
    if (wp.isTextResult == true) {
      texts = Object.values(wp.diNames);
      for (let i = 0; i < texts.length; i++) { choices.push({ number: 0, text: texts[i] }); }
      Goal.correctChoice = firstCond(choices, x => x.text == Goal.label);
    } else if (wp.isFractionResult == true) {
      let res = wp.result.number;
      if (res.n / res.d > 2) {
        wp.result.isMixed = true;
        wp.result.mixed = getMixedNumber(res.n, res.d);
      }
      nums = get3FractionVariants(res);
      texts = nums.map(x => getTextForFractionX(x.n, x.d));
      wp.result.text = texts[0];
      for (let i = 0; i < texts.length; i++) { choices.push({ number: nums[i], text: texts[i] }); }
      Goal.correctChoice = firstCond(choices, x => x.text == wp.result.text);
    } else {
      let res = wp.result.number;
      nums = [res, res + randomNumber(1, 25), res / randomNumber(2, 5), res * randomNumber(2, 5)];
      texts = nums.map(x => (Math.round(x * 100) / 100));
      for (let i = 0; i < texts.length; i++) { choices.push({ number: nums[i], text: texts[i] }); }
      Goal.correctChoice = choices[0];
    }
    shuffle(choices);
    if (coin()) shuffle(choices);
    Goal.choices = choices;
    let dParent = this.dResult;
    let idx = 0;
    for (const ch of choices) {
      ////'&frac57;', //'&frac12;', 
      let dButton = mButton(ch.text, this.onClickChoice.bind(this), dParent, { wmin: 100, fz: 36, margin: 20, rounding: 4, vpadding: 4, hpadding: 10 }, ['toggleButtonClass']);
      dButton.id = 'bChoice_' + idx; idx += 1;
      if (ch.text == wp.result.text) {
        Goal.choice = ch.toString();
        Goal.buttonCorrect = dButton;
      }
    }
  }
  onClickChoice(ev) {
    let id = evToClosestId(ev);
    let b = mBy(id);
    let index = Number(stringAfter(id, '_'));
    Goal.choice = Goal.choices[index];
    Goal.buttonClicked = b;
    if (Goal.choice == Goal.correctChoice) { mStyle(b, { bg: 'green' }); mCheckit(this.textArea, 100); }
    else { mXit(b, 100); }
    this.controller.evaluate.bind(this.controller)();
  }
  eval() {
    clearFleetingMessage();
    Selected = { delay: 5000, reqAnswer: this.wp.result.number, answer: Goal.choice.number, feedbackUI: Goal.buttonClicked };
    if (this.wp.isTextResult) { Selected.reqAnswer = this.wp.result.text; Selected.answer = Goal.choice.text; }
    return (Goal.buttonClicked == Goal.buttonCorrect);
  }
  createInputElements() {
    this.inputBox = addNthInputElement(this.dResult, 0);
    this.defaultFocusElement = this.inputBox.id;
    onclick = () => mBy(this.defaultFocusElement).focus();
    mBy(this.defaultFocusElement).focus();
  }
  activate() { }
  eval_dep(ev) {
    console.log('#', this.trialNumber, 'of', this.trials);
    clearFleetingMessage();
    Selected = {};
    let answer = normalize(this.inputBox.value, 'E');
    let reqAnswer = normalize(this.wp.result.text, 'E');
    console.log('answer', answer, 'req', reqAnswer);
    let isCorrect = answer == reqAnswer;
    Selected = { reqAnswer: reqAnswer, answer: answer, feedbackUI: isCorrect ? Goal.buttonClicked : Goal.buttonCorrect };
    return (answer == reqAnswer);
  }
  trialPrompt_dep() {
    sayTryAgain();
    let n = this.trialNumber;
    showFleetingMessage('try again!', 0, {}, true);
    this.inputBox = addNthInputElement(this.dResult, this.trialNumber);
    this.defaultFocusElement = this.inputBox.id;
    mLinebreak(dTable);
    return 10;
  }
  activate_input() {
    this.inputBox.onkeyup = ev => {
      if (!canAct()) return;
      if (ev.key === "Enter") {
        ev.cancelBubble = true;
        this.controller.evaluate.bind(this.controller)(ev);
      }
    };
    this.inputBox.focus();
  }
}
class GSentence extends Game {
  constructor(name, o) {
    super(name, o);
    this.prevLanguage = this.language;
    this.language = 'E';
  }
  startGame() {
    this.correctionFunc = () => {
      let sent = this.sentenceList[0].join(' ');
      this.dWordArea.innerHTML = `<h1>${sent}</h1>`;
      if (this.spokenFeedback) sayRandomVoice(sent);
      return 3000;
    }
    this.successFunc = () => { mCheckit(this.dWordArea, 120); };
  }
  clear() { super.clear(); this.language = this.prevLanguage; }
  start_Level() {
    this.sentences = [];
    for (const s of EnglishSentences) {
      let slist = isList(s) ? s : [s];
      slist = slist.map(x => x.split(' '));
      if (slist[0].length <= this.maxWords && slist[0].length >= this.minWords) this.sentences.push(slist);
    }
  }
  dropHandler(source, target, isCopy = false, clearTarget = false) {
    let prevTarget = source.target;
    source.target = target;
    let dSource = iDiv(source);
    let dTarget = iDiv(target);
    if (clearTarget) {
      let ch = dTarget.children[0];
      let chSource = firstCond(Pictures, x => iDiv(x) == ch);
      if (chSource) {
        if (isdef(prevTarget)) {
          mAppend(iDiv(prevTarget), ch);
          chSource.target = prevTarget;
        } else {
          mAppend(this.dWordArea, ch);
          delete chSource.target;
        }
      }
      clearElement(dTarget);
    }
    if (isCopy) {
      let dNew = mText(dSource.innerHTML, dTarget, { wmin: 100, fz: 20, padding: 4, margin: 4, display: 'inline-block' });
      addDDSource(dNew, isCopy, clearTarget);
    } else {
      mAppend(dTarget, dSource);
    }
  }
  prompt() {
    show_instruction('form a correct sentence', dTitle, 'form a correct sentence');
    mLinebreak(dTable);
    let sl = this.sentenceList = chooseRandom(this.sentences);
    let words = this.sentenceList[0];
    let fz = 32;
    let h = fz * 1.25, wmin = fz * 1.25;
    let items = Pictures = [];
    let containers = this.containers = [];
    let options = _simpleOptions({ fz: fz, bg: 'transparent', fg: 'white', showPic: false, showLabels: true }, { wmin: wmin });
    let dArea = mDiv(dTable, { h: 150, display: 'flex', 'flex-wrap': 'wrap', layout: 'fhcc' });
    mLinebreak(dTable);
    let dWordArea = this.dWordArea = mDiv(dTable, { h: 70, wmin: 20, display: 'flex', 'flex-wrap': 'wrap', layout: 'fhcc' });
    let i = 0;
    for (const word of words) {
      let item = { label: word, index: i };
      let container = { label: word, index: i };
      i += 1;
      let d = makeItemDiv(item, options);
      let dCont = mDiv(dArea, { wmin: wmin + 12, hmin: h + 10, bg: colorTrans('beige', .25), fg: 'black', margin: 12 });
      container.div = dCont;
      items.push(item);
      containers.push(container);
    }
    shuffle(items);
    items.map(x => { mAppend(dWordArea, iDiv(x)); mStyle(iDiv(x), { h: h, w: 'auto' }); });
    enableDD(items, containers, this.dropHandler.bind(this), false, true);
    mLinebreak(dTable, 50);
    mButton('Done!', this.controller.evaluate.bind(this.controller), dTable, { fz: 28, matop: 10, rounding: 10, padding: 16, border: 8 }, ['buttonClass']);
    this.controller.activateUi.bind(this.controller)();
  }
  trialPrompt() {
    sayTryAgain();
    showFleetingMessage('Try again!', 0, { fg: 'white' });
    TOMain = setTimeout(() => { Pictures.map(x => mAppend(this.dWordArea, iDiv(x))); }, 1200);
    return 1500;
  }
  eval() {
    let words = [];
    for (const cont of this.containers) {
      let d = iDiv(cont);
      let ch = d.firstChild;
      if (ch && isdef(ch.firstChild)) {
        words.push(ch.firstChild.innerHTML);
      } else break;
    }
    let answer = words.join(' ');
    let isCorrect = false;
    for (const sent of this.sentenceList) {
      let variant = sent.join(' ');
      if (answer == variant) isCorrect = true;
    }
    Selected = { piclist: Pictures, feedbackUI: Pictures.map(x => iDiv(x)), sz: getRect(iDiv(Pictures[0])).h + 10 };
    return isCorrect;
  }
}
class GSteps extends Game {
  constructor(name, o) { super(name, o); }
  startGame() { this.correctionFunc = showCorrectWords; }
  start_Level() {
    super.start_Level();
    this.keys = this.keys.filter(x => containsColorWord(x));
  }
  prompt() {
    this.piclist = [];
    let colorKeys = this.numColors > 1 ? choose(this.colors, this.numColors) : null;
    let bg = this.numColors > 1 || this.numRepeat > 1 ? 'white' : 'random';
    let rows = this.numColors > 1 ? this.numColors : undefined;
    let showRepeat = this.numRepeat > 1;
    myShowPics(this.interact.bind(this), { bg: bg },
      { rows: rows, showRepeat: showRepeat, colorKeys: colorKeys, numRepeat: this.numRepeat, contrast: this.contrast });
    setMultiGoal(this.numSteps);
    let cmd = 'click';
    let spoken = [], written = [], corr = [];
    for (let i = 0; i < this.numSteps; i++) {
      let goal = Goal.pics[i];
      let sOrdinal = getOrdinal(goal.iRepeat);
      [written[i], spoken[i], corr[i]] = getOrdinalColorLabelInstruction(cmd, sOrdinal, goal.color, goal.label);
      goal.correctionPhrase = corr[i];
      cmd = 'then';
    }
    let sWritten = this.showVisualInstruction ? written.join('; ') : 'listen to instruction!';
    show_instruction(sWritten, dTitle, spoken.join('. '), { fz: 20 });
    this.controller.activateUi.bind(this.controller)();
  }
  trialPrompt() {
    sayTryAgain();
    showFleetingMessage(this.message, 0);
    return 1000;
  }
  activate() {
    for (const p of this.piclist) { toggleSelectionOfPicture(p); }
    this.piclist = [];
  }
  interact(ev) {
    ev.cancelBubble = true;
    if (!canAct()) { console.log('no act'); return; }
    let pic = findItemFromEvent(Pictures, ev);
    toggleSelectionOfPicture(pic, this.piclist);
    if (this.piclist.length == Goal.pics.length) {
      clearFleetingMessage();
      Selected = { piclist: this.piclist }; this.controller.evaluate.bind(this.controller)();
    }
  }
  eval() {
    Selected = { piclist: this.piclist, feedbackUI: this.piclist.map(x => iDiv(x)), sz: getRect(iDiv(this.piclist[0])).h };
    let isCorrect = true;
    this.message = this.language == 'D' ? 'beachte die REIHENFOLGE!' : 'mind the ORDER!';
    for (let i = 0; i < this.piclist.length; i++) {
      let p = this.piclist[i];
      if (!Goal.pics.includes(p)) this.message = this.language == 'D' ? 'noch einmal!' : 'try again!';
      if (this.piclist[i] != Goal.pics[i]) isCorrect = false;
    }
    return isCorrect;
  }
}
class GSwap extends Game {
  constructor(name, o) {
    super(name, o);
    if (this.language == 'C') { this.prevLanguage = this.language; this.language = chooseRandom('E', 'D'); }
    ensureDictionary();
  }
  startGame() { this.correctionFunc = showCorrectLabelSwapping; }
  clear() { super.clear(); if (isdef(this.prevLanguage)) this.language = this.prevLanguage; }
  start_Level() {
    this.keys = setKeysG(this, filterWordByLengthG, 25);
    if (this.keys.length < 25) { this.keys = setKeysG(this, filterWordByLengthG, 25, 'all'); }
    this.trials = 2;
  }
  dropHandler(source, target, isCopy = false, clearTarget = false) {
    let prevTarget = source.target;
    source.target = target;
    let dSource = iDiv(source);
    let dTarget = iDiv(target);
    if (clearTarget) {
      let ch = dTarget.children[0];
      let chSource = firstCond(Pictures, x => iDiv(x) == ch);
      if (chSource) {
        if (isdef(prevTarget)) {
          mAppend(iDiv(prevTarget), ch);
          chSource.target = prevTarget;
        } else {
          mAppend(this.dWordArea, ch);
          delete chSource.target;
        }
      }
      clearElement(dTarget);
    }
    if (isCopy) {
      let dNew = mText(dSource.innerHTML, dTarget, { wmin: 100, fz: 20, padding: 4, margin: 4, display: 'inline-block' });
      addDDSource(dNew, isCopy, clearTarget);
    } else {
      mAppend(dTarget, dSource);
    }
  }
  prompt() {
    show_instruction('swap letter to form words', dTitle, 'swap letter to form words');
    mLinebreak(dTable);
    let fz = 32;
    let options = _simpleOptions({ language: this.language, w: 200, h: 200, keySet: this.keys, luc: 'u', fz: fz, bg: 'random', fg: 'white', showLabels: true });
    let n = 2;
    let items = gatherItems(n, options);
    let style = { margin: 3, cursor: 'pointer', fg: 'white', display: 'inline', bg: '#00000020', align: 'center', border: 'transparent', outline: 'none', family: 'Consolas', fz: 80 };
    for (const item of items) {
      let d1 = item.container = mDiv(dTable, { hmin: 250 });
      let d = iLetters(item.label, d1, style);
      iAdd(item, { div: d });
      let letters = item.letters = [];
      for (let i = 0; i < arrChildren(d).length; i++) {
        let ch = d.children[i];
        let l = {
          itemId: item.id, div: ch, i: i, letter: ch.innerHTML,
          swapInfo: item.swaps[i],
          state: 'swapped',
          isBlinking: false, fg: 'white', bg: 'transparent'
        };
        letters.push(l);
        ch.onclick = () => { startBlinking(l, item.letters, true) };
      }
      mStyle(d, { margin: 35 });
      delete item.swaps;
    }
    showPictureHints(Pictures, 'container');
    mLinebreak(dTable, 50);
    this.buttonDone = mButton('Done!', () => {
      if (!canAct()) return;
      for (let i = 0; i < Pictures.length; i++) {
        let p = Pictures[i];
        let blinking = getBlinkingLetter(p);
        if (!blinking) {
          let msg = 'You need to pick 1 letter to swap in EACH word!!!';
          Speech.say(msg);
          sayRandomVoice(msg);
          showFleetingMessage('You need to pick 1 letter to swap in EACH word!!!', 0, { fz: 30 });
          return;
        }
      }
      this.controller.evaluate.bind(this.controller)();
    }, dTable, { fz: 28, matop: 10, rounding: 10, padding: 16, border: 8 }, ['buttonClass']);
    this.controller.activateUi.bind(this.controller)();
  }
  trialPrompt() {
    if (this.trialNumber % 2 == 0) showPictureHints(Pictures, 'container'); else showTextHints(Pictures, 'container', 'origLabel');
    TOMain = setTimeout(() => {
      for (const p of Pictures) {
        for (const l of p.letters) {
          l.state = 'swapped';
          if (isdef(l.swapInfo)) {
            iDiv(l).innerHTML = p.label[l.i];
          }
        }
      }
    }, 1500);
    return 1800;
  }
  activate() {
    if (this.trialNumber >= 1) { sayTryAgain(); showFleetingMessage('Try again!'); }
    else { showFleetingMessage('click one letter in each word!'); }
  }
  eval() {
    let n = Pictures.length;
    let blinkInfo = this.blinkInfo = [];
    clearFleetingMessage();
    for (let i = 0; i < n; i++) {
      let p = Pictures[i];
      let blinking = getBlinkingLetter(p);
      blinkInfo.push({ i: i, blinking: blinking });
    }
    for (let i = 0; i < n; i++) { let l = blinkInfo[i].blinking; if (!l) continue; stopBlinking(l); }
    for (const blinki of blinkInfo) { if (!blinki.blinking) { return false; } }
    let isCorrect = true;
    for (let i = 0; i < n; i++) {
      let b1 = blinkInfo[i].blinking;
      let b2 = blinkInfo[(i + 1) % blinkInfo.length].blinking;
      let item = Items[b1.itemId];
      let item2 = Items[b2.itemId];
      let l = item.letters[b1.i];
      let sw = l.swapInfo;
      if (nundef(sw)) { sw = l.swapInfo = { correct: { itemId: item.id, index: b1.i, l: b1.letter } }; }
      sw.temp = { itemId: item2.id, index: b2.i, l: b2.letter };
      item.testLabel = replaceAtString(item.label, b1.i, b2.letter);
      iDiv(l).innerHTML = b2.letter;
      l.state = 'temp';
    }
    for (const p of Pictures) { if (p.testLabel != p.origLabel) { isCorrect = false; } }
    let feedbackList = [];
    for (let i = 0; i < n; i++) {
      let item = Pictures[i];
      let d;
      if (isCorrect) d = iDiv(item.letters[item.iLetter]);
      else {
        let iLetter = blinkInfo[i].blinking.i;
        if (item.iLetter != iLetter) d = iDiv(item.letters[iLetter]);
      }
      if (isdef(d)) feedbackList.push(d);
    }
    Selected = { piclist: Pictures, feedbackUI: feedbackList, sz: getRect(iDiv(Pictures[0])).h, delay: 800 };
    return isCorrect;
  }
}
class GTouchColors extends Game {
  constructor(name, o) { super(name, o); }
  start_Level() {
    super.start_Level();
    this.keys = this.keys.filter(x => containsColorWord(x));
  }
  prompt() {
    let colorKeys = choose(this.colors, this.numColors);
    let rows = this.numColors;
    let showLabels = this.lang == 'C' || this.showLabels;
    console.log('showLabels', showLabels);
    myShowPics(this.controller.evaluate.bind(this.controller), { bg: 'white' }, { showLabels: showLabels, colorKeys: colorKeys, rows: rows });
    if (this.shuffle == true) {
      let dParent = iDiv(Pictures[0]).parentNode;
      shuffleChildren(dParent);
    }
    setGoal(randomNumber(0, Pictures.length - 1));
    let [written, spoken] = getOrdinalColorLabelInstruction('click');
    show_instruction(written, dTitle, spoken);
    this.controller.activateUi.bind(this.controller)();
  }
  eval(ev) {
    ev.cancelBubble = true;
    let item = findItemFromEvent(Pictures, ev);
    Selected = { answer: item.label, reqAnswer: Goal.label, pic: item, feedbackUI: iDiv(item) };
    if (item == Goal) { return true; } else { return false; }
  }
}
class GTouchPic extends Game {
  constructor(name, o) { super(name, o); }
  prompt() {
    myShowPics(this.controller.evaluate.bind(this.controller), {}, { showLabels: (this.lang == 'C' || this.showLabels) });
    setGoal();
    let wr = 'click ';
    show_instruction(wr + `<b>${Goal.label.toUpperCase()}</b>`, dTitle, Goal.label);
    this.controller.activateUi.bind(this.controller)();
  }
}
class GWritePic extends Game {
  constructor(name, o) { super(name, o); }
  startGame() {
    this.correctionFunc = showCorrectWordInTitle;
    onkeydown = ev => {
      if (!canAct()) return;
      if (isdef(this.inputBox)) { this.inputBox.focus(); }
    }
  }
  start_Level() {
    this.keys = setKeysG(this, filterWordByLengthG, 25);
    if (this.keys.length < 25) { this.keys = setKeysG(this, filterWordByLengthG, 25, 'all'); }
  }
  prompt() {
    let showLabels = this.showLabels == true && this.labels == true;
    myShowPics(() => mBy(this.defaultFocusElement).focus(), {}, { showLabels: showLabels });
    setGoal();
    if (this.instruction == 'all') {
      let wr = (this.language == 'E' ? 'type ' : "schreib' ");
      show_instruction(wr + `<b>${Goal.label.toUpperCase()}</b>`, dTitle, wr + Goal.label);
    } else if (this.instruction == 'spokenGoal') {
      let wr = this.language == 'E' ? 'type the correct word' : "schreib' das passende wort";
      let sp = (this.language == 'E' ? 'type' : "schreib'") + ' ' + Goal.label;
      show_instruction(wr, dTitle, sp);
    } else {
      let wr = this.language == 'E' ? 'type the correct word' : "schreib' das passende wort";
      show_instruction(wr, dTitle, wr);
    }
    mLinebreak(dTable, 20);
    this.inputBox = addNthInputElement(dTable, this.trialNumber);
    this.defaultFocusElement = this.inputBox.id;
    this.controller.activateUi.bind(this.controller)();
  }
  trialPrompt() {
    sayTryAgain();
    let n = this.trialNumber == 1 ? 1 : (this.trialNumber + Math.floor((Goal.label.length - this.trialNumber) / 2));
    showFleetingMessage(Goal.label.substring(0, n));
    mLinebreak(dTable);
    this.inputBox = addNthInputElement(dTable, this.trialNumber);
    this.defaultFocusElement = this.inputBox.id;
    return 10;
  }
  activate() {
    this.inputBox.onkeyup = ev => {
      if (!canAct()) return;
      if (ev.key === "Enter") {
        ev.cancelBubble = true;
        this.controller.evaluate.bind(this.controller)(ev);
      }
    };
    this.inputBox.focus();
  }
  eval(ev) {
    let answer = normalize(this.inputBox.value, this.language);
    let reqAnswer = normalize(Goal.label, this.language);
    let correctPrefix = this.correctPrefix = getCorrectPrefix(Goal.label, this.inputBox.value);
    Selected = { reqAnswer: reqAnswer, answer: answer, feedbackUI: iDiv(Goal) };
    if (answer == reqAnswer) { showFleetingMessage(Goal.label); return true; }
    else { return false; }
  }
}
class GMissingNumber extends Game {
  constructor(name, o) { super(name, o); }
  startGame() {
    this.successFunc = successThumbsUp;
    this.failFunc = failThumbsDown;
    this.correctionFunc = this.showCorrectSequence.bind(this);
  }
  showCorrectSequence() { return numberSequenceCorrectionAnimation(getNumSeqHint); }
  start_Level() {
    if (!isList(this.steps)) this.steps = [this.steps];
    this.numPics = 2;
    this.labels = false;
  }
  prompt() {
    mLinebreak(dTable, 12);
    showHiddenThumbsUpDown(110);
    mLinebreak(dTable);
    this.step = chooseRandom(this.steps);
    this.op = chooseRandom(this.ops);
    this.oop = OPS[this.op];
    this.seq = createNumberSequence(this.seqLen, this.minNum, this.maxNum, this.step, this.op);
    [this.words, this.letters] = showNumberSequence(this.seq, dTable);
    setNumberSequenceGoal();
    mLinebreak(dTable);
    let instr1 = (this.language == 'E' ? 'complete the sequence' : "ergänze die reihe");
    show_instruction(instr1, dTitle, instr1);
    if (this.showHint) {
      hintEngineStart(getNumSeqHintString, [0, 1, 2, 3, 4], 5000 + this.level * 1000);
    }
    this.controller.activateUi.bind(this.controller)();
  }
  trialPrompt() {
    let hintlist = this.trialNumber >= 4 ? [this.trialNumber] : range(this.trialNumber, 4);
    if (this.showHint) hintEngineStart(getNumSeqHintString, hintlist, 3000 + this.level * 1000);
    TOMain = setTimeout(() => getWrongChars().map(x => unfillChar(x)), 500);
    return 600;
  }
  activate() { addKeyup('G', this.interact.bind(this)); }
  interact(ev) {
    if (!isNumber(ev.key) && ev.key != '-') return;
    clearFleetingMessage();
    if (!canAct()) return;
    let sel = Selected = onKeyWordInput(ev);
    if (nundef(sel)) return;
    let lastInputCharFilled = sel.target;
    console.assert(sel.isMatch == (lastInputCharFilled.letter == sel.ch), lastInputCharFilled, sel.ch);
    if (sel.isMatch && sel.isVeryLast) {
      deactivateFocusGroup();
      this.controller.evaluate.bind(this.controller)(true);
    } else if (sel.isMatch && sel.isLastOfGroup) {
      sel.target.isBlank = false;
      sel.target.group.hasBlanks = false;
      removeInPlace(Goal.blankWords, sel.target.group);
      removeInPlace(Goal.blankChars, sel.target);
      deactivateFocusGroup();
      console.log('haaaaaaaaaaaalo', Goal.isFocus)
    } else if (sel.isMatch) {
      removeInPlace(Goal.blankChars, sel.target);
      sel.target.isBlank = false;
    } else if (sel.isVeryLast) {
      Selected.words = getInputWords();
      Selected.answer = getInputWordString();
      Selected.req = getCorrectWordString();
      deactivateFocusGroup();
      this.controller.evaluate.bind(this.controller)(false);
    } else if (sel.isLastOfGroup) {
      Selected.words = getInputWords();
      Selected.answer = getInputWordString();
      Selected.req = getCorrectWordString();
      deactivateFocusGroup();
      this.controller.evaluate.bind(this.controller)(false);
    } else {
      if (!this.silent) { writeSound(); playSound('incorrect1'); }
      deactivateFocusGroup();
      showFleetingMessage('does NOT fit: ' + Selected.ch, 0, { fz: 24 });
      setTimeout(() => unfillCharInput(Selected.target), 500);
    }
  }
  eval(isCorrect) { return isCorrect; }
}
class GameTimed extends Game {
  constructor(name, o) { super(name, o); }
  clear() { clearInterval(this.TOI); super.clear(); this.timer = null; }
  makeTimer() {
    this.timer = true;
    if (nundef(this.msTotal)) this.msTotal = 5000;
    if (nundef(this.msInterval)) this.msInterval = 100;
    let w = this.wTimerOuter = 200;
    this.dTimeOuter = mDiv(dTable, { w: w, h: 25, border: 'white', rounding: 10, position: 'relative' });
    [this.wTimer, this.r, this.g] = [0, 0, 255];
    this.dTimeInner = mDiv(this.dTimeOuter, { h: 25, w: this.wTimer, rounding: 10, bg: `rgb(${this.r},${this.g},0)`, position: 'absolute', left: 0, top: 0 });
    this.dTimeDisplay = mDiv(this.dTimeOuter, { patop: 2, align: 'center', h: 25, w: w, position: 'absolute', left: 0, top: 0 });
    mLinebreak(dTable);
    this.dPause = mDiv(dTable, { cursor: 'pointer', fz: 12, hpadding: 30, vpadding: 10 }, null, 'click to pause');
    this.dPause.onclick = () => this.pause();
  }
  pause() {
    if (nundef(this.timer)) return;
    clearInterval(this.TOI);
    this.dPause.innerHTML = 'click to resume...';
    this.dPause.onclick = () => this.resume();
  }
  resume() {
    if (nundef(this.timer)) return;
    this.dPause.innerHTML = 'click to pause...';
    this.dPause.onclick = () => this.pause();
    this.TOI = setInterval(this.onTick.bind(this), this.msInterval);
  }
  activate() {
    if (nundef(this.timer)) return;
    this.msLeft = valf(this.msTotal, 10000);
    this.dTimeDisplay.innerHTML = timeConversion(this.msLeft, 'sh');
    this.TOI = setInterval(this.onTick.bind(this), this.msInterval);
  }
  onTick() {
    this.msLeft -= this.msInterval;
    this.wTimer += this.wTimerOuter * this.msInterval / this.msTotal;
    let inc_color = 255 * this.msInterval / this.msTotal;
    this.r += inc_color; this.g -= inc_color;
    mStyle(this.dTimeInner, { w: this.wTimer, bg: `rgb(${this.r},${this.g},0)` });
    this.dTimeDisplay.innerHTML = timeConversion(this.msLeft, 'sh');
    if (this.msLeft < 100) {
      clearInterval(this.TOI);
      this.dPause.style.opacity = 0;
      this.onTimeup();
    }
  }
}
class GSpotit extends GameTimed {
  constructor(name, o) { super(name, o); }
  startGame() { this.correctionFunc = showCorrectUis; }
  start_Level() {
    super.start_Level();
    this.colarr = _calc_hex_col_array(this.rows, this.cols);
    let perCard = arrSum(this.colarr);
    this.nShared = (this.numCards * (this.numCards - 1)) / 2;
    this.nUnique = perCard - this.numCards + 1;
    this.numKeysNeeded = this.nShared + this.numCards * this.nUnique;
    this.keys = setKeysG(this, (_, x) => !x.includes(' '), this.numKeysNeeded + 1);
  }
  deal() {
    let keys = choose(this.keys, this.numKeysNeeded);
    let dupls = keys.slice(0, this.nShared);
    let uniqs = keys.slice(this.nShared);
    let infos = [];
    for (let i = 0; i < this.numCards; i++) {
      let keylist = uniqs.slice(i * this.nUnique, (i + 1) * this.nUnique);
      let info = { id: getUID(), shares: {}, keys: keylist, rows: this.rows, cols: this.cols, colarr: this.colarr };
      infos.push(info);
    }
    let iShared = 0;
    for (let i = 0; i < this.numCards; i++) {
      for (let j = i + 1; j < this.numCards; j++) {
        let c1 = infos[i];
        let c2 = infos[j];
        let dupl = dupls[iShared++];
        c1.keys.push(dupl);
        c1.shares[c2.id] = dupl;
        c2.shares[c1.id] = dupl;
        c2.keys.push(dupl);
      }
    }
    for (const info of infos) { shuffle(info.keys); }
    return infos;
  }
  interact(ev) {
    ev.cancelBubble = true;
    if (!canAct()) { console.log('no act'); return; }
    let keyClicked = evToProp(ev, 'key');
    let id = evToId(ev);
    if (isdef(keyClicked) && isdef(Items[id])) {
      this.pause();
      let item = Items[id];
      if (Object.values(item.shares).includes(keyClicked)) {
        let otherCard = spotitFindCardSharingSymbol(item, keyClicked);
        let cardSymbol = ev.target;
        let otherSymbol = spotitFindSymbol(otherCard, keyClicked);
        Selected = { isCorrect: true, feedbackUI: [cardSymbol, otherSymbol] };
      } else {
        let cardSymbol = ev.target;
        Selected = { isCorrect: false, feedbackUI: [cardSymbol], correctUis: this.getSharedSymbols(), correctionDelay: this.items.length * 1500 };
      }
      this.controller.evaluate.bind(this.controller)();
    }
  }
  getSharedSymbols() {
    let result = [];
    for (const item of this.items) {
      for (const id in item.shares) {
        let k = item.shares[id];
        let ui = iGetl(item, k);
        result.push(ui);
      }
    }
    return result;
  }
  eval() { return Selected.isCorrect; }
  prompt() {
    this.trials = 1;
    show_instruction('find common symbol', dTitle);
    mLinebreak(dTable, 25);
    let infos = this.deal();
    let items = this.items = [];
    for (const info of infos) {
      let item = spotitCard(info, dTable, { margin: 10 }, this.interact.bind(this));
      items.push(item);
    }
    this.controller.activateUi.bind(this.controller)();
  }
  activate() { }
  onTimeup() {
    Selected = { isCorrect: false, correctUis: this.getSharedSymbols(), correctionDelay: this.items.length * 2000 };
    this.controller.evaluate.bind(this.controller)();
  }
}
class GSpotitMulti extends GSpotit {
  constructor(name, o) { super(name, o); }
  make_players(table) {
    let players = this.players = {};
    for (const plname of table.players) {
      players[plname] = { name: plname, color: getColorDictColor(DB.users[plname].color), imgPath: `../base/assets/images/${plname}.jpg`, score: 0 };
    }
    this.player = Session.cur_user;
    this.me = players[this.player];
    this.others = Object.values(players).filter(x => x.name != this.player);
  }
  startGame() {
    resetState();
    this.successFunc = successPictureGoal;
    this.failFunc = failPictureGoal;
    this.correctionFunc = showCorrectUis;
    this.numCards = 2;
    this.colarr = _calc_hex_col_array(this.rows, this.cols);
    let perCard = arrSum(this.colarr);
    this.nShared = (this.numCards * (this.numCards - 1)) / 2;
    this.nUnique = perCard - this.numCards + 1;
    this.numKeysNeeded = this.nShared + this.numCards * this.nUnique;
    this.keys = setKeysG(this, (_, x) => !x.includes(' '), this.numKeysNeeded + 1);
    resetRound();
    uiActivated = false;
    QContextCounter += 1;
    showStats(false);
    this.update_status();
    show_title(Session.table.friendly);
    this.trialNumber = 0;
    hide('sidebar');
    this.trials = 1;
    this.startTime = get_timestamp();
    mLinebreak(dTable, 25);
    let infos = this.deal();
    let items = this.items = [];
    for (const info of infos) {
      let item = spotitCard(info, dTable, { margin: 10 }, this.interact.bind(this));
      items.push(item);
    }
    Selected = null;
    uiActivated = true;
  }
  update_status() {
    let d = dTitle;
    clearElement(d);
    let d1 = mDiv(d, { display: 'flex', 'justify-content': 'center' });
    for (const plname in this.players) {
      let pl = this.players[plname];
      let d2 = mDiv(d1, { vmargin: 10, hmargin: 20, align: 'center' }, null, `<img src='${pl.imgPath}' style="display:block" class='img_person' width=50 height=50>${pl.score}`);
    }
  }
  evaluate() {
    if (!canAct()) return;
    uiActivated = false; clearTimeouts();
    IsAnswerCorrect = Selected.isCorrect;
    this.me.score += IsAnswerCorrect ? 1 : 0;
    user_game_status();
  }
  //#region spotit
  interact(ev) {
    ev.cancelBubble = true;
    if (!canAct()) { console.log('no act'); return; }
    let keyClicked = evToProp(ev, 'key');
    let id = evToId(ev);
    if (isdef(keyClicked) && isdef(Items[id])) {
      this.pause();
      let item = Items[id];
      if (Object.values(item.shares).includes(keyClicked)) {
        let otherCard = spotitFindCardSharingSymbol(item, keyClicked);
        let cardSymbol = ev.target;
        let otherSymbol = spotitFindSymbol(otherCard, keyClicked);
        Selected = { isCorrect: true, feedbackUI: [cardSymbol, otherSymbol] };
      } else {
        let cardSymbol = ev.target;
        Selected = { isCorrect: false, feedbackUI: [cardSymbol], correctUis: this.getSharedSymbols(), correctionDelay: this.items.length * 1500 };
      }
      this.evaluate.bind(this)();
    }
  }
  deal() {
    let keys = choose(this.keys, this.numKeysNeeded);
    let dupls = keys.slice(0, this.nShared);
    let uniqs = keys.slice(this.nShared);
    let infos = [];
    for (let i = 0; i < this.numCards; i++) {
      let keylist = uniqs.slice(i * this.nUnique, (i + 1) * this.nUnique);
      let info = { id: getUID(), shares: {}, keys: keylist, rows: this.rows, cols: this.cols, colarr: this.colarr };
      infos.push(info);
    }
    let iShared = 0;
    for (let i = 0; i < this.numCards; i++) {
      for (let j = i + 1; j < this.numCards; j++) {
        let c1 = infos[i];
        let c2 = infos[j];
        let dupl = dupls[iShared++];
        c1.keys.push(dupl);
        c1.shares[c2.id] = dupl;
        c2.shares[c1.id] = dupl;
        c2.keys.push(dupl);
      }
    }
    for (const info of infos) { shuffle(info.keys); }
    return infos;
  }
  getSharedSymbols() {
    let result = [];
    for (const item of this.items) {
      for (const id in item.shares) {
        let k = item.shares[id];
        let ui = iGetl(item, k);
        result.push(ui);
      }
    }
    return result;
  }
  //#endregion
}
class GSpotitMulti_mess extends GSpotit {
  constructor(name, o) { super(name, o); }
  static start_fen(players) { let fen = {}; for (const pl of players) { fen[pl] = 0; } return fen; }
  fen_to_state(fen) {
    console.log('fen', fen);
    this.playerscores = isDict(fen) ? fen : JSON.parse(fen);
    for (const plname in this.players) { let pl = this.players[plname]; pl.score = this.playerscores[plname]; }
    console.log('players', this.players);
  }
  make_players(table) {
    let players = this.players = {};
    for (const plname of table.players) {
      players[plname] = { name: plname, color: getColorDictColor(DB.users[plname].color), imgPath: `../base/assets/images/${plname}.jpg`, score: 0 };
    }
    this.player = Session.cur_user;
    this.me = players[this.player];
    this.others = Object.values(players).filter(x => x.name != this.player);
  }
  make_fen_vor_move(table, moves = []) { return table.fen; }
  make_fen_after_move() {
    this.me.score += IsAnswerCorrect ? 1 : 0;
    let fen = {};
    for (const plname in this.players) {
      let pl = this.players[plname];
      fen[plname] = pl.score;
    }
    return fen;
  }
  startGame(fen) {
    resetState();
    this.successFunc = successPictureGoal;
    this.failFunc = failPictureGoal;
    this.correctionFunc = showCorrectUis;
    console.log(this.player);
    Settings.updateGameValues(this.player, this);
    super.start_level();
    this.numCards = 2;
    this.colarr = _calc_hex_col_array(this.rows, this.cols);
    let perCard = arrSum(this.colarr);
    this.nShared = (this.numCards * (this.numCards - 1)) / 2;
    this.nUnique = perCard - this.numCards + 1;
    this.numKeysNeeded = this.nShared + this.numCards * this.nUnique;
    this.keys = setKeysG(this, (_, x) => !x.includes(' '), this.numKeysNeeded + 1);
    this.fen_to_state(fen);
    resetRound();
    uiActivated = false;
    TOMain = setTimeout(() => this.prompt(), 300);
  }
  update_status() {
    let d = dTitle;
    clearElement(d);
    let d1 = mDiv(d, { display: 'flex', 'justify-content': 'center' });
    for (const plname in this.players) {
      let pl = this.players[plname];
      let d2 = mDiv(d1, { vmargin: 10, hmargin: 20, align: 'center' }, null, `<img src='${pl.imgPath}' style="display:block" class='img_person' width=50 height=50>${pl.score}`);
    }
  }
  prompt() {
    QContextCounter += 1;
    showStats(false);
    this.update_status();
    show_title(Session.table.friendly);
    this.trialNumber = 0;
    hide('sidebar');
    this.trials = 1;
    this.startTime = get_timestamp();
    mLinebreak(dTable, 25);
    let infos = this.deal();
    let items = this.items = [];
    for (const info of infos) {
      let item = spotitCard(info, dTable, { margin: 10 }, this.interact.bind(this));
      items.push(item);
    }
    this.activateUi.bind(this)();
  }
  activateUi() {
    Selected = null;
    uiActivated = true;
    this.activate();
  }
  deal() {
    let keys = choose(this.keys, this.numKeysNeeded);
    let dupls = keys.slice(0, this.nShared);
    let uniqs = keys.slice(this.nShared);
    let infos = [];
    for (let i = 0; i < this.numCards; i++) {
      let keylist = uniqs.slice(i * this.nUnique, (i + 1) * this.nUnique);
      let info = { id: getUID(), shares: {}, keys: keylist, rows: this.rows, cols: this.cols, colarr: this.colarr };
      infos.push(info);
    }
    let iShared = 0;
    for (let i = 0; i < this.numCards; i++) {
      for (let j = i + 1; j < this.numCards; j++) {
        let c1 = infos[i];
        let c2 = infos[j];
        let dupl = dupls[iShared++];
        c1.keys.push(dupl);
        c1.shares[c2.id] = dupl;
        c2.shares[c1.id] = dupl;
        c2.keys.push(dupl);
      }
    }
    for (const info of infos) { shuffle(info.keys); }
    return infos;
  }
  interact(ev) {
    ev.cancelBubble = true;
    if (!canAct()) { console.log('no act'); return; }
    let keyClicked = evToProp(ev, 'key');
    let id = evToId(ev);
    if (isdef(keyClicked) && isdef(Items[id])) {
      this.pause();
      let item = Items[id];
      if (Object.values(item.shares).includes(keyClicked)) {
        let otherCard = spotitFindCardSharingSymbol(item, keyClicked);
        let cardSymbol = ev.target;
        let otherSymbol = spotitFindSymbol(otherCard, keyClicked);
        Selected = { isCorrect: true, feedbackUI: [cardSymbol, otherSymbol] };
      } else {
        let cardSymbol = ev.target;
        Selected = { isCorrect: false, feedbackUI: [cardSymbol], correctUis: this.getSharedSymbols(), correctionDelay: this.items.length * 1500 };
      }
      this.evaluate.bind(this)();
    }
  }
  evaluate() {
    if (!canAct()) return;
    uiActivated = false; clearTimeouts();
    IsAnswerCorrect = Selected.isCorrect;
    this.me.score += IsAnswerCorrect ? 1 : 0;
    user_game_status();
  }
  getSharedSymbols() {
    let result = [];
    for (const item of this.items) {
      for (const id in item.shares) {
        let k = item.shares[id];
        let ui = iGetl(item, k);
        result.push(ui);
      }
    }
    return result;
  }
  to_move(is_correct, ms_total) { return '' + (is_correct ? 1 : 0) + ' ' + ms_total; }
  from_move(data) { return { is_correct: (data[0] == '1' ? true : false), ms_total: stringAfter(data, ' ') }; }
  onTimeup() {
    Selected = { isCorrect: false, correctUis: this.getSharedSymbols(), correctionDelay: this.items.length * 2000 };
    this.evaluate.bind(this)();
  }
}
class GProg extends Game {
  constructor(name, o) { super(name, o); }
  prompt() {
    let c = this.card = cRound(dTable);
    let d = c.visual = iDiv(c);
    visualPropertySetter(this.card);
    visualAttributeSetter(this.card);
    d.innerHTML = 'HALLO';
    mStyle(d, { fg: 'blue' });
    mLinebreak(dTable, 25);
    this.ta = this.createTextArea();
    this.ta.value = `mCenterCenterFlex(card.visual);`;
    mLinebreak(dTable, 25);
    mButton('run', this.runCode.bind(this), dTable, { bg: 'skyblue', fg: 'black', fz: 32 }, 'mybutton');
  }
  runCode() {
    let code = this.ta.value;
    let prelim = '';
    prelim = 'let card = this.card;';
    code = prelim + code;
    eval(code);
  }
  createTextArea() {
    let dCode = mDiv(dTable, {});
    let ta = this.ta = mCreate('textarea');
    mAppend(dCode, ta);
    ta.setAttribute('rows', 10);
    ta.setAttribute('cols', 60);
    mStyle(ta, { family: 'courier', padding: 10 });
    return ta;
  }
}
class GKrieg extends G2Player {
  write() { write('game', ...arguments); }
  startGame() {
    this.write('start game')
    super.startGame();
    let back = this.back = new GKriegBack();
    this.setStartPosition();
    this.front = new GKriegFront(130, dTable);
    this.front.presentState(this.back.get_state());
    mLinebreak(dTable, 50);
    this.moveButton = mButton('Move!', this.interact.bind(this), dTable, { fz: 28, matop: 10, rounding: 10, padding: 16, border: 8 }, ['buttonClass']);
  }
  setStartPosition() {
    this.back.load(null);
  }
  prompt() {
    this.write('prompt')
    let msg = this.plTurn == this.ai ? 'Ai thinking...' : 'Deterministic: click Move!';
    showInstruction('', msg, dTitle, false);
    this.controller.activateUi();
  }
  activate() {
    let pl = this.plTurn;
    let autoplay = false;
    let manual = true;
    if (!manual && (autoplay || pl == this.ai)) {
      if (this.ai == pl) uiActivated = false;
      setTimeout(this.interact.bind(this), 500);
    } else {
      this.moveButton.style.opacity = 1;
    }
  }
  interact() {
    if (!canAct()) { console.log('NOPE!!!!', 'ai', aiActivated, 'ui', uiActivated); return; }
    this.controller.deactivateUi();
    this.write('interact');
    let back = this.back;
    back.make_random_move();
    this.front.animatePlayerMove(back.turn(), this.onPlayerMoveCompleted.bind(this));
  }
  onPlayerMoveCompleted() {
    let back = this.back;
    this.front.presentState(this.back.get_state());
    let x = this.back.resolve();
    if (isdef(x)) {
      this.moveButton.style.opacity = .3;
      this.TO = setTimeout(() => { this.front.animateResolve(x, () => { GC.evaluate(x) }) },
        1000
      );
    } else this.controller.evaluate(x);
  }
  changePlayer() {
    this.write('change player')
    this.back.swap_turn();
    this.plTurn = this.players[this.back.player().index];
    this.opp = this.players[this.back.opponent().index];
  }
  eval(x) {
    let back = this.back;
    this.write('eval', x)
    if (isdef(x)) this.front.presentState(this.back.get_state());
    if (back.is_out_of_cards()) {
      this.moveButton.remove();
      this.gameOver = true;
      let w = back.winner();
      if (isdef(w)) this.winner = this.players[w.index];
      this.bannerPos = -480;
    }
  }
}
class GTTT extends G2Player {
  startGame() {
    super.startGame();
    this.createBoard();
    this.human.sym = 'O';
    this.ai.sym = 'X';
    this.setStartPosition();
  }
  createBoard() {
    this.rows = this.cols = this.boardSize;
    this.board = new Board(this.rows, this.cols, this.controller.uiInteract.bind(this.controller));
  }
  setStartPosition() {
    return;
    let positions = [
      new Array(9).fill(null),
      ['X', 'X', null, 'O', null, null, 'O', null, null],
      [null, 'X', null, 'X', null, 'O', null, 'O', null],
      [null, null, null, null, 'X', 'O', null, 'O', null],
    ];
    if (isdef(this.iPosition)) {
      let idx = this.iPosition + 1; idx = idx % positions.length; this.iPosition = idx;
    } else this.iPosition = 0;
    let state = nundef(this.startPosition) || this.startPosition == 'empty' ? positions[0]
      : this.startPosition == 'random' ? chooseRandom(positions)
        : positions[this.iPosition];
    this.board.setState(state, { X: this.ai.color, O: this.human.color });
  }
  prompt() {
    let msg = this.plTurn == this.ai ? 'Ai thinking...' : 'click an empty field!';
    showInstruction('', msg, dTitle, false);
    this.controller.activateUi();
  }
  activate() {
    let pl = this.plTurn;
    let autoplay = false;
    if (autoplay || pl == this.ai) {
      if (this.ai == pl) uiActivated = false;
      setTimeout(() => AIMinimax(this, this.afterComputerMove.bind(this)), 200);
    }
  }
  interact(ev) {
    let tile = evToItemC(ev);
    if (isdef(tile.label)) return;
    let pl = this.plTurn;
    addLabel(tile, pl.sym, { fz: 60, fg: pl.color });
    this.controller.evaluate(tile);
  }
  afterComputerMove(iMove) {
    let tile = this.board.items[iMove];
    this.interact({ target: iDiv(tile) });
  }
  eval() {
    let done = this.checkFinal();
    this.gameOver = done > 0;
    if (this.gameOver) { this.winner = done > 1 ? this.plTurn : null; this.tie = done == 1; }
  }
  checkFinal(state) {
    if (nundef(state)) state = this.getState();
    let isTie = false;
    let isWin = checkWinnerTTT(state);
    if (!isWin) { isTie = checkBoardFull(state) || !checkPotentialTTT(state); }
    return isWin ? 2 : isTie ? 1 : 0;
  }
  getState() { return this.board.getState(); }
  applyMove(state, move, player) { arrReplaceAtInPlace(state, move, player.sym); }
  undoMove(state, move, player) { arrReplaceAtInPlace(state, move, ' '); }
  getAvailableMoves(state) {
    let moves = [];
    for (let i = 0; i < state.length; i++) {
      if (EmptyFunc(state[i])) moves.push(i);
    }
    shuffle(moves);
    return moves;
  }
  heuristic1(node, depth) { }
  evalState(node, depth) {
    let x = checkWinnerTTT(node);
    if (checkBoardFull(node) || x) {
      return { reached: true, val: (!x ? 0 : (10 - depth) * (x == MAXIMIZER.sym ? 1 : -1)) };
    }
    return { reached: false };
  }
  evalStateL(node, depth) {
    let key = node.join('');
    let val = DMM[key];
    let x = isdef(val) ? val : checkWinnerTTT(node);
    DMM[key] = x;
    if (checkBoardFull(node) || x) {
      return { reached: true, val: (!x ? 0 : (10 - depth) * (x == MAXIMIZER.sym ? 1 : -1)) };
    }
    return { reached: false };
  }
  evalStateL2(node, depth) {
    let full = checkBoardFull(node);
    if (full) {
      let key = JSON.stringify(node);
      let x = DMM[key];
      if (nundef(x)) DMM[key] = x = checkWinnerTTT(node);
      return { reached: true, val: (!x ? 0 : (10 - depth) * (x == MAXIMIZER.sym ? 1 : -1)) };
    } else {
      let x = checkWinnerTTT(node);
      if (x) return { reached: true, val: (!x ? 0 : (10 - depth) * (x == MAXIMIZER.sym ? 1 : -1)) };
      return { reached: false };
    }
  }
}
class GC4 extends GTTT {
  startGame() {
    super.startGame();
  }
  createBoard() {
    this.board = new Board(this.rows, this.cols, this.controller.uiInteract.bind(this.controller), { margin: 6, w: 60, h: 60, bg: 'white', fg: 'black', rounding: '50%' });
  }
  setStartPosition() {
    let positions = [
      [[0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0]],
      [[0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      ['O', 'X', 0, 0, 0, 0, 0],
      ['O', 'X', 0, 0, 0, 0, 0]],
      [[0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      ['O', 'X', 0, 0, 0, 0, 0],
      ['O', 'X', 0, 0, 0, 0, 0],
      ['O', 'X', 0, 0, 0, 0, 0]],
      [[0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 'O', 0, 0, 0],
      ['O', 'X', 0, 'O', 0, 0, 0],
      ['O', 'X', 0, 'O', 0, 0, 0]],
      [[0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, "X", 0, 0, 0],
      ["X", 0, 0, "O", 0, 0, 0],
      ["O", "X", 0, "O", 0, 0, 0],
      ["O", "X", "O", "O", 0, 0, 0]],
      [[0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0],
      ["X", 0, 0, 0, 0, 0, 0],
      ["X", 0, 0, 0, "O", "O", 0]],
    ];
    this.iPosition = 4;
    if (isdef(this.iPosition)) {
      let idx = this.iPosition + 1; idx = idx % positions.length; this.iPosition = idx;
    } else this.iPosition = 0;
    let state = nundef(this.startPosition) || this.startPosition == 'empty' ? positions[0]
      : this.startPosition == 'random' ? chooseRandom(positions)
        : positions[this.iPosition];
    this.board.setState(state, { X: this.ai.color, O: this.human.color });
  }
  checkFinal(state) {
    if (nundef(state)) state = this.getState();
    let isTie = false;
    let isWin = checkWinnerC4(state, this.rows, this.cols, this.stride);
    if (!isWin) { isTie = checkBoardFull(state); }
    return isWin ? 2 : isTie ? 1 : 0;
  }
  checkLegal(tile) {
    let col = tile.col;
    let topmost = this.board.items[col];
    if (EmptyFunc(topmost.label)) return true; else return false;
  }
  findBottomEmptyTileInColumn(col) {
    let x = lastCond(this.board.items, x => x.col == col && EmptyFunc(x.label));
    return x;
  }
  interact(ev) {
    let tile = evToItemC(ev);
    let legal = this.checkLegal(tile);
    if (!legal) { console.log('illegal move!'); return; }
    let pl = this.plTurn;
    let bottomMost = this.findBottomEmptyTileInColumn(tile.col);
    addLabel(bottomMost, pl.sym, { fz: 60, fg: pl.color });
    this.controller.evaluate(tile);
  }
  getAvailableMoves(state) {
    let moves = [];
    for (let c = 0; c < G.cols; c++) {
      for (let r = G.rows - 1; r >= 0; r--) {
        let i = r * G.cols + c;
        if (EmptyFunc(state[i])) { moves.push(i); break; }
      }
    }
    shuffle(moves)
    return moves;
  }
  evalState(node, depth) {
    let x = checkWinnerC4(node);
    if (checkBoardFull(node) || x) {
      let res = { reached: true, val: (!x ? 0 : (10 - depth) * (x == MAXIMIZER.sym ? 1 : -1)) };
      return res;
    }
    return { reached: false };
  }
}
class GReversi extends GTTT {
  createBoard() {
    this.board = new Board(this.rows, this.cols, this.controller.uiInteract.bind(this.controller), { margin: 6, w: 60, h: 60, bg: 'white', fg: 'black', rounding: '50%' });
  }
  setStartPosition() {
    let positions = [
      [[0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0],
      [0, 0, 'O', 'X', 0, 0],
      [0, 0, 'X', 'O', 0, 0],
      [0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0]],
    ];
    if (isdef(this.iPosition)) {
      let idx = this.iPosition + 1; idx = idx % positions.length; this.iPosition = idx;
    } else this.iPosition = 0;
    if (this.startPosition == 'empty' || this.rows != 6 || this.cols != 6) {
      let pos = bCreateEmpty(this.rows, this.cols);
      let r1 = this.rows / 2 - 1, r2 = this.rows / 2, c1 = this.cols / 2 - 1, c2 = this.cols / 2;
      pos[r1 * this.cols + c1] = pos[r2 * this.cols + c2] = 'O';
      pos[r1 * this.cols + c2] = pos[r2 * this.cols + c1] = 'X';
      positions[0] = pos;
    }
    let state = nundef(this.startPosition) || this.startPosition == 'empty' ? positions[0]
      : this.startPosition == 'random' ? chooseRandom(positions)
        : positions[this.iPosition];
    this.board.setState(state, { X: this.ai.color, O: this.human.color });
  }
  startGame() {
    super.startGame();
    this.setStartPosition();
  }
  checkLegal(tile) {
    let state = this.getState();
    if (!EmptyFunc(tile.label)) return false;
    let nei = bNei(state, tile.index, this.rows, this.cols, true);
    for (const n of nei) {
      if (!n) continue;
      let t = state[n];
      if (!EmptyFunc(t)) return true;
    }
    console.log('ILLEGAL MOVE! tile', tile.index, 'does not have neighbor!')
    return false;
  }
  interact(ev) {
    let tile = evToItemC(ev);
    if (!this.checkLegal(tile)) return;
    let pl = this.plTurn;
    addLabel(tile, pl.sym, { fz: 60, fg: pl.color });
    let state = this.getState();
    let iCapt = bCapturedPieces(pl.sym, state, tile.index, this.rows, this.cols);
    for (const i of iCapt) {
      let item = this.board.get(i);
      modLabel(item, this.plTurn.sym, { fg: this.plTurn.color });
    }
    this.controller.evaluate(tile);
  }
  activate() {
    let pl = this.plTurn;
    let autoplay = false;
    if (autoplay || pl == this.ai) {
      if (this.ai == pl) uiActivated = false;
      setTimeout(() => AIMinimax(this, this.afterComputerMove.bind(this)), 200);
    }
  }
  checkFinal(state, pl1, pl2) {
    if (nundef(state)) state = this.getState();
    if (nundef(pl1)) pl1 = this.plTurn;
    if (nundef(pl2)) pl2 = this.plOpp;
    return GReversi.checkEnd(state, pl1, pl2);
  }
  static checkEnd(state, pl1, pl2) {
    let hasPl1 = false, hasPl2 = false, s1 = pl1.sym, s2 = pl2.sym, hasEmpty = false;
    for (const s of state) {
      if (!hasPl1 && s == s1) hasPl1 = true;
      else if (!hasPl2 && s == s2) hasPl2 = true;
      else if (!hasEmpty && EmptyFunc(s)) hasEmpty = true;
      if (hasPl1 && hasPl2 && hasEmpty) return false;
    }
    let winner = !hasPl2 ? pl1 : !hasPl1 ? pl2 : 0;
    let full = !hasEmpty;
    if (full) {
      let n1 = arrCount(state, x => x == s1);
      let n2 = arrCount(state, x => x == s2);
      if (!winner && n1 != n2) {
        if (n1 > n2) winner = pl1; else winner = pl2;
      }
    }
    return winner ? { reached: true, winner: winner } : full ? { reached: true, winner: null } : { reached: false };
  }
  heuristic(state, plMax, plMin) {
    let vmax = 0, vmin = 0;
    vmax = vmax + arrCount(state, x => x == plMax.sym);
    vmin = vmin + arrCount(state, x => x == plMin.sym);
    return vmax - vmin;
  }
  heureval(state) {
    let heurinfo = GReversi.heuristic(state, MAXIMIZER, MINIMIZER);
    let val = heurinfo.val;
    return val;
  }
  eval() {
    this.moveCounter += 1;
    let info = this.checkFinal();
    this.gameOver = info.reached;
    if (this.gameOver) {
      this.winner = info.winner;
      this.tie = !info.winner;
      if (this.winner) {
        this.loser = this.winner == this.ai ? this.human : this.ai;
        let state = this.getState();
        let nWinner = arrCount(state, x => x == this.winner.sym);
        let nLoser = arrCount(state, x => x == this.loser.sym);
        this.info = '(' + nWinner + ':' + nLoser + ')';
      }
    }
  }
  getAvailableMoves(state) {
    let moves = [];
    for (let i = 0; i < state.length; i++) {
      if (EmptyFunc(state[i])) {
        let nei = bNei(state, i, G.rows, G.cols, true);
        let iFull = firstCond(nei, x => !EmptyFunc(state[x]));
        if (iFull != null) moves.push(i);
      }
    }
    return moves;
  }
  evalState(state, depth) {
    let info = GReversi.checkEnd(state, MAXIMIZER, MINIMIZER);
    let val = info.reached && info.winner ? (100 - depth) * (info.winner == MAXIMIZER ? 1 : -1) : 0;
    return { reached: info.reached, val: val };
  }
  applyMove(state, move, player) {
    arrReplaceAtInPlace(state, move, player.sym);
    let iCapt = bCapturedPieces(player.sym, state, move, G.rows, G.cols);
    for (const i of iCapt) { state[i] = player.sym; }
  }
}
class GChess extends G2Player {
  clear() { super.clear(); if (isdef(this.game)) { this.game.reset(); } }
  startGame() {
    super.startGame();
    this.createBoard();
    this.game = new Chess();
    this.setStartPosition();
    let c = this.game.turn();
    if (c == 'b') { this.plTurn.color = 'black'; this.plOpp.color = 'white'; } else { this.plTurn.color = 'white'; this.plOpp.color = 'black'; }
    showFleetingMessage(`You play ${this.human.color}`)
  }
  createBoard() {
    let d = mDiv(dTable, { h: 500, w: 500 }, 'dChessBoard');
    let config = {
      pieceTheme: '../alibs/chessBoard/img/chesspieces/wikipedia/{piece}.png',
      draggable: true,
      onDragStart: this.onDragStart.bind(this),
      onDrop: this.onDrop.bind(this),
      onSnapEnd: this.onSnapEnd.bind(this),
    }
    this.board = ChessBoard('dChessBoard', config);
    mLinebreak(dTable);
  }
  setStartPosition() {
    let positions = [
      'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1',
      // //'8/8/8/8/8/8/8/8 b KQkq - 0 1', //black starts
    ];
    if (nundef(this.iPosition)) this.iPosition = 0;
    let state = nundef(this.startPosition) || this.startPosition == 'empty' ? positions[0] : this.startPosition == 'random' ? chooseRandom(positions) : positions[this.iPosition];
    if (!isString(state)) state = arrToFen(state.arr, state.plStart);
    this.game.load(state); //'r1bqkbnr/pppp1ppp/2n5/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 0 1');
    this.board.position(this.game.fen());
    let idx = this.iPosition + 1; idx = idx % positions.length; this.iPosition = idx;
  }
  prompt() {
    let msg = this.plTurn == this.ai && !this.manual ? `Ai (${this.ai.color.toUpperCase()}) thinking...`
      : `player: ${this.plTurn.color.toUpperCase()}`;
    showInstruction(this.game.in_check() ? '- CHECK!!!' : '', msg, dTitle, false);
    this.controller.activateUi();
  }
  activate() {
    let pl = this.plTurn;
    let autoplay = false;
    if (autoplay || pl == this.ai) {
      if (this.ai == pl) { uiActivated = false; aiActivated = true; }
      this.TO = setTimeout(() => {
        let color = this.game.turn();
        if (color === 'b') { var move = getBestMove(this.game, color, globalSum)[0]; }
        else { var move = getBestMove(this.game, color, -globalSum)[0]; }
        globalSum = evaluateBoard(move, globalSum, 'b');
        this.game.move(move);
        this.board.position(this.game.fen());
        this.controller.evaluate();
      }, 100);
    } else { aiActivated = false; uiActivated = true; }
  }
  getTurnColor() { return this.getPlayer(this.game.turn() == 'b' ? 'black' : 'white'); }
  getOppColor() { return this.getPlayer(this.game.turn() == 'b' ? 'white' : 'black'); }
  getPlayer(color) { return firstCond(this.players, x => x.color == color); }
  changePlayer() { this.plTurn = this.game.turn() == 'b' ? this.getPlayer('black') : this.getPlayer('white'); }
  onDragStart(source, piece, position, orientation) {
    if (this.game.game_over() || !uiActivated) return false;
    if ((this.game.turn() === 'w' && piece.search(/^b/) !== -1) ||
      (this.game.turn() === 'b' && piece.search(/^w/) !== -1)) {
      return false
    }
  }
  onDrop(source, target) {
    var move = this.game.move({
      from: source,
      to: target,
      promotion: 'q'
    });
    if (move === null) return 'snapback';
    this.controller.evaluate();
  }
  onSnapEnd() { this.board.position(this.game.fen()) }
  eval() {
    this.info = null;
    let over = this.gameOver = this.game.game_over();
    if (this.game.in_draw()) { this.tie = true; console.log('in_draw'); this.info = '(draw)'; }
    if (this.game.in_stalemate()) { this.tie = true; console.log('in_stalemate'); this.info = '(stalemate)'; }
    if (this.game.in_threefold_repetition()) { this.tie = true; console.log('in_threefold_repetition'); this.info = '(threefold repetition)'; }
    if (this.game.in_checkmate()) {
      this.tie = false;
      this.winner = this.getOppColor();
      console.log('in_checkmate');
      this.info = `(${this.winner.color.toUpperCase()})`;
    }
  }
}
class GSayPic extends Game {
  constructor(name, o) { super(name, o); }
  clear() { Speech.stopRecording(); }
  prompt() {
    myShowPics();
    setGoal();
    let wr = (this.language == 'E' ? 'say: ' : "sage: ");
    show_instruction(wr + `<b>${Goal.label.toUpperCase()}</b>`, dTitle);
    animate(dInstruction, 'pulse800' + bestContrastingColor(this.color, ['yellow', 'red']), 900);
    mLinebreak(dTable, 25);
    MicrophoneUi = mMicrophone(dTable, this.color);
    MicrophoneHide();
    TOMain = setTimeout(this.controller.activateUi.bind(this.controller), 200);
  }
  trialPrompt(nTrial) {
    sayRandomVoice(nTrial < 2 ? 'speak UP!!!' : 'Louder!!!', 'LAUTER!!!');
    animate(dInstruction, 'pulse800' + bestContrastingColor(this.color, ['yellow', 'red']), 500);
    return 600;
  }
  activate() {
    if (Speech.isSpeakerRunning()) {
      TOMain = setTimeout(this.activate.bind(this), 200);
    } else {
      TOMain = setTimeout(() => Speech.startRecording(this.language, this.controller.evaluate.bind(this.controller)), 100);
    }
  }
  eval(isfinal, speechResult, confidence, sessionId) {
    if (sessionId != SessionId) {
      alert('NOT THIS BROWSER!!!!!!'); return undefined;
    }
    let answer = Goal.answer = normalize(speechResult, this.language);
    let reqAnswer = Goal.reqAnswer = normalize(Goal.label, this.language);
    Selected = { reqAnswer: reqAnswer, answer: answer, feedbackUI: iDiv(Goal) };
    if (isEmpty(answer)) return false;
    else return isSimilar(answer, reqAnswer) || isList(Goal.info.valid) && firstCond(Goal.info.valid, x => x.toUpperCase() == answer.toUpperCase());
  }
}
class GProg0 extends Game {
  constructor(name, o) { super(name, o); }
  startGame(fen) {
  }
  prompt() {
    let c = this.card0 = cLandscape(dTable);
    this.card1 = iDiv(c).style;
    this.card2 = iDiv(c);
    this.card3 = iDiv(c);
    show_instruction('write code what rank and suit this card should have', dTitle);
    mLinebreak(dTable, 25);
    let dCode = mDiv(dTable, {});
    let ta = this.ta = mCreate('textarea');
    mAppend(dCode, ta);
    ta.setAttribute('rows', 10);
    ta.setAttribute('cols', 60);
    mStyle(ta, { family: 'courier', padding: 10 });
    ta.value = `mStyle(iDiv(G.card0),{bg:'pink'})`;
    ta.value = `this.card1.background = 'yellow'`;
    ta.value = `this.card2.style.background = 'yellow'`;
    ta.value = `this.set('background','red');`;
    ta.value = `this.set(this.card1,'background','red');`;
    ta.value = `set(card1,'background','red');`;
    ta.value = `card.background = 'red';`;
    ta.value = `card.color = 'red';`;
    ta.value = `card.color = 'red';`;
    mLinebreak(dTable, 25);
    mButton('run', this.runCode.bind(this), dTable, { bg: 'skyblue', fg: 'black', fz: 32 }, 'mybutton');
    console.log('type of style', typeof this.card1);
  }
  set(o, prop, val) {
    o[prop] = val;
  }
  runCode() {
    let code = this.ta.value;
    let prelim = '';
    prelim = 'let card = this.card1; ';
    prelim = `
    var card = new ProgObject(this.card0);
    console.log('card',card);
    `;
    prelim = `
    var obj = {};
    Object.defineProperty(obj, prop, {
        get: function() {return this.card1; },
        set: function(val) { this.card1.val = val; }
    });
    `
    code = prelim + code;
    console.log('code', code);
    eval(code);
  }
}
class GProg1 extends Game {
  constructor(name, o) { super(name, o); }
  prompt() {
    let c = this.card = cLandscape(dTable);
    let d = this.visual = iDiv(c);
    this.style = d.style;
    let propertyGiver1 = (o, prop, setter) => {
      Object.defineProperty(o, prop, {
        get: function () { return this.val; },
        set: function (val) { this.val = val; setter(val); }
      });
    };
    let visualPropertySetter1 = (o) => {
      propertyGiver1(o, 'bg', x => { mStyle(G.visual, { 'bg': x }); });
    }
    visualPropertySetter1(this.card);
    d.innerHTML = 'HALLO';
    mStyle(d, { fg: 'blue' });
    mLinebreak(dTable, 25);
    let dCode = mDiv(dTable, {});
    let ta = this.ta = mCreate('textarea');
    mAppend(dCode, ta);
    ta.setAttribute('rows', 10);
    ta.setAttribute('cols', 60);
    mStyle(ta, { family: 'courier', padding: 10 });
    ta.value = `card.bg = 'red'; console.log(card.bg);`;
    mLinebreak(dTable, 25);
    mButton('run', this.runCode.bind(this), dTable, { bg: 'skyblue', fg: 'black', fz: 32 }, 'mybutton');
    console.log('type of style', typeof this.card1);
  }
  runCode() {
    let code = this.ta.value;
    let prelim = '';
    prelim = 'let [card,visual,style] = [this.card,this.visual,this.style]; ';
    code = prelim + code;
    console.log('code', code);
    eval(code);
  }
}
class IClass extends LiveObject {
  constructor(k, U, G, T) {
    super(k);
    this.player = {};
    copyKeys(U, this.player);
    copyKeys(G, this);
    copyKeys(T, this);
    this.running = false;
    this.uiState = this.immediateStart ? LiveObject.States.ready : LiveObject.States.none;
    this.startTime = Date.now();
    this.div = null;
  }
  loop() {
    this.update();
    this.present();
    this.activate();
  }
  getState() {
    return { players: this.players, table: this.table, options: this.options, turn: this.turn };
  }
  setState(s) {
    this.players = s.players;
    this.table = s.table;
    this.options = s.options;
    this.turn = s.turn;
  }
  present() {
    console.log('state', this.getState());
  }
  update() {
    for (const pl of this.players) this.updatePlayer(pl);
    this.updateTable();
    this.updateTurn();
    this.updateOptions(this.player);
  }
  updateOptions() { this.options = {}; }
  updatePlayer() { }
  updateTable() { this.table = {}; }
  updateTurn() { this.turn = chooseRandom(this.players).id; }
}
class GGuess extends IClass {
  setup() {
  }
  updatePlayer(pl) {
  }
  updateOptions(pl) {
    this.options = Array.from('ABCDEFGHIJKLMNOPQRSTUVWXYZ');
    console.log(this.options);
  }
}
class AddonClass extends LiveObject {
  constructor(k, dbInfo, userInfo) {
    super(k);
    copyKeys(dbInfo, this);
    copyKeys(userInfo, this);
    this.running = false;
    this.uiState = this.immediateStart ? LiveObject.States.ready : LiveObject.States.none;
    this.startTime = Date.now();
    this.callback = this.div = this.dContent = null;
  }
  //#region internal
  _createDivs() {
    this.dInstruction = mDiv(this.dContent);
    this.dMain = mDiv(this.dContent);
    this.dHint = mDiv(this.dContent); this.dHint.innerHTML = 'hallo'; this.dHint.style.opacity = 0;
  }
  _createScreen() {
    show(mBy('dAddons'));
    let bg = colorTrans('silver', .25);
    let d = mScreen(mBy('dAddons'), { bg: bg, display: 'flex', layout: 'fvcc' });
    let dContent = mDiv(d, { display: 'flex', layout: 'fvcs', fg: 'contrast', fz: 24, bg: 'silver', patop: 50, pabottom: 50, matop: -50, w: '100vw' });
    return [d, dContent];
  }
  //#endregion
  checkEndCondition() {
    let c = this.endsWhen;
    let res = false;
    if (isdef(c) && this[c.prop] == c.value) res = true;
    console.log('condition:', res, 'tNext', this.tNext)
    return res;
  }
  exit() {
    hide('dAddons');
    this.tNext *= this.tFactor;
    this.startTime = Date.now();
    this.clear();
    this.callback();
  }
  init() {
    [this.div, this.dContent] = this._createScreen();
    this._createDivs();
    this.setRunning();
    let caption = this.presentInit();
    mButton(isdef(caption) ? caption : 'Got it!', this.prompt.bind(this), this.dContent, { fz: 32, matop: 10 });
  }
  isTimeForAddon() {
    switch (this.uiState) {
      case LiveObject.States.none: this.getReady(this.tNext); return false;
      case LiveObject.States.gettingReady: return false;
      case LiveObject.States.ready: return true;
      case LiveObject.States.running: return Date.now() - this.startTime >= this.tNext;
    }
  }
  presentInit() { console.log('presenting initial information'); }
  presentPrompt() { console.log('prompting user to do something') }
  prompt() {
    clearElement(this.dContent);
    this.trialsNeeded = 0;
    this._createDivs();
    this.presentPrompt();
    this.activate();
  }
  processInput() {
    if (!this.uiActivated) return;
    this.uiActivated = false;
    let isCorrect = this.eval(...arguments);
    if (isCorrect) {
      this.positive();
      this.exit();
    } else {
      this.negative();
      this.trialPrompt();
    }
  }
  positive() {
    this.trialNumber = null;
    delete this.dHint;
  }
  negative() {
    if (nundef(this.trialNumber)) this.trialNumber = 1; else this.trialNumber += 1;
  }
  run() {
    show('dAddons');
    if (this.running) { this.prompt(); } else this.init();
  }
  trialPrompt() {
    this.trialsNeeded += 1;
    let [wr, sp] = this.getHint();
    this.hintLength = wr.length;
    if (isdef(sp)) sayRandomVoice(sp);
    this.dHint.innerHTML = 'Hint: ' + wr; this.dHint.style.opacity = 1;
    this.activate();
  }
}
class APasscode extends AddonClass {
  constructor(k, dbInfo, userInfo) {
    super(k, dbInfo, userInfo);
    this.needNewPasscode = true;
  }
  presentInit() {
    let keys = getRandomKeysFromGKeys(1);
    let options = { rows: 1 };
    this.pictures = getPics(null, {}, options, keys);
    this.goal = this.pictures[0];
    this.passcode = this.goal.label;
    let dParent = this.dContent;
    let d_title = mDiv(dParent);
    showInstruction(this.goal.label, Settings.language == 'E' ? 'the passcode is' : 'das Codewort ist', d_title, true);
    let d_pics = mDiv(dParent);
    presentItems(this.pictures, d_pics, options.rows);
    this.TOList.push(setTimeout(anim1, 300, this.goal, 500));
  }
  presentPrompt() {
    let keys = getRandomKeysIncluding(this.numPics, this.goal.key, 'all');
    let iGoal = keys.indexOf(this.goal.key);
    let options = { rows: 2, showLabels: true };
    this.pictures = getPics(this.processInput.bind(this), undefined, { rows: 2, showLabels: true }, keys);
    this.goal = this.pictures[iGoal];
    showInstruction('', 'click ' + (Settings.language == 'E' ? 'the passcode' : 'das Codewort'), this.dInstruction, true);
    presentItems(this.pictures, this.dMain, options.rows);
  }
  eval(ev) {
    ev.cancelBubble = true;
    let item = findItemFromEvent(this.pictures, ev);
    Selected = { pic: item, feedbackUI: item.div, sz: getBounds(item.div).height };
    Selected.reqAnswer = this.goal.label;
    Selected.answer = item.label;
    if (item.label == this.goal.label) { return true; } else { return false; }
  }
  getHint() {
    let hintLength, spoken;
    if (this.trialNumber > this.passcode.length * 2) {
      hintLength = this.passcode.length;
      spoken = 'click ' + this.passcode.toUpperCase() + '!!!';
    } else if (this.trialNumber > this.passcode.length * 2 - 1) {
      hintLength = this.passcode.length;
      spoken = (Settings.language == 'E' ? 'REMEMBER ' : 'MERKE DIR ') + this.passcode.toUpperCase() + '!!!';
    } else if (this.trialNumber > this.passcode.length) {
      hintLength = (this.trialNumber - this.passcode.length);
      let letters = this.passcode.substring(0, hintLength);
      let letters1 = letters.split();
      spoken = (Settings.language == 'E' ? 'the passcode starts with' : 'das Codewort beginnt mit') + ' ' + letters1.join(', ');
    } else {
      hintLength = this.trialNumber;
      spoken = null;
    }
    return [this.passcode.substring(0, hintLength), spoken];
  }
}
class AAddress extends APasscode {
  constructor(k, dbInfo, userInfo) {
    super(k, dbInfo, userInfo);
  }
  clear() { super.clear(); Speech.setLanguage(Settings.language); window.onclick = null; }
  presentInit() {
    this.msgPrompt = 'enter your address';
    this.lastHintPrompt = 'please complete entering address!';
    this.goal = { label: '17448 NE 98th Way Redmond 98052' };
    Speech.setLanguage('E')
    let wr = 'your address is:';
    let sp = 'your address is 1 7 4 4 8 - North-East 98th Way - Redmond, 9 8 0 5 2';
    showInstruction(this.goal.label, wr, this.dInstruction, true, sp, 12);
    this.goal.div = mText(this.goal.label, this.dMain, { fz: 40 });
    this.TOList.push(setTimeout(anim1, 300, this.goal, 500));
  }
  presentPrompt() {
    Speech.setLanguage('E');
    stdInstruction(this.msgPrompt, this.dInstruction, this.msgPrompt, { voice: 'zira' });
    this.input = stdInput(this.dMain, { w: 600, fz: 24 });
    this.input.id = this.defaultFocusElement = 'inputAddon';
    this.nCorrect = 0;
  }
  activate() {
    window.onclick = () => mBy(this.defaultFocusElement).focus();
    this.input.onkeyup = ev => {
      if (ev.key === "Enter") {
        ev.cancelBubble = true;
        this.processInput(ev);
      }
    };
    this.input.focus();
    super.activate();
  }
  eval() {
    let correctPrefix = this.correctPrefix = getCorrectPrefix(this.goal.label, this.input.value);
    return correctPrefix == this.goal.label;
  }
  getHint() {
    let oldHintLength = isdef(this.hintLength) ? this.hintLength : 0;
    if (nundef(this.hintLength)) this.hintLength = 0;
    this.input.value = this.correctPrefix;
    let progress = this.correctPrefix.length > this.nCorrect;
    if (this.correctPrefix.length > this.nCorrect) {
      this.hintLength = 1;
      this.nCorrect = this.correctPrefix.length;
    } else if (this.hintLength < this.goal.label.length - this.nCorrect) this.hintLength += 1;
    if (this.hintLength == 0) this.hintLength = 1;
    let wr = substringOfMinLength(this.goal.label, this.correctPrefix.length, this.hintLength);
    let sp = oldHintLength == this.hintLength && !progress ? this.lastHintPrompt : null;
    return [wr, sp];
  }
}
class APassword extends AAddress {
  presentInit() {
    this.goal = null;
    Speech.setLanguage('E');
    let msg = 'create a new password!';
    this.msgPrompt = 'enter your password';
    this.lastHintPrompt = 'please complete entering password!';
    stdInstruction(msg, this.dInstruction, msg, { voice: 'zira' });
    this.input = stdInputVal(this.dMain, { w: 600, fz: 24 }, 'hallo');
    this.input.id = this.defaultFocusElement = 'inputAddon';
    window.onclick = () => mBy(this.defaultFocusElement).focus();
    return 'set password';
  }
  presentPrompt() {
    if (nundef(this.goal)) this.goal = { label: this.input.value.trim() };
    super.presentPrompt();
  }
}
class GPasscode extends Game {
  constructor(name, o) { super(name, o); this.needNewPasscode = true; }
  clear() { clearTimeout(this.TO); clearTimeCD(); }
  startGame() {
    this.incrementLevelOnPositiveStreak = this.samplesPerGame;
    this.decrementLevelOnNegativeStreak = this.samplesPerGame;
  }
  start_Level() { this.needNewPasscode = true; }
  prompt() {
    this.trials = 1;
    if (this.needNewPasscode) {
      this.timeout = 1000;
      this.needNewPasscode = false;
      let keys = getRandomKeysFromGKeys(this.passcodeLength);
      myShowPics(null,
        { border: '3px solid #ffffff80' },
        { numRepeat: this.numRepeat, sameBackground: true }, keys);
      Goal = Pictures[0];
      this.wort = (this.language == 'E' ? 'the passcode' : 'das Codewort');
      showInstruction(Goal.label, this.wort + (this.language == 'E' ? ' is' : ' ist'), dTitle, true);
      TOMain = setTimeout(anim1, 300, Goal, 500, showGotItButton);
    } else {
      this.timeout *= 2;
      doOtherStuff();
    }
  }
  eval(x) {
    CountdownTimer.cancel();
    let isCorrect = super.eval(x);
    if (!isCorrect) this.needNewPasscode = true;
    return isCorrect;
  }
}
class GStory extends Game {
  constructor(name) { super(name); }
  prompt() {
    let showLabels = G.showLabels == true && Settings.labels == true;
    myShowPics(evaluate, {}, { showLabels: showLabels });
    setGoal();
    showInstruction(Goal.label, 'click', dTitle, true);
    activateUi();
  }
}
class GSentence1 extends Game {
  constructor(name, o) {
    super(name, o);
    this.prevLanguage = this.language;
    this.language = 'E';
  }
  startGame() {
    this.correctionFunc = showCorrectPictureLabels;
    this.failFunc = failSomePictures;
    this.successFunc = () => { mCheckit(this.dWordArea, 120); };
  }
  clear() { super.clear(); this.language = this.prevLanguage; }
  start_Level() {
    this.sentences = EnglishSentences.map(x => x.split(' ')).filter(x => x.length <= this.maxWords);
  }
  dropHandler(source, target, isCopy = false, clearTarget = false) {
    let prevTarget = source.target;
    source.target = target;
    let dSource = iDiv(source);
    let dTarget = iDiv(target);
    if (clearTarget) {
      let ch = dTarget.children[0];
      let chSource = firstCond(Pictures, x => iDiv(x) == ch);
      if (chSource) {
        if (isdef(prevTarget)) {
          mAppend(iDiv(prevTarget), ch);
          chSource.target = prevTarget;
        } else {
          mAppend(this.dWordArea, ch);
          delete chSource.target;
        }
      }
      clearElement(dTarget);
    }
    if (isCopy) {
      let dNew = mText(dSource.innerHTML, dTarget, { wmin: 100, fz: 20, padding: 4, margin: 4, display: 'inline-block' });
      addDDSource(dNew, isCopy, clearTarget);
    } else {
      mAppend(dTarget, dSource);
    }
  }
  prompt() {
    let words = this.sentence = chooseRandom(this.sentences);
    showInstruction('', 'drag words into blanks', dTitle, true);
    mLinebreak(dTable);
    let fz = 32;
    let h = fz * 1.25, wmin = fz * 1.25;
    let items = Pictures = [];
    let containers = [];
    let options = _simpleOptions({ fz: fz, bg: 'transparent', fg: 'white', showPic: false, showLabels: true }, { wmin: wmin });
    let dArea = mDiv(dTable, { h: 150, display: 'flex', 'flex-wrap': 'wrap', layout: 'fhcc' });
    mLinebreak(dTable);
    let dWordArea = this.dWordArea = mDiv(dTable, { h: 70, wmin: 20, display: 'flex', 'flex-wrap': 'wrap', layout: 'fhcc' });
    let i = 0;
    for (const word of words) {
      let item = { label: word, index: i };
      let container = { label: word, index: i };
      i += 1;
      let d = makeItemDiv(item, options);
      let dCont = mDiv(dArea, { wmin: wmin + 12, hmin: h + 10, bg: colorTrans('beige', .25), fg: 'black', margin: 12 });
      container.div = dCont;
      items.push(item);
      containers.push(container);
    }
    shuffle(items);
    items.map(x => { mAppend(dWordArea, iDiv(x)); mStyleX(iDiv(x), { h: h, w: 'auto' }); });
    enableDD(items, containers, this.dropHandler.bind(this), false, true);
    mLinebreak(dTable, 50);
    mButton('Done!', this.controller.evaluate.bind(this.controller), dTable, { fz: 28, matop: 10, rounding: 10, padding: 16, border: 8 }, ['buttonClass']);
    this.controller.activateUi.bind(this.controller)();
  }
  trialPrompt() {
    sayTryAgain();
    showFleetingMessage('Try again!', 0, { fg: 'white' });
    TOMain = setTimeout(() => { Pictures.map(x => mAppend(this.dWordArea, iDiv(x))); }, 1200);
    return 1500;
  }
  eval() {
    let i = 0;
    let isCorrect = true;
    for (const p of Pictures) {
      let cont = p.target;
      if (nundef(cont)) p.isCorrect = isCorrect = false;
      else if (p.index != cont.index) p.isCorrect = isCorrect = false;
      else p.isCorrect = true;
    }
    Selected = { piclist: Pictures, feedbackUI: Pictures.map(x => iDiv(x)), sz: getRect(iDiv(Pictures[0])).h + 10 };
    return isCorrect;
  }
}
class CCanvasNoClear extends CCanvas {
  clear() { }
}
class CCanvasPlot extends CCanvas {
  clear() {
    cClear(this.cv, this.cx);
    this.draw_axes();
  }
  draw_axes() {
    let ctx = this.cx;
    ctx.beginPath();
    ctx.strokeStyle = "rgb(128,128,128)";
    ctx.moveTo(this.minx, 0); ctx.lineTo(this.maxx, 0);
    ctx.moveTo(0, this.miny); ctx.lineTo(0, this.maxy);
    ctx.stroke();
  }
  draw() {
    this.clear();
    for (const item of this.items) {
      if (isdef(item.func)) this.plot(item.func, item.color, item.thickness);
      else {
        super.draw_item(item);
      }
    }
  }
  pp(x, y, label = 'hallo', styles = {}) {
    addKeys({ fg: 'silver', bg: 'silver', w: 3, h: 3 }, styles)
    cEllipse(x, y, styles.w, styles.h, { bg: styles.bg }, 0, this.cx);
    addKeys({ x: x, y: y, offy: 'below 4', offx: 'center', family: 'arial narrow', fz: 20 }, styles);
    draw_text(this, label, styles);
  }
  plot(func, color, thick, filled = false) {
    let cx = this.cx;
    var xx, yy, dx = 4, x0 = 0, y0 = 0, scale = this.scale = 40;
    var imax = Math.round(this.maxx / dx);
    var imin = Math.round(this.minx / dx);
    cx.beginPath();
    cx.lineWidth = thick;
    cx.strokeStyle = cx.fillStyle = color;
    for (var i = imin; i <= imax; i++) {
      xx = dx * i; yy = scale * func(xx / scale);
      if (i == imin) cx.moveTo(x0 + xx, y0 - yy);
      else cx.lineTo(x0 + xx, y0 - yy);
    }
    cx.stroke(); if (filled) cx.fill();
  }
}
class GAnagramBROKEN extends Game {
  constructor(name, o) {
    super(name, o);
    if (this.language == 'C') {
      this.realLanguage = this.language;
      this.language = chooseRandom('E', 'S', 'F', 'D');
    }
  }
  clear() { super.clear(); if (isdef(this.language)) this.language = this.language; }
  start_Level() {
    this.keys = setKeysG(this, filterWordByLengthG, 10);
    if (this.keys.length < 10) { this.keys = setKeysG(this, filterWordByLengthG, 10, 'all'); }
  }
  prompt() {
    myShowPics(null, {}, {});
    if (this.hidden) {
      let d = iDiv(Pictures[0]);
      animate(d, 'aniAppearMinute', 100000);
    }
    setGoal();
    let w = this.showWord ? Goal.label : '';
    let wr = `drag letters to form ${w}`;
    let sp = `forme ${w}`;
    show_instruction(wr, dTitle, sp);
    mLinebreak(dTable, 22);
    let word = Goal.label.toUpperCase();
    let wlen = word.length;
    let wTable = getRect(mBy('table')).w;
    let wmax = wTable / wlen;
    let gap = 4;
    let fzMax = wTable / wlen - 3 * gap;
    let fz = Math.min(70, fzMax);
    let dpEmpty = createLetterInputsX(word, dTable, { pabottom: 5, bg: 'grey', display: 'inline-block', fz: fz, w: fz, h: fz * 1.1, margin: gap });
    let inputs = blankInputs(dpEmpty, range(0, wlen - 1), false);
    for (let i = 0; i < inputs.length; i++) {
      let l = iDiv(inputs[i]);
      ipadd(l);
      mClass(l, 'dropzone');
      l.id = 'input' + i;
    }
    this.inputs = inputs;
    let x = mLinebreak(dTable, 35);
    fz = Math.min(60, fzMax);
    let dp = createLetterInputsX(word, dTable, { bg: 'silver', display: 'inline-block', fz: fz, w: fz, h: fz * 1.1, margin: 4 });
    scrambleInputs(dp);
    let letters = Array.from(dp.children);
    for (let i = 0; i < letters.length; i++) {
      let l = letters[i];
      l.setAttribute('draggable', true);
      ipadd(l);
      l.id = 'letter' + i;
    }
    this.letters = letters;
    mLinebreak(dTable, 35);
    this.bDone = mButton('Done!', this.controller.evaluate.bind(this.controller), dTable, { fz: 28, matop: 10, rounding: 10, padding: 16, border: 8 }, ['buttonClass']);
    if (this.hidden) showFleetingMessage('category: ' + Pictures[0].info.subgroup, 5000);
    else if (!this.showWord) { showLabelPercentHintAfter(50, 6000); }
    this.controller.activateUi.bind(this.controller)();
  }
  trialPrompt() {
    sayTryAgain();
    setTimeout(() => {
      this.inputs.map(x => iDiv(x).innerHTML = '_')
    }, 1500);
    return 10;
  }
  eval() {
    let s = this.inputs.map(x => iDiv(x).innerHTML);
    let w = s = s.join('');
    let word = Goal.label.toUpperCase();
    Selected = { answer: w, reqAnswer: word, feedbackUI: iDiv(Goal) };
    return w == word;
  }
  onTimeup() { this.controller.evaluate(); }
}
class GameTimed1 extends Game {
  constructor(name, o) { super(name, o); }
  clear() { clearInterval(this.TOI); super.clear(); }
  makeTimer() {
    if (nundef(this.msTotal)) this.msTotal = 5000;
    if (nundef(this.msInterval)) this.msInterval = 100;
    let w = this.wTimerOuter = 200;
    this.dTimeOuter = mDiv(dTable, { w: w, h: 25, border: 'white', rounding: 10, position: 'relative' });
    [this.wTimer, this.r, this.g] = [0, 0, 255];
    this.dTimeInner = mDiv(this.dTimeOuter, { h: 25, w: this.wTimer, rounding: 10, bg: `rgb(${this.r},${this.g},0)`, position: 'absolute', left: 0, top: 0 });
    this.dTimeDisplay = mDiv(this.dTimeOuter, { patop: 2, align: 'center', h: 25, w: w, position: 'absolute', left: 0, top: 0 });
    mLinebreak(dTable);
    this.dPause = mDiv(dTable, { cursor: 'pointer', fz: 12, hpadding: 30, vpadding: 10 }, null, 'click to pause');
    this.dPause.onclick = () => this.pause();
  }
  pause() {
    clearInterval(this.TOI);
    this.dPause.innerHTML = 'click to resume...';
    this.dPause.onclick = () => this.resume();
  }
  resume() {
    this.dPause.innerHTML = 'click to pause...';
    this.dPause.onclick = () => this.pause();
    this.TOI = setInterval(this.onTick.bind(this), this.msInterval);
  }
  activate() {
    this.msLeft = valf(this.msTotal, 10000);
    this.dTimeDisplay.innerHTML = timeConversion(this.msLeft, 'sh');
    this.TOI = setInterval(this.onTick.bind(this), this.msInterval);
  }
  onTick() {
    this.msLeft -= this.msInterval;
    this.wTimer += this.wTimerOuter * this.msInterval / this.msTotal;
    let inc_color = 255 * this.msInterval / this.msTotal;
    this.r += inc_color; this.g -= inc_color;
    mStyle(this.dTimeInner, { w: this.wTimer, bg: `rgb(${this.r},${this.g},0)` });
    this.dTimeDisplay.innerHTML = timeConversion(this.msLeft, 'sh');
    if (this.msLeft < 100) {
      clearInterval(this.TOI);
      this.dPause.style.opacity = 0;
      this.onTimeup();
    }
  }
}
class GSpotit1 extends GameTimed1 {
  constructor(name, o) { super(name, o); }
  startGame() { this.correctionFunc = showCorrectUis; }
  start_Level() {
    this.colarr = _calc_hex_col_array(this.rows, this.cols);
    let perCard = arrSum(this.colarr);
    this.nShared = (this.numCards * (this.numCards - 1)) / 2;
    this.nUnique = perCard - this.numCards + 1;
    this.numKeysNeeded = this.nShared + this.numCards * this.nUnique;
    this.keys = setKeysG(this, (_, x) => !x.includes(' '), this.numKeysNeeded + 1);
  }
  deal() {
    let keys = choose(this.keys, this.numKeysNeeded);
    let dupls = keys.slice(0, this.nShared);
    let uniqs = keys.slice(this.nShared);
    let infos = [];
    for (let i = 0; i < this.numCards; i++) {
      let keylist = uniqs.slice(i * this.nUnique, (i + 1) * this.nUnique);
      let info = { id: getUID(), shares: {}, keys: keylist, rows: this.rows, cols: this.cols, colarr: this.colarr };
      infos.push(info);
    }
    let iShared = 0;
    for (let i = 0; i < this.numCards; i++) {
      for (let j = i + 1; j < this.numCards; j++) {
        let c1 = infos[i];
        let c2 = infos[j];
        let dupl = dupls[iShared++];
        c1.keys.push(dupl);
        c1.shares[c2.id] = dupl;
        c2.shares[c1.id] = dupl;
        c2.keys.push(dupl);
      }
    }
    for (const info of infos) { shuffle(info.keys); }
    return infos;
  }
  interact(ev) {
    ev.cancelBubble = true;
    if (!canAct()) { console.log('no act'); return; }
    let keyClicked = evToProp(ev, 'key');
    let id = evToId(ev);
    if (isdef(keyClicked) && isdef(Items[id])) {
      this.pause();
      let item = Items[id];
      if (Object.values(item.shares).includes(keyClicked)) {
        let otherCard = spotitFindCardSharingSymbol(item, keyClicked);
        let cardSymbol = ev.target;
        let otherSymbol = spotitFindSymbol(otherCard, keyClicked);
        Selected = { isCorrect: true, feedbackUI: [cardSymbol, otherSymbol] };
      } else {
        let cardSymbol = ev.target;
        Selected = { isCorrect: false, feedbackUI: [cardSymbol], correctUis: this.getSharedSymbols(), correctionDelay: this.items.length * 1500 };
      }
      this.controller.evaluate.bind(this.controller)();
    }
  }
  getSharedSymbols() {
    let result = [];
    for (const item of this.items) {
      for (const id in item.shares) {
        let k = item.shares[id];
        let ui = iGetl(item, k);
        result.push(ui);
      }
    }
    return result;
  }
  eval() { return Selected.isCorrect; }
  prompt() {
    this.trials = 1;
    show_instruction('find common symbol', dTitle);
    this.makeTimer();
    mLinebreak(dTable, 25);
    let infos = this.deal();
    let items = this.items = [];
    for (const info of infos) {
      let item = spotitCard(info, dTable, { margin: 10 }, this.interact.bind(this));
      items.push(item);
    }
    this.controller.activateUi.bind(this.controller)();
  }
  onTimeup() {
    Selected = { isCorrect: false, correctUis: this.getSharedSymbols(), correctionDelay: this.items.length * 2000 };
    this.controller.evaluate.bind(this.controller)();
  }
}
class GAnagram_orig extends Game {
  constructor(name, o) {
    super(name, o);
    if (this.language == 'C') {
      this.realLanguage = this.language;
      this.language = chooseRandom('E', 'S', 'F', 'D');
    }
  }
  clear() { super.clear(); if (isdef(this.language)) this.language = this.language; }
  start_Level() {
    this.keys = setKeysG(this, filterWordByLengthG, 10);
    if (this.keys.length < 10) { this.keys = setKeysG(this, filterWordByLengthG, 10, 'all'); }
  }
  prompt() {
    myShowPics(null, {}, {});
    if (this.hidden) {
      let d = iDiv(Pictures[0]);
      animate(d, 'aniAppearMinute', 100000);
    }
    setGoal();
    showInstruction(this.showWord ? Goal.label : '', this.language == 'E' ? 'drag letters to form' : "forme", dTitle, true);
    mLinebreak(dTable, 25);
    this.inputs = createDropInputs();
    let x = mLinebreak(dTable, 50);
    this.letters = createDragLetters();
    if (this.hidden) showFleetingMessage('category: ' + Pictures[0].info.subgroup, 5000);
    else if (!this.showWord) { showLabelPercentHintAfter(50, 6000); }
    this.controller.activateUi.bind(this.controller)();
  }
  trialPrompt() {
    sayTryAgain();
    setTimeout(() => {
      this.inputs.map(x => iDiv(x).innerHTML = '_')
    }, 1500);
    return 10;
  }
  eval(w, word) {
    Selected = { answer: w, reqAnswer: word, feedbackUI: iDiv(Goal) };
    return w == word;
  }
}
class GAnagram_MESSY extends Game {
  constructor(name, o) {
    super(name, o);
    if (this.language == 'C') {
      this.realLanguage = this.language;
      this.language = chooseRandom('E', 'S', 'F', 'D');
    }
  }
  clear() { super.clear(); if (isdef(this.language)) this.language = this.language; }
  start_Level() {
    this.keys = setKeysG(this, filterWordByLengthG, 10);
    if (this.keys.length < 10) { this.keys = setKeysG(this, filterWordByLengthG, 10, 'all'); }
  }
  prompt() {
    myShowPics(null, {}, {});
    if (this.hidden) {
      let d = iDiv(Pictures[0]);
      animate(d, 'aniAppearMinute', 100000);
    }
    setGoal();
    showInstruction(this.showWord ? Goal.label : '', this.language == 'E' ? 'drag letters to form' : "forme", dTitle, true);
    mLinebreak(dTable, 25);
    let fz = 120; let word = Goal.label.toUpperCase(); let wlen = word.length;
    let dpEmpty = createLetterInputsX(word, dTable, { pabottom: 5, bg: 'grey', display: 'inline-block', fz: fz, w: fz, h: fz * 1.1, margin: 4 });
    let inputs = blankInputs(dpEmpty, range(0, wlen - 1), false);
    for (let i = 0; i < inputs.length; i++) {
      let l = iDiv(inputs[i]);
      l.ondragover = ev => ev.preventDefault();
      l.ondrop = event => {
        event.preventDefault();
        var data = event.dataTransfer.getData("Text");
        event.target.innerHTML = data;
      }
      makeDraggableInner(l);
      mClass(l, 'dropzone');
      l.id = 'input' + i;
    }
    this.inputs = inputs;
    let x = mLinebreak(dTable, 50);
    fz = 60; word = Goal.label.toUpperCase();
    let dp = createLetterInputsX(word, dTable, { bg: 'silver', display: 'inline-block', fz: fz, w: fz, h: fz * 1.1, margin: 4 });
    scrambleInputs(dp);
    let letters = Array.from(dp.children);
    for (let i = 0; i < letters.length; i++) {
      let l = letters[i];
      l.setAttribute('draggable', true);
      makeDraggableInner(l);
      l.id = 'letter' + i;
    }
    this.letters = letters;
    if (this.hidden) showFleetingMessage('category: ' + Pictures[0].info.subgroup, 5000);
    else if (!this.showWord) { showLabelPercentHintAfter(50, 6000); }
    this.controller.activateUi.bind(this.controller)();
  }
  trialPrompt() {
    sayTryAgain();
    setTimeout(() => {
      this.inputs.map(x => iDiv(x).innerHTML = '_')
    }, 1500);
    return 10;
  }
  eval(w, word) {
    Selected = { answer: w, reqAnswer: word, feedbackUI: iDiv(Goal) };
    return w == word;
  }
}
class GAnagram_PCOnly extends Game {
  constructor(name, o) {
    super(name, o);
    if (this.language == 'C') {
      this.realLanguage = this.language;
      this.language = chooseRandom('E', 'S', 'F', 'D');
    }
  }
  clear() { super.clear(); if (isdef(this.language)) this.language = this.language; }
  start_Level() {
    this.keys = setKeysG(this, filterWordByLengthG, 10);
    if (this.keys.length < 10) { this.keys = setKeysG(this, filterWordByLengthG, 10, 'all'); }
  }
  prompt() {
    myShowPics(null, {}, {});
    if (this.hidden) {
      let d = iDiv(Pictures[0]);
      animate(d, 'aniAppearMinute', 100000);
    }
    setGoal();
    showInstruction(this.showWord ? Goal.label : '', this.language == 'E' ? 'drag letters to form' : "forme", dTitle, true);
    mLinebreak(dTable, 25);
    let fz = 120; let word = Goal.label.toUpperCase(); let wlen = word.length;
    let dpEmpty = createLetterInputsX(word, dTable, { pabottom: 5, bg: 'grey', display: 'inline-block', fz: fz, w: fz, h: fz * 1.1, margin: 4 });
    let inputs = blankInputs(dpEmpty, range(0, wlen - 1), false);
    for (let i = 0; i < inputs.length; i++) {
      let l = iDiv(inputs[i]);
      l.ondragover = ev => ev.preventDefault();
      l.ondrop = event => { event.preventDefault(); var data = event.dataTransfer.getData("Text"); event.target.innerHTML = data; }
      makeDraggableInner(l);
      mClass(l, 'dropzone');
      l.id = 'input' + i;
    }
    this.inputs = inputs;
    let x = mLinebreak(dTable, 50);
    fz = 60; word = Goal.label.toUpperCase();
    let dp = createLetterInputsX(word, dTable, { bg: 'silver', display: 'inline-block', fz: fz, w: fz, h: fz * 1.1, margin: 4 });
    scrambleInputs(dp);
    let letters = Array.from(dp.children);
    for (let i = 0; i < letters.length; i++) {
      let l = letters[i];
      l.setAttribute('draggable', true);
      makeDraggableInner(l);
      l.id = 'letter' + i;
    }
    this.letters = letters;
    mLinebreak(dTable, 50);
    this.bDone = mButton('Done!', this.controller.evaluate.bind(this.controller), dTable, { fz: 28, matop: 10, rounding: 10, padding: 16, border: 8 }, ['buttonClass']);
    if (this.hidden) showFleetingMessage('category: ' + Pictures[0].info.subgroup, 5000);
    else if (!this.showWord) { showLabelPercentHintAfter(50, 6000); }
    this.controller.activateUi.bind(this.controller)();
  }
  trialPrompt() {
    sayTryAgain();
    setTimeout(() => {
      this.inputs.map(x => iDiv(x).innerHTML = '_')
    }, 1500);
    return 10;
  }
  eval() {
    let s = this.inputs.map(x => iDiv(x).innerHTML);
    let w = s = s.join('');
    let word = Goal.label.toUpperCase();
    Selected = { answer: w, reqAnswer: word, feedbackUI: iDiv(Goal) };
    return w == word;
  }
}
class CounterClass extends Map {
  constructor(iter, key = null) {
    super();
    this.key = key || (x => x);
    for (let x of iter) {
      this.add(x);
    }
  }
  add(x) {
    x = this.key(x);
    this.set(x, (this.get(x) || 0) + 1);
  }
}
function __pictoG(key, x, y, w, h, fg, bg) {
  let ch = iconChars[key];
  let family = (ch[0] == 'f' || ch[0] == 'F') ? 'pictoFa' : 'pictoGame';
  let text = String.fromCharCode('0x' + ch);
}
async function __start() {
  set_run_state_no_server();
  onpagedeactivated(() => { fiddleSave(); dbSave(); });
  await load_syms();
  await load_db();
  let dicode = CODE.di = await route_path_yaml_dict('../basejs/z_all.yaml');
  let dijustcode = CODE.justcode = await route_path_yaml_dict('../basejs/z_allcode.yaml');
  dTable = mSection({ h: window.innerHeight - 68 }, 'dTable');
  computeClosure();
}
function _addFilterHighlight(mobj) { mobj.highC('green'); }
function _addOnelineVars(superdi, o) {
  let [code, type] = [o.code, o.type];
  let crn = (code.match(/\r\n/g) || []).length;
  let oneliner = crn == 1;
  //let specialword = 'Counter'; //'PORT';
  if (oneliner && type == 'var' && code.includes(',') && !code.includes('[') && !code.includes('{ ')) {
    let othervars = stringAfter(code, 'var').trim().split(',');
    othervars = othervars.map(x => firstWord(x, true));
    othervars.shift();
    for (const v of othervars) {
      let o1 = jsCopy(o);
      o1.lead = o.key;
      o1.key = v;
      o1.code = '';
      o1.sig = `var ${v};`;
      if (isNumber(v)) { continue; }
      lookupSetOverride(superdi, [type, v], o1);
    }
  }
}
function _addPicto(dParent, key) {
  let pic = picto(key, 0, 0, 50, 50, 'red', 'black');
  dParent.appendChild(pic);
  return pic;
}
function _addRelatives(id, oid) {
  if (isdef(oid2ids[oid])) {
    for (const idOther of oid2ids[oid]) {
      if (idOther == id) {
        console.log('object', id, 'already exists in oid2ids[', oid, ']');
        continue;
      }
      listKey(id2uids, id, idOther);
      listKey(id2uids, idOther, id);
    }
  }
}
function _addShape(mobj, w, h, color, shape, { dx = 0, dy = 0, x1, y1, x2, y2, border, thickness, alpha, n = 6, path, idx, rounding } = {}) {
  let r = mobj['_' + shape]();
  mobj.shape = shape;
  if (alpha) color = colorFrom(color, alpha);
  mobj.elem.setAttribute('fill', color);
  if (this.isLine) {
    dx = isdef(dx) ? dx + this.x : this.x;
    dy = isdef(dy) ? dy + this.y : this.y;
  }
  let t = getTypeOf(r);
  if (t == 'rect') { _setRectDims(r, w, h, dx, dy); }
  else if (t == 'ellipse') { _setEllipseDims(r, w, h, dx, dy); }
  else if (t == 'polygon') {
    let pts;
    if (shape == 'hex') { if (h <= 0) { h = (2 * w) / 1.73; } pts = size2hex(w, h, dx, dy); }
    else if (shape == 'triangle') { pts = size2triup(w, h, dx, dy); }
    else if (shape == 'triangleDown') { pts = size2tridown(w, h, dx, dy); }
    else if (shape == 'star') {
      h = h == 0 ? w : h;
      let rad = w / 2;
      let pOuter = getCirclePoints(rad, n);
      let pInner = getCirclePoints(rad / 2, n, 180 / n);
      let points = [];
      for (let i = 0; i < n; i++) {
        points.push(pOuter[i]);
        points.push(pInner[i]);
      }
      for (let i = 0; i < points.length; i++) {
        points[i].X = (points[i].X + w / 2) / w;
        points[i].Y = (points[i].Y + h / 2) / h;
      }
      pts = polyPointsFrom(w, h, dx, dy, points);
    }
    r.setAttribute('points', pts);
  } else if (t == 'image') { _setRectDims(r, w, h, dx, dy); r.setAttribute('href', path); }
  else if (t == 'line') { _setLineDims(r, x1, y1, x2, y2) }
  if (thickness) {
    r.setAttribute('stroke-width', thickness);
    r.setAttribute('stroke', border ? border : mobj.fg);
  }
  if (rounding) {
    r.setAttribute('rx', rounding);
    r.setAttribute('ry', rounding);
  }
  if (isdef(idx) && mobj.elem.childNodes.length > idx) {
    mobj.elem.insertBefore(r, mobj.elem.childNodes[idx]);
  } else {
    mobj.elem.appendChild(r);
  }
  return r;
}
function _addStandardInteraction(id) {
  let mobj = UIS[id];
  switch (id[2]) {
    case 'a':
      mobj.addClickHandler('elem', onClickSelectTuple);
      mobj.addMouseEnterHandler('title', highlightMsAndRelatives);
      mobj.addMouseLeaveHandler('title', unhighlightMsAndRelatives);
      break;
    case 'l':
    case 'r':
      mobj.addMouseEnterHandler('title', highlightMsAndRelatives);
      mobj.addMouseLeaveHandler('title', unhighlightMsAndRelatives);
      break;
    case 't':
      if (id[0] == 'm') {
        mobj.addClickHandler('elem', onClickFilterOrInfobox);
        if (mobj.isa.card) {
          mobj.addMouseEnterHandler('title', _highlightAndMagnify);
          mobj.addMouseLeaveHandler('title', _unhighlightAndMinify);
        } else {
          mobj.addMouseEnterHandler('title', highlightMsAndRelatives);
          mobj.addMouseLeaveHandler('title', unhighlightMsAndRelatives);
        }
      } else {
        mobj.addClickHandler('elem', onClickFilterTuples);
        mobj.addMouseEnterHandler('title', highlightMsAndRelatives);
        mobj.addMouseLeaveHandler('title', unhighlightMsAndRelatives);
      }
      break;
    default:
      mobj.addClickHandler('elem', onClickFilterTuples);
      mobj.addMouseEnterHandler('title', highlightMsAndRelatives);
      mobj.addMouseLeaveHandler('title', unhighlightMsAndRelatives);
      break;
  }
}
function _bestRowsColsFill(items, options) {
  let combis = _getSLCombis(items.length, options.isRegular);
  let wa = options.area.w, ha = options.area.h, wp = options.szPic.w, hp = options.szPic.h;
  let rows, cols;
  cols = wa / wp;
  rows = ha / hp;
  let aRatio = cols < rows ? cols / rows : rows / cols;
  options.or = cols < rows ? 'P' : 'L';
  let rmin = 20000, best;
  for (const r of combis) {
    let rnew = Math.abs(aRatio - r.s / r.l);
    if (rnew < rmin) { rmin = rnew; best = r; }
  }
  if (options.or == 'P') { rows = best.l; cols = best.s; } else { rows = best.s; cols = best.l; }
  let [w, h] = [options.szPic.w, options.szPic.h] = [wa / cols, ha / rows];
  return [rows, cols, w, h, options.or];
}
function _bestRowsColsSize(items, options) {
  let combis = _getSLCombis(items.length, options.isRegular, true);
  options.szPicTest = { w: options.szPic.w, h: options.szPic.h };
  let bestCombi = safeLoop(_findBestCombiOrShrink, [items, options, combis]);
  let [rows, cols, w, h] = [bestCombi.rows, bestCombi.cols, options.szPicTest.w, options.szPicTest.h]
  delete options.szPicTest;
  return [rows, cols, w, h, rows < cols ? 'L' : 'P'];
}
function _bestRowsColsSizeWH(items, wTotal, hTotal, options) {
  let combis = _getSLCombis(items.length, options.isRegular, true);
  options.szPicTest = { w: options.szPic.w, h: options.szPic.h };
  let bestCombi = safeLoop(_findBestCombiOrShrinkWH, [items, wTotal, hTotal, options, combis]);
  let [rows, cols, w, h] = [bestCombi.rows, bestCombi.cols, options.szPicTest.w, options.szPicTest.h]
  delete options.szPicTest;
  return [rows, cols, w, h, rows < cols ? 'L' : 'P'];
}
function _bringCardToFront(id) { let elem = document.getElementById(id); maxZIndex += 1; elem.style.zIndex = maxZIndex; }
function _calc_hex_col_array(rows, cols) {
  let colarr = [];
  let even = rows % 2 == 0;
  for (let i = 0; i < rows; i++) {
    colarr[i] = cols;
    if (even && i < (rows / 2) - 1) cols += 1;
    else if (even && i > rows / 2) cols -= 1;
    else if (!even && i < (rows - 1) / 2) cols += 1;
    else if (!even || i >= (rows - 1) / 2) cols -= 1;
  }
  return colarr;
}
function _calc_hex_col_array_old(rows, cols) {
  let colarr = [];
  for (let i = 0; i < rows; i++) {
    colarr[i] = cols;
    if (i < (rows - 1) / 2) cols += 1;
    else cols -= 1;
  }
  return colarr;
}
function _calcFontPicFromText(options, overrideExisting = true) {
  if (nundef(options.fzPic) || overrideExisting) options.fzPic = Math.floor(options.fzText * 4 * (options.luc == 'u' ? .7 : .6));
  return options.fzPic;
}
function _calcPadGap(p, w, h) {
  if (isString(p)) {
    let pad = Math.min(w, h) * firstNumber(p) / 100;
    console.log('pad', padding);
    return pad;
  } else if (p > 0 && p < 1) return Math.min(w, h) * p;
  else return p;
}
function _centerGridVerticallyWithinArea(items, options) {
  let dGrid = mBy(options.idGrid);
  let dArea = mBy(options.idArea);
  let gRect = getRect(dGrid);
  let aRect = getRect(dArea);
  let itemRect = getRect(lDiv(items[0]));
  let [gsz, asz, itemsz] = [rectToSize(gRect), rectToSize(aRect), rectToSize(itemRect)]
  let extra = options.area.h - gRect.h;
  let pv = valf(options.percentVertical, 50);
  let matop = extra * pv / 100;
  mStyleX(dGrid, { matop: matop });
  mReveal(dMain);
}
function _chainExRec(akku, taskChain, onComplete) {
  if (CancelChain) {
    clearTimeout(ChainTimeout);
    BlockChain = false;
    console.log('chain canceled!');
    return akku;
  } else if (isEmpty(taskChain)) {
    BlockChain = false;
    if (onComplete) onComplete(akku);
    else console.log('akku', akku, '\nBlockChain', BlockChain, '\nCancelChain', CancelChain)
  } else {
    let task = taskChain[0], f = task.f, parr = isdef(task.parr) ? task.parr : [], t = task.msecs, waitCond = task.waitCond, tWait = task.tWait;
    if (isdef(waitCond) && !waitCond()) {
      if (nundef(tWait)) tWait = 300;
      ChainTimeout = setTimeout(() => _chainExRec(akku, taskChain, onComplete), tWait);
    } else {
      for (let i = 0; i < parr.length; i++) {
        let para = parr[i];
        if (para == '_last') parr[i] = arrLast(akku);
        else if (para == '_all' || para == '_list') parr[i] = akku;
        else if (para == '_first') parr[i] = akku[0];
      }
      let result = f(...parr);
      if (isdef(result)) akku.push(result);
      if (isdef(t)) {
        ChainTimeout = setTimeout(() => _chainExRec(akku, taskChain.slice(1), onComplete), t);
      } else {
        _chainExRec(akku, taskChain.slice(1), onComplete);
      }
    }
  }
}
function _checkOverflow(items, options, dGrid) {
  console.log('exec...')
  if (isOverflown(dGrid)) { _sizeByFactor(items, options, dGrid, .99); }
}
function _checkOverflowPixel(items, options, dGrid) {
  console.log('exec...')
  if (isOverflown(dGrid)) { _sizeByPixel(items, options, dGrid, -1); }
}
function _clearHand(idHand, subArea) {
  let hand = UIS[idHand];
  if (hand.cards) {
    while (!isEmpty(hand.cards)) {
      removeCardFromHand(hand.cards[0], hand, subArea);
    }
  }
}
function _cloneIfNecessary(value, optionsArgument) {
  var clone = optionsArgument && optionsArgument.clone === true
  return (clone && _isMergeableObject(value)) ? deepmerge(_emptyTarget(value), value, optionsArgument) : value
}
function _closeInfoboxesForBoatOids(boat) {
  let oids = boat.o.oids;
  for (const oid of oids) hideInfobox(oid);
}
function _computeClosure(symlist) {
  let keys = {};
  for (const k in CODE.di) { for (const k1 in CODE.di[k]) keys[k1] = CODE.di[k][k1]; }
  CODE.all = keys;
  CODE.keylist = Object.keys(keys)
  let inter = intersection(Object.keys(keys), Object.keys(window));
  let done = {};
  let tbd = valf(symlist, ['_start']);
  let MAX = 1007, i = 0;
  let alltext = '';
  while (!isEmpty(tbd)) {
    if (++i > MAX) break;
    let sym = tbd[0];
    let o = CODE.all[sym];
    if (nundef(o)) o = getObjectFromWindow(sym);
    if (o.type != 'func' && o.type != 'cla') { tbd.shift(); lookupSet(done, [o.type, sym], o); continue; }
    let olive = window[sym];
    if (nundef(olive)) { tbd.shift(); lookupSet(done, [o.type, sym], o); continue; }
    let text = olive.toString();
    if (!isEmpty(text)) alltext += text + '\r\n';
    let words = toWords(text, true);
    for (const w of words) {
      if (nundef(done[w]) && w != sym && isdef(CODE.all[w])) addIf(tbd, w);
    }
    tbd.shift();
    lookupSet(done, [o.type, sym], o);
  }
  let tres = '';
  for (const k of ['const', 'var', 'cla', 'func']) {
    console.log('done', k, done[k])
    let o = done[k]; if (nundef(o)) continue;
    let klist = get_keys(o);
    if (k == 'func') klist = sortCaseInsensitive(klist);
    else if (k == 'cla') klist = sortClassKeys(done);
    else if (k == 'const') klist = sortConstKeys(done).map(x => x.key);
    for (const k1 of klist) {
      let code = CODE.justcode[k1];
      if (!isEmptyOrWhiteSpace(code)) tres += code + '\r\n';
    }
  }
  return done;
}
function _createDeck({ hasJokers = false } = {}) {
  let deck = null;
  if (hasJokers) { deck = DeckA(true); }
  else { deck = DeckA(); }
  deck.isFaceDown = true;
  return deck;
}
function _createDivs(items, ifs, options) {
  if (nundef(options.textPos)) options.textPos = 'none';
  let w = isdef(options.w) ? options.w : options.sz;
  let h = isdef(options.h) ? options.h : options.sz;
  let padding = (isdef(ifs.padding) ? ifs.padding : 1);
  let bo = ifs.border;
  bo = isdef(bo) ? isString(bo) ? firstNumber(bo) : bo : 0;
  let wNet = w - 2 * padding - 2 * bo;
  let hNet = h - 2 * padding - 2 * bo;
  let pictureSize = wNet;
  options.center = true;
  let picStyles = { w: wNet, h: isdef(options.center) ? hNet : hNet + padding };
  let textStyles, hText;
  if (options.showLabels) {
    let longestLabel = findLongestLabel(items);
    let oneWord = longestLabel.label.replace(' ', '_');
    let maxTextHeight = options.showPics ? hNet / 2 : hNet;
    textStyles = idealFontsize(oneWord, hNet, maxTextHeight, 22, 8);
    hText = textStyles.h;
    pictureSize = hNet - hText;
    picStyles = { w: pictureSize, h: pictureSize };
    delete textStyles.h;
    delete textStyles.w;
  }
  let outerStyles = { rounding: 10, margin: w / 12, display: 'inline-block', w: w, h: h, padding: padding, bg: 'white', align: 'center', 'box-sizing': 'border-box' };
  if (options.showLabels == true && options.textPos == 'none' && nundef(options.h)) delete outerStyles.h;
  outerStyles = deepmergeOverride(outerStyles, ifs);
  let pic, text;
  for (let i = 0; i < items.length; i++) {
    let item = items[i];
    let k = item.key;
    let d = mDiv();
    if (isdef(item.textShadowColor)) {
      let sShade = '0 0 0 ' + item.textShadowColor;
      if (options.showPics) {
        picStyles['text-shadow'] = sShade;
        picStyles.fg = colorFrom('black', item.contrast); //'#00000080' '#00000030' 
      } else {
        textStyles['text-shadow'] = sShade;
        textStyles.fg = colorFrom('black', item.contrast); //'#00000080' '#00000030' 
      }
    }
    if (options.showPics) {
      pic = zPic(k, null, picStyles, true, false);
      delete pic.info;
      mAppend(d, pic.div);
    }
    if (options.showLabels) {
      textStyles.fg = item.fg;
      text = zText1Line(item.label, null, textStyles, hText);
      mAppend(d, text.div);
    }
    outerStyles.bg = item.bg;
    outerStyles.fg = item.fg;
    mStyleX(d, outerStyles);
    d.id = getUID();
    d.onclick = options.onclick;
    item.id = d.id;
    item.row = Math.floor(item.index / options.cols);
    item.col = item.index % options.cols;
    item.div = d;
    if (isdef(pic)) { item.pic = pic; item.fzPic = pic.innerDims.fz; }
    if (isdef(text)) item.text = text;
    item.isSelected = false;
    item.isLabelVisible = options.showLabels;
    item.dims = parseDims(w, w, d.style.padding);
    if (options.showRepeat) addRepeatInfo(d, item.iRepeat, w);
  }
}
function _createDivsS(items, ifs, options) {
  if (nundef(options.textPos)) options.textPos = 'none';
  let w = isdef(options.w) ? options.w : options.sz;
  let h = isdef(options.h) ? options.h : options.sz;
  let padding = (isdef(ifs.padding) ? ifs.padding : 1);
  let bo = ifs.border;
  bo = isdef(bo) ? isString(bo) ? firstNumber(bo) : bo : 0;
  let wNet = w - 2 * padding - 2 * bo;
  let hNet = h - 2 * padding - 2 * bo;
  let pictureSize = wNet;
  options.center = true;
  let picStyles = { w: wNet, h: isdef(options.center) ? hNet : hNet + padding };
  let textStyles, hText;
  if (options.showLabels) {
    let longestLabel = findLongestLabel(items);
    let oneWord = longestLabel.label.replace(' ', '_');
    let maxTextHeight = options.showPics ? hNet / 2 : hNet;
    textStyles = idealFontsize(oneWord, hNet, maxTextHeight, 22, 8);
    hText = textStyles.h;
    pictureSize = hNet - hText;
    picStyles = { w: pictureSize, h: pictureSize };
    delete textStyles.h;
    delete textStyles.w;
  }
  let outerStyles = { rounding: 10, margin: w / 12, display: 'inline-block', w: w, h: h, padding: padding, bg: 'white', align: 'center', 'box-sizing': 'border-box' };
  if (options.showLabels == true && options.textPos == 'none' && nundef(options.h)) delete outerStyles.h;
  outerStyles = deepmergeOverride(outerStyles, ifs);
  let pic, text;
  for (let i = 0; i < items.length; i++) {
    let item = items[i];
    let k = item.key;
    let d = mDiv();
    if (isdef(item.textShadowColor)) {
      let sShade = '0 0 0 ' + item.textShadowColor;
      if (options.showPics) {
        picStyles['text-shadow'] = sShade;
        picStyles.fg = colorFrom('black', item.contrast); //'#00000080' '#00000030' 
      } else {
        textStyles['text-shadow'] = sShade;
        textStyles.fg = colorFrom('black', item.contrast); //'#00000080' '#00000030' 
      }
    }
    if (options.showPics) {
      pic = zPicS(item, null, picStyles, true, false);
      delete pic.info;
      mAppend(d, pic.div);
    }
    if (options.showLabels) {
      textStyles.fg = item.fg;
      text = zText1Line(item.label, null, textStyles, hText);
      mAppend(d, text.div);
    }
    outerStyles.bg = item.bg;
    outerStyles.fg = item.fg;
    mStyleX(d, outerStyles);
    d.id = getUID();
    d.onclick = options.onclick;
    item.id = d.id;
    item.row = Math.floor(item.index / options.cols);
    item.col = item.index % options.cols;
    item.div = d;
    if (isdef(pic)) { item.pic = pic; item.fzPic = pic.innerDims.fz; }
    if (isdef(text)) item.text = text;
    item.isSelected = false;
    item.isLabelVisible = options.showLabels;
    item.dims = parseDims(w, w, d.style.padding);
    if (options.showRepeat) addRepeatInfo(d, item.iRepeat, w);
  }
}
function _createDom(domType) {
}
async function _dbInitX(dir = '../DATA/') {
  let users = await route_path_yaml_dict(dir + 'users.yaml');
  let settings = await route_path_yaml_dict(dir + 'settings.yaml');
  let addons = await route_path_yaml_dict(dir + 'addons.yaml');
  let games = await route_path_yaml_dict(dir + 'games.yaml');
  let tables = await route_path_yaml_dict(dir + 'tables.yaml');
  DB = {
    id: 'boardGames',
    users: users,
    settings: settings,
    games: games,
    tables: tables,
    addons: addons,
  };
  dbSaveX();
}
async function _dbLoadX(callback) {
  let path = './DB.yaml';
  DB = await route_path_yaml_dict(path);
  if (isdef(callback)) callback();
}
function _deepMerge(target, source, optionsArgument) {
  var array = Array.isArray(source);
  var options = optionsArgument || { arrayMerge: _defaultArrayMerge }
  var arrayMerge = options.arrayMerge || _defaultArrayMerge
  if (array) {
    return Array.isArray(target) ? arrayMerge(target, source, optionsArgument) : _cloneIfNecessary(source, optionsArgument)
  } else {
    return _mergeObject(target, source, optionsArgument)
  }
}
function _defaultArrayMerge(target, source, optionsArgument) {
  var destination = target.slice()
  source.forEach(function (e, i) {
    if (typeof destination[i] === 'undefined') {
      destination[i] = _cloneIfNecessary(e, optionsArgument)
    } else if (_isMergeableObject(e)) {
      destination[i] = deepmerge(target[i], e, optionsArgument)
    } else if (target.indexOf(e) === -1) {
      destination.push(_cloneIfNecessary(e, optionsArgument))
    }
  })
  return destination
}
function _deleteFromOwnerList(id) { let owner = IdOwner[id[2]]; if (isdef(owner)) removeInPlace(owner, id); }
function _deqSound() {
  let key = _qSound.shift();
  let url = _audioSources[key];
  _sndPlayer = new Audio(url);
  _sndPlayer.onended = _whenSoundPaused;
  _sndPlayer.onloadeddata = () => { _loaded = true; _sndPlayer.play(); };
  _sndPlayer.load();
}
function _emptyTarget(val) {
  return Array.isArray(val) ? [] : {}
}
function _enqSound(key) { if (nundef(_qSound)) _qSound = []; _qSound.push(key); }
function _evToClass(ev, className) {
  let elem = findParentWithClass(ev.target, className);
  return elem;
}
async function _experimental() {
  t01_fractions();
}
function _extendItemsAndOptions(items, options) {
  options.longestLabel = findLongestWord(items.map(x => x.label));
  options.wLongest = extendWidth(options.longestLabel);
  let ifs = options.ifs;
  for (let i = 0; i < items.length; i++) {
    let item = items[i];
    item.index = i;
    let val;
    for (const propName in ifs) {
      let prop = ifs[propName];
      if (isLiteral(prop)) val = prop;
      else if (isList(prop)) val = prop[i % prop.length];
      else if (typeof (prop) == 'function') val = prop(i, item, options, items);
      else val = null;
      if (isdef(val)) item[propName] = val;
    }
  }
  if (options.numRepeat > 1) { items = zRepeatEachItem(items, options.numRepeat, options.shufflePositions); }
  if (isdef(options.colorKeys)) items = zRepeatInColorEachItem(items, options.colorKeys);
  options.N = items.length;
  return items;
}
function _extendOptions(options, defOptions, createArea = true) {
  defOptions = {
    wper: 96, hper: 96, dParent: dTable,
    showPic: true, szPic: { w: 120, h: 120 }, bg: 'random', fg: 'white', margin: 4, rounding: 6,
    showLabels: true, luc: 'l', labelPos: 'bottom', lang: 'E', keySet: 'all',
    fzText: 20, fzPic: 60,
    padding: .025, gap: .1, isUniform: true, isRegular: false, fillArea: true,
    shufflePositions: false, sameBackground: true, showRepeat: false, repeat: 1,
    contrast: .32,
    ifs: {},
    handler: _standardHandler,
  };
  addKeys(defOptions, options);
  if (createArea && nundef(options.dArea)) {
    if (isdef(options.wArea) && isdef(options.hArea)) {
      options.dArea = getMainArea(options.dParent, { w: options.wArea, h: options.hArea });
    } else if (isdef(options.areaPadding)) {
      options.dArea = getMainAreaPadding(options.dParent, padding = options.areaPadding);
    } else options.dArea = getMainAreaPercent(options.dParent, null, options.wper, options.hper, getUID());
    options.area = getRect(options.dArea);
    options.idArea = options.dArea.id;
    options.aRatio = options.area.w / options.area.h;
    options.containerShape = options.area.w > options.area.h ? 'L' : 'P';
  }
  if (options.repeat > 1 && nundef(options.ifs.bg)) {
    let bg = isdef(options.colorKeys) ? 'white' : (i) => options.sameBackground ? computeColor('random') : 'random';
    let fg = isdef(options.colorKeys) ? 'black' : 'white';
    options.ifs.bg = bg;
    options.ifs.fg = fg;
  }
  _calcFontPicFromText(options, false);
  if (nundef(options.labelStyles)) options.labelStyles = {};
  if (options.showLabels) {
    if (options.labelPos == 'bottom') options.labelBottom = true; else options.labelTop = true;
    options.labelStyles.fz = options.fzText;
  }
  options.picStyles = { fz: options.fzPic };
  let [w, h] = [options.szPic.w, options.szPic.h];
  options.outerStyles = {
    w: w, h: h, bg: options.bg, fg: options.fg,
    display: 'inline-flex', 'flex-direction': 'column',
    'justify-content': 'center', 'align-items': 'center', 'vertical-align': 'top',
    //'place-content': 'center',
    padding: 0, box: true, margin: options.margin, rounding: options.rounding,
  };
  return options;
}
function _extendOptions_0(dArea, options, defOptions) {
  defOptions = {
    szPic: { w: 100, h: 100 },
    showLabels: true, maxlen: 25, luc: 'c', labelPos: 'bottom', lang: 'D',
    fzText: 20, fzPic: 60,
    padding: .025, gap: .1, isUniform: true, isRegular: true, fillArea: false,
    shufflePositions: false, sameBackground: true, showRepeat: false, repeat: 1,
    contrast: .32,
    ifs: {},
    handler: _standardHandler,
  };
  addKeys(defOptions, options);
  if (options.repeat > 1 && nundef(options.ifs.bg)) {
    let bg = isdef(options.colorKeys) ? 'white' : (i) => options.sameBackground ? computeColor('random') : 'random';
    options.ifs.bg = bg;
  }
  _calcFontPicFromText(options, false);
  options.area = getRect(dArea);
  options.idArea = dArea.id;
  options.aRatio = options.area.w / options.area.h;
  options.containerShape = options.area.w > options.area.h ? 'L' : 'P';
  if (nundef(options.labelStyles)) options.labelStyles = {};
  if (options.showLabels) {
    if (options.labelPos == 'bottom') options.labelBottom = true; else options.labelTop = true;
    options.labelStyles.fz = options.fzText;
  }
  options.picStyles = { fz: options.fzPic };
  options.outerStyles = {
    bg: 'blue', fg: 'contrast',
    display: 'inline-flex', 'flex-direction': 'column', 'place-content': 'center',
    padding: 0, box: true, rounding: 6,
  };
  return options;
}
function _extendOptionsFillArea(dArea, options) {
  defOptions = {
    szPic: { w: 100, h: 100 },
    showLabels: true, maxlen: 25, padding: .025, gap: .1,
    isUniform: true, fillArea: true,
    fzText: 8, luc: 'c', labelPos: 'bottom', lang: 'E',
  };
  if (nundef(options.fzPic)) options.fzPic = Math.floor(options.fzText * 4 * (options.luc == 'u' ? .7 : .6));
  _extendOptions_0(dArea, options, defOptions);
}
function _findBestCombiOrShrink(items, options, combis) {
  bestCombi = firstCond(combis, x => options.area.w / x.cols > options.szPicTest.w && options.area.h / x.rows > options.szPicTest.h);
  if (isdef(bestCombi)) return bestCombi;
  options.szPicTest = { w: .9 * options.szPicTest.w, h: .9 * options.szPicTest.h };
  return null;
}
function _findBestCombiOrShrinkWH(items, wTotal, hTotal, options, combis) {
  bestCombi = firstCond(combis, x => wTotal / x.cols > options.szPicTest.w && hTotal / x.rows > options.szPicTest.h);
  if (isdef(bestCombi)) return bestCombi;
  options.szPicTest = { w: .9 * options.szPicTest.w, h: .9 * options.szPicTest.h };
  return null;
}
function _findCollections(key, o) {
  let sets = [];
  _recFindCollections(key, o, sets);
  return sets;
}
function _gCreate(tag) { return document.createElementNS('http:/' + '/www.w3.org/2000/svg', tag); }
function _genOptions(opt = {}) {
  let defOptions = {
    szPic: { w: 100, h: 100 }, wper: 80, hper: 80, n: 20,
    showLabels: true, maxlen: 25, luc: 'c', labelPos: 'bottom', lang: 'D',
    fzText: 20, fzPic: 60,
    padding: .025, gap: .1, isUniform: true, isRegular: true, fillArea: false,
  };
  addKeys(defOptions, opt);
  if (nundef(opt.dArea)) opt.dArea = getMainAreaPercent(dTable, YELLOW, opt.wper, opt.hper, 'dArea');
  if (nundef(opt.items)) opt.items = genItems(opt.n, opt);
  _calcFontPicFromText(opt, false);
  opt.area = getRect(opt.dArea);
  opt.aRatio = opt.area.w / opt.area.h;
  opt.containerShape = opt.area.w > opt.area.h ? 'L' : 'P';
  if (nundef(opt.labelStyles)) opt.labelStyles = {};
  if (opt.showLabels) {
    if (opt.labelPos == 'bottom') opt.labelBottom = true; else opt.labelTop = true;
    opt.labelStyles.fz = opt.fzText;
  }
  opt.picStyles = { fz: opt.fzPic };
  opt.outerStyles = {
    bg: 'random', display: 'inline-flex', 'flex-direction': 'column', 'place-content': 'center',
    padding: 0, box: true, rounding: 6,
  };
  return opt;
}
function _get_layer(key, options) {
  let o = Geo.layerInfo[key];
  if (nundef(o)) o = Geo.layerInfo.empty;
  copyKeys(options, o.options);
  return L.tileLayer(o.url, o.options);
}
function _getChildrenOf(id) { let ui = UIS[id]; return ui.children; }
function _getCollectionType(o) {
  if (nundef(o)) return false;
  if (nundef(o._set) && !isList(o)) return false;
  let arr;
  if (isdef(o._set)) arr = o._set; else arr = o;
  if (!isList(arr) || isEmpty(arr)) return false;
  let type = null;
  let generic_type = null;
  for (const el of arr) {
    if (nundef(el)) return false;
    if (isdef(el._obj)) {
      if (type && type != '_obj') return false;
      type = '_obj';
      let oEl = G.table[el._obj];
      if (nundef(oEl)) return false;
      if (isdef(oEl.generic_type)) {
        if (!generic_type) generic_type = oEl.generic_type;
        if (generic_type != oEl.generic_type) return false;
      }
    } else {
      if (type == '_obj') return false;
      if (!type) type = generic_type = 'string';
    }
  }
  return { type: type, generic_type: generic_type };
}
function _getKeysCond(n, cond, keySet = 'all') {
  if (isString(keySet)) keySet = KeySets[keySet];
  let keys = isdef(cond) ? isString(cond) ?
    isdef(KeySets[cond]) ? KeySets[cond] : keySet.filter(x => x.includes(cond))
    : keySet.filter(x => cond(Syms[x])) : keySet;
  keys = n >= keys.length ? keys : choose(keys, n);
  return keys;
}
function _getRandomRegularN(from = 2, to = 100) {
  const arr = [2, 3, 4, 6, 8, 9, 12, 15, 16, 20, 24, 30, 36, 40, 42, 44, 48, 56, 64, 72, 84, 96, 100];
  return chooseRandom(arr.filter(x => x >= from && x <= to));
}
function _getRegularN(from = 2, to = 100) {
  const arr = [2, 3, 4, 6, 8, 9, 12, 15, 16, 20, 24, 30, 36, 40, 42, 44, 48, 56, 64, 72, 84, 96, 100];
  return arr.filter(x => x >= from && x <= to);
}
function _getSLCombis(n, onlyRegular = false, addColsRows_cr = false) {
  let sq = Math.ceil(Math.sqrt(n));
  let res = [];
  for (let i = 1; i <= sq; i++) {
    let s = i;
    let l = Math.ceil(n / s);
    if (s <= l && s * l >= n) res.push({ s: s, l: l });
  }
  if (onlyRegular) res = res.filter(x => x.s * x.l == n);
  if (addColsRows_cr) {
    let resX = [];
    for (const res1 of res) {
      resX.push({ rows: res1.s, cols: res1.l, s: res1.s, l: res1.l, sum: res1.s + res1.l });
      if (res1.s != res1.l) resX.push({ rows: res1.l, cols: res1.s, s: res1.s, l: res1.l, sum: res1.s + res1.l });
    }
    sortBy(resX, 'rows');
    sortBy(resX, 'sum');
    return resX;
  }
  return res;
}
function _getSymbolKey(name) { return name.replace(new RegExp(' ', 'g'), '_').toLowerCase(); }
function _getTestPathForPlayerNum() { return GAME + (USE_MAX_PLAYER_NUM ? '_max' : ''); }
function _getTransformInfoDOM(d) {
  let t = d.style.transform;
  console.log(t)
  getTranslateX(d);
}
function _gSizeToContent(svg) {
  var bbox = svg.getBBox();
  svg.setAttribute("width", bbox.x + bbox.width + bbox.x);
  svg.setAttribute("height", bbox.y + bbox.height + bbox.y);
}
function _handChanged(oids, area) {
  let idHand = area;
  let hand = UIS[idHand];
  if (nundef(hand)) return false;
  let cards = hand.cards;
  if (nundef(cards) && isEmpty(oids)) return false;
  if (isdef(hand) && isdef(hand.cards)) return !sameList(oids, hand.cards);
  else return true;
}
function _handleEvent(ev) { ev.cancelBubble = true; return evToItem(ev); }
function _handleTextTooSmall(fz, fzPic, wn, hn, options) {
  console.log('???????fzText too small!!!', fz, 'fzPic', fzPic, 'N=', options.N, !options.isUniform);
  fz = Math.ceil(fz + 2);
  fzPic = Math.floor(Math.min(hn - fz * 1.5, fz * 3));
  options.fzPic = options.picStyles.fz = fzPic;
  options.fzText = options.labelStyles.fz = fz;
}
function _hexGrid(loc, idBoard, sBoard, soDict) {
  let board = createGrid(loc, idBoard, sBoard, soDict, 'hex');
  addVisuals(board);
  return board;
}
function _hideBoat(id) { let mobj = UIS[id]; mobj.hide(); mobj.o.weg = true; }
function _highlightAndMagnify(ev, mobj, partName) {
  magnifyFront(mobj.id);
  highlightMsAndRelatives(ev, mobj, partName);
}
function _highlightBoat(id) {
  if (id === null) return;
  if (boatHighlighted) {
    if (boatHighlighted.id == id) return;
    else _unhighlightBoat();
  }
  boatHighlighted = UIS[id];
  boatHighlighted.elem.scrollIntoView(false);
  highlightMsAndRelatives(null, boatHighlighted);
  _openInfoboxesForBoatOids(boatHighlighted);
}
function _highlightNextBoat() {
  if (!boatHighlighted) _highlightBoat(getFirstBoatId());
  else {
    let idx = boatHighlighted.o.iTuple + 1;
    _highlightBoat(getBoatIdByIdx(boatHighlighted.o.iTuple + 1));
  }
}
function _highlightPrevBoat() {
  if (!boatHighlighted) _highlightBoat(getLastBoatId()); else _highlightBoat(getBoatIdByIdx(boatHighlighted.o.iTuple - 1));
}
function _initAutoplayToActionButtons() {
  let d = document.getElementById('a_d_autoplay_buttons');
  let buttons = [...d.children];
  let defaultIds = ['c_b_NextPlayer', 'c_b_NextTurn', 'c_b_NextPhase'];
  let kws = lookup(S.settings, ['dev', 'run_to_buttons']);
  if (!kws) kws = {};
  let kwKeys = getKeys(kws);
  let requiredButtonIds = kwKeys.map(x => 'c_b_RTA_' + x).concat(defaultIds);
  let actualButtons = buttons.filter(x => x.id).map(x => x.id);
  for (const id of arrMinus(actualButtons, requiredButtonIds)) $('#' + id).remove();
  for (const id of arrMinus(requiredButtonIds, actualButtons)) {
    let b = document.createElement('button');
    let key = id.substring(8);
    b.innerHTML = kws[key];
    b.id = id;
    b.onclick = () => onClickRunToAction(key);
    d.appendChild(b);
  }
}
function _initCheatButtons() {
  let areaName = 'a_d_cheat_buttons';
  let kws = lookup(S.settings, ['dev', 'cheat_buttons']);
  if (!kws) { hide(areaName); return; }
  show(areaName);
  let d = document.getElementById(areaName);
  let buttons = [...d.children];
  let kwKeys = getKeys(kws);
  let requiredButtonIds = kwKeys.map(x => 'c_b_CHT_' + x);
  let actualButtons = buttons.filter(x => x.id).map(x => x.id);
  for (const id of arrMinus(actualButtons, requiredButtonIds)) $('#' + id).remove();
  for (const id of arrMinus(requiredButtonIds, actualButtons)) {
    let b = document.createElement('button');
    let key = id.substring(8);
    b.innerHTML = kws[key];
    b.id = id;
    b.onclick = () => onClickCheat(key);
    d.appendChild(b);
  }
}
function _initGameGlobals() {
  S.user = {};
  G = { table: {}, players: {} };
  UIS = {};
  IdOwner = {};
  id2oids = {};
  oid2ids = {};
  id2uids = {};
}
function _initPlayers() {
  S.players = {};
  G.players = {};
  let ckeys = Object.keys(playerColors);
  let i = 0;
  for (const id in G.serverData.players) {
    let pl = G.serverData.players[id];
    let colorName = isdef(pl.color) ? pl.color : ckeys[i];
    colorName = colorName.toLowerCase();
    let altName = capitalize(colorName);
    let color = isdef(playerColors[colorName]) ? playerColors[colorName] : colorName;
    let plInfo = firstCond(S.gameConfig.players, x => x.id == id);
    S.players[id] = { username: plInfo.username, playerType: plInfo.playerType, agentType: plInfo.agentType, id: id, color: color, altName: altName, index: plInfo.index };
    i += 1;
  }
}
function _initScenarioButtons() {
  let areaName = 'a_d_scenario_buttons';
  let kws = lookup(S.settings, ['dev', 'scenario_buttons']);
  if (!kws) { hide(areaName); return; }
  show(areaName);
  let d = document.getElementById(areaName);
  let buttons = [...d.children];
  let kwKeys = getKeys(kws);
  let requiredButtonIds = kwKeys.map(x => 'c_b_SCE_' + x);
  let actualButtons = buttons.filter(x => x.id).map(x => x.id);
  for (const id of arrMinus(actualButtons, requiredButtonIds)) $('#' + id).remove();
  for (const id of arrMinus(requiredButtonIds, actualButtons)) {
    let b = document.createElement('button');
    let key = id.substring(8);
    let caption = kws[key];
    b.innerHTML = caption;
    b.id = id;
    b.onclick = () => onClickPushScenario(stringBefore(caption, ' '), stringAfter(caption, ' '));
    d.appendChild(b);
  }
}
function _initServer(callbacks = []) {
  S = { path: {}, user: {}, settings: {}, vars: {} };
  counters = { msg: 0, click: 0, mouseenter: 0, mouseleave: 0, events: 0 };
  setDefaultSettings();
  if (!isEmpty(callbacks)) callbacks[0](arrFromIndex(callbacks, 1));
}
function _isInHand(oidCard, idHand) {
  let hand = UIS[idHand];
  let cards = hand.cards;
  return isdef(cards) && cards.includes(oidCard);
}
function _isMergeableObject(val) {
  var nonNullObject = val && typeof val === 'object'
  return nonNullObject
    && Object.prototype.toString.call(val) !== '[object RegExp]'
    && Object.prototype.toString.call(val) !== '[object Date]'
}
async function _loader() {
  Daat = {};
  if (CLEAR_LOCAL_STORAGE) localStorage.clear();
  C52 = await localOrRoute('C52', '../assets/c52.yaml');
  symbolDict = Syms = await localOrRoute('syms', '../assets/allSyms.yaml');
  SymKeys = Object.keys(Syms);
  ByGroupSubgroup = await localOrRoute('gsg', '../assets/symGSG.yaml');
  WordP = await route_path_yaml_dict('../assets/math/allWP.yaml');
  DB = await route_path_yaml_dict('./DB.yaml');
  console.assert(isdef(DB));
  DA = {}; Items = {};
  Speech = new SpeechAPI('E');
  KeySets = getKeySets();
  TOMan = new TimeoutManager();
  _start();
}
async function _loader_dep() {
  Daat = {};
  if (CLEAR_LOCAL_STORAGE) localStorage.clear();
  C52 = await localOrRoute('C52', '../assets/c52.yaml');
  symbolDict = Syms = await localOrRoute('syms', '../assets/allSyms.yaml');
  SymKeys = Object.keys(Syms);
  ByGroupSubgroup = await localOrRoute('gsg', '../assets/symGSG.yaml');
  WordP = await route_path_yaml_dict('../assets/math/allWP.yaml');
  if (BROADCAST_SETTINGS) {
    await _dbInitX();
    _start0();
  } else { dbLoadX(_start0); }
}
function _makeCardDivAristocracy(oid, o) {
  let elem = document.createElement('div');
  let faceElem = document.createElement('div');
  let backElem = document.createElement('div');
  faceElem.classList.add('face');
  backElem.classList.add('back');
  let cardName = isdef(o.name) ? o.name : 'King';
  let rank = cards52GetRankFromName(cardName);
  let suit = 0;
  elem.faceElem = faceElem;
  elem.backElem = backElem;
  elem.isCard = true;
  elem.suit = suit;
  elem.rank = rank;
  setSide(elem, 'front');
  return elem;
}
function _makeCardDivCatan(oid, o) {
  let symbolKeyPropName = 'name';
  let key = _getSymbolKey(o[symbolKeyPropName]);
  let symbol = symbols[key];
  let color = symbolColors[key];
  let d = document.createElement('div');
  $(d).on("mouseenter", function () { magnifyFront(this.id); });
  $(d).on("mouseleave", function () { minifyBack(this.id); });
  d.innerHTML = 'hallo';
  d.style.position = 'absolute';
  let dx = 0;
  d.style.left = '' + dx + 'px';
  d.style.top = '0px';
  let ch = iconChars[symbol];
  let text = String.fromCharCode('0x' + ch);
  let family = (ch[0] == 'f' || ch[0] == 'F') ? 'pictoFa' : 'pictoGame';
  d.innerHTML = `
    <div class="cardCatan">
      <p style='font-size:22px;'>${o.name}</p>
      <div class="cardCenter">
        <div class="circular" style='background:${color}'><span style='color:white;font-size:70px;font-weight:900;font-family:${family}'>${text}</span></div>
      </div>
      <hr>
      <p style='font-size:20px;'>${o.desc}</p>
      <div style='color:${color};position:absolute;left:8px;top:8px;width:35px;height:35px'>
        <span style='font-family:${family}'>${text}</span>
      </div>
    </div>
  `;
  return d;
}
function _makeCardDivDefault(oid, o) {
  let symbolKeyPropName = 'name';
  let key = _getSymbolKey(o[symbolKeyPropName]);
  let symbol = symbols[key];
  let color = symbolColors[key];
  let d = document.createElement('div');
  $(d).on("mouseenter", function () { magnifyFront(this.id); });
  $(d).on("mouseleave", function () { minifyBack(this.id); });
  d.innerHTML = 'hallo';
  d.style.position = 'absolute';
  let dx = 0;
  d.style.left = '' + dx + 'px';
  d.style.top = '0px';
  let ch = iconChars[symbol];
  let text = String.fromCharCode('0x' + ch);
  let family = (ch[0] == 'f' || ch[0] == 'F') ? 'pictoFa' : 'pictoGame';
  d.innerHTML = `
    <div class="cardCatan">
      <p style='font-size:22px;'>${o.name}</p>
      <div class="cardCenter">
        <div class="circular" style='background:${color}'><span style='color:white;font-size:70px;font-weight:900;font-family:${family}'>${text}</span></div>
      </div>
      <hr>
      <p style='font-size:20px;'>${o.desc}</p>
      <div style='color:${color};position:absolute;left:8px;top:8px;width:35px;height:35px'>
        <span style='font-family:${family}'>${text}</span>
      </div>
    </div>
  `;
  return d;
}
function _makeDefault(id, oid, o, areaName, title) {
  if (isdef(UIS[id])) { error('CANNOT create ' + id + ' TWICE!!!!!!!!!'); return; }
  let mobj = new MOBJ();
  mobj.id = id;
  let domel = document.createElement('div');
  domel.style.cursor = 'default';
  mobj.elem = domel;
  mobj.parts.elem = mobj.elem;
  mobj.domType = getTypeOf(domel);
  mobj.cat = DOMCATS[mobj.domType];
  let idParent = areaName;
  mobj.idParent = idParent;
  let parent = UIS[idParent];
  parent.children.push(id);
  let sTitle = title;
  mobj.title(sTitle);
  mobj.o = o;
  mobj.isa[o.obj_type] = true;
  linkObjects(id, oid);
  listKey(IdOwner, id[2], id);
  UIS[id] = mobj;
  mobj.attach();
  return mobj;
}
function _makeGameplayerArea(plAreaName, areaName) {
  let deckArea = getMainArea(defaultDeckAreaName);
  let parentArea = UIS[areaName];
  if (isdef(deckArea)) {
    let x = deckArea.w;
    let h = parentArea.h / 2;
    let y = h;
    let w = parentArea.w - deckArea.w;
    let mobj = makeArea(plAreaName, areaName);
    mobj.setBg('seagreen');
    mobj.setBounds(x, y, w, h, 'px');
    mobj.nextCoords = { x: 0, y: 0 };
    mobj.elem.classList.add('flexWrap');
    return mobj;
  }
}
function _makeGridGrid(items, options, dGrid, showBorder = false) {
  let wcol = options.isUniform ? '1fr' : 'auto';
  let display = options.fillArea ? 'grid' : 'inline-grid';
  mStyleX(dGrid, {
    display: display,
    'grid-template-columns': `repeat(${options.cols}, ${wcol})`,
    gap: options.gap,
    box: true
  });
  if (showBorder) mStyleX(dGrid, { border: '5px solid yellow' });
}
function _makeGroundShape(mobj, x, y, w, h, color, shape, { dx = 0, dy = 0, x1, y1, x2, y2, overlay, scale, scaleX, scaleY, rot, color2, setFg, border, thickness, alpha, idx, rounding } = {}) {
  let r = _addShape(mobj, w, h, color, shape, { dx: dx, dy: dy, x1: x1, y1: y1, x2: x2, y2: y2, border: border, thickness: thickness, alpha: alpha, idx: idx, rounding: rounding })
  mobj.orig.shape = shape;
  let ov = overlay ? mobj['_' + shape]() : null;
  if (ov) ov.setAttribute('class', 'overlay');
  let t = getTypeOf(r);
  if (ov) {
    if (t == 'rect' || t == 'image') { _setRectDims(ov, w, h, dx, dy); }
    else if (t == 'ellipse') { _setEllipseDims(ov, w, h, dx, dy); }
    else if (t == 'polygon') { let pts = r.getAttribute('points'); ov.setAttribute('points', pts); }
    else if (t == 'line') { _setLineDims(r, x1, y1, x2, y2) }
    if (rounding) {
      ov.setAttribute('rx', rounding);
      ov.setAttribute('ry', rounding);
    }
    mobj.elem.appendChild(ov);
    mobj.overlay = ov;
  }
  mobj.bg = mobj.orig.bg = color;
  if (setFg || color2) mobj.fg = mobj.orig.fg = color2 ? color2 : colorIdealText(color);
  mobj.orig.w = mobj.w = w;
  mobj.orig.h = mobj.h = h;
  mobj.orig.x = mobj.x = x;
  mobj.orig.y = mobj.y = y;
  if (isdef(scale)) { scaleX = scaleY = scale; }
  mobj.orig.scaleX = mobj.scaleX = scaleX ? scaleX : 1;
  mobj.orig.scaleY = mobj.scaleY = scaleY ? scaleY : 1;
  mobj.orig.scale = mobj.scale = scale ? scale : 1;
  mobj.orig.rot = mobj.rot = rot ? rot : 0;
  if (isdef(scaleX) || isdef(scaleX) || isdef(rot)) mobj._setTransform(mobj.elem, { x: x, y: y, scaleX: scaleX, scaleY: scaleY, rotDeg: rot });
  else mobj.setPos(x, y);
  mobj.ground = r;
  return mobj;
}
function _makeHandArea(key, handAreaName, parentAreaId) {
  let parentArea = UIS[parentAreaId];
  if (isdef(parentArea)) {
    let mobj = makeArea(handAreaName, parentAreaId);
    mobj.setBg(randomColor());
    mobj.title(stringAfter(key, '.'));
    let bTitle = getBounds(mobj.parts.title);
    mobj.parts['title'].fontSize = '12px';
    mobj.elem.style.minWidth = bTitle.width + 'px'; //'90px';
    mobj.elem.style.minHeight = '160px';
    mobj.body('hand');
    let div = mobj.parts['hand'];
    div.style.position = 'relative';
    div.style.left = '10px';
    div.style.top = '10px';
    div.style.width = 'auto';
    div.style.height = 'auto';
    return mobj;
  }
}
function _makeNoneGrid(items, options, dGrid) {
  options.szPic = { w: options.area.w / options.cols, h: options.area.h / options.rows };
  _setRowsColsSize(options);
  for (const item of items) {
    let live = item.live;
    if (options.isUniform) {
      mStyleX(live.div, { w: options.szPic.w, h: options.szPic.h, margin: options.gap / 2, padding: options.padding / 2 });
    } else {
      mStyleX(live.div, { margin: options.gap / 2, padding: options.padding });
    }
    mStyleX(live.dLabel, { fz: options.fzText });
    mStyleX(live.dPic, { fz: options.fzPic });
  }
  mStyleX(dGrid, { padding: 0, border: '5px solid blue', box: true })
  let ov = getVerticalOverflow(dGrid);
  if (Math.floor(ov) == 0 && !options.isUniform) {
    _tryGrow(items, options);
  }
  if (ov > 0) {
    options.fzPic = options.picStyles.fz = options.fzPic * .9;
    for (const it of items) { mStyleX(lGet(it).dPic, { fz: options.fzPic }); }
    ov = getVerticalOverflow(dGrid);
    let newGap = Math.ceil(options.gap / 2);
    while (ov > 0) {
      for (const it of items) { mStyleX(lDiv(it), { fz: 4, margin: newGap, padding: newGap / 2, rounding: 0 }); }
      ov = getVerticalOverflow(dGrid);
      if (ov && newGap == 1) {
        for (const it of items) { mStyleX(lDiv(it), { margin: 0, padding: 0 }); }
        break;
      }
      newGap = Math.ceil(newGap / 2);
    }
  }
}
function _makeTabletopCardsArea(areaName) {
  let deckArea = getMainArea(defaultDeckAreaName);
  let parentArea = UIS[areaName];
  if (isdef(deckArea)) {
    let x = deckArea.w;
    let h = parentArea.h / 2;
    let y = 0;
    let w = parentArea.w - deckArea.w;
    let id = 'tabletopCardsArea';
    let mobj = makeArea(id, areaName);
    mobj.setBg('seagreen');
    mobj.setBounds(x, y, w, h, 'px');
    mobj.nextCoords = { x: 0, y: 0 };
    mobj.elem.classList.add('flexWrap');
    return mobj;
  }
}
function _mergeObject(target, source, optionsArgument) {
  var destination = {}
  if (_isMergeableObject(target)) {
    Object.keys(target).forEach(function (key) {
      destination[key] = _cloneIfNecessary(target[key], optionsArgument)
    })
  }
  Object.keys(source).forEach(function (key) {
    if (!_isMergeableObject(source[key]) || !target[key]) {
      destination[key] = _cloneIfNecessary(source[key], optionsArgument)
    } else {
      destination[key] = _deepMerge(target[key], source[key], optionsArgument)
    }
  })
  return destination;
}
function _mergeOptions() {
  if (isdef(S.user.spec) && isdef(S.user.spec.SETTINGS)) {
    for (const k in S.user.spec.SETTINGS) {
      if (isdef(S.settings[k])) {
        S.settings[k] = deepmerge(S.settings[k], S.user.spec.SETTINGS[k], { arrayMerge: overwriteMerge });
      } else {
        S.settings[k] = S.user.spec.SETTINGS[k];
      }
    }
  }
}
function _mPlayPause(dParent, styles = {}, handler = null) {
  if (!handler) handler = audio_onclick_pp;
  let html = `
    <section id="dButtons">
      <a id="bPlay" href="#" }">
        <i class="fa fa-play fa-2x"></i>
      </a>
      <a id="bPause" href="#" style="display: none">
        <i class="fa fa-pause fa-2x"></i>
      </a>
    </section>
  `;
  let pp = mCreateFrom(html);
  mAppend(dParent, pp);
  mStyle(pp, styles);
  mBy('bPlay').onclick = () => { hide0('bPlay'); show0('bPause'); handler(); }
  mBy('bPause').onclick = () => { hide0('bPause'); show0('bPlay'); handler(); }
  return { button: pp, show_play: () => { hide0('bPause'); show0('bPlay'); }, show_pause: () => { hide0('bPlay'); show0('bPause'); } };
}
function _mStamp(d1, text, color, sz) {
  mStyle(d1, { position: 'relative' });
  let r = getRect(d1);
  let [w, h] = [r.w, r.h];
  color = ['green', 'red', 'blue'].includes(color) ? color : 'black';
  sz = valf(sz, r.h / 7);
  console.log('r', r, 'sz', sz);
  let [padding, border, rounding, angle] = [sz / 10, sz / 6, sz / 8, rNumber(-25, 25)];
  let d2 = mDiv(d1, {
    fg: color,
    position: 'absolute', top: 25, left: 5,
    transform: `rotate(${angle}deg)`,
    fz: sz,
    hpadding: 2,
    vpadding: 0,
    rounding: rounding,
    weight: 400,
    display: 'inline-block',
    'text-transform': 'uppercase',
    family: 'fredericka',
    'mix-blend-mode': 'multiply',
  }, null, text);
  mClass(d2, `${color}stamp`);
}
function _mtest() {
  MSInit();
}
function _onPlayerChange(pid) {
  if (isPlain()) return;
  if (!G.playerChanged || pid != G.player) return;
  let o = G.playersAugmented[pid];
  _updatePageHeader(pid);
  if (G.previousPlayer) _updateLogArea(G.previousPlayer, pid);
  let mobj = getVisual(pid);
  if (mobj) {
  }
  let msDef = getDefVisual(pid);
  if (msDef) {
    let msParentId = msDef.parentId;
    let msParent = UIS[msParentId];
    var target = msDef.elem;
    target.parentNode.scrollTop = target.offsetTop;
  }
}
function _openInfoboxesForBoatOids(boat) {
  let oids = boat.o.oids;
  let mainIds = oids.map(x => getMainId(x));
  for (const id of mainIds) {
    let mobj = UIS[id];
    openInfobox(null, mobj);
  }
}
function _paramsQ(parr) {
  parr = isdef(parr) ? parr : [];
  for (let i = 0; i < parr.length; i++) {
    let para = parr[i];
    if (para == '_last') parr[i] = arrLast(AkQ);
    else if (para == '_all' || para == '_list') parr[i] = AkQ;
    else if (para == '_first') parr[i] = AkQ[0];
  }
  return parr;
}
function _pickStringForAction(x) {
  if (x.type == 'fixed') return x.val;
  if (x.type == 'obj') return x.ID;
  if (x.type == 'player') return x.val;
}
function _playersCreateNew() {
  for (const pid of G.playersCreated) {
    if (!defaultVisualExists(pid) && S.settings.player.createDefault)
      makeDefaultPlayer(pid, G.playersAugmented[pid], S.settings.player.defaultArea);
    if (mainVisualExists(pid)) continue;
    let updatedVisuals;
    if (S.settings.userBehaviors) {
      updatedVisuals = runBehaviors(pid, G.playersAugmented, PLAYER_CREATE);
    }
    if (nundef(updatedVisuals) || !updatedVisuals.includes(pid)) {
      if (isPlain()) {
        let mobj = makeMainPlayer(pid, G.playersAugmented[pid], S.settings.player.defaultMainArea);
        if (mobj === null && !defaultVisualExists(pid) && S.settings.table.createDefault != false) {
          makeDefaultObject(pid, G.playersAugmented[pid], S.settings.table.defaultArea);
        }
      }
    }
  }
}
function _playersUpdate() {
  for (const pid in G.playersUpdated) {
    let pl = G.playersAugmented[pid];
    let updatedVisuals = {};
    if (S.settings.userBehaviors) {
      updatedVisuals = runBehaviors(pid, G.playersAugmented, PLAYER_UPDATE);
      runBindings(pid, G.playersAugmented)
    }
    let mobj = getVisual(pid);
    if (!updatedVisuals[pid] && isdef(mobj)) {
      presentMainPlayer(pid, mobj, G.playersAugmented, false);
    }
    if (!isPlain() && !updatedVisuals[pid] && S.settings.hasCards) {
      if (G.player == pid) {
        if (G.playerChanged) {
          switchPlayerArea();
        }
        updateGameplayerCardCollections(pid, pl);
      }
    }
    if (!S.settings.player.createDefault || mobj && S.settings.player.createDefault != true) continue;
    let plms = presentDefault(pid, pl, false);
    _onPlayerChange(pid);
  }
}
function _poll() {
  if (nundef(U) || nundef(Z) || nundef(Z.friendly)) { console.log('poll without U or Z!!!', U, Z); return; }
  show_polling_signal();
  if (nundef(DA.pollCounter)) DA.pollCounter = 0; DA.pollCounter++; console.log('polling');
  if (Z.game == 'feedback' && i_am_host()) {
    send_or_sim({ friendly: Z.friendly, uname: Z.uplayer, fen: Z.fen, write_fen: true, auto: true }, 'table');
  } else send_or_sim({ friendly: Z.friendly, uname: Z.uplayer, auto: true }, 'table');
}
async function _preloader() {
  timit = new TimeIt('timit', EXPERIMENTAL);
  if (FASTSTART) {
    let syms = localStorage.getItem('syms');
    if (isdef(syms)) {
      console.log('from local');
      Syms = JSON.parse(syms);
    } else {
      Syms = await route_path_yaml_dict('../assets/syms.yaml');
      localStorage.setItem('syms', JSON.stringify(Syms));
    }
    SymKeys = Object.keys(Syms);
    dTable = mBy('table');
    mText('hallo', dTable, { fz: 100 });
    timit.show('DONE')
  } else _loader();
}
function _prepText1_dep(items, ifs, options) {
  //#region phase2: prepare items for container
  options.showLabels = true;
  let sz = options.sz;
  let padding = (isdef(ifs.padding) ? ifs.padding : 1);
  let bo = ifs.border;
  bo = isdef(bo) ? isString(bo) ? firstNumber(bo) : bo : 0;
  let szNet = sz - 2 * padding - 2 * bo;
  let textStyles, hText;
  if (options.showLabels) {
    let longestLabel = findLongestLabel(items);
    let oneWord = longestLabel.label.replace(' ', '_');
    textStyles = idealFontsize(oneWord, szNet, szNet, 22, 8);
    hText = textStyles.h;
    delete textStyles.h;
    delete textStyles.w;
  }
  let outerStyles = { rounding: 10, margin: sz / 12, display: 'inline-block', w: sz, padding: padding, bg: 'white', align: 'center', 'box-sizing': 'border-box' };
  outerStyles = deepmergeOverride(outerStyles, ifs);
  let pic, text;
  for (let i = 0; i < items.length; i++) {
    let item = items[i];
    let k = item.key;
    let d = mDiv();
    if (isdef(item.textShadowColor)) {
      let sShade = '0 0 0 ' + item.textShadowColor;
      textStyles['text-shadow'] = sShade;
      textStyles.fg = colorFrom('black', item.contrast); //'#00000080' '#00000030' 
    }
    if (options.showLabels) {
      textStyles.fg = item.fg;
      text = zText1Line(item.label, null, textStyles, hText);
      mAppend(d, text.div);
    }
    outerStyles.bg = item.bg;
    outerStyles.fg = item.fg;
    mStyleX(d, outerStyles);
    d.id = getUID();
    d.onclick = options.onclick;
    item.id = d.id;
    item.row = Math.floor(item.index / options.cols);
    item.col = item.index % options.cols;
    item.div = d;
    item.pic = null;
    item.isSelected = false;
    item.isLabelVisible = options.showLabels;
    item.dims = parseDims(sz, sz, d.style.padding);
    if (options.showRepeat) addRepeatInfo(d, item.iRepeat, sz);
    item.fzPic = 0;
  }
  //#endregion
}
function _preselectFirstVisualsForBoats() {
  let oidlist = [];
  for (const id of getBoatIds()) {
    let oids = id2oids[id];
    if (isdef(oids)) oids.map(x => addIf(oidlist, x))
  }
  let vislist = oidlist.map(x => getMainId(x)).filter(x => x !== null);
  vislist = vislist.concat(oidlist.map(x => getDefId(x)));
  vislist.map(id => UIS[id].highFrame());
}
function _presentLocationChange(oid, mobj) {
  if (G.table[oid].obj_type == 'robber') {
    let o = G.table[oid];
    let changedProps = G.tableUpdated[oid];
    if (changedProps.summary.includes('loc')) {
      let oidLoc = o.loc._obj;
      let visLoc = getVisual(oidLoc);
      mobj.setPos(visLoc.x, visLoc.y);
    }
  }
}
function _quadGrid(loc, idBoard, sBoard, soDict) {
  let board = createGrid(loc, idBoard, sBoard, soDict, 'quad');
  addVisuals(board);
  return board;
}
function _rChoose(arr, n = 1, func = null, exceptIndices = null) {
  let arr1 = jsCopy(arr);
  if (isdef(exceptIndices)) {
    for (const i of exceptIndices) removeInPlace(arr1, arr[i]);
  }
  if (isdef(func)) arr1 = arr1.filter(func);
  if (n == 1) {
    let idx = Math.floor(Math.random() * arr1.length);
    return arr1[idx];
  }
  arrShufflip(arr1);
  return arr1.slice(0, n);
}
function _recFindCollections(key, o, sets) {
  let tt = _getCollectionType(o);
  if (tt) {
    sets.push({ name: key, key: key, type: tt.type, generic_type: tt.generic_type, hand: o, arr: getSimpleSetElements(o) });
  } else if (isDict(o)) {
    for (const k in o) {
      let newSets = [];
      _recFindCollections(key + '.' + k, o[k], newSets);
      for (const s of newSets) {
        sets.push(s);
      }
    }
  } else if (isList(o)) {
    let i = 0;
    for (const cand of o) {
      let k = key + '_' + i;
      i += 1;
      let newSets = [];
      _recFindCollections(k, cand, newSets);
      for (const s of newSets) {
        sets.push(s);
      }
    }
  }
}
function _reduceFontsBy(tx, px, items, options) {
  fz = options.fzText - tx;
  fzPic = options.fzPic - px;
  options.fzPic = options.picStyles.fz = fzPic;
  options.fzText = options.labelStyles.fz = fz;
  for (const item of items) {
    let ui = item.live;
    if (tx != 0) mStyleX(ui.dLabel, { fz: fz });
    if (px != 0) mStyleX(ui.dPic, { fz: fzPic });
  }
}
function _reduceSizeBy(tx, px, items, options) {
  w = options.szPic.w - tx;
  h = options.szPic.h - tx;
  fz = options.fzText - tx;
  fzPic = options.fzPic - px;
  options.fzPic = options.picStyles.fz = fzPic;
  options.fzText = options.labelStyles.fz = fz;
  options.szPic = { w: w, h: h };
  for (const item of items) {
    let ui = item.live;
    if (tx != 0) {
      mStyleX(ui.dLabel, { fz: fz }); mStyleX(ui.div, { w: w, h: h });
    }
    if (px != 0) mStyleX(ui.dPic, { fz: fzPic });
  }
  console.log('fonts set to', fz, fzPic);
}
function _register(o, keyword, func) {
  if (nundef(S.registry[keyword])) S.registry[keyword] = {};
  S.registry[keyword][o.id] = func;
}
function _removeAllHighlighting(id) { let mobj = UIS[id]; mobj.unhighAll(); }
function _removeClickHandler(id) { let mobj = UIS[id]; mobj.removeClickHandler(); }
function _removeFilterHighlight(mobj) { mobj.unhighC(); }
function _removeHoverHandlers(id) { let mobj = UIS[id]; mobj.removeHoverHandlers(); }
function _removeInteraction(id) { let mobj = UIS[id]; mobj.removeHandlers(); mobj.unhighAll(); }
function _repositionCards(msHand) {
  if (msHand.numCards == 0) return;
  let dTitle = msHand.parts.title;
  let dBody = msHand.parts.hand;
  let dHand = msHand.elem;
  let bTitle = getBounds(dTitle);
  let bBody = getBounds(dBody, true);
  let bHand = getBounds(dHand);
  let yBody = bTitle.height;
  let hHand = msHand.hHand;
  let hAvailable = hHand - yBody;
  let wHand = bHand.width;
  let W = wHand;
  let H = hHand;
  let w = msHand.wCard;
  let h = msHand.hCard;
  let n = msHand.numCards;
  let x, y, dx, padding;
  let offset = { x: 0, y: 0 };
  if (msHand.adjustSize) {
    W = w + (n) * w / 4;
    H = h;
    padding = 0;
    msHand.setSize(W + 2 * padding + yBody, H);
    x = padding + offset.x;
    y = padding + offset.y;
  } else {
    padding = x = y = 0;
  }
  dx = n > 1 ? (W - w) / (n - 1) : 0;
  if (dx > w) dx = w;
  let i = 0;
  for (const oidCard of msHand.cards) {
    let id = getMainId(oidCard);
    let c = UIS[id];
    c.zIndex = c.elem.style.zIndex = i;
    i += 1;
    c.setPos(x, y);
    x += dx;
  }
}
function _runQ() {
  QCounter += 1; console.log('===>run', QCounter, Q);
  if (isEmpty(Q)) { console.log('Q empty!', AkQ); return; }
  let task = Q.shift();
  let f = task.f;
  let parr = _paramsQ(task.parr);
  console.log('task:', f.name, 'params', parr)
  let result = f(...parr);
  if (isdef(result)) AkQ.push(result);
  if (!isEmpty(Q)) runQ();
}
function _runRegistry(keyword) {
  if (nundef(S.registry[keyword])) return;
  for (const id in S.registry[keyword]) {
    S.registry[keyword][id](getVisual(id));
  }
}
function _saveAll() {
  saveUser();
  dbSave('boardGames');
}
function _selectText(el) {
  var sel, range;
  if (window.getSelection && document.createRange) {
    sel = window.getSelection();
    if (sel.toString() == '') {
      window.setTimeout(function () {
        range = document.createRange();
        range.selectNodeContents(el);
        sel.removeAllRanges();
        sel.addRange(range);
      }, 1);
    }
  } else if (document.selection) {
    sel = document.selection.createRange();
    if (sel.text == '') {
      range = document.body.createTextRange();
      range.moveToElementText(el);
      range.select();
    }
  }
}
function _sendCardToBack(id) { let c = UIS[id]; let elem = document.getElementById(id); elem.style.zIndex = c.zIndex; }
function _setEllipseDims(r, w, h, dx, dy) {
  r.setAttribute('rx', w / 2);
  r.setAttribute('ry', h / 2);
  r.setAttribute('cx', dx);
  r.setAttribute('cy', dy);
}
function _setIsa(ms, o) {
  listKey(ms, 'isa', o.obj_type);
  for (const d in isa) {
    if (d == 'id') { continue; }
    ms[d] = isa[d];
  }
}
function _setLineDims(r, x1, y1, x2, y2) {
  r.setAttribute('x1', x1);
  r.setAttribute('y1', y1);
  r.setAttribute('x2', x2);
  r.setAttribute('y2', y2);
}
function _setRectDims(r, w, h, dx, dy) {
  r.setAttribute('width', w);
  r.setAttribute('height', h);
  r.setAttribute('x', -w / 2 + dx);
  r.setAttribute('y', -h / 2 + dy);
}
function _setRowsColsSize(options) {
  let [rows, cols, wb, hb] = [options.rows, options.cols, options.szPic.w, options.szPic.h];
  options.or = rows < cols ? 'L' : 'P'
  let gap = options.gap = _calcPadGap(options.gap, wb, hb);
  let [wOffset, hOffset] = [gap / cols, gap / rows];
  let offset = Math.max(wOffset, hOffset, gap * .25);
  let w = wb - gap - offset, h = hb - gap - offset;
  options.szPic.w = w;
  options.szPic.h = h;
  options.padding = _calcPadGap(options.padding, w, h);
  options.outerStyles.padding = options.padding;
  let wn = w - options.padding * 2;
  let hn = h - options.padding * 2;
  let fz = options.showLabels == true ? (wn / options.longestLabelLen) * (options.luc != 'u' ? 1.9 : 1.7) : 0;
  let fzPic = Math.min(wn / 1.3, (hn - fz * 1.2) / 1.3);
  if (fzPic < fz * 2) { fz = Math.floor(hn / 4); fzPic = fz * 2; }
  let fzTest = Math.min(hn / 3, idealFontDims(options.longestLabel, wn, hn - fzPic, fz, 4).fz);
  options.fzPic = options.picStyles.fz = Math.floor(fzPic)
  options.fzText = options.labelStyles.fz = options.isUniform ? Math.min(Math.floor(fz), Math.floor(fzTest)) : Math.floor(fz);
  if (!options.isUniform && fz < 6 && fz * 4 < fzPic) { _handleTextTooSmall(fz, fzPic, wn, hn, options); }
}
function _setTextFont(items, options, fz) {
  options.fzText = options.labelStyles.fz = fz;
  console.log('items', items)
  items.map(x => { let dl = x.live.dLabel; if (isdef(dl)) dl.style.fontSize = fz + 'px'; });
}
function _setToList(oval) { if (typeof oval == 'object' && '_set' in oval) return oval._set; else return oval; }
function _show_history_popup() {
  if (isdef(mBy('dHistoryPopup')) || isEmpty(Z.fen.history)) return;
  let dpop = mPopup('', dTable, { fz: 16, bg: colorLight('#EDC690', .5), rounding: 8, fg: 'dimgray', top: 0, right: 0, border: 'white' }, 'dHistoryPopup');
  mAppend(dpop, UI.dHistory);
  mInsert(dpop, mCreateFrom(`<div style="margin-left:10px;text-align:left;width:100%;font-family:Algerian;font-size:22px;">${Config.games[Z.game].friendly}</div>`));
  let bclose = mButtonX(dpop, hide_history_popup, 'tr', 25, 'dimgray');
}
function _showBoat(id) { let mobj = UIS[id]; mobj.show(); mobj.o.weg = false; }
function _showHand(oids, idArea) {
  let idHand = idArea;
  let hand = UIS[idArea];
  let areaName = getAreaName(idArea);
  for (const oid of oids) {
    let mobj = getVisual(oid);
    if (nundef(mobj)) {
      mobj = makeCard(oid, G.table[oid], idHand);
    }
    if (!_isInHand(oid, idHand)) {
      addCardToHand(oid, idArea);
    }
  }
}
function _showPassToNextPlayer(plWaitingFor) {
  unfreezeUI();
  let d = document.getElementById('passToNextPlayerUI');
  let color = getPlayerColor(plWaitingFor);
  d.style.backgroundColor = color;
  let button = document.getElementById('c_b_passToNextPlayer');
  button.textContent = 'PASS TO ' + plWaitingFor;
  show('passToNextPlayerUI');
  WAITINGFORPLAYER = plWaitingFor;
}
function _simpleOptions(options = {}, defsOuter = {}) {
  options.showPic = valf(options.showPic, isdef(options.fzPic));
  options.showLabels = isdef(options.fz);
  options.szPic = { w: options.w, h: options.h };
  options.fzText = options.fz;
  if (nundef(options.rounding)) options.rounding = 4;
  if (nundef(options.margin)) options.margin = 4;
  if (nundef(options.padding)) options.padding = 0;
  if (nundef(options.labelStyles)) options.labelStyles = {};
  if (options.showLabels) { if (nundef(options.labelPos)) options.labelBottom = true; options.labelStyles.fz = options.fzText; }
  options.picStyles = { fz: options.fzPic };
  let [w, h] = [options.szPic.w, options.szPic.h];
  options.outerStyles = {
    w: w, h: h, bg: options.bg, fg: options.fg,
    display: 'inline-flex', 'flex-direction': 'column',
    'justify-content': 'center', 'align-items': 'center', 'vertical-align': 'top',
    padding: 0, box: true, margin: options.margin, rounding: options.rounding,
  };
  if (isdef(defsOuter)) addKeys(defsOuter, options.outerStyles);
  return options;
}
function _singleThreadedChainExRec(akku, onComplete) {
  if (CancelChain) {
    clearTimeout(ChainTimeout);
    BlockChain = false;
    console.log('chain canceled!', akku);
  } else if (isEmpty(TaskChain)) {
    BlockChain = false;
    onComplete(akku);
  } else {
    let task = TaskChain[0], f = task.f, parr = isdef(task.parr) ? task.parr : [], t = task.msecs, waitCond = task.waitCond, tWait = task.tWait;
    console.log('task:', f.name, 't', t)
    if (isdef(waitCond) && !waitCond()) {
      if (nundef(tWait)) tWait = 300;
      ChainTimeout = setTimeout(() => _singleThreadedChainExRec(akku, onComplete), tWait);
    } else {
      for (let i = 0; i < parr.length; i++) {
        let para = parr[i];
        if (para == '_last') parr[i] = arrLast(akku);
        else if (para == '_all' || para == '_list') parr[i] = akku;
        else if (para == '_first') parr[i] = akku[0];
      }
      let result = f(...parr);
      if (isdef(result)) akku.push(result);
      TaskChain = TaskChain.slice(1);
      if (isdef(t)) {
        ChainTimeout = setTimeout(() => _singleThreadedChainExRec(akku, onComplete), t);
      } else {
        _chainExRec(akku, onComplete);
      }
    }
  }
}
function _sizeByFactor(items, options, dGrid, factor = .9) {
  console.log('vorher', options.szPic, options.fzText, options.fzPic, options.padding, options.gap);
  w = options.szPic.w * factor;
  h = options.szPic.h * factor;
  fz = options.fzText;
  fzPic = options.fzPic * factor;
  options.fzPic = options.picStyles.fz = fzPic;
  options.fzText = options.labelStyles.fz = fz;
  options.szPic = { w: w, h: h };
  options.padding *= factor;
  options.gap *= factor;
  mStyleX(dGrid, { gap: options.gap / 2 });
  for (const item of items) { let ui = item.live; mStyleX(ui.dLabel, { fz: fz }); mStyleX(ui.div, { padding: options.padding, w: w, h: h }); mStyleX(ui.dPic, { fz: fzPic }); }
  console.log('fonts set to', fz, fzPic);
  console.log('...nachher', options.szPic, options.fzText, options.fzPic, options.padding, options.gap);
}
function _sizeByPixel(items, options, dGrid, factor = -1) {
  console.log('vorher', options.szPic, options.fzText, options.fzPic, options.padding, options.gap);
  w = options.szPic.w + factor;
  h = options.szPic.h + factor;
  fz = options.fzText + factor;
  fzPic = options.fzPic + factor;
  options.fzPic = options.picStyles.fz = fzPic;
  options.fzText = options.labelStyles.fz = fz;
  options.szPic = { w: w, h: h };
  options.padding += factor;
  options.gap += factor;
  mStyleX(dGrid, { gap: options.gap / 2 });
  for (const item of items) { let ui = item.live; mStyleX(ui.dLabel, { fz: fz }); mStyleX(ui.div, { padding: options.padding, w: w, h: h }); mStyleX(ui.dPic, { fz: fzPic }); }
  console.log('fonts set to', fz, fzPic);
  console.log('...nachher', options.szPic, options.fzText, options.fzPic, options.padding, options.gap);
}
function _spgameStart() {
  console.assert(isdef(DB));
  initLive();
  initTable();
  initSidebar();
  initAux();
  initScore();
  Speech = new SpeechAPI('E');
  console.log('Syms', Syms)
  KeySets = getKeySetsX();
  Settings = { language: 'E' }
  test04_textItems();
}
function _standardHandler(handler) {
  let f = isdef(handler) ?
    ev => { ev.cancelBubble = true; let res = handler(ev, evToItem(ev)); }
    : ev => { ev.cancelBubble = true; console.log('clicked on', evToClosestId(ev), evToLive(ev), evToItem(ev)); };
  return f;
}
async function _start() {
  set_run_state_no_server();
  onpagedeactivated(() => { saveEnv(); dbSave(); });
  await load_syms();
  await load_db();
  let dicode = CODE.di = await route_path_yaml_dict('../y/z_all.yaml');
  let kwindow = get_keys(window);
  test100();
}
function _start_game(gamename, players, options) {
}
async function _start_old() {
  //#region prelim timit set_run_state onpagedeactivated load:syms db codebase
  let timit = new TimeIt('* using timit *');
  set_run_state_vps();
  onpagedeactivated(save_all);
  await load_syms();
  await load_db();
  await load_codebase();
  timit.show();
  //#endregion
  //#region db tests
  function test_random_update() {
    let n = rNumber();
    let i = rNumber(0, DB.appdata.howto.length - 1);
    let rec = { kw: 'k' + n, c: 'hallo' + (n + i) };
    db_update('howto', i, rec);
  }
  //#endregion
  //#region other tests
  //#endregion
}
async function _start0() {
  console.assert(isdef(DB));
  DA = {}; Items = {};
  Speech = new SpeechAPI('E');
  KeySets = getKeySets();
  TOMan = new TimeoutManager();
  _start();
}
async function _start1() {
  set_run_state_no_server();
  onpagedeactivated(() => { fiddleSave(); dbSave(); });
  await load_syms();
  await load_db();
  let dicode = CODE.di = await route_path_yaml_dict('../basejs/z_all.yaml');
  let dijustcode = CODE.justcode = await route_path_yaml_dict('../basejs/z_allcode.yaml');
  computeClosure(['_start1']);
}
function _startHotseat() {
  timit.start_of_cycle(getFunctionCallerName());
  S.vars.switchedGame = true;
  S.settings.game = GAME;
  checkCleanup();
  S.user = {};
  G = { table: {}, players: {} };
  UIS = {};
  IdOwner = {};
  id2oids = {};
  oid2ids = {};
  id2uids = {};
  if (S.settings.useSpec) loadUserSpec([loadUserCode, sendInitNewGame]); else sendInitNewGame();
}
function _startLobby() { lobbyView(); }
function _startLogin() { loginView(); }
function _startMultiplayer() {
  whichGame(onWhichGame);
}
async function _startNewGame(role = 'starter') {
  gameView();
  S.settings.game = GAME;
  flags.specAndDOM = true;
  checkCleanup_III();
  S.user = {};
  G = { table: {}, players: {}, signals: {} };
  UIS = {};
  IdOwner = {};
  id2oids = {};
  oid2ids = {};
  id2uids = {};
  let initFunc = (role == 'starter') ? sendInitNewGame : sendStatusNewGame;
  await loadSpecAndCode();
  if (TESTING) stubSendInitNewGame(role == 'starter');
  else initFunc();
}
function _startRestartSame() {
  checkCleanup_I();
  sendRestartGame(USERNAME, SEED, [gameStep]);
}
async function _startSession() {
  timit = new TimeIt(getFunctionCallerName(), TIMIT_SHOW);
  await loadAssets();
  _initServer([ensureAllGames, () => {
    console.log('allGames', allGames)
    timit.showTime('nach loadAllGames_dep+loadIcons')
    gcsAuto();
    S.gameConfig = gcs[GAME];
    _startNewGame('starter');
    //#region earlier tests and starts:
    //#endregion
  }]);
}
function _startShort() {
  timit.start_of_cycle(getFunctionCallerName());
  if (isdef(UIS)) {
    stopInteraction();
    clearLog();
  }
  _sendRoute('/begin/1', d6 => {
    let user = isdef(S.gameInfo.userList) ? S.gameInfo.userList[0] : USERNAME;
    timit.showTime('sending status');
    _sendRoute('/status/' + user, d7 => {
      let data = JSON.parse(d7);
      timit.showTime('start processing');
      processData(data);
      gameStep();
    });
  });
}
function _startTest() {
  test03_2Hands();
}
function _startTest01() {
  console.log('HALLOOOOO');
  atest01();
}
function _syncUsernameOfSender(username) {
  if (nundef(username)) username = Username; else Username = username;
  plidSentStatus = getPlidForUsername(username);
}
function _SYS_START() {
  if (nundef(S) || nundef(S.vars)) {
    addEventListener('keyup', keyUpHandler);
    addEventListener('keydown', keyDownHandler);
  } else { checkCleanup(); }
  timit = new TimeIt(getFunctionCallerName());
  timit.tacit();
  S = { path: {}, user: {}, settings: {}, vars: { firstTime: true } };
  counters = { msg: 0, click: 0, mouseenter: 0, mouseleave: 0, events: 0 };
  DELETED_IDS = [];
  if (S.vars.firstTime) setDefaultSettings();
  console.log('playMode:', S.settings.playMode, 'PLAYMODE', PLAYMODE, 'S.playModeChanged', S.playModeChanged)
  S.vars.switchedGame = true;
  S.vars.firstTime = false;
  _initGameGlobals();
  presentMainMenu();
}
function _tableCreateNew() {
  for (const oid of G.tableCreated) {
    let o = G.table[oid];
    if (!defaultVisualExists(oid) && S.settings.table.createDefault == true) {
      makeDefaultObject(oid, G.table[oid], S.settings.table.defaultArea);
    }
    if (S.settings.table.ignoreTypes.includes(o.obj_type)
      || mainVisualExists(oid)
      || !S.settings.boardDetection && !S.settings.deckDetection && !S.settings.userStructures) {
      continue;
    }
    let updatedVisuals;
    let mobj;
    if (S.settings.userBehaviors) {
      updatedVisuals = runBehaviors(oid, G.table, TABLE_CREATE);
    }
    if (nundef(updatedVisuals) || !updatedVisuals.includes(oid)) {
      if ('loc' in o && isBoardElement(o.loc._obj)) mobj = makeMainBoardElementVisual(oid, G.table[oid]);
      if (mobj === null && !defaultVisualExists(oid) && S.settings.table.createDefault != false) {
        makeDefaultObject(oid, G.table[oid], S.settings.table.defaultArea);
      }
    }
  }
}
function _tableCreateNewSimple() {
  for (const oid of G.tableCreated) {
    let o = G.table[oid];
    if (S.settings.table.ignoreTypes.includes(o.obj_type)) continue;
    console.assert(!defaultVisualExists(oid), 'DEFAULT VISUAL EXISTS FOR ' + oid, o);
    let updatedVisuals = runBehaviors(oid, G.table, TABLE_CREATE);
    if (!updatedVisuals.includes(oid) && !mainVisualExists(oid)) {
      makeDefaultObject(oid, G.table[oid], S.settings.table.defaultArea);
    } else {
      console.log(updatedVisuals.includes(oid) ? 'created ' + oid : 'exists:' + oid);
    }
  }
}
function _tableRemove() {
  for (const oid of G.tableRemoved) {
    deleteOid(oid);
  }
}
function _tableRemoveSimple() {
  for (const oid of G.tableRemoved) {
    deleteOid(oid);
  }
}
function _tableUpdate() {
  for (const oid in G.tableUpdated) {
    let o = G.table[oid];
    if (nundef(o)) {
      continue;
    }
    if (isStructuralElement(oid)) {
      continue;
    }
    let changedProps = G.tableUpdated[oid].summary;
    let mobj = getVisual(oid);
    let updatedVisuals;
    if (!isDeckObject(o) && mobj) {
      if (S.settings.userBehaviors) {
        updatedVisuals = runBehaviors(oid, G.table, TABLE_UPDATE);
      }
      if (nundef(updatedVisuals) || !updatedVisuals.includes(oid)) {
        if (changedProps.includes('loc')) _presentLocationChange(oid, mobj);
        presentMain(oid, mobj, G.table);
      }
    }
    if (!S.settings.table.createDefault || mobj && S.settings.table.createDefault == 'miss') continue;
    presentDefault(oid, G.table[oid]);
  }
  if (S.settings.hasCards && !isPlain()) {
    for (const oid in G.table) {
      updateTableCardCollections(oid);
    }
  }
}
function _tableUpdateSimple() {
  for (const oid in G.tableUpdated) {
    let o = G.table[oid];
    if (nundef(o)) continue;
    let mobj = getVisual(oid);
    let updatedVisuals = runBehaviors(oid, G.table, TABLE_UPDATE);
    presentDefault(oid, G.table[oid]);
  }
}
function _test() {
  let o1 = {
    "_set": [
      {
        "_tuple": [
          {
            "_set": [
              { "ID": "91", "val": "Corner[91]", "type": "obj" },
              { "ID": "92", "val": "Corner[92]", "type": "obj" },
              { "ID": "93", "val": "Corner[93]", "type": "obj" },
            ]
          }
        ]
      }
    ]
  };
  let o3 = {
    "_set": [
      {
        "_tuple": [
          {
            "_set": [
              { "ID": "1", "val": "Corner[1]", "type": "obj" },
              { "ID": "2", "val": "Corner[2]", "type": "obj" },
            ]
          },
          {
            "_set": [
              { "ID": "3", "val": "Corner[3]", "type": "obj" },
            ]
          },
        ]
      }
    ]
  };
  let o4 = {
    "_tuple": [
      {
        "_set": [
          { "ID": "1", "val": "Corner[1]", "type": "obj" },
          { "ID": "2", "val": "Corner[2]", "type": "obj" },
        ]
      },
      {
        "_set": [
          { "ID": "3", "val": "Corner[3]", "type": "obj" },
        ]
      },
      {
        "_set": [
          { "ID": "4", "val": "Corner[3]", "type": "obj" },
          { "ID": "5", "val": "Corner[3]", "type": "obj" },
        ]
      },
    ]
  };
  let o2 = {
    "_set": [
      { "ID": "1", "val": "Corner[1]", "type": "obj" },
      { "ID": "2", "val": "Corner[2]", "type": "obj" },
      { "ID": "3", "val": "Corner[2]", "type": "obj" },
    ]
  };
  let o5 = {
    "_set": [
      {
        "_tuple": [
          {
            "_set": [
              { "ID": "1", "val": "Corner[1]", "type": "obj" },
              { "ID": "2", "val": "Corner[2]", "type": "obj" },
            ]
          },
          {
            "_set": [
              { "ID": "3", "val": "Corner[3]", "type": "obj" },
            ]
          },
        ]
      },
      {
        "_tuple": [
          {
            "_set": [
              { "ID": "4", "val": "Corner[1]", "type": "obj" },
              { "ID": "5", "val": "Corner[2]", "type": "obj" },
            ]
          },
          {
            "_set": [
              { "ID": "6", "val": "Corner[3]", "type": "obj" },
            ]
          },
        ]
      }
    ]
  };
  let o6 = {
    "_tuple": [
      {
        "_set": [
          { "ID": "4", "val": "Corner[1]", "type": "obj" },
          { "ID": "5", "val": "Corner[2]", "type": "obj" },
        ]
      },
      {
        "_set": [
          { "ID": "6", "val": "Corner[3]", "type": "obj" },
        ]
      },
    ]
  };
  let o7 = {
    "_tuple": [
      {
        "_set": [
          { "ID": "1", "val": "Corner[1]", "type": "obj" },
          { "ID": "2", "val": "Corner[2]", "type": "obj" },
        ]
      },
      {
        "_set": [
          { "ID": "3", "val": "Corner[3]", "type": "obj" },
        ]
      },
    ]
  };
  let o = o5;
  console.log('output', exp(o) ? tsRec(exp(o)) : 'undefined');
}
function _test01_load_game_info() {
  timit = new TimeIt('*');
  timit.showTime('hallo');
  ensureAllGames([() => timit.showTime('done')]);
}
async function _testing() {
  Items = {};
  iTest00();
}
function _testTable() {
  initRSGData(); hideLobby(); hideLogin(); showGame(); initDom();
  let gplayers = {
    White: {
      altName: "White",
      buildings: {
        city: { _set: [] },
        road: { _set: [{ _obj: "149" }] },
        settlement: { _set: [{ _obj: "148" }, { _obj: "158" }] },
      },
      color: "white",
      devcards: { _set: [] },
      id: { _player: "White" },
      opps: [{ _player: "Red" }, { _player: "Blue" }],
      opps2: { _set: ["White", "Red", "Blue"] },
      opps3: { _set: [{ _player: "Red" }, { _player: "Blue" }] },
      index: 0,
      name: "White",
      num_res: 3,
      obj_type: "GamePlayer",
      past_devcards: { _set: [] },
      reserve: { road: 14, settlement: 3, city: 4 },
      resources: { wood: 1, brick: 0, sheep: 1, ore: 0, wheat: 1 },
      username: "felix",
    },
    Red: {
      altName: "Red",
      buildings: {
        city: { _set: [] },
        road: { _set: [{ _obj: "149" }] },
        settlement: { _set: [{ _obj: "148" }, { _obj: "158" }] },
      },
      color: "Red",
      devcards: { _set: [] },
      id: "Red",
      index: 0,
      name: "Red",
      num_res: 3,
      past_devcards: { _set: [] },
      reserve: { road: 14, settlement: 3, city: 4 },
      resources: { wood: 1, brick: 0, sheep: 1, ore: 0, wheat: 1 },
      username: "maus",
    }
  };
  let gtable = {
    2: {
      col: 6,
      corners: [{ _obj: "101" }, { _obj: "102" }, { _obj: "103" }, { _obj: "104" }, { _obj: "99" }, { _obj: "98" }],
      edges: [{ _obj: "27" }, { _obj: "26" }, { _obj: "25" }, { _obj: "24" }, { _obj: "23" }, { _obj: "22" }],
      neighbors: [null, null, { _obj: "78" }, { _obj: "79" }, { _obj: "70" }, null],
      num: 11,
      obj_type: "hex",
      res: "ore",
      row: 0,
      visible: { _set: ["White", "Red", "Blue"] }
    },
    148: {
      loc: { _obj: "131" },
      obj_type: "settlement",
      player: {
        _player: "White"
      },
      opps: { opp1: { _player: "Red" }, opp2: { _player: "Blue" } },
      visible: {
        _set: [{ _player: "Red" }, { _player: "Blue" }]
      },
    },
    149: {
      loc: { _obj: "138" },
      obj_type: "settlement",
      player: {
        _player: "White"
      },
      visible: {
        _set: ["White", "Red", "Blue"]
      },
    },
    158: {
      loc: { _obj: "134" },
      obj_type: "road",
      player: {
        _player: "Red"
      },
      visible: { _set: ["White", "Red", "Blue"] },
    },
    145: {
      cols: 9,
      corners: { _set: [{ _obj: "101" }, { _obj: "102" }, { _obj: "103" },] },
      edges: { _set: [{ _obj: "101" }, { _obj: "102" }, { _obj: "103" },] },
      fields: { _set: [{ _obj: "101" }, { _obj: "102" }, { _obj: "103" },] },
      map: {
        _ndarray: [
          [null, { _obj: "3" }, null, { _obj: "4" }],
          [{ _obj: "5" }, null, { _obj: "6" }, null, { _obj: "7" }],
          [null, { _obj: "8" }, null],
        ]
      },
      obj_type: "board",
      rows: 5,
      visible: { _set: ["White", "Red", "Blue"] }
    }
  };
  console.log('gplayers', gplayers);
  console.log('gtable', gtable);
  addTableToArea(gtable[145], 'a_d_game');
  addTableToArea(gtable[148], 'a_d_game');
  addTableToArea(gplayers.White, 'a_d_objects');
}
function _tryGrow(items, options) {
  let again = false;
  let lastItem = items[items.length - 1];
  let rect = getRect(lDiv(lastItem));
  let bottom = rect.y + rect.h;
  let hArea = options.area.h;
  if (hArea > rect.h + 2 * options.gap) {
    fz = options.fzText + 1;
    fzPic = options.fzPic + 2;
    options.fzPic = options.picStyles.fz = fzPic;
    options.fzText = options.labelStyles.fz = fz;
    for (const item of items) {
      let live = item.live;
      mStyleX(live.dLabel, { fz: options.fzText });
      mStyleX(live.dPic, { fz: options.fzPic });
    }
    let ov = getVerticalOverflow(mBy(options.idGrid));
    if (Math.floor(ov) <= 0) again = true; else again = false;
  }
  if (again) _tryGrow(items, options);
  else {
    fz = options.fzText - 1;
    fzPic = options.fzPic - 2;
    options.fzPic = options.picStyles.fz = fzPic;
    options.fzText = options.labelStyles.fz = fz;
    for (const item of items) {
      let live = item.live;
      mStyleX(live.dLabel, { fz: options.fzText });
      mStyleX(live.dPic, { fz: options.fzPic });
    }
  }
}
function _ui_game_menu_item(g, g_tables = []) {
  function runderkreis(color, id) {
    return `<div id=${id} style='width:20px;height:20px;border-radius:50%;background-color:${color};color:white;position:absolute;left:0px;top:0px;'>` + '' + "</div>";
  }
  let [sym, bg, color, id] = [Syms[g.logo], g.color, null, getUID()];
  if (!isEmpty(g_tables)) {
    let t = g_tables[0];
    let have_another_move = t.player_status == 'joined';
    color = have_another_move ? 'green' : 'red';
    id = `rk_${t.id}`;
  }
  return `
  <div onclick="onclick_game_menu_item(event)" gamename=${g.id} style='cursor:pointer;border-radius:10px;margin:10px;padding:5px;padding-top:15px;min-width:120px;height:90px;display:inline-block;background:${bg};position:relative;'>
  ${nundef(color) ? '' : runderkreis(color, id)}
  <span style='font-size:50px;font-family:${sym.family}'>${sym.text}</span><br>${g.friendly.toString()}</div>
  `;
}
function _unfocusOnEnter(ev) { if (ev.key === 'Enter') { ev.preventDefault(); mBy('dummy').focus(); } }
function _unhighlightAndMinify(ev, mobj, partName) {
  minifyBack(mobj.id);
  unhighlightMsAndRelatives(ev, mobj, partName);
}
function _unhighlightBoat() {
  if (boatHighlighted) {
    unhighlightMsAndRelatives(null, boatHighlighted);
    _closeInfoboxesForBoatOids(boatHighlighted);
    boatHighlighted = null;
  }
}
function _updateCollections(propChanges, pool, propNames) {
  for (const oid in propChanges) {
    let o = pool[oid];
    if (!o || isBoardElementObject(o) || isBoardObject(o) || isDeckObject(o)) continue;
    for (const propName of propChanges[oid].summary) {
      if (!propNames.includes(propName)) continue;
      let o = pool[oid][propName];
      if (isSimple(o) || (isDict(o) && isdef(o.generic_type))) continue;
      let cLast = getCollections(oid, propName);
      let cCurrent = _findCollections(oid + '.' + propName, o);
      if (isEmpty(cCurrent) && isEmpty(cLast)) continue;
      let currentKeys = cCurrent.map(x => x.name);
      for (const c of cCurrent) {
        if (cLast && c.name in cLast) {
          if (nundef(collections[oid])) collections[oid] = {};
          if (nundef(collections[oid][propName])) collections[oid][propName] = {};
          collections[oid][propName][c.name] = c;
          c.tbd = 'update';
        } else {
          if (nundef(collections[oid])) collections[oid] = {};
          if (nundef(collections[oid][propName])) collections[oid][propName] = {};
          collections[oid][propName][c.name] = c;
          c.tbd = 'add';
        }
      }
      if (!cLast) continue;
      for (const k in cLast) {
        if (!(currentKeys.includes(k))) {
          collections[oid][propName][k].tbd = 'remove';
        }
      }
    }
  }
}
function _updateLogArea(prevPlid, plid) {
  if (prevPlid) hide('a_d_log_' + prevPlid);
  let id = 'a_d_log_' + plid;
  if (UIS[id]) show(id);
}
function _updatePageHeader(pid) {
  let mobj;
  for (const pl of S.gameConfig.players) {
    mobj = getPageHeaderDivForPlayer(pl.id);
    mobj.classList.remove('gamePlayer');
  }
  mobj = getPageHeaderDivForPlayer(pid);
  mobj.classList.add('gamePlayer');
}
function _valf(val, def) { return isdef(val) ? val : def; }
function _visualizeAritOp(op, a, b, dParent, symResult) {
  op = isString(op) ? OPS[op] : op;
  let dx = mDiv(dParent); mFlex(dx); mStyleX(dx, { 'align-items': 'center', gap: 16 });
  let d1 = visNumber(a, dx, 'blue');
  let d2 = visOperator(op.wr, dx);
  let d3 = visNumber(b, dx, 'green');
  let d4 = visOperator('=', dx);
  let result = isdef(symResult) ? symResult : op.f(a, b);
  let d5 = visNumber(result, dx, 'red');
  return dx;
}
function _visualizeMult(a, b, dParent, symResult) {
  op = OPS.mult;
  let dx = mDiv(dParent); mFlex(dx); mStyleX(dx, { 'align-items': 'center', gap: 16 });
  visNumber(a, dx, 'blue', 'v');
  for (let i = 1; i < b; i++) {
    let d2 = visOperator('+', dx);
    visNumber(a, dx, 'blue', 'v');
  }
  let d4 = visOperator('=', dx);
  let result = isdef(symResult) ? symResult : op.f(a, b);
  let d5 = visNumber(result, dx, 'red');
  return dx;
}
function _visualizeNumber(n, dParent, color, or = 'h') {
  let root = Math.sqrt(n);
  let rows = Math.floor(root);
  let cols = Math.ceil(root);
  if (or == 'v') { let h = rows; rows = cols; cols = h; }
  let dArea = mDiv(dParent, { display: 'inline-grid', 'grid-template-columns': `repeat(${cols}, 1fr)`, bg: 'white', fg: color });
  for (let i = 0; i < n; i++) {
    let item = getItem('plain-circle');
    let d = miPic(item, dArea, { fz: 12, margin: 6 });
    iAdd(item, { div: d });
    mAppend(dArea, d);
  }
  return dArea;
}
function _whenSoundPaused() {
  _sndPlayer = null;
  _sndPlayerIdle = true;
  _loaded = false;
  if (!isEmpty(_qSound)) { _deqSound(); } else { _idleSound = true; }
}
function _zoomIfNeeded(arr) {
  let wTotalNeeded = 0;
  for (const dName of arr) {
    let n = isNumber(dName) ? dName * bodyZoom : getBounds(dName).width;
    wTotalNeeded += n;
  }
  let wWindow = window.innerWidth;
  let newBodyZoom = (wWindow * bodyZoom / wTotalNeeded).toFixed(2);
  if (newBodyZoom == bodyZoom || newBodyZoom > 1 && bodyZoom == 1.0) return;
  if (Math.abs(newBodyZoom - 1.0) <= .03) {
    newBodyZoom = 1.0;
  }
  bodyZoom = Math.min(1.0, newBodyZoom);
  document.body.style.transformOrigin = '0% 0%';
  if (bodyZoom == 1.0) document.body.style.transform = 'none';
  else document.body.style.transform = 'scale(' + bodyZoom + ')';
}
function _zPicS(itemInfoKey, dParent, styles = {}) {
  let [item, info, key] = detectItemInfoKey(itemInfoKey);
  let outerStyles = isdef(styles) ? jsCopy(styles) : {};
  outerStyles.display = 'inline-block';
  let family = info.family;
  let wInfo = info.w;
  let hInfo = info.h; if (info.type == 'icon' && hInfo == 133) hInfo = 110;
  info.fz = 100;
  let innerStyles = { family: family };
  let [padw, padh] = isdef(styles.padding) ? [styles.padding, styles.padding] : [0, 0];
  let dOuter = isdef(dParent) ? mDiv(dParent) : mDiv();
  let d = mDiv(dOuter);
  d.innerHTML = info.text;
  let wdes, hdes, fzdes, wreal, hreal, fzreal, f;
  if (isdef(styles.w) && isdef(styles.h) && isdef(styles.fz)) {
    [wdes, hdes, fzdes] = [styles.w, styles.h, styles.fz];
    let fw = wdes / wInfo;
    let fh = hdes / hInfo;
    let ffz = fzdes / info.fz;
    f = Math.min(fw, fh, ffz);
  } else if (isdef(styles.w) && isdef(styles.h)) {
    [wdes, hdes] = [styles.w, styles.h];
    let fw = wdes / wInfo;
    let fh = hdes / hInfo;
    f = Math.min(fw, fh);
  } else if (isdef(styles.w) && isdef(styles.fz)) {
    [wdes, fzdes] = [styles.w, styles.fz];
    let fw = wdes / wInfo;
    let ffz = fzdes / info.fz;
    f = Math.min(fw, ffz);
  } else if (isdef(styles.h) && isdef(styles.fz)) {
    [hdes, fzdes] = [styles.h, styles.fz];
    let fh = hdes / hInfo;
    let ffz = fzdes / info.fz;
    f = Math.min(fh, ffz);
  } else if (isdef(styles.h)) {
    hdes = styles.h;
    f = hdes / hInfo;
  } else if (isdef(styles.w)) {
    wdes = styles.w;
    f = wdes / wInfo;
  } else {
    mStyleX(d, innerStyles);
    mStyleX(dOuter, outerStyles);
    return dOuter;
  }
  fzreal = Math.floor(f * info.fz);
  wreal = Math.round(f * wInfo);
  hreal = Math.round(f * hInfo);
  wdes = Math.round(wdes);
  hdes = Math.round(hdes);
  padw += isdef(styles.w) ? (wdes - wreal) / 2 : 0;
  padh += isdef(styles.h) ? (hdes - hreal) / 2 : 0;
  if (!(padw >= 0 && padh >= 0)) {
    console.log(info)
    console.log('\nstyles.w', styles.w, '\nstyles.h', styles.h, '\nstyles.fz', styles.fz, '\nstyles.padding', styles.padding, '\nwInfo', wInfo, '\nhInfo', hInfo, '\nfzreal', fzreal, '\nwreal', wreal, '\nhreal', hreal, '\npadw', padw, '\npadh', padh);
  }
  innerStyles.fz = fzreal;
  innerStyles.weight = 900;
  innerStyles.w = wreal;
  innerStyles.h = hreal;
  mStyleX(d, innerStyles);
  outerStyles.padding = '' + padh + 'px ' + padw + 'px';
  outerStyles.w = wreal;
  outerStyles.h = hreal;
  mStyleX(dOuter, outerStyles);
  return {
    info: info, key: info.key, div: dOuter, outerDims: { w: wdes, h: hdes, hpadding: padh, wpadding: padw },
    innerDims: { w: wreal, h: hreal, fz: fzreal }, bg: dOuter.style.backgroundColor, fg: dOuter.style.color
  };
}
function a_game() {
  function state_info(dParent) { dParent.innerHTML = `turn: ${Z.turn}, stage:${Z.stage}`; }
  function setup(players, options) {
    let fen = { players: {}, plorder: jsCopy(players), history: [] };
    shuffle(fen.plorder);
    let starter = fen.starter = fen.plorder[0];
    let cards_needed = players.length * options.handsize * 1.4;
    fen.num_decks = Math.ceil(cards_needed / 52);
    fen.deck = create_fen_deck('n', fen.num_decks, 0);
    shuffle(fen.deck);
    let [i, n, diff] = [0, players.length, get_slot_diff(fen)];
    for (const plname of players) {
      let pl = fen.players[plname] = {
        hand: deck_deal(fen.deck, options.handsize),
        score: 0,
        name: plname,
        color: get_user_color(plname),
        slot: diff * i,
      };
      i++;
    }
    [fen.phase, fen.stage, fen.step, fen.turn] = ['', 'click', 0, [starter]];
    return fen;
  }
  function present() { present_a_game(); }
  function check_gameover() { return false; }
  function activate_ui() {
    activate_a_game();
  }
  function post_collect() { agmove_resolve(); }
  return { post_collect, state_info, setup, present, check_gameover, activate_ui };
}
function a0(ev) {
  toggle_select(evToItem(ev), G.selist);
  toolbar_check();
}
function a0_functions() {
}
function a1(ev) { a0(ev); }
function a2_add_selection(items, label, min = 0, max = 100, goto_post = true) {
  clear_previous_level();
  A.level++;
  A.items = items;
  A.goto_post = goto_post;
  A.selected = [];
  let show_submit_button = min > 1 || min != max;
  let dParent = window[`dActions${A.level}`];
  for (const item of items) {
    let a = item.a;
    let idButton = getUID('b'); item.idButton = idButton; A.di[idButton] = item; item.uids = [idButton];
    let b = mButton(a, show_submit_button ? a2_toggle_selection : a2_select, dParent, { fz: 13 }, ['donebutton', 'enabled'], idButton);
    if (isdef(item.o)) {
      let go = item.o;
      let d = iDiv(go);
      go.id = d.id = getUID();
      mClass(d, 'hoverScale');
      d.onclick = show_submit_button ? a2_toggle_selection : a2_select;
      let idCard = d.id; item.idCard = idCard; A.di[idCard] = item; item.uids.push(idCard);
      set_hover_ui(b, go);
    }
  }
  if (show_submit_button) {
    if (isdef(mBy('b_submit'))) { let b = mBy('b_submit'); mAppend(dParent, b); }
    else mButton('submit', goto_post ? a2_post_if_uiActivated : a2_pre_if_uiActivated, dParent, { fz: 13, bg: 'red', fg: 'silver' }, ['donebutton', 'enabled'], 'b_submit');
  }
  if (isdef(mBy('b_restart_action'))) { let b = mBy('b_restart_action'); mAppend(dParent, b); }
  else mButton('restart action', () => turn_send_reload(G.otree.plturn), dParent, { fz: 13, bg: 'red', fg: 'silver' }, ['donebutton', 'enabled'], 'b_restart_action');
  if (items.length <= min) {
    uiActivated = false;
    for (let i = 0; i < items.length; i++) {
      A.selected.push(i);
      let a = items[i];
      mStyle(mBy(a.idButton), { bg: 'yellow' });
      if (isdef(a.idCard)) mClass(mBy(a.idCard), 'card_selected');
    }
    setTimeout(() => { if (goto_post) { ari_post_action(); } else { ari_pre_action(); } }, 500);
  } else if (is_admin()) {
    let movekey = G.otree.plturn + '_' + ITER;
    let selection_list = DA.auto_moves[movekey];
    if (nundef(selection_list)) selection_list = DA.auto_moves[ITER];
    if (isEmpty(selection_list)) return;
    uiActivated = false;
    let selection = selection_list.shift();
    let numbers = [];
    for (const el of selection) {
      if (el == 'last') {
        numbers.push(A.items.length - 1);
      } else if (isString(el)) {
        let commands = A.items.map(x => x.key);
        let idx = commands.indexOf(el);
        numbers.push(idx);
      } else numbers.push(el);
    }
    selection = numbers;
    setTimeout(() => {
      A.selected = selection;
      if (selection.length == 1) A.selected_key = A.items[A.selected[0]].key;
      a2_highlight_selected_items();
      if (A.goto_post) { ari_post_action(); } else { ari_pre_action(); }
    }, 1000);
  }
}
function a2_exchange_items(otree, o0, o1) {
  elem_from_to(o0.key, lookup(otree, o0.path.split('.')), lookup(otree, o1.path.split('.')));
  elem_from_to(o1.key, lookup(otree, o1.path.split('.')), lookup(otree, o0.path.split('.')));
}
function a2_get_all_hidden_building_items(uname) {
  let items = [];
  for (const gb of G[uname].buildings) {
    items = items.concat(a2_get_hidden_building_items(gb));
  }
  a2_reindex(items);
  return items;
}
function a2_get_build_items(uname) { return a2_get_hand_and_stall_items(uname); }
function a2_get_building_items(uname) {
  let gblist = G[uname].buildings;
  let items = [], i = 0;
  for (const o of gblist) {
    let name = o.type + ' ' + (o.list[0][0] == 'T' ? '10' : o.list[0][0]);
    o.div = o.container;
    let item = { o: o, a: name, key: o.list[0], friendly: name, path: o.path, index: i, ui: o.container };
    i++;
    items.push(item);
  }
  return items;
}
function a2_get_building_items_of_type(uname, types = ['farms', 'estates', 'chateaus']) {
  let gblist = G[uname].buildings.filter(x => types.includes(x.type));
  let items = [], i = 0;
  for (const o of gblist) {
    let name = o.type + ' ' + (o.list[0][0] == 'T' ? '10' : o.list[0][0]);
    o.div = o.container;
    let item = { o: o, a: name, key: o.list[0], friendly: name, path: o.path, index: i, ui: o.container };
    i++;
    items.push(item);
  }
  return items;
}
function a2_get_buildings(gblist) {
  let items = [], i = 0;
  for (const o of gblist) {
    let name = o.type + ' ' + (o.list[0][0] == 'T' ? '10' : o.list[0][0]);
    o.div = o.container;
    let item = { o: o, a: name, key: o.list[0], friendly: name, path: o.path, index: i, ui: o.container };
    i++;
    items.push(item);
  }
  return items;
}
function a2_get_coin_amounts(plturn) {
  let items = [];
  for (let i = 0; i <= G.otree[plturn].coins; i++) {
    let cmd = '' + i;
    let item = { o: null, a: cmd, key: cmd, friendly: cmd, path: null, index: i };
    items.push(item);
  }
  return items;
}
function a2_get_commands(plturn) {
  let avail = ari_get_actions(G.otree, plturn);
  let items = [], i = 0;
  for (const cmd of avail) {
    let item = { o: null, a: cmd, key: cmd, friendly: cmd, path: null, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function a2_get_endgame(plturn) {
  let items = [], i = 0;
  for (const cmd of ['end game', 'go on']) {
    let item = { o: null, a: cmd, key: cmd, friendly: cmd, path: null, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function a2_get_estates_chateaus_items(uname) { return a2_get_building_items_of_type(uname, ['estates', 'chateaus']); }
function a2_get_farms_estates_items(uname) { return a2_get_building_items_of_type(uname, ['farms', 'estates']); }
function a2_get_hand_and_stall_items(uname) {
  let items = a2_get_hand_items(uname);
  items = items.concat(a2_get_stall_items(uname));
  a2_reindex(items);
  return items;
}
function a2_get_hand_items(uname) {
  let items = [], i = 0;
  for (const o of G[uname].hand.items) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: `${uname}.hand`, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function a2_get_harvest_items(uname) {
  let items = []; let i = 0;
  for (const gb of G[uname].buildings) {
    if (isdef(gb.harvest)) {
      let d = gb.harvest;
      mStyle(d, { cursor: 'pointer', opacity: 1 });
      gb.div = d;
      let name = 'H' + i + ':' + (gb.list[0][0] == 'T' ? '10' : gb.list[0][0]);
      let item = { o: gb, a: name, key: name, friendly: name, path: gb.path, index: i };
      i++;
      items.push(item);
    }
  }
  return items;
}
function a2_get_hidden_building_items(b) {
  let items = [];
  for (let i = 1; i < b.items.length; i++) {
    let o = b.items[i];
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: b.path + '.list', index: i - 1 };
    items.push(item);
  }
  return items;
}
function a2_get_market_items() {
  let items = [], i = 0;
  for (const o of G.market.items) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: `market`, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function a2_get_open_discard_items() {
  let items = [], i = 0;
  for (const o of G.open_discard.items) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: `open_discard`, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function a2_get_other_buildings(plturn) {
  let items = [], i = 0;
  for (const uname of G.otree.plorder) {
    if (uname == plturn) continue;
    items = items.concat(a2_get_buildings(G[uname].buildings));
  }
  a2_reindex(items);
  return items;
}
function a2_get_repair_items(uname) {
  let ihand = a2_get_hand_items(uname);
  let istall = a2_get_stall_items(uname);
  let irepair = a2_get_all_hidden_building_items(uname);
  irepair.map(x => face_up(x.o));
  let items = ihand.concat(istall).concat(irepair);
  a2_reindex(items);
  return items;
}
function a2_get_stall_items(uname) {
  let items = [], i = 0;
  for (const o of G[uname].stall.items) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: `${uname}.stall`, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function a2_get_trade_items(uname) {
  let items = a2_get_market_items(uname);
  items = items.concat(a2_get_stall_items(uname));
  for (const plname of G.otree.plorder) {
    if (plname != uname) items = items.concat(a2_get_stall_items(plname));
  }
  a2_reindex(items);
  return items;
}
function a2_highlight_selected_items() {
  for (const i of A.selected) {
    let a = A.items[i];
    mStyle(mBy(a.idButton), { bg: 'yellow' });
    if (isdef(a.idCard)) mClass(mBy(a.idCard), 'card_selected');
  }
}
function a2_pay_with_card(item) {
  let fen = Z.fen;
  let source = lookup(fen, item.path.split('.'));
  elem_from_to_top(item.key, source, fen.deck_discard);
  ari_reorg_discard(fen);
}
function a2_pay_with_coin(uplayer) {
  let fen = Z.fen;
  fen.players[uplayer].coins -= 1;
}
function a2_post_if_uiActivated() {
  if (!uiActivated) { console.log('ui is deactivated!!!'); return; }
  ari_post_action();
}
function a2_pre_if_uiActivated() {
  if (!uiActivated) { console.log('ui is deactivated!!!'); return; }
  ari_pre_action();
}
function a2_reindex(items) { let i = 0; items.map(x => { x.index = i; i++; }); }
function a2_select(ev) {
  if (!uiActivated) { console.log('ui is deactivated!!!'); return; }
  let id = evToId(ev);
  let a = A.di[id];
  A.selected = [a.index];
  A.selected_key = A.items[a.index].key;
  mStyle(mBy(a.idButton), { bg: 'yellow' });
  if (isdef(a.idCard)) mClass(mBy(a.idCard), 'card_selected');
  if (A.goto_post) ari_post_action(); else ari_pre_action();
}
function a2_toggle_selection(ev) {
  if (!uiActivated) { console.log('ui is deactivated!!!'); return; }
  let id = evToId(ev);
  let a = A.di[id];
  if (A.selected.includes(a.index)) {
    removeInPlace(A.selected, a.index);
    mStyle(mBy(a.idButton), { bg: 'grey' });
    if (isdef(a.idCard)) mClassRemove(mBy(a.idCard), 'card_selected');
  } else {
    A.selected.push(a.index);
    mStyle(mBy(a.idButton), { bg: 'yellow' });
    if (isdef(a.idCard)) mClass(mBy(a.idCard), 'card_selected');
  }
}
function Accel() {
  var ax;
  var ay;
  var az;
  var rotX;
  var rotY;
  var rotZ;
  if (window.DeviceMotionEvent == undefined) {
    console.log("This program requires an accelerometer");
  } else {
    window.ondevicemotion = function (event) {
      this.ax = event.accelerationIncludingGravity.x;
      this.ay = event.accelerationIncludingGravity.y;
      this.az = event.accelerationIncludingGravity.z;
      rotation = event.rotationRate;
      if (rotation != null) {
        this.rotX = Math.round(rotation.alpha);
        this.rotY = Math.round(rotation.beta);
        this.rotZ = Math.round(rotation.gamma);
      }
    }
  }
  this.getAX = function () {
    if (window.ax == null) {
      window.ax = 0;
    }
    return window.ax;
  }
  this.getAY = function () {
    if (window.ay == null) {
      window.ay = 0;
    }
    return window.ay;
  }
  this.getAZ = function () {
    if (window.az == null) {
      window.az = 0;
    }
    return window.az;
  }
  this.getRotX = function () { return rotX; }
  this.getRotY = function () { return rotY; }
  this.getRotZ = function () { return rotZ; }
}
function accelerate(n) {
  meme.gravity = n;
}
function ack_player(plname) {
  let [fen, uplayer, pl] = [Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  assertion(sameList(Z.turn, [plname]), "ack_player: wrong turn");
  if (plname == fen.lastplayer || fen.players[uplayer].buy == true) {
    let func = window[fen.callbackname_after_ack];
    if (isdef(func)) func();
  } else {
    Z.turn = [get_next_in_list(plname, fen.ack_players)];
  }
  turn_send_move_update();
}
function action_close(item) {
  console.log('HALLO CLOSE!!!!!!!!!!!!!!!')
  let o = fromLocalStorage('app');
  let duration = get_now() - o.tStart;
  let factor = valf(item.val, 3);
  let secs = Math.round(duration / 1000);
  let mins = Math.round(secs / 60);
  let res = mins;
  let points = Math.round(res * factor / 5); if (points == 0) points = 1;
  let t = new Date(o.tStart).toTimeString().substring(0, 5);
  let s = `a:${t},${res},${points}`;
  console.log('string:', s);
  setTimeout(() => navigator.clipboard.writeText(s), 100)
}
function action_open(item) {
  console.log('HALLO OPEN!!!!!!!!!!!!!!!')
  let o = { tStart: get_now(), app: 'action' };
  toLocalStorage(o, 'app');
  let d = iDiv(item);
  let d1 = mDiv(d, { fz: 15, position: 'absolute', top: 2, right: 4 }, null, new Date(o.tStart).toTimeString().substring(0, 5));
  let d2 = mGrid(3, 3, d, { gap: 3, matop: 12 });
  for (const n of [.5, 1, 2, 3, 5, 8, 12, 20, 50]) {
    let b = mButton(n, () => item.val = n, d2, { cursor: 'pointer' });
  }
}
function actionOrWaiting(player, dAction, callback) {
  if ('actions' in dAction) {
    unitTestSender('found actions for', player);
    dAction.info.game.player = player;
    callback(dAction);
  } else if ('waiting_for' in dAction) {
    let waiting = getSet(dAction, 'waiting_for');
    unitTestSender('NEED PLAYER CHANGE!!!!!!!!!!!!', waiting);
    if (!empty(waiting)) {
      let newPlayer = waiting[0];
      sender.send('status_test/' + newPlayer, dNewPlayer => {
        dAction = extend(true, dAction, dNewPlayer);
        unitTestSender('action+status data for', newPlayer, dAction);
        dAction.info.game.player = newPlayer;
        callback(dAction);
      });
    } else {
      alert('empty waiting_for and no actions!!!');
    }
  } else {
    unitTestSender('NEED TO SEND EMPTY ACTION!!!!!!!!!!!!!', player);
    alert('sending empty action!!!', player);
    sendAction(player, ['pass'], dEMpty => {
      dAction = extend(true, dAction, dEmpty);
      callback(dAction);
    });
  }
}
function actions_off() {
  hide('dLeftSide');
  delete Session.is_actions;
  Actions = [];
}
function actions_on() {
  if (!isdef(mBy('dLeiste'))) initActionPanel();
  Session.is_actions = true;
  Actions = [];
}
function activate_a_game() {
  if (Z.stage == 'click') {
    show_MMM('back to normal!!!!');
    mButton('single turn move', agmove_single, dTable, { margin: 20 });
    mButton('clear players', agmove_clear_all, dTable, { margin: 20 });
    mButton('clear first', agmove_clear_first, dTable, { margin: 20 });
  } else if (Z.stage == 'clear') {
    agmove_startmulti();
  } else {
    mButton('indiv move', agmove_indiv, dTable, { margin: 20 });
  }
}
function activate_actions(r, uname) {
  console.log('actions', r.actions);
  if (!isEmpty(DA.staged_moves)) {
    dastaged(r, uname, 500);
  } else if (r.actions.length == 1) {
    autoselect_action(r, r.actions[0], uname);
  } else {
    for (const a of r.actions) {
      if (isdef(Items[a])) {
        let item = R.get_item(a);
        let d = iDiv(item);
        mStyle(d, { cursor: 'pointer' });
        d.onclick = ev => onselect_action(ev, r, a, uname);
      } else if (a == 'pass') {
        activate_pass_button(a, uname);
      } else if (startsWith(a, 'draw')) {
        let path = stringAfter(a, '.');
        let item = R.get_item(path);
        let d = iDiv(item);
        mStyle(d, { cursor: 'pointer' });
        d.onclick = ev => onselect_action(ev, r, a, uname);
        activate_draw_button(r, a, uname);
      }
    }
    highlight_player(uname);
    uiActivated = true;
  }
}
function activate_draw_button(r, action, uname) {
  mButton('draw', ev => select_action(r, action, uname), dActions, { fz: 13 }, ['donebutton', 'enabled'], 'd_draw');
}
function activate_pass_button(r, action, uname) {
  mButton('pass', ev => select_action(r, action, uname), dActions, { fz: 13 }, ['donebutton', 'enabled'], 'd_pass');
}
function activate_playerstats(items) {
  let fen = Z.fen;
  for (const plname in fen.players) {
    let ui = items[plname];
    let d = iDiv(ui);
    d.onclick = () => { switch_uname(plname); onclick_reload(); }
  }
}
function activate_ui() {
  if (uiActivated) { DA.ai_is_moving = false; return; }
  uiActivated = true; DA.ai_is_moving = false;
}
function activateChat(username) {
  if (DA.activeChat == username) { console.log('already active:', username); return; }
  if (isdef(DA.activeChat) && DA.activeChat != username) deactivateChat(DA.activeChat);
  DA.activeChat = username;
  let active = ActiveChats[username];
  let othername = username;
  let mename = Username;
  let other = active.userdata;
  let me = Userdata;
  if (nundef(active.div)) {
    let dcontactlist = mBy('dChat');
    other.bg = randomColor();
    other.fg = colorIdealText(other.bg);
    let dContact = presentInChatList(other, dcontactlist);
    active.div = dContact;
    mStyle(dContact, { bg: other.bg, fg: other.fg });
    dContact.onclick = () => activateChat(username);
  } else {
    console.log('es gibt schon ein entry fuer', username, 'in chat menu', iDiv(active), '\nactive', active)
  }
  mClass(active.div, 'activeChat');
  let d = showChatWindow();
  clearElement(d);
  console.log('add title to chatWindow!');
  for (const msg of active.messages) {
    let className = msg.sender == othername ? 'message_left' : 'message_right';
    let path = getProfileImagePath(msg.sender == othername ? other : me);
    let d1 = mDiv(d);
    if (msg.sender == othername) mStyle(d1, { bg: other.bg, fg: other.fg });
    let dImg = mImg(path, d1, { w: 40, h: 40, rounding: '50%' }, 'profile_img');
    let dtext = mText(msg.message, d1, {});
    mStyle(d1, { 'box-shadow': '0px 0px 10px #aaa', rounding: 10, padding: 10, matop: 10, display: 'flex', gap: 10, float: msg.sender == othername ? 'left' : 'right', w: '60%' });
  }
}
function ActivateChessWidgets() {
  StopThinking();
  $("#SetFen").click(function () {
    var fenStr = $("#fenIn").val();
    ParseFen(fenStr);
    PrintBoard();
    SetInitialBoardPieces();
    GameController.PlayerSide = brd_side;
    CheckAndSet();
    EvalPosition();
    NewGameAjax();
  });
  $("#UndoButton").click(function () {
    console.log('Undo request... brd_hisPly:' + brd_hisPly);
    if (brd_hisPly > 0) {
      TakeMove(); if (brd_hisPly > 0) TakeMove();
      brd_ply = 0;
      SetInitialBoardPieces();
      $("#currentFenSpan").text(BoardToFen());
    }
  });
  $("#HintButton").click(function () {
    FLAG_HINT_ONLY = true;
    let move = PreSearch();
  });
  $("#SearchButton").click(function () {
    GameController.PlayerSide = brd_side ^ 1;
    PreSearch();
  });
  $("#FlipButton").click(function () {
    GameController.BoardFlipped ^= 1;
    console.log("Flipped:" + GameController.BoardFlipped);
    SetInitialBoardPieces();
  });
  $("#EndGameButton").click(function () {
    let fen = chooseRandom(FenPositionList).FEN;
    console.log('fen', fen)
    NewGame(fen);
    NewGameAjax();
  });
  $("#NewGameButton").click(function () {
    NewGame();
    NewGameAjax();
  });
}
function activateFocusGroup(iFocus) {
  if (isdef(iFocus)) Goal.iFocus = iFocus;
  if (Goal.iFocus === null) {
    console.log('nothing to activate');
    return;
  }
  let g = Goal.words[Goal.iFocus];
  g.div.style.backgroundColor = 'black';
}
function activateML() {
  onkeypress = ev => {
    clearFleetingMessage();
    if (uiPaused || ev.ctrlKey || ev.altKey) return;
    let charEntered = ev.key.toString();
    if (!isAlphaNum(charEntered)) return;
    Selected = { lastLetterEntered: charEntered.toUpperCase() };
    if (nMissing == 1) {
      let d = Selected.feedbackUI = inputs[0].div;
      Selected.lastIndexEntered = inputs[0].index;
      Selected.inp = inputs[0];
      d.innerHTML = Selected.lastLetterEntered;
      mRemoveClass(d, 'blink');
      let result = buildWordFromLetters(mParent(d));
      evaluate(result);
    } else {
      let ch = charEntered.toUpperCase();
      for (const inp of inputs) {
        if (inp.letter == ch) {
          Selected.lastIndexEntered = inp.index;
          Selected.inp = inp;
          let d = Selected.feedbackUI = inp.div;
          d.innerHTML = ch;
          mRemoveClass(d, 'blink');
          removeInPlace(inputs, inp);
          nMissing -= 1;
          break;
        }
      }
      if (nundef(Selected.lastIndexEntered)) {
        showFleetingMessage('you entered ' + Selected.lastLetterEntered)
        say('this letter does NOT belong to the word!')
      }
      showFleetingMessage(composeFleetingMessage(), 3000);
    }
  }
}
function activateOn(item, event, handler) {
  let d = item.div;
  mStyleX(d, { cursor: 'pointer' });
  d[event] = ev => { handler(ev); evaluate() };
  item.isActive = true;
}
async function activateSP() {
  if (isSpeakerRunning) {
    setTimeout(activateSP, 300);
  } else {
    setTimeout(() => record(currentLanguage, bestWord), 100);
  }
}
async function activateSPA() {
  OnMicrophoneReady = setTimeout(() => {
    say(bestWord, .7, 1, 1, false, 'random');
  }, DELAY_BETWEEN_MIKE_AND_SPEECH);
  setTimeout(() => record(currentLanguage, bestWord), 100);
}
function activateTC() {
  uiActivatedTC = true;
}
function activateTests(commaSepString) {
  addIfComma(commaSepString, activatedTests);
}
function activateTooltips() {
  for (const oid in G.table) {
    if (isdef(getFirstVisual(oid))) createTooltip(oid);
  }
  for (const oid in G.players) {
    if (isdef(getFirstVisual(oid))) createTooltip(oid);
  }
}
function activateTooltips_hallo() {
  for (const oid in G.table) {
    if (isdef(getVisual(oid))) createTooltip(oid);
  }
  for (const oid in G.players) {
    if (isdef(getVisual(oid))) createTooltip(oid);
  }
}
function activateTP() {
  uiActivated = true;
}
function activateUi() {
  Selected = null;
  uiActivated = true;
  G.instance.activate();
}
function activateUis(R) {
  for (const uid in R.uiNodes) {
    let n = R.uiNodes[uid];
    if (isdef(n.oid) && isdef(n.ui)) {
      n.act.activate(highSelfAndRelatives, unhighSelfAndRelatives, selectUid);
    }
  }
  R.isUiActive = true;
}
function activateUserSelection() {
  hide(document.getElementById('dFrozen'));
  show(document.getElementById('dActive'));
  hide(document.getElementById('bNextPlayer'));
  show(document.getElementById('uiActiveButtons'));
  show(document.getElementById('ui2Buttons'));
  show(document.getElementById('uiEditButtons'));
}
function activateWaitingForServer() {
  show(document.getElementById('dFrozen'));
  hide(document.getElementById('dActive'));
  hide(document.getElementById('bNextPlayer'));
  hide(document.getElementById('uiActiveButtons'));
  hide(document.getElementById('ui2Buttons'));
  hide(document.getElementById('uiEditButtons'));
}
function activateWP() {
  inputBox.onkeyup = ev => {
    if (ev.ctrlKey || uiPaused) return;
    if (ev.key === "Enter") {
      ev.cancelBubble = true;
      evaluate(ev);
    }
  };
  inputBox.focus();
}
function activationUI() { uiPaused &= ~beforeActivationMask; }
function actualCenter(elem, relToParent = false, elRelTo) {
  let b = getBounds(elem, relToParent, elRelTo);
  return { x: Math.round(b.left + b.width / 2), y: Math.round(b.top + b.height / 2) };
}
function actualHeight(elem) { return Math.round(getBounds(elem).height); }
function actualLeft(elem, relToParent = false, elRelTo) { return Math.round(getBounds(elem, relToParent, elRelTo).left); }
function actualTop(elem, relToParent = false, elRelTo) { return Math.round(getBounds(elem, relToParent, elRelTo).top); }
function actualWidth(elem) { return Math.round(getBounds(elem).width); }
function add_a_correct_building_to(fen, uname, type) {
  let ranks = lookupSet(DA, ['test', 'extra', 'ranks'], 'A23456789TJQK');
  if (ranks.length <= 0) {
    console.log('===>ranks empty!', ranks)
    ranks = lookupSetOverride(DA, ['test', 'extra', 'ranks'], 'A23456789TJQK');
  }
  let r = ranks[0]; lookupSetOverride(DA, ['test', 'extra', 'ranks'], ranks.substring(1));
  let keys = [`${r}Sn`, `${r}Hn`, `${r}Cn`, `${r}Dn`];
  if (type != 'farm') keys.push(`${r}Cn`); if (type == 'chateau') keys.push(`${r}Hn`);
  fen.players[uname].buildings[type].push({ list: keys, h: null });
}
function add_a_schwein(fen, uname) {
  let type = rChoose(['farm', 'estate', 'chateau']);
  let keys = deck_deal(fen.deck, type[0] == 'f' ? 4 : type[0] == 'e' ? 5 : 6);
  fen.players[uname].buildings[type].push({ list: keys, h: null });
}
function add_agent_at(map, p1) {
  if (M.state != 'a') { console.log('wrong state!', M.state); return; }
  let a = new Agent(map, .0001, false, null, p1);
  lookupAddToList(M, ['agents'], a);
  console.log("adding agent at", p1);
}
function add_auction_history() {
  let [fen, plorder] = [Z.fen, Z.plorder];
  for (const plname of fen.plorder) {
    if (nundef(fen.buy[plname])) continue;
    ari_history_list([`${plname} buys ${fen.buy[plname].a} for ${fen.second_most}`], 'auction');
  }
}
function add_card_to_group(card, oldgroup, oldindex, targetcard, targetgroup) {
  card.groupid = targetgroup.id;
  if (card.source == 'hand') {
    let hand = UI.players[Z.uplayer].hand;
    removeInPlace(hand.items, card);
  }
  card.source = 'group';
  mDroppable(iDiv(card), drop_card_fritz, dragover_fritz);
  if (nundef(targetcard)) {
    targetgroup.ids.push(card.id);
    mAppend(iDiv(targetgroup), iDiv(card));
  } else {
    let index = targetgroup.ids.indexOf(targetcard.id) + 1;
    targetgroup.ids.splice(index, 0, card.id);
    mClear(iDiv(targetgroup));
    for (let i = 0; i < targetgroup.ids.length; i++) {
      let c = Items[targetgroup.ids[i]];
      mAppend(iDiv(targetgroup), iDiv(c));
    }
  }
  resplay_container(targetgroup);
}
function add_click_set_agent() { M.state = 'a'; M.map.on('click', e => { add_agent_at(M.map, [e.latlng.lat, e.latlng.lng]) }); }
function add_edit(x, y, text = '', bg = 'random') {
  let d = mDiv(dTable, { bg: bg, fg: 'contrast', x: x, y: y, position: 'absolute', padding: 10, wmin: 10, }, getUID(), text);
  DA.edits.push(d);
  add_interaction(d);
}
function add_element(f) {
  if (tree.length == 0) { addlayer(); return; }
  let root = firstCond(tree, x => !x.finished);
  if (!root) {
    console.log('tree is finished!');
    return;
  }
  if (root) f(root);
}
function add_havecode_content(dParent) {
  let d1 = mDiv(dParent);
  let [dl, dr] = mColFlex(d1, [4, 1]);
  dr.innerHTML = img_html('verify_right.jpg');
  let d2 = mDiv(dl, { w: '100%', padding: 12, box: true });
  let d3 = mDiv(d2, { fz: 22, weight: 900, rounding: 4, hmin: 50, border: 'none' }, null, 'Enter Authorization Code');
  let d4 = mDiv(dl, { w: '100%', padding: 12, box: true, fz: 14, family: 'Verdana' }, null, 'An authorization code was sent to your phone');
  let d5 = mDiv(dl, { w: '100%', matop: 12, mabottom: 20, hpadding: 12, box: true, fz: 14, family: 'Verdana' }, null, 'XXX-XXX-0297');
  let html = `
    <div>
      <form action="javascript:onclick_boa_submit_code();">
        <div>
          <label for="inpAuthocode">Authorization code</label><br>
          <input style="border:1px dotted silver;padding:4px" id="inpAuthocode" name="authocode" value="XXXXXX" type="text" />
          <div class="clearboth"></div>
        </div>
        <div style="font-size:12px;margin:30px 0px">The code expires 10 minutes after you request it.</div>
        <a style="font-size:12px;">Request another authorization code</a>
        <div style="margin-top:30px"><button id='bSubmit'>SUBMIT</button><button id='bCancel'>CANCEL</button></div>
      </form>
    </div>
  `;
  let d6 = mDiv(dl, { w: '100%', matop: 12, hpadding: 12, box: true, fz: 14, family: 'Verdana' }, null, html);
  let bSubmit = document.getElementById('bSubmit');
  let bStyle = { vpadding: 6, hpadding: 20, fz: 20, rounding: 6, maright: 25, weight: 'bold' };
  mStyle(bSubmit, bStyle);
  mStyle(bCancel, bStyle); mStyle(bCancel, { fg: 'grey', border: 'grey' })
  mClass(bSubmit, 'btn-bofa-blue');
  bCancel.onclick = onclick_boa_cancel;
}
function add_interaction(d) {
  d.setAttribute('contentEditable', true);
  d.style.outline = 'none';
  d.onkeydown = function (e) {
    DA.tabKeyPressed = e.keyCode == 9;
    if (DA.tabKeyPressed) {
      e.preventDefault();
      return;
    } else {
    }
  };
  d.onkeyup = function (e) {
    if (DA.tabKeyPressed) {
      let idx = DA.edits.indexOf(e.target);
      let next = (idx + 1) % DA.edits.length;
      if (next != idx) DA.edits[next].focus();
      e.preventDefault();
      return;
    }
  };
  d.onfocus = e => {
    if (DA.focusElement != e.target && isdef(DA.focusElement)) {
      let el = DA.focusElement;
      if (isEmpty(el.innerHTML)) {
        removeInPlace(DA.edits, el);
        el.remove();
      }
    }
    DA.focusElement = e.target;
  };
  d.focus();
}
function add_make_payments_button(ev) {
  let id = evToClosestId(ev);
  let inp = mBy(id);
  if (isdef(DA.prevHidden)) { mClear(DA.prevHidden); }
  let dHidden = inp.parentNode.parentNode.parentNode.parentNode.parentNode.lastChild;
  mClear(dHidden);
  let d1 = mCard(dHidden, { w: '90%', padding: 10, box: true });
  let el = mDiv(d1, { cursor: 'pointer' }, null, `<span class="btn-bofa btn-bofa-blue btn-bofa-blue-lock">Make Payments</span>`);
  el.onclick = () => make_payments_challenge_eval(inp);
  DA.prevHidden = dHidden;
}
function add_new_user(udata, save = true) {
  console.log('WILL NOT ADD NEW USERS AT THIS TIME!!!', udata); return;
  console.assert(isDict(udata) && isdef(udata.name) && isString(udata.name) && udata.name.length < 50, 'CANNOT ADD THIS WEIRED USER ' + udata.name);
  DB.users[udata.name] = udata;
  if (save) db_save();
  return udata;
}
function add_players() {
  let res = prompt('enter player names to be added: ');
  let parts = splitAtAnyOf(res, ' ,');
  let list = Session.game_options.players.slice(1);
  for (const p of parts) {
    let name = p.toLowerCase().trim();
    if (isdef(DB.users[name])) addIf(list, name);
  }
  list.sort(); list.unshift(Session.cur_user);
  populate_players(list);
}
function add_rumors_to_buildings(o) {
  fen = o.fen;
  for (const plname of fen.plorder) {
    let buildings = fen.players[plname].buildings;
    for (const type in buildings) {
      for (const b of buildings[type]) {
        if (type == 'farm') b.h = rCard('n');
        b.rumors = arrFunc(2, () => rCard('r'));
      }
    }
  }
}
function add_schwein(card, fenbuilding, uibuilding) {
  if (isdef(uibuilding)) add_ui_schwein(card, uibuilding.schweine);
  let ckey = isString(card) ? card : card.key;
  let index = isString(card) ? fenbuilding.list.indexOf(ckey) : card.index;
  fenbuilding.schweine.push(index);
  console.log('fen schweine', fenbuilding.schweine);
}
function add_to_chain(list) { DA.chain = DA.chain.concat(list); }
function add_transaction(cmd) {
  if (!DA.simulate) start_transaction();
  DA.transactionlist.push(cmd);
}
function add_ui_schwein(item, uischweine) {
  uischweine.push(item);
  mStyle(iDiv(item), { position: 'relative' });
  miPic('pig', iDiv(item), { position: 'absolute', top: 30, left: 0, fz: 30 });
  face_up(item);
}
async function add_users_to_sql_db(not_in_sql_db) { to_server(not_in_sql_db, 'add_users'); }
function add_verify_content(dParent) {
  let d1 = mDiv(dParent);
  let [dl, dr] = mColFlex(d1, [4, 1]);
  dr.innerHTML = img_html('verify_right.jpg');
  let d2 = mDiv(dl, { w: '100%', padding: 12, box: true });
  let d3 = mDiv(d2, { fz: 22, weight: 900, rounding: 4, hmin: 50, border: '3px solid black' }, null, 'Request Authorization Code');
  let d4 = mDiv(dl, { w: '100%', padding: 12, box: true, fz: 14, family: 'Verdana' }, null, 'To verify your identity, we need to send you an authorization code');
  let d5 = mDiv(dl, { w: '100%', matop: 12, hpadding: 12, box: true, fz: 14, family: 'Verdana' }, null, 'Select a Phone Number');
  let st1 = `padding:12px;font-size:18px;`;
  let stradio = `margin:5px 10px;color:black`;
  let html = `
    <div id='dPhoneContact' style="${st1}">
      <fieldset>
        <div style="${stradio}">
          <div>
            <input class="multipleContact" id="tlpvt-text1" name="phoneContact" value="text_1" type="radio" />
            <label for="tlpvt-text1">XXX-XXX-7382</label>
            <div class="clearboth"></div>
          </div>
        </div>
        <div style="${stradio}">
          <div class="phone-num">
            <input class="multipleContact" id="tlpvt-text2" name="phoneContact" value="text_2" type="radio" />
            <label class="TL_NPI_L1" for="tlpvt-text2">XXX-XXX-9671</label>
            <div class="clearboth"></div>
          </div>
        </div>
        <div style="${stradio}">
          <div class="phone-num">
            <input class="multipleContact" id="tlpvt-text3" name="phoneContact" value="text_3" type="radio" />
            <label class="TL_NPI_L1" for="tlpvt-text3">XXX-XXX-0297</label>
            <div class="clearboth"></div>
          </div>
        </div>
      </fieldset>
    </div>
  `;
  mAppend(dl, mCreateFrom(html));
  let d7 = mDiv(dl, { w: '100%', matop: 12, hpadding: 12, box: true, fz: 14, family: 'Verdana' }, null, 'How would you like to receive it?');
  html = `
    <div id='dTextOrPhone' style="${st1}">
      <fieldset>
        <div style="${stradio}">
          <div>
            <input class="multipleContact" id="tph-text1" name="textorphone" value="text_1" type="radio" checked />
            <label for="tph-text1">Text message</label>
            <div class="clearboth"></div>
          </div>
        </div>
        <div style="${stradio}">
          <div class="phone-num">
            <input class="multipleContact" id="tph-text2" name="textorphone" value="text_2" type="radio" />
            <label class="TL_NPI_L1" for="tph-text2">Phone call</label>
            <div class="clearboth"></div>
          </div>
        </div>
      </fieldset>
    </div>
  `;
  mAppend(dl, mCreateFrom(html));
  let d9 = mDiv(dl, { w: '100%', matop: 12, hpadding: 12, box: true, fz: 14, family: 'Verdana' }, null, 'The code expires 10 minutes after you request it');
  let d10 = mDiv(dl, { w: '100%', matop: 12, hpadding: 12, box: true, fz: 14, family: 'Verdana' }, null, '<a>Having trouble receiving you code by phone?</a>');
  let d11 = mDiv(dl, { w: '100%', matop: 12, hpadding: 12, box: true, fz: 14, family: 'Verdana' }, null, 'You are consenting to be contacted at the phone number selected for the purpose of receiving an authorization code. If you selected text message, Wireless and text message fees may apply from you carrier.<br>Supported carriers include AT&T, Sprint, T-Mobile, US Cellular, Verizon, or any other branded wireless operator.');
  let d12 = mDiv(dl, { hpadding: 12, matop: 24, gap: 12 }); mFlex(d12);
  let bstyle = { vpadding: 12, hpadding: 20, fz: 20, fg: 'grey', rounding: 6, maright: 25, weight: 'bold' };
  mButton('SEND CODE', onclick_boa_sendcode, d12, bstyle);
  mButton('CANCEL', onclick_boa_cancel, d12, bstyle);
}
function addAdjacencyFromTo(r1, r2, dir, rect) {
  let house = Items[r1.house];
  if (!r2) rect = rrto(rect, house.rect);
  lookupAddToList(r1, ['walls', dir], { rect: rect, dir: dir, room: r2 ? r2.id : r2, door: null });
  let dir2 = r2 ? getOppDir(dir) : dir;
  lookupAddToList(r2 ? r2 : Items[r1.house], ['walls', dir2], { rect: rect, dir: dir2, room: r1.id, door: null });
}
function addAll(akku, other) {
  for (const el of other) {
    akku.push(el);
  }
  return akku;
}
function addAREA(id, o) {
  if (AREAS[id]) {
    error('AREAS ' + id + ' exists already!!! ');
    error(o);
    return;
  }
  AREAS[id] = o;
}
function addAsSoundToDatabase(info, answer) {
}
function addBadge(dParent, level, clickHandler, animateRubberband = false) {
  let fg = '#00000080';
  let textColor = 'white';
  let isText = true; let isOmoji = false;
  let i = level - 1;
  let key = levelKeys[i];
  let k = replaceAll(key, ' ', '-');
  let item = getItem(k);
  let label = item.label = "level " + i;
  let h = window.innerHeight;
  let sz = h / 14;
  let options = _simpleOptions({ w: sz, h: sz, fz: sz / 4, fzPic: sz / 2, bg: levelColors[i], fg: textColor });
  options.handler = clickHandler;
  let d = makeItemDiv(item, options);
  mAppend(dParent, d);
  item.index = i;
  badges.push(item);
  return arrLast(badges);
}
function AddBlackPawnCaptureMove(from, to, cap) {
  if (RanksBrd[from] == RANKS.RANK_2) {
    AddCaptureMove(MOVE(from, to, cap, PIECES.bQ, 0));
    AddCaptureMove(MOVE(from, to, cap, PIECES.bR, 0));
    AddCaptureMove(MOVE(from, to, cap, PIECES.bB, 0));
    AddCaptureMove(MOVE(from, to, cap, PIECES.bN, 0));
  } else {
    AddCaptureMove(MOVE(from, to, cap, PIECES.EMPTY, 0));
  }
}
function AddBlackPawnQuietMove(from, to) {
  if (RanksBrd[from] == RANKS.RANK_2) {
    AddQuietMove(MOVE(from, to, PIECES.EMPTY, PIECES.bQ, 0));
    AddQuietMove(MOVE(from, to, PIECES.EMPTY, PIECES.bR, 0));
    AddQuietMove(MOVE(from, to, PIECES.EMPTY, PIECES.bB, 0));
    AddQuietMove(MOVE(from, to, PIECES.EMPTY, PIECES.bN, 0));
  } else {
    AddQuietMove(MOVE(from, to, PIECES.EMPTY, PIECES.EMPTY, 0));
  }
}
function addBoard(R) { R.initRound(); reAddServerObject('board'); }
function addBoatInteraction(id) {
  let mobj = UIS[id];
  mobj.addClickHandler('elem', onClickSelectTuple);
  mobj.addMouseEnterHandler('title', (x, pName) => x.high(pName));
  mobj.addMouseLeaveHandler('title', (x, pName) => x.unhigh(pName));
}
function addBorder(elem, color, thickness) {
  elem.style.border = color + ' ' + thickness + 'px solid';
  elem.style.boxSizing = 'border-box';
}
function addByKey(oNew, oOld, except) {
  for (const k in oNew) {
    let val = oNew[k];
    if (isdef(except) && except.includes(k) || !isNumber(val)) continue;
    oOld[k] = isdef(oOld[k]) ? oOld[k] + val : val;
  }
}
function AddCaptureMove(move) {
  brd_moveList[brd_moveListStart[brd_ply + 1]] = move;
  brd_moveScores[brd_moveListStart[brd_ply + 1]++] = MvvLvaScores[CAPTURED(move) * 14 + brd_pieces[FROMSQ(move)]] + 1000000;
}
function addCard(c, deck, top = true) { top ? deck.push(c) : deck.unshift(c); }
function addCardsToMainPlayer(n = 1) {
  if (GAME != 'catan') return;
  for (const plid in serverData.players) {
    let res = [];
    for (let i = 0; i < n; i++) {
      let card = {
        id: getUID(),
        short_name: 'K',
        obj_type: 'card',
        generic_type: 'card'
      };
      res.push({ _obj: card.id });
      serverData.table[card.id] = card;
    }
    let pl = serverData.players[plid];
    res = GAME == 'catan' ? pl.devcards._set.concat(res) : pl.hand._set.concat(res);
    if (GAME == 'catan') pl.devcards = { _set: res }; else pl.hand = { _set: res };
    break;
  }
}
function addCardsToPlayers(n = 1) {
  for (const plid in serverData.players) {
    let res = [];
    for (let i = 0; i < n; i++) {
      let card = {
        id: getUID(),
        short_name: 'K',
        obj_type: 'card',
        generic_type: 'card'
      };
      res.push({ _obj: card.id });
      serverData.table[card.id] = card;
    }
    let pl = serverData.players[plid];
    res = GAME == 'catan' ? pl.devcards._set.concat(res) : pl.hand._set.concat(res);
    if (GAME == 'catan') pl.devcards = { _set: res }; else pl.hand = { _set: res };
  }
}
function addCardTo(d) {
}
function addCardToCollectionArea(oid, collectionAreaName) {
  let idCollection = getIdArea(collectionAreaName);
  let isCard = getMainId(oid);
  let msCard = UIS[isCard];
  let msCollection = UIS[idCollection];
  msCard.hand = idCollection;
  msCard.collectionKey = msCollection.collectionKey;
  if (nundef(msCollection.numCards)) {
    msCollection.numCards = 1;
    msCollection.dx = 0;
    msCollection.cards = [oid];
  } else {
    msCollection.numCards += 1;
    msCollection.cards.push(oid);
  }
  let n = msCollection.numCards;
  msCard.zIndex = n;
  msCard.attach('hand');
  let hCard = msCard.elem.offsetHeight;
  let bounds = getBounds(msCard.elem);
  let hCard1 = bounds.height;
  let hHand = getBounds(msCollection.elem).height;
  let partHand = msCollection.parts['hand'];
  if (isdef(partHand)) hHand -= getBounds(partHand, true).y;
  msCollection.hHand = hHand;
  let wCard = msCard.elem.offsetWidth;
  let scale = 1;
  if (hCard >= hHand) {
    scale = hHand / hCard;
    msCard.elem.style.transform = `scale(${scale})`;
    msCard.elem.style.transformOrigin = '0% 0%';
  }
  msCollection.scale = scale;
  wCard = msCard.elem.offsetWidth;
  let wReal = wCard * scale;
  let hReal = hCard * scale;
  msCollection.wCard = wReal;
  msCollection.hCard = hReal;
  repositionCards(msCollection);
}
function addCardToHand(oid, areaName) {
  let idHandMS = getIdArea(areaName);
  let idCardMS = getMainId(oid);
  let mobj = UIS[idCardMS];
  let msHand = UIS[idHandMS];
  mobj.hand = idHandMS;
  if (nundef(msHand.numCards)) {
    msHand.numCards = 1;
    msHand.dx = 0;
    msHand.cards = [oid];
  } else {
    msHand.numCards += 1;
    msHand.cards.push(oid);
  }
  let n = msHand.numCards;
  mobj.zIndex = n;
  mobj.attach('hand');
  let hCard = mobj.elem.offsetHeight;
  let bounds = getBounds(mobj.elem);
  let hCard1 = bounds.height;
  let hHand = getBounds(msHand.elem).height;
  let partHand = msHand.parts['hand'];
  if (isdef(partHand)) hHand -= getBounds(partHand, true).y;
  msHand.hHand = hHand;
  let wCard = mobj.elem.offsetWidth;
  let scale = 1;
  if (hCard >= hHand) {
    scale = hHand / hCard;
    mobj.elem.style.transform = `scale(${scale})`;
    mobj.elem.style.transformOrigin = '0% 0%';
  }
  msHand.scale = scale;
  wCard = mobj.elem.offsetWidth;
  let wReal = wCard * scale;
  let hReal = hCard * scale;
  msHand.wCard = wReal;
  msHand.hCard = hReal;
  _repositionCards(msHand);
}
function addCatsToKeys() {
  console.log('Syms', Syms);
  for (const ksk in KeySets) {
    for (const k of KeySets[ksk]) {
      let info = Syms[k]
      lookupAddIfToList(info, ['cats'], ksk);
    }
  }
  downloadAsYaml(Syms, 'symsWithCats');
}
function addChat(msg) { addListItem('chatEvent', msg); }
function addClass(el, clName) { if (!el) return; el.classList.add(clName); }
function addClassInfo(ui, n) {
  if (isdef(ui.firstChild)) {
    let cl1 = Array.from(ui.firstChild.classList); cl1 = isEmpty(cl1) ? cl1 : cl1.join(',');
    let cl = Array.from(ui.classList); cl = isEmpty(cl) ? cl : cl.join(',');
    n.class = { pre: cl1, top: cl };
  } else {
    let cl = Array.from(ui.classList); cl = isEmpty(cl) ? cl : cl.join(',');
    n.class = cl;
  }
}
function addColorPicker(c) {
  let form = mBy('myform');
  let img = mBy('imgPreview');
  let picker = mColorPickerBehavior(colorFrom(c), img, form,
    (a) => { DA.newColor = a; DA.colorChanged = true; },
    { w: 322, h: 45, bg: 'green', rounding: 6, margin: 'auto', align: 'center' });
  if (is_online()) {
    img.ondragover = img.ondrop = img.ondragleave = handle_drag_and_drop;
  }
  mBy('img_dd_instruction').style.opacity = is_online() ? 1 : 0;
  img.onload = null;
}
function addColumn(dParent, o, keys) {
  console.log('addColumn', dParent)
  let d = getFloatLeftDiv();
  console.log('d', d)
  let t = tableElem(o, keys);
  d.appendChild(t);
  dParent.appendChild(d);
  dParent.style.backgroundColor = 'dimgray';
  return [d, t];
}
function addComment(s, dParent) { return mMultiline(s, 2, dParent); }
function addCSSClass(className, text) {
  sheet.insertRule('.' + className + ' { ' + text + ' }', 0);
}
function addDDSource(source, isCopy = true, clearTarget = false) {
  DDInfo.sources.push(source);
  let d = iDiv(source);
  d.onmousedown = (ev) => ddStart(ev, source, isCopy, clearTarget);
}
function addDDTarget(target, isCopy = true, clearTarget = false) {
  DDInfo.targets.push(target);
  target.isCopy = isCopy;
  target.clearTarget = clearTarget;
}
function addDeckTo(deck, domel, id, flip = false, drag = false) {
  if (nundef(id)) id = getUID();
  clearElement(domel);
  let mobj = new DeckMS(id, deck);
  mobj.attachTo(domel);
  if (flip) enableFlipForDeck(mobj.o);
  if (drag) enableDragForDeck(mobj.o);
  return mobj;
}
function addDiv(dParent, { html, w = '100%', h = '100%', bg, fg, border, rounding, margin, padding, float, position, x, y, textAlign, fontSize }) {
  return addDivU({ dParent: dParent, html: html, w: w, h: h, bg: bg, fg: fg, border: border, rounding: rounding, margin: margin, padding: padding, float: float, position: position, x: x, y: y, textAlign: textAlign, fz: fontSize });
}
function addDivClass(dParent, id, className) { return addDivU({ dParent: dParent, id: id, className: className }); }
function addDivFill(id, dParent) { return addDivU({ dParent: dParent, id: id, w: '100%', h: '100%' }); }
function addDivFullClass(dParent, id, className) { return addDivU({ dParent: dParent, id: id, w: '100%', h: '100%', className: className }); }
function addDivPos(dParent, x, y, w, h, { gap, bg, fg, border, rounding, textAlign, fontSize } = {}) {
  if (gap > 0) {
    let wCont = dParent.offsetWidth;
    let isRight = x + w >= wCont;
    let hCont = dParent.offsetHeight;
    let isBottom = y + h >= hCont;
    x += gap;
    y += gap;
    w -= (isRight ? 2 : 1) * gap;
    h -= (isBottom ? 2 : 1) * gap;
  }
  return addDiv(dParent, { position: 'absolute', x: x, y: y, w: w, h: h, bg, fg, border, rounding, textAlign, fontSize });
}
function addDivPosGap(dParent, x, y, w, h, { gap, bg, fg, border, rounding, textAlign, fontSize, position = 'absolute' } = {}) {
  return addDivU({ dParent: dParent, x: x, y: y, w: w, h: h, gap: gap, bg: bg, fg: fg, border: border, textAlign: textAlign, fz: fontSize, position: position });
}
function addDivPosTo(dParent, x = 0, y = 0, w = 100, h = 100, unit = '%', bg = 'blue', position = 'absolute') {
  return addDivU({ dParent: dParent, x: x, y: y, w: w, h: h, unit: unit, position: position, bg: bg });
}
function addDivTo(dParent, w = 100, h = 100, unit = '%', bg = 'blue') { return addDivU({ dParent: dParent, w: w, h: h, unit: unit, bg: bg }); }
function addDivToBody(w = 100, h = 100, unit = '%', bg = 'blue') { return addDivU({ dParent: document.body, w: w, h: h, unit: unit, bg: bg }); }
function addDivU({ id, dParent, w, h, unit, fg, bg, position, x, y, html, className, styleStr, border, rounding, gap, margin, padding, float, textAlign, fz }) {
  let d1 = document.createElement('div');
  if (isdef(dParent)) dParent.appendChild(d1); else dParent = null;
  if (isdef(id)) d1.id = id;
  if (isdef(fg)) d1.style.setProperty('color', fg);
  if (isdef(bg)) d1.style.setProperty('background-color', bg);
  if (isdef(html)) d1.innerHTML = html;
  if (gap > 0 && (unit == '%' || dParent && isdef(dParent.offsetWidth) && isdef(dParent.offsetHeight))) {
    let wCont = unit == '%' ? 100 : dParent.offsetWidth;
    let isRight = x + w >= wCont;
    let hCont = unit == '%' ? 100 : dParent.offsetHeight;
    let isBottom = y + h >= hCont;
    x += gap;
    y += gap;
    w -= (isRight ? 2 : 1) * gap;
    h -= (isBottom ? 2 : 1) * gap;
  }
  if (nundef(unit)) unit = '%';
  if (isdef(w)) d1.style.setProperty('width', makeUnitString(w, unit));
  if (isdef(h)) d1.style.setProperty('height', makeUnitString(h, unit));
  if (isdef(x) || isdef(y)) { posXY(d1, dParent, x, y, unit, position); }
  if (isdef(className)) d1.classList.add(className);
  if (isdef(styleStr)) d1.style.cssText += styleStr;
  if (isdef(border)) {
    d1.style.border = border;
    if (isdef(rounding)) d1.style.borderRadius = rounding;
  }
  if (isdef(margin)) d1.style.setProperty('margin', makeUnitString(margin, 'px'));
  if (isdef(padding)) d1.style.setProperty('padding', makeUnitString(padding, 'px'));
  if (float) d1.style.setProperty('float', float);
  if (textAlign) d1.style.textAlign = textAlign;
  if (isdef(fz)) d1.style.setProperty('fontSize', makeUnitString(fz, 'px'));
  return d1;
}
function addDummy() {
  let b = mButton('', null, dTitleRight, { opacity: 0, h: 0, w: 0, padding: 0, margin: 0, outline: 'none', border: 'none', bg: 'transparent' });
  b.id = 'dummy';
}
function addEdges(board, bid, gName, streets) {
  board.edges = [];
  board.edgesByStartRowCol = [];
  for (const fid of board.fields) {
    let f = EID[fid];
    let nodelist = Object.values(f.nodes);
    for (let k = 0; k < nodelist.length; k++) {
      let n1 = EID[nodelist[k]];
      let n2 = k == nodelist.length - 1 ? EID[nodelist[0]] : EID[nodelist[k + 1]];
      let smaller = n1;
      let bigger = n2;
      if (n1.x > n2.x) {
        smaller = n2;
        bigger = n1;
      } else if (n1.x == n2.x) {
        if (n1.y > n2.y) {
          smaller = n2;
          bigger = n1;
        }
      }
      let xEdge = (smaller.x + bigger.x) / 2;
      let yEdge = (smaller.y + bigger.y) / 2;
      let edge = byPos1(xEdge, yEdge);
      streets.border = 'green';
      if (!edge) {
        edge = makeElemY('edge', bid, gName, streets.level, {
          row: smaller.row,
          col: smaller.col,
          x: xEdge,
          y: yEdge,
          x1: smaller.x,
          y1: smaller.y,
          x2: bigger.x,
          y2: bigger.y,
          ipal: streets.ipal,
          bg: streets.bg,
          fg: streets.fg,
          shape: streets.shape,
          border: streets.border,
          thickness: streets.thickness
        });
        board.edges.push(edge.id);
        if (!(edge.row in board.edgesByStartRowCol)) board.edgesByStartRowCol[edge.row] = [];
        board.edgesByStartRowCol[edge.row][edge.col] = edge.id;
        edge.source = smaller.id;
        edge.dest = bigger.id;
        smaller.edges.push(edge.id);
        bigger.edges.push(edge.id);
        edge.nodes = [smaller.id, bigger.id];
        edge.fields = [];
      }
      f.edges.push(edge.id);
      edge.fields.push(f.id);
    }
  }
}
function addEndHandler() {
  recognition.onend = function () {
    if (!isGameWithSpeechRecognition()) return;
    isRunning = false;
    if (recordCallback) {
      if (RecogOutput) console.log('* recog.onend: recordCallback NON_EMPTY!', recordCallback);
      recordCallback();
      return;
    }
    MicrophoneHide();
    if (hasGotResult && !hasGotFinalResult) {
      if (RecogOutput) console.log('* recog.onend: EVAL interim', interim_transcript);
      setSpeechResult(interim_transcript, interim_confidence, interim_confidence2);
      evaluate(interim_transcript);
    } else if (!hasGotResult) {
      if (RecogOutput) console.log('* recog.onend: never got result!!!');
      if (OnMicrophoneProblem) OnMicrophoneProblem();
      else evaluate('');
    } else {
      if (RecogOutput) console.log('* recog.onend final DONE!', final_transcript);
    }
  };
}
function AddEnPassantMove(move) {
  brd_moveList[brd_moveListStart[brd_ply + 1]] = move;
  brd_moveScores[brd_moveListStart[brd_ply + 1]++] = 105 + 1000000;
}
function addErrorHandler() {
  recognition.onerror = function (event) {
    if (!isGameWithSpeechRecognition()) return;
    isRunning = false;
    if (RecogOutput) console.error(event);
    if (OnMicrophoneProblem) OnMicrophoneProblem();
    if (recordCallback) recordCallback();
  };
}
function addFilterHighlight(ms) { ms.highC('green'); }
function addFlexGridDiv(dParent) { return addDivU({ dParent: dParent, className: 'flex-grid' }); }
function addfork(root) {
  for (const a of [PI / 4, -PI / 6]) {
    let b = root.branch(a);
    root.children.push(b);
    tree.push(b);
  }
  root.finished = true;
}
function addGameViewHandlers() { addEventListener('keyup', keyUpHandler); addEventListener('keydown', keyDownHandler); }
function addGArea(gName, areaName = 'a_d_game', x = 0, y = 0, clearFirst = true) {
  let d = document.getElementById(areaName);
  if (clearFirst) {
    clearElement(d);
  }
  console.log(d, d.childNodes, d.firstChild);
  let container = d.firstChild ? d.firstChild : addDiv(d, { position: 'relative' });
  let w = container.offsetWidth;
  let h = container.offsetHeight;
  console.log('w', w, 'h', h);
  console.log(container);
  let dNew = addDiv(container, { position: 'absolute', x: x, y: y, w: w, h: h, bg: 'slategray', gap: 0 });
  let g = addSvgg(dNew, gName);
  g.classList.add('gCentered');
  return dNew;
}
function addGFill(id, dParent) {
  let res = addSvgg(dParent, id, { originInCenter: true });
  return res;
}
function addGrid9To(d, centerW, centerH, gap = '2px') {
  return makeGrid9(d, centerW, centerH, gap);
}
function addGridTo(d, rows, cols, gap = '2px') {
  console.log(d, rows, cols, gap);
  d.classList.add('gridContainer');
  d.style.setProperty('--grid-rows', rows);
  d.style.setProperty('--grid-cols', cols);
  d.style.setProperty('--grid-gap', gap);
  let cells = [];
  for (let r = 0; r < rows; r++) {
    cells[r] = [];
    for (let c = 0; c < cols; c++) {
      let cell = document.createElement("div");
      console.log(cell)
      cell.innerText = (r + ',' + c);
      d.appendChild(cell).className = "grid-item";
      cells[r].push(cell);
    }
  }
  return cells;
}
function addGridToBody(rows, cols) {
  let d = addDivToBody();
  d.classList.add('gridContainer');
  makeRows(d, rows, cols);
  return d;
}
async function addGroupInfo() {
  let symbolDict = SymbolDict = await localOrRoute('symbolDict', '../assets/symbolDict.yaml');
  let sInfo = SInfo = await localOrRoute('sInfo', '../assets/s_info.yaml');
  for (const k in Syms) {
    let old = symbolDict[k];
    let info = sInfo[k];
    if (isdef(old) && isdef(old.group)) {
      Syms[k].group = old.group;
      Syms[k].subgroup = old.subgroups;
    } else {
      Syms[k].subgroup = info.subgroup;
      Syms[k].group = info.group;
    }
  }
  for (const k in Syms) {
    if (nundef(Syms[k].group) || nundef(Syms[k].subgroup)) {
      console.log('IMMER NOCH KEIN GROUP INFO!!!!', k, Syms[k], sInfo[k], symbolDict[k]);
    }
  }
}
function AddGUIPiece(sq, pce) {
  var rank = RanksBrd[sq];
  var file = FilesBrd[sq];
  var rankName = "rank" + (rank + 1);
  var fileName = "file" + (file + 1);
  pieceFileName = "../base/assets/images/chess/" + SideChar[PieceCol[pce]] + PceChar[pce].toUpperCase() + ".png";
  imageString = "<image src=\"" + pieceFileName + "\" class=\"Piece clickElement " + rankName + " " + fileName + "\"/>";
  $("#ChessBoard").append(imageString);
}
function addHandTo(d) {
}
function addIdentityInformation() {
  if (nundef(S.gameConfig)) S.gameConfig = {};
  let gc = S.gameConfig;
  gc.username = USERNAME;
  let myPlayers = [];
  if (gc.gameConfig.players) {
    gc.gameStarter = gc.players[0];
    for (const pl of gc.players) {
      if (startsWith(pl.username, USERNAME)) myPlayers.push(pl);
    }
  }
}
function addIf(arr, el) { if (!arr.includes(el)) arr.push(el); }
function addIf_dep(el, arr) {
  if (!arr.includes(el)) arr.push(el);
}
function addIf_depComma(csv, arr) {
  let strings = csv.split(',');
  for (const s of strings) {
    addIf_dep(s.trim(), arr);
  }
}
function addIf_depDict(key, val, dict) {
  if (!(key in dict)) {
    dict[key] = [val];
  } else {
    addIf_dep(val, dict[key]);
  }
}
function addIf_depKeys(dict, keys, val) {
  let d = dict;
  keysCopy = jsCopy(keys);
  let lastKey = keysCopy.pop();
  for (const k of keysCopy) {
    if (!(k in d)) {
      d[k] = {};
    }
    d = d[k];
  }
  if (!(lastKey in d)) d[lastKey] = val;
  return d[lastKey];
}
function addIfComma(csv, arr) {
  let strings = csv.split(',');
  for (const s of strings) {
    addIf_dep(s.trim(), arr);
  }
}
function addIfDict(key, val, dict) {
  if (!(key in dict)) {
    dict[key] = [val];
  } else {
    addIf_dep(val, dict[key]);
  }
}
function addIfKeys(dict, keys, val) {
  let d = dict;
  keysCopy = jsCopy(keys);
  let lastKey = keysCopy.pop();
  for (const k of keysCopy) {
    if (!(k in d)) {
      d[k] = {};
    }
    d = d[k];
  }
  if (!(lastKey in d)) d[lastKey] = val;
  return d[lastKey];
}
function addItem(owner, key, val) {
  let o = owner[key] = val;
  Items.push(o);
}
function addKeydown(k, f) { if (nundef(DA.keydown)) DA.keydown = {}; DA.keydown[k] = f; }
function addKeys(ofrom, oto) { for (const k in ofrom) if (nundef(oto[k])) oto[k] = ofrom[k]; return oto; }
function addKeyup(k, f) {
  if (nundef(DA.keyup)) DA.keyup = {};
  DA.keyup[k] = f;
}
function addLabel(item, label, styles) {
  item.label = label;
  let div = iDiv(item);
  if (isdef(item.live.dLabel)) mRemove(item.live.dLabel);
  let dLabel = item.live.dLabel = mDiv(div, styles, null, label);
  mCenterFlex(div, true, true);
  mStyleX(div, { 'vertical-align': 'top' });
  return dLabel;
}
function addLabel1(item, label, replaceOld = true) {
  let div = iDiv(item);
  mStyleX(div, { 'vertical-align': 'top' });
  if (isdef(item.live.dLabel)) mRemove(item.live.dLabel);
  let dLabel = item.live.dLabel = mDiv(div, { fz: 20 }, null, label);
  return div;
}
function addLabels(items, lang = 'E', luc = 'c') {
  for (const item of items) {
    let label = item.info[lang];
    item.label = luc == 'c' ? toNoun(label) : luc == 'l' ? label : label.toUpperCase();
  }
}
function addlayer() {
  if (tree.length == 0) {
    let a = createVector(width / 2, height);
    let b = createVector(width / 2, height - 100);
    let root = tree[0] = new Branch(a, b);
  } else if (numlayers === 6) {
    for (let i = tree.length - 1; i >= 0; i--) {
      if (!tree[i].finished) addleaf(tree[i]);
    }
    clearInterval(interval_id);
  } else {
    for (let i = tree.length - 1; i >= 0; i--) {
      if (!tree[i].finished) addfork(tree[i]);
    }
    numlayers++;
  }
}
function addleaf(root) {
  let leaf = { current: root.get_healthy_end().copy(), orig: root.get_healthy_end().copy() };
  leaves.push(leaf);
  root.finished = true;
}
function addListItem(idParent, text) {
  const parent = document.getElementById(idParent);
  const el = document.createElement('li');
  el.innerHTML = text;
  parent.appendChild(el);
  parent.scrollTop = el.offsetTop;
}
function addLobbyViewHandlers() {
  document.getElementById('bLogout').addEventListener('click', onClickLogout);
  if (USE_SOCKETIO) document.getElementById('chat_form').addEventListener('submit', onChatSubmitted);
  document.getElementById('bJoinGame').addEventListener('click', onClickJoinGameLobby);
  document.getElementById('bCreateGame').addEventListener('click', onClickCreateGameLobby);
  document.getElementById('bResumeGame').addEventListener('click', onClickResumeGameLobby);
}
function addLoginViewHandlers() { document.getElementById('login_form').addEventListener('submit', onLoginSubmitted); }
function addManual00Node(nParent, R, funcContent) {
  let uidParent = nParent ? nParent.uid : null;
  let nChild = { uidParent: uidParent, idUiParent: uidParent, uid: getUID(), type: 'manual00', content: randomLetter() };
  nChild.content = isdef(funcContent) ? funcContent(nChild) : nChild.uid;
  if (nParent) {
    if (nundef(nParent.children)) nParent.children = [];
    nParent.children.push(nChild.uid);
  } else {
  }
  R.rNodes[nChild.uid] = nChild;
  return nChild;
}
function addManualCircle(g) {
  let circle = new MMS({ parent: g, type: 'ellipse' }).attach();
  let r = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
  r.setAttribute('rx', 35);
  r.setAttribute('ry', 45);
  r.setAttribute('cx', 0);
  r.setAttribute('cy', 0);
  r.setAttribute('fill', 'yellow');
  g.elem.appendChild(r);
  return r;
}
function addMessage(msg) {
  setMessage(msg);
  addListItem('events', msg);
}
function addModuleExports(list) {
  let txt =
    `if (this && typeof module == "object" && module.exports && this === module.exports) {\r\n`
    + `  module.exports = {\r\n`;
  for (const s of list) {
    txt += `    ${s},\r\n`
  };
  txt += '  }\r\n}';
  return txt;
}
function addMonthToDate(date, months) {
  let d = new Date(date);
  d.setMonth(d.getMonth() + months);
  return d;
}
function addMSContainer(dParent, gid, { w = '100%', h = '100%', margin = 'auto' }) {
  let d1 = addDiv(dParent, { w: w, h: h, margin: margin });
  d1.style.position = 'relative';
  let g1 = addSvgg(d1, gid);
  return { div: d1, g: g1 };
}
function addNewlyCreatedServerObjects(sdata, R) {
  for (const oid in sdata) { R.addObject(oid, sdata[oid]); R.addRForObject(oid); }
  for (const oid in sdata) {
    let o = sdata[oid];
    if (isdef(o.loc)) { continue; }
    let success = einhaengen(oid, o, R);
  }
  sieveLocOids(R);
}
function addNewObjectToSourcesAndPools(o, R) {
  let sp = R.getSpec();
  let missing = [];
  for (const k in sp) {
    let n = sp[k];
    if (nundef(n._source)) {
      n.source = R.defSource;
      pools[k] = n.pool = makePool(n.cond, n.source, R);
      n.pool.map(x => R.addR(x, k));
    } else missing.push(k);
  }
  while (missing.length > 0) {
    let done = null;
    for (const k of missing) {
      let n = sp[k];
      let sourceNode = sp[n._source];
      if (nundef(sourceNode.pool)) continue;
      n.source = sourceNode.pool;
      pools[k] = n.pool = makePool(n.cond, n.source, R);
      n.pool.map(x => R.addR(x, k));
      done = k;
      break;
    }
    removeInPlace(missing, done);
  }
  return [sp, pools];
}
function addNewServerObjectToRsg(oid, o, R, skipEinhaengen = false) {
  R.addObject(oid, o);
  addRForObject(oid, R);
  if (skipEinhaengen) { return; } else { einhaengen(oid, o, R); }
}
function addNodes(board, bid, gName, cities) {
  let wNode = board.hField / 8;
  let hNode = board.hField / 8;
  board.vertices = correctPolys(board.fields.map(fid => EID[fid].poly), wNode, board.hField / 12);
  board.nodes = [];
  board.nodesByRowCol = [];
  for (const fid of board.fields) {
    let f = EID[fid];
    let poly = f.poly;
    for (const pt of poly) {
      let node = byPos1(pt.x, pt.y, x => x.type == 'node');
      if (!node) {
        node = makeElemY('node', bid, gName, cities.level, {
          row: pt.y < f.y ? f.row - 1 : f.row,
          col: pt.x < f.x ? f.col - 1 : f.col,
          w: wNode,
          h: hNode,
          x: pt.x,
          y: pt.y,
          ipal: cities.ipal,
          bg: cities.bg,
          fg: cities.fg,
          shape: cities.shape,
          border: cities.border,
          thickness: cities.thickness
        });
        board.nodes.push(node.id);
        if (!(node.row in board.nodesByRowCol)) board.nodesByRowCol[node.row] = [];
        board.nodesByRowCol[node.row][node.col] = node.id;
        node.edges = [];
        node.fields = [];
        node.nodes = [];
      }
      node.fields.push(fid);
      f.nodes.push(node.id);
    }
  }
}
function addNthInputElement(dParent, n) {
  mLinebreak(dParent, 10);
  let d = mDiv(dParent);
  let dInp = mCreate('input');
  dInp.type = "text"; dInp.autocomplete = "off";
  dInp.style.margin = '10px;'
  dInp.id = 'inputBox' + n;
  dInp.style.fontSize = '20pt';
  mAppend(d, dInp);
  return dInp;
}
function addOidByLocProperty(oid, key, R) {
  let o = R.getO(oid);
  let oidParent = o.loc;
  let parents = R.oid2uids[oidParent];
  if (isEmpty(parents)) { return []; }
  let topUids = [];
  for (const uidParent of parents) {
    if (parentHasThisChildAlready(uidParent, oid) || !parentHasChannelForThisOid(R.rNodes[uidParent], oid)) continue;
    let n1 = instantOidKey(oid, key, uidParent, R);
    topUids.push({ uid: n1.uid, uidParent: uidParent });
  }
  return topUids;
}
function addOidByParentKeyLocation(oid, key, R) {
  let parents = R.Locations[key];
  if (nundef(parents)) {
    if (oid == '146') console.log('not added!!!', oid, key)
    return;
  }
  let topUids = [];
  for (const uidParent of parents) {
    if (parentHasThisChildAlready(uidParent, oid)) continue;
    let n1 = instantOidKey(oid, key, uidParent, R);
    topUids.push({ uid: n1.uid, uidParent: uidParent });
  }
  return topUids;
}
function addOnelineVars(superdi, o) {
  let [code, type] = [o.code, o.type];
  let crn = (code.match(/\r\n/g) || []).length;
  let oneliner = crn == 1;
  //let specialword = 'Counter'; //'PORT';
  let signal = false;
  if (oneliner && type == 'var' && code.includes(',') && !code.includes('[') && !code.includes('{ ')) {
    let othervars = stringAfter(code, 'var').trim().split(',');
    let varkeys = othervars.map(x => firstWord(x, true));
    assertion(varkeys[0] == o.name, `WTF?!?! ${varkeys[0]} ### ${o.name}?!?!?!?!????????????? addOnelinerVars`);
    o.code = stringBefore(code, ',') + ';'
    othervars.shift();
    if (signal) console.log('othervars', othervars, varkeys)
    for (const vcode of othervars) {
      let o1 = jsCopy(o);
      let code1 = vcode.trim();
      if (!code1.endsWith(';')) code1 += ';';
      if (signal) console.log('code1', code1);
      let k1 = o1.name = firstWord(code1, true);
      if (signal) console.log('k1', k1);
      o1.code = 'var ' + code1; // + code1.endsWith(';')?'':';'; //'\r\n':';\r\n';
      o1.sig = `var ${k1};`;
      if (isNumber(k1)) { continue; }
      if (signal) console.log('trage ein', k1, o1)
      lookupSetOverride(superdi, [type, k1], o1);
    }
  }
}
function addonFeatureInit() {
  ADS = null;
  if (USE_ADDONS == true) {
    ADS = jsCopy(lookup(DB, ['addons']));
    let di = {
      aPasscode: APasscode, aAddress: AAddress, aPassword: APassword,
      aExercise: APasscode, aMeditation: APasscode,
    };
    for (const k in ADS) { ADS[k].cl = di[k]; }
  }
}
function addPanel(areaName, oid) {
  let id = getDynId(areaName, oid);
  let color = randomColor();
  let parent = mBy(areaName);
  let ui = mDiv100(parent); ui.id = id; mColor(ui, color);
  let n = { type: 'panel', id: id, color: color, ui: ui };
  AREAS[areaName].panels.push(n);
  addAREA(id, n);
}
function addPara(div, s, margin = '0px', fontSize = '10px', color = 'green') {
  let p = getPara(s);
  div.appendChild(p);
  return p;
}
function addPara_tnt(div, s, margin = '0px', fontSize = '10px', color = 'green') {
  let p = document.createElement('p');
  p.id = uidHelpers();
  div.appendChild(p);
  $(p.id).css('background-color', 'violet');
  p.textContent = s;
  return p;
}
function addPeepToCrowd() {
  const peep = removeRandomFromArray(availablePeeps)
  const walk = getRandomFromArray(walks)({
    peep,
    props: resetPeep({
      peep,
      stage,
    })
  }).eventCallback('onComplete', () => {
    removePeepFromCrowd(peep)
    addPeepToCrowd()
  })
  peep.walk = walk
  crowd.push(peep)
  crowd.sort((a, b) => a.anchorY - b.anchorY)
  return peep
}
function addPic(item, key) {
  let div = item.div;
  let newItem = getPic(key, item.sz, item.bg, item.label);
  clearElement(div);
  mAppend(div, newItem.div.children[0]);
  mAppend(div, newItem.div.children[0]);
  item.pic = newItem.pic;
  item.text = newItem.text;
}
function addPicto(IdBoard, key, sz, x, y) {
  let mobj = makeDrawingElement(getUID(), 'board');
  let ch;
  try {
    ch = iconChars.get(key);
    if (!ch) {
      key = iconChars.getRandomKey();
      console.log(key)
      ch = iconChars.get(key);
    }
  } catch {
    ch = iconChars[key];
  }
  console.log('in addPicto got key', key, ch);
  mobj._pictoFromChar(ch, x, y, sz, sz, randomColor());
  mobj.attach();
}
function addPicto_dep(IdBoard, key, sz, x, y) {
  if (!(key in iconChars)) key = 'crow';
  console.log('found key:', key);
  let mobj = makeDrawingElement(getUID(), 'board');
  mobj._picto(key, x, y, sz, sz, randomColor());
  mobj.attach();
}
function addPictoDiv(key, area, color = 'blue', w = 50, h = 0) {
  let d = pictoDiv(key, color, w, h ? h : w);
  mAppend(area, d);
  return d;
}
function addPictoFromChar(IdBoard, ch, sz, x, y) {
  let mobj = makeDrawingElement(getUID(), 'board');
  mobj._pictoFromChar(ch, x, y, sz, sz, randomColor());
  mobj.attach();
}
function AddPiece(sq, pce) {
  var col = PieceCol[pce];
  HASH_PCE(pce, sq);
  brd_pieces[sq] = pce;
  brd_material[col] += PieceVal[pce];
  brd_pList[PCEINDEX(pce, brd_pceNum[pce])] = sq;
  brd_pceNum[pce]++;
}
function addPlayer(playerId, callback) {
  let username = USERNAME;
  if (nundef(S.plAddedByMe)) S.plAddedByMe = {};
  else {
    let up = S.plAddedByMe;
    let unames = Object.values(up);
    let plids = Object.keys(up);
    let i = plids.length;
    username = i == 0 ? USERNAME : USERNAME + i;
  }
  S.plAddedByMe[playerId] = username;
  pageHeaderAddPlayer(username, playerId, inferPlayerColorFromNameOrInit(playerId, S.gameInfo.player_names.indexOf(playerId)));
  let route = '/add/player/' + username + '/' + playerId; _sendRouteJS(route, callback);
}
function AddQuietMove(move) {
  brd_moveList[brd_moveListStart[brd_ply + 1]] = move;
  if (brd_searchKillers[brd_ply] == move) {
    brd_moveScores[brd_moveListStart[brd_ply + 1]] = 900000;
  } else if (brd_searchKillers[MAXDEPTH + brd_ply] == move) {
    brd_moveScores[brd_moveListStart[brd_ply + 1]] = 800000;
  } else {
    brd_moveScores[brd_moveListStart[brd_ply + 1]] = brd_searchHistory[brd_pieces[FROMSQ(move)] * BRD_SQ_NUM + TOSQ(move)];
  }
  brd_moveListStart[brd_ply + 1]++;
}
function addRandomChildren(n, R) {
  let num = randomNumber(1, 4);
  for (let i = 0; i < num; i++) {
    addManual00Node(n, R);
  }
  return n;
}
function addRandomContentToSidebarOrTable() {
  console.log('clicked!');
  let content = randomContent();
  console.log('content is type', type, '=>', content);
  let d = chooseRandom([mBy('dLeft'), mBy('dRight'), dTable]);
  mAddContentAndMeasureW(dTable, content);
}
function addRelatives(id, oid) {
  if (isdef(oid2ids[oid])) {
    for (const idOther of oid2ids[oid]) {
      if (idOther == id) {
        continue;
      }
      listKey(id2uids, id, idOther);
      listKey(id2uids, idOther, id);
    }
  }
}
function addRepeatInfo(dPic, iRepeat, wpic) {
  let szi = Math.max(Math.floor(wpic / 8), 8);
  dPic.style.position = 'relative';
  let d2 = mText('' + iRepeat, dPic, { fz: szi, weight: 'bold', fg: 'contrast', position: 'absolute', left: szi / 2, top: szi / 2 - 2 });
  return d2;
}
function addResizeInfo(nBoard, nMember, sizeNeeded) {
  let szNeeded = Math.max(sizeNeeded.w, sizeNeeded.h);
  if (nMember.info.size < szNeeded) {
    let memType = nMember.info.memType;
    let newSize = Math.max(sizeNeeded.w, sizeNeeded.h);
    newSize = Math.ceil(newSize / 4);
    newSize *= 4;
    if (newSize % 4 != 0) newSize += 4;
    let key = memType + 's';
    if (memType == 'edge') {
      newSize *= 2;
      memType = 'field';
      key = 'fields';
    }
    if (nundef(nBoard.resizeInfo)) nBoard.resizeInfo = {};
    if (nundef(nBoard.resizeInfo[key]) || nBoard.resizeInfo[key] < newSize) {
      nBoard.resizeInfo[key] = newSize;
      nMember.sizeNeeded = { w: newSize, h: newSize }
      if (key == 'corners') {
        let fSize = isdef(nBoard.resizeInfo.fields);
        if (nundef(fSize)) {
          let f0 = R.uiNodes[nBoard.children[0]];
          fSize = f0.info.size;
        }
        if (fSize < newSize * 3) {
          nBoard.resizeInfo.fields = newSize * 3;
        }
      }
    }
    nBoard.adirty = nMember.adirty = true;
  }
}
function addResultHandler() {
  recognition.onresult = function (event) {
    if (!isGameWithSpeechRecognition()) {
      if (RecogOutput) console.log('*event recog.onresult triggered but not a game with speech recog!!!')
      return;
    }
    hasGotResult = true;
    for (var i = event.resultIndex; i < event.results.length; ++i) {
      if (event.results[i].isFinal) {
        final_transcript += event.results[i][0].transcript;
        final_confidence_sum += event.results[i][0].confidence;
        final_num += 1;
      } else {
        interim_transcript += event.results[i][0].transcript;
        interim_confidence_sum += event.results[i][0].confidence;
        interim_num += 1;
      }
    }
    if (isdef(final_transcript) && !isEmpty(final_transcript)) {
      final_confidence = Goal.confidence = event.results[0][0].confidence;
      final_confidence2 = final_confidence_sum / final_num;
      hasGotFinalResult = true;
      final_confidence = event.results[0][0].confidence;
      recognition.stop();
      setSpeechResult(final_transcript, final_confidence, final_confidence2, true);
      evaluate(final_transcript);
    } else if (isdef(interim_transcript) && !isEmpty(interim_transcript)) {
      interim_confidence = event.results[0][0].confidence;
      interim_confidence2 = interim_confidence_sum / interim_num;
    } else {
      if (RecogOutput) console.log('* got result but final and interim are empty!')
    }
  };
}
function addRForObject(oid, R) {
  let o = R.getO(oid);
  let sp = R.getSpec();
  for (const k in sp) {
    let n = sp[k];
    if (nundef(n.cond)) continue;
    if (n.cond == 'all' || evalConds(o, n.cond)) { R.addR(oid, k); }
  }
  if (isEmpty(R.getR(oid))) {
    for (const k in sp) {
      let n = sp[k];
      if (nundef(n.cond)) continue;
      let keys = Object.keys(n.cond);
      if (!keys.includes('no_spec')) continue;
      let condCopy = jsCopy(n.cond);
      delete condCopy['no_spec'];
      if (evalConds(o, condCopy)) { R.addR(oid, k); }
    }
  }
  createPrototypesForOid(oid, o, R);
}
function addRobber(R) { R.initRound(); reAddServerObject('robber'); }
function addRowColInfo(dPic, row, col, szPic) {
  let szi = Math.max(Math.floor(szPic / 12), 8);
  console.log(szi);
  dPic.style.position = 'relative';
  let d2 = mText('row:' + row, dPic, { fz: szi, color: 'black', position: 'absolute', left: szi, top: szi / 2 })
  let d3 = mText('col:' + col, dPic, { fz: szi, color: 'black', position: 'absolute', left: szi, top: (szi / 2 + szi + 2) })
}
function addRowsCols(items) {
  let byrc = {};
  let byx = sortBy(items, 'x');
  let c = 0, x = byx[0].x;
  for (let i = 0; i < byx.length; i++) {
    let item = byx[i];
    if (!isCloseTo(item.x, x, 2)) { c += 1; x = item.x; }
    item.col = c;
  }
  let byy = sortBy(items, 'y');
  let r = 0, y = byy[0].y;
  for (let i = 0; i < byy.length; i++) {
    let item = byy[i];
    if (!isCloseTo(item.y, y, 2)) { r += 1; y = item.y; }
    item.row = r;
    lookupSet(byrc, [item.row, item.col], item);
  }
  return byrc;
}
function addScoreToUserSession() {
  let sc = { nTotal: Score.nTotal, nCorrect: Score.nCorrect, nCorrect1: Score.nCorrect1 };
  let game = G.id;
  let level = G.level;
  let session = U.session;
  if (nundef(session)) {
    console.log('THERE WAS NO USER SESSION IN _addScoreToUserSession!!!!!!!!!!!!!!!!!!!!!')
    U.session = {};
  }
  let sGame = session[game];
  if (nundef(sGame)) {
    sGame = session[game] = jsCopy(sc);
    sGame.byLevel = {};
    sGame.byLevel[level] = jsCopy(sc);
  } else {
    addByKey(sc, sGame);
    let byLevel = lookupSet(sGame, ['byLevel', level], {});
    addByKey(sc, byLevel);
  }
  sGame.percentage = Math.round(100 * sGame.nCorrect / sGame.nTotal);
  saveUser();
}
function addServerObject(oid, o, R) {
  if (!serverData.table) serverData.table = {};
  serverData.table[oid] = o;
  sData[oid] = jsCopy(o);
  addSO(oid, o, R);
  recAdjustDirtyContainers(R.tree.uid, R, true);
  updateOutput(R);
}
function addSessionToUserGames() {
  if (!isEmpty(U.session)) {
    for (const g in U.session) {
      let recOld = lookup(U, ['games', g]);
      let recNew = U.session[g];
      addByKey(recNew, recOld);
      recOld.percentage = Math.round(100 * recOld.nCorrect / recOld.nTotal);
      if (nundef(recOld.byLevel)) recOld.byLevel = {};
      for (const l in recNew.byLevel) {
        if (nundef(recOld.byLevel[l])) recOld.byLevel[l] = jsCopy(recNew.byLevel[l]);
        else addByKey(recNew.byLevel[l], recOld.byLevel[l]);
      }
    }
  }
  U.session = {};
}
function addSimpleProps(ofrom, oto = {}) { for (const k in ofrom) { if (nundef(oto[k]) && isLiteral(k)) oto[k] = ofrom[k]; } return oto; }
function addSO(oid, o, R) { let sd = {}; sd[oid] = o; addNewlyCreatedServerObjects(sd, R); }
function addSourcesAndPools(R) {
  let sp = jsCopy(R.getSpec());
  let pools = {};
  let missing = [];
  for (const k in sp) {
    let n = sp[k];
    if (nundef(n._source)) {
      n.source = R.defSource;
      pools[k] = n.pool = makePool(n.cond, n.source, R);
      n.pool.map(x => R.addR(x, k));
    } else missing.push(k);
  }
  while (missing.length > 0) {
    let done = null;
    for (const k of missing) {
      let n = sp[k];
      let sourceNode = sp[n._source];
      if (nundef(sourceNode.pool)) continue;
      n.source = sourceNode.pool;
      pools[k] = n.pool = makePool(n.cond, n.source, R);
      n.pool.map(x => R.addR(x, k));
      done = k;
      break;
    }
    removeInPlace(missing, done);
  }
  return [sp, pools];
}
function addSpanColor(dParent, id, bg, fg) {
  let d = document.createElement('span');
  dParent.appendChild(d);
  d.id = id;
  d.style.color = fg;
  d.style.backgroundColor = bg;
  return d;
}
function addStandardInteraction(id) {
  let ms = UIS[id];
  switch (id[2]) {
    case 'a': ms.addClickHandler('elem', onClickSelectTuple); break;
    case 'l': break;
    case 'r': break;
    case 't':
      if (id[0] == 'm') {
        ms.addClickHandler('elem', onClickFilterAndInfobox)
      } else {
        ms.addClickHandler('elem', onClickFilterTuples);
      }
      break;
    default: ms.addClickHandler('elem', onClickFilterTuples); break;
  }
  ms.addMouseEnterHandler('title', highlightMsAndRelatives);
  ms.addMouseLeaveHandler('title', unhighlightMsAndRelatives);
}
function addStartHandler() {
  recognition.onstart = function () {
    if (RecogOutput) console.log('* recog.onstart')
    interim_transcript = '';
    final_transcript = '';
    final_confidence = final_confidence2 = final_confidence_sum = final_num = 0;
    interim_confidence = interim_confidence2 = interim_confidence_sum = interim_num = 0;
    hasGotResult = hasGotFinalResult = false;
    recordCallback = null;
    if (!isGameWithSpeechRecognition()) return;
    isRunning = true;
    MicrophoneStart();
  };
}
function addStateToHistory(prefix = 'auto') {
  if (!isEmpty(prefix)) {
    let pack = packageState();
    HistoryOfStates[prefix] = pack;
    localStorage.setItem('history', JSON.stringify(HistoryOfStates));
    console.log('saved state', prefix, 'freeForm', pack.settings.freeForm, 'board', pack.settings.boardFilename)
  }
}
function addStyledDiv(dParent, id, html, styleString) { return addDivU({ dParent: dParent, id: id, html: html, styleStr: styleString }); }
function addSvgg(dParent, gid, { w = '100%', h = '100%', bg, fg, originInCenter = false } = {}) {
  let svg1 = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  if (!dParent.style.width || !dParent.style.height) {
    let pBounds = getBounds(dParent);
    w = pBounds.width + 'px';
    h = pBounds.height + 'px';
    if (pBounds.width == 0) {
      w = '100%';
      h = '100%';
    }
  }
  if (!dParent.style.position) dParent.style.position = 'relative';
  svg1.setAttribute('width', w);
  svg1.setAttribute('height', h);
  let style = 'margin:0;padding:0;position:absolute;top:0px;left:0px;';
  if (bg) style += 'background-color:' + bg;
  svg1.setAttribute('style', style);
  dParent.appendChild(svg1);
  let g1 = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  if (gid) g1.id = gid;
  svg1.appendChild(g1);
  if (originInCenter) { g1.style.transform = "translate(50%, 50%)"; }
  return g1;
}
function addSvggViewbox(dParent, gid, { w = '100%', h = '100%', bg, fg, originInCenter = false } = {}) {
  let svg1 = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  if (!dParent.style.width || !dParent.style.height) {
    let pBounds = getBounds(dParent);
    w = pBounds.width + 'px';
    h = pBounds.height + 'px';
  }
  if (!dParent.style.position) dParent.style.position = 'relative';
  svg1.setAttribute('width', w);
  svg1.setAttribute('height', h);
  svg1.setAttribute('viewBox', "0 0 433 375");
  let style = 'margin:0;padding:0;position:absolute;top:0px;left:0px;';
  if (bg) style += 'background-color:' + bg;
  svg1.setAttribute('style', style);
  dParent.appendChild(svg1);
  let g1 = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  if (gid) g1.id = gid;
  svg1.appendChild(g1);
  if (originInCenter) { g1.style.transform = "translate(50%, 50%)"; }
  return g1;
}
function addTableTo(table) {
  let div = document.getElementById('slideInAvailableCadres');
  div.appendChild(table);
}
function addTableToArea(o, areaName) {
  let d = UIS[areaName].elem;
  let t = tableElemX(o);
  console.log('d', d)
  console.log('t', t.table)
  d.appendChild(t.table)
  d.appendChild(document.createElement('hr'));
}
function addTask(task) {
  if (!CancelChain) TaskChain.push(task);
}
function addTestInteraction(id) {
  let mobj = UIS[id];
  mobj.addClickHandler('title', onClickGetUIS);
  mobj.addMouseEnterHandler('title', (x, pName) => x.high(pName));
  mobj.addMouseLeaveHandler('title', (x, pName) => x.unhigh(pName));
}
function addTestInteraction1(id) {
  let mobj = UIS[id];
  mobj.addClickHandler('', onClick1);
}
function addTitleLine(dParent, left, center, right) {
  let dt = document.createElement('div');
  dt.style.textAlign = 'center';
  dt.classList.add('ttdiv')
  let pl = getPara(left, 'left');
  let pr = getPara(right, 'right');
  let pCenter = getPara(center);
  dt.appendChild(pl);
  dt.appendChild(pr);
  dt.appendChild(pCenter);
  dParent.appendChild(dt);
  return [dt, dt.offsetWidth, dt.offsetHeight, dParent.offsetWidth, dParent.offsetHeight];
}
function addTitleToGrid(n, d) {
  if (n.content && n.params.padding) {
    let d1 = mText(n.content, d);
    d1.style.display = 'block';
    d1.style.backgroundColor = 'black';
    d1.style.position = 'absolute';
    d1.style.width = '100%';
  }
}
function addToPool(pool, poolArr, perle, index) {
  let p = pool[index] = { key: perle.key, index: index };
  poolArr.push(index);
  return p;
}
function addUserAsFirstAvailablePlayer() {
  let nextPlayer = S.availablePlayers[0];
  addPlayer(nextPlayer, onPlayerAdded);
}
function addVisuals(board, { f2nRatio = 4, opt = 'fitRatio', gap = 4, margin = 20, edgeColor, fieldColor, nodeColor, iPalette = 1, nodeShape = 'circle', factors, w, h } = {}) {
  let area = UIS[board.idParent];
  w = area.w;
  h = area.h;
  let isPalField, isPalCorner, isPalEdge = [false, false, false];
  let pal = S.settings.palette;
  [fieldColor, nodeColor, edgeColor] = [pal[2], pal[3], pal[4]];
  let [fw, fh, nw, nh, ew] = getBoardScaleFactors(board, { factors: factors, opt: opt, f2nRatio: f2nRatio, w: w, h: h, margin: margin });
  for (const id of board.structInfo.fields) {
    let o = getVisual(id);
    makeVisual(o, o.memInfo.x * fw, o.memInfo.y * fh, board.structInfo.wdef * fw - gap, board.structInfo.hdef * fh - gap, fieldColor, o.memInfo.shape);
    o.memInfo.isPal = isPalField;
    o.attach();
  }
  if (isdef(board.structInfo.corners)) {
    for (const id of board.structInfo.corners) {
      let mobj = getVisual(id);
      mobj.memInfo.isPal = isPalCorner;
      makeVisual(mobj, mobj.memInfo.x * fw, mobj.memInfo.y * fh, Math.max(board.structInfo.wdef * nw, ew), Math.max(board.structInfo.hdef * nh, ew), nodeColor, nodeShape);
    }
  }
  if (isdef(board.structInfo.edges)) {
    let nodeSize = getVisual(board.structInfo.corners[0]).w;
    for (const id of board.structInfo.edges) {
      let mobj = getVisual(id);
      mobj.memInfo.isPal = isPalEdge;
      makeVisual(mobj, mobj.memInfo.x * fw, mobj.memInfo.y * fh, mobj.memInfo.thickness * ew, 0, edgeColor, 'line', { x1: mobj.memInfo.x1 * fw, y1: mobj.memInfo.y1 * fh, x2: mobj.memInfo.x2 * fw, y2: mobj.memInfo.y2 * fh });
      mobj.length = mobj.h = mobj.distance - nodeSize;
      mobj.attach();
    }
  }
  if (isdef(board.structInfo.corners)) {
    for (const id of board.structInfo.corners) getVisual(id).attach();
  }
}
async function addVocabTo2020Syms() {
  let syms20 = await route_path_yaml_dict('../assets/syms2020.yaml');
  let etext = await route_path_text('../assets/speech/w2020/w20_E.txt');
  let ew = etext.split('\n');
  let dtext = await route_path_text('../assets/speech/w2020/w20_D.txt');
  let ftext = await route_path_text('../assets/speech/w2020/w20_F.txt');
  let stext = await route_path_text('../assets/speech/w2020/w20_S.txt');
  let ctext = await route_path_text('../assets/speech/w2020/w20_C.txt');
  let dw = dtext.split('\n');
  let fw = ftext.split('\n');
  let sw = stext.split('\n');
  let cw = ctext.split('\n');
  let edict = {};
  for (let i = 0; i < ew.length; i++) {
    let ek = ew[i].toLowerCase().trim();
    if (isEmpty(ek)) continue;
    edict[ek] = { E: ek, D: dw[i].toLowerCase().trim(), F: fw[i].toLowerCase().trim(), S: sw[i].toLowerCase().trim(), C: cw[i].trim() };
  }
  console.log(edict);
  let edlist = dict2list(edict, 'key');
  for (const k in syms20) {
    console.log('k=' + k, edict[k]);
    let e = firstCond(edlist, x => k.includes(x.key.toLowerCase()) || k.includes('pinch') && x.key.toLowerCase().includes('pinch'));
    console.log('entry for', k, 'is', e);
    if (isdef(e)) {
      let info = syms20[k];
      info.E = e.E;
      info.D = e.D;
      info.F = e.F;
      info.S = e.S;
      info.C = e.C;
    }
  }
  downloadAsYaml(syms20, 'syms20');
}
function addWeekToDate(date, weeks) {
  let d = new Date(date);
  d.setDate(d.getDate() + (weeks * 7));
  return d;
}
function AddWhitePawnCaptureMove(from, to, cap) {
  if (RanksBrd[from] == RANKS.RANK_7) {
    AddCaptureMove(MOVE(from, to, cap, PIECES.wQ, 0));
    AddCaptureMove(MOVE(from, to, cap, PIECES.wR, 0));
    AddCaptureMove(MOVE(from, to, cap, PIECES.wB, 0));
    AddCaptureMove(MOVE(from, to, cap, PIECES.wN, 0));
  } else {
    AddCaptureMove(MOVE(from, to, cap, PIECES.EMPTY, 0));
  }
}
function AddWhitePawnQuietMove(from, to) {
  if (RanksBrd[from] == RANKS.RANK_7) {
    AddQuietMove(MOVE(from, to, PIECES.EMPTY, PIECES.wQ, 0));
    AddQuietMove(MOVE(from, to, PIECES.EMPTY, PIECES.wR, 0));
    AddQuietMove(MOVE(from, to, PIECES.EMPTY, PIECES.wB, 0));
    AddQuietMove(MOVE(from, to, PIECES.EMPTY, PIECES.wN, 0));
  } else {
    AddQuietMove(MOVE(from, to, PIECES.EMPTY, PIECES.EMPTY, 0));
  }
}
function adjacency_init(items) {
  let last = arrLast(items);
  let [rows, cols] = [last.iy + 1, last.ix + 1];
  console.log('there are', rows, 'rows', cols, 'cols')
}
function adjustContainerLayout(n, R) {
  console.log('...........adjustContainer____________', n.uid);
  n.adirty = false;
  if (n.type == 'grid') {
    resizeBoard(n, R);
    return;
  }
  if (n.type == 'hand') { layoutHand(n); return; }
  if (n.uid && isBoardMember(n.uid, R)) {
    adjustLayoutForBoardMember(n, R);
  }
  let params = n.params;
  let num = n.children.length;
  let or = params.orientation ? params.orientation : DEF_ORIENTATION;
  mFlex(n.ui, or);
  let split = params.split ? params.split : DEF_SPLIT;
  if (split == 'min') return;
  let reverseSplit = false;
  if (split == 'equal') split = (1 / num);
  else if (isNumber(split)) reverseSplit = true;
  for (let i = 0; i < num; i++) {
    let d = R.uiNodes[n.children[i]].ui;
    mFlexChildSplit(d, split);
    if (reverseSplit) { split = 1 - split; }
  }
}
function adjustLayoutForBoardMember(n, R) {
  console.log('adjust layout for', n.uid);
  let ch = n.children[0];
  let n1 = R.uiNodes[ch];
  console.log('id_divParent', n1.idUiParent, 'id_directParent', n1.uidParent)
  let divParent = mBy(n1.idUiParent);
  let directParent = mBy(n1.uidParent);
  let ui = n1.ui;
  let nuiBoard = R.uiNodes[n.uidParent];
  console.log(nuiBoard)
  let bmk = getBounds(directParent, false, divParent);
  let arr;
  let [wTotal, hTotal, wBoard, hBoard, fw, fh, fSpacing, fSize, gap] =
    [nuiBoard.wTotal, nuiBoard.hTotal, nuiBoard.wBoard, nuiBoard.hBoard, nuiBoard.fw, nuiBoard.fh, nuiBoard.fSpacing, nuiBoard.fSize, nuiBoard.gap];
  console.log('wTotal', wTotal, 'hTotal', hTotal, 'wBoard', wBoard,
    'hBoard', hBoard, 'fw', fw, 'fh', fh, 'fSpacing', fSpacing, 'fSize', fSize, 'gap', gap)
  let bdiv = getBounds(divParent);
  divParent.style.backgroundColor = 'yellow';
  ui.style.position = 'absolute';
  ui.style.display = 'inline-block';
  let bel = getBounds(ui);
  let x = 0;
  let y = 0;
  ui.style.left = x + 'px';
  ui.style.top = y + 'px';
  ui.style.margin = '0px';
  console.log('x', x, '\nbdiv left', bdiv.left, 'w', bdiv.width, '\nbmk left', bmk.left, 'w', bmk.width, '\nbel left', bel.left, 'w', bel.width);
  n.sizeNeeded = { w: Math.max(bmk.width, bel.width), h: Math.max(bmk.height, bel.height) };
  if (bmk.width < bel.width || bmk.height < bel.height) {
    let nBoard = R.uiNodes[n.uidParent];
    nBoard.adirty = true;
    let memType = n.info.memType;
    let curSize = n.typParams.size;
    let newSize = Math.max(bel.width, bel.height);
    newSize = Math.ceil(newSize / 4);
    newSize *= 4;
    if (newSize % 4 != 0) newSize += 4;
    if (nundef(nBoard.resizeInfo)) nBoard.resizeInfo = {};
    nBoard.resizeInfo[memType + 's'] = newSize;
  }
  n.uiType = 'childOfBoardElement';
  n.potentialOverlap = true;
}
function adjustPlayerAreaWise() {
  let areaName = S.settings.present.player.defaultArea;
  let msArea = UIS[areaName];
  let wArea = msArea.w;
  let minWidth = S.vars.wDefaultPlayer + 10;
  if (wArea < minWidth) {
    let diff = S.vars.wDefaultPlayer + 10 - wArea;
    setCSSVariable('--wPlayers', minWidth)
  }
}
function adjustTableSize(R) {
  let d = mBy('table');
  let root = R.root;
  let b = getBounds(root.ui, true)
  if (!isdef(root.size)) {
    setSP(root);
  } else {
  }
  d.style.minWidth = root.size.w + 'px';
  d.style.minHeight = (root.size.h + 4) + 'px';
}
function ADMinusKeys(ad1, ad2) {
  let arr1 = ad1;
  let arr2 = ad2;
  if (!Array.isArray(ad1)) {
    console.log('ad1 not an array:', typeof ad1, ad1);
    arr1 = getKeys(ad1);
  }
  if (!Array.isArray(ad2)) {
    console.log('ad2 not an array:', typeof ad2, ad2);
    arr1 = getKeys(ad2);
  }
  return arrMinus(arr1, arr2);
}
function aFlip(d, ms = 300) {
  return anime({ targets: d, scaleX: -1, duration: ms, easing: 'easeInOutSine' });
}
function agCircle(g, sz) { let r = gEllipse(sz, sz); g.appendChild(r); return r; }
function agColoredShape(g, shape, w, h, color) {
  SHAPEFUNCS[shape](g, w, h);
  gBg(g, color);
}
function agEllipse(g, w, h) { let r = gEllipse(w, h); g.appendChild(r); return r; }
function agG(g) { let g1 = gG(); g.appendChild(g1); return g1; }
function aggregate_elements(list_of_object, propname) {
  let result = [];
  for (let i = 0; i < list_of_object.length; i++) {
    let obj = list_of_object[i];
    let arr = obj[propname];
    for (let j = 0; j < arr.length; j++) {
      result.push(arr[j]);
    }
  }
  return result;
}
function aggregate_player(fen, prop) {
  let res = [];
  for (const uplayer in fen.players) {
    let list = fen.players[uplayer][prop];
    res = res.concat(list);
  }
  return res;
}
function aggregate_player_hands_by_rank(fen) {
  let di_ranks = {};
  let akku = [];
  for (const uname in fen.players) {
    let pl = fen.players[uname];
    let hand = pl.hand;
    for (const c of hand) {
      akku.push(c);
      let r = c[0];
      if (isdef(di_ranks[r])) di_ranks[r] += 1; else di_ranks[r] = 1;
    }
  }
  fen.akku = akku;
  return di_ranks;
}
function agHex(g, w, h) { let pts = size2hex(w, h); return agPoly(g, pts); }
function agLine(g, x1, y1, x2, y2) { let r = gLine(x1, y1, x2, y2); g.appendChild(r); return r; }
function agmove_clear_all() { Z.stage = 'clear'; Z.fen.endcond = 'all'; Z.fen.acting_host = Z.uplayer; Z.turn = [Z.uplayer]; take_turn_clear(); }
function agmove_clear_first() { Z.stage = 'clear'; Z.fen.endcond = 'first'; Z.fen.acting_host = Z.uplayer; Z.turn = [Z.uplayer]; take_turn_clear(); }
function agmove_clear_turn() { Z.stage = 'clear'; Z.fen.endcond = 'turn'; Z.fen.acting_host = Z.uplayer; Z.turn = [Z.uplayer]; take_turn_clear(); }
function agmove_indiv(plname, slot) {
  if (isDict(plname) && Z.uplayer != 'mimi') return;
  if (isString(plname)) Z.uplayer = plname;
  console.log('sender:', Z.uplayer);
  let pl = Z.fen.players[Z.uplayer];
  Z.state = { val: pl.hand[0] };
  if (nundef(slot)) slot = busy_wait_until_slot(pl.slot);
  console.log('time sending:', slot, Date.now());
  take_turn_collect_open();
  if (plname != 'felix') agmove_indiv('felix', pl.slot);
}
function agmove_resolve() {
  console.log('---------------------- RESOLVE ----------------------');
  assertion(isdef(Z.playerdata), 'no playerdata');
  assertion(Z.uplayer == Z.fen.acting_host, 'wrong player resolves!!!!', Z.uplayer);
  let [fen, uplayer, pl, pldata] = [Z.fen, Z.uplayer, Z.pl, Z.playerdata];
  fen.collection = [];
  for (const data of pldata) {
    fen.collection.push({ name: data.name, state: data.state });
  }
  console.log('players selected the following cards:', fen.collection);
  [Z.stage, Z.turn] = [Z.fen.stage_after_multi, Z.fen.turn_after_multi];
  take_turn_resolve('single');
}
function agmove_single() {
  if (Z.pl.hand.length > 2) removeInPlace(Z.pl.hand, Z.pl.hand[0]);
  Z.turn = [get_next_player(Z, Z.uplayer)];
  take_turn_fen();
}
function agmove_startmulti() { Z.stage = 'multi'; Z.turn = Z.plorder;[Z.fen.stage_after_multi, Z.fen.turn_after_multi] = ['click', [rChoose(Z.plorder)]]; take_turn_fen(); }
function agPoly(g, pts) { let r = gPoly(pts); g.appendChild(r); return r; }
function agRect(g, w, h) { let r = gRect(w, h); g.appendChild(r); return r; }
function agShape(g, shape, w, h, color, rounding) {
  let sh = gShape(shape, w, h, color, rounding);
  g.appendChild(sh);
  return sh;
}
function agText(g, txt, fg, bg, font) {
  let res = new gText(g);
  res.text({ txt: txt, fill: fg, bgText: bg, font: font });
  return res;
}
function AI(playerToControl) {
  var ctl = playerToControl;
  var State = {
    WAITING: 0,
    FOLLOWING: 1,
    AIMING: 2
  }
  var currentState = State.FOLLOWING;
  function repeat(cb, cbFinal, interval, count) {
    var timeout = function () {
      repeat(cb, cbFinal, interval, count - 1);
    }
    if (count <= 0) {
      cbFinal();
    } else {
      cb();
      setTimeout(function () {
        repeat(cb, cbFinal, interval, count - 1);
      }, interval);
    }
  }
  function aimAndFire() {
    var numRepeats = Math.floor(5 + Math.random() * 5);
    function randomMove() {
      if (Math.random() > .5) {
        ctl.move(-distance);
      } else {
        ctl.move(distance);
      }
    }
    function randomAimAndFire() {
      var d = Math.floor(Math.random() * 3 - 1);
      opponent.setAim(d);
      opponent.fire();
      currentState = State.FOLLOWING;
    }
    repeat(randomMove, randomAimAndFire, 250, numRepeats);
  }
  function moveTowardsBall() {
    if (ball.getPosition()[1] >= ctl.getPosition()[1] + ctl.getSize() / 2) {
      ctl.move(distance);
    } else {
      ctl.move(-distance);
    }
    setTimeout(function () {
      currentState = State.FOLLOWING;
    }, 400);
  }
  function update() {
    switch (currentState) {
      case State.FOLLOWING:
        if (ball.getOwner() === ctl) {
          currentState = State.AIMING;
          aimAndFire();
        } else {
          moveTowardsBall();
          currentState = State.WAITING;
        }
      case State.WAITING:
        break;
      case State.AIMING:
        break;
    }
  }
  return {
    update: update
  }
}
function ai_move(ms = 100) {
  DA.ai_is_moving = true;
  let [A, fen] = [valf(Z.A, {}), Z.fen];
  let selitems;
  if (Z.game == 'ferro') {
    if (Z.stage == 'card_selection') {
      let uplayer = Z.uplayer;
      let i1 = firstCond(A.items, x => x.path.includes(`${uplayer}.hand`));
      let i2 = firstCond(A.items, x => x.key == 'discard');
      selitems = [i1, i2];
    } else if (Z.stage == 'buy_or_pass') {
      selitems = [A.items[1]];
    } else selitems = [A.items[0]];
  } else if (Z.game == 'bluff') {
    let [newbid, handler] = bluff_ai();
    if (newbid) { fen.newbid = newbid; UI.dAnzeige.innerHTML = bid_to_string(newbid); }
    else if (handler != handle_gehtHoch) { bluff_generate_random_bid(); }
    A.callback = handler;
    selitems = [];
  } else if (A.command == 'trade') {
    selitems = ai_pick_legal_trade();
  } else if (A.command == 'exchange') {
    selitems = ai_pick_legal_exchange();
  } else if (A.command == 'upgrade') {
    selitems = [rChoose(A.items)];
  } else if (A.command == 'rumor') {
    selitems = [];
    let buildings = A.items.filter(x => x.path.includes('building'));
    let rumors = A.items.filter(x => !x.path.includes('building'));
    selitems = [rChoose(buildings), rChoose(rumors)];
  } else if (ARI.stage[Z.stage] == 'rumors_weitergeben') {
    let players = A.items.filter(x => Z.plorder.includes(x.key))
    let rumors = A.items.filter(x => !Z.plorder.includes(x.key))
    selitems = [rChoose(players), rChoose(rumors)];
  } else if (ARI.stage[Z.stage] == 'journey') {
    selitems = [];
  } else {
    let items = A.items;
    let nmin = A.minselected;
    let nmax = Math.min(A.maxselected, items.length);
    let nselect = rNumber(nmin, nmax);
    selitems = rChoose(items, nselect); if (!isList(selitems)) selitems = [selitems];
  }
  for (const item of selitems) {
    select_last(item, select_toggle);
    if (isdef(item.submit_on_click)) A.selected.pop();
  }
  clearTimeout(TO.ai);
  loader_on();
  TO.ai = setTimeout(() => { if (isdef(A.callback)) A.callback(); loader_off(); }, ms);
}
function ai_pick_legal_exchange() {
  let [A, fen, uplayer, items] = [Z.A, Z.fen, Z.uplayer, Z.A.items];
  let firstPick = rChoose(items, 1, x => x.path.includes('building'));
  let secondPick = rChoose(items, 1, x => !x.path.includes('building'));
  return [firstPick, secondPick];
}
function ai_pick_legal_trade() {
  let [A, fen, uplayer, items] = [Z.A, Z.fen, Z.uplayer, Z.A.items];
  let stall = fen.players[uplayer].stall;
  let firstPick = rChoose(items, 1, x => x.path.includes(uplayer));
  let secondPick = rChoose(items, 1, x => !x.path.includes(uplayer));
  return [firstPick, secondPick];
}
function ai_schummler() { }
function AIMinimax(g, callback) {
  let state = g.getState();
  state = boardToNode(state);
  F_END = g.evalState;
  F_HEURISTIC = g.heuristic;
  F_MOVES = g.getAvailableMoves;
  F_APPLYMOVE = g.applyMove;
  F_UNDOMOVE = g.undoMove;
  MAXIMIZER = g.plTurn;
  MINIMIZER = g.plOpp;
  SelectedMove = null;
  let algorithm = g.copyState == true ? minimaxCopy : myMinimax;
  let val = algorithm(state, 0, -Infinity, Infinity, g.searchDepth, true);
  CCC = 0;
  callback(SelectedMove);
}
async function ajaxPostCors(url, data, type, handle_result) {
  data.data_type = type;
  var formData = new FormData();
  for (const k in data) {
    formData.append(k, data[k]);
  }
  let h = new Headers();
  h.append('Accept', 'application/text');
  var resp = await fetch(url, {
    method: 'POST',
    mode: 'cors',
    headers: h,
    body: formData,
  });
  let result = await resp.text();
  try {
    let jsonResult = JSON.parse(result);
    if (isdef(handle_result)) handle_result(jsonResult);
  } catch {
    if (isdef(handle_result)) handle_result({ message: result });
  }
}
function ajaxSimple(method, url, callback) {
  var ajax = new XMLHttpRequest();
  ajax.onload = () => {
    if (ajax.status == 200 || ajax.readyState == 4) {
      if (isdef(callback)) callback(ajax);
    }
  }
  ajax.open(method, url, true);
  ajax.send();
}
function aJumpby(elem, h = 40, ms = 1000) {
  anime({
    targets: elem,
    keyframes: [
      { translateY: 2, scaleX: 1.05, scaleY: .95 },
      { translateY: 2, scaleX: 1.05, scaleY: .95 },
      { translateY: -h, scaleX: .9, scaleY: 1.1 },
      { translateY: -h, scaleX: .9, scaleY: 1.1 },
      { translateY: 0, scaleX: 1, scaleY: 1 },
      { translateY: -7, scaleX: 1, scaleY: 1 },
      { translateY: 0, scaleX: 1, scaleY: 1 },
      { translateY: 0, scaleX: 1, scaleY: 1 },
      { translateY: 0, scaleX: 1, scaleY: 1 },
      { translateY: 0, scaleX: 1, scaleY: 1 },
    ],
    duration: 1000,
    easing: 'easeInOutSine', //'easeOutElastic(1, .8)',
  });
}
function all2DigitFractions() {
  let fr = {
    1: [2, 3, 4, 5, 6, 7, 8, 9],
    2: [3, 5, 7, 9],
    3: [2, 4, 5, 7, 8],
    4: [3, 5, 7, 9],
    5: [2, 3, 4, 6, 7, 8, 9],
    6: [5, 7],
    7: [2, 3, 4, 5, 6, 8, 9],
    8: [3, 5, 7, 9],
    9: [2, 4, 5, 7, 8],
  };
  return fr;
}
function all2DigitFractionsExpanded() {
  let f = all2DigitFractions();
  let res = [];
  for (const i in f) {
    for (const j of f[i]) {
      res.push({ numer: i, denom: j });
    }
  }
  return res;
}
function all2DigitFractionsUnder1() {
  let fr = {
    1: [2, 3, 4, 5, 6, 7, 8, 9],
    2: [3, 5, 7, 9],
    3: [4, 5, 7, 8],
    4: [5, 7, 9],
    5: [6, 7, 8, 9],
    6: [7],
    7: [8, 9],
    8: [9],
  };
  return fr;
}
function all2DigitFractionsUnder1Expanded() {
  let f = all2DigitFractionsUnder1();
  let res = [];
  for (const i in f) {
    for (const j of f[i]) {
      res.push({ numer: i, denom: j });
    }
  }
  return res;
}
function allCond(arr, cond) { return forAll(arr, cond); }
function allCondDict(d, func) {
  let res = [];
  for (const k in d) { if (func(d[k])) res.push(k); }
  return res;
}
function allCondDictKV(d, func) {
  let res = [];
  for (const k in d) { if (func(k, d[k])) res.push(k); }
  return res;
}
function allCondX(ad, func) {
  let res = [];
  if (nundef(ad)) return res;
  else if (isDict(ad)) {
    for (const k in ad) {
      let v = ad[k];
      if (func(v)) { if (nundef(v.key)) v.key = k; res.push(v); }
    }
  } else {
    for (const a of ad) { if (func(a)) res.push(a) }
  }
  return res;
}
function allElementsFromPoint(x, y) {
  var element, elements = [];
  var old_visibility = [];
  while (true) {
    element = document.elementFromPoint(x, y);
    if (!element || element === document.documentElement) {
      break;
    }
    elements.push(element);
    old_visibility.push(element.style.visibility);
    element.style.visibility = 'hidden';
  }
  for (var k = 0; k < elements.length; k++) {
    elements[k].style.visibility = old_visibility[k];
  }
  elements.reverse();
  return elements;
}
function allIntegers(s) {
  return s.match(/\d+\.\d+|\d+\b|\d+(?=\w)/g).map(v => {
    return +v;
  });
}
function allLettersContained(sFull, sPart) {
  for (const ch of sPart) {
    if (!(sFull.includes(ch))) return false;
  }
  return true;
}
function allNumbers(s) {
  let m = s.match(/\-.\d+|\-\d+|\.\d+|\d+\.\d+|\d+\b|\d+(?=\w)/g);
  if (m) return m.map(v => +v); else return null;
}
function allNumbers_dep(s) {
  return s.match(/\d+\.\d+|\d+\b|\d+(?=\w)/g).map(v => {
    return +v;
  });
}
function allow_polling() { IS_POLLING_ALLOWED = true; if (isdef(DA.poll)) poll(); }
function allowDrop(ev) { ev.preventDefault(); }
function allowDropKey(ev) {
  ev.stopPropagation();
  let dragged = ev.toElement;
  let target = ev.target;
  if (nundef(key) || key == ev.target.dd) {
    ev.preventDefault();
    console.log(ev, '\nkey:', key, dragged.id, dragged.dd, target.dd)
  }
}
function allWordsAndKeysLowerCase() {
  let newSyms = {};
  for (const k in Syms) {
    let info = Syms[k];
    let inew = jsCopy(info);
    for (const x of ['E', 'D', 'F', 'S']) {
      if (isdef(info[x])) {
        console.log(info[x])
        inew[x] = info[x].toLowerCase();
      }
    }
    newSyms[k.toLowerCase()] = inew;
  }
  downloadAsYaml(newSyms, 'syms1');
}
function allWordsContainedInKeys(dict, keywords) {
  let res = [];
  for (const k in dict) {
    let isMatch = true;
    for (const w of keywords) {
      if (!k.includes(w)) { isMatch = false; break; }
    }
    if (isMatch) res.push(dict[k]);
  }
  return res;
}
function allWordsContainedInKeysAsWord(dict, keywords) {
  let res = [];
  for (const k in dict) {
    let isMatch = true;
    let wordsInKey = splitAtWhiteSpace(k);
    for (const w of keywords) {
      if (!wordsInKey.includes(w)) { isMatch = false; break; }
    }
    if (isMatch) res.push(dict[k]);
  }
  return res;
}
function allWordsContainedInProps(dict, keywords, props) {
  let res = [];
  for (const k in dict) {
    let isMatch = true;
    let propString = '';
    for (const p of props) {
      propString += dict[k][p] + ' ';
    }
    for (const w of keywords) {
      if (!propString.includes(w)) { isMatch = false; break; }
    }
    if (isMatch) {
      res.push(dict[k]);
    }
  }
  return res;
}
function allWordsContainedInPropsAsWord(dict, keywords, props) {
  let res = [];
  for (const k in dict) {
    let isMatch = true;
    let keywordList = [];
    for (const p of props) {
      if (nundef(dict[k][p])) continue;
      let wordsInKey = splitAtWhiteSpace(dict[k][p]);
      keywordList = keywordList.concat(wordsInKey);
    }
    for (const w of keywords) {
      if (!keywordList.includes(w)) { isMatch = false; break; }
    }
    if (isMatch) res.push(dict[k]);
  }
  return res;
}
function AlphaBeta(alpha, beta, depth, DoNull) {
  if (depth <= 0) {
    return Quiescence(alpha, beta);
  }
  if ((srch_nodes & 2047) == 0) CheckUp();
  srch_nodes++;
  if ((IsRepetition() || brd_fiftyMove >= 100) && brd_ply != 0) {
    return 0;
  }
  if (brd_ply > MAXDEPTH - 1) {
    return EvalPosition(pos);
  }
  var InCheck = SqAttacked(brd_pList[PCEINDEX(Kings[brd_side], 0)], brd_side ^ 1);
  if (InCheck == BOOL.TRUE) {
    depth++;
  }
  var Score = -INFINITE;
  if (DoNull == BOOL.TRUE && BOOL.FALSE == InCheck &&
    brd_ply != 0 && (brd_material[brd_side] > 50200) && depth >= 4) {
    var ePStore = brd_enPas;
    if (brd_enPas != SQUARES.NO_SQ) HASH_EP();
    brd_side ^= 1;
    HASH_SIDE();
    brd_enPas = SQUARES.NO_SQ;
    Score = -AlphaBeta(-beta, -beta + 1, depth - 4, BOOL.FALSE);
    brd_side ^= 1;
    HASH_SIDE();
    brd_enPas = ePStore;
    if (brd_enPas != SQUARES.NO_SQ) HASH_EP();
    if (srch_stop == BOOL.TRUE) return 0;
    if (Score >= beta) {
      return beta;
    }
  }
  GenerateMoves();
  var MoveNum = 0;
  var Legal = 0;
  var OldAlpha = alpha;
  var BestMove = NOMOVE;
  Score = -INFINITE;
  var PvMove = ProbePvTable();
  if (PvMove != NOMOVE) {
    for (MoveNum = brd_moveListStart[brd_ply]; MoveNum < brd_moveListStart[brd_ply + 1]; ++MoveNum) {
      if (brd_moveList[MoveNum] == PvMove) {
        brd_moveScores[MoveNum].score = 2000000;
        break;
      }
    }
  }
  for (MoveNum = brd_moveListStart[brd_ply]; MoveNum < brd_moveListStart[brd_ply + 1]; ++MoveNum) {
    PickNextMove(MoveNum);
    if (MakeMove(brd_moveList[MoveNum]) == BOOL.FALSE) {
      continue;
    }
    Legal++;
    Score = -AlphaBeta(-beta, -alpha, depth - 1, BOOL.TRUE);
    TakeMove();
    if (srch_stop == BOOL.TRUE) return 0;
    if (Score > alpha) {
      if (Score >= beta) {
        if (Legal == 1) {
          srch_fhf++;
        }
        srch_fh++;
        if ((brd_moveList[MoveNum] & MFLAGCAP) == 0) {
          brd_searchKillers[MAXDEPTH + brd_ply] = brd_searchKillers[brd_ply];
          brd_searchKillers[brd_ply] = brd_moveList[MoveNum];
        }
        return beta;
      }
      alpha = Score;
      BestMove = brd_moveList[MoveNum];
      if ((BestMove & MFLAGCAP) == 0) {
        brd_searchHistory[brd_pieces[FROMSQ(BestMove)] * BRD_SQ_NUM + TOSQ(BestMove)] += depth;
      }
    }
  }
  if (Legal == 0) {
    if (InCheck) {
      return -MATE + brd_ply;
    } else {
      return 0;
    }
  }
  if (alpha != OldAlpha) {
    StorePvMove(BestMove);
  }
  return alpha;
}
function alphaToHex(zero1) {
  zero1 = Math.round(zero1 * 100) / 100;
  var alpha = Math.round(zero1 * 255);
  var hex = (alpha + 0x10000)
    .toString(16)
    .slice(-2)
    .toUpperCase();
  var perc = Math.round(zero1 * 100);
  return hex;
}
function aMove(d, dSource, dTarget, callback, offset, ms, easing, fade) {
  let b1 = getRect(dSource);
  let b2 = getRect(dTarget);
  if (nundef(offset)) offset = { x: 0, y: 0 };
  let dist = { x: b2.x - b1.x + offset.x, y: b2.y - b1.y + offset.y };
  d.style.zIndex = 100;
  let a = d.animate({ opacity: valf(fade, 1), transform: `translate(${dist.x}px,${dist.y}px)` }, { easing: valf(easing, 'EASE'), duration: ms });
  a.onfinish = () => { d.style.zIndex = iZMax(); if (isdef(callback)) callback(); };
}
function aMoveTo(d, dTarget, x, y, ms) {
  let bi = iTableBounds(d);
  let b1 = iTableBounds(d.parentNode);
  let b2 = iTableBounds(dTarget);
  d.animate([
    { position: 'absolute', left: `${bi.x}px`, top: `${bi.y}px` },
    { position: 'absolute', left: `${x + b2.x}px`, top: `${y + b2.y}px` },
  ], {
    duration: ms,
    fill: 'forwards'
  });
}
function analyse_tables(user_tables) {
  user_tables.map(x => console.log('table:', x));
  let bygame = {}, bytid = {};
  for (const t of user_tables) {
    lookupAddToList(bygame, [t.game], t);
    lookupSet(bytid, [t.id], t);
  }
  if (!isEmpty(user_tables)) {
    Session.cur_table = user_tables[0];
    Session.cur_tid = Session.cur_table.id;
  } else {
    Session.cur_table = null;
    Session.cur_tid = undefined;
  }
  lookupSetOverride(DA, [Session.cur_user, 'tables_by_game'], bygame);
  lookupSetOverride(DA, [Session.cur_user, 'tables_by_tid'], bytid);
  return bygame;
}
function ani_say(d, fSpeak) {
  if (isdef(fSpeak)) fSpeak();
  mClass(d, 'onPulse');
  setTimeout(() => mRemoveClass(d, 'onPulse'), 500);
}
function aniFadeIn(elem, secs) {
  elem.style.opacity = 0;
  setTimeout(() => { mRemoveClass(elem, 'transopaOff'); mClass(elem, 'transopaOn'); }, secs * 1000);
}
function aniFadeInOut(elem, secs) {
  mClass(elem, 'transopaOn');
  setTimeout(() => { mRemoveClass(elem, 'transopaOn'); mClass(elem, 'transopaOff'); }, secs * 1000);
}
function aniFadeInOut_new(elem, msDuration) {
  elem.animate()
  mClass(elem, 'transopaOn');
  return setTimeout(() => { mRemoveClass(elem, 'transopaOn'); mClass(elem, 'transopaOff'); }, secs * 1000);
}
function aniGameOver(msg, silent = false) {
  if (!silent && !G.silentMode) { writeSound(); playSound('goodBye'); }
  interrupt();
  show('freezer2');
  let dComment = mBy('dCommentFreezer2');
  let dMessage = mBy('dMessageFreezer2');
  let d = mBy('dContentFreezer2');
  clearElement(d);
  mStyleX(d, { fz: 20, matop: 40, bg: 'silver', fg: 'indigo', rounding: 20, padding: 25 })
  let style = { matop: 4 };
  dComment.innerHTML = 'Great Job!';
  dMessage.innerHTML = isdef(msg) ? msg : 'Time for a Break...';
  d.style.textAlign = 'center';
  mText('Unit Score:', d, { fz: 22 });
  for (const gname in U.session) {
    let sc = U.session[gname];
    if (sc.nTotal == 0) continue;
    if (DB.games[gname].controllerType == 'solitaire') mText(`${DB.games[gname].friendly}: ${sc.nCorrect}/${sc.nTotal} correct answers (${sc.percentage}%) `, d, style);
    else if (DB.games[gname].controllerType == 'solo') {
      mText(`${DB.games[gname].friendly}: Won:${sc.nWins}, Lost:${sc.nLoses}, Tied:${sc.nTied} `, d, style);
    }
  }
  mClass(mBy('freezer2'), 'aniSlowlyAppear');
}
function aniInstruction(spoken) {
  if (isdef(spoken)) sayRandomVoice(spoken);
  mClass(dInstruction, 'onPulse');
  setTimeout(() => mRemoveClass(dInstruction, 'onPulse'), 500);
}
function anim_face_down(item, ms = 300, callback = null) { face_up(item); anim_toggle_face(item, callback); }
function anim_face_up(item, ms = 300, callback = null) { face_down(item); anim_toggle_face(item, callback); }
function anim_from_deck_to_hand(el, deck, hand) {
  let topmost = deck.items.shift();
  console.assert(el == topmost, 'top deck elem is NOT correct!!!!')
  face_up(topmost);
  let dfrom = iDiv(topmost);
  deck.list = deck.items.map(x => x.key);
  deck.topmost = deck.items[0];
  let dto = iDiv(arrLast(hand.items));
  let rfrom = getRect(dfrom, mBy('inner_left_panel'));
  let rto = getRect(dto, mBy('inner_left_panel'));
  dfrom.style.xIndex = 100;
  let [offx, offy] = [OVW, 0]
  let a = aTranslateByEase(dfrom, offx + rto.l - rfrom.l, offy + rto.t - rfrom.t, 500, 'ease');
  a.onfinish = () => {
    dfrom.remove();
    dfrom.style.position = 'static';
    hand.items.push(topmost);
    hand.list = hand.items.map(x => x.key);
    mAppend(hand.container, dfrom);
    mContainerSplay(hand.container, 2, CWIDTH, CHEIGHT, hand.list.length, OVW);
    mItemSplay(topmost, hand.list, 2, OVW);
  };
}
function anim_from_deck_to_handX(el, deck, hand) {
  anim_turn_top_card(el, () => anim_move_top_card(el, deck, hand));
}
function anim_from_deck_to_marketX(deck, market) {
  anim_turn_top_cardX(deck, () => anim_move_top_card_marketX(deck, market));
}
function anim_from_deck_to_marketX_orig(el, deck, market) {
  anim_turn_top_card(el, () => anim_move_top_card_market(el, deck, market));
}
function anim_move_top_card(el, deck, hand) {
  let topmost = deck.items.shift();
  console.assert(el == topmost, 'top deck elem is NOT correct!!!!')
  let dfrom = iDiv(topmost);
  deck.list = deck.items.map(x => x.key);
  deck.topmost = deck.items[0];
  let dto = iDiv(arrLast(hand.items));
  let rfrom = getRect(dfrom, mBy('inner_left_panel'));
  let rto = getRect(dto, mBy('inner_left_panel'));
  dfrom.style.xIndex = 100;
  let [offx, offy] = [OVW, 0]
  let a = aTranslateByEase(dfrom, offx + rto.l - rfrom.l, offy + rto.t - rfrom.t, 500, 'ease');
  a.onfinish = () => {
    dfrom.remove();
    dfrom.style.position = 'static';
    hand.items.push(topmost);
    hand.list = hand.items.map(x => x.key);
    mAppend(hand.container, dfrom);
    mContainerSplay(hand.container, 2, CWIDTH, CHEIGHT, hand.list.length, OVW);
    mItemSplay(topmost, hand.list, 2, OVW);
    qanim();
  };
}
function anim_move_top_card_market(deck, market) {
  let topmost = deck.items.shift();
  let dfrom = iDiv(topmost);
  deck.list = deck.items.map(x => x.key);
  deck.topmost = deck.items[0];
  let dto = isEmpty(market.items) ? market.container : iDiv(arrLast(market.items));
  let rfrom = getRect(dfrom, mBy('inner_left_panel'));
  let rto = getRect(dto, mBy('inner_left_panel'));
  dfrom.style.xIndex = 100;
  let [offx, offy] = isEmpty(market.items) ? [4, 4] : [topmost.w, 0];
  let a = aTranslateByEase(dfrom, offx + rto.l - rfrom.l, offy + rto.t - rfrom.t, 500, 'ease');
  a.onfinish = () => {
    dfrom.remove();
    dfrom.style.position = 'static';
    dfrom.style.zIndex = 0;
    market.items.push(topmost);
    market.list = market.items.map(x => x.key);
    mAppend(market.container, dfrom);
    qanim();
  };
}
function anim_move_top_card_marketX(deck, market) {
  let topmost = deck.items.shift();
  let dfrom = iDiv(topmost);
  deck.list = deck.items.map(x => x.key);
  deck.topmost = deck.items[0];
  let dto = isEmpty(market.items) ? market.container : iDiv(arrLast(market.items));
  let rfrom = getRect(dfrom, mBy('inner_left_panel'));
  let rto = getRect(dto, mBy('inner_left_panel'));
  dfrom.style.xIndex = 100;
  let [offx, offy] = isEmpty(market.items) ? [4, 4] : [topmost.w, 0];
  let a = aTranslateByEase(dfrom, offx + rto.l - rfrom.l, offy + rto.t - rfrom.t, 500, 'ease');
  a.onfinish = () => {
    dfrom.remove();
    dfrom.style.position = 'static';
    dfrom.style.zIndex = 0;
    market.items.push(topmost);
    market.list = market.items.map(x => x.key);
    mAppend(market.container, dfrom);
    qanim();
  };
}
function anim_move_top_cardX(deck, hand) {
  let topmost = deck.items.shift();
  let dfrom = iDiv(topmost);
  deck.list = deck.items.map(x => x.key);
  deck.topmost = deck.items[0];
  let dto = iDiv(arrLast(hand.items));
  let rfrom = getRect(dfrom, mBy('inner_left_panel'));
  let rto = getRect(dto, mBy('inner_left_panel'));
  dfrom.style.xIndex = 100;
  let [offx, offy] = [OVW, 0]
  let a = aTranslateByEase(dfrom, offx + rto.l - rfrom.l, offy + rto.t - rfrom.t, 500, 'ease');
  a.onfinish = () => {
    dfrom.remove();
    dfrom.style.position = 'static';
    hand.items.push(topmost);
    hand.list = hand.items.map(x => x.key);
    mAppend(hand.container, dfrom);
    mContainerSplay(hand.container, 2, CWIDTH, CHEIGHT, hand.list.length, OVW);
    mItemSplay(topmost, hand.list, 2, OVW);
    qanim();
  };
}
function anim_toggle_face(item, ms = 300, callback = null) {
  let d = iDiv(item);
  mClass(d, 'aniflip');
  TO.anim = setTimeout(() => {
    if (item.faceUp) face_down(item); else face_up(item); mClassRemove(d, 'aniflip');
    if (isdef(callback)) callback();
  }, ms);
}
function anim_toggle_face_orig(item, callback) {
  let d = iDiv(item);
  mClass(d, 'aniflip');
  TO.anim = setTimeout(() => {
    if (item.faceUp) face_down(item); else face_up(item); mClassRemove(d, 'aniflip');
    if (isdef(callback)) callback();
  }, 300);
}
function anim_turn_top_card(el, callback) {
  anim_toggle_face(el, callback);
}
function anim_turn_top_cardX(deck, callback) { anim_toggle_face(deck.topmost, callback); }
function anim1(elem, prop, from, to, ms) {
  if (prop == 'left') elem.style.position = 'absolute';
  if (isNumber(from)) from = '' + from + 'px';
  if (isNumber(to)) to = '' + to + 'px';
}
function animate(elem, aniclass, timeoutms) {
  mClass(elem, aniclass);
  TOMan.TO.anim = setTimeout(() => mRemoveClass(elem, aniclass), timeoutms);
}
function animate_card_approx(card, goal, ms, callback) {
  let d = iDiv(card);
  let dgoal = iDiv(goal);
  let r = getRect(d);
  let rgoal = getRect(dgoal);
  let c = { x: r.x + r.w / 2, y: r.y + r.h / 2 };
  let cgoal = { x: rgoal.x + rgoal.w / 2, y: rgoal.y + rgoal.h / 2 };
  let v = { x: cgoal.x - c.x, y: cgoal.y - c.y };
  mAnimateList(d, { transform: `translateX(${v.x}px) translateY(${v.y}px)`, opacity: 0 }, callback, ms, 'linear');
}
function animate_card_exchange(i0, i1, callback) {
  ari_make_unselectable(i0);
  ari_make_unselectable(i1);
  let d0 = iDiv(i0.o);
  let d1 = iDiv(i1.o);
  let r0 = getRect(d0);
  let r1 = getRect(d1);
  let c0 = { x: r0.x + r0.w / 2, y: r0.y + r0.h / 2 };
  let c1 = { x: r1.x + r1.w / 2, y: r1.y + r1.h / 2 };
  let v = { x: c1.x - c0.x, y: c1.y - c0.y };
  mTranslateBy(d0, v.x, v.y);
  mTranslateBy(d1, -v.x, -v.y, 700, callback);
}
function animate_card_transfer(card, goal, callback) {
  let d = iDiv(card);
  let dgoal = iDiv(goal);
  let r = getRect(d);
  let rgoal = getRect(dgoal);
  let c = { x: r.x + r.w / 2, y: r.y + r.h / 2 };
  let cgoal = { x: rgoal.x + rgoal.w / 2, y: rgoal.y + rgoal.h / 2 };
  let v = { x: cgoal.x - c.x, y: cgoal.y - c.y };
  mTranslateBy(d, v.x, v.y, 700, callback);
}
function animate_title() {
  var rev = "fwd";
  function titlebar(val) {
    var msg = "Hallodi!";
    var res = " ";
    var speed = 100;
    var pos = val;
    msg = "   |-" + msg + "-|";
    var le = msg.length;
    if (rev == "fwd") {
      if (pos < le) {
        pos = pos + 1;
        scroll = msg.substr(0, pos);
        document.title = scroll;
        timer = window.setTimeout("titlebar(" + pos + ")", speed);
      }
      else {
        rev = "bwd";
        timer = window.setTimeout("titlebar(" + pos + ")", speed);
      }
    }
    else {
      if (pos > 0) {
        pos = pos - 1;
        var ale = le - pos;
        scrol = msg.substr(ale, le);
        document.title = scrol;
        timer = window.setTimeout("titlebar(" + pos + ")", speed);
      }
      else {
        rev = "fwd";
        timer = window.setTimeout("titlebar(" + pos + ")", speed);
      }
    }
  }
  titlebar(0);
}
function animateColor(elem, from, to, classes, ms) {
  elem.style.backgroundColor = from;
  setTimeout(() => animate(elem, classes, ms), 10);
}
function animateColorScale(elem, color = 'green', scale = 1.5, timeoutms = 2000, aniClass = 'scaleInColor') {
  setCSSVariable('--aniColor', color);
  setCSSVariable('--aniScale', scale);
  mClass(elem, aniClass);
  setTimeout(() => mRemoveClass(elem, aniClass), timeoutms);
}
function animatedTitle(msg = 'DU BIST DRAN!!!!!') {
  TO.titleInterval = setInterval(() => {
    let corner = CORNERS[WhichCorner++ % CORNERS.length];
    document.title = `${corner} ${msg}`; //'⌞&amp;21543;    U+231E \0xE2Fo\u0027o Bar';
  }, 1000);
}
function animateProperty(elem, prop, start, middle, end, msDuration, forwards) {
  let kflist = [];
  for (const v of [start, middle, end]) {
    let o = {};
    o[prop] = isString(v) || prop == 'opacity' ? v : '' + v + 'px';
    kflist.push(o);
  }
  let opts = { duration: msDuration };
  if (isdef(forwards)) opts.fill = forwards;
  elem.animate(kflist, opts);
}
function animatePropertyX(elem, prop, start_middle_end, msDuration, forwards, easing, delay) {
  let kflist = [];
  for (const perc in start_middle_end) {
    let o = {};
    let val = start_middle_end[perc];
    o[prop] = isString(val) || prop == 'opacity' ? val : '' + val + 'px';
    kflist.push(o);
  }
  let opts = { duration: msDuration, fill: valf(forwards, 'none'), easing: valf(easing, 'ease-it-out'), delay: valf(delay, 0) };
  elem.animate(kflist, opts);
}
function animateStyles(d, styles1, styles2, ms) {
  d.style.transition = `${ms}ms`;
  mStyle(d, styles2);
}
function Animation(spriteSheet, imgWidth, imgHeight, cellWidth, cellHeight) {
  this.sheet = spriteSheet;
  this.imgWidth = imgWidth;
  this.imgHeight = imgHeight;
  this.cellWidth = cellWidth;
  this.cellHeight = cellHeight;
  this.animationLength = 1000;
  this.changeLength = false;
  this.cycles = new Array();
  this.currentCycleName = "";
  this.currentCycle = null;
  this.cyclePlaySettings = new Array(PLAY_LOOP, PLAY_LOOP, PLAY_LOOP, PLAY_LOOP);
  this.changeAnimation = false;
  this.timer = new Timer();
  this.framesPerRow = 0;
  this.framesPerColumn = 0;
  this.totalCycleTime = 0;
  this.fps = 0;
  this.isPaused = false;
  this.setup = function () {
    this.timer.start();
    this.framesPerRow = this.imgWidth / this.cellWidth;
    this.framesPerColumn = this.imgHeight / this.cellHeight;
  }
  this.addCycle = function (cycleName, startingCell, frames) {
    cycle = new Array(cycleName, startingCell, frames);
    this.cycles.push(cycle);
  }
  this.drawFrame = function (ctx) {
    this.fps += 1;
    if (!this.isPaused) { this.totalCycleTime += this.timer.getTimeElapsed(); }
    if (this.changeAnimation == true) {
      for (i = 0; i < this.cycles.length; i++) {
        if (this.cycles[i][0] == this.currentCycleName) {
          this.currentCycle = this.cycles[i];
        }
      }
    }
    if (this.changeAnimation || this.changeLength) {
      this.frameDelta = this.animationLength / this.currentCycle[2];
      this.changeAnimation = false;
      this.changeLength = false;
      this.fps = 0;
    }
    currentFrame = Math.floor((this.totalCycleTime % this.animationLength) / this.frameDelta);
    document.getElementById("FPS").innerHTML = this.animationLength;
    row = Math.floor((this.currentCycle[1] + currentFrame) / this.framesPerRow);
    col = (this.currentCycle[1] + currentFrame) - (row * Math.floor(this.imgWidth / this.cellWidth));
    frameY = row * this.cellHeight;
    frameX = col * this.cellWidth;
    ctx.drawImage(this.sheet, frameX, frameY, this.cellWidth, this.cellHeight, 0 - (this.cellWidth / 2), 0 - (this.cellHeight / 2), this.cellWidth, this.cellHeight);
  }
  this.setCycle = function (cycleName) {
    this.currentCycleName = cycleName;
    this.changeAnimation = true;
    this.totalCycleTime = 0;
  }
  this.renameCycles = function (cycleNames) {
    for (i = 0; i < cycleNames.length; i++) {
      number = parseInt(this.cycles[i][0].slice(5));
      if (this.currentCycleName == this.cycles[i][0]) { this.currentCycleName = cycleNames[number - 1]; }
      this.cycles[i][0] = cycleNames[number - 1];
    }
  }
  this.play = function () {
    this.isPaused = false;
    this.timer.reset();
  }
  this.pause = function () {
    this.isPaused = true;
  }
  this.reset = function () {
    this.totalCycleTime = 0;
    this.timer.reset();
  }
  this.setAnimationSpeed = function (animLength) {
    if (animLength <= 50) { animLength = 50; }
    this.animationLength = animLength;
    this.changeLength = true;
  }
}
function animationCallback(secs, callback, removeBg = false) {
  for (const p of Pictures) { slowlyTurnFaceDown(p, secs - 1, removeBg); }
  TOMain = setTimeout(() => {
    callback();
  }, secs * 1000);
}
function animbuilding(ui_building, ms = 800, callback = null) {
  let d = ui_building.cardcontainer;
  let ani = [{ transform: 'scale(1)' }, { transform: 'scale(1.5)' }, { transform: 'scale(1)' }];
  let options = {
    duration: ms,
    iterations: 1,
    easing: 'ease-out',
  };
  let a = d.animate(ani, options);
  a.onfinish = callback;
}
function animcoin(plname, ms = 800, callback = null) {
  let d = UI.player_stat_items[plname].dCoin;
  let ani = [{ transform: 'scale(1)' }, { transform: 'scale(3)' }, { transform: 'scale(1)' }];
  let options = {
    duration: ms,
    iterations: 1,
    easing: 'ease-out',
  };
  let a = d.animate(ani, options);
  a.onfinish = () => {
    let uplayer = Z.uplayer;
    let dAmount = UI.player_stat_items[uplayer].dAmount;
    dAmount.innerHTML = Z.fen.players[uplayer].coins;
    mStyle(dAmount, { fg: 'red' });
    if (callback) callback();
  };
}
function animtest(d, ms = 1000, callback) {
  let spinAway = [
    { transform: 'rotate(0) scale(1)' },
    { transform: 'rotate(360deg) scale(0)' }
  ];
  spinAway = [
    { transform: 'rotate(0) scale(1)' },
    { transform: 'rotate(180deg) scale(0)' },
    { transform: 'rotate(360deg) scale(2)' }
  ];
  spinAway = [
    { transform: 'scale(1)' },
    { transform: 'scale(3)' },
    { transform: 'scale(1)' }
  ];
  let options = {
    duration: ms,
    iterations: 1,
    easing: 'ease-out', //'cubic-bezier(.24,.65,.78,.03)',
    //easing: 'cubic-bezier(.89,.31,.67,1.05)', // 'cubic-bezier(.55,.22,.52,.98)' //'cubic-bezier(1,-0.03,.86,.68)'
  }
  d.addEventListener('click', (ev) => {
    evNoBubble(ev);
    let a = d.animate(spinAway, options);
    a.onfinish = callback;
  });
}
function aniPulse(elem, ms) { animate(elem, 'onPulse', ms); }
function anipulse(d, ms = 3000, callback) {
  let a = d.animate(
    [{
      'background-color': '#2ba805',
      'box-shadow': '0 0 3px #2ba805'
    },
    {
      'background-color': `#49e819`,
      'box-shadow': `0 0 10px #49e819`,
    },
    {
      'background-color': `#2ba805`,
      'box-shadow': `0 0 3px #2ba805`
    }], { fill: 'both', duration: ms, easing: 'ease', delay: 1000 });
  a.onfinish = callback;
  return a;
}
function aniSequence() {
}
function aniSuper(elem, name, duration, easing, delay, iterations, direction, before_after, playstate) {
}
function annotate(sp) {
  for (const k in sp) {
    let node = sp[k];
    node.pool = [];
    let pool = makePool(node);
    for (const oid in pool) {
      let o = pool[oid];
      if (!evalCond(o, node)) continue;
      if (nundef(o.RSG)) o.RSG = {};
      let rsg = o.RSG;
      rsg[k] = true;
      node.pool.push(oid);
    }
  }
}
function any(arr, cond) {
  return !isEmpty(arr.filter(cond));
}
function anyStartsWith(arr, prefix) {
  return any(arr, el => startsWith(el, prefix));
}
function anyString(x, indent = 0, ifDict = 'entries') {
  if (isLiteral(x)) return x;
  else if (isListOfLiterals(x)) return x.join(' ');
  else if (isEmpty(x)) return x;
  else if (isList(x)) { return x.map(el => anyString(el, indent + 1, ifDict)).join(' '); }
  else if (isDict(x)) {
    let s = '';
    for (const k in x) { s += '\n' + ' '.repeat(indent) + k + ': ' + anyString(x[k], indent + 1, ifDict); }
    return s;
  }
}
function anyString2(x, indent = 0, proplist, include = true, toplevelOnly = false) {
  if (isLiteral(x)) return x;
  else if (isListOfLiterals(x)) return x.join(' ');
  else if (isEmpty(x)) return x;
  else if (isList(x)) {
    if (toplevelOnly) proplist = null;
    return x.map(el => anyString2(el, indent + 1, proplist, include)).join(' ');
  }
  else if (isDict(x)) {
    let plist = proplist;
    if (toplevelOnly) proplist = null;
    let s = '';
    if (isdef(plist)) {
      if (include) {
        for (const k of plist) {
          if (nundef(x[k])) { console.log('continue', x, k); continue; }
          s += '\n' + ' '.repeat(indent) + k + ': ' + anyString2(x[k], indent + 1, proplist, include);
        }
      } else {
        for (const k of plist) {
          if (isdef(x[k])) continue;
          s += '\n' + ' '.repeat(indent) + k + ': ' + anyString2(x[k], indent + 1, proplist, include);
        }
      }
    } else {
      for (const k in x) { s += '\n' + ' '.repeat(indent) + k + ': ' + anyString2(x[k], indent + 1, proplist, include); }
    }
    return s;
  }
}
function anyString3(x, indent = 0, proplist = null, include = true, guard = ['specKey', 'label', 'pool', 'el', 'sub', 'elm', 'cond', 'info', 'o', 'ui', 'source', 'bi']) {
  if (isLiteral(x)) return x;
  else if (isListOfLiterals(x)) return x.join(' ');
  else if (isEmpty(x)) return x;
  else if (isList(x)) {
    return x.map(el => anyString3(el, indent + 1, proplist, include)).join(' ');
  }
  else if (isDict(x)) {
    let s = '';
    for (const k in x) {
      if (guard.includes(k)) continue;
      if (isdef(proplist) && !include && proplist.includes(k)) continue;
      else if (isdef(proplist) && include && !proplist.includes(k)) continue;
      s += '\n' + ' '.repeat(indent) + k + ': ' + anyString3(x[k], indent + 1, proplist, include);
    }
    return s;
  }
}
function anyToString1(x, indent = 0, ifDict = 'entries') {
  if (isList(x) && !isEmpty(x)) { return x.join(' '); }
  else if (isDict(x)) {
    return ifDict == 'keys' ? Object.keys(x).join(' ')
      : ifDict == 'entries' ? Object.entries(x).map(([k, v]) => k + ': ' + dictOrListToString(v, 'ifDict', indent + 2)).join('\n')
        : Object.entries(x).join(' ');
  }
  else return x;
}
function anyWordContainedInKeys(dict, keywords) {
  let res = [];
  for (const k in dict) {
    let isMatch = false;
    for (const w of keywords) {
      if (k.includes(w)) { isMatch = true; break; }
    }
    if (isMatch) res.push(dict[k]);
  }
  return res;
}
function anyWordContainedInKeysAsWord(dict, keywords) {
  let res = [];
  for (const k in dict) {
    let isMatch = false;
    let wordsInKey = splitAtWhiteSpace(k);
    for (const w of keywords) {
      if (wordsInKey.includes(w)) { isMatch = true; break; }
    }
    if (isMatch) res.push(dict[k]);
  }
  return res;
}
function anyWordContainedInProps(dict, keywords, props) {
  let res = [];
  for (const k in dict) {
    let isMatch = false;
    let propString = '';
    for (const p of props) { propString += dict[k][p]; }
    for (const w of keywords) {
      if (propString.includes(w)) { isMatch = true; break; }
    }
    if (isMatch) res.push(dict[k]);
  }
  return res;
}
function anyWordContainedInPropsAsWord(dict, keywords, props) {
  let res = [];
  for (const k in dict) {
    let isMatch = false;
    let keywordList = [];
    for (const p of props) {
      if (nundef(dict[k][p])) continue;
      let wordsInKey = splitAtWhiteSpace(dict[k][p]);
      keywordList = keywordList.concat(wordsInKey);
    }
    for (const w of keywords) {
      if (keywordList.includes(w)) { isMatch = true; break; }
    }
    if (isMatch) res.push(dict[k]);
  }
  return res;
}
function apiphp(o, saveFromZ = false) {
  let [data, cmd] = [o.data, o.cmd];
  let result = {}, friendly, uname, state, player_status, fen;
  if (saveFromZ && isdef(data.friendly) && !db_table_exists(data.friendly)) {
    let res = db_new_table(data.friendly, Z.game, Z.host, jsCopy(Z.playerlist), jsCopy(Z.fen), jsCopy(Z.options));
    if (isdef(Z.playerdata)) res.playerdata = jsCopy(Z.playerdata);
  }
  if (cmd == 'table') {
    if (isdef(data.auto)) result.auto = data.auto;
    friendly = data.friendly;
    uname = data.uname;
    result.status = "table";
    if (isdef(data.clear_players)) {
      result.playerdata = db_clear_players(friendly);
      result.status = "clear_players";
    } else if (isdef(data.write_player) && isdef(data.state)) {
      player_status = isdef(data.player_status) ? data.player_status : '';
      result.playerdata = db_write_player(friendly, uname, data.state, player_status);
      result.status = "write_player";
    } else {
      result.playerdata = db_read_playerdata(friendly);
    }
    if (isdef(data.write_fen)) {
      result.table = db_write_fen(friendly, data.fen);
      result.status += " write_fen";
    } else {
      result.table = db_read_table(friendly);
    }
  } else if (cmd == 'startgame') {
    let res = db_new_table(data.friendly, data.game, data.host, data.players, data.fen, data.options);
    result.table = res.table;
    result.playerdata = res.playerdata;
    result.status = `startgame ${data.friendly}`;
  } else if (cmd == 'tables') {
    result.tables = dict2list(GT, 'friendly').map(x => x.table);
    result.status = "tables";
  } else if (cmd == 'gameover') {
    result.table = db_write_fen(data.friendly, data.fen, data.scoring);
    result.status = `scored table ${data.friendly}`;
  }
  return result;
}
function appears_once_only(board, possibilities, segment, r, c) {
  let updated = false
  for (i = 0; i < possibilities.length; i++) {
    let possibility = possibilities[i]
    let counter = 0
    segment.forEach(cell => {
      if (Array.isArray(cell)) {
        if (cell.includes(possibility)) {
          counter++
        }
      } else {
        if (cell == possibility) {
          counter++
        }
      }
    })
    if (counter == 1) {
      board[r][c] = possibility
      updated = true
      break
    }
  }
  return updated
}
function apply_skin1(item) {
  let d = item.container; mCenterFlex(d); mStyle(d, { position: 'relative', w: 400 });
  mText(`${item.label}: <span style="font-size:20px;margin:10px;color:red">${item.content}</span>`, d);
  let b = mButton(item.caption, item.handler, d, { position: 'absolute', right: 0, top: 'calc( 50% - 12px )', h: 24 }, ['selectbutton', 'enabled']);
  console.log('button', b)
}
function apply_skin2(item) {
  let d = item.container; mCenterFlex(d); mStyle(d, { position: 'relative', w: 400 });
  let h = 24;
  let top = `calc( 50% - ${h / 2}px )`
  mText(item.label + ':', d, { position: 'absolute', left: 0, top: top, h: h });
  mText(`<span style="font-size:20px;margin:10px;color:red">${item.content}</span>`, d);
  item.button = mButton(item.caption, item.handler, d, { position: 'absolute', right: 0, top: top, h: h, w: 80 }, ['selectbutton', 'enabled']);
}
function apply_skin3(item) {
  let d = item.container; mCenterCenterFlex(d); mStyle(d, { position: 'relative', w: 400 });
  let h = 24;
  let top = `calc( 50% - ${h / 2}px )`
  mText(item.label + ':', d, { position: 'absolute', left: 0, top: top, h: h });
  let panel = UI.dAnzeige = item.panel = mDiv(d, { bg: '#ffffff80', padding: '4px 12px', w: 200, align: 'center', rounding: 8 });
  let words = toWords(item.content)
  let panelitems = UI.panelItems = item.panelitems = [];
  for (let i = 0; i < 4; i++) {
    let text = valf(words[i], '');
    let dw = mDiv(panel, { hpadding: 4, display: 'inline', fz: 22, weight: 'bold', fg: 'red' }, `dbid_${i}`, text);
    panelitems.push({ div: dw, index: i, initial: text, state: 'unselected' })
  }
  let b = item.buttonX = mDiv(panel, { fz: 10, hpadding: 4, bg: 'white' }, null, 'CLR', 'enabled'); mPlace(b, 'tr', 2)
  b.onclick = bluff_clear_panel;
  item.button = mButton(item.caption, item.handler, d, { position: 'absolute', right: 0, top: top, h: h, w: 80 }, ['selectbutton', 'enabled']);
}
function applyColorkey(item) {
  let l = item.live;
  let sShade = '0 0 0 ' + item.textShadowColor;
  item.shadeStyles = { 'text-shadow': sShade, fg: colorFrom('black', l.options.contrast) };
  let ui = l.options.showPic ? l.dPic : l.dLabel;
  mStyleX(ui, item.shadeStyles);
}
function applyCssStyles(ui, params) {
  let domType = getTypeOf(ui);
  if (domType == 'g') {
    mStyle(ui, params);
  } else {
    mStyle(ui, params);
  }
}
function applySettings(b, s, h = 768, topFrame = 0) {
  let isRealBoard = topFrame == 0;
  let hBoard = h, wBoard = 2 * h;
  let scale = hBoard / valf(s.hBoard, 768);
  calcLayoutParameters(s, b, scale);
  clearElement(b.dOuter);
  b.fields = null;
  createFields(s, b, scale);
  console.log('applySettings: baseColor', s.baseColor);
  if (isRealBoard) setNewBackgroundColor(s.baseColor);
  return b;
}
function applyStandard(dParent, s, h = 768, topFrame = 0) {
  let isRealBoard = topFrame == 0;
  let b = { boardFilename: s.boardFilename };
  let hBoard = h, wBoard = 2 * h;
  let scale = hBoard / valf(s.hBoard, 768);
  calcLayoutParameters(s, b, scale);
  let d0;
  if (isRealBoard) {
    d0 = b.d0 = mDiv(dParent, { h: hBoard });
  } else {
    d0 = b.d0 = mDiv(dParent, { w: wBoard + 100, h: hBoard + topFrame }, 'd0_' + b.boardFilename);
  }
  mCenterCenterFlex(d0);
  let dOuter = b.dOuter = mDiv(d0, {}, 'dOuter_' + b.boardFilename);
  mCenterCenterFlex(dOuter);
  loadBoardImage(dParent, s, b, scale, topFrame != 0);
  console.log('applyStandard: baseColor', s.baseColor);
  if (isRealBoard) setNewBackgroundColor(s.baseColor);
  createFields(s, b, scale);
  return b;
}
function applyStyles(g, id, styles) { g.mStyle(id, styles, isdef(g.getNode(id)) ? 'node' : 'edge'); }
function appSpecificSettings() {
  updateLabelSettings();
  updateTimeSettings();
  updateKeySettings();
  updateSpeakmodeSettings();
}
function areaBlink(id) {
  let area = UIS[id];
  if (area) area.elem.classList.add('blink');
}
function areaRows(soDict, loc) {
  let area = getVisual(loc);
  let [w, areaH] = area.getSize();
  let keys = getKeys(soDict);
  let n = keys.length;
  let h = Math.floor(areaH / n);
  let extra = areaH - n * h;
  let x = 0;
  let y = 0;
  let [iPalette, ipal] = area.getColorInfo();
  let pal = S.pals[iPalette];
  ipal = n <= pal.length - ipal ? ipal : n <= pal.length ? pal.length - n : ipal;
  let i = 0;
  for (const k in soDict) {
    let id = k;
    i += 1;
    let o = createMainDiv(id, loc);
    let h1 = i == n - 1 ? h + extra : h;
    o.setBounds(x, y, w, h1);
    o.setPalette(iPalette, ipal);
    y += h1;
    ipal = (ipal + 1) % pal.length;
  }
}
function areNeighbors(r1, r2) {
  let res = firstCond(r1.doors, x => x.includes(r1.id) && x.includes(r2.id));
  return res != null;
}
function aRestore(elem) { elem.style.transform = ''; }
function ari_action_round_over(otree, plturn) {
  ari_move_market_to_discard(otree);
  ari_move_stalls_to_hands(otree);
  ari_add_hand_card(otree);
  otree.round = [];
  otree.iturn = 0;
  if (otree.stage == 10) {
    otree.phase = 'queen';
    otree.stage = 3;
  } else if (otree.phase == 'king') {
    otree.pl_gameover = [];
    for (const uname of otree.plorder) {
      let [bcorrect, realvps] = ari_get_correct_buildings(otree[uname].buildings);
      let can_end = ari_check_end_condition(bcorrect);
      if (can_end) otree.pl_gameover.push(uname);
    }
    if (!isEmpty(otree.pl_gameover)) {
      otree.stage = 10;
      otree.iturn = otree.plorder.indexOf(otree.pl_gameover[0]);
    } else {
      otree.phase = 'queen';
      otree.stage = 3;
    }
  } else if (otree.phase == 'queen') {
    for (const uname of otree.plorder) {
      for (const k in otree[uname].buildings) {
        if (k == 'farms') continue;
        let n = otree[uname].buildings[k].length;
        otree[uname].coins += n;
      }
    }
    otree.phase = 'jack';
    otree.stage = 3;
  } else {
    ari_move_herald(otree, plturn);
    ari_add_harvest_cards(otree);
    otree.phase = 'king';
    ari_tax_phase_needed(otree, plturn);
  }
}
function ari_activate_ui() { ari_pre_action(); }
function ari_add_hand_card() {
  let fen = Z.fen;
  for (const uplayer of fen.plorder) {
    ari_ensure_deck(fen, 1);
    top_elem_from_to(fen.deck, fen.players[uplayer].hand);
  }
}
function ari_add_harvest_cards(fen) {
  for (const plname of fen.plorder) {
    for (const f of fen.players[plname].buildings.farm) {
      if (nundef(f.h)) {
        let list = [];
        ari_ensure_deck(fen, 1);
        top_elem_from_to(fen.deck, list);
        f.h = list[0];
      }
    }
  }
}
function ari_add_rumor(fenbuilding, key) {
  if (nundef(fenbuilding.rumors)) fenbuilding.rumors = [];
  fenbuilding.rumors.push(key);
}
function ari_branch(obj, otree, rtree) {
  verify_unit_test(otree);
  ari_player_stats(otree);
  G.plprev = G.plturn;
  let plturn = G.plturn = otree.plturn;
  let turn_changed = G.plprev != G.plturn;
  let my_turn = G.plturn == G.cur_user;
  console.assert(otree.plturn == otree.plorder[otree.iturn], 'TURN MIXUP!');
  if (TESTING) console.log('___ ITER:' + ITER, plturn, turn_changed ? '(changed)' : '', my_turn ? 'ME!' : '', isdef(otree.num_actions) ? 'actions:' + otree.num_actions : '');
  ari_present(otree, plturn);
  A = { level: 0, di: {}, ll: [], items: [], selected: [], tree: null, breadcrumbs: [], sib: [], command: null };
  console.assert(G.otree == otree, 'OTREE FAIL!!!!!!!!!!!');
  table_shield_off();
  if (isdef(otree.winner)) {
    stop_game();
    ari_reveal_all_buildings(otree);
    if (!TestRunning) turn_show_gameover(otree);
  } else if (G.cur_user == plturn || is_admin(G.cur_user)) {
    ari_pre_action(otree, plturn);
  } else {
    let txt = otree.num_actions > 0 ? ('(' + otree.action_number + '/' + otree.total_pl_actions + ')') : '';
    dTop.innerHTML =
      `<div style='padding:4px 10px;font-size:20px;display:flex;justify-content:space-between'>
      <div>${G.table.friendly.toLowerCase()}</div>
      <div>${plturn} ${txt} ${ARI.stage[otree.stage]}</div>
      <div>phase: ${otree.phase.toUpperCase()}</div>
    </div>`;
    table_shield_on();
  }
}
function ari_calc_fictive_vps(fen, plname) {
  let pl = fen.players[plname];
  let bs = pl.buildings;
  let vps = calc_building_vps(bs);
  return vps;
}
function ari_calc_real_vps(fen, plname) {
  let pl = fen.players[plname];
  let bs = ari_get_correct_buildings(pl.buildings);
  let vps = calc_building_vps(bs);
  for (const btype in bs) {
    let blist = bs[btype];
    for (const b of blist) {
      let lead = b.list[0];
      if (firstCond(pl.commissions, x => x[0] == lead[0])) {
        vps += 1;
      }
    }
  }
  return vps;
}
function ari_check_action_available(a, fen, uplayer) {
  let cards;
  let pl = fen.players[uplayer];
  if (a == 'trade') {
    cards = ari_get_all_trading_cards(fen);
    let not_pl_stall = cards.filter(x => !pl.stall.includes(x.key));
    return cards.length >= 2 && pl.stall.length > 0 && not_pl_stall.length > 0;
  } else if (a == 'exchange') {
    cards = ari_get_all_wrong_building_cards(fen, uplayer);
    return cards.length > 0 && (pl.hand.length + pl.stall.length > 0);
  } else if (a == 'build') {
    let res = ari_get_player_hand_and_stall(fen, uplayer);
    if (res.length < 4) return false;
    let has_a_king = firstCond(res, x => x[0] == 'K');
    if (pl.coins < 1 && !has_a_king) return false;
    if (fen.phase != 'king' && (!has_a_king || res.length < 5)) return false;
    if (pl.coin == 0 && res.length < 5) return false;
    return true;
  } else if (a == 'upgrade') {
    if (isEmpty(pl.buildings.farm) && isEmpty(pl.buildings.estate)) return false;
    let res = ari_get_player_hand_and_stall(fen, uplayer);
    if (isEmpty(res)) return false;
    let has_a_king = firstCond(res, x => x[0] == 'K');
    if (pl.coins < 1 && !has_a_king) return false;
    if (fen.phase != 'king' && !has_a_king) return false;
    if (pl.coin == 0 && res.length < 2) return false;
    return true;
  } else if (a == 'downgrade') {
    if (isEmpty(pl.buildings.chateau) && isEmpty(pl.buildings.estate)) return false;
    return true;
  } else if (a == 'buy') {
    if (fen.open_discard.length == 0) return false;
    let res = ari_get_player_hand_and_stall(fen, uplayer);
    let has_a_jack = firstCond(res, x => x[0] == 'J');
    if (pl.coins < 1 && !has_a_jack) return false;
    if (fen.phase != 'jack' && !has_a_jack) return false;
    return true;
  } else if (a == 'visit') {
    let others = fen.plorder.filter(x => x != uplayer);
    let n = 0;
    for (const plname of others) {
      for (const k in fen.players[plname].buildings) {
        n += fen.players[plname].buildings[k].length;
      }
    }
    if (n == 0) return false;
    let res = ari_get_player_hand_and_stall(fen, uplayer);
    let has_a_queen = firstCond(res, x => x[0] == 'Q');
    if (pl.coins < 1 && !has_a_queen) return false;
    if (fen.phase != 'queen' && !has_a_queen) return false;
    return true;
  } else if (a == 'harvest') {
    let harvests = ari_get_all_building_harvest_cards(fen, uplayer);
    return !isEmpty(harvests);
  } else if (a == 'pickup') {
    return !isEmpty(pl.stall);
  } else if (a == 'sell') {
    return pl.stall.length >= 2;
  } else if (a == 'pass') {
    return true;
  } else if (a == 'commission') {
    for (const c of pl.commissions) {
      let rank = c[0];
      if (firstCond(pl.stall, x => x[0] == rank)) return true;
    }
    return false;
  } else if (a == 'rumor') {
    if (isEmpty(pl.rumors)) return false;
    let others = fen.plorder.filter(x => x != uplayer);
    let n = 0;
    for (const plname of others) {
      for (const k in fen.players[plname].buildings) {
        n += fen.players[plname].buildings[k].length;
      }
    }
    if (n == 0) return false;
    return true;
  } else if (a == 'inspect') {
    if (isEmpty(pl.rumors)) return false;
    let others = fen.plorder.filter(x => x != uplayer);
    let n = 0;
    for (const plname of others) {
      for (const k in fen.players[plname].buildings) {
        n += fen.players[plname].buildings[k].length;
      }
    }
    return n > 0;
  } else if (a == 'blackmail') {
    let others = fen.plorder.filter(x => x != uplayer);
    let n = 0;
    for (const plname of others) {
      for (const k in fen.players[plname].buildings) {
        let list = fen.players[plname].buildings[k];
        let building_with_rumor = firstCond(list, x => !isEmpty(x.rumors));
        if (building_with_rumor) n++;
      }
    }
    if (n == 0) return false;
    let res = ari_get_player_hand_and_stall(fen, uplayer);
    let has_a_queen = firstCond(res, x => x[0] == 'Q');
    if (pl.coins < 1 && !has_a_queen) return false;
    if (fen.phase != 'queen' && !has_a_queen) return false;
    return true;
  } else if (a == 'buy rumor') {
    if (fen.deck_rumors.length == 0) return false;
    if (pl.coins < 1) return false;
    return true;
  }
}
function ari_check_end_condition(blist) {
  let nchateau = blist.chateau.length;
  let nfarm = blist.farm.length;
  let nestate = blist.estate.length;
  if (nchateau >= 2 || nchateau >= 1 && nfarm >= 3 || nchateau >= 1 && nestate >= 2) {
    return true;
  }
  return false;
}
function ari_clear_church() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  for (const prop of ['church', 'church_order', 'selorder', 'tithemin', 'tithe_minimum', 'toBeSelected', 'candidates']) delete fen[prop];
  for (const plname in fen.players) {
    delete fen.players[plname].tithes;
  }
  fen.church = ari_deck_deal_safe(fen, Z.plorder.length);
}
function ari_complete_building() {
  let [otree, plturn] = [G.otree, G.otree.plturn];
  let building_items = A.selected.map(x => A.items[x]);
  let building_type = building_items.length == 4 ? 'farms' : building_items.length == '5' ? 'estates' : 'chateaus';
  console.log('...building a', building_type);
  otree[plturn].buildings[building_type].push({ list: building_items.map(x => x.key), h: null });
  for (const item of building_items) {
    let source = lookup(otree, item.path.split('.'));
    removeInPlace(source, item.key);
  }
  ari_redo_player_ui(otree, plturn);
  ari_next_action(otree, plturn);
}
function ari_complete_upgrade() {
  let [otree, plturn] = [G.otree, G.otree.plturn];
  let gb = A.building;
  let b = lookup(otree, gb.path.split('.'));
  let n = A.upgrade_cards.length;
  let type0 = gb.o.type;
  let len = gb.o.list.length + n;
  let type1 = len == 5 ? 'estates' : 'chateaus';
  let target = lookup(otree, gb.path.split('.'));
  for (const o of A.upgrade_cards) {
    let source = lookup(otree, o.path.split('.'));
    elem_from_to(o.key, source, target.list);
  }
  let bres = target;
  bres.harvest = null;
  removeInPlace(otree[plturn].buildings[type0], bres);
  otree[plturn].buildings[type1].push(bres);
  ari_redo_player_ui(otree, plturn);
  ari_next_action(otree, plturn);
}
function ari_create_card_assets(scolors) {
  let sz = 100;
  set_card_constants(sz * .7, sz, 'A23456789TJQK', 'SHDC', scolors);
  let colors = { r: RED, b: BLUE, g: GREEN, p: PURPLE, y: YELLOW, o: ORANGE };
  let ranknames = { A: 'Ace', K: 'King', T: '10', J: 'Jack', Q: 'Queen' };
  let suitnames = { S: 'Spades', H: 'Hearts', C: 'Clubs', D: 'Diamonds' };
  let di = {};
  for (const r of Card.ranks) {
    for (const s of Card.suits) {
      for (const c of Card.decks) {
        let k = r + s + c;
        di[k] = { key: k, val: r == 'A' ? 1 : 'TJQK'.includes(r) ? 10 : Number(r), rank: r, suit: s, color: colors[c], c52key: 'card_' + r + s, w: sz * .7, h: sz, sz: sz, ov: Card.ovw, friendly: `${isNumber(r) ? r : ranknames[r]} of ${suitnames[s]}`, short: `${r}${s}` };
      }
    }
  }
  Aristocards = di;
  return di;
}
function ari_create_ui_tree(n, dParent, r) {
  let d = null;
  if (n.oid == 'o_1') {
    d = mDiv(dParent, { w: '100%' }, getUID('u'));
  } else if (startsWith(n.path, 'deck')) {
    let deck = G[n.path] = ui_type_deck(n.content);
    d = deck.container;
  } else if (r.otree.player_names.includes(n.content)) {
    d = ui_make_player(Session.otree, n.content, dParent);
  } else if (n.type == 'cardlist') {
    d = ari_make_cardlist(n.content, 2, dParent);
  } else if (n.type == 'card') {
    return;
  } else if (n.type == 'string') {
    let id = getUID('u');
    d = mDiv(dParent, { bg: 'inherit' }, id, n.content);
  }
  if (nundef(d)) return; else r.add_ui_node(d, d.id, n.oid);
  for (const ch of n.children) {
    ari_create_ui_tree(r.nodes[ch], d, r);
  }
}
function ari_deck_add_safe(otree, n, arr) {
  ari_ensure_deck(otree, n);
  deck_add(otree.deck, n, arr);
}
function ari_deck_deal_safe(fen, n) { ari_ensure_deck(fen, n); return deck_deal(fen.deck, n); }
function ari_ensure_deck(fen, n) {
  if (fen.deck.length < n) { ari_refill_deck(fen); }
}
function ari_get_actions(uplayer) {
  let fen = Z.fen;
  let actions = exp_rumors(Z.options) ? ['trade', 'exchange', 'build', 'upgrade', 'downgrade', 'buy', 'buy rumor', 'rumor', 'inspect', 'blackmail', 'harvest', 'pickup', 'sell', 'tithe', 'commission']
    : ['trade', 'exchange', 'build', 'upgrade', 'downgrade', 'buy', 'visit', 'harvest', 'pickup', 'sell', 'tithe', 'commission'];
  if (Config.autosubmit) actions.push('pass');
  let avail_actions = [];
  for (const a of actions) {
    let avail = ari_check_action_available(a, fen, uplayer);
    if (avail) avail_actions.push(a);
  }
  return avail_actions;
}
function ari_get_all_building_harvest_cards(fen, uplayer) {
  let res = [];
  let pl = fen.players[uplayer];
  for (const b of pl.buildings.farm) {
    if (b.h) res.push({ b: b, h: b.h });
  }
  return res;
}
function ari_get_all_trading_cards(fen) {
  let res = [];
  fen.market.map(c => res.push({ key: c, path: 'market' }));
  for (const uplayer of fen.plorder) {
    let pl = fen.players[uplayer];
    let stall = pl.stall;
    stall.map(x => res.push({ key: x, path: `players.${uplayer}.stall` }));
  }
  return res;
}
function ari_get_all_trading_cards_orig(otree) {
  let res = [];
  let plcardlists = otree.plorder.map(x => otree[x].stall);
  plcardlists.map(x => x.map(c => res.push[{ c: c, owner: x }]));
  otree.market.map(c => res.push({ c: c, owner: 'market' }));
  return res;
}
function ari_get_all_wrong_building_cards(fen, uplayer) {
  let res = [];
  let pl = fen.players[uplayer];
  for (const k in pl.buildings) {
    for (const b of pl.buildings[k]) {
      let bcards = b.list;
      let lead = bcards[0];
      let [rank, suit] = [lead[0], lead[1]];
      for (let i = 1; i < bcards.length; i++) {
        if (bcards[i][0] != rank) res.push({ c: bcards[i], building: b });
      }
    }
  }
  return res;
}
function ari_get_building_type(obuilding) { let n = obuilding.list.length; return n == 4 ? 'farm' : n == 5 ? 'estate' : 'chateau'; }
function ari_get_card(ckey, h, w, ov = .3) {
  let type = ckey[2];
  let sz = { largecard: 100, smallcard: 50 };
  let info = type == 'n' ? to_aristocard(ckey, sz.largecard) : type == 'l' ? to_luxurycard(ckey, sz.largecard) : type == 'r' ? to_rumorcard(ckey, sz.smallcard) : to_commissioncard(ckey, sz.smallcard);
  let card = cardFromInfo(info, h, w, ov);
  if (type == 'l') luxury_card_deco(card);
  return card;
}
function ari_get_card_large(ckey, h, w, ov = .2) {
  let type = ckey[2];
  let sz = { largecard: 120, smallcard: 80 };
  let info = type == 'n' ? to_aristocard(ckey, sz.largecard) : type == 'l' ? to_luxurycard(ckey, sz.largecard) : type == 'r' ? to_rumorcard(ckey, sz.smallcard) : to_commissioncard(ckey, sz.smallcard);
  let card = cardFromInfo(info, h, w, ov);
  if (type == 'l') luxury_card_deco(card);
  return card;
}
function ari_get_cardinfo(ckey) { return Aristocards[ckey]; }
function ari_get_correct_buildings(buildings) {
  let bcorrect = { farm: [], estate: [], chateau: [] };
  for (const type in buildings) {
    for (const b of buildings[type]) {
      let list = b.list;
      let lead = list[0];
      let iscorrect = true;
      for (const key of arrFromIndex(list, 1)) {
        if (key[0] != lead[0]) { iscorrect = false; continue; }
      }
      if (iscorrect) {
        lookupAddIfToList(bcorrect, [type], b);
      }
    }
  }
  return bcorrect;
}
function ari_get_fictive_vps(fen, uname) {
  let pl = fen.players[uname];
  let bs = pl.buildings;
  let vps = calc_building_vps(bs);
  return vps;
}
function ari_get_first_tax_payer(fen, pl_tax) { return ari_get_tax_payer(fen, pl_tax, 0); }
function ari_get_max_journey_length(fen, uplayer) {
  let pl = fen.players[uplayer];
  let sorted_journeys = sortByDescending(pl.journeys.map(x => ({ arr: x, len: x.length })), 'len');
  return isEmpty(pl.journeys) ? 0 : sorted_journeys[0].len;
}
function ari_get_player_hand_and_stall(fen, uplayer) {
  let res = [];
  res = res.concat(fen.players[uplayer].hand);
  res = res.concat(fen.players[uplayer].stall);
  return res;
}
function ari_get_real_vps(fen, uname) {
  let pl = fen.players[uname];
  let bs = ari_get_correct_buildings(pl.buildings);
  let vps = calc_building_vps(bs);
  for (const btype in bs) {
    let blist = bs[btype];
    for (const b of blist) {
      let lead = b.list[0];
      if (firstCond(pl.commissions, x => x[0] == lead[0])) vps += 1;
    }
  }
  return vps;
}
function ari_get_tax_payer(fen, pl_tax, ifrom = 0) {
  let iturn = ifrom;
  let uplayer = fen.plorder[iturn];
  if (nundef(uplayer)) return null;
  while (pl_tax[uplayer] <= 0) {
    iturn++;
    if (iturn >= fen.plorder.length) return null;
    uplayer = fen.plorder[iturn];
  }
  return uplayer;
}
function ari_get_vps(otree, uname) {
  if (uname == otree.plturn) {
    return calc_building_vps(otree, uname);
  } else {
    return calc_building_vps(otree, uname);
  }
}
function ari_globalize(g, uname) {
  DA.uname = uname; DA.g = g;
  z = {};
  z.A = { level: 0, di: {}, ll: [], items: [], selected: [], tree: null, breadcrumbs: [], sib: [], command: null };
  copyKeys(DA.g, z);
  copyKeys(jsCopy(DA.g.fen), z);
  copyKeys(UI, z);
  z.uname = uname;
}
function ari_history_list(lines, title = '', fen) {
  if (nundef(fen)) fen = Z.fen;
  if (nundef(fen.history)) fen.history = [];
  fen.history.push({ title: title, lines: lines });
}
function ari_make_cardlist(list, splay, dParent) {
  let id = getUID('u');
  let d = mDiv(dParent, { bg: 'random', padding: 10 }, id);
  let items = list.map(x => ari_get_card(x));
  let [w, h] = [items[0].w, items[0].h];
  items.map(x => mAppend(d, iDiv(x)));
  mContainerSplay(d, splay, w, h, items.length, 20);
  items.map(x => mItemSplay(x, list, splay));
  return d;
}
function ari_make_selectable(item, dParent, dInstruction) {
  let A = Z.A;
  switch (item.itemtype) {
    case 'card': make_card_selectable(item); break;
    case 'container': make_container_selectable(item); break;
    case 'string': make_string_selectable(item); break;
  }
}
function ari_make_selected(item) {
  let A = Z.A;
  switch (item.itemtype) {
    case 'card': make_card_selected(item); break;
    case 'container': make_container_selected(item); break;
    case 'string': make_string_selected(item); break;
  }
}
function ari_make_unselectable(item) {
  let A = Z.A;
  switch (item.itemtype) {
    case 'card': make_card_unselectable(item); break;
    case 'container': make_container_unselectable(item); break;
    case 'string': make_string_unselectable(item); break;
  }
}
function ari_make_unselected(item) {
  let A = Z.A;
  switch (item.itemtype) {
    case 'card': make_card_unselected(item); break;
    case 'container': make_container_unselected(item); break;
    case 'string': make_string_unselected(item); break;
  }
}
function ari_move_herald(fen) {
  fen.heraldorder = arrCycle(fen.heraldorder, 1);
  ari_history_list([`*** new herald: ${fen.heraldorder[0]} ***`], 'herald');
  return fen.heraldorder[0];
}
function ari_move_market_to_discard() {
  let fen = Z.fen;
  while (fen.market.length > 0) {
    elem_from_to_top(fen.market[0], fen.market, fen.deck_discard);
  }
  ari_reorg_discard();
}
function ari_move_stalls_to_hands() {
  let fen = Z.fen;
  for (const uplayer of fen.plorder) {
    fen.players[uplayer].hand = fen.players[uplayer].hand.concat(fen.players[uplayer].stall);
    fen.players[uplayer].stall = [];
  }
}
function ari_next_action() {
  let [fen, uplayer] = [Z.fen, Z.uplayer];
  deactivate_ui();
  console.assert(isdef(Z.num_actions));
  fen.num_actions -= 1;
  fen.action_number += 1;
  if (fen.num_actions <= 0) {
    fen.total_pl_actions = 0;
    lookupAddIfToList(fen, ['actionsCompleted'], uplayer);
    let next = ari_select_next_player_according_to_stall_value(fen);
    if (!next) {
      ari_next_phase();
    } else {
      Z.turn = [next];
    }
  } else {
    Z.stage = 5;
  }
  take_turn_fen();
}
function ari_next_phase() {
  let [fen, uplayer] = [Z.fen, Z.uplayer];
  ari_move_market_to_discard();
  ari_move_stalls_to_hands();
  ari_add_hand_card();
  delete fen.actionsCompleted;
  delete fen.stallSelected;
  Z.turn = [fen.plorder[0]];
  if (Z.stage == 10) {
    Z.phase = 'queen';
    [Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, Z.phase);
  } else if (fen.phase == 'king') {
    fen.pl_gameover = [];
    for (const plname of fen.plorder) {
      let bcorrect = ari_get_correct_buildings(fen.players[plname].buildings);
      let can_end = ari_check_end_condition(bcorrect);
      if (can_end) fen.pl_gameover.push(plname);
    }
    if (!isEmpty(fen.pl_gameover)) {
      Z.stage = 10;
      Z.turn = [fen.pl_gameover[0]];
    } else {
      Z.phase = 'queen';
      [Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, Z.phase);
    }
  } else if (fen.phase == 'queen') {
    for (const uplayer of fen.plorder) {
      for (const k in fen.players[uplayer].buildings) {
        if (k == 'farm') continue;
        let n = fen.players[uplayer].buildings[k].length;
        fen.players[uplayer].coins += n;
        if (n > 0) ari_history_list([`${uplayer} gets ${n} coins for ${k} buildings`], 'payout');
      }
    }
    Z.phase = 'jack';
    [Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, Z.phase);
  } else {
    fen.herald = ari_move_herald(fen, uplayer);
    fen.plorder = jsCopy(fen.heraldorder);
    ari_add_harvest_cards(fen);
    Z.phase = 'king';
    let taxneeded = ari_tax_phase_needed(fen);
    Z.turn = taxneeded ? fen.turn : [fen.herald];
    if (taxneeded) Z.stage = 2; else[Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, Z.phase);
  }
  return Z.stage;
}
function ari_open_market(fen, phase, deck, market) {
  DA.qanim = [];
  let n_market = phase == 'jack' ? 3 : 2;
  fen.stage = Z.stage = phase == 'jack' ? 12 : phase == 'queen' ? 11 : 4;
  fen.stallSelected = [];
  delete fen.passed;
  for (let i = 0; i < n_market; i++) {
    DA.qanim.push([qanim_flip_topmost, [deck]]);
    DA.qanim.push([qanim_move_topmost, [deck, market]]);
    DA.qanim.push([q_move_topmost, [deck, market]]);
  }
  DA.qanim.push([q_mirror_fen, ['deck', 'market']]);
  DA.qanim.push([ari_pre_action, []]);
  qanim();
}
function ari_open_rumors(stage = 28) {
  let [fen, deck] = [Z.fen, UI.deck_rumors];
  DA.qanim = [];
  fen.stage = Z.stage = stage;
  let n = Math.min(2, fen.deck_rumors.length);
  let cards = arrTake(fen.deck_rumors, n);
  let uicards = cards.map(x => ari_get_card(x));
  let dest = UI.rumor_top = ui_type_market([], deck.container.parentNode, { maleft: 12 }, `rumor_top`, 'rumor_top', ari_get_card);
  mMagnifyOnHoverControlPopup(dest.cardcontainer);
  for (let i = 0; i < n; i++) {
    DA.qanim.push([qanim_flip_topmost, [deck]]);
    DA.qanim.push([qanim_move_topmost, [deck, dest]]);
    DA.qanim.push([q_move_topmost, [deck, dest]]);
  }
  DA.qanim.push([q_mirror_fen, ['deck_rumors', 'rumor_top']]);
  DA.qanim.push([ari_pre_action, []]);
  qanim();
}
function ari_payment(rank = 'king') {
  if (A.payment_complete == true) return true;
  let [otree, plturn] = [G.otree, G.otree.plturn];
  let items = a2_get_build_items(plturn);
  let pay_letter = rank.toUpperCase()[0];
  let pay_cards = items.filter(x => x.key[0] == pay_letter);
  let has_pay_card = !isEmpty(pay_cards);
  if (has_pay_card && otree[plturn].coins > 0 && otree.phase == rank) {
    otree.stage = 20;
    let items = pay_cards;
    items.push({ o: null, a: 'coin', key: 'coin', friendly: 'coin', path: null });
    let i = 0; items.map(x => { x.index = i; i++; });
    a2_add_selection(items, 'payment', 1, 1, false);
    return false;
  } else if (has_pay_card && pay_cards.length > 1) {
    otree.stage = 20;
    let items = pay_cards;
    let i = 0; items.map(x => { x.index = i; i++; });
    a2_add_selection(items, 'payment', 1, 1, false);
    return false;
  } else if (has_pay_card) {
    console.assert(otree[plturn].coins == 0 || otree.phase != rank, 'HAS A COIN in matching phase!!!!');
    let k = pay_cards[0];
    a2_pay_with_card(k);
    return true;
  } else {
    a2_pay_with_coin(plturn);
    return true;
  }
}
function ari_player_stats(otree) {
  let player_stat_items = G.player_stat_items = ui_player_info(otree.plorder.map(x => otree[x]));
  let herald = otree.plorder[0];
  for (const uname of otree.plorder) {
    let pl = otree[uname];
    let item = player_stat_items[uname];
    let d = iDiv(item); mCenterFlex(d); mLinebreak(d);
    if (uname == herald) {
      mSym('tied-scroll', d, { fg: 'gold', fz: 24 }, 'TL');
    }
    player_stat_count('coin', pl.coins, d);
    if (!isEmpty(otree[uname].stall) && otree.stage >= 5 && otree.stage <= 6) {
      player_stat_count('shinto shrine', !otree.round.includes(uname) || otree.stage < 6 ? calc_stall_value(otree, uname) : '_', d);
    }
    player_stat_count('star', ari_get_vps(otree, uname), d);
  }
}
function ari_post_action() {
  clearElement(dError);
  let otree = G.otree;
  let [step, stage, iturn, round, phase, plturn] = set_state_numbers(otree);
  let [deck, market, discard, open_discard] = [G.deck, G.market, G.deck_discard, G.open_discard];
  if (stage == 2) {
    let items = A.selected.map(x => A.items[x]);
    let n = otree.pl_tax[plturn];
    if (items.length != n) {
      output_error(`please select exactly ${n} cards`);
      return;
    }
    for (const item of items) {
      elem_from_to_top(item.key, otree[plturn].hand, otree.deck_discard);
    }
    ari_reorg_discard(otree);
    let [iturn, plnext] = ari_get_tax_payer(otree, otree.pl_tax, otree.iturn + 1);
    if (iturn == null) {
      otree.stage = 3;
      otree.iturn = 0;
      delete otree.pl_tax;
    } else {
      otree.iturn = iturn;
    }
    otree.plturn = otree.plorder[otree.iturn];
    turn_send_move_update(otree, plturn);
  } else if (stage == 3) {
    console.assert(false, 'NO SHOULD NOT COME TO POST STATE 3');
  } else if (stage == 4) {
    let selectedKeys = A.selected.map(i => A.items[i].key);
    for (const ckey of selectedKeys) {
      elem_from_to(ckey, otree[plturn].hand, otree[plturn].stall);
    }
    otree.round.push(plturn);
    if (is_round_over(otree)) {
      otree.round = [];
      let next = ari_select_next_player_according_to_stall_value(otree);
      if (!next) { ari_next_action(otree, plturn); return; }
    } else {
      otree.iturn++;
    }
    otree.plturn = otree.plorder[otree.iturn];
    turn_send_move_update(otree, plturn);
  } else if (stage == 6 && A.selected_key == 'trade') {
    if (A.selected.length != 2) {
      output_error('please, select exactly 2 cards!');
      return;
    }
    let i0 = A.items[A.selected[0]];
    let i1 = A.items[A.selected[1]];
    if (i0.path == i1.path) {
      output_error('you cannot trade cards from the same group');
      return;
    } else {
      a2_exchange_items(otree, i0, i1);
      ari_next_action(otree, plturn);
    }
  } else if (stage == 6 && A.selected_key == 'repair') {
    if (A.selected.length != 2) {
      output_error('please, select exactly 2 cards!');
      return;
    }
    let i0 = A.items[A.selected[0]];
    let i1 = A.items[A.selected[1]];
    let [p0, p1] = [i0.path, i1.path];
    if (p0.includes('build') == p1.includes('build')) {
      output_error('select exactly one building card and one of your hand or stall cards!');
      return;
    }
    a2_exchange_items(otree, i0, i1);
    console.log('repair items', i0, i1);
    let ibuilding = p0.includes('build') ? i0 : i1;
    let obuilding = lookup(otree, stringBeforeLast(ibuilding.path, '.').split('.'));
    console.log('obuilding', obuilding);
    obuilding.schwein = null;
    ari_next_action(otree, plturn);
  } else if (stage == 6 && A.command == 'build') {
    console.log('should have paid for building!', otree[plturn].coins);
    if (A.selected.length < 4 || A.selected.length > 6) {
      output_error('select 4, 5, or 6 cards to build!');
      return;
    }
    ari_complete_building();
  } else if (stage == 6 && A.command == 'upgrade') {
    let n = A.selected.length;
    if (n > 2 || n == 2 && !has_farm(plturn)) {
      output_error('too many cards selected!');
      return;
    } else if (n == 0) {
      output_error('please select hand or stall card(s) to upgrade!');
      return;
    }
    A.upgrade_cards = A.selected.map(x => A.items[x]);
    otree.stage = 102;
    let b_items = a2_get_farms_estates_items(plturn);
    a2_add_selection(b_items, 'buildings', 1, 1);
  } else if (stage == 102) {
    A.building = A.items[A.selected[0]];
    ari_complete_upgrade();
  } else if (stage == 6 && A.command == 'downgrade') {
    A.building = A.items[A.selected[0]];
    otree.stage = 103;
    let items = a2_get_hidden_building_items(A.building.o);
    items.map(x => face_up(x.o));
    A.possible_downgrade_cards = items;
    a2_add_selection(items, 'downgrade cards');
  } else if (stage == 103) {
    A.downgrade_cards = A.selected.map(x => A.items[x]);
    let obuilding = lookup(otree, A.building.path.split('.'));
    let n = obuilding.list.length;
    let nremove = A.downgrade_cards.length;
    let nfinal = n - nremove;
    let type = A.building.o.type;
    let list = otree[plturn].buildings[type];
    removeInPlace(list, obuilding);
    let cards = A.downgrade_cards.map(x => x.key);
    if (nfinal < 4) {
      otree[plturn].hand = otree[plturn].hand.concat(obuilding.list);
    } else if (nfinal == 4) {
      otree[plturn].buildings.farms.push(obuilding);
      otree[plturn].hand = otree[plturn].hand.concat(cards);
    } else if (nfinal == 5) {
      otree[plturn].buildings.estates.push(obuilding);
      otree[plturn].hand = otree[plturn].hand.concat(cards);
    } else if (nfinal == 6) {
      otree[plturn].buildings.chateaus.push(obuilding);
      otree[plturn].hand = otree[plturn].hand.concat(cards);
    }
    A.downgrade_cards.map(x => removeInPlace(obuilding.list, x.key));
    ari_next_action(otree, plturn);
  } else if (stage == 6 && A.command == 'buy') {
    let item = A.items[A.selected[0]];
    elem_from_to(item.key, otree.open_discard, otree[plturn].hand);
    ari_reorg_discard(otree);
    ari_next_action(otree, plturn);
  } else if (stage == 6 && A.command == 'visit') {
    let item = A.items[A.selected[0]];
    console.log('building to inspect', item);
    let obuilding = lookup(otree, item.path.split('.'));
    let owner = stringBefore(item.path, '.');
    if (isdef(obuilding.schwein)) {
      let res = confirm('destroy the building?');
      if (!res) {
        if (otree[owner].coins > 0) {
          otree[owner].coins -= 1;
          otree[plturn].coins += 1;
        }
      } else {
        let list = obuilding.list;
        console.log('!!!!!!!!!!!!!building', obuilding, 'DESTROY!!!!!!!!!!!!!!!!', '\nlist', list);
        let correct_key = list[0];
        let rank = correct_key[0];
        while (list.length > 0) {
          let ckey = list[0];
          if (ckey[0] != rank) {
            elem_from_to_top(ckey, list, otree.deck_discard);
          } else {
            elem_from_to(ckey, list, otree[owner].hand);
          }
        }
        if (isdef(obuilding.harvest)) {
          otree.deck_discard.unshift(obuilding.harvest);
        }
        ari_reorg_discard(otree);
        let blist = lookup(otree, stringBeforeLast(item.path, '.').split('.'));
        removeInPlace(blist, obuilding);
      }
    } else {
      let cards = item.o.items;
      let key = cards[0].rank;
      let schweine = false;
      let schwein = null;
      for (const c of cards) {
        if (c.rank != key) { schweine = true; schwein = c.key; face_up(c); break; }
      }
      if (schweine) {
        if (otree[owner].coins > 0) {
          otree[owner].coins--;
          otree[plturn].coins++;
        }
        let b = lookup(otree, item.path.split('.'));
        b.schwein = schwein;
      }
    }
    ari_next_action(otree, plturn);
  } else if (stage == 6 && A.selected_key == 'sell') {
    if (A.selected.length != 2) {
      output_error('select exactly 2 cards to sell!');
      return;
    }
    for (const i of A.selected) {
      let c = A.items[i].key;
      elem_from_to(c, otree[plturn].stall, otree.deck_discard);
    }
    ari_reorg_discard(otree);
    otree[plturn].coins += 1;
    ari_next_action(otree, plturn);
  } else if (stage == 6 && A.command == 'harvest') {
    let item = A.items[A.selected[0]];
    let obuilding = lookup(otree, item.path.split('.'));
    otree[plturn].hand.push(obuilding.h);
    obuilding.h = null;
    ari_next_action(otree, plturn);
  } else if (stage == 100) {
    console.log('pickup', A.selected_key, A.items, A.selected);
    let item = A.items[A.selected[0]];
    elem_from_to(item.key, otree[plturn].stall, otree[plturn].hand);
    ari_next_action(otree, plturn);
  } else if (A.selected_key == 'pass') {
    console.log('HAAAAAAAAAAAAAAAAAAAAAAAAAAAALLLLLLLLLLLLLLLLLLLLLLLLLOOOOOOOOOOOOOOOOO')
    otree.num_actions = 0;
    ari_next_action(otree, plturn);
  } else if (stage == 10) {
    if (A.selected_key == 'end game') {
      for (const uname of otree.plorder) {
        let [bcorrect, realvps] = ari_get_correct_buildings(otree[uname].buildings);
        otree[uname].score = realvps;
      }
      let scores = otree.plorder.map(x => ({ name: x, vps: otree[x].realvps }));
      let sorted = sortByDescending(scores, 'vps');
      ari_reveal_all_buildings(otree);
      otree.winner = sorted[0].name;
      turn_send_gameover(otree, plturn);
    } else {
      let iturn = otree.iturn += 1;
      if (iturn >= otree.pl_gameover.length) {
        delete otree.pl_gameover;
        otree.round = [];
        otree.iturn = 0;
        otree.stage = 3;
        otree.phase = 'queen';
        otree.plturn = otree.plorder[otree.iturn];
        turn_send_move_update(otree, plturn);
      } else {
        otree.plturn = otree.plorder[otree.iturn];
        turn_send_move_update(otree, plturn);
      }
    }
  } else if (stage == 11) {
    let keys = A.selected.map(x => A.items[x]).map(x => x.key);
    keys.map(x => lookupAddIfToList(otree, ['ball', plturn], x));
    keys.map(x => removeInPlace(otree[plturn].hand, x));
    let iturn = otree.iturn += 1;
    if (iturn >= otree.plorder.length) {
      if (isdef(otree.ball)) {
        let all = [];
        for (const c of otree.market) all.push(c);
        for (const uname in otree.ball) for (const c of otree.ball[uname]) all.push(c);
        shuffle(all);
        otree.market = [];
        for (let i = 0; i < 2; i++) top_elem_from_to(all, otree.market);
        for (const uname in otree.ball) for (let i = 0; i < otree.ball[uname].length; i++) top_elem_from_to(all, otree[uname].hand);
        delete otree.ball;
      }
      otree.round = [];
      otree.iturn = 0;
      otree.stage = 4;
      otree.phase = 'queen';
    }
    otree.plturn = otree.plorder[otree.iturn];
    turn_send_move_update(otree, plturn);
  } else if (stage == 12) {
    let keys = A.selected.map(x => A.items[x]);
    keys.map(x => lookupAddIfToList(otree, ['auction', plturn], x));
    let iturn = otree.iturn += 1;
    if (iturn >= otree.plorder.length) {
      let list = dict2list(otree.auction);
      list.map(x => { x.uname = x.id; x.item = x.value[0]; x.amount = Number(x.item.a); });
      list = sortByDescending(list, 'amount');
      let max = list[0].amount;
      let second = otree.second_most = list[1].amount;
      otree.stage = 13;
      let maxplayers = otree.maxplayers = list.filter(x => x.amount == max).map(x => x.uname);
      otree.round = arrMinus(otree.plorder, maxplayers);
      otree.iturn = otree.plorder.indexOf(maxplayers[0]);
    }
    otree.plturn = otree.plorder[otree.iturn];
    turn_send_move_update(otree, plturn);
  } else if (stage == 13) {
    let item = A.selected.map(x => A.items[x])[0];
    lookupSet(otree, ['buy', plturn], item);
    for (const uname of otree.maxplayers) {
      if (!lookup(otree, ['buy', uname])) {
        otree.iturn = otree.plorder.indexOf(uname);
        otree.plturn = otree.plorder[otree.iturn];
        turn_send_move_update(otree, plturn);
        return;
      }
    }
    let buylist = dict2list(otree.buy);
    let discardlist = [];
    for (const uname of otree.maxplayers) {
      let choice = otree.buy[uname];
      let is_unique = !firstCond(buylist, x => x.id != uname && x.value == choice);
      if (is_unique) {
        otree[uname].coins -= otree.second_most;
        elem_from_to(choice.key, otree.market, otree[uname].hand);
      } else addIf(discardlist, choice);
    }
    for (const choice of discardlist) {
      elem_from_to(choice.key, otree.market, otree.deck_discard);
      ari_reorg_discard(otree);
    }
    otree.iturn = 0;
    otree.stage = 4;
    otree.round = [];
    otree.plturn = otree.plorder[otree.iturn];
    turn_send_move_update(otree, plturn);
  }
}
function ari_pre_action() {
  let [stage, A, fen, phase, uplayer, deck, market] = [Z.stage, Z.A, Z.fen, Z.phase, Z.uplayer, Z.deck, Z.market];
  if (Z.num_actions > 0) fen.progress = `(action ${Z.action_number} of ${Z.total_pl_actions})`; else delete fen.progress;
  show_stage();
  switch (ARI.stage[stage]) {
    case 'action: command': Z.stage = 6; select_add_items(ui_get_commands(uplayer), process_command, 'must select an action', 1, 1); break;
    case 'action step 2':
      switch (A.command) {
        case 'trade': select_add_items(ui_get_trade_items(uplayer), post_trade, 'must select 2 cards to trade', 2, 2); break;
        case 'build': select_add_items(ui_get_payment_items('K'), payment_complete, 'must select payment for building', 1, 1); break;
        case 'upgrade': select_add_items(ui_get_payment_items('K'), payment_complete, 'must select payment for upgrade', 1, 1); break;
        case 'downgrade': select_add_items(ui_get_building_items(uplayer, A.payment), process_downgrade, 'must select a building to downgrade', 1, 1); break;
        case 'pickup': select_add_items(ui_get_stall_items(uplayer), post_pickup, 'must select a stall card to take into your hand', 1, 1); break;
        case 'harvest': select_add_items(ui_get_harvest_items(uplayer), post_harvest, 'must select a farm to harvest from', 1, 1); break;
        case 'sell': select_add_items(ui_get_stall_items(uplayer), post_sell, 'must select 2 stall cards to sell', 2, 2); break;
        case 'buy': select_add_items(ui_get_payment_items('J'), payment_complete, 'must select payment option', 1, 1); break;
        case 'buy rumor': ari_open_rumors(); break;
        case 'exchange': select_add_items(ui_get_exchange_items(uplayer), post_exchange, 'must select cards to exchange', 2, 2); break;
        case 'visit': select_add_items(ui_get_payment_items('Q'), payment_complete, 'must select payment for visiting', 1, 1); break;
        case 'rumor': select_add_items(ui_get_other_buildings_and_rumors(uplayer), process_rumor, 'must select a building and a rumor card to place', 2, 2); break;
        case 'inspect': select_add_items(ui_get_other_buildings(uplayer), process_inspect, 'must select building to visit', 1, 1); break;
        case 'blackmail': select_add_items(ui_get_payment_items('Q'), payment_complete, 'must select payment for blackmailing', 1, 1); break;
        case 'commission': select_add_items(ui_get_commission_items(uplayer), process_commission, 'must select a card to commission', 1, 1); break;
        case 'pass': post_pass(); break;
      }
      break;
    case 'pick_schwein': select_add_items(ui_get_schweine_candidates(A.uibuilding), post_inspect, 'must select the new schwein', 1, 1); break;
    case 'comm_weitergeben': if (!is_playerdata_set(uplayer)) select_add_items(ui_get_all_commission_items(uplayer), process_comm_setup, `must select ${fen.comm_setup_num} card${fen.comm_setup_num > 1 ? 's' : ''} to discard`, fen.comm_setup_num, fen.comm_setup_num); break;
    case 'rumors_weitergeben':
      let rumitems = ui_get_rumors_and_players_items(uplayer);
      if (isEmpty(rumitems)) {
        show_waiting_message('waiting for other players...');
        Z.state = null;
        let done = rumor_playerdata_complete();
        if (done) {
          Z.turn = [Z.host];
          Z.stage = 105; //'next_rumors_setup_stage';
          clear_transaction();
          take_turn_fen();
        } else autopoll();
      } else select_add_items(rumitems, process_rumors_setup, `must select a player and a rumor to pass on`, 2, 2);
      break;
    case 'next_rumor_setup_stage': post_rumor_setup(); break;
    case 'buy rumor': select_add_items(ui_get_top_rumors(), post_buy_rumor, 'must select one of the new rumor cards', 1, 1); break;
    case 'rumor discard': select_add_items(ui_get_rumors_items(uplayer), process_rumor_discard, 'must select a rumor card to discard', 1, 1); break;
    case 'rumor_both': select_add_items(ui_get_top_rumors(), post_rumor_both, 'must select one of the new rumor cards', 1, 1); break;
    case 'blackmail': select_add_items(ui_get_other_buildings_with_rumors(uplayer), process_blackmail, 'must select a building to blackmail', 1, 1); break;
    case 'blackmail_owner': select_add_items(ui_get_blackmailed_items(), being_blackmailed, 'must react to BLACKMAIL!!!', 1, 1); break;
    case 'accept_blackmail': select_add_items(ui_get_stall_items(uplayer), post_accept_blackmail, 'must select a card to pay off blackmailer', 1, 1); break;
    case 'blackmail_complete': post_blackmail(); break;
    case 'journey': select_add_items(ui_get_hand_and_journey_items(uplayer), process_journey, 'may form new journey or add cards to existing one'); break;
    case 'add new journey': post_new_journey(); break;
    case 'auto market': ari_open_market(fen, phase, deck, market); break;
    case 'TEST_starts_in_stall_selection_complete':
      if (is_stall_selection_complete()) {
        delete fen.stallSelected;
        fen.actionsCompleted = [];
        if (check_if_church()) ari_start_church_stage(); else ari_start_action_stage();
      } else select_add_items(ui_get_hand_items(uplayer), post_stall_selected, 'must select your stall'); break;
    case 'stall selection': select_add_items(ui_get_hand_items(uplayer), post_stall_selected, 'must select cards for stall'); break;
    case 'church': select_add_items(ui_get_hand_and_stall_items(uplayer), post_tithe, `must select cards to tithe ${isdef(fen.tithemin) ? `(current minimum is ${fen.tithemin})` : ''}`, 1, 100); break;
    case 'church_minplayer_tithe_add': select_add_items(ui_get_hand_and_stall_items(uplayer), post_tithe_minimum, `must select cards to reach at least ${fen.tithe_minimum}`, 1, 100); break;
    case 'church_minplayer_tithe_downgrade': select_add_items(ui_get_building_items(uplayer, A.payment), process_downgrade, 'must select a building to downgrade', 1, 1); break;
    case 'church_minplayer_tithe': console.log('NOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO');
      let pl = fen.players[uplayer];
      let hst = pl.hand.concat(pl.stall);
      let vals = hst.map(x => ari_get_card(x).val);
      let sum = arrSum(vals);
      let min = fen.tithe_minimum;
      if (sum < min) {
        ari_history_list([`${uplayer} must downgrade a building to tithe ${min}!`], 'downgrade');
        select_add_items(ui_get_building_items(uplayer, A.payment), process_downgrade, 'must select a building to downgrade', 1, 1);
      } else {
        ari_history_list([`${uplayer} must tithe more cards to reach ${min}!`], 'tithe');
        select_add_items(ui_get_hand_and_stall_items(uplayer), post_tithe_minimum, `must select cards to reach at least ${fen.tithe_minimum}`, 1, 100);
      }
      break;
    case 'church_newcards':
      reveal_church_cards();
      let items = ui_get_church_items(uplayer);
      let num_select = items.length == fen.church.length ? 1 : 2;
      let instr = num_select == 1 ? `must select a card for ${fen.candidates[0]}` : 'must select card and player';
      select_add_items(items, post_church, instr, num_select, num_select);
      break;
    case 'complementing_market_after_church':
      select_add_items(ui_get_hand_items(uplayer), post_complementing_market_after_church, 'may complement stall'); break;
    case 'tax': let n = fen.pl_tax[uplayer]; select_add_items(ui_get_hand_items(uplayer), post_tax, `must pay ${n} card${if_plural(n)} tax`, n, n); break;
    case 'build': select_add_items(ui_get_build_items(uplayer, A.payment), post_build, 'must select cards to build (first card determines rank)', 4, 6, true); break;
    case 'commission_stall': select_add_items(ui_get_commission_stall_items(), process_commission_stall, 'must select matching stall card to discard', 1, 1); break;
    case 'commission new': select_add_items(ui_get_commission_new_items(uplayer), post_commission, 'must select a new commission', 1, 1); break;
    case 'upgrade': select_add_items(ui_get_build_items(uplayer, A.payment), process_upgrade, 'must select card(s) to upgrade a building', 1); break;
    case 'select building to upgrade': select_add_items(ui_get_farms_estates_items(uplayer), post_upgrade, 'must select a building', 1, 1); break;
    case 'select downgrade cards': select_add_items(A.possible_downgrade_cards, post_downgrade, 'must select card(s) to downgrade a building', 1, is_in_middle_of_church() ? 1 : 100); break;
    case 'buy': select_add_items(ui_get_open_discard_items(uplayer, A.payment), post_buy, 'must select a card to buy', 1, 1); break;
    case 'visit': select_add_items(ui_get_other_buildings(uplayer, A.payment), process_visit, 'must select a building to visit', 1, 1); break;
    case 'visit destroy': select_add_items(ui_get_string_items(['destroy', 'get cash']), post_visit, 'must destroy the building or select the cash', 1, 1); break;
    case 'ball': select_add_items(ui_get_hand_items(uplayer), post_ball, 'may add cards to the ball'); break;
    case 'auction: bid': select_add_items(ui_get_coin_amounts(uplayer), process_auction, 'must bid for the auction', 1, 1); break;
    case 'auction: buy': select_add_items(ui_get_market_items(), post_auction, 'must buy a card', 1, 1); break;
    case 'end game?': select_add_items(ui_get_endgame(uplayer), post_endgame, 'may end the game here and now or go on!', 1, 1); break;
    case 'pick luxury or journey cards': select_add_items(ui_get_string_items(['luxury cards', 'journey cards']), post_luxury_or_journey_cards, 'must select luxury cards or getting cards from the other end of the journey', 1, 1); break;
    case 'next_comm_setup_stage': select_confirm_weiter(post_comm_setup_stage); break;
    default: console.log('stage is', stage); break;
  }
}
function ari_present(dParent) {
  let [fen, ui, uplayer, stage, pl] = [Z.fen, UI, Z.uplayer, Z.stage, Z.pl];
  let [dOben, dOpenTable, dMiddle, dRechts] = tableLayoutMR(dParent);
  if (fen.num_actions > 0 && (Z.role == 'active' || Z.mode == 'hotseat')) {
    mStyle(dOben, { hmin: 110 })
  }
  ari_stats(dRechts);
  show_history(fen, dRechts);
  let deck = ui.deck = ui_type_deck(fen.deck, dOpenTable, { maleft: 12 }, 'deck', 'deck', ari_get_card);
  let market = ui.market = ui_type_market(fen.market, dOpenTable, { maleft: 12 }, 'market', 'market', ari_get_card, true);
  let open_discard = ui.open_discard = ui_type_market(fen.open_discard, dOpenTable, { maleft: 12 }, 'open_discard', 'discard', ari_get_card);
  let deck_discard = ui.deck_discard = ui_type_deck(fen.deck_discard, dOpenTable, { maleft: 12 }, 'deck_discard', '', ari_get_card);
  if (exp_commissions(Z.options)) {
    let open_commissions = ui.open_commissions = ui_type_market(fen.open_commissions, dOpenTable, { maleft: 12 }, 'open_commissions', 'bank', ari_get_card);
    mMagnifyOnHoverControlPopup(ui.open_commissions.cardcontainer);
    let deck_commission = ui.deck_commission = ui_type_deck(fen.deck_commission, dOpenTable, { maleft: 4 }, 'deck_commission', '', ari_get_card);
    let comm = ui.commissioned = ui_type_rank_count(fen.commissioned, dOpenTable, {}, 'commissioned', 'sentiment', ari_get_card);
    if (comm.items.length > 0) { let isent = arrLast(comm.items); let dsent = iDiv(isent); set_card_border(dsent, 15, 'green'); }
  }
  if (exp_church(Z.options)) {
    let church = ui.church = ui_type_church(fen.church, dOpenTable, { maleft: 28 }, 'church', 'church', ari_get_card);
  }
  if (exp_rumors(Z.options)) {
    let deck_rumors = ui.deck_rumors = ui_type_deck(fen.deck_rumors, dOpenTable, { maleft: 25 }, 'deck_rumors', 'rumors', ari_get_card);
  }
  let uname_plays = fen.plorder.includes(Z.uname);
  let show_first = uname_plays && Z.mode == 'multi' ? Z.uname : uplayer;
  let order = get_present_order();
  for (const plname of order) {
    let pl = fen.players[plname];
    let playerstyles = { w: '100%', bg: '#ffffff80', fg: 'black', padding: 4, margin: 4, rounding: 9, border: `2px ${get_user_color(plname)} solid` };
    let d = mDiv(dMiddle, playerstyles, null, get_user_pic_html(plname, 25));
    mFlexWrap(d);
    mLinebreak(d, 9);
    let hidden = compute_hidden(plname);
    ari_present_player(plname, d, hidden);
  }
  ari_show_handsorting_buttons_for(Z.mode == 'hotseat' ? Z.uplayer : Z.uname); delete Clientdata.handsorting;
  show_view_buildings_button(uplayer);
  let desc = ARI.stage[Z.stage];
  Z.isWaiting = false;
  if (isdef(fen.winners)) ari_reveal_all_buildings(fen);
  else if (desc == 'comm_weitergeben' && is_playerdata_set(uplayer)) {
    if ((Z.mode == 'hotseat' || Z.host == uplayer) && check_resolve()) {
      Z.turn = [Z.host];
      Z.stage = 104; //'next_comm_setup_stage';
    }
    show_waiting_message(`waiting for other players...`);
    Z.isWaiting = true;
  }
}
function ari_present_player(plname, d, ishidden = false) {
  let fen = Z.fen;
  let pl = fen.players[plname];
  let ui = UI.players[plname] = { div: d };
  let hand = ui.hand = ui_type_hand(pl.hand, d, {}, `players.${plname}.hand`, 'hand', ari_get_card);
  if (ishidden) { hand.items.map(x => face_down(x)); }
  let stall = ui.stall = ui_type_market(pl.stall, d, { maleft: 12 }, `players.${plname}.stall`, 'stall', ari_get_card);
  if (fen.stage < 5 && ishidden) { stall.items.map(x => face_down(x)); }
  if (exp_commissions(Z.options)) {
    if (!ishidden) pl.commissions = correct_handsorting(pl.commissions, plname);
    ui.commissions = ui_type_market(pl.commissions, d, { maleft: 12 }, `players.${plname}.commissions`, 'commissions', Z.stage == 23 ? ari_get_card_large : ari_get_card);
    if (ishidden) { ui.commissions.items.map(x => face_down(x)); }
    else mMagnifyOnHoverControlPopup(ui.commissions.cardcontainer);
  }
  if (exp_rumors(Z.options)) {
    if (!ishidden) pl.rumors = correct_handsorting(pl.rumors, plname);
    ui.rumors = ui_type_market(pl.rumors, d, { maleft: 12 }, `players.${plname}.rumors`, 'rumors', Z.stage == 24 ? ari_get_card_large : ari_get_card);
    if (ishidden) { ui.rumors.items.map(x => face_down(x)); }
    else mMagnifyOnHoverControlPopup(ui.rumors.cardcontainer);
  }
  ui.journeys = [];
  let i = 0;
  for (const j of pl.journeys) {
    let jui = ui_type_hand(j, d, { maleft: 12 }, `players.${plname}.journeys.${i}`, '', ari_get_card);
    i += 1;
    ui.journeys.push(jui);
  }
  mLinebreak(d, 8);
  ui.buildinglist = [];
  ui.indexOfFirstBuilding = arrChildren(d).length;
  for (const k in pl.buildings) {
    let i = 0;
    for (const b of pl.buildings[k]) {
      let type = k;
      let b_ui = ui_type_building(b, d, { maleft: 8 }, `players.${plname}.buildings.${k}.${i}`, type, ari_get_card, true, ishidden);
      b_ui.type = k;
      ui.buildinglist.push(b_ui);
      if (b.isblackmailed) { mStamp(b_ui.cardcontainer, 'blackmail'); }
      lookupAddToList(ui, ['buildings', k], b_ui);
      i += 1;
    }
  }
}
function ari_redo_player_stats(otree, uname) {
  let item = G.player_stat_items[uname];
  let d = iDiv(item);
  let stall_value = otree[uname].stall_value;
  mRemoveChildrenFromIndex(d, otree.herald == uname ? 3 : 2);
  let pl = otree[uname];
  player_stat_count('coin', pl.coins, d);
  if (isdef(stall_value)) { player_stat_count('shinto shrine', stall_value, d); }
  player_stat_count('star', ari_get_vps(otree, uname), d);
}
function ari_redo_player_ui(otree, plturn) {
  let d = G[plturn].hand.container.parentNode;
  d.innerHTML = plturn;
  ari_present_player(otree, plturn, d);
}
function ari_refill_deck(fen) {
  fen.deck = fen.deck.concat(fen.open_discard).concat(fen.deck_discard);
  shuffle(fen.deck);
  fen.open_discard = [];
  fen.deck_discard = [];
  console.log('deck refilled: contains', fen.deck.length, 'cards');
}
function ari_reorg_discard() {
  let fen = Z.fen;
  while (fen.deck_discard.length > 0 && fen.open_discard.length < 4) {
    bottom_elem_from_to(fen.deck_discard, fen.open_discard);
  }
}
function ari_reveal_all_buildings(fen) {
  for (const plname of fen.plorder) {
    let gbs = UI.players[plname].buildinglist;
    for (const gb of gbs) {
      gb.items.map(x => face_up(x));
    }
  }
}
function ari_select_next_player_according_to_stall_value() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  Z.stage = 5;
  let minval = 100000;
  let minplayer = null;
  for (const uname of fen.plorder) {
    if (fen.actionsCompleted.includes(uname)) continue;
    let stall = fen.players[uname].stall;
    if (isEmpty(stall)) { fen.actionsCompleted.push(uname); continue; }
    let val = fen.players[uname].stall_value = arrSum(stall.map(x => ari_get_card(x).val));
    if (val < minval) { minval = val; minplayer = uname; }
  }
  if (!minplayer) {
    return null;
  } else {
    Z.turn = fen.turn = [minplayer];
    fen.num_actions = fen.total_pl_actions = fen.players[minplayer].stall.length;
    fen.action_number = 1;
    return minplayer;
  }
}
function ari_setup(player_names) {
  let pre_fen = {};
  let deck = pre_fen.deck = get_keys(Aristocards).filter(x => 'br'.includes(x[2]));
  shuffle(deck);
  pre_fen.market = [];
  pre_fen.deck_discard = [];
  pre_fen.open_discard = [];
  let pls = pre_fen.players = {};
  for (const plname of player_names) {
    let pl = pls[plname] = {
      hand: deck_deal(deck, 7),
      buildings: { farms: [], estates: [], chateaus: [] },
      stall: [],
      stall_value: 0,
      coins: 3,
      vps: 0,
      score: 0,
    };
  }
  pre_fen.plorder = jsCopy(player_names);
  pre_fen.herald = player_names[0];
  pre_fen.phase = 'king';
  pre_fen.stage = 3;
  pre_fen.iturn = 0;
  pre_fen.plturn = pre_fen.plorder[pre_fen.iturn];
  pre_fen.round = [];
  pre_fen.step = 0;
  let fen = pre_fen;
  return fen;
}
function ari_show_building(otree, uname, building_cards) {
  DA.qanim = [
    [anim_from_deck_to_marketX, [deck, market]],
    [anim_from_deck_to_marketX, [deck, market]],
    [update_otree_from_ui, [otree, { deck: deck, market: market }]],
    [ari_pre_action, []],
  ];
  qanim();
}
function ari_show_deck(list, dParent) {
  let id = getUID('u');
  let d = mDiv(dParent, { bg: 'random', padding: 10 }, id);
  console.log('list', list);
  let items = list.map(x => ari_get_card(x));
  let [w, h] = [items[0].w, items[0].h];
  console.log('cards', w, h, items);
  items.map(x => mAppend(d, iDiv(x)));
  mContainerSplay(d, splay, w, h, items.length, 20);
  items.map(x => mItemSplay(x, list, splay));
  return d;
}
function ari_show_handsorting_buttons_for(plname) {
  if (Z.role == 'spectator' || isdef(mBy('dHandButtons'))) return;
  let fen = Z.fen;
  let pl = fen.players[plname];
  if (pl.hand.length <= 1) return;
  let d = UI.players[plname].hand.container; mStyle(d, { position: 'relative' });
  let dHandButtons = mDiv(d, { position: 'absolute', bottom: -2, left: 52, height: 25 }, 'dHandButtons');
  show_player_button('sort', dHandButtons, onclick_by_rank);
}
function ari_start_action_stage() {
  let next = ari_select_next_player_according_to_stall_value();
  if (!next) { ari_next_phase(); }
  take_turn_fen();
}
function ari_start_church_stage() {
  let [fen] = [Z.fen];
  let order = fen.plorder = fen.church_order = determine_church_turn_order();
  [Z.turn, Z.stage] = [[order[0]], 17];
  ari_history_list([`inquisition starts!`], 'church');
  take_turn_fen();
}
function ari_state(dParent) {
  function get_phase_html() {
    if (isEmpty(Z.phase) || Z.phase == 'over') return null;
    let rank = Z.phase[0].toUpperCase();
    let card = ari_get_card(rank + 'Hn', 40);
    let d = iDiv(card);
    mClassRemove(d.firstChild, 'card');
    return iDiv(card).outerHTML;
  }
  if (DA.TEST0 == true) {
    let html = `${Z.stage}`;
    if (isdef(Z.playerdata)) {
      let trigger = get_multi_trigger();
      if (trigger) html += ` trigger:${trigger}`;
      for (const data of Z.playerdata) {
        if (data.name == trigger) continue;
        let name = data.name;
        let state = data.state;
        let s_state = object2string(state);
        html += ` ${name}:'${s_state}'`;
      }
      dParent.innerHTML += ` ${Z.playerdata.map(x => x.name)}`;
    }
    dParent.innerHTML = html;
    return;
  }
  let user_html = get_user_pic_html(Z.uplayer, 30);
  let phase_html = get_phase_html();
  let html = '';
  if (phase_html) html += `${Z.phase}:&nbsp;${phase_html}`;
  if (Z.stage == 17) { html += `&nbsp;&nbsp;CHURCH EVENT!!!`; }
  else if (TESTING) { html += `&nbsp;&nbsp;&nbsp;stage: ${ARI.stage[Z.stage]}`; }
  else html += `&nbsp;player: ${user_html} `;
  dParent.innerHTML = html;
}
function ari_stats(dParent) {
  let player_stat_items = UI.player_stat_items = ui_player_info(dParent);
  let fen = Z.fen;
  let herald = fen.heraldorder[0];
  for (const plname in fen.players) {
    let pl = fen.players[plname];
    let item = player_stat_items[plname];
    let d = iDiv(item); mCenterFlex(d); mLinebreak(d);
    if (plname == herald) {
      mSym('tied-scroll', d, { fg: 'gold', fz: 24, padding: 4 }, 'TR');
    }
    if (exp_church(Z.options)) {
      if (isdef(pl.tithes)) {
        player_stat_count('cross', pl.tithes.val, d);
      }
    }
    let dCoin = player_stat_count('coin', pl.coins, d);
    item.dCoin = dCoin.firstChild;
    item.dAmount = dCoin.children[1];
    let list = pl.hand.concat(pl.stall);
    let list_luxury = list.filter(x => x[2] == 'l');
    player_stat_count('pinching hand', list.length, d);
    let d1 = player_stat_count('hand-holding-usd', list_luxury.length, d);
    mStyle(d1.firstChild, { fg: 'gold', fz: 20 })
    if (!isEmpty(fen.players[plname].stall) && fen.stage >= 5 && fen.stage <= 6) {
      player_stat_count('shinto shrine', !fen.actionsCompleted.includes(plname) || fen.stage < 6 ? calc_stall_value(fen, plname) : '_', d);
    }
    player_stat_count('star', plname == U.name || isdef(fen.winners) ? ari_calc_real_vps(fen, plname) : ari_calc_fictive_vps(fen, plname), d);
    if (fen.turn.includes(plname)) {
      show_hourglass(plname, d, 30, { left: -3, top: 0 }); //'calc( 50% - 36px )' });
    }
  }
}
function ari_tax_phase_needed(fen) {
  let pl_tax = {};
  let need_tax_phase = false;
  for (const uplayer of fen.plorder) {
    let hsz = fen.players[uplayer].hand.length;
    let nchateaus = fen.players[uplayer].buildings.chateau.length;
    let allowed = ARI.sz_hand + nchateaus;
    let diff = hsz - allowed;
    if (diff > 0) need_tax_phase = true;
    pl_tax[uplayer] = diff;
  }
  if (need_tax_phase) {
    fen.turn = [ari_get_first_tax_payer(fen, pl_tax)];
    fen.pl_tax = pl_tax;
    fen.stage = 2;
    return true;
  } else {
    fen.stage = 3;
    return false;
  }
}
function ari_test_hand_to_discard(fen, uname, keep = 0) {
  let list = fen.players[uname].hand;
  while (fen.open_discard.length < 4 && list.length > keep) top_elem_from_to(list, fen.open_discard);
  while (list.length > keep) top_elem_from_to(list, fen.deck_discard);
}
function ari_ui_player(otree, uname, dParent) {
  let dPlayer = ui_make_player(otree, uname, dParent);
  let dHand = ari_make_cardlist(otree[uname].hand, 2, dPlayer);
}
function ari_ut0_create_staged() {
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  for (const uname in fen.players) {
    let pl = fen.players[uname];
    while (!isEmpty(pl.hand)) last_elem_from_to(pl.hand, fen.deck);
  }
  fen.players.mimi.hand = 'AHb ADb 2Cb 4Cb 6Cb KCb QDb'.split(' ');
  fen.players.leo.hand = 'ACb ASb 2Db 4Db 6Db KDb QSb'.split(' ');
  fen.players.mimi.buildings.farms = [{ list: '4Cr 4Sr 4Sb 4Dr'.split(' '), h: null }, { list: '5Cr 5Sr 5Sb 5Dr'.split(' '), h: null }];
  fen.players.mimi.buildings.estates = [{ list: 'TCr TSr TSb TDr TDb'.split(' '), h: null }];
  DA.staged_moves = [];
  DA.iter = 100;
  return [fen, player_names];
}
function ari_ut1_create_staged() {
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  top_elem_from_to(fen.deck, fen.market);
  top_elem_from_to(fen.deck, fen.market);
  fen.stage = 4;
  top_elem_from_to(fen.players.mimi.hand, fen.players.mimi.stall);
  top_elem_from_to(fen.players.mimi.hand, fen.players.mimi.stall);
  fen.iturn = 1;
  fen.plturn = 'leo';
  fen.round = ['mimi'];
  DA.staged_moves = [];
  DA.iter = 100;
  return [fen, player_names];
}
function ari_ut10_create_staged() {
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  DA.staged_moves = [];
  DA.iter = 100;
  return [fen, player_names];
}
function ari_ut100_create_staged() {
  console.log('*** test 100: tax ***');
  TestNumber = 100;
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'amanda', 'felix', 'lauren', 'blade'];
  let fen = ari_setup(player_names);
  ari_test_hand_to_discard(fen, 'mimi');
  deck_add(fen.deck, 3, fen.players.amanda.hand);
  ari_test_hand_to_discard(fen, 'felix', 3);
  deck_add(fen.deck, 1, fen.players.blade.hand);
  let sz = ARI.sz_hand;
  fen.pl_tax = { mimi: -sz, amanda: 3, felix: -sz + 3, lauren: 0, blade: 1 };
  [fen.iturn, fen.plturn] = [1, 'amanda'];
  fen.stage = 2;
  DA.fen0 = fen;
  DA.staged_moves = [];
  DA.iter = 100;
  DA.iter_verify = 3;
  DA.verify = (ot) => {
    let res = forAll(ot.plorder, x => ot[x].hand.length <= sz);
    if (!res) for (const uname of ot.plorder) console.log('pl', uname, 'hand', ot[uname].hand.length, 'should be', Math.min(sz, DA.fen0.players[uname].hand.length));
    return res;
  };
  DA.auto_moves = {
    amanda_1: [[0, 1, 2]],
    blade_2: [[0]],
  }
  return [fen, player_names];
}
function ari_ut101_create_staged() {
  console.log('*** test 101: stall selection 5 players ***');
  TestNumber = 101;
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'amanda', 'felix', 'lauren', 'blade'];
  let fen = ari_setup(player_names);
  ari_test_hand_to_discard(fen, 'mimi');
  ari_test_hand_to_discard(fen, 'felix');
  fen.stage = 3;
  DA.fen0 = fen;
  DA.staged_moves = [];
  DA.iter = 100;
  DA.iter_verify = 6;
  DA.verify = (ot) => {
    let stall_sz = { mimi: 0, amanda: 3, felix: 0, lauren: 1, blade: 2 };
    let res = forAll(ot.plorder, x => ot[x].stall.length == stall_sz[x]);
    if (!res) for (const uname of ot.plorder) console.log('pl', uname, 'stall', ot[uname].stall.length, 'should be', stall_sz[uname]);
    return res;
  };
  DA.auto_moves = {
    amanda_2: [[0, 1, 2]],
    lauren_4: [[0]],
    blade_5: [[0, 1]],
  }
  return [fen, player_names];
}
function ari_ut102_create_staged() {
  console.log('*** test 102: stall selection mimi-leo ***');
  TestNumber = 102;
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  ari_test_hand_to_discard(fen, 'mimi');
  fen.stage = 3;
  DA.fen0 = fen;
  DA.iter_verify = 3;
  DA.verify = (ot) => {
    let stall_sz = { mimi: 0, leo: 3 };
    let res = forAll(ot.plorder, x => ot[x].stall.length == stall_sz[x]);
    if (!res) for (const uname of ot.plorder) console.log('pl', uname, 'stall', ot[uname].stall.length, 'should be', stall_sz[uname]);
    return res;
  };
  DA.auto_moves = {
    leo_2: [[0, 1, 2]],
  };
  return [fen, player_names];
}
function ari_ut103_create_staged() {
  console.log('*** test 103: trade ***');
  TestNumber = 103;
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  arisim_stage_3(fen);
  arisim_stage_4_all_mimi_starts(fen, 2);
  DA.fen0 = fen;
  DA.auto_moves = {
    mimi_1: [['trade'], [1, 3]],
    mimi_2: [['pass']],
    leo_3: [['trade'], [1, 3]],
    leo_4: [['pass']],
  };
  DA.iter_verify = 5;
  DA.verify = (ot) => {
    let res = firstCond(ot.mimi.hand, x => x == DA.fen0.market[1]);
    if (!res) console.log('mimi stall does not contain market card from start!!!');
    return res;
  };
  return [fen, player_names];
}
function ari_ut104_create_staged() {
  console.log('*** test 104: downgrade from estate to farm ***');
  TestNumber = 104;
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  arisim_stage_3(fen);
  arisim_stage_4_all_mimi_starts(fen);
  stage_building(fen, fen.iturn, 'estate');
  DA.fen0 = fen;
  DA.iter_verify = 2;
  DA.verify = (ot) => {
    let stall_sz = { mimi: 0, leo: 3 };
    let res = ot.mimi.buildings.farms.length == 1 && ot.mimi.buildings.estates.length == 0;
    if (!res) console.log('mimi buildings', ot.mimi.buildings);
    return res;
  };
  DA.auto_moves = {
    mimi_1: [['downgrade'], [0]],
  };
  return [fen, player_names];
}
function ari_ut105_create_staged() {
  console.log('*** test 105: visit ***');
  TestNumber = 105;
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo', 'meckele'];
  let fen = ari_setup(player_names);
  arisim_stage_3(fen);
  arisim_stage_4_all_mimi_starts(fen);
  stage_replace_hand_cards_by(fen, 'mimi', ['QSy']);
  stage_building(fen, fen.iturn, 'estate');
  stage_building(fen, 1, 'estate');
  stage_building(fen, 2, 'estate');
  fen.phase = 'queen';
  DA.fen0 = fen;
  DA.iter_verify = 2;
  DA.verify = (ot) => {
    let uname_visited = ot.plturn;
    let building = ot[uname_visited].buildings.estates[0];
    let res = ot.mimi.coins == 2 || ot.mimi.coins == 4 || ot.mimi.hand.length + ot.mimi.stall.length == 6;
    if (!res) console.log('mimi visit payment did not work!', building.list);
    return res;
  };
  DA.auto_moves = {
    mimi_1: [['visit'], [0], [0], ['pass']],
  };
  return [fen, player_names];
}
function ari_ut106_create_staged() {
  console.log('*** test 106: double visit ***');
  TestNumber = 106;
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo', 'meckele'];
  let fen = ari_setup(player_names);
  arisim_stage_3(fen);
  arisim_stage_4_all_mimi_starts(fen);
  stage_replace_hand_cards_by(fen, 'mimi', ['QSy', 'QSg']);
  stage_building(fen, fen.iturn, 'estate');
  stage_building(fen, 1, 'chateau');
  stage_building(fen, 2, 'chateau');
  fen.phase = 'queen';
  DA.fen0 = fen;
  DA.auto_moves = {
    mimi_1: [['visit'], [0], [0]],
    mimi_2: [['visit'], [0], [0]],
  };
  DA.iter_verify = 3;
  DA.verify = (ot) => {
    let uname_visited = ot.plorder[1];
    let chateaus = ot[uname_visited].buildings.chateaus;
    console.log('chateaus:', uname_visited, chateaus);
    let res = ot.mimi.coins == 5 || ot[uname_visited].buildings.chateaus.length == 0;
    if (!res) console.log('double visit failed or building is correct!!!');
    return res;
  };
  return [fen, player_names];
}
function ari_ut107_create_staged() {
  console.log('*** test 107: end game ***');
  TestNumber = 107;
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  arisim_stage_3(fen);
  arisim_stage_4_all_mimi_starts(fen);
  stage_correct_buildings(fen, { mimi: { farms: 2, estates: 2, chateaus: 1 }, leo: { farms: 3 } });
  DA.fen0 = fen;
  DA.auto_moves = {
    mimi_1: [['pass']],
    leo_2: [['pass']],
    3: [[0]],
  };
  DA.iter_verify = 4;
  DA.verify = (ot) => {
    let res = ot.winner = 'mimi';
    if (!res) console.log('end game mimi should win didnt work!', ot);
    return res;
  };
  return [fen, player_names];
}
function ari_ut108_create_staged() {
  console.log('*** test 108: buy from open discard ***');
  TestNumber = 108;
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  fen.open_discard = deck_deal(fen.deck, 4);
  arisim_stage_3(fen);
  arisim_stage_4_all_mimi_starts(fen);
  stage_correct_buildings(fen, { mimi: { farms: 2, estates: 2, chateaus: 1 }, leo: { farms: 3 } });
  fen.phase = 'jack';
  DA.fen0 = fen;
  DA.auto_moves = {
    mimi_1: [['buy'], [0], [0]],
  };
  DA.iter_verify = 2;
  DA.verify = (ot) => {
    let res = ot.open_discard.length == 3 && ot.mimi.hand.length == 5 && ot.mimi.coins == 2
      || arrLast(ot.open_discard)[0] == 'J' && ot.mimi.hand.length == 4 && ot.mimi.coins == 3;
    if (!res) console.log('buy form discard does not work!', ot.mimi, ot.open_discard);
    return res;
  };
  return [fen, player_names];
}
function ari_ut109_create_staged() {
  console.log('*** test 109: harvest ***');
  TestNumber = 109;
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo', 'meckele'];
  let fen = ari_setup(player_names);
  fen.open_discard = deck_deal(fen.deck, 4);
  arisim_stage_3(fen);
  arisim_stage_4_all_mimi_starts(fen);
  stage_correct_buildings(fen, { mimi: { farms: 2, estates: 2 }, leo: { farms: 3 }, meckele: { farms: 2 } });
  fen.phase = 'jack';
  DA.fen0 = fen;
  DA.auto_moves = [
    [[]],
    [['pass']], [['pass']], [['pass']],
    [[0]], [[0]], [[0]],
    [[0, 1]], [[0, 1]], [[0, 1]],
    [['harvest'], [0]],
  ];
  DA.iter_verify = 11;
  DA.verify = (ot) => {
    let uname = ot.plturn;
    let res = ot[uname].buildings.farms[0].h == null && ot[uname].hand.length == 6;
    if (!res) console.log('harvest FAIL!', ot[uname]);
    return res;
  };
  return [fen, player_names];
}
function ari_ut11_create_staged() {
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  let [mimi, leo] = [fen.players.mimi, fen.players.leo];
  mimi.buildings.farms = [{ list: deck_deal(fen.deck, 4), h: null }];
  leo.buildings.farms = [{ list: deck_deal(fen.deck, 4), h: null }];
  fen.open_discard = deck_deal(fen.deck, 4);
  fen.market = deck_deal(fen.deck, 2);
  fen.phase = 'king';
  arisim_stage_4(fen, 3, 3);
  DA.staged_moves = [];
  DA.iter = 100;
  return [fen, player_names];
}
function ari_ut110_create_staged() {
  console.log('*** test 110: end game 2 ***');
  TestNumber = 110;
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  arisim_stage_3(fen);
  arisim_stage_4_all_mimi_starts(fen);
  fen.open_discard = deck_deal(fen.players.mimi.hand, 2);
  deck_add(fen.players.leo.hand, 2, fen.open_discard);
  stage_correct_buildings(fen, { mimi: { farms: 2, estates: 2, chateaus: 1 }, leo: { farms: 3 } });
  fen.phase = 'jack';
  DA.fen0 = fen;
  DA.auto_moves = [
    [[]],
    [['pass']], [['pass']],
    [[0]], [[0]],
    [['pass']], [['pass']],
    [[1]],
  ];
  DA.iter_verify = 8;
  DA.verify = (ot) => {
    let res = ot.stage == 3;
    if (!res) console.log('Not ending game FAIL!', ot.stage);
    return res;
  };
  return [fen, player_names];
}
function ari_ut111_create_staged() {
  console.log('*** test 111: auction payment test ***');
  TestNumber = 111;
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo', 'meckele'];
  let fen = ari_setup(player_names);
  arisim_stage_3(fen);
  arisim_stage_4_all_mimi_starts(fen);
  fen.open_discard = deck_deal(fen.players.mimi.hand, 2);
  deck_add(fen.players.leo.hand, 2, fen.open_discard);
  fen.phase = 'queen';
  DA.fen0 = fen;
  DA.auto_moves = {
    1: [['pass']],
    2: [['pass']],
    3: [['pass']],
    4: [[0]],
    5: [[1]],
    6: [[2]],
    7: [[0]],
  };
  DA.iter_verify = 8;
  DA.verify = (ot) => {
    let coins = ot.plorder.map(x => ot[x].coins);
    let sum = arrSum(coins);
    let res = sum == 8;
    if (!res) console.log('payment for auction card wrong', coins, sum);
    return res;
  };
  return [fen, player_names];
}
function ari_ut112_create_staged() {
  console.log('*** test 112: auction payment test 2 ***');
  TestNumber = 112;
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo', 'meckele', 'felix', 'amanda'];
  let fen = ari_setup(player_names);
  arisim_stage_3(fen);
  arisim_stage_4_all_mimi_starts(fen);
  fen.phase = 'queen';
  DA.fen0 = fen;
  DA.auto_moves = {
    1: [['pass']],
    2: [['pass']],
    3: [['pass']],
    4: [['pass']],
    5: [['pass']],
    6: [[1]],
    7: [[0]],
    8: [[2]],
    9: [[2]],
    10: [[1]],
    11: [[0]],
    12: [[1]],
  };
  DA.iter_verify = 13;
  DA.verify = (ot) => {
    let coins = ot.plorder.map(x => ot[x].coins);
    let sum = arrSum(coins);
    let res = sum == 11;
    if (!res) console.log('payment for auction card wrong', coins, sum);
    return res;
  };
  return [fen, player_names];
}
function ari_ut113_create_staged() {
  console.log('*** test 113: buy from open discard w/ jack ***');
  TestNumber = 113;
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  fen.open_discard = deck_deal(fen.deck, 4);
  arisim_stage_3(fen);
  arisim_stage_4_all_mimi_starts(fen);
  stage_replace_hand_cards_by(fen, 'mimi', ['JSy']);
  stage_correct_buildings(fen, { mimi: { farms: 2, estates: 2, chateaus: 1 }, leo: { farms: 3 } });
  fen.phase = 'jack';
  DA.fen0 = fen;
  DA.auto_moves = {
    mimi_1: [['buy'], [0], [0]],
  };
  DA.iter_verify = 2;
  DA.verify = (ot) => {
    let res = ot.open_discard.length == 3 && ot.mimi.hand.length == 5 && ot.mimi.coins == 2
      || arrLast(ot.open_discard)[0] == 'J' && ot.mimi.hand.length == 4 && ot.mimi.coins == 3;
    if (!res) console.log('buy form discard does not work!', ot.mimi, ot.open_discard);
    return res;
  };
  return [fen, player_names];
}
function ari_ut12_create_staged() {
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'amanda', 'felix', 'lauren', 'blade'];
  let fen = ari_setup(player_names);
  DA.staged_moves = [];
  DA.iter = 100;
  return [fen, player_names];
}
function ari_ut13_create_staged() {
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'amanda', 'felix', 'lauren', 'blade'];
  let fen = ari_setup(player_names);
  ari_test_hand_to_discard(fen, 'mimi');
  ari_test_hand_to_discard(fen, 'lauren');
  console.log('mimi', fen.players.mimi)
  DA.staged_moves = [];
  DA.iter = 100;
  return [fen, player_names];
}
function ari_ut14_create_staged() {
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'amanda', 'felix', 'lauren', 'blade'];
  let fen = ari_setup(player_names);
  DA.fen0 = jsCopy(fen);
  arisim_stage_3(fen);
  arisim_stage_4_all(fen, 1);
  DA.staged_moves = [];
  DA.iter = 100;
  DA.iter_verify = 2;
  DA.verify = (ot) => {
    let plast = arrLast(ot.round);
    let ok = sameList(ot[plast].hand, DA.fen0.players[plast].hand);
    console.log('pl', plast, 'hand', ot[plast].hand, 'should be', DA.fen0.players[plast].hand);
    return ok;
  }
  return [fen, player_names];
}
function ari_ut15_create_staged() {
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'amanda', 'felix', 'lauren', 'blade'];
  let fen = DA.fen0 = ari_setup(player_names);
  ari_test_hand_to_discard(fen, 'mimi');
  ari_test_hand_to_discard(fen, 'amanda');
  ari_test_hand_to_discard(fen, 'lauren');
  ari_test_hand_to_discard(fen, 'blade');
  DA.staged_moves = [];
  DA.iter = 100;
  DA.iter_verify = 3;
  DA.verify = (ot) => ot.plturn == 'felix';
  return [fen, player_names];
}
function ari_ut16_create_staged() {
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  DA.staged_moves = [];
  DA.iter = 100;
  return [fen, player_names];
}
function ari_ut2_create_staged() {
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  arisim_stage_3(fen);
  arisim_stage_4(fen);
  DA.staged_moves = [];
  DA.iter = 100;
  return [fen, player_names];
}
function ari_ut206_create_staged() {
  console.log('*** test 206: prep double visit ***');
  TestNumber = 206;
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo', 'meckele'];
  let fen = ari_setup(player_names);
  arisim_stage_3(fen);
  arisim_stage_4_all_mimi_starts(fen);
  stage_replace_hand_cards_by(fen, 'mimi', ['QSy', 'QSg']);
  stage_building(fen, fen.iturn, 'estate');
  fen.players.leo.buildings.farms = [{ list: '4Cy 4Sy 4Hy 6Dy'.split(' '), h: null }, { list: '5Cy JSy 5Sy 5Dy'.split(' '), h: null }];
  fen.phase = 'queen';
  DA.fen0 = fen;
  return [fen, player_names];
}
function ari_ut3_create_staged() {
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  for (const uname in fen.players) {
    let pl = fen.players[uname];
    while (!isEmpty(pl.hand)) last_elem_from_to(pl.hand, fen.deck);
  }
  fen.players.mimi.hand = 'AHb ADb 2Cb 4Cb 6Cb KCb QDb'.split(' ');
  fen.players.leo.hand = 'ACb KDb QSb ASb 2Db 4Db 6Db'.split(' ');
  fen.players.mimi.buildings.farms = [{ list: '4Cr 7Sr 4Sb 4Dr'.split(' '), h: null }];
  fen.players.leo.buildings.estates = [{ list: 'TCr 7Sr TSb TDr TDb'.split(' '), h: null }];
  fen.market = 'KSb 3Sb'.split(' ');
  arisim_stage_4(fen, 3, 2);
  DA.staged_moves = [];
  DA.iter = 100;
  return [fen, player_names];
}
function ari_ut306_create_staged() {
  console.log('*** test 306: prep double visit ***');
  TestNumber = 306;
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo', 'meckele'];
  let fen = ari_setup(player_names);
  arisim_stage_3(fen);
  arisim_stage_4_all_mimi_starts(fen);
  stage_replace_hand_cards_by(fen, 'mimi', ['QSy', 'QSg']);
  stage_building(fen, fen.iturn, 'estate');
  fen.players.leo.buildings.farms = [{ list: '4Cy 4Sy 4Hy 6Dy'.split(' '), h: null }, { list: '5Cy JSy 5Sy 5Dy'.split(' '), h: null }];
  fen.phase = 'queen';
  DA.fen0 = fen;
  DA.auto_moves = [[],
  [['visit'], ['last'], [0]],
  [['visit'], ['last'], [1]],
  [['pass']],
  ];
  return [fen, player_names];
}
function ari_ut4_create_staged() {
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  for (const uname in fen.players) {
    let pl = fen.players[uname];
    while (!isEmpty(pl.hand)) last_elem_from_to(pl.hand, fen.deck);
  }
  fen.players.mimi.hand = 'AHb ADb 2Cb 4Cb 6Cb KCb QDb'.split(' ');
  fen.players.leo.hand = 'ACb KDb QSb ASb 2Db 4Db 6Db'.split(' ');
  fen.players.mimi.buildings.farms = [{ list: '4Cr 7Sr 4Sb 4Dr'.split(' '), h: null }];
  fen.players.leo.buildings.estates = [{ list: 'TCr 7Sr TSb TDr TDb'.split(' '), h: null }];
  fen.market = 'KSb 3Sb'.split(' ');
  fen.phase = 'queen';
  fen.stage = 11;
  DA.staged_moves = [];
  DA.iter = 100;
  return [fen, player_names];
}
function ari_ut5_create_staged() {
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  for (const uname in fen.players) {
    let pl = fen.players[uname];
    while (!isEmpty(pl.hand)) last_elem_from_to(pl.hand, fen.deck);
  }
  fen.players.mimi.hand = 'AHb ADb 2Cb 4Cb 6Cb KCb QDb'.split(' ');
  fen.players.leo.hand = 'ACb KDb QSb ASb 2Db 4Db 6Db'.split(' ');
  fen.players.mimi.buildings.farms = [{ list: '4Cr 7Sr 4Sb 4Dr'.split(' '), h: null }];
  fen.players.leo.buildings.estates = [{ list: 'TCr 7Sr TSb TDr TDb'.split(' '), h: null }];
  fen.phase = 'jack';
  fen.stage = 3;
  DA.staged_moves = [];
  DA.iter = 100;
  return [fen, player_names];
}
function ari_ut6_create_staged() {
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  for (const uname in fen.players) {
    let pl = fen.players[uname];
    while (!isEmpty(pl.hand)) last_elem_from_to(pl.hand, fen.deck);
  }
  fen.players.mimi.hand = 'AHb ADb 2Cb 4Cb 6Cb KCb QDb'.split(' ');
  fen.players.leo.hand = 'ACb KDb QSb ASb 2Db 4Db 6Db'.split(' ');
  fen.players.mimi.buildings.farms = [{ list: '4Cr 7Sr 4Sb 4Dr'.split(' '), h: null }];
  fen.players.leo.buildings.estates = [{ list: 'TCr 7Sr TSb TDr TDb'.split(' '), h: null }];
  for (let i = 0; i < 3; i++) {
    top_elem_from_to(fen.deck, fen.market);
  }
  fen.phase = 'jack';
  arisim_stage_4(fen);
  DA.staged_moves = [];
  DA.iter = 100;
  return [fen, player_names];
}
function ari_ut7_create_staged() {
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  for (const uname in fen.players) {
    let pl = fen.players[uname];
    while (!isEmpty(pl.hand)) last_elem_from_to(pl.hand, fen.deck);
  }
  fen.players.mimi.hand = 'AHb ADb 2Cb 4Cb 6Cb QCb QDb'.split(' ');
  fen.players.leo.hand = 'ACb KDb QSb ASb 2Db 4Db 6Db'.split(' ');
  fen.players.mimi.buildings.farms = [{ list: '4Cr 7Sr 4Sb 4Dr'.split(' '), h: null }];
  fen.players.leo.buildings.estates = [{ list: 'TCr 7Sr TSb TDr TDb'.split(' '), h: null }];
  for (let i = 0; i < 3; i++) {
    top_elem_from_to(fen.deck, fen.market);
  }
  fen.phase = 'jack';
  arisim_stage_4(fen);
  DA.staged_moves = [];
  DA.iter = 100;
  return [fen, player_names];
}
function ari_ut8_create_staged() {
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  deck_add(fen.deck, 1, fen.players.mimi.hand); //'AHb ADb 2Cb 4Cb 6Cb QCb QDb'.split(' ');
  //deck_add(fen.deck, 2, fen.players.leo.hand); //'ACb KDb QSb ASb 2Db 4Db 6Db'.split(' ');
  fen.players.mimi.buildings.farms = [{ list: deck_deal(fen.deck, 4), h: '3Hb' }];
  fen.players.leo.buildings.farms = [{ list: deck_deal(fen.deck, 4), h: null }];
  fen.players.leo.buildings.estates = [{ list: deck_deal(fen.deck, 5), h: null }];
  fen.market = deck_deal(fen.deck, 3);
  fen.phase = 'jack';
  arisim_stage_4(fen);
  DA.staged_moves = [];
  DA.iter = 100;
  return [fen, player_names];
}
function ari_ut9_create_staged() {
  Session.cur_game = 'gAristo';
  let player_names = ['mimi', 'leo'];
  let fen = ari_setup(player_names);
  for (const uname in fen.players) {
    let pl = fen.players[uname];
    while (!isEmpty(pl.hand)) last_elem_from_to(pl.hand, fen.deck);
  }
  fen.players.mimi.hand = 'AHb ADb 2Cb 4Cb 6Cb QCb QDb'.split(' ');
  fen.players.leo.hand = 'ACb KDb QSb ASb 2Db 4Db 6Db'.split(' ');
  fen.players.mimi.buildings.farms = [{ list: '4Cr 7Sr 4Sb 4Dr'.split(' '), h: '3Hb' }];
  fen.players.leo.buildings.farms = [{ list: 'JCr JSr JSb JDr'.split(' '), h: '3Sr' }];
  fen.players.leo.buildings.estates = [{ list: 'TCr 7Sr TSb TDr TDb'.split(' '), h: null }];
  for (let i = 0; i < 3; i++) {
    top_elem_from_to(fen.deck, fen.market);
  }
  fen.phase = 'king';
  arisim_stage_4(fen);
  DA.staged_moves = [];
  DA.iter = 100;
  return [fen, player_names];
}
function arisim_stage_3(fen) {
  top_elem_from_to(fen.deck, fen.market);
  top_elem_from_to(fen.deck, fen.market);
  if (fen.phase == 'jack') top_elem_from_to(fen.deck, fen.market);
  fen.stage = 4;
}
function arisim_stage_4(fen, n_mimi = 2, n_leo = 3) {
  for (let i = 0; i < n_mimi; i++) top_elem_from_to(fen.players.mimi.hand, fen.players.mimi.stall);
  for (let i = 0; i < n_leo; i++)  top_elem_from_to(fen.players.leo.hand, fen.players.leo.stall);
  fen.stage = 5;
  let valmimi = fen.players.mimi.stall_value = arrSum(fen.players.mimi.stall.map(x => Aristocards[x].val));
  let valleo = fen.players.leo.stall_value = arrSum(fen.players.leo.stall.map(x => Aristocards[x].val));
  let minplayer = valmimi <= valleo ? 'mimi' : 'leo';
  fen.iturn = fen.plorder.indexOf(minplayer); fen.plturn = minplayer;
  fen.num_actions = fen.total_pl_actions = fen.players[minplayer].stall.length;
  fen.action_number = 1;
}
function arisim_stage_4_all(fen, n = 3) {
  for (let i = 0; i < n; i++) top_elem_from_to(fen.players.mimi.hand, fen.players.mimi.stall);
  let others = get_keys(fen.players).filter(x => x != 'mimi');
  for (const uname of others) {
    for (let i = 0; i < n; i++)  top_elem_from_to(fen.players[uname].hand, fen.players[uname].stall);
  }
  let list = [];
  for (const uname of get_keys(fen.players)) {
    fen.players[uname].stall_value = arrSum(fen.players[uname].stall.map(x => Aristocards[x].val));
    list.push({ uname: uname, val: fen.players[uname].stall_value });
  }
  fen.stage = 5;
  list = sortBy(list, 'val');
  let minplayer = list[0].uname;
  fen.iturn = fen.plorder.indexOf(minplayer);
  fen.plturn = minplayer;
  fen.num_actions = fen.total_pl_actions = fen.players[minplayer].stall.length;
  fen.action_number = 1;
}
function arisim_stage_4_all_mimi_starts(fen, n = 3) {
  for (let i = 0; i < n; i++) top_elem_from_to(fen.players.mimi.hand, fen.players.mimi.stall);
  let others = get_keys(fen.players).filter(x => x != 'mimi');
  for (const uname of others) {
    for (let i = 0; i < n; i++)  top_elem_from_to(fen.players[uname].hand, fen.players[uname].stall);
  }
  let list = [];
  for (const uname of get_keys(fen.players)) {
    fen.players[uname].stall_value = arrSum(fen.players[uname].stall.map(x => Aristocards[x].val));
    list.push({ uname: uname, val: fen.players[uname].stall_value });
  }
  fen.stage = 5;
  list = sortBy(list, 'val');
  let minplayer = list[0].uname;
  if (minplayer != 'mimi') {
    console.log('NOT mimi!!! minplayer', minplayer)
    let best_stall = fen.players[minplayer].stall;
    let best_stall_value = fen.players[minplayer].stall_value;
    fen.players[minplayer].stall = fen.players.mimi.stall;
    fen.players[minplayer].stall_value = fen.players.mimi.stall_value;
    fen.players.mimi.stall = best_stall;
    fen.players.mimi.stall_value = best_stall_value;
    minplayer = 'mimi';
  }
  fen.iturn = fen.plorder.indexOf(minplayer);
  fen.plturn = minplayer;
  console.assert(fen.plturn == 'mimi', 'WTF?????????????????');
  fen.num_actions = fen.total_pl_actions = fen.players[minplayer].stall.length;
  fen.action_number = 1;
}
function aristo() {
  const rankstr = 'A23456789TJQK*';
  function setup(players, options) {
    let fen = { players: {}, plorder: jsCopy(players), history: [] };
    let n = players.length;
    let num_decks = fen.num_decks = 2 + (n >= 8 ? 2 : n >= 6 ? 1 : 0);
    let deck = fen.deck = create_fen_deck('n', num_decks);
    shuffle(deck);
    let deck_commission = fen.deck_commission = create_fen_deck('c'); shuffle(deck_commission);
    let deck_luxury = fen.deck_luxury = create_fen_deck('l'); shuffle(deck_luxury);
    let deck_rumors = fen.deck_rumors = exp_rumors(options) ? create_fen_deck('r') : []; shuffle(deck_rumors);
    shuffle(fen.plorder);
    fen.market = [];
    fen.deck_discard = [];
    fen.open_discard = [];
    fen.commissioned = [];
    fen.open_commissions = exp_commissions(options) ? deck_deal(deck_commission, 3) : [];
    fen.church = exp_church(options) ? deck_deal(deck, players.length) : [];
    for (const plname of players) {
      let pl = fen.players[plname] = {
        hand: deck_deal(deck, 7),
        commissions: exp_commissions(options) ? deck_deal(deck_commission, 4) : [],
        rumors: exp_rumors(options) ? deck_deal(deck_rumors, players.length - 1) : [],
        journeys: [],
        buildings: { farm: [], estate: [], chateau: [] },
        stall: [],
        stall_value: 0,
        coins: 3,
        vps: 0,
        score: 0,
        name: plname,
        color: get_user_color(plname),
      };
    }
    fen.phase = 'king';
    fen.num_actions = 0;
    fen.herald = fen.plorder[0];
    fen.heraldorder = jsCopy(fen.plorder);
    if (exp_commissions(options)) {
      ari_history_list([`commission trading starts`], 'commissions', fen);
      [fen.stage, fen.turn] = [23, options.mode == 'hotseat' ? [fen.plorder[0]] : fen.plorder]; fen.comm_setup_num = 3; fen.keeppolling = true;
    } else if (exp_rumors(options) && fen.plorder.length > 2) {
      ari_history_list([`gossiping starts`], 'rumors', fen);
      [fen.stage, fen.turn] = [24, options.mode == 'hotseat' ? [fen.plorder[0]] : fen.plorder];
    } else[fen.stage, fen.turn] = set_journey_or_stall_stage(fen, options, fen.phase);
    return fen;
  }
  function activate_ui() { ari_activate_ui(); }
  function check_gameover(z) { return isdef(z.fen.winners) ? z.fen.winners : false; }
  function present(dParent) { ari_present(dParent); }
  function stats(dParent) { ari_stats(dParent); }
  function state_info(dParent) { ari_state(dParent); }
  function get_selection_color(item) {
    if (Z.stage == 41 && Z.A.selected.length == 1) return 'blue'; return 'red';
  }
  return { get_selection_color, rankstr, setup, activate_ui, check_gameover, present, state_info, stats };
}
function aristoAggregateVisible(g) {
  let result = [];
  let stalls = g.allPlayers.map(x => x.stall);
  result = arrFlatten(stalls).concat(g.market.cards);
  return result;
}
function aristoAIAction(pl, g, key) {
  if (key == 'stall') {
    let deck1 = new Deck(pl.hand);
    pl.stall = deck1.deal(randomNumber(Math.min(2, deck1.count()), Math.min(5, deck1.count())));
    pl.hand = deck1.cards();
  }
}
function aristocracy_activate(fen, plname) {
  console.log('activating for', plname)
}
function aristocracy_present(fen, dParent, plname) {
  console.log('fen', fen);
}
function aristocracy_setup(player_names) {
  let fen = {};
  let deck = fen.deck = get_keys(Aristocards).filter(x => 'br'.includes(x[2]));
  shuffle(deck);
  fen.market = [];
  fen.deck_discard = [];
  fen.open_discard = [];
  let pls = fen.players = {};
  for (const plname of player_names) {
    let pl = pls[plname] = {
      hand: deck_deal(deck, 7),
      buildings: { farms: [], estates: [], chateaus: [] },
      stall: [],
      stall_value: 0,
      coins: 3,
      vps: 0,
      score: 0,
    };
  }
  fen.plorder = rPlayerOrder(player_names);
  fen.iturn = 0;
  fen.plturn = fen.plorder[0];
  fen.turn = [fen.plturn];
  fen.round = [];
  fen.herald = fen.plturn;
  fen.phase = 'king';
  fen.stage = 3;
  fen.step = 0;
  return fen;
}
function aristoExchangeCard() { }
function aristoGame1(g) {
  let phase = g.phase = 'king';
  let players = g.allPlayers;
  let i = 0; players.map(x => x.index = i++);
  let indices = players.map(x => x.index);
  let me = g.me;
  let others = g.others;
  let market = g.market;
  let buy_cards = g.buy_cards;
  let draw_pile = g.draw_pile; draw_pile.type = 'deck';
  let deck = draw_pile.deck = new Deck();
  deck.init52_double();
  let discard_pile = g.discard_pile; discard_pile.type = 'deck';
  let discard = discard_pile.deck = new Deck();
  for (const pl of players) { pl.hand = deck.deal(7); pl.coins = 3; }
  market.cards = deck.deal(3); market.type = 'cards';
  buy_cards.cards = []; buy_cards.type = 'cards';
  let herald = g.herald = players[1];
  let heraldOrder = g.heraldOrder = arrCycle(indices, herald.index);
  g.stallsHidden = true;
  for (const plIndex of heraldOrder) {
    if (plIndex == 0) break;
    let pl = players[plIndex];
    aristoAIAction(pl, g, 'stall');
  }
  aristoUi(dTable, g);
  dLineTopMiddle.innerHTML = 'choose your stall!';
  mButton('submit move', () => aristoUserAction(g, 'stall', aristoGame2), mBy('sidebar').firstChild, { w: 80, bg: g.color }, 'mybutton');
  for (const card of g.me.handItems) {
    let d = iDiv(card);
    d.onclick = () => {
      if (card.isSelected) {
        card.isSelected = false;
        iDiv(card).style.transform = 'unset';
      } else {
        card.isSelected = true;
        iDiv(card).style.transform = 'translateY(-25px)';
      }
    }
  }
}
function aristoGame2(g) {
  let heraldOrder = g.heraldOrder;
  let players = g.allPlayers;
  let me = g.me;
  let iNext = heraldOrder.indexOf(0) + 1;
  for (let i = iNext; i < heraldOrder.length; i++) {
    let plIndex = heraldOrder[i];
    let pl = players[plIndex];
    if (plIndex == 0) break;
    let deck1 = new Deck(pl.hand);
    pl.stall = deck1.deal(randomNumber(Math.min(2, deck1.count()), Math.min(5, deck1.count())));
    pl.hand = deck1.cards();
  }
  g.stallsHidden = false;
  aristoUi(dTable, g);
  setTimeout(() => aristoGame3(g), 2000);
}
function aristoGame3(g) {
  let heraldOrder = g.heraldOrder;
  let players = g.allPlayers;
  let me = g.me;
  let stallOrder = g.stallOrder = calcStallOrder(players);
  players.map(x => x.nActions = x.stall.length);
  for (const plIndex of stallOrder) {
    let pl = players[1];
    console.log('player', pl.name, 'starts with', pl.nActions, 'actions, stall value is', pl.stallValue);
    if (plIndex == 0) break;
    while (pl.nActions > 0) {
      aristoBuild(pl, g);
      break;
    }
    console.log('player', pl.name, 'still has', pl.nActions, 'actions');
  }
  aristoUi(dTable, g);
  return;
  console.log('Game', g);
}
function aristoUi(dParent, g) {
  clearTable();
  let d1 = mDiv(dParent, { w: '100%' }); mFlex(d1, 'v');
  let dWorld = mDiv(d1, { bg: 'random', hmin: 170, flex: 1 });
  mFlex(dWorld);
  iAdd(g.me, { div: cardZone(d1, g.me, 2) });
  let others = g.others;
  for (let i = 0; i < others.length; i++) {
    let pl = others[i];
    iAdd(pl, { div: cardZone(d1, pl) });
  }
  for (const o of [g.draw_pile, g.market, g.buy_cards, g.discard_pile]) { iAdd(o, { div: cardZone(dWorld, o) }); }
  for (const name of ['draw_pile', 'market', 'buy_cards', 'discard_pile']) { g[name + 'Items'] = showCards(g[name]); }
  for (const pl of g.allPlayers) {
    pl.handItems = showCards({ div: iDiv(pl), type: pl == g.me ? 'hand' : 'handHidden', cards: pl.hand });
    if (isdef(pl.stall)) pl.stallItems = showCards({ div: iDiv(pl), type: g.stallsHidden ? 'cardsHidden' : 'cards', cards: pl.stall });
    if (isdef(pl.buildings)) {
      for (const building of pl.buildings) {
        let bItem = showCards({ div: iDiv(pl), type: 'hand', cards: building });
        lookupAddToList(pl, ['buildingItems'], bItem);
      }
    }
  }
}
function aristoUserAction(g, key, followFunc) {
  if (key == 'stall') {
    let me = g.me;
    let indices = arrIndices(me.handItems, x => x.isSelected);
    [me.stall, me.hand] = arrSplitByIndices(me.hand, indices);
    followFunc(g);
  }
}
function aRollby(elem, dx = 100, ms = 3000) {
  anime({ targets: elem, translateX: dx, rotate: '1turn', duration: ms });
}
function aRotate(d, ms = 2000) { return d.animate({ transform: `rotate(360deg)` }, ms); }
function aRotateAccel(d, ms) { return d.animate({ transform: `rotate(1200deg)` }, { easing: 'cubic-bezier(.72, 0, 1, 1)', duration: ms }); }
function arr_count(arr, funcprop) {
  console.log('arr', arr);
  let di = {};
  if (isdef(funcprop) && isString(funcprop)) {
    for (const a of arr) { if (isdef(di[a[funcprop]])) di[a[funcprop]] += 1; else di[a[funcprop]] = 1; }
  } else if (isdef(funcprop)) {
    for (const a of arr) {
      let val = funcprop(a);
      if (isdef(di[val])) di[val] += 1; else di[val] = 1;
    }
  } else {
    for (const a of arr) { if (isdef(di[a])) di[a] += 1; else di[a] = 1; }
  }
  for (const a of arr) {
    a.rank = a.key[0];
    a.count = di[a.rank];
  }
  let sorted = sortByDescending(arr, 'count');
  return sorted;
}
function arr_get_max(arr, func) {
  if (isEmpty(arr)) return null;
  if (nundef(func)) func = x => x;
  let i = 0; let aug = arr.map(x => ({ el: jsCopy(x), val: func(x), i: i++ }));
  sortByDescending(aug, 'val');
  let max = aug[0].val;
  let res = arrTakeWhile(aug, x => x.val == max); return res.map(x => arr[x.i]);
}
function arr_get_min(arr, func) {
  if (isEmpty(arr)) return null;
  if (nundef(func)) func = x => x;
  let i = 0; let aug = arr.map(x => ({ el: jsCopy(x), val: func(x), i: i++ }));
  sortBy(aug, 'val');
  let min = aug[0].val;
  let res = arrTakeWhile(aug, x => x.val == min); return res.map(x => arr[x.i]);
}
function arr_to_dict_by(arr, prop) { let di = {}; for (const a of arr) { lookupAddToList(di, [a[prop]], a); } return di; }
function arr2Set(arr2d, func) {
  for (let i = 0; i < arr2d.length; i++) {
    for (let j = 0; j < arr2d[i].length; j++) {
      let o = arr2d[i][j];
      if (typeof o == 'object') {
        func(o, i, j);
      }
    }
  }
}
function arrAdd(arr1, arr2) {
  let i = 0; return arr1.map(x => x + arr2[i++]);
}
function arrangeChildrenAsCircle(n, R) {
}
function arrangeChildrenAsMatrix(n, R, rows, cols) {
  let children = n.children.map(x => R.uiNodes[x]);
  let num = children.length;
  let size = 20;
  let padding = 4;
  let i = 0;
  for (const n1 of children) {
    let b = getBounds(n1.ui);
    let newMax = Math.max(Math.max(b.width, b.height), size);
    if (newMax > size) {
      size = newMax;
    }
  }
  let [y0, wTitle] = calcParentContentYOffsetAndWidth(n, padding);
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      let n1 = children[i]; i += 1;
      n1.params.size = { w: size - 1, h: size - 1 };
      n1.params.pos = { x: padding + r * size, y: y0 + c * size };
      n1.params.sizing = 'fixed';
    }
  }
}
function arrangeChildrenAsQuad(n, R) {
  let children = n.children.map(x => R.uiNodes[x]);
  let num = children.length;
  let rows = Math.ceil(Math.sqrt(num));
  let cols = Math.floor(Math.sqrt(num));
  let size = 20;
  let padding = 4;
  let i = 0;
  for (const n1 of children) {
    let b = getBounds(n1.ui);
    let newMax = Math.max(Math.max(b.width, b.height), size);
    if (newMax > size) {
      size = newMax;
    }
  }
  let [y0, wTitle] = calcParentContentYOffsetAndWidth(n, padding);
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      let n1 = children[i]; i += 1;
      n1.params.size = { w: size - 1, h: size - 1 };
      n1.params.pos = { x: padding + r * size, y: y0 + c * size };
      n1.params.sizing = 'fixed';
    }
  }
}
function arrangeOverride(n, R) {
  if (nundef(n.children)) return { w: 0, h: 0 }
  if (isdef(RLAYOUT[n.type])) {
    return RLAYOUT[n.type](n, R);
  }
  if (n.type == 'grid') {
    console.log('should have been done')
  } else if (n.type == 'hand') {
    console.log('should have been done')
    let szNeeded = handLayout(n, R);
    return szNeeded;
  } else if (n.info) {
    n.sizeNeeded = wrapLayoutSizeNeeded(n.children, R);
    let nBoard = R.uiNodes[n.uidParent];
    addResizeInfo(nBoard, n, n.sizeNeeded);
    return { w: n.sizeNeeded.w, h: n.sizeNeeded.h };
  } else if (n.uiType == 'd') {
    let szNeeded = panelLayout(n, R);
    return szNeeded;
  } else {
    console.log('!!!!!!!!!!case NOT catched in arrangeOverride_!!!!!!!!!!', n);
  }
  return res;
}
function arrAverage(arr, prop) {
  let n = arr.length; if (!n) return 0;
  let sum = arrSum(arr, prop);
  return sum / n;
}
function arrBuckets(arr, func, sortbystr) {
  let di = {};
  for (const a of arr) {
    let val = func(a);
    if (nundef(di[val])) di[val] = { val: val, list: [] };
    di[val].list.push(a);
  }
  let res = []
  let keys = get_keys(di);
  if (isdef(sortbystr)) {
    keys.sort((a, b) => sortbystr.indexOf(a) - sortbystr.indexOf(b));
  }
  return keys.map(x => di[x]);
}
function arrByClassName(classname, d) {
  if (nundef(d)) d = document;
  return Array.from(d.getElementsByClassName(classname));
}
function arrChildren(elem) { return [...toElem(elem).children]; }
function arrClear(arr) { arr.length = 0; }
function arrCount(arr, func) { return arr.filter(func).length; }
function arrCreate(n, func) {
  let res = [];
  for (let i = 0; i < n; i++) {
    res.push(func(i));
  }
  return res;
}
function arrCycle(arr, count) { return arrRotate(arr, count); }
function arrCycleSwap(arr, prop, clockwise = true) {
  let n = arr.length;
  let h = arr[0].prop;
  for (let i = 1; i < n; i++) { arr[i - 1][prop] = arr[i][prop]; }
  arr[n - 1][prop] = h;
}
function arrExcept(arr, el) {
  let res = [];
  for (const a of arr) { if (a != el) res.push(a); }
  return res;
}
function arrExtend(arr, list) { list.map(x => arr.push(x)); return arr; }
function arrFirst(arr) { return arr.length > 0 ? arr[0] : null; }
function arrFirstOfLast(arr) { if (arr.length > 0) { let l = arrLast(arr); return isList(l) ? arrFirst(l) : null; } else return null; }
function arrFlatten(arr) {
  let res = [];
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr[i].length; j++) {
      res.push(arr[i][j]);
    }
  }
  return res;
}
function arrFromIndex(arr, i) { return arr.slice(i); }
function arrFromTo(arr, iFrom, iTo) { return takeFromTo(arr, iFrom, iTo); }
function arrFunc(n, func) { let res = []; for (let i = 0; i < n; i++) res.push(func()); return res; }
function arrIndices(arr, func) {
  let indices = [];
  for (let i = 0; i < arr.length; i++) { if (func(arr[i])) indices.push(i); }
  return indices;
}
function arrlast(arr) {
  return arr.length > 0 ? arr[arr.length - 1] : null;
}
function arrLast(arr) { return arr.length > 0 ? arr[arr.length - 1] : null; }
function arrLastOfLast(arr) { if (arr.length > 0) { let l = arrLast(arr); return isList(l) ? arrLast(l) : null; } else return null; }
function arrMax(arr, f) { return arr_get_max(arr, f); }
function arrMin(arr, f) { return arr_get_min(arr, f); }
function arrMinMax(arr, func) {
  if (nundef(func)) func = x => x;
  let min = func(arr[0]), max = func(arr[0]), imin = 0, imax = 0;
  for (let i = 1, len = arr.length; i < len; i++) {
    let v = func(arr[i]);
    if (v < min) {
      min = v; imin = i;
    } else if (v > max) {
      max = v; imax = i;
    }
  }
  return { min: min, imin: imin, max: max, imax: imax, elmin: arr[imin], elmax: arr[imax] };
}
function arrMinus(a, b) { if (isList(b)) return a.filter(x => !b.includes(x)); else return a.filter(x => x != b); }
function arrNext(list, el) {
  let iturn = list.indexOf(el);
  let nextplayer = list[(iturn + 1) % list.length];
  return nextplayer;
}
function arrNoDuplicates(arr) {
  let di = {};
  let arrNew = [];
  for (const el of arr) {
    if (!isLiteral(el)) continue;
    if (isdef(di[el])) continue;
    di[el] = true;
    arrNew.push(el);
  }
  return arrNew;
}
function arrPairs(a) {
  let res = [];
  for (let i = 0; i < a.length; i++) {
    for (let j = i + 1; j < a.length; j++) {
      res.push([a[i], a[j]]);
    }
  }
  return res;
}
function arrPlus(a, b) { b.map(x => a.push(x)); return a; }
function arrPrev(list, el) {
  let iturn = list.indexOf(el);
  if (iturn == 0) iturn = list.length;
  let nextplayer = list[(iturn - 1) % list.length];
  return nextplayer;
}
function arrRange(from = 1, to = 10, step = 1) { let res = []; for (let i = from; i <= to; i += step)res.push(i); return res; }
function arrRemove(arr, listweg) {
  arrReplace(arr, listweg, []);
}
function arrRemoveDuplicates(items, prop) {
  let di = {};
  let res = [];
  for (const item of items) {
    if (isdef(di[item[prop].toLowerCase()])) { continue; }
    res.push(item);
    di[item[prop].toLowerCase()] = true;
  }
  return res;
}
function arrRemoveLast(arr) { arr.length -= 1; }
function arrRemovip(arr, el) {
  let i = arr.indexOf(el);
  if (i > -1) arr.splice(i, 1);
  return i;
}
function arrRepeat(n, el) { let res = []; for (let i = 0; i < n; i++) res.push(el); return res; }
function arrReplace(arr, listweg, listdazu) {
  arrExtend(arr, listdazu);
  listweg.map(x => arrRemovip(arr, x));
  return arr;
}
function arrReplace1(arr, elweg, eldazu) {
  let i = arr.indexOf(elweg);
  arr[i] = eldazu;
  return arr;
}
function arrReplaceAt(arr, index, val, inPlace = true) { return inPlace ? arrReplaceAtInPlace(arr, index, val) : arrReplaceAtCopy(arr, index, val); }
function arrReplaceAtCopy(arr, index, val) {
  let res = new Array();
  for (let i = 0; i < arr.length; i++) {
    if (i == index) res[i] = val; else res[i] = arr[i];
  }
  return res;
}
function arrReplaceAtInPlace(arr, index, val) { arr[index] = val; }
function arrReverse(arr) { return jsCopy(arr).reverse(); }
function arrRotate(arr, count) {
  var unshift = Array.prototype.unshift,
    splice = Array.prototype.splice;
  var len = arr.length >>> 0, count = count >> 0;
  let arr1 = jsCopy(arr);
  unshift.apply(arr1, splice.call(arr1, count % len, len));
  return arr1;
}
function arrShufflip(arr) { if (isEmpty(arr)) return []; else return fisherYates(arr); }
function arrSplitAtIndex(arr, i) {
  return [arr.slice(0, i), arr.slice(i)];
}
function arrSplitByIndices(arr, indices) {
  let [a1, a2] = [[], jsCopy(arr)];
  for (let i = 0; i < indices.length; i++) {
    let el = arr[indices[i]];
    a1.push(el);
    removeInPlace(a2, el);
  }
  return [a1, a2];
}
function arrString(arr, func) {
  if (isEmpty(arr)) return '[]';
  let s = '[';
  for (const el of arr) {
    if (isList(el)) s += arrString(el, func) + ','; else s += (isdef(func) ? func(el) : el) + ',';
  }
  s = s.substring(0, s.length - 1);
  s += ']';
  return s;
}
function arrSum(arr, props) {
  if (nundef(props)) return arr.reduce((a, b) => a + b);
  if (!isList(props)) props = [props];
  return arr.reduce((a, b) => a + (lookup(b, props) || 0), 0);
}
function arrSwap(arr, i, j) { let h = arr[i]; arr[i] = arr[j]; arr[j] = h; }
function arrSwap2d(arr, r1, c1, r2, c2) { let h = arr[r1][c1]; arr[r1][c1] = arr[r2][c2]; arr[r2][c2] = h; }
function arrTail(arr) { return arr.slice(1); }
function arrTake(arr, n = 0, from = 0) {
  if (isDict(arr)) {
    let keys = Object.keys(arr);
    return n > 0 ? keys.slice(from, from + n).map(x => (arr[x])) : keys.slice(from).map(x => (arr[x]));
  } else return n > 0 ? arr.slice(from, from + n) : arr.slice(from);
}
function arrTakeFromEnd(arr, n) {
  if (arr.length <= n) return arr.map(x => x); else return arr.slice(arr.length - n);
}
function arrTakeFromTo(arr, a, b) { return takeFromTo(arr, a, b); }
function arrTakeLast(arr, n, from = 0) {
  let res = [];
  if (isDict(arr)) {
    let keys = Object.keys(arr);
    let ilast = keys.length - 1; for (let i = ilast - from; i >= 0 && i > ilast - from - n; i--) { res.unshift(arr[keys[i]]); }
  } else {
    let ilast = arr.length - 1; for (let i = ilast - from; i >= 0 && i > ilast - from - n; i--) { res.unshift(arr[i]); }
  }
  return res;
}
function arrTakeWhile(arr, func) {
  let res = [];
  for (const a of arr) {
    if (func(a)) res.push(a); else break;
  }
  return res;
}
function arrToFen(board, plStart = 'w') {
  let result = "";
  for (let y = 0; y < board.length; y++) {
    let empty = 0;
    for (let x = 0; x < board[y].length; x++) {
      if (isNumber(board[y][x])) {
        empty += 1; continue;
      }
      let c = board[y][x][0];
      if (c == 'w' || c == 'b') {
        if (empty > 0) {
          result += empty.toString();
          empty = 0;
        }
        if (c == 'w') {
          result += board[y][x][1].toUpperCase();
        } else {
          result += board[y][x][1].toLowerCase();
        }
      } else {
        empty += 1;
      }
    }
    if (empty > 0) {
      result += empty.toString();
    }
    if (y < board.length - 1) {
      result += '/';
    }
  }
  result += ` ${plStart} KQkq - 0 1`;
  return result;
}
function arrToggleMember(arr, el) { if (arr.includes(el)) removeInPlace(arr, el); else arr.push(el); }
function arrToMatrix(arr, rows, cols) {
  let i = 0, res = [];
  for (let r = 0; r < rows; r++) {
    let rarr = [];
    for (let c = 0; c < cols; c++) {
      let a = arr[i]; i++;
      rarr.push(a);
    }
    res.push(rarr);
  }
  return res;
}
function arrWithout(arr, b) { return arrMinus(arr, b); }
function arrZip(arr1, arr2) {
  let res = [];
  for (let i = 0; i < Math.min(arr1, arr2); i++) {
    let o = {};
    addKeys(arr1[i], o);
    addKeys(arr2[i], o);
    res.push(o);
  }
  return res;
}
function asElem(x) { return isString(x) ? mBy(x) : x; }
function asList(x) { return isList(x) ? x : [x]; }
function assertion(cond) {
  if (!cond) {
    let args = [...arguments];
    for (const a of args) {
      console.log('\n', a);
    }
    throw new Error('TERMINATING!!!')
  }
}
function assets_get() {
  where([...arguments]);
  to_server([...arguments], 'assets');
}
function assets_parse(o) {
  where(o);
  for (const k in o) {
    let text = o[k];
    if (k == 'allSyms') {
      symbolDict = Syms = jsyaml.load(text);
      SymKeys = Object.keys(Syms);
    } else if (k == 'symGSG') {
      ByGroupSubgroup = jsyaml.load(text);
    } else if (k == 'allWP') {
      WordP = jsyaml.load(text);
    } else if (k == 'fens') {
      FenPositionList = csv2list(text);
    } else if (startsWith(k, 'db_')) {
      let okey = stringAfter(k, '_');
      DB[okey] = jsyaml.load(text);
    } else {
      window[capitalize(k)] = jsyaml.load(text);
    }
  }
  if (nundef(KeySets) && isdef(o.symGSG)) { KeySets = getKeySets(); }
}
function aSvg(dParent) {
  if (!dParent.style.position) dParent.style.position = 'relative';
  let svg1 = gSvg();
  svg1.setAttribute('width', '100%');
  svg1.setAttribute('height', '100%');
  let style = 'margin:0;padding:0;position:absolute;top:0px;left:0px;';
  svg1.setAttribute('style', style);
  dParent.appendChild(svg1);
  return svg1;
}
function aSvgg(dParent, originInCenter = true) {
  if (!dParent.style.position) dParent.style.position = 'relative';
  let svg1 = gSvg();
  svg1.setAttribute('width', '100%');
  svg1.setAttribute('height', '100%');
  let style = 'margin:0;padding:0;position:absolute;top:0px;left:0px;';
  svg1.setAttribute('style', style);
  dParent.appendChild(svg1);
  let g1 = document.createElementNS('http:/' + '/www.w3.org/2000/svg', 'g');
  svg1.appendChild(g1);
  if (originInCenter) { g1.style.transform = "translate(50%, 50%)"; }
  return g1;
}
async function atest01() {
  let url = '/frontend/static/rsg/assets/gameIconCodes.yml';
  let response = await fetch(url);
  if (response.ok) {
    let t = await response.text();
    let iconDict = jsyaml.load(t);
    timit.showTime('nach atest01')
    console.log(iconDict);
  } else {
    alert("HTTP-Error: " + response.status);
  }
}
async function atest02() {
}
async function atestLoadIcons() {
  timit.showTime('_______start gameIconCode');
  let gaIcons = await route_rsg_asset('gameIconCodes');
  timit.showTime('_______start faIconCodes');
  let faIcons = await route_rsg_asset('faIconCodes');
  timit.showTime('_______start iconTest');
  let smallIcons = await route_rsg_asset('iconTest');
  timit.showTime('nach atestLoadIconst');
  faKeys = [];
  for (const k in gaIcons) {
    if (isdef(faIcons[k])) faKeys.push(k);
  }
  console.log('common keys:', faKeys);
}
function atleastOneElementOfXIsDictWithKey(lst, k) {
  for (const x of lst) { if (!x) continue; if (isDict(x) && k in x) return true; }
  return false;
}
function atleastOneElementOfXIsDictWithKey_obj(lst) {
  for (const x of lst) { if (!x) continue; if (isDict(x) && '_obj' in x) return true; }
  return false;
}
function aTranslateBy(d, x, y, ms) { return d.animate({ transform: `translate(${x}px,${y}px)` }, ms); }
function aTranslateBy_v0(d, x, y, ms) {
  let a = d.animate([
    { transform: `translate(${x}px,${y}px)` }
  ], {
    duration: ms,
  });
  return a;
}
function aTranslateBy_v1(d, x, y, ms) {
  let a = d.animate({ transform: `translate(${x}px,${y}px)` }, ms);
  return a;
}
function aTranslateByEase(d, x, y, ms, easing = 'cubic-bezier(1,-0.03,.27,1)') {
  return d.animate({ transform: `translate(${x}px,${y}px)` }, { easing: easing, duration: ms });
}
function aTranslateFadeBy(d, x, y, ms) { return d.animate({ opacity: .5, transform: `translate(${x}px,${y}px)` }, { easing: MyEasing, duration: ms }); }
function attachTo(div, deck) { deck.mount(div); }
function audio_beep(vol, freq, duration) {
  console.log('sollte beepen!!!');
  if (nundef(_AUDIOCONTEXT)) _AUDIOCONTEXT = new AudioContext();
  let a = _AUDIOCONTEXT;
  v = a.createOscillator()
  u = a.createGain()
  v.connect(u)
  v.frequency.value = freq
  v.type = "square";
  u.connect(a.destination)
  u.gain.value = vol * 0.01
  v.start(a.currentTime)
  v.stop(a.currentTime + duration * 0.001);
}
function audio_onclick_pp() {
  audio_toggle('mozart');
  if (audio_playing()) { hide0('bPlay'); show0('bPause'); } else { hide0('bPause'); show0('bPlay'); }
}
function audio_pause() {
  _qSound = [];
  if (_loaded && isdef(_sndPlayer)) {
    clearTimeout(_TOSound);
    _sndPlayer.onended = null;
    _sndPlayer.onpause = _whenSoundPaused;
    _sndPlayer.pause();
  }
}
function audio_play(key, wait = true) {
  if (!wait) _qSound = [];
  _enqSound(key);
  if (_idleSound) { _idleSound = false; _deqSound(); }
}
function audio_playing() { return DA.isSound; }
function audio_toggle(key) {
  if (DA.isSound == true) { audio_pause(); DA.isSound = false; return; }
  audio_play(key);
  DA.isSound = true;
}
function augment(obj, newobj) {
  return extend(true, obj, newobj);
}
function aushaengen(oid, R) {
  while (true) {
    let uid = firstCondDict(R.rNodes, x => x.oid == oid);
    if (!uid) return;
    let n = R.rNodes[uid];
    let len = Object.keys(R.rNodes).length;
    recRemove(n, R);
    let len2 = Object.keys(R.rNodes).length;
    if (len2 < len) {
    } else {
      console.log('DID NOT REMOVE ANYTHING!!!!', len, len2);
      return;
    }
  }
}
function autocomplete(inp, arr) {
  var currentFocus;
  inp = toElem(inp);
  inp.addEventListener('input', e => {
    var a, b, i, val = this.value;
    autocomplete_closeAllLists();
    if (!val) { return false; }
    currentFocus = -1;
    a = document.createElement('DIV');
    a.setAttribute('id', this.id + 'autocomplete-list');
    a.setAttribute('class', 'autocomplete-items');
    this.parentNode.appendChild(a);
    for (i = 0; i < arr.length; i++) {
      if (arr[i].substr(0, val.length).toUpperCase() == val.toUpperCase()) {
        b = document.createElement('DIV');
        b.innerHTML = '<strong>' + arr[i].substr(0, val.length) + '</strong>';
        b.innerHTML += arr[i].substr(val.length);
        b.innerHTML += "<input type='hidden' value='" + arr[i] + "'>";
        b.addEventListener('click', e => {
          inp.value = this.getElementsByTagName('input')[0].value;
          autocomplete_closeAllLists();
        });
        a.appendChild(b);
      }
    }
  });
  inp.addEventListener('keydown', e => {
    var x = document.getElementById(this.id + 'autocomplete-list');
    if (x) x = x.getElementsByTagName('div');
    if (e.keyCode == 40) {
      currentFocus++;
      autocomplete_addActive(x);
    } else if (e.keyCode == 38) {
      currentFocus--;
      autocomplete_addActive(x);
    } else if (e.keyCode == 13) {
      e.preventDefault();
      if (currentFocus > -1) {
        if (x) x[currentFocus].click();
      }
    }
  });
  inp.addEventListener('dblclick', e => { evNoBubble(e); });
  document.addEventListener('click', e => {
    autocomplete_closeAllLists(e.target);
  });
}
function autocomplete_addActive(x) {
  if (!x) return false;
  autocomplete_removeActive(x);
  if (currentFocus >= x.length) currentFocus = 0;
  if (currentFocus < 0) currentFocus = x.length - 1;
  x[currentFocus].classList.add('autocomplete-active');
}
function autocomplete_closeAllLists(elmnt) {
  var x = document.getElementsByClassName('autocomplete-items');
  for (var i = 0; i < x.length; i++) {
    if (elmnt != x[i] && elmnt != inp) {
      x[i].parentNode.removeChild(x[i]);
    }
  }
}
function autocomplete_removeActive(x) {
  for (var i = 0; i < x.length; i++) {
    x[i].classList.remove('autocomplete-active');
  }
}
function autoGameScreen() {
}
function autopoll(ms) { TO.poll = setTimeout(_poll, valf(ms, valf(Z.options.poll, 2000))); }
function autoselect_action(r, action, uname, item) { select_action(r, action, uname, item); }
function autosend(plname, slot) {
  Z.uplayer = plname;
  take_turn_collect_open();
}
function autoTestSpeech() {
  ensureSymBySet();
  nextIndex += 1;
  let k = SymKeysBySet['nosymbols'][nextIndex];
  let info = SymbolDict[k];
  let best = stringAfterLast(info.E, '|');
  console.log('best', best, '(key', k, ')');
  record('E', best)
  say(best, .7, 1, .7, false, 'random', () => { console.log('done:', k) });
}
function availableGames(callback) { let route = '/game/available'; _sendRouteJS(route, callback); }
function availablePlayers(callback) { let route = '/game/players'; _sendRouteJS(route, callback); }
function backtrack_based(orig_board) {
  let board = JSON.parse(JSON.stringify(orig_board));
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      if (board[r][c] == 0) {
        complete_cell(board, r, c)
        if (is_solved(board)) return board;
        let cell = board[r][c]
        if (Array.isArray(cell)) {
          for (let i = 0; i < cell.length; i++) {
            let board_2 = JSON.parse(JSON.stringify(board));
            board_2[r][c] = cell[i]
            if (completed_board = backtrack_based(board_2)) {
              return completed_board;
            }
          }
          return false
        }
      }
    }
  }
  return false;
}
function badges_off() {
  hide('dLeftSide');
  delete Session.is_badges;
  Badges = [];
}
function badges_on() {
  if (!isdef(mBy('dLeiste'))) initSidebar();
  Session.is_badges = true;
  Badges = [];
}
function bCapturedPieces(plSym, arr, idx, rows, cols, includeDiagonals = true) {
  let res = [];
  let nei = bNei(arr, idx, rows, cols, includeDiagonals);
  for (let dir = 0; dir < 8; dir++) {
    let i = nei[dir];
    if (nundef(i)) continue;
    let el = arr[i];
    if (empty_func(el) || el == plSym) continue;
    let inew = [];
    let MAX = 100, cmax = 0;
    while (isOppPiece(el, plSym)) {
      if (cmax > MAX) break; cmax += 1;
      inew.push(i);
      i = bNeiDir(arr, i, dir, rows, cols);
      if (nundef(i)) break;
      el = arr[i];
    }
    if (el == plSym) {
      res = res.concat(inew);
    }
  }
  return res;
}
function bCheck(r, c, rows, cols) { return r >= 0 && r < rows && c >= 0 && c < cols ? r * cols + c : null; }
function bCreateEmpty(rows, cols) { return new Array(rows * cols).fill(null); }
function beautify_history(lines, title, fen, uplayer) {
  let html = `<div class="history"><span style="color:red;font-weight:bold;">${title}: </span>`;
  for (const l of lines) {
    let words = toWords(l);
    for (const w1 of words) {
      if (is_card_key(w1)) {
        html += mCardText(w1);
        continue;
      }
      w = w1.toLowerCase();
      if (isdef(fen.players[w])) {
        html += `<span style="color:${get_user_color(w)};font-weight:bold"> ${w} </span>`;
      } else html += ` ${w} `;
    }
  }
  html += "</div>";
  return html;
}
function beep(vol, freq, duration) {
  console.log('sollte beepen!!!');
  if (nundef(_AUDIOCONTEXT)) _AUDIOCONTEXT = new AudioContext();
  let a = _AUDIOCONTEXT;
  v = a.createOscillator()
  u = a.createGain()
  v.connect(u)
  v.frequency.value = freq
  v.type = "square";
  u.connect(a.destination)
  u.gain.value = vol * 0.01
  v.start(a.currentTime)
  v.stop(a.currentTime + duration * 0.001);
}
function beforeActivationUI() { uiPaused |= beforeActivationMask; uiPaused &= ~hasClickedMask; }
function being_blackmailed() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  let cmd = item.key;
  console.log('selected reaction to blackmail:', item.key);
  if (cmd == 'accept') { Z.stage = 34; ari_pre_action(); }
  else if (cmd == 'reject') { post_reject_blackmail(); }
  else { post_defend_blackmail(); }
}
function bestContrastingColor(color, colorlist) {
  let contrast = 0;
  let result = null;
  let rgb = colorRGB(color, true);
  rgb = [rgb.r, rgb.g, rgb.b];
  for (c1 of colorlist) {
    let x = colorRGB(c1, true)
    x = [x.r, x.g, x.b];
    let c = getContrast(rgb, x);
    if (c > contrast) { contrast = c; result = c1; }
  }
  return result;
}
function bFreeRayDir(arr, idx, dir, rows, cols) {
  let indices = [];
  let i = idx;
  while (i < arr.length) {
    i = bNeiDir(arr, i, dir, rows, cols);
    if (!i || !empty_func(arr[i])) break; else indices.push(i);
  }
  return indices;
}
function bFreeRayDir1(arr, idx, dir, rows, cols) {
  let indices = [];
  let i = idx;
  while (i < arr.length) {
    i = bNeiDir(arr, i, dir, rows, cols);
    if (!i) break;
    else indices.push(i);
    if (!empty_func(arr[i])) break;
  }
  return indices;
}
function bFullCol(arr, icol, rows, cols) {
  let iStart = icol;
  let x = arr[iStart]; if (empty_func(x)) return null;
  for (let i = iStart + cols; i < iStart + (cols * rows); i += cols) if (arr[i] != x) return null;
  return x;
}
function bFullDiag(arr, rows, cols) {
  let iStart = 0;
  let x = arr[iStart]; if (empty_func(x)) return null;
  for (let i = iStart + cols + 1; i < arr.length; i += cols + 1) { if (arr[i] != x) return null; }
  return x;
}
function bFullDiag2(arr, rows, cols) {
  let iStart = cols - 1;
  let x = arr[iStart]; if (empty_func(x)) return null;
  for (let i = iStart + cols - 1; i < arr.length - 1; i += cols - 1) { if (arr[i] != x) return null; }
  return x;
}
function bFullRow(arr, irow, rows, cols) {
  let iStart = irow * cols;
  let x = arr[iStart]; if (empty_func(x)) return null;
  for (let i = iStart + 1; i < iStart + cols; i++) if (arr[i] != x) return null;
  return x;
}
function bGetChunks(arr2d, rowsEach, colsEach) {
  let res = [];
  let [rTotal, cTotal] = [arr2d.length, arr2d[0].length];
  for (let r = 0; r < rTotal; r += rowsEach) {
    let m1 = [];
    for (let c = 0; c < cTotal; c += colsEach) {
      m1 = bGetSubMatrix(arr2d, r, rowsEach, c, colsEach);
      res.push(arrFlatten(m1));
    }
  }
  return res;
}
function bGetChunksWithIndices(arr2d, rowsEach, colsEach) {
  let res = [];
  let [rTotal, cTotal] = [arr2d.length, arr2d[0].length];
  for (let r = 0; r < rTotal; r += rowsEach) {
    let m1 = [];
    for (let c = 0; c < cTotal; c += colsEach) {
      m1 = bGetSubMatrixWithIndices(arr2d, r, rowsEach, c, colsEach);
      res.push(arrFlatten(m1));
    }
  }
  return res;
}
function bGetCol(arr, icol, rows, cols) {
  let iStart = icol;
  let res = [];
  for (let i = iStart; i < iStart + (cols * rows); i += cols) res.push(arr[i]);
  return res;
}
function bGetCols(arr2d) {
  let rows = arr2d.length;
  let cols = arr2d[0].length;
  let res = [];
  for (let c = 0; c < cols; c++) { res.push([]); }
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      res[c].push(arr2d[r][c]);
    }
  }
  return res;
}
function bGetInitialState() {
}
function bGetRow(arr, irow, rows, cols) {
  let iStart = irow * cols;
  let arrNew = arr.slice(iStart, iStart + cols);
  let res = [];
  for (let i = iStart; i < iStart + cols; i++) res.push(arr[i]);
  console.assert(sameList(arrNew, res), 'NOOOOOO');
  return res;
}
function bGetRows(arr2d) {
  return arr2d;
}
function bGetSubMatrix(arr2d, rFrom, rows, cFrom, cols) {
  let res = []; for (let i = 0; i < rows; i++) res.push([]);
  let [rTotal, cTotal] = [arr2d.length, arr2d[0].length];
  let rIndex = 0;
  for (let r = rFrom; r < rFrom + rows; r++) {
    for (let c = cFrom; c < cFrom + cols; c++) {
      res[rIndex].push(arr2d[r][c]);
    }
    rIndex += 1;
  }
  return res;
}
function bGetSubMatrixWithIndices(arr2d, rFrom, rows, cFrom, cols) {
  let res = []; for (let i = 0; i < rows; i++) res.push([]);
  let [rTotal, cTotal] = [arr2d.length, arr2d[0].length];
  let rIndex = 0;
  for (let r = rFrom; r < rFrom + rows; r++) {
    for (let c = cFrom; c < cFrom + cols; c++) {
      res[rIndex].push({ row: r, col: c, val: arr2d[r][c] });
    }
    rIndex += 1;
  }
  return res;
}
function bgFromPal(ipal_dep, pal) {
  return getpal(ipal_dep, 0, 'b', pal);
}
function bgNum(k, v) {
}
function bid_to_string(bid) { return bid.join(' '); }
function binding01(R) {
  serverData.table.o1.name = 'felix';
  let upd = { oid: 'o1', prop: 'name', ukind: 'valueChange', oldval: 'max', newval: 'felix' };
  let sUpdated = { o1: [upd] };
  updateBindings(sUpdated, R);
}
function binding02(R) {
  let o = serverData.table.o3 = { name: 'ama' };
  let upd = { oid: 'o3', o: o, ukind: 'new' };
  let sCreated = { o3: [upd] };
  updateCreatedBindings(sCreated, R);
}
function blackOrWhite(cssHSLA, maxLumForWhite = 88) {
  let l = getLuminosity(cssHSLA);
  let hue = getHue(cssHSLA);
  if (hue > 40 && hue < 90) maxLumForWhite = 60;
  let result = l <= maxLumForWhite ? 'white' : 'black';
  testHelpers('lum(' + l + '), hue(' + hue + ') : ' + result);
  return result;
}
function blank(card) { clearElement(card.elem); }
function blankExpResult() { }
function blankInputs(d, ilist, blink = true) {
  let inputs = [];
  for (const idx of ilist) {
    let inp = d.children[idx];
    inp.innerHTML = '_';
    if (blink) mClass(inp, 'blink');
    inputs.push({ letter: Goal.word[idx].toUpperCase(), div: inp, index: idx });
  }
  return inputs;
}
function blankOperand2() { }
function blankOperator() { }
function blankWordInputs(wi, n, pos = 'random') {
  let indivInputs = [];
  let remels =
    pos == 'random' ? choose(wi, n)
      : pos == 'notStart' ? arrTake(wi.slice(1, wi.length - 1), n)
        : pos == 'start' ? arrTake(wi, n)
          : takeFromTo(wi, wi.length - n, wi.length);
  for (const el of remels) {
    for (const inp of el.charInputs) { unfillCharInput(inp); }
    indivInputs = indivInputs.concat(el.charInputs);
    el.hasBlanks = true;
    el.nMissing = el.charInputs.length;
    if (n > 1) iDiv(el).onclick = onClickWordInput;
  }
  return { iFocus: null, words: remels, letters: indivInputs };
}
function bluff() {
  const rankstr = '3456789TJQKA2';
  function setup(players, options) {
    let fen = { players: {}, plorder: jsCopy(players), history: {}, stage: 'move', phase: '' };
    let num_cards_needed = players.length * options.max_handsize;
    let num_decks_needed = fen.num_decks = Math.ceil(num_cards_needed / 52);
    let deck = fen.deck = create_fen_deck('n', num_decks_needed);
    shuffle(deck);
    shuffle(fen.plorder);
    fen.turn = [fen.plorder[0]];
    for (const plname of fen.plorder) {
      let handsize = options.min_handsize;
      fen.players[plname] = {
        hand: deck_deal(deck, handsize),
        handsize: handsize,
        name: plname,
        color: get_user_color(plname),
      };
    }
    fen.stage = 0;
    return fen;
  }
  function clear_ack() { if (Z.stage == 1) { bluff_change_to_turn_round(); take_turn_fen(); } }
  function check_gameover(Z) { let pls = get_keys(Z.fen.players); if (pls.length < 2) Z.fen.winners = pls; return valf(Z.fen.winners, false); }
  function activate_ui() { bluff_activate_new(); }
  function present(dParent) { bluff_present(dParent); }
  function stats(dParent) { bluff_stats(dParent); }
  function state_info(dParent) { bluff_state(dParent); }
  return { rankstr, setup, activate_ui, check_gameover, clear_ack, present, state_info, stats };
}
function bluff_ack_uplayer() {
  let [A, fen, stage, uplayer] = [Z.A, Z.fen, Z.stage, Z.uplayer];
  fen.players[uplayer].ack = true;
  ack_player(uplayer);
}
function bluff_activate(fen, plname) {
  console.log('activating for', plname)
}
function bluff_activate_new() {
  let [z, A, fen, stage, uplayer, ui, dt] = [Z, Z.A, Z.fen, Z.stage, Z.uplayer, UI, UI.dOpenTable];
  if (stage == 1) bluff_activate_stage1(); else { bluff_activate_stage0(); if (is_ai_player()) ai_move(1000); }
}
function bluff_activate_stage0() {
  let [z, A, fen, stage, uplayer, ui, dt] = [Z, Z.A, Z.fen, Z.stage, Z.uplayer, UI, UI.dOpenTable];
  if (isdef(fen.lastbid)) show(ui.currentBidItem.button);
  bluff_show_new_bid(dt);
  mLinebreak(dt, 10);
  bluff_button_panel1(dt, fen.newbid, 50);
}
function bluff_activate_stage1() {
  let [z, A, fen, stage, uplayer, ui, dt] = [Z, Z.A, Z.fen, Z.stage, Z.uplayer, UI, UI.dOpenTable];
  if (isdef(DA.ack) && isdef(DA.ack[uplayer])) { console.log('DA.ack', DA.ack); mText('...waiting for ack', dt); return; }
  if (isdef(ui.dHandsize)) mPulse(ui.dHandsize, 2000);
}
function bluff_ai() {
  let [A, fen, uplayer, pl] = [Z.A, Z.fen, Z.uplayer, Z.pl];
  const torank = { _: '_', three: '3', four: '4', five: '5', six: '6', seven: '7', eight: '8', nine: '9', ten: 'T', jack: 'J', queen: 'Q', king: 'K', ace: 'A' };
  const toword = { _: '_', '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine', T: 'ten', J: 'jack', Q: 'queen', K: 'king', A: 'ace' };
  let words = get_keys(torank).slice(1);
  let all_hand_cards = aggregate_elements(dict2list(fen.players, 'name'), 'hand');
  let no_twos = all_hand_cards.filter(x => x[0] != '2');
  let rankstr = '3456789TJQKA2';
  sortByRank(all_hand_cards, rankstr);
  let byrank = aggregate_player_hands_by_rank(fen);
  let rank_list = dict2list(byrank, 'rank');
  let unique_ranks = sortByRank(get_keys(byrank));
  let myranks = sortByRank(pl.hand.map(x => x[0]));
  let my_unique = unique_ranks.filter(x => myranks.includes(x));
  rank_list.map(x => { x.mine = myranks.includes(x.rank); x.irank = rankstr.indexOf(x.rank); x.i = x.irank + 100 * x.value; });
  rank_list = rank_list.filter(x => x.rank != '2');
  sortByDescending(rank_list, 'i');
  let maxcount = rank_list[0].value;
  let mymaxcount = rank_list.filter(x => x.mine)[0].value;
  let expected = all_hand_cards.length / 13;
  let nreason = Math.max(1, Math.round(expected * 2));
  let n_twos = all_hand_cards.filter(x => x[0] == '2').length;
  let have2 = firstCond(rank_list, x => x.rank == '2' && x.mine);
  return botbest(rank_list, maxcount, mymaxcount, expected, nreason, n_twos, have2, words, fen);
}
function bluff_button_panel1(dt, bid, sz) {
  let n = bid[0] == '_' ? 1 : Number(bid[0]);
  let arr1 = arrRange(n, n + 5);
  let arr2 = toLetters('3456789TJQKA');
  let arr3 = arrRange(0, 5);
  let arr4 = toLetters('3456789TJQKA');
  let dPanel = mDiv(dt, { gap: 5 });
  [d1, d2, d3, d4] = mColFlex(dPanel, [1, 2, 1, 2]);
  UI.dn1 = create_bluff_input1(d1, arr1, 1, sz, 0); d1.onmouseenter = () => iHigh(UI.panelItems[0]); d1.onmouseleave = () => iUnhigh(UI.panelItems[0]);
  UI.dr1 = create_bluff_input1(d2, arr2, 2, sz, 1); d2.onmouseenter = () => iHigh(UI.panelItems[1]); d2.onmouseleave = () => iUnhigh(UI.panelItems[1]);
  UI.dn2 = create_bluff_input1(d3, arr3, 1, sz, 2); d3.onmouseenter = () => iHigh(UI.panelItems[2]); d3.onmouseleave = () => iUnhigh(UI.panelItems[2]);
  UI.dr2 = create_bluff_input1(d4, arr4, 2, sz, 3); d4.onmouseenter = () => iHigh(UI.panelItems[3]); d4.onmouseleave = () => iUnhigh(UI.panelItems[3]);
}
function bluff_change_to_ack_round(fen, nextplayer) {
  [Z.stage, Z.turn] = [1, [get_admin_player(fen.plorder)]];
  fen.keeppolling = true;
  fen.nextturn = [nextplayer];
}
function bluff_change_to_turn_round() {
  let [fen, stage] = [Z.fen, Z.stage];
  assertion(stage == 1, "ALREADY IN TURN ROUND!!!!!!!!!!!!!!!!!!!!!!");
  Z.stage = 0;
  Z.turn = fen.nextturn;
  Z.round += 1;
  for (const k of ['bidder', 'loser', 'aufheber', 'lastbid', 'lastbidder']) delete fen[k];
  for (const k of ['nextturn', 'keeppolling']) delete fen[k];
  for (const plname of fen.plorder) { delete fen.players[plname].lastbid; }
}
function bluff_clear_panel() {
  for (const item of UI.panelItems) {
    let d = iDiv(item);
    d.innerHTML = '_';
  }
  Z.fen.newbid = ['_', '_', '_', '_'];
}
function bluff_convert2ranks(b) { return [b[0], BLUFF.torank[b[1]], b[2] == '_' ? 0 : b[2], BLUFF.torank[b[3]]]; }
function bluff_convert2words(b) { return [b[0], BLUFF.toword[b[1]], b[2] < 1 ? '_' : b[2], BLUFF.toword[b[3]]]; }
function bluff_generate_random_bid() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  const di2 = { _: '_', three: 3, four: 4, five: 5, six: 6, seven: 7, eight: 8, nine: 9, ten: 'T', jack: 'J', queen: 'Q', king: 'K', ace: 'A' };
  let words = get_keys(di2).slice(1);
  let b = isdef(fen.lastbid) ? jsCopy(fen.lastbid) : null;
  if (isdef(b)) {
    assertion(b[0] >= (b[2] == '_' ? 0 : b[2]), 'bluff_generate_random_bid: bid not formatted correctly!!!!!!!', b)
    let nmax = calc_reasonable_max(fen);
    let n = b[0] == '_' ? 1 : Number(b[0]);
    let done = false;
    if (n > nmax + 1) {
      const di = { '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine', T: 'ten', J: 'jack', Q: 'queen', K: 'king', A: 'ace' };
      let rankstr = '3456789TJQKA';
      let w1 = di2[b[1]];
      let idx = isdef(w1) ? rankstr.indexOf(w1) : -1;
      if (idx >= 0 && idx < rankstr.length - 2) {
        let r = rankstr[idx + 1];
        b[1] = di[r];
        done = true;
      }
    }
    if (!done) {
      if (b[3] == '_') { b[2] = 1; b[3] = rChoose(words, 1, x => x != b[1]); }
      else if (b[0] > b[2]) { b[2] += 1; }
      else { b[0] += coin(80) ? 1 : 2; if (coin()) b[2] = b[3] = '_'; }
    }
  } else {
    let nmax = calc_reasonable_max(fen);
    let nmin = Math.max(nmax - 1, 1);
    let arr_nmax = arrRange(1, nmax);
    let arr_nmin = arrRange(1, nmin);
    b = [rChoose(arr_nmax), rChoose(words), rChoose(arr_nmin), rChoose(words)];
    if (b[1] == b[3]) b[3] = rChoose(words, 1, x => x != b[1]);
    if (coin()) b[2] = b[3] = '_';
  }
  fen.newbid = b;
  UI.dAnzeige.innerHTML = bid_to_string(b);
}
function bluff_present(fen, dParent, plname) {
  console.log('fen', fen);
}
function bluff_present_new(dParent) {
  let [dOben, dOpenTable, dMiddle, dRechts] = tableLayoutMR(dParent, 1, 0);
  let [fen, uplayer, ui, stage, dt] = [Z.fen, Z.uplayer, UI, Z.stage, dOpenTable];
  clearElement(dt); mCenterFlex(dt);
  if (stage == 1) { DA.no_shield = true; } else { DA.ack = {}; DA.no_shield = false; }
  bluff_stats_new(dt);
  mLinebreak(dt, 10);
  bluff_show_cards(dt);
  mLinebreak(dt, 4);
  let item = ui.currentBidItem = bluff_show_current_bid(dt);
  hide(item.button);
  mLinebreak(dt, 10);
  if (stage == 1) {
    let loser = fen.loser;
    let msg1 = fen.war_drin ? 'war drin!' : 'war NICHT drin!!!';
    let msg2 = isdef(fen.players[loser]) ? `${capitalize(loser)} will get ${fen.players[loser].handsize} cards!` : `${capitalize(loser)} is out!`;
    mText(`<span style="color:red">${msg1} ${msg2}</span>`, dt, { fz: 22 });
    mLinebreak(dt, 4);
  }
}
function bluff_reset_to_current_bid() { onclick_reload(); }
function bluff_setup(players) {
  let fen = {};
  let deck = fen.deck = get_keys(Aristocards).filter(x => 'r'.includes(x[2]));
  shuffle(deck);
  let pls = fen.players = {};
  for (const uname of players) {
    let pl = pls[uname] = {};
    pl.hand = deck_deal(deck, 2);
  }
  fen.plorder = rPlayerOrder(players);
  fen.turn = [fen.plorder[0]];
  fen.iturn = 0;
  fen.round = [];
  fen.phase = 'create';
  fen.instruction = 'bid!';
  return fen;
}
function bluff_show_cards(dt) {
  let [fen, ui, stage, uplayer] = [Z.fen, UI, Z.stage, Z.uplayer];
  let pl = fen.players[uplayer], upl = ui.players[uplayer] = {};
  mText(stage == 1 ? "all players' cards: " : "player's hand: ", dt); mLinebreak(dt, 2);
  let cards = stage == 1 ? fen.akku : pl.hand;
  cards = sort_cards(cards, false, 'CDSH', true, '3456789TJQKA2');
  let hand = upl.hand = ui_type_hand(cards, dt, { hmin: 160 }, null, '', ckey => ari_get_card(ckey, 150));
  let uname_plays = isdef(fen.players[Z.uname]);;
  let ishidden = stage == 0 && uname_plays && uplayer != Z.uname && Z.mode != 'hotseat';
  if (ishidden) { hand.items.map(x => face_down(x)); }
}
function bluff_show_current_bid(dt) {
  let fen = Z.fen;
  let bid = fen.oldbid = valf(fen.lastbid, ['_', '_', '_', '_']);
  let d = mDiv(dt);
  let content = `${bid_to_string(bid)}`;
  let item = { container: d, label: 'current bid', content: content, caption: 'geht hoch!', handler: handle_gehtHoch };
  apply_skin2(item);
  return item;
}
function bluff_show_new_bid(dt) {
  let fen = Z.fen;
  let bid = fen.oldbid = valf(fen.lastbid, ['_', '_', '_', '_']);
  fen.newbid = jsCopy(bid);
  let d = mDiv(dt);
  let content = `${bid_to_string(bid)}`;
  let item = { container: d, label: 'YOUR bid', content: content, caption: 'BID', handler: handle_bid };
  apply_skin3(item);
}
function bluff_start_bid(o) {
  let ranks = rChoose(BLUFF.rankstr, 2).map(x => BLUFF.toword[x]);
  let b2 = coin(10) ? '_' : rNumber(1, 4);
  o.fen.lastbid = [rNumber(1, 4), ranks[0], b2, b2 == '_' ? '_' : ranks[1]];
}
function bluff_state(dParent) {
  let user_html = get_user_pic_html(Z.uplayer, 30);
  dParent.innerHTML = `Round ${Z.round}:&nbsp;player: ${user_html} `;
}
function bluff_state_new(dParent) {
  let user_html = get_user_pic_html(Z.uplayer, 30);
  dParent.innerHTML = `Round ${Z.round}:&nbsp;player: ${user_html} `;
}
function bluff_stats(dParent) {
  let player_stat_items = UI.player_stat_items = ui_player_info(dParent, {}, { 'border-width': 1, margin: 10, wmax: 180 });
  let fen = Z.fen;
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    let item = player_stat_items[plname];
    let d = iDiv(item); mCenterFlex(d); mLinebreak(d);
    if (fen.turn.includes(plname)) {
      let dh = show_hourglass(plname, d, 20, { left: -4, top: 0 });
    }
    let dhz = mDiv(d, { fg: pl.handsize == Z.options.max_handsize ? 'yellow' : 'white' }, null, `hand: ${pl.handsize}`); mLinebreak(d);
    if (plname == fen.loser) UI.dHandsize = dhz;
    let elem = mDiv(d, { fg: plname == fen.lastbidder ? 'red' : 'white' }, null, `${valf(pl.lastbid, ['_']).join(' ')}`);
    let szhand = getSizeNeeded(dhz);
    let sz = getSizeNeeded(elem);
    let w = Math.max(szhand.w + 20, sz.w + 20, 80);
    mStyle(d, { w: w });
    mLinebreak(d);
  }
  return player_stat_items[Z.uplayer];
}
function bluff_stats_new(dParent) {
  let player_stat_items = UI.player_stat_items = ui_player_info(Z, dParent, {}, { 'border-width': 1, margin: 10, wmax: 180 });
  let fen = Z.fen;
  for (const uname of fen.plorder) {
    let pl = fen.players[uname];
    let item = player_stat_items[uname];
    let d = iDiv(item); mCenterFlex(d); mLinebreak(d);
    if (fen.turn.includes(uname)) {
      let dh = show_hourglass(uname, d, 20, { left: -4, top: 0 });
    }
    let dhz = mDiv(d, { fg: pl.handsize == Z.options.max_handsize ? 'yellow' : 'white' }, null, `hand: ${pl.handsize}`); mLinebreak(d);
    if (uname == fen.loser) UI.dHandsize = dhz;
    let elem = mDiv(d, { fg: uname == fen.lastbidder ? 'red' : 'white' }, null, `${valf(pl.lastbid, ['_']).join(' ')}`);
    let szhand = getSizeNeeded(dhz);
    let sz = getSizeNeeded(elem);
    let w = Math.max(szhand.w + 20, sz.w + 20, 80);
    mStyle(d, { w: w });
    mLinebreak(d);
  }
  return player_stat_items[Z.uplayer];
}
function bNei(arr, idx, rows, cols, includeDiagonals = true) {
  let nei = [];
  let [r, c] = iToRowCol(idx, rows, cols);
  if (r > 0) nei.push(idx - cols); else nei.push(null);
  if (r > 0 && c < cols - 1 && includeDiagonals) nei.push(idx - cols + 1); else nei.push(null);
  if (c < cols - 1) nei.push(idx + 1); else nei.push(null);
  if (r < rows - 1 && c < cols - 1 && includeDiagonals) nei.push(idx + cols + 1); else nei.push(null);
  if (r < rows - 1) nei.push(idx + cols); else nei.push(null);
  if (r < rows - 1 && c > 0 && includeDiagonals) nei.push(idx + cols - 1); else nei.push(null);
  if (c > 0) nei.push(idx - 1); else nei.push(null);
  if (r > 0 && c > 0 && includeDiagonals) nei.push(idx - cols - 1); else nei.push(null);
  return nei;
}
function bNeiDir(arr, idx, dir, rows, cols, includeDiagonals = true) {
  let [r, c] = iToRowCol(idx, rows, cols);
  switch (dir) {
    case 0: if (r > 0) return (idx - cols); else return (null);
    case 1: if (r > 0 && c < cols - 1 && includeDiagonals) return (idx - cols + 1); else return (null);
    case 2: if (c < cols - 1) return (idx + 1); else return (null);
    case 3: if (r < rows - 1 && c < cols - 1 && includeDiagonals) return (idx + cols + 1); else return (null);
    case 4: if (r < rows - 1) return (idx + cols); else return (null);
    case 5: if (r < rows - 1 && c > 0 && includeDiagonals) return (idx + cols - 1); else return (null);
    case 6: if (c > 0) return (idx - 1); else return (null);
    case 7: if (r > 0 && c > 0 && includeDiagonals) return (idx - cols - 1); else return (null);
  }
  return null;
}
function boa_save() { localStorage.setItem('boa', JSON.stringify(S)); }
function boa_start() {
  let d = mBy('dBoa');
  mClear(d);
  mAppend(d, get_header_top('Log In'));
  mAppend(d, get_red_header('Mobile and Online Bill Pay', true));
  mAppend(d, get_boa_start_content());
  let footer = mAppend(d, get_boa_footer1());
  mStyle(footer, { matop: 100, hmax: 150 });
  S.boa_loggedin = false;
}
function boahavecode_start() {
  let d = mBy('dBoa');
  mClear(d);
  mAppend(d, get_header_top('Extra Security At Sign-in'));
  mAppend(d, get_red_header('Verify Your Identity'));
  add_havecode_content(d);
  mAppend(d, get_boa_footer2());
  S.boa_state = 'authorization_pending';
  console.log(S.boa_authorization_code);
}
function boalogin_start() {
  console.log('boalogin_start');
  let d = mBy('dBoa');
  mClear(d);
  mAppend(d, get_header_top(''));
  mAppend(d, get_red_header('Log In to Online Banking'));
  mAppend(d, get_boalogin_html());
  mAppend(d, get_boa_footer2());
  S.boa_state = 'loginform';
  let elem = get_boa_userid_input();
  elem.onfocus = () => { bw_symbol_pulse(); S.current_input = get_boa_userid_input(); S.current_label = 'userid'; };
  let elem2 = get_boa_pwd_input();
  elem2.onfocus = () => { bw_symbol_pulse(); S.current_input = get_boa_pwd_input(); S.current_label = 'pwd'; };
}
function boamain_start() {
  S.boa_state = 'authorized';
  if (DA.challenge == 1) {
    TO.boa = setTimeout(() => {
      S.boa_state = null;
      let msg = DA.challenge == 1 ? 'CONGRATULATIONS!!!! YOU SUCCEEDED IN LOGGING IN TO BOA' : 'Session timed out!';
      show_eval_message(true, null, onclick_home);
    }, 1000);
  } else if (DA.challenge == 3) show_bill_button();
  show_correct_location('boa');
  let dParent = mBy('dBoa'); mClear(dParent);
  let d0 = mDiv(dParent, { align: 'center' }, 'dBoaMain'); mCenterFlex(d0);
  let [wtotal, wleft, wright] = [972, 972 - 298, 292];
  let d = mDiv(d0, { w: wtotal, hmin: 500 }); mAppend(d, createImage('boamain_header.png', { h: 111 }));
  let dl = mDiv(d, { float: 'left', w: wleft, hmin: 400 });
  let dr = mDiv(d, { float: 'right', hmin: 400, w: wright });
  mDiv(dr, { h: 100 });
  mAppend(dr, createImage('boamain_rechts.png', { w: 292 }));
  mAppend(dl, createImage('boamain_left_top.jpg', { matop: 50, maleft: -20 }));
  mDiv(dl, { bg: '#857363', fg: 'white', fz: 15 }, null, '&nbsp;&nbsp;<i class="fa fa-caret-down"></i>&nbsp;&nbsp;Default Group<div style="float:right;">Sort&nbsp;&nbsp;</div>');
  let boadata = get_fake_boa_data_list();
  let color_alt = '#F9F7F4';
  let i = 0;
  for (const o of boadata) {
    let k = o.key;
    o.index = i;
    let logo = valf(o.logo, 'defaultacct.jpg');
    let path = `${logo}`;
    let [sz, bg] = [25, i % 2 ? 'white' : color_alt];
    let dall = mDiv(dl, { bg: bg, fg: '#FCFCFC', 'border-bottom': '1px dotted silver' }, `dAccount${i}`);
    let da = mDiv(dall);
    mFlexLR(da);
    let img = createImage(path, { h: sz, margin: 10 });
    let da1 = mDiv(da);
    mAppend(da1, img);
    let dtext = mDiv(da1, { align: 'left', display: 'inline-block', fg: '#FCFCFC', fz: 14 });
    mAppend(dtext, mCreateFrom(`<a>${k}</a>`));
    let dsub = mDiv(dtext, { fg: 'dimgray', fz: 12 }, null, o.sub);
    let da2 = mDiv(da); mFlex(da2);
    let da21 = mDiv(da2, { w: 100, hmargin: 20, mabottom: 20 });
    let padinput = 7;
    mDiv(da21, { fg: 'black', fz: 12, weight: 'bold' }, null, 'Amount');
    mDiv(da21, { w: 100 }, null, `<input onfocus="add_make_payments_button(event)" style="color:dimgray;font-size:14px;border:1px dotted silver;padding:${padinput}px;width:85px" id="inp${i}" name="authocode" value="$" type="text" />`);
    let da22 = mDiv(da2, { maright: 10 });
    mDiv(da22, { fg: 'black', fz: 12, weight: 'bold' }, null, 'Deliver By');
    mDiv(da22, {}, null, `<input style="color:dimgray;font-size:12px;border:1px dotted silver;padding:${padinput}px" id="inpAuthocode" name="authocode" value="" type="date" />`);
    let dabot = mDiv(dall);
    mFlexLR(dabot);
    let lastpayment = isdef(o['Last Payment']) ? `Last Payment: ${o['Last Payment']}` : ' ';
    mDiv(dabot, { fz: 12, fg: '#303030', maleft: 10, mabottom: 25 }, null, `${lastpayment}`);
    mDiv(dabot, { fz: 12, fg: 'blue', maright: 90, mabottom: 25 }, null, `<a>Activity</a>&nbsp;&nbsp;&nbsp;<a>Reminders</a>&nbsp;&nbsp;&nbsp;<a>AutoPay</a>`);
    mDiv(dall);
    i++;
  }
}
function board_to_fen(board) {
  let result = "";
  for (let y = 0; y < board.length; y++) {
    let empty = 0;
    for (let x = 0; x < board[y].length; x++) {
      let c = board[y][x][0];
      if (c == 'w' || c == 'b') {
        if (empty > 0) {
          result += empty.toString();
          empty = 0;
        }
        if (c == 'w') {
          result += board[y][x][1].toUpperCase();
        } else {
          result += board[y][x][1].toLowerCase();
        }
      } else {
        empty += 1;
      }
    }
    if (empty > 0) {
      result += empty.toString();
    }
    if (y < board.length - 1) {
      result += '/';
    }
  }
  result += ' w KQkq - 0 1';
  return result;
}
function boardArrOmitFirstRowCol(boardArr, rows, cols) {
  let res = [];
  for (let r = 1; r < rows; r++) {
    for (let c = 1; c < cols; c++) {
      let i = iFromRowCol(r, c, rows, cols);
      res.push(boardArr[i]);
    }
  }
  return res;
}
function boardArrReduced(boardArr, rows, cols) {
  let res = [];
  for (let r = 1; r < rows; r++) {
    for (let c = 1; c < cols; c++) {
      let i = iFromRowCol(r, c, rows, cols);
      res.push(boardArr[i]);
    }
  }
  return res;
}
function boardTestGetCol() {
  let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
  let [rows, cols] = [3, 4];
  for (let i = 0; i < cols; i++) {
    let x = bGetCol(arr, i, rows, cols);
    console.log('arr', toBoardString(arr, rows, cols), 'col', i, x);
  }
}
function boardTestGetRow() {
  let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
  let [rows, cols] = [6, 2];
  for (let i = 0; i < rows; i++) {
    let x = bGetRow(arr, i, rows, cols);
    console.log('arr', toBoardString(arr, rows, cols), 'row', i, x);
  }
}
function BoardToFen() {
  var fenStr = '';
  var rank, file, sq, piece;
  var emptyCount = 0;
  for (rank = RANKS.RANK_8; rank >= RANKS.RANK_1; rank--) {
    emptyCount = 0;
    for (file = FILES.FILE_A; file <= FILES.FILE_H; file++) {
      sq = FR2SQ(file, rank);
      piece = brd_pieces[sq];
      if (piece == PIECES.EMPTY) {
        emptyCount++;
      } else {
        if (emptyCount != 0) {
          fenStr += String.fromCharCode('0'.charCodeAt() + emptyCount);
        }
        emptyCount = 0;
        fenStr += PceChar[piece];
      }
    }
    if (emptyCount != 0) {
      fenStr += String.fromCharCode('0'.charCodeAt() + emptyCount);
    }
    if (rank != RANKS.RANK_1) {
      fenStr += '/'
    } else {
      fenStr += ' ';
    }
  }
  fenStr += SideChar[brd_side] + ' ';
  if (brd_enPas == SQUARES.NO_SQ) {
    fenStr += '- '
  } else {
    fenStr += PrSq(brd_enPas) + ' ';
  }
  if (brd_castlePerm == 0) {
    fenStr += '- '
  } else {
    if (brd_castlePerm & CASTLEBIT.WKCA) fenStr += 'K';
    if (brd_castlePerm & CASTLEBIT.WQCA) fenStr += 'Q';
    if (brd_castlePerm & CASTLEBIT.BKCA) fenStr += 'k';
    if (brd_castlePerm & CASTLEBIT.BQCA) fenStr += 'q';
  }
  fenStr += ' ';
  fenStr += brd_fiftyMove;
  fenStr += ' ';
  var tempHalfMove = brd_hisPly;
  if (brd_side == COLOURS.BLACK) {
    tempHalfMove--;
  }
  fenStr += tempHalfMove / 2;
  return fenStr;
}
function boardToNode(state) {
  let res = new Array();
  for (let i = 0; i < state.length; i++) {
    if (state[i] == null) res[i] = ' ';
    else res[i] = state[i];
  }
  return res;
}
function boaverify_start() {
  let d = mBy('dBoa');
  mClear(d);
  mAppend(d, get_header_top('Extra Security At Sign-in'));
  mAppend(d, get_red_header('Verify Your Identity'));
  add_verify_content(d);
  mAppend(d, get_boa_footer2());
}
function book_animals_1() {
  let pics = {};
  for (const k of KeySets.animals) {
    let item = miPic(k, dContent)
    pics[k] = item;
  }
  return { pics: pics, play: () => { } };
}
function book_blaettern(page) {
  if (DA.currentpage != page && isNumber(DA.currentpage)) mStyleRemove(dFooter.children[DA.currentpage], 'fg');
  mStyle(dFooter.children[page], { fg: 'yellow' });
  DA.currentpage = page;
  dTitle.innerHTML = DA.currentbook.title + ' pg.' + page;
}
function book_cs_1() {
  let o = mCanvas(dContent, { w: 600, h: 300 }, {}, startloop, pauseloop, 'cc');
  o.draw = draw_random_walk;
  return o;
}
function book_cs_2() {
  let o = mCanvas(dContent, { w: 600, h: 300 }, {}, startloop, pauseloop, 'cc');
  o.draw = draw_perlin_x;
  return o;
}
function book_cs_3() {
  let o = mCanvas(dContent, { w: 600, h: 300 }, {}, startloop, pauseloop, 'cc');
  o.draw = draw_perlin_xy;
  return o;
}
function book_cs_4() {
  let o = mCanvas(dContent, { w: 600, h: 300, bg: 'transparent' }, {}, startloop, pauseloop, 'cc');
  o.draw = draw_random_walk;
  return o;
}
function book_get(id) { return jsCopy(DB.appdata.book.find(x => x.id == id)); }
function book_open(item) {
  console.log('BOOK OPEN!!!!!!!!!!!!!!!');
  let d = iDiv(item);
  let dg = mGrid(2, 1, d, { gap: 3, matop: 22 });
  let books = DB.appdata.book;
  for (const book of books) {
    let d1 = mDiv(dg, { fg: rColor(23) }, null, book.title, 'hop1');
    d1.onclick = () => book_open_title(book.id);
  }
}
function book_open_next_page() {
  let page = isNumber(DA.currentpage) ? DA.currentpage + 1 : 1;
  if (page > DA.currentbook.pages) page = 1;
  book_open_page(page);
}
function book_open_page(page) {
  pauseloop(); iClear(dContent);
  book_blaettern(page);
  let book = G = book_get(dContent.getAttribute('book'));
  let func = window[`book_${book.id}_${page}`];
  let o = G.canvas = func();
  iReg(o);
  dButtons = G.canvas.controls;
  addKeys(G, window);
  o.play();
}
function book_open_prev_page() {
  let page = isNumber(DA.currentpage) ? DA.currentpage - 1 : DA.currentbook.pages;
  if (page < 1) page = DA.currentbook.pages;
  book_open_page(page);
}
function book_open_title(id, page) {
  clear_all();
  dTable = mSection({ bg: DB.apps.book.color }, 'dTable', null, null, 'bookgrid');
  let book = DA.currentbook = book_get(id);
  dTitle = mDiv(dTable, {}, null, book.title)
  mButtonX(dTable, () => mClear(dTable), pos = 'tr', sz = 25, color = 'white')
  dContent = mDiv(dTable, {}, 'dContent'); mCenterCenterFlex(dContent);
  dContent.setAttribute('book', id);
  let footer = dFooter = mDiv(dTable, { align: 'center' });
  maButton('<', () => book_open_prev_page(), footer);
  for (const p of range(1, book.pages)) {
    maButton(p, () => book_open_page(p), footer);
  }
  maButton('>', () => book_open_next_page(), footer);
  book_open_page(valf(page, 1));
}
function BookMove() {
  var gameLine = printGameLine();
  var bookMoves = [];
  var lengthOfLineHack = gameLine.length;
  if (gameLine.length == 0) lengthOfLineHack--;
  for (var bookLineNum = 0; bookLineNum < brd_bookLines.length; ++bookLineNum) {
    if (LineMatch(brd_bookLines[bookLineNum], gameLine) == BOOL.TRUE) {
      var move = brd_bookLines[bookLineNum].substr(lengthOfLineHack + 1, 4);
      if (move.length == 4) {
        var from = SqFromAlg(move.substr(0, 2));
        var to = SqFromAlg(move.substr(2, 2));
        varInternalMove = ParseMove(from, to);
        bookMoves.push(varInternalMove);
      }
    }
  }
  console.log("Total + " + bookMoves.length + " moves in array");
  if (bookMoves.length == 0) return NOMOVE;
  var num = Math.floor(Math.random() * bookMoves.length);
  return bookMoves[num];
}
function bot_clairvoyant(list, maxvalue, mmax, exp, nreas, n2, have2, words, fen) {
  let reduced_list = list.filter(x => x.value == list[0].value || x.mine);
  let res = reduced_list.length >= 2 ? rChoose(list, 2) : [reduced_list[0], { value: 0, rank: '_' }];
  let max = res[0].value >= res[1].value ? res[0] : res[1]; let min = res[0].value < res[1].value ? res[0] : res[1];
  let b = [max.value, max.rank, min.value, min.rank];
  if (isdef(fen.lastbid)) {
    let [n1, r1, n2, r2] = bluff_convert2ranks(fen.lastbid);
    if (!is_bid_higher_than(bluff_convert2words(b), fen.lastbid)) {
      return [null, handle_gehtHoch];
    }
  }
  return [bluff_convert2words(b), handle_bid];
}
function bot_perfect(list, max, mmax, exp, nreas, n2, have2, words, fen) {
  let i = 0; while (list[i].rank == '2') i++;
  let b = [list[i].value + n2, list[i].rank, list[i + 1].value, list[i + 1].rank];
  list.map(x => console.log(x));
  console.log('b:', b);
  if (isdef(fen.lastbid)) {
    let [n1, r1, n2, r2] = bluff_convert2ranks(fen.lastbid);
    if (!is_bid_higher_than(bluff_convert2words(b), fen.lastbid)) {
      return [null, handle_gehtHoch];
    }
  }
  return [bluff_convert2words(b), handle_bid];
}
function bot_random(list, max, mmax, exp, nreas, n2, have2, words, fen) {
  let ranks = rChoose('3456789TJQKA', 2);
  let b;
  if (nundef(fen.lastbid)) b = [rNumber(1, nreas), ranks[0], rNumber(1, nreas), ranks[1]];
  else if (fen.lastbid[0] > nreas + 2) {
    return [null, handle_gehtHoch];
  } else {
    [n1, r1, n2, r2] = bluff_convert2ranks(fen.lastbid);
    assertion(isNumber(n1) && n1 > 0 && isNumber(n2), 'bot_random: n1 or n2 is not a number OR n1<=0!!!!!!!', n1, n2);
    if ((n1 + n2) / 2 > nreas && coin(50)) {
      return [null, handle_gehtHoch];
    } else if ((n1 + n2) / 2 <= nreas + 1) b = n1 <= nreas + 1 ? [n1 + 1, r1, n2, r2] : [n1, r1, n2 + 1, r2];
    else {
      let [i1, i2] = [BLUFF.rankstr.indexOf(r1), BLUFF.rankstr.indexOf(r2)];
      let s = '3456789TJQKA';
      let imin = Math.min(i1, i2); let imax = Math.max(i1, i2); let i = imax == i1 ? 1 : 2;
      let [smin, between, smax] = [s.substring(0, imin), s.substring(imin + 1, imax), s.substring(imax + 1, s.length)];
      if (!isEmpty(smax)) { if (i == 1) b = [n1, rChoose(smax), n2, r2]; else b = [n1, r1, n2, rChoose(smax)]; }
      else if (!isEmpty(between)) { if (i == 2) b = [n1, rChoose(between), n2, r2]; else b = [n1, r1, n2, rChoose(between)]; }
      else return [null, handle_gehtHoch];
    }
  }
  return [bluff_convert2words(b), handle_bid];
}
function botbest(list, max, mmax, exp, nreas, n2, have2, words, fen) {
  if (nundef(DA.ctrandom)) DA.ctrandom = 1; console.log(`${DA.ctrandom++}: ${Z.uplayer} using strategy`, Z.strategy)
  let bot = window[`bot_${Z.strategy}`];
  let [b, f] = bot(list, max, mmax, exp, nreas, n2, have2, words, fen);
  assertion(!b || b[2] != 0, 'bot returned bid with n2==0');
  return [b, f];
}
function bottom_elem_from_to(arr1, arr2) { last_elem_from_to(arr1, arr2); }
function bottom_elem_from_to_top(arr1, arr2) { arr2.unshift(arr1.pop()); }
function bPartialCol(arr, icol, rows, cols) {
  let iStart = icol;
  let x = null;
  for (let i = iStart; i < iStart + (cols * rows); i += cols) { if (empty_func(arr[i])) continue; else if (empty_func(x)) x = arr[i]; else if (arr[i] != x) return null; }
  return x;
}
function bPartialDiag(arr, rows, cols) {
  let iStart = 0;
  let x = null;
  for (let i = iStart; i < arr.length; i += cols + 1) { if (empty_func(arr[i])) continue; else if (empty_func(x)) x = arr[i]; else if (arr[i] != x) return null; }
  return x;
}
function bPartialDiag2(arr, rows, cols) {
  let iStart = cols - 1;
  let x = null;
  for (let i = iStart; i < arr.length - 1; i += cols - 1) {
    if (empty_func(arr[i])) continue; else if (empty_func(x)) x = arr[i]; else if (arr[i] != x) return null;
  }
  return x;
}
function bPartialRow(arr, irow, rows, cols) {
  let iStart = irow * cols;
  let x = null;
  for (let i = iStart; i < iStart + cols; i++) {
    if (empty_func(arr[i])) continue;
    else if (empty_func(x)) x = arr[i];
    else if (arr[i] != x) return null;
  }
  return x;
}
function Branch(start, end) {
  this.start = start;
  this.end = end;
  this.init = [start.x, start.y, end.x, end.y];
  this.children = [];
  this.finished = false;
  this.get_healthy_end = () => { return createVector(this.init[2], this.init[3]); }
  this.repair = () => {
    this.start.x = this.init[0];
    this.start.y = this.init[1];
    this.end.x = this.init[2];
    this.end.y = this.init[3];
  }
  this.jitter = () => {
    this.end.x += random(-1, 1);
    this.end.y += random(-1, 1);
  }
  this.show = () => {
    stroke(255);
    line(this.start.x, this.start.y, this.end.x, this.end.y)
  }
  this.branch = (angle, factor = .67) => {
    let dir = p5.Vector.sub(this.end, this.start);
    dir.rotate(angle);
    dir.mult(factor);
    let newend = p5.Vector.add(this.end, dir);
    let b = new Branch(this.end, newend);
    this.children.push(b);
    return b;
  }
}
function branch_draw(o) {
  cStyle({ fg: o.color, thickness: o.thickness, cap: 'round' }, CX);
  if (C.root.jitter) cLine(o.p1.x, o.p1.y, o.p2.x + Math.random() * 2 - 1, o.p2.y + Math.random() * 2 - 1, {}, CX);
  else cLine(o.p1.x, o.p1.y, o.p2.x, o.p2.y, {}, CX);
}
function bRayDir(arr, idx, dir, rows, cols) {
  let indices = [];
  let i = idx;
  while (i < arr.length) {
    let i = bNeiDir(arr, i, dir, rows, cols);
    if (!i) break; else indices.push(i);
  }
  return indices;
}
function bringInfoboxToFront(mobj) {
  mobj.elem.style.zIndex = maxZIndex;
  maxZIndex += 1;
}
function bringToFront(ui) {
  ui.style.zIndex = maxZIndex;
  maxZIndex += 1;
}
async function broadcastSIMA(usersPath = './_users.yaml', settingsPath = './_settings.yaml', gamesPath = './_games.yaml', addonsPath = './_addons.yaml') {
  let users = await loadYamlDict(usersPath);
  let settings = await loadYamlDict(settingsPath);
  let games = await loadYamlDict(gamesPath);
  let addons = await loadYamlDict(addonsPath);
  DB = {
    id: 'speechGames',
    users: users,
    settings: settings,
    games: games,
    addons: addons,
  };
  saveSIMA();
  if (CLEAR_LOCAL_STORAGE) localStorage.clear();
  await loadAssetsSIMA('../assets/');
}
function bStrideCol(arr, icol, rows, cols, stride) {
  for (let i = 0; i <= rows - stride; i++) {
    let ch = bStrideColFrom(arr, i, icol, rows, cols, stride);
    if (ch) return ch;
  }
  return null;
}
function bStrideColFrom(arr, irow, icol, rows, cols, stride) {
  if (rows - irow < stride) return null;
  let iStart = irow * cols + icol;
  let x = arr[iStart];
  if (empty_func(x)) return null;
  for (let i = iStart + cols; i < iStart + cols * stride; i += cols) if (arr[i] != x) return null;
  return x;
}
function bStrideDiag2From(arr, irow, icol, rows, cols, stride) {
  if (rows - irow < stride || icol - stride + 1 < 0) return null;
  let iStart = irow * cols + icol;
  let x = arr[iStart];
  if (empty_func(x)) return null;
  for (let i = iStart + cols - 1; i < iStart + (cols - 1) * stride; i += cols - 1) if (arr[i] != x) return null;
  return x;
}
function bStrideDiagFrom(arr, irow, icol, rows, cols, stride) {
  if (rows - irow < stride || cols - icol < stride) return null;
  let iStart = irow * cols + icol;
  let x = arr[iStart];
  if (empty_func(x)) return null;
  for (let i = iStart + cols + 1; i < iStart + (cols + 1) * stride; i += cols + 1) if (arr[i] != x) return null;
  return x;
}
function bStrideRow(arr, irow, rows, cols, stride) {
  for (let i = 0; i <= cols - stride; i++) {
    let ch = bStrideRowFrom(arr, irow, i, rows, cols, stride);
    if (ch) return ch;
  }
  return null;
}
function bStrideRowFrom(arr, irow, icol, rows, cols, stride) {
  if (cols - icol < stride) return null;
  let iStart = irow * cols + icol;
  let x = arr[iStart];
  if (empty_func(x)) return null;
  for (let i = iStart + 1; i < iStart + stride; i++) if (arr[i] != x) return null;
  return x;
}
function bTest01() {
  let arr = [1, 1, 1, 1, 2, 1, 0, 1, 0], rows = 3, cols = 3, irow = 0;
  console.log(bFullRow(arr, irow, rows, cols));
  console.log('____________')
  arr = [1, 1, 1, 1, 2, 1, 1, 1, 0], rows = 3, cols = 3, irow = 2;
  console.log(bFullRow(arr, irow, rows, cols));
  console.log('____________')
  arr = [1, 1, 1, 1, 2, 1, 1, 1, 0], rows = 3, cols = 3, icol = 0;
  console.log(bFullCol(arr, icol, rows, cols));
  console.log('____________')
  arr = [1, 1, 0, 2, 1, 1, 1, 0, 1], rows = 3, cols = 3;
  console.log(bFullDiag(arr, rows, cols));
  console.log('____________')
  arr = [2, 1, 0, 2, 1, 1, 1, 0, 1], rows = 3, cols = 3;
  console.log(bFullDiag(arr, rows, cols));
  console.log('____________')
  arr = [2, 1, 0, 0, 2, 1, 1, 0, 1], rows = 3, cols = 3;
  console.log(bFullDiag(arr, rows, cols));
  console.log('____________')
  arr = [2, 2, 1, 2, 1, 2, 1, 2, 2], rows = 3, cols = 3;
  console.log(bFullDiag2(arr, rows, cols));
  console.log('____________')
  arr = [2, 1, 0, 0, 0, 1, 0, 0, 1], rows = 3, cols = 3;
  console.log(bFullDiag2(arr, rows, cols));
  console.log('============================')
}
function bTest02() {
  let arr = [1, null, 1, 1, 2, 1, 0, 1, 0], rows = 3, cols = 3, irow = 0;
  console.log(bPartialRow(arr, irow, rows, cols));
  console.log('____________')
  arr = [1, 1, 1, 1, 0, 1, 1, 1, 2], rows = 3, cols = 3, irow = 2;
  console.log(bPartialRow(arr, irow, rows, cols));
  console.log('____________')
  arr = [1, 1, 1, null, 2, 1, 1, 1, 0], rows = 3, cols = 3, icol = 0;
  console.log(bPartialCol(arr, icol, rows, cols));
  console.log('____________')
  arr = [1, 1, 0, 2, null, 1, 1, 0, 1], rows = 3, cols = 3;
  console.log(bPartialDiag(arr, rows, cols));
  console.log('____________')
  arr = [2, 1, 0, 2, 1, 1, 1, 0, 1], rows = 3, cols = 3;
  console.log(bPartialDiag(arr, rows, cols));
  console.log('____________')
  arr = [2, 1, 0, 0, 2, 1, 1, 0, 1], rows = 3, cols = 3;
  console.log(bPartialDiag(arr, rows, cols));
  console.log('____________')
  arr = [2, 2, 1, 2, null, 2, 1, 2, 2], rows = 3, cols = 3;
  console.log(bPartialDiag2(arr, rows, cols));
  console.log('____________')
  arr = [2, 1, 0, 0, 0, 1, 0, 0, 1], rows = 3, cols = 3;
  console.log(bPartialDiag2(arr, rows, cols));
}
function bTest03() {
  let arr = [[0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
  ['O', 'X', 0, 0, 0, 0, 0],
  ['O', 'O', 'O', 'O', 0, 0, 0]]
  let arrf = arrFlatten(arr), rows = 6, cols = 7, irow = 5, stride = 4;
  console.log('arr', arr[5]);
  console.log('stride in row', irow + ':', bStrideRow(arrf, irow, rows, cols, stride));
  console.log('____________');
  arr = [[0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
  ['O', 'X', 0, 0, 0, 0, 0],
  [0, 0, 0, 'O', 'O', 'O', 0]]
  arrf = arrFlatten(arr), rows = 6, cols = 7, irow = 5, stride = 4;
  console.log('arr', arr[5]);
  console.log('stride in row', irow + ':', bStrideRow(arrf, irow, rows, cols, stride));
  console.log('____________');
  arr = [[0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
  ['O', 'X', 0, 0, 0, 0, 0],
  [0, 'O', 'O', 'O', 'O', 0, 0]]
  arrf = arrFlatten(arr), rows = 6, cols = 7, irow = 5, stride = 4;
  console.log('arr', arr[5]);
  console.log('stride in row', irow + ':', bStrideRow(arrf, irow, rows, cols, stride));
  console.log('____________');
  arr = [[0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
  ['O', 'X', 0, 0, 0, 0, 0],
  [0, 0, 0, 'O', 'O', 'O', 'O']]
  arrf = arrFlatten(arr), rows = 6, cols = 7, irow = 5, stride = 4;
  console.log('arr', arr[5]);
  console.log('stride in row', irow + ':', bStrideRow(arrf, irow, rows, cols, stride));
  console.log('____________');
}
function bTest04() {
  let arr = [[0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0],
  ['O', 0, 0, 0, 0, 0, 0],
  ['O', 0, 0, 0, 0, 0, 0],
  ['O', 'X', 0, 0, 0, 0, 0],
  ['O', 'O', 'O', 'O', 0, 0, 0]]
  let arrf = arrFlatten(arr), rows = 6, cols = 7, icol = 0, stride = 4;
  console.log('stride in col', icol + ':', bStrideCol(arrf, icol, rows, cols, stride));
  console.log('____________');
  arr = [[0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 'X', 0, 0],
  ['O', 0, 0, 0, 'X', 0, 0],
  ['O', 0, 0, 0, 'O', 0, 0],
  ['O', 'X', 0, 0, 'X', 0, 0],
  ['O', 'O', 'O', 'O', 0, 0, 0]]
  arrf = arrFlatten(arr), rows = 6, cols = 7, icol = 4, stride = 4;
  console.log('stride in col', icol + ':', bStrideCol(arrf, icol, rows, cols, stride));
  console.log('____________');
  arr = [[0, 0, 'X', 0, 'X', 0, 0],
  [0, 0, 0, 0, 'X', 0, 0],
  ['O', 0, 0, 0, 'X', 0, 0],
  ['O', 0, 0, 0, 'X', 0, 0],
  ['O', 'X', 0, 0, 'O', 0, 0],
  ['O', 'O', 'O', 'O', 0, 0, 0]]
  arrf = arrFlatten(arr), rows = 6, cols = 7, icol = 4, stride = 4;
  console.log('stride in col', icol + ':', bStrideCol(arrf, icol, rows, cols, stride));
  console.log('____________');
}
function bTest05() {
  let arr = [
    [0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0],
    ['O', 0, 0, 0, 0, 0, 0],
    [0, 'O', 0, 0, 0, 0, 0],
    ['O', 'X', 'O', 0, 0, 0, 0],
    ['O', 'O', 'O', 'O', 0, 0, 0]]
  let arrf = arrFlatten(arr), rows = 6, cols = 7, irow = 2, icol = 0, stride = 4;
  console.log('stride in diag', irow, icol + ':', bStrideDiagFrom(arrf, irow, icol, rows, cols, stride));
  console.log('____________');
  arr = [
    [0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 'X', 0],
    ['O', 0, 0, 0, 0, 0, 'X'],
    [0, 'O', 0, 0, 0, 0, 0],
    ['O', 'X', 'O', 0, 0, 0, 0],
    ['O', 'O', 'O', 'O', 0, 0, 0]]
  arrf = arrFlatten(arr), rows = 6, cols = 7, irow = 1, icol = 5, stride = 4;
  console.log('stride in diag', irow, icol + ':', bStrideDiagFrom(arrf, irow, icol, rows, cols, stride));
  console.log('____________');
  arr = [
    [0, 0, 0, 0, 0, 0, 'X'],
    [0, 0, 0, 0, 0, 'X', 0],
    ['O', 0, 0, 0, 'X', 0, 'X'],
    [0, 'O', 0, 'X', 0, 0, 0],
    ['O', 'X', 'O', 0, 0, 0, 0],
    ['O', 'O', 'O', 'O', 0, 0, 0]]
  arrf = arrFlatten(arr), rows = 6, cols = 7, irow = 0, icol = 6, stride = 4;
  console.log('stride in diag2', irow, icol + ':', bStrideDiag2From(arrf, irow, icol, rows, cols, stride));
  console.log('____________');
  arr = [
    [0, 0, 0, 0, 0, 0, 'X'],
    [0, 0, 0, 0, 0, 'X', 0],
    ['O', 0, 0, 'O', 'X', 0, 'X'],
    [0, 'O', 'O', 'X', 0, 0, 0],
    ['O', 'O', 'O', 0, 0, 0, 0],
    ['O', 'O', 'O', 'O', 0, 0, 0]]
  arrf = arrFlatten(arr), rows = 6, cols = 7, irow = 2, icol = 3, stride = 4;
  console.log('stride in diag2', irow, icol + ':', bStrideDiag2From(arrf, irow, icol, rows, cols, stride));
  console.log('____________');
}
function bTest06() {
  let pos = [
    [0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0],
    [0, 'X', 0, 0, 0, 0, 0],
    [0, 'X', 0, 'O', 0, 0, 0],
    ['O', 'X', 0, 'O', 0, 0, 0],
    ['O', 'X', 0, 'O', 0, 0, 0]];
  let arr = arrFlatten(pos);
  let str = bStrideCol(arr, 1, 6, 7, 4);
  console.log('stride', str)
  let w = checkWinnerC4(arr, 6, 7, 4);
  printState(arr)
  console.log('w', w);
}
function bTest07() {
  let arr = [0, 0, 0, 0, 0, 0, 0, "X", 0, 0, 0, 0, 0, 0, "X", 0, 0, "X", "X", 0, "O", "X", 0, "X", "O", "O", "O", "X", "O", "X", "O", "O", "O", "X", "O", "O", "X", "O", "O", "O", "X", "O"];
  let w = checkWinnerC4(arr, 6, 7, 4);
  printState(arr)
  console.log('w', w);
}
function bTest08() {
  let arr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "X", 0, 0, 0, "X", 0, 0, "O", 0, 0, 0, "O", "X", 0, "O", 0, 0, 0, "O", "X", "O", "O", "O", "O", 0];
  let w = checkWinnerC4(arr, 6, 7, 4);
  printState(arr)
  console.log('w', w);
}
function bTest09() {
  let pos = [
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 'X', 0, 0, 0],
    [0, 'X', 0, 'O', 0],
    ['O', 'X', 0, 'O', 0]];
  let arr = arrFlatten(pos);
  let nei = bNei(arr, 6, 5, 5);
  console.log(nei)
  nei = bNei(arr, 0, 5, 5);
  console.log(nei)
  nei = bNei(arr, 24, 5, 5);
  console.log(nei)
}
function bTest10() {
  let pos = [
    [0, 1, 2, 3, 4, 5],
    [6, 7, 8, 9, 10, 11],
    [12, 13, 14, 15, 16, 17],
    [18, 19, 20, 21, 22, 23],
    [24, 25, 26, 27, 28, 29]];
  let arr = arrFlatten(pos);
  printState(arr);
  let nei = bNei(arr, 6, 6, 6);
  console.log(nei);
  nei = bNei(arr, 7, 6, 6);
  console.log(nei);
  nei = bNei(arr, 16, 6, 6);
  console.log(nei);
}
function btest11_fractions() {
  let a = math.fraction(1, 4);
  let b = math.fraction(1, 4);
  let c = math.multiply(a, b);
  console.log(a, b, c);
  let d = math.add(a, b);
  console.log(d)
  let e = math.multiply(2, a);
  console.log(e)
}
function buildChanav(n, rParent) {
  let parentChanav = convertToList(rParent ? rParent.chanav : R.initialChannels);
  let ownChanav = convertToList(n.chanav);
  let res = ownChanav;
  parentChanav.map(x => addIf(res, x));
  return isEmpty(res) ? null : res.length == 1 ? res[0] : res;
}
function building_is_correct(b) {
  let key = b.keycard.key;
  let list = b.list;
  for (let i = 0; i < list.length; i++) { if (list[i][0] != key[0]) return false; }
  return true;
}
function buildNewSyms() {
  let newSyms = {};
  for (const k of KeySets.all) {
    let info = Syms[k];
    console.log(info)
    delete info.w;
    delete info.h;
    let old = symbolDict[k];
    console.log('old symbol:', old);
    if (isdef(old)) {
      addIf(info.cats, old.group);
      addIf(info.cats, old.subgroups);
    }
    newSyms[k] = Syms[k];
  }
  downloadAsYaml(newSyms, 'newSyms')
}
function buildWordFromLetters(dParent) {
  let letters = Array.from(dParent.children);
  let s = letters.map(x => x.innerHTML);
  s = s.join('');
  return s;
}
function busy_wait_until_slot(slot) {
  let diff = get_slot_diff(Z.fen);
  let dd;
  do {
    dd = last_n_digits(Date.now(), 2);
    if (dd >= slot && dd <= slot + diff) { break; }
  } while (true);
  return dd;
}
function bw_list_entry(d, key, loginOrCard = 'login') {
  let logins = loginOrCard == 'login' ? get_fake_bw_logins() : get_fake_bw_cards();
  let login = logins[key];
  let d4 = mDiv(d, { bg: 'white', fg: 'black', 'border-bottom': '1px dotted #ddd' });
  let d5 = mDiv(d4, { display: 'flex' });
  let dimg = mDiv(d5, { bg: 'white', fg: 'black' }, null, `<img src='../rechnung/images/${login.logo}' height=14 style="margin:8px">`);
  let dtext = mDiv(d5, { cursor: 'pointer' }, null, `<div>${key}</div><div style="font-size:12px;color:gray">${login.sub}</div>`);
  dtext.onclick = () => onclick_bw_symbol(key)
  let d6 = mDiv(d4, { display: 'flex', padding: 2 });
  let disyms = {
    bwtext: { postfix: 'userid', matop: 2, maright: 0, mabottom: 0, maleft: 0, sz: 27 },
    bwcross: { postfix: 'cross', matop: 2, maright: 0, mabottom: 0, maleft: -13, sz: 25 },
    bwkey: { postfix: 'pwd', matop: 0, maright: 0, mabottom: 0, maleft: -12, sz: 27 },
    bwclock: { postfix: 'clock', matop: 0, maright: 0, mabottom: 0, maleft: 0, sz: 25 },
  }
  for (const k of ['bwtext', 'bwcross', 'bwkey']) {
    let o = disyms[k];
    let [filename, styles] = [k, disyms[k]];
    let path = `../rechnung/images/${filename}.png`;
    let [sz, ma] = [styles.sz, `${styles.matop}px ${styles.maright}px ${styles.mabottom}px ${styles.maleft}px`];
    let img = mDiv(d6, { paright: 16 }, null, `<img src='${path}' height=${sz} style="margin:${ma}">`);
    if (k != 'bwcross') {
      mStyle(img, { cursor: 'pointer' });
      img.onclick = () => onclick_bw_symbol(key, o.postfix);
    }
  }
  mFlexSpacebetween(d4);
  return d4;
}
function bw_login_popup() {
  let html = `
    <div id="dBw" class="mystyle" style="background:silver;padding:12px">
      <div id="dBWLogin">
        <form action="javascript:bw_master_password_check()" id="fBitwarden">
          <label for="inputPassword">Enter Master Password:</label>
          <input type="password" id="inputPassword" placeholder="" />
        </form>
        <div id="bw_login_status" style="color:red"></div>
      </div>
    </div>
  `;
  let d = mCreateFrom(html);
  let dParent = mBy('dPopup');
  show(dParent);
  mClear(dParent);
  mStyle(dParent, { top: 50, right: 10 });
  mAppend(dParent, d);
  document.getElementById("inputPassword").focus();
}
function bw_master_password_check() {
  let pw = mBy('inputPassword').value;
  if (pw == S.master_password) {
    S.bw_state = 'loggedin';
    toggle_bw_symbol();
    hide('dPopup');
    if (DA.name == 'Password') {
      show_eval_message(true); DA.name = DA.challenge = null;
    }
  } else if (DA.name == 'Password') {
    DA.name = DA.challenge = null;
    show_eval_message(false, `Fail! the password is ${S.master_password}`);
    mBy('inputPassword').value = '';
    hide('dPopup');
  } else {
    let d = mBy('bw_login_status');
    d.innerHTML = 'Incorrect Master Password';
  }
}
function bw_master_password_renew() {
  let [inp1, inp2] = [document.getElementById('inputPassword'), document.getElementById('inputPassword2')];
  let pw = inp1.value;
  let pw2 = inp2.value;
  let letters = toLetters(pw);
  let minlen = 8;
  let correct = false;
  let d = mBy('dError');
  if (pw.length < minlen) {
    d.innerHTML = `password needs to be at least ${minlen} long!`;
  } else if (!letters.find(x => 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.includes(x))) {
    d.innerHTML = 'password needs to contain at least 1 uppercase letter!';
  } else if (!letters.find(x => '0123456789'.includes(x))) {
    d.innerHTML = 'password needs to contain at least 1 digit!';
  } else if (isAlphaNum(pw)) {
    d.innerHTML = 'password needs to contain at least 1 special symbol!';
  } else if (pw !== pw2) {
    d.innerHTML = 'passwords do not match';
  } else correct = true;
  if (correct) {
    console.log('new password has been set!', pw);
    S.master_password = pw;
    boa_save();
    hide('dPopup');
    show_eval_message(true, `Password has been set to ${pw}`); DA.challenge = DA.name = null;
  } else {
    inp1.value = inp2.value = '';
    inp1.focus();
  }
}
function bw_set_new_password_popup() {
  let w = 200;
  let html = `
    <div id="dBw" class="mystyle" style="background:silver;padding:12px">
    <h2 style="text-align:center">Set New Master Password</h2>
    <div id="dBWLogin" style="text-align:right">
        <form action="javascript:bw_master_password_renew()" id="fBitwarden">
          <label for="inputPassword">New Password:</label>
          <input style="width:${w}px" type="password" id="inputPassword" placeholder="" onkeydown="focusNextSiblingOrSubmitOnEnter(event,'inputPassword2')" />
          <br><br><label for="inputPassword2">Repeat Password:</label>
          <input style="width:${w}px" type="password" id="inputPassword2" placeholder="" onkeydown="focusNextSiblingOrSubmitOnEnter(event,'fBitwarden')" />
          <br>
          <div id="dError" style="color:yellow;background:red;text-align:center;margin-top:4px;padding:0px 10px;box-sizing:border-box"></div>
          <br><button onclick="bw_master_password_renew()" >Submit</button>
        </form>
      </div>
    </div>
  `;
  let d = mCreateFrom(html);
  let dParent = mBy('dPopup');
  show(dParent);
  mClear(dParent);
  mStyle(dParent, { top: 50, right: 10 });
  mAppend(dParent, d);
  document.getElementById("inputPassword").focus();
}
function bw_symbol_pulse() { let elem = mBy('tbbw'); if (nundef(elem)) return; else { mPulse1(elem); } }
function bw_widget_popup(key = 'boa') {
  let dpop = mBy('dPopup');
  show(dpop); mClear(dpop)
  mStyle(dpop, { top: 50, right: 10, border: 'silver' });
  let prefix = key;
  let douter = mDiv(dpop, { wmin: 200, bg: 'white', fg: 'black', border: '1px single #ccc' }, 'dBw');
  let d2 = mDiv(douter, { padding: 0, h: 30 }, null, `<img width='100%' src='../rechnung/images/bwsearch.jpg'>`);
  let d = mDiv(douter, { padding: 0, hmax: 600, 'overflow-y': 'auto' });
  let dtb = mDiv(douter, { padding: 8 }); mFlexEvenly(dtb);
  let dibuttons = { tab: { top: 2, left: 0 }, vault: { top: 1, left: 3 }, send: { top: 2, left: 3 }, generator: { top: 2, left: 1 }, settings: { top: 4, left: 2 } };
  for (const bname in dibuttons) {
    let path = `../rechnung/images/bw${bname}.jpg`;
    let db = mDiv(dtb, { w: 60 }); mCenterFlex(db);
    let img = mDiv(db, { h: 36, w: 36, bg: 'white', position: 'relative' }, null, `<img style="position:absolute;top:${dibuttons[bname].top}px;left:${dibuttons[bname].left}px" src='${path}'>`);
    mLinebreak(db);
    let txt = mDiv(db, { fz: 12 }, null, capitalize(bname));
  }
  let d3 = mDiv(d, { bg: '#eee', fg: 'dimgray', padding: 8, matop: 8 }, null, 'LOGINS');
  bw_list_entry(d, key);
  let d7 = mDiv(d, { bg: '#eee', fg: 'dimgray', padding: 7 }, null, 'CARDS');
  let data = get_fake_bw_cards();
  let color_alt = '#F9F7F4';
  let i = 0;
  for (const k in data) {
    let dentry = bw_list_entry(d, k, 'cards');
  }
}
function byEndNodeIds(nid1, nid2) {
}
function byId(id) {
  return lookup(EID, [id]);
}
function byPos(x, y, func) {
  let els = lookup(EC, [y]);
  if (els) {
    let lst = lookup(els, [x]);
    if (lst) {
      return func ? lst.filter(x => func(x)) : lst;
    }
  }
}
function byPos1(x, y, func) {
  let els = byPos(x, y, func);
  if (els && els.length > 0) return els[0];
  return null;
}
function byType(type, func) {
  els = lookup(ET, [type]);
  if (els) {
    return func ? els.filter(x => func(x)) : els;
  }
}
function byType1(type, func) {
  let els = byType(type, func);
  if (els && els.length > 0) return els[0];
  return null;
}
function C_draw() {
  if (!C.changed) return;
  cClear(CV, CX);
  for (const type in C.items) { let f = get_func(type, 'draw'); for (const item of C.items[type]) { f(item); } }
  C.changed = false;
}
function C_update() { C.root.animated = true; get_func(C.name, 'add')(); }
function cal_num_syms_adaptive() {
  let [uplayer, fen] = [Z.uplayer, Z.fen];
  let pl = fen.players[uplayer];
  pl.score = get_player_score(pl.name);
  let by_score = dict2list(fen.players);
  for (const pl of by_score) { pl.score = get_player_score(pl.name); }
  let avg_score = 0;
  for (const pl of by_score) { avg_score += pl.score; }
  avg_score /= by_score.length;
  let di = { nasi: -3, gul: -3, sheeba: -2, mimi: -1, annabel: 1 };
  let baseline = valf(di[uplayer], 0);
  let dn = baseline + Math.floor(pl.score - avg_score);
  let n = Z.options.num_symbols;
  let nfinal = Math.max(4, Math.min(14, dn + n));
  return nfinal;
}
function calc_bid_minus_cards(fen, bid) {
  let di2 = { _: '_', three: 3, four: 4, five: 5, six: 6, seven: 7, eight: 8, nine: 9, ten: 'T', jack: 'J', queen: 'Q', king: 'K', ace: 'A' };
  let di_ranks = aggregate_player_hands_by_rank(fen);
  let [brauch1, r1, brauch2, r2] = bid;
  [r1, r2] = [di2[r1], di2[r2]];
  if (brauch1 == '_') brauch1 = 0;
  if (brauch2 == '_') brauch2 = 0;
  let hab1 = valf(di_ranks[r1], 0);
  let hab2 = valf(di_ranks[r2], 0);
  let wildcards = valf(di_ranks['2'], 0);
  let diff1 = Math.max(0, brauch1 - hab1);
  let diff2 = Math.max(0, brauch2 - hab2);
  return diff1 + diff2 - wildcards;
}
function calc_building_vps(bs) {
  let res = 0;
  res += bs.farm.length;
  res += bs.estate.length * 2;
  res += bs.chateau.length * 3;
  return res;
}
function calc_ferro_highest_goal_achieved(pl) {
  let jsorted = jsCopy(pl.journeys).sort((a, b) => b.length - a.length);
  let di = {
    '3': jsorted.length > 0 && is_group(jsorted[0]) && jsorted[0].length >= 3,
    '33': jsorted.length > 1 && is_group(jsorted[0]) && jsorted[0].length >= 3
      && is_group(jsorted[1]) && jsorted[1].length >= 3,
    '4': jsorted.length > 0 && is_group(jsorted[0]) && jsorted[0].length >= 4,
    '44': jsorted.length > 1 && is_group(jsorted[0]) && jsorted[0].length >= 4
      && is_group(jsorted[1]) && jsorted[1].length >= 4,
    '5': jsorted.length > 0 && is_group(jsorted[0]) && jsorted[0].length >= 5,
    '55': jsorted.length > 1 && is_group(jsorted[0]) && jsorted[0].length >= 5
      && is_group(jsorted[1]) && jsorted[1].length >= 5,
    '7R': jsorted.length > 0 && is_sequence(jsorted[0]) && jsorted[0].length >= 7,
  };
  for (const k of Z.fen.availableGoals) {
    if (pl.goals[k]) {
      console.log('player', pl.name, 'already achieved goal', k);
      continue;
    }
    let achieved = di[k];
    if (achieved) {
      return k;
    }
  }
  return null;
}
function calc_ferro_score(roundwinner) {
  let [round, plorder, stage, A, fen, uplayer] = [Z.round, Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer];
  assertion(roundwinner == uplayer, '_calc_ferro_score: roundwinner != uplayer');
  for (const plname of plorder) {
    let pl = fen.players[plname];
    pl.newcards = [];
    if (nundef(pl.score)) pl.score = 0;
    if (uplayer == plname) pl.score -= round * 5;
    else pl.score += calc_hand_value(pl.hand);
  }
}
function calc_fritz_score() {
  let [round, plorder, stage, A, fen, uplayer] = [Z.round, Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer];
  for (const plname of fen.roundorder) {
    let pl = fen.players[plname];
    if (nundef(pl.score)) pl.score = 0;
    else pl.score += calc_hand_value(pl.hand.concat(pl.loosecards), fritz_get_card);
  }
}
function calc_hand_value(hand, card_func = ferro_get_card) {
  let vals = hand.map(x => card_func(x).val);
  let sum = vals.reduce((a, b) => a + b, 0);
  return sum;
}
function calc_hex_col_array(rows, cols) {
  let colarr = [];
  for (let i = 0; i < rows; i++) {
    colarr[i] = cols;
    if (i < (rows - 1) / 2) cols += 1;
    else cols -= 1;
  }
  return colarr;
}
function calc_map_dims() {
  let d = M.dims = {
    pixels: get_map_dims_in_pixel(),
    meters: get_map_dims_in_meters(),
    latlng: get_map_dims_in_lat_lng(),
    zoom: M.map.getZoom(),
  };
  let ppm = M.dims.pixels_per_meter = [d.pixels[0] / d.meters[0], d.pixels[1] / d.meters[1]];
  M.dims.meters_per_pixel = [1 / ppm[0], 1 / ppm[1]];
  let ppll = M.dims.pixels_per_ll = [d.pixels[0] / d.latlng[1], d.pixels[1] / d.latlng[0]];
  M.dims.ll_per_pixel = [1 / ppll[0], 1 / ppll[1]];
  let mpll = M.dims.meters_per_ll = [d.meters[0] / d.latlng[1], d.meters[1] / d.latlng[0]];
  M.dims.ll_per_meters = [1 / mpll[1], 1 / mpll[0]];
}
function calc_maxdepth(maxnodes, rules) {
  let laus = rules.map(x => x.aus).join();
  let lwird = rules.map(x => x.wird).join();
  let naus = countAll(laus, 'ABF');
  let nwird = countAll(lwird, 'ABF');
  let ratio = nwird / naus;
  let pow = 2;
  while (Math.pow(ratio, pow) < maxnodes) pow++;
  return pow - 1;
}
function calc_reasonable_max(fen) {
  let allcards = [];
  for (const plname in fen.players) {
    let pl = fen.players[plname];
    allcards = allcards.concat(pl.hand);
  }
  let ncards = allcards.length;
  let nmax = Math.floor(ncards / 13) + 1;
  return nmax;
}
function calc_speed(oldgoal, newgoal) {
  let speed = Math.abs(newgoal - oldgoal) / 10;
  return speed;
}
function calc_stall_value(fen, plname) { let st = fen.players[plname].stall; if (isEmpty(st)) return 0; else return arrSum(st.map(x => ari_get_card(x).val)); }
function calc_syms(numSyms) {
  let n = numSyms, rows, realrows, colarr;
  if (n == 3) { rows = 2; realrows = 1; colarr = [1, 2]; }
  else if (n == 4) { rows = 2; realrows = 2; colarr = [2, 2]; }
  else if (n == 5) { rows = 3; realrows = 3; colarr = [1, 3, 1]; }
  else if (n == 6) { rows = 3.3; realrows = 3; colarr = [2, 3, 1]; }
  else if (n == 7) { rows = 3; realrows = 3; colarr = [2, 3, 2]; }
  else if (n == 8) { rows = 3.8; realrows = 4; colarr = [1, 3, 3, 1]; }
  else if (n == 9) { rows = 4; realrows = 4; colarr = [2, 3, 3, 1]; }
  else if (n == 10) { rows = 4; realrows = 4; colarr = [2, 3, 3, 2]; }
  else if (n == 11) { rows = 4.5; realrows = 4; colarr = [2, 3, 4, 2]; }
  else if (n == 12) { rows = 5; realrows = 5; colarr = [1, 3, 4, 3, 1]; }
  else if (n == 13) { rows = 5; realrows = 5; colarr = [2, 3, 4, 3, 1]; }
  else if (n == 14) { rows = 5; realrows = 5; colarr = [2, 3, 4, 3, 2]; }
  else if (n == 15) { rows = 5.5; realrows = 5; colarr = [2, 3, 5, 3, 2]; }
  else if (n == 16) { rows = 5.5; realrows = 5; colarr = [2, 3, 5, 4, 2]; }
  else if (n == 17) { rows = 5.5; realrows = 5; colarr = [2, 4, 5, 4, 2]; }
  else if (n == 18) { rows = 5.8; realrows = 5; colarr = [2, 4, 5, 4, 3]; }
  return [rows, realrows, colarr];
}
function calcAddressWithin(o, addr, R) {
  if (!o) return addr;
  if (isLiteral(addr)) {
    if (isString(addr)) {
      if (addr[0] != '.') return addr;
      let props = addr.split('.').slice(1);
      if (props.length == 1 && isEmpty(props[0])) {
        console.log('ERROR!!!!!!!! sollte abgefangen werden!!!! props empty!')
        return o;
      } else if (props.length == 1) {
        return { key: props[0], obj: o };
      }
      else {
        let key = arrLast(props);
        let len = props.length;
        let props1 = props.slice(0, len - 1);
        return { key: key, obj: dPP(o, props1, R) };
      }
    } else {
      return addr;
    }
  }
  else if (isDict(addr)) {
    let content = {};
    for (const k in addr) {
      let c = calcAddressWithin(o, addr[k], R);
      if (c) content[k] = c;
    }
    return content;
  } else if (isList(addr)) {
    let content = addr.map(x => calcAddressWithin(o, x, R));
    return content;
  }
  return null;
}
function calcAristoHandValue(cards) {
  let ranks = cards.map(x => x % 13);
  let total = 0;
  for (const rank of ranks) { total += Math.min(10, rank + 1); }
  return total;
}
function calcBoardDimensions(nuiBoard, R) {
  let boardInfo = nuiBoard.bi.board.info;
  let bParams = nuiBoard.params;
  let fSpacing = bParams.field_spacing;
  if (nundef(fSpacing)) nuiBoard.params.field_spacing = fSpacing = 60;
  let margin = isdef(bParams.padding) ? bParams.padding : 0;
  let gap = fSpacing - nuiBoard.params.sizes.f;
  let [fw, fh] = [fSpacing / boardInfo.wdef, fSpacing / boardInfo.hdef];
  let cornerSize = isEmpty(nuiBoard.bi.corners) ? 0 : isdef(bParams.corners) ? bParams.corners.size : 15;
  let [wBoard, hBoard] = [fw * boardInfo.w + cornerSize, fh * boardInfo.h + cornerSize];
  let [wTotal, hTotal] = [wBoard + 2 * margin, hBoard + 2 * margin];
  nuiBoard.wTotal = wTotal;
  nuiBoard.hTotal = hTotal;
  nuiBoard.wBoard = wBoard;
  nuiBoard.hBoard = hBoard;
  nuiBoard.fSpacing = fSpacing;
  nuiBoard.fw = fw;
  nuiBoard.fh = fh;
  nuiBoard.gap = gap;
  nuiBoard.fSize = fSpacing - gap;
}
function calcBoardDimensionsX(nuiBoard, R) {
  let boardInfo = nuiBoard.bi.board.info;
  let bParams = nuiBoard.params;
  let fSpacing = bParams.field_spacing;
  if (nundef(fSpacing)) nuiBoard.params.field_spacing = fSpacing = 60;
  let margin = isdef(bParams.padding) ? bParams.padding : 0;
  let gap = fSpacing - nuiBoard.params.sizes.f;
  let [fw, fh] = [fSpacing / boardInfo.wdef, fSpacing / boardInfo.hdef];
  let cornerSize = isEmpty(nuiBoard.bi.corners) ? 0 : nuiBoard.params.sizes.c;
  let [wBoard, hBoard] = [fw * boardInfo.w + cornerSize, fh * boardInfo.h + cornerSize];
  let [wTotal, hTotal] = [wBoard + 2 * margin, hBoard + 2 * margin];
  nuiBoard.wTotal = wTotal;
  nuiBoard.hTotal = hTotal;
  nuiBoard.wBoard = wBoard;
  nuiBoard.hBoard = hBoard;
  nuiBoard.fSpacing = fSpacing;
  nuiBoard.fw = fw;
  nuiBoard.fh = fh;
  nuiBoard.gap = gap;
  nuiBoard.fSize = fSpacing - gap;
}
function calcContent_dep(oid, o, path) {
  if (isString(path)) {
    if (path[0] != '.') return path;
    let props = path.split('.').slice(1);
    let content = isEmpty(props) ? o.obj_type : lookup(o, props);
    return content;
  } else if (isDict(path)) {
    let content = {};
    for (const k in path) {
      let c = calcContent_dep(oid, o, path[k]);
      if (c) content[k] = c;
    }
    return content;
  }
  return null;
}
function calcContentFromData(oid, o, data, R, default_data) {
  if (!o) return data;
  if (isLiteral(data)) {
    if (isString(data)) {
      if (data[0] != '.') return data;
      let props = data.split('.').slice(1);
      if (props.length == 1 && isEmpty(props[0])) return o;
      else {
        let res = dPP1(o, props, R);
        if (isdef(res)) return res;
      }
    } else {
      return data;
    }
  }
  else if (isDict(data)) {
    let content = {};
    for (const k in data) {
      let c = calcContentFromData(oid, o, data[k], R);
      if (isdef(c)) content[k] = c;
    }
    return content;
  } else if (isList(data)) {
    let content = data.map(x => calcContentFromData(oid, o, x, R));
    return content;
  }
  if (isdef(default_data)) {
    let finalRes = calcContentFromData(oid, o, default_data, R);
    return finalRes;
  } else return null;
}
function calcCycles(R) {
  let oids = jsCopy(R.locOids);
  let cycles = R.partitions = {};
  let oid2partition = R.oid2partition = {};
  let cid;
  while (!isEmpty(oids)) {
    let oid = oids[0];
    cid = getUID();
    let c = cycles[cid] = { isCycle: false, oids: [] };
    while (true) {
      if (c.oids.includes(oid)) {
        c.isCycle = true;
        break;
      }
      if (isdef(oid2partition[oid])) {
        let cid2 = oid2partition[oid];
        let c2 = cycles[cid2];
        c.oids.map(x => oid2partition[x] = cid2);
        c2.oids = c.oids.concat(c2.oids);
        c = c2;
        delete cycles[cid];
        break;
      } else {
        c.oids.push(oid);
        oid2partition[oid] = cid;
      }
      removeInPlace(oids, oid);
      let o = R.getO(oid);
      if (nundef(o.loc)) break;
      oid = o.loc;
    }
  }
  for (const k in R.partitions) {
    let c = R.partitions[k];
    c.oids.reverse();
    let removed;
    if (!c.isCycle) { removed = c.oids.shift(); }
    for (const oid of c.oids) {
      if (nundef(R.getO(oid)).loc) {
        alert('SORT CYCLES SAFETY CHECK FAILED! no loc in ' + oid);
      }
    }
    if (isdef(removed && isdef(R.getO(removed)).loc)) {
      alert('SORT CYCLES SAFETY CHECK FAILED! removed has loc' + removed);
    }
  }
}
function calcDimsAndSize(cols, lines, dParent, wmax, hmax) {
  let ww, wh, hpercent, wpercent;
  if (isdef(dParent)) {
    let b = getBounds(dParent);
    ww = b.width;
    wh = b.height;
    hpercent = .9;
    wpercent = .9;
  } else if (isdef(wmax) && isdef(hmax)) {
    ww = wmax;
    wh = hmax;
    hpercent = .6;
    wpercent = .6;
  } else {
    ww = window.innerWidth;
    wh = window.innerHeight;
    hpercent = .56;
    wpercent = .64;
  }
  let sz, picsPerLine;
  if (lines > 1) {
    let hpic = wh * hpercent / lines;
    let wpic = ww * wpercent / cols;
    sz = Math.min(hpic, wpic);
    picsPerLine = cols;
  } else {
    let dims = calcRowsColsX(cols);
    let hpic = wh * hpercent / dims.rows;
    let wpic = ww * wpercent / dims.cols;
    sz = Math.min(hpic, wpic);
    picsPerLine = dims.cols;
  }
  pictureSize = Math.max(50, Math.min(sz, 200));
  return [pictureSize, picsPerLine];
}
function calcFieldGaps(sz) {
  sz = Number(sz);
  let s = G.settings;
  s.wGap = s.dxCenter - sz;
  s.hGap = s.dyCenter - sz;
  G.clientBoard = applySettings(G.clientBoard, s);
}
function calcIdUiParent(n, R, uidParent) {
  if (uidParent && isBoardMember(uidParent, R)) {
    let divParent = findAncestorElemOfType(mBy(uidParent), 'div');
    n.idUiParent = divParent.id;
  } else {
    n.idUiParent = uidParent;
  }
}
function calcLayoutParameters(s, b, scale = 1) {
  let [layout, horDist, vertDist, rows, cols] = [s.boardLayout, s.dxCenter, s.dyCenter, s.rows, s.cols];
  let isHexLayout = startsWith(layout, 'hex');
  let hline = isHexLayout ? vertDist * .75 : vertDist;
  if (nundef(rows) || layout == 'circle') rows = Math.floor(s.hFieldArea / hline);
  if (nundef(cols) || layout == 'circle') cols = Math.floor(s.wFieldArea / horDist)
  let [centers, wNeeded, hNeeded] = getCentersFromRowsCols(layout, rows, cols, horDist, vertDist);
  s.nFields = centers.length;
  [b.nFields, b.wNeeded, b.hNeeded, b.centers] = [s.nFields, wNeeded, hNeeded, centers];
  [b.layout, b.rows, b.cols, b.dxCenter, b.dyCenter, b.hline] = [s.boardLayout, rows, cols, horDist, vertDist, hline];
  if (scale != 1) {
    for (const c of centers) {
      c.x = c.x * scale;
      c.y = c.y * scale;
    }
    b.wNeeded *= scale;
    b.hNeeded *= scale;
    b.dxCenter *= scale;
    b.dyCenter *= scale;
    b.hline *= scale;
  }
  return s.nFields;
}
function calcMainVisualPosCenterInGameArea(mobj) {
  let area = UIS['a_d_game'];
  let parent = UIS[mobj.idParent];
  if (nundef(parent.x)) parent = UIS[parent.idParent];
  let offX = 0;
  let offY = 0;
  if (mobj.cat == 'g') { offX = parent.w / 2; offY = parent.h / 2; }
  let x = offX + parent.x + mobj.x;
  let y = offY + parent.y + mobj.y;
  return { x: x, y: y };
}
function calcMemorizingTime(numItems, randomGoal = true) {
  let ldep = Math.max(6, randomGoal ? numItems * 2 : numItems);
  return ldep;
}
function calcNFields(s) {
  let [layout, wCell, hCell, rows, cols] = [s.boardLayout, s.dxCenter, s.dyCenter, s.rows, s.cols];
  let boardSize = { w: s.wFieldArea, h: s.hFieldArea };
  let [w, h] = [boardSize.w, boardSize.h];
  if (layout == 'circle') {
    let hline = layout == 'circle' ? hCell * 1.2 : layout == 'hex' ? hCell * .78 : hCell;
    rows = Math.floor(h / hline);
    cols = Math.floor(w / wCell);
  }
  let n;
  if (layout == 'hex1') {
    let colarr = _calc_hex_col_array(rows, cols);
    n = arrSum(colarr);
  } else if (layout == 'quad') {
    n = rows * cols;
  } else if (layout == 'hex') {
    console.log('rows', rows, 'cols', cols)
    let [cs, wn, hn] = hexCenters(rows, cols, wCell, hCell);
    n = cs.length;
  } else if (layout == 'circle') {
    let [cs, wn, hn] = circleCenters(rows, cols, wCell, hCell);
    n = cs.length;
  }
  return n;
}
function calcNumRowsFitting(dParent, maxHeight, html) {
  let sz = getTextSize(html, dParent);
  return maxHeight / (sz.h + 2);
}
function calcParentContentYOffsetAndWidth(n, parentPadding) {
  let y0 = 0;
  let wTitle = 0;
  if (isdef(n.content)) {
    let uiParent = n.ui;
    let cont = uiParent.firstChild;
    let b = getBounds(cont, true);
    wTitle = b.width;
    if (isdef(n.params.padding)) wTitle += 2 * n.params.padding;
    y0 = parentPadding + b.top + b.height + parentPadding;
  } else y0 = parentPadding;
  return [y0, wTitle];
}
function calcRays(n, gParent, R) {
  if (n.params.dray) {
    let ui = n.ui;
    let buid = n.uidParent;
    let b = R.rNodes[buid];
    let bui = R.UIS[buid];
    let size = 20;
    let fsp = bui.params.field_spacing;
    let info = n.info;
    let x = info.x * fsp;
    let y = info.y * fsp;
    let w = size;
    let h = size;
    let D = distance(0, 0, x, y);
    let p = n.params.dray;
    let rel = p.rel;
    let nanc = n;
    if (rel == 'ancestor') {
      console.log('haaaaaaaaaaaaaaaaalllllllllllllllooooooooooooo')
      while (true) {
        nanc = R.rNodes[nanc.uidParent];
        if (nundef(nanc) || nundef(nanc.oid)) { nanc = null; break; }
        let o = R.getO(nanc.oid);
        let conds = p.cond;
        let tf = evalConds(o, conds);
        if (tf) { break; }
      }
    }
    let by = p.by;
    nby = isNumber(by) ? by : firstNumber(by);
    if (isString(by) && by[by.length - 1] == '%') {
      nby = nby * size / 100;
    }
    let elem = isdef(nanc) ? nanc : rel == 'parent' ? gParent : ui;
    let norm = nby / D;
    let xdisp = x * norm;
    let ydisp = y * norm;
    let txt = n.label.texts;
    let el = n.label.texts[0].ui;
    el.setAttribute('x', xdisp);
    el.setAttribute('y', ydisp);
    if (isdef(n.label.textBackground)) {
      if (n.params.bgText) {
        let tb = n.label.textBackground;
        let tbb = getBounds(tb);
        let origX = tb.getAttribute('x');
        let newX = origX + xdisp;
        tb.setAttribute('x', xdisp - tbb.width / 2);
        let origY = tb.getAttribute('y');
        let newY = origY + ydisp;
        tb.setAttribute('y', ydisp - tbb.height * 4 / 5);
      } else {
        n.label.textBackground.remove();
        delete n.label.textBackground;
      }
    }
  }
}
function calcRowsCols(num, rows, cols) {
  let shape = 'rect';
  if (isdef(rows) && isdef(cols)) {
  } else if (isdef(rows)) {
    cols = Math.ceil(num / rows);
  } else if (isdef(cols)) {
    rows = Math.ceil(num / cols);
  } else if (num == 2) {
    rows = 1; cols = 2;
  } else if ([4, 6, 9, 12, 16, 20, 25, 30, 36, 42, 29, 56, 64].includes(num)) {
    rows = Math.floor(Math.sqrt(num));
    cols = Math.ceil(Math.sqrt(num));
  } else if ([3, 8, 15, 24, 35, 48, 63].includes(num)) {
    let lower = Math.floor(Math.sqrt(num));
    console.assert(num == lower * (lower + 2), 'RECHNUNG FALSCH IN calcRowsCols');
    rows = lower;
    cols = lower + 2;
  } else if (num > 1 && num < 10) {
    shape = 'circle';
  } else if (num > 16 && 0 == num % 4) {
    rows = 4; cols = num / 4;
  } else if (num > 9 && 0 == num % 3) {
    rows = 3; cols = num / 3;
  } else if (0 == num % 2) {
    rows = 2; cols = num / 2;
  } else {
    rows = 1; cols = num;
  }
  return { rows: rows, cols: cols, recommendedShape: shape };
}
function calcRowsColsSizeAbWo(n, wmax, hmax, showLabels, wimax = 200, himax = 200, fw = 1, fh = 1) {
  let rows = n > 35 ? 6 : n > 28 ? 5 : n > 24 && !showLabels || n > 21 ? 4 : n > 8 ? 3 : n > 3 ? 2 : 1;
  let cols = Math.ceil(n / rows);
  return calcSizeAbWo(n, rows, cols, wmax, hmax, wimax, himax, fw, fh);
}
function calcRowsColsX(num) {
  const table = {
    2: { rows: 1, cols: 2 },
    5: { rows: 2, cols: 3 },
    7: { rows: 2, cols: 4 },
    11: { rows: 3, cols: 4 },
  };
  if (isdef(table[num])) return table[num]; else return calcRowsCols(num);
}
function calcScreenSizeNeeded() {
  if (nundef(bodyZoom)) bodyZoom = 1.0;
  let wAreas = ['a_d_actions', 'a_d_game', 'a_d_player', 'a_d_log'];
  let wTotal = 0;
  let wTotal2 = 0;
  for (const a of wAreas) {
    let mobj = UIS[a];
    let b = getBounds(mobj.elem);
    let wIst = Math.round(b.width / bodyZoom);
    wTotal2 += wIst;
  }
  let hAreas = ['a_d_header', 'a_d_status', 'a_d_game', 'a_d_buttons'];
  let hTotal = 0;
  let hTotal2 = 0;
  for (const a of hAreas) {
    let mobj = UIS[a];
    let hSoll = mobj.h;
    hTotal += hSoll;
    let b = getBounds(mobj.elem);
    let hIst = Math.round(b.height);
    hTotal2 += hIst;
  }
  return (window.innerWidth * 100) / wTotal2;
}
function calcSizeAbWo(n, rows, cols, wmax, hmax, wimax = 200, himax = 200, fw = 1, fh = 1) {
  if (nundef(cols)) cols = Math.ceil(n / rows); else if (nundef(rows)) rows = Math.ceil(n / cols);
  let wi = wmax * fw / cols;
  let hi = hmax * fh / rows;
  wi = Math.min(wi, wimax);
  hi = Math.min(hi, himax);
  return [wi, hi, rows, cols];
}
function calcSizeMeasured(n, R) {
  if (isdef(n.info)) {
    return { w: n.info.size, h: n.info.size };
  } else if (n.type == 'grid') {
    calcBoardDimensions(n, R);
    return { w: n.wTotal, h: n.hTotal };
  } else if (n.type == 'hand' || n.ui.style.display == 'flex' && isdef(n.children)) {
    return { w: 0, h: 0 };
  } else {
    let b = getBounds(n.ui, true);
    return { w: b.width, h: b.height };
  }
}
function calcSnailPositions(x, y, d, n) {
  let p = { x: x, y: y };
  let res = [p];
  let step = 1;
  let k = 1;
  while (true) {
    for (i = 0; i < step; i++) {
      if (k < n) {
        p = mup(null, p, d);
        res.push(p);
        k += 1;
      } else return res;
    }
    for (i = 0; i < step; i++) {
      if (k < n) {
        p = mri(null, p, d);
        res.push(p);
        k += 1;
      } else return res;
    }
    step += 1;
    for (i = 0; i < step; i++) {
      if (k < n) {
        p = mdo(null, p, d);
        res.push(p);
        k += 1;
      } else return res;
    }
    for (i = 0; i < step; i++) {
      if (k < n) {
        p = mle(null, p, d);
        res.push(p);
        k += 1;
      } else return res;
    }
    step += 1;
  }
}
function calcStallOrder(players) {
  for (const pl of players) {
    pl.stallValue = calcAristoHandValue(pl.stall);
  }
  let stallOrder = players.map(x => ({ stallValue: x.stallValue, index: x.index }));
  let plSorted = sortBy(stallOrder, 'stallValue').map(x => x.index);
  return plSorted;
}
function calcTotalDims(n, uids, R) {
  let hMax = 0;
  let margin = isdef(n.params.margin) ? n.params.margin : 0;
  let wTotal = margin;
  for (const ch of uids) {
    let n1 = R.uiNodes[ch];
    let w = n1.size.w;
    let h = n1.size.h;
    hMax = Math.max(hMax, h);
    wTotal += w + margin;
  }
  return { w: wTotal, h: hMax + 2 * margin, margin: margin };
}
function calculateDaysBetweenDates(begin, end) {
  var oneDay = 24 * 60 * 60 * 1000;
  var firstDate = new Date(begin);
  var secondDate = new Date(end);
  var diffDays = Math.round(Math.abs((firstDate.getTime() - secondDate.getTime()) / (oneDay)));
  return diffDays;
}
function calculateDims(n, sz = 60, minRows = 1) {
  var rows = minRows;
  var cols = Math.ceil(n / rows);
  var gap = 10;
  var padding = 20;
  let w = 9999999;
  testHelpers('calculateDims with:', rows, cols);
  let rOld = 0;
  while (true) {
    rOld = rows;
    for (var i = Math.max(2, rows); i < n / 2; i++) {
      if (n % i == 0) {
        rows = i;
        cols = n / i;
        break;
      }
    }
    w = padding * 2 - gap + (sz + gap) * cols;
    if (w > window.innerWidth) {
      if (rows == rOld) {
        rows += 1;
        cols = Math.ceil(n / rows);
      } else if (gap > 1) gap -= 1;
      else if (padding > 1) padding -= 2;
      else {
        minRows += 1;
        gap = 6;
        padding = 10;
      }
    } else break;
    if (rows == rOld) break;
  }
  return { rows: rows, cols: cols, gap: gap, padding: padding, width: w };
}
function calculateTopLevelGElement(el) {
  while (el && el.parentNode) {
    let t = getTypeOf(el);
    let tParent = getTypeOf(el.parentNode);
    if (tParent == 'svg') break;
    el = el.parentNode;
  }
  return el;
}
function call_answer(i) { call_func('a' + i); }
function call_func(name) { let f = window[name]; f(); }
function call_question(i) { call_func('q' + i); }
function Camera(scene) {
  this.canvas = scene.canvas;
  this.context = this.canvas.getContext("2d");
  this.cHeight = parseInt(this.canvas.height);
  this.cWidth = parseInt(this.canvas.width);
  this.cameraOffsetX = 0;
  this.cameraOffsetY = 0;
  this.target = false;
  this.waitX = 0;
  this.waitY = 0;
  this.focalPointX = 0;
  this.focalPointY = 0;
  this.moveCamera = function (x, y) {
    this.cameraOffsetX += x;
    this.cameraOffsetY += y;
  }
  this.followSprite = function (sprite, waitX, waitY) {
    this.target = sprite;
    if (typeof waitX != "undefined") {
      this.waitX = waitX;
      this.waitY = waitY;
    }
  }
  this.update = function () {
    this.focalPointX = this.cameraOffsetX + this.cWidth / 2;
    this.focalPointY = this.cameraOffsetY + this.cHeight / 2;
    if (this.target && !this.checkFocusBounds()) {
      this.cameraOffsetX = this.target.x + (this.target.width / 2) - (this.cWidth / 2) + this.waitX;
      this.cameraOffsetY = this.target.y + (this.target.height / 2) - (this.cHeight / 2) + this.waitY;
    }
  }
  this.checkFocusBounds = function () {
    centerX = this.target.x + (this.target.width / 2);
    centerY = this.target.y + (this.target.height / 2);
    if (Math.abs(this.focalPointX - centerX) >= this.waitX) { return false; }
    if (Math.abs(this.focalPointY - centerY) >= this.waitY) { return false; }
    else { return true; }
  }
}
function canAct() { return (aiActivated || uiActivated) && !auxOpen; }
function canAIAct() { return aiActivated && !auxOpen; }
function cancel_game() { iClear('dMenu'); }
function cancelDD() {
  DragElem.remove();
  DragElem = DragSource = DragSourceItem = DropZoneItem = null;
}
function canHumanAct() { return uiActivated && !auxOpen; }
function cap_each_word(s) {
  let arr = s.split(' ');
  let res = '';
  for (const a of arr) { res += capitalize(a) + ' '; }
  return res.slice(0, -1);
}
function capitalize(s) {
  if (typeof s !== 'string') return '';
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function capitals_in_red(feature) {
  console.log('feature data', feature.data);
  let type = lookup(feature, ['data', 'type']);
  console.log('city', lookup(feature, ['data', 'name']), ':', type)
  return type == 'capital' ? 'red' : 'yellow';
}
function CAPTURED(m) { return (((m) >> 14) & 0xF); }
function Card(img, bunch, id, reverse) {
  var self = this;
  this.img = img;
  this.bunch = bunch;
  this.id = id;
  this.reverse = reverse;
  this.suit = Math.floor(id / self.bunch.board.deck.cardSuit);
  this.number = Math.floor(id % self.bunch.board.deck.cardSuit) + 1;
  this.color = Math.floor(id / self.bunch.board.deck.cardSuit) % 2;
  this.img.card = self;
  this.onDblClick = function () {
    self.reverse ? self.bunch.onDblClickReverse(self) : self.bunch.onDblClickCard(self);
  }
  this.flip = function () {
    self.reverse = !self.reverse;
    self.img.src = self.bunch.board.deck.cardSrc(self.id, self.reverse);
  }
  this.moveTo = function (bunch) {
    self.bunch = bunch;
    self.img.style.zIndex = self.bunch.cardZIndex();
    self.img.style.left = String(self.bunch.cardLeft()) + "px";
    self.img.style.top = String(self.bunch.cardTop()) + "px";
    self.reverse = self.bunch.cardReverse();
    self.img.src = self.bunch.board.deck.cardSrc(self.id, self.reverse);
  }
}
function card123(oCard, w, h) {
  if (lookup(SPEC, ['typeMappings', 'card'])) {
    for (const k in SPEC.typeMappings.card) {
      oCard[k] = oCard[SPEC.typeMappings.card[k]];
    }
  }
  let el = cardFace(oCard, w, h);
  return el;
}
function card52(irankey, suit, w, h) {
  //#region set rank and suit from inputs
  let rank = irankey;
  if (nundef(irankey) && nundef(suit)) {
    irankey = chooseRandom(Object.keys(c52));
    rank = irankey[5];
    suit = irankey[6];
  } else if (nundef(irankey)) {
    irankey = '2';
    suit = 'B';
  } else if (nundef(suit)) {
    if (isNumber(irankey)) irankey = getC52Key(iramkey);
    rank = irankey[5];
    suit = irankey[6];
  }
  console.log('rank', rank, 'suit', suit);
  if (rank == '10') rank = 'T';
  if (rank == '1') rank = 'A';
  if (nundef(suit)) suit = 'H'; else suit = suit[0].toUpperCase();
  //#endregion
  //#region load svg for card_[rank][suit] (eg. card_2H)
  let cardKey = 'card_' + rank + suit;
  let svgCode = c52[cardKey];
  svgCode = '<div>' + svgCode + '</div>';
  let el = createElementFromHTML(svgCode);
  if (isdef(h) || isdef(w)) { mSize(el, w, h); }
  //#endregion
  return { rank: rank, suit: suit, key: cardKey, div: el };
}
function cardContent(card, { topLeft, topRight, bottomLeft, bottomRight, reverseBottom = false, title, footer, middle, text }) {
  let svg = card.firstChild;
  let div = card;
  card.style.setProperty('position', 'relative');
  card.style.setProperty('font-size', '3mm');
  topLeft = ['A', '2'];
  bottomRight = ['A', 2];
  middle = null;
  let gap = 2; let d;
  let fBL = reverseBottom ? posBLR : posBL;
  let fBR = reverseBottom ? posBRR : posBR;
  if (isdef(topLeft)) { d = mDiv(card); mGap(d, gap); posTL(d); asList(topLeft).map(x => mDiv(d).innerHTML = x); }
  if (isdef(topRight)) { d = mDiv(card); mGap(d, gap); posTR(d); asList(topRight).map(x => mDiv(d).innerHTML = x); }
  if (isdef(bottomLeft)) { d = mDiv(card); mGap(d, gap); fBL(d); asList(bottomLeft).map(x => mDiv(d).innerHTML = x); }
  if (isdef(bottomRight)) { d = mDiv(card); mGap(d, gap); fBR(d); asList(bottomRight).map(x => mDiv(d).innerHTML = x); }
  if (isdef(middle)) {
    d = mDiv(card); mSize(d, 50, 50, '%'); mFont(d, '7mm');
    let dContent = mDiv(d); dContent.innerHTML = middle; if (isdef(text)) posCICT(dContent); else posCIC(dContent);
  }
  if (isdef(text)) {
    d = mDiv(card); mSize(d, 80, 50, '%'); mFont(d, '1.8mm');
    let lines = 4; if (isdef(middle)) { posCICB(d); d.appendChild(document.createElement('hr')); } else { posCIC(d); lines = 8; }
    let dContent = mDiv(d); dContent.innerHTML = text; dContent.classList.add('textEllipsis4Lines'); dContent.style.setProperty('-webkit-line-clamp', lines);
  }
}
function cardFace({ cardKey, rank, suit, key } = {}, w, h) {
  let svgCode;
  if (isdef(cardKey)) {
    cardKey = 'card_' + cardKey;
    svgCode = isdef(c52[cardKey]) ? c52[cardKey] : testCards[cardKey];
    if (!svgCode) svgCode = vidCache.getRandom('c52');
  } else if (isdef(key)) {
    cardKey = key;
    svgCode = testCards[cardKey];
    if (!svgCode) svgCode = vidCache.getRandom('c52');
  } else {
    if (nundef(rank)) { rank = '2'; suit = 'B'; }
    if (rank == '10') rank = 'T';
    if (rank == '1') rank = 'A';
    if (nundef(suit)) suit = 'H';
    cardKey = 'card_' + rank + suit;
    svgCode = c52[cardKey];
  }
  svgCode = '<div>' + svgCode + '</div>';
  let el = createElementFromHTML(svgCode);
  if (isdef(h)) { mSize(el, w, h); }
  return el;
}
function cardFromInfo(info, h, w, ov) {
  let svgCode = C52[info.c52key];
  svgCode = '<div>' + svgCode + '</div>';
  let el = mCreateFrom(svgCode);
  h = valf(h, valf(info.h, 100));
  w = valf(w, h * .7);
  mSize(el, w, h);
  let res = {};
  copyKeys(info, res);
  copyKeys({ w: w, h: h, faceUp: true, div: el }, res);
  if (isdef(ov)) res.ov = ov;
  return res;
}
function cardGameTest01() {
  rAreas();
}
function cardGameTest02() {
  setBackgroundColor(null, 'random');
  mStyle(dTable, { h: 400, bg: 'black', padding: 10 });
  let SPEC = { layout: ['T', 'H A'], showAreaNames: true };
  let s = '';
  let m = [];
  for (const line of SPEC.layout) {
    s += '"' + line + '" ';
    let letters = line.split(' ');
    let arr = [];
    for (const l of letters) { if (!isEmpty(l)) arr.push(l); }
    m.push(arr);
  }
  console.log('m', m, '\ns', s); return;
}
function cardGameTest03_OK() {
  setBackgroundColor(null, 'random');
  mStyle(dTable, { h: 400, bg: 'black', padding: 10 });
  let dGrid = mDiv100(dTable, { display: 'inline-grid' });
  let layout = ['T', 'H A'];
  let x = createGridLayout(dGrid, layout);
  console.log('result', x);
  createAreas(dGrid, x, 'a');
}
function cardGameTest04() {
  setBackgroundColor(null, 'random');
  let dGrid = mDiv(dTable, { bg: 'red', w: '80%', h: 400, padding: 10, display: 'inline-grid', rounding: 10 }, 'dGrid');
  let layout = ['T', 'H A'];
  let x = createGridLayout(dGrid, layout);
  console.log('result', x);
  createAreas(dGrid, x, 'dGrid');
}
function cardGameTest05() {
  setBackgroundColor(null, 'random');
  let dGrid = mDiv(dTable, { gap: 10, bg: 'white', w: '80%', h: 400, padding: 10, display: 'inline-grid', rounding: 10 }, 'dGrid');
  let layout = ['T', 'H A'];
  let areaStyles = { bg: 'random', rounding: 6 };
  let contentStyles = { bg: 'dimgray', lowerRounding: 6 };
  let messageStyles = { bg: 'dimgray', fg: 'yellow' };
  let titleStyles = { family: 'AlgerianRegular', upperRounding: 6 };
  let areas = {
    T: { title: 'table', id: 'dTrick', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles },
    H: { title: 'YOU', id: 'dHuman', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles },
    A: { title: 'opponent', id: 'dAI', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles },
  };
  let x = createGridLayout(dGrid, layout);
  console.log('result', x);
  let items = [];
  for (const k in areas) {
    let item = areas[k];
    item.areaStyles['grid-area'] = k;
    let dCell = mTitledMessageDiv(item.title, dGrid, item.id, item.areaStyles, item.contentStyles, item.titleStyles, item.messageStyles)
    iRegister(item, item.id);
    iAdd(item, { div: dCell, dTitle: dCell.children[0], dMessage: dCell.children[1], dContent: dCell.children[2] });
    items.push(item);
  }
  return items;
}
function cardGameTest06_clean_OK() {
  setBackgroundColor(null, 'random');
  let dGrid = mDiv(dTable, { gap: 10, bg: 'white', w: '90%', hmin: 400, padding: 10, display: 'inline-grid', rounding: 10 }, 'dGrid');
  let layout = ['T', 'H A'];
  let areaStyles = { bg: 'green', rounding: 6 };
  let contentStyles = { lowerRounding: 6 };
  let messageStyles = { fg: 'yellow' };
  let titleStyles = { bg: 'dimgray', family: 'AlgerianRegular', upperRounding: 6 };
  let areas = {
    T: { title: 'table', id: 'dTrick', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles },
    H: { title: 'YOU', id: 'dHuman', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles },
    A: { title: 'opponent', id: 'dAI', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles },
  };
  areas.T.areaStyles.w = '100%';
  let x = createGridLayout(dGrid, layout);
  console.log('result', x);
  let items = [];
  for (const k in areas) {
    let item = areas[k];
    item.areaStyles['grid-area'] = k;
    let dCell = mTitledMessageDiv(item.title, dGrid, item.id, item.areaStyles, item.contentStyles, item.titleStyles, item.messageStyles)
    iRegister(item, item.id);
    iAdd(item, { div: dCell, dTitle: dCell.children[0], dMessage: dCell.children[1], dContent: dCell.children[2] });
    mCenterCenterFlex(diContent(item));
    mStyle(diContent(item), { gap: 10 });
    items.push(item);
  }
  return items;
}
function cardGameTest07() {
  let items = cardGameTest07_helper();
  for (let i = 0; i < 3; i++) {
    let arr = [0, 1, 2, 10, 11].map(x => 1 + (x + i * 13) % 52);
    let d = diContent(items[i]);
    let id = 'h' + i;
    iH00(arr, d, { bg: 'blue' }, id);
  }
}
function cardGameTest07_helper() {
  setBackgroundColor(null, 'random');
  let dGrid = mDiv(dTable, { gap: 10, bg: 'white', w: '90%', padding: 10, display: 'inline-grid', rounding: 10 }, 'dGrid');
  let layout = ['T', 'H A'];
  let areaStyles = { bg: 'green', rounding: 6 };
  let contentStyles = { lowerRounding: 6 };
  let messageStyles = { fg: 'yellow' };
  let titleStyles = { bg: 'dimgray', family: 'AlgerianRegular', upperRounding: 6 };
  let areas = {
    T: { title: 'table', id: 'dTrick', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles },
    H: { title: 'YOU', id: 'dHuman', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles },
    A: { title: 'opponent', id: 'dAI', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles },
  };
  let x = createGridLayout(dGrid, layout);
  console.log('result', x);
  let items = [];
  for (const k in areas) {
    let item = areas[k];
    item.areaStyles['grid-area'] = k;
    let dCell = mTitledMessageDiv(item.title, dGrid, item.id, item.areaStyles, item.contentStyles, item.titleStyles, item.messageStyles)
    iRegister(item, item.id);
    iAdd(item, { div: dCell, dTitle: dCell.children[0], dMessage: dCell.children[1], dContent: dCell.children[2] });
    mCenterCenterFlex(diContent(item));
    mStyle(diContent(item), { gap: 10 });
    items.push(item);
  }
  return items;
}
function cardGameTest08() {
  let state = {
    pl1: { hand: [1, 2, 3, 4, 5], trick: [[6]] },
    pl2: { hand: [11, 12, 13, 14, 15], trick: [[16]] },
  };
  let trick = arrFlatten(state.pl1.trick).concat(arrFlatten(state.pl2.trick));
  let pl1Hand = state.pl1.hand;
  let pl2Hand = state.pl2.hand;
  let arrs = [trick, pl1Hand, pl2Hand];
  let items = makeAreasKrieg(dTable);
  for (let i = 0; i < 3; i++) {
    let arr = arrs[i];
    let item = items[i];
    let d = diContent(item);
    let id = 'h' + i;
    iMessage(item, '');
    iH00(arr, d, { bg: 'blue' }, id);
  }
}
function cardGameTest09() {
  let state = {
    pl1: { hand: [1, 2, 3, 4, 5], trick: [[6], [7, 8, 9]] },
    pl2: { hand: [11, 12, 13, 14, 15], trick: [[16], [17, 18, 19]] },
  };
  let areaItems = makeAreasKrieg(dTable);
  presentState1(state, areaItems);
}
function cardHand(pool, loc, o, oid, path, omap) {
  let size = CARD_SZ;
  let [w, h, gap] = [size * .66, size, 4];
  let olist = mapOMap(omap, pool);
  if (isEmpty(olist)) return null;
  let uis = getUis(olist, sizedCard123(w, h));
  let area = stage2_prepArea(loc);
  let container = stage3_prepContainer(area); mColor(container, 'red')
  stage4_layout(uis, container, w, h, gap, layoutHand);
}
function cardInno(dParent, key) {
  if (nundef(key)) key = chooseRandom(Object.keys(Cinno));
  let cardInfo = Cinno[key];
  cardInfo.key = key;
  let sym = INNO.sym[cardInfo.type];
  let info = Syms[sym.key];
  let card = cBlank(dParent, { fg: 'black', bg: INNO.color[cardInfo.color], w: CSZ, h: CSZ * .65 });
  let [dCard, sz, szTitle, margin] = [iDiv(card), CSZ / 5, CSZ / 8, CSZ / 40];
  let [dTitle, dMain] = cTitleArea(card, szTitle);
  let d = mAddContent(dTitle, key, {
    patop: 4, bg: sym.bg, fg: 'white', h: szTitle, fz: szTitle * .7, align: 'center',
    position: 'relative'
  });
  mAddContent(d, cardInfo.age, { hpadding: szTitle / 4, float: 'right' });
  let s = mSym(sym.key, d, { hpadding: szTitle / 4, h: szTitle * .7, fg: sym.fg, float: 'left' });
  let positions = ['tl', 'bl', 'bc', 'br'];
  for (let i = 0; i < 4; i++) {
    let r = cardInfo.resources[i];
    let pos = positions[i];
    if (r in INNO.sym) { innoSym(r, dMain, sz, pos, margin); }
    else if (r == 'None') { innoAgeNumber(cardInfo.age, dMain, sz, pos, margin); }
    else if (isNumber(r)) { innoBonusNumber(r, dMain, sz, pos, margin); }
    else if (r == 'echo') { innoEcho(cardInfo.echo, dMain, sz, pos, margin); }
  }
  let box = mBoxFromMargins(dMain, 10, margin, sz + margin, sz + 2 * margin);
  mStyle(box, { align: 'left' });
  let text = '';
  for (const dog of cardInfo.dogmas) {
    console.log('text', cardInfo.type, sym);
    let t = startsWith(dog, 'I demand') ? ('I <b>demand</b>' + dog.substring(8)) : dog;
    text += `<span style="color:${sym.bg};font-family:${info.family}">${info.text}</span>` + '&nbsp;' + t + '<br>';
  }
  let t2 = innoText(text);
  box.onclick = (ev) => makeInfobox(ev, box, 2);
  mFillText(t2, box);
}
function cardInno1(key, wCard = 420) {
  if (nundef(key)) key = chooseRandom(Object.keys(Cinno));
  let f = wCard / 420;
  let [w, h, szSym, paSym, fz, pa, bth, vGapTxt, rnd, gap] = [420 * f, 200 * f, 100 * f, 8 * f, 100 * f * .8, 20 * f, 4 * f, 8 * f, 10 * f, 6 * f].map(x => Math.ceil(x));
  let info = Cinno[key];
  info.key = key;
  let cdict = { red: RED, blue: 'royalblue', green: 'green', yellow: 'yelloworange', purple: 'indigo' };
  info.c = getColorDictColor(cdict[info.color]);
  let d = mDiv();
  mSize(d, w, h);
  mStyle(d, { fz: pa, margin: 8, align: 'left', bg: info.c, rounding: rnd, patop: paSym, paright: pa, pabottom: szSym, paleft: szSym + paSym, border: '' + bth + 'px solid silver', position: 'relative' })
  mText(info.key.toUpperCase(), d, { fz: pa, weight: 'bold', margin: 'auto' });
  mLinebreak(d);
  for (const dog of info.dogmas) {
    let text = replaceSymbols(dog);
    let d1 = mText(text, d);
    d1.style.marginBottom = '' + vGapTxt + 'px';
  }
  let syms = []; let d1;
  szSym -= gap;
  let sdict = {
    tower: { k: 'white-tower', bg: 'dimgray' }, clock: { k: 'watch', bg: 'navy' }, crown: { k: 'crown', bg: 'black' },
    tree: { k: 'tree', bg: GREEN },
    bulb: { k: 'lightbulb', bg: 'purple' }, factory: { k: 'factory', bg: 'red' }
  };
  for (const s in sdict) { sdict[s].sym = Syms[sdict[s].k]; }
  for (const sym of info.resources) {
    let isEcho = false;
    if (sym == 'None') {
      d1 = mDiv(d, { fz: fz * .75, fg: 'black', bg: 'white', rounding: '50%', display: 'inline' });
      let d2 = mText('' + info.age, d1, {});
      mClass(d2, 'centerCentered');
    } else if (sym == 'echo') {
      let text = info.echo;
      console.log('info.echo', info.echo);
      if (isList(info.echo)) text = info.echo[0];
      text = replaceSymbols(text);
      wEcho = szSym;
      let [w1, h1, w2, h2] = [wEcho, szSym, wEcho - 8, szSym - 8];
      d1 = mDiv(d, { display: 'inline', fg: 'white', bg: 'dimgray', rounding: 6, h: h1, w: w1 });
      let [bestFont, w3, h3] = fitFont(text, 20, w2, h2);
      let d2 = mDiv(d1, { w: w3, h: h3, fz: bestFont }, null, text);
      mCenterCenterFlex(d1);
      isEcho = true;
    } else if (isNumber(sym)) {
      d1 = mDiv(d, { fz: fz * .75, fg: 'white', bg: 'brown', border: '2px solid black', rounding: '50%', display: 'inline' });
      mCenterCenterFlex(d1);
      let d2 = mText('' + info.age, d1, {});
    } else {
      let key = sdict[sym].k;
      let mi = mPic(key, d, { w: szSym, fz: szSym * .8, bg: sdict[sym].bg, rounding: '10%' });
      d1 = iDiv(mi);
    }
    syms.push({ isEcho: isEcho, div: d1 });
  }
  placeSymbol(syms[0], szSym, gap, { left: 0, top: 0 });
  placeSymbol(syms[1], szSym, gap, { left: 0, bottom: 0 });
  placeSymbol(syms[2], szSym, gap, { left: w / 2, bottom: 0 });
  placeSymbol(syms[3], szSym, gap, { right: 0, bottom: 0 });
  info.div = d;
  return info;
}
function cardInnoSZ(key, wCard = 420) {
  if (nundef(key)) key = chooseRandom(Object.keys(cinno));
  let f = wCard / 420;
  let [w, h, szSym, paSym, fz, pa, bth, vGapTxt, rnd, gap] = [420 * f, 200 * f, 50 * f, 8 * f, 50 * f * .8, 20 * f, 4 * f, 8 * f, 10 * f, 6 * f].map(x => Math.ceil(x));
  let info = cinno[key];
  info.key = key;
  let cdict = { red: 'red1', blue: 'blue1', green: 'green1', yellow: 'yellow1', purple: 'purple' }
  info.c = colorDarker(ColorDict[cdict[info.color]].c, .6);
  let d = mDiv();
  mSize(d, w, h);
  mStyleX(d, { fz: pa, margin: 8, align: 'left', bg: info.c, rounding: rnd, patop: paSym, paright: pa, pabottom: szSym, paleft: szSym + paSym, border: '' + bth + 'px solid silver', position: 'relative' })
  mText(info.key.toUpperCase(), d, { fz: pa, weight: 'bold', margin: 'auto' });
  mLinebreak(d);
  for (const dog of info.dogmas) {
    console.log(dog);
    let d1 = mText(dog, d);
    d1.style.marginBottom = '' + vGapTxt + 'px';
  }
  let syms = []; let d1;
  szSym -= gap;
  let sdict = {
    tower: { k: 'white-tower', bg: 'dimgray' }, clock: { k: 'watch', bg: 'navy' }, crown: { k: 'crown', bg: 'black' },
    tree: { k: 'tree', bg: GREEN },
    bulb: { k: 'lightbulb', bg: 'purple' }, factory: { k: 'factory', bg: 'red' }
  };
  for (const sym of info.resources) {
    console.log(sym)
    if (sym == 'None') {
      console.log('age of card:', info.age)
      d1 = mDiv(d, { fz: fz * .75, fg: 'black', bg: 'white', rounding: '50%', display: 'inline' });
      let d2 = mText('' + info.age, d1, {});
      mClass(d2, 'centerCentered')
    } else if (sym == 'echo') {
    } else {
      console.log('ssssssssssssssssssssssss', sym)
      let key = sdict[sym].k;
      d1 = maPic(key, d, { w: szSym, bg: sdict[sym].bg, rounding: '10%' });
    }
    syms.push(d1);
  }
  mStyleX(syms[0], { position: 'absolute', w: szSym, h: szSym, left: 0, top: 0, margin: gap });
  mStyleX(syms[1], { position: 'absolute', w: szSym, h: szSym, left: 0, bottom: 0, margin: gap });
  mStyleX(syms[2], { position: 'absolute', w: szSym, h: szSym, left: w / 2, bottom: 0, margin: gap });
  mStyleX(syms[3], { position: 'absolute', w: szSym, h: szSym, right: 0, bottom: 0, margin: gap });
  info.div = d;
  return info;
  return 'hallo';
}
function cardInnoz(key, wCard = 420) {
  if (nundef(key)) key = chooseRandom(Object.keys(cinno));
  let f = wCard / 420;
  let [w, h, szSym, paSym, fz, pa, bth, vGapTxt, rnd, gap] = [420 * f, 200 * f, 50 * f, 8 * f, 50 * f * .8, 20 * f, 4 * f, 8 * f, 10 * f, 6 * f].map(x => Math.ceil(x));
  let info = cinno[key]; info.key = key;
  let cdict = { red: 'red1', blue: 'blue1', green: 'green1', yellow: 'yellow1', purple: 'purple' }
  info.c = colorDarker(ColorDict[cdict[info.color]].c, .6);
  let d = mDiv();
  mSize(d, w, h);
  mStyleX(d, { fz: pa, margin: 8, align: 'left', bg: info.c, rounding: rnd, patop: paSym, paright: pa, pabottom: szSym, paleft: szSym + paSym, border: '' + bth + 'px solid silver', position: 'relative' })
  mText(info.key.toUpperCase(), d, { fz: pa, weight: 'bold', margin: 'auto' });
  mLinebreak(d);
  for (const dog of info.dogmas) {
    let d1 = mText(dog, d);
    d1.style.marginBottom = '' + vGapTxt + 'px';
  }
  let syms = []; let d1;
  szSym -= gap;
  let sdict = {
    tower: { k: 'white-tower', bg: 'dimgray' }, clock: { k: 'watch', bg: 'navy' }, crown: { k: 'crown', bg: 'black' },
    tree: { k: 'tree', bg: GREEN },
    bulb: { k: 'lightbulb', bg: 'purple' }, factory: { k: 'factory', bg: 'red' }
  };
  for (const sym of info.resources) {
    if (sym == 'None') {
      d1 = { div: mDiv(d, { fz: fz * .75, w: szSym, h: szSym, fg: 'black', bg: 'white', rounding: '50%', display: 'inline' }) };
      let d2 = mText('' + info.age, d1.div, {});
      mClass(d2, 'centerCentered')
    } else if (sym == 'echo') {
    } else {
      let key = sdict[sym].k;
      d1 = zPic(key, d, { padding: 0, w: szSym, h: szSym, bg: sdict[sym].bg, rounding: '10%' });
    }
    syms.push(d1);
  }
  mStyleX(syms[0].div, { position: 'absolute', left: 0, top: 0, margin: gap });
  mStyleX(syms[1].div, { position: 'absolute', left: 0, bottom: 0, margin: gap });
  mStyleX(syms[2].div, { position: 'absolute', left: w / 2, bottom: 0, margin: gap });
  mStyleX(syms[3].div, { position: 'absolute', right: 0, bottom: 0, margin: gap });
  info.div = d;
  return info;
  return 'hallo';
}
function cardPattern(n, sym) {
  let di = {
    1: [sym],
    2: [[sym], [sym]],
    3: [[sym], [sym], [sym]],
    4: [[sym, sym], [sym, sym]],
    5: [[sym, sym], [sym], [sym, sym]],
    6: [[sym, sym], [sym, sym], [sym, sym]],
    7: [[sym, sym], [sym, sym, sym], [sym, sym]],
    8: [[sym, sym, sym], [sym, sym], [sym, sym, sym]],
    9: [[sym, sym, sym], [sym, sym, sym], [sym, sym, sym]],
    10: [[sym, sym, sym], [sym, sym, sym, sym], [sym, sym, sym]],
    11: [[sym, sym, sym, sym], [sym, sym, sym], [sym, sym, sym, sym]],
    12: [[sym, sym, sym, sym], [sym, sym, sym, sym], [sym, sym, sym, sym]],
    13: [[sym, sym, sym], [sym, sym], [sym, sym, sym], [sym, sym], [sym, sym, sym]],
    14: [[sym, sym, sym, sym], [sym, sym, sym, sym], [sym, sym, sym, sym]],
    15: [[sym, sym, sym, sym], [sym, sym, sym, sym], [sym, sym, sym, sym]],
  };
  return di[n];
}
function cards52GetRankFromName(name) {
  let rank;
  let n = firstNumber(name);
  if (isdef(n) && !isNaN(n)) rank = n;
  else {
    let ch = name.toLowerCase()[0];
    rank = ch == 'k' ? 13 : ch == 'q' ? 12 : 11;
  }
  return rank;
}
function cardZone(dParent, o, flex = 1, hmin = 170) {
  let dOuter = mDiv(dParent, { bg: o.color, fg: 'contrast', flex: flex, hmin: hmin }, 'd' + o.name, o.name);
  let dInner = mDiv(dOuter);
  mFlex(dInner); dInner.style.alignContent = 'flex-start';
  return dInner;
}
function carteset(l1, l2) {
  let res = [];
  for (var el1 of l1) {
    for (var el2 of l2) {
      if (isList(el1)) res.push(el1.concat(el2));
      else res.push([el1].concat(el2));
    }
  }
  return res;
}
function cartesi(l1, l2) {
  let res = [];
  for (var el1 of l1) {
    for (var el2 of l2) {
      res.push(el1.concat(el2));
    }
  }
  return res;
}
function cartesian(s1, s2, sep = '_') {
  let res = [];
  for (const el1 of s1) {
    for (const el2 of s2) {
      res.push(el1 + '_' + el2);
    }
  }
  return res;
}
function cartesianOf(ll) {
  let cart = ll[0];
  for (let i = 1; i < ll.length; i++) {
    cart = cartesian(cart, ll[i]);
  }
  return cart;
}
function catanBoard(dParent, rows, topcols, styles = {}) {
  let g = hex1Board(dParent, rows, topcols, styles);
  hexCornerNodes(g);
}
function catFiltered(cats, name, best) {
  let keys = setCategories(cats);
  let bestName = null;
  let k1 = keys.filter(x => best.includes(x));
  if (k1.length > 80) bestName = name + '100';
  else if (k1.length > 40) bestName = name + '50';
  else if (k1.length > 20) bestName = name + '25';
  let result = {};
  result[name] = keys;
  if (bestName) result[bestName] = k1;
  return result;
}
function cBlank(dParent, styles = {}, id) {
  if (nundef(styles.h)) styles.h = Card.sz;
  if (nundef(styles.w)) styles.w = styles.h * .7;
  if (nundef(styles.bg)) styles.bg = 'white';
  styles.position = 'relative';
  let [w, h, sz] = [styles.w, styles.h, Math.min(styles.w, styles.h)];
  if (nundef(styles.rounding)) styles.rounding = sz * .05;
  let d = mDiv(dParent, styles, id, null, 'card');
  let item = mItem(null, { div: d }, { type: 'card', sz: sz, rounding: styles.rounding });
  copyKeys(styles, item);
  return item;
}
function cBlankSvg(dParent, styles = {}) {
  if (nundef(styles.h)) styles.h = Card.sz;
  if (nundef(styles.w)) styles.w = styles.h * .7;
  if (nundef(styles.bg)) styles.bg = 'white';
  styles.position = 'relative';
  let [w, h, sz] = [styles.w, styles.h, Math.min(styles.w, styles.h)];
  if (nundef(styles.rounding)) styles.rounding = sz * .05;
  let d = mDiv(dParent, styles, null, null, 'card');
  let svg = mgTag('svg', d, { width: '100%', height: '100%' });
  let g = mgTag('g', svg);
  let item = mItem(null, { div: d, svg: svg, g: g }, { type: 'card', sz: sz });
  copyKeys(styles, item);
  return item;
}
function ccanvas(dParent, styles, bstyles, play, pause, origin = 'cc') {
  let o = mCanvas(dParent, styles, bstyles, play, pause);
  [this.cv, this.cx, this.play, this.pause] = [o.cv, o.cx, o.play, o.pause];
  let [w, h] = [this.w, this.h] = [this.cv.width, this.cv.height];
  this.defaultsize = 20;
  this.origin = cv_init_origin(this, origin);
  this.cx.translate(this.origin.x, this.origin.y);
  this.maxx = w - this.origin.x; this.minx = this.maxx - w;
  this.maxy = h - this.origin.y; this.miny = this.maxy - h;
  this.items = [];
}
function cCenterOrigin(cnv, ctx) {
  cSetOrigin(ctx, cnv.width / 2, cnv.height / 2);
}
function cCircle(c, sz, n, disp = -90) {
  let rad = sz / 2;
  centers = getEllipsePoints(rad, rad, n, disp)
  centers = centers.map(pt => ({ x: pt.X + c.x, y: pt.Y + c.y }));
  return centers;
}
function cClear(cnv = null, ctx = null) {
  if (nundef(cnv)) { cnv = CV; ctx = CX; if (!ctx) return; }
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, cnv.width, cnv.height);
  ctx.restore();
}
function cColor(fill, cvx) { if (nundef(cvx)) cvx = CX; CX.fillStyle = fill; }
function cdf0(x) {
  function normal(x, mu, sigma) {
    return stdNormal((x - mu) / sigma);
  }
  function stdNormal(z) {
    var j, k, kMax, m, values, total, subtotal, item, z2, z4, a, b;
    if (z < -6) { return 0; }
    if (z > 6) { return 1; }
    m = 1;
    b = z;
    z2 = z * z;
    z4 = z2 * z2;
    values = [];
    for (k = 0; k < 100; k += 2) {
      a = 2 * k + 1;
      item = b / (a * m);
      item *= (1 - (a * z2) / ((a + 1) * (a + 2)));
      values.push(item);
      m *= (4 * (k + 1) * (k + 2));
      b *= z4;
    }
    total = 0;
    for (k = 49; k >= 0; k--) {
      total += values[k];
    }
    return 0.5 + 0.3989422804014327 * total;
  }
  return normal(x, 100, 15);
}
function cEllipse(x, y, w, h, styles = null, angle = 0, ctx = null) {
  if (nundef(ctx)) { ctx = CX; if (!ctx) return; }
  if (styles) cStyle(styles, ctx);
  ctx.beginPath();
  ctx.ellipse(x, y, w / 2, h / 2, -angle, 0, 2 * Math.PI);
  if (isdef(styles.bg) || nundef(styles.fg)) ctx.fill();
  if (isdef(styles.fg)) ctx.stroke();
}
function centerFit(d, child) {
  let bChild = getBounds(child);
  let b = getBounds(d);
  let padding = firstNumber(d.style.padding);
  let wdes = b.width;
  let hdes = b.height;
  let wdesChild = wdes - 2 * padding;
  let hdesChild = hdes - 2 * padding;
  let wChild = bChild.width;
  let hChild = bChild.height;
  let padx = Math.floor(padding + (wdesChild - bChild.width) / 2);
  let pady = Math.floor(padding + (hdesChild - bChild.height) / 2);
  d.style.padding = pady + 'px ' + padx + 'px';
}
function cha3(cities) {
  let list = rChoose(cities, 20);
  for (const o of list) {
    map_add_city(o);
  }
  console.log('source', ensure_city_layer().getSource().getFeatures().map(x => x.data.city_ascii));
}
function chainCancel() {
  CancelChain = true;
  clearTimeout(ChainTimeout);
  TaskChain = [];
  setTimeout(() => BlockChain = false, 100);
}
function chainEx(taskChain, onComplete, ifBlocked = 'wait', singleThreaded = true) {
  if (BlockChain) {
    console.log('chain blocked!')
    switch (ifBlocked) {
      case 'interrupt': CancelChain = true; setTimeout(() => chainEx(taskChain, onComplete, 'wait'), 300); break;
      case 'wait': setTimeout(() => chainEx(taskChain, onComplete, 'wait'), 300); break;
      case 'return': default://just drop it
    }
  } else {
    BlockChain = true;
    CancelChain = false;
    let akku = [];
    if (singleThreaded) {
      TaskChain = taskChain;
      _singleThreadedChainExRec(akku, onComplete);
    } else {
      _chainExRec(akku, taskChain, onComplete);
    }
  }
}
function chainSend(msgChain, callback) {
  let akku = [];
  this.chainSendRec(akku, msgChain, callback);
}
function chainSendRec(akku, msgChain, callback) {
  if (msgChain.length > 0) {
    _sendRoute(msgChain[0], d => {
      akku.push(d);
      this.chainSendRec(akku, msgChain.slice(1), callback)
    });
  } else {
    callback(akku);
  }
}
function chall4() {
  let caps = M.capitals;
  let list = caps;
  for (const o of list) {
    map_add_city(o);
    console.log('city', o)
  }
  console.log('source', ensure_city_layer().getSource().getFeatures().map(x => x.data.city_ascii));
}
function challenge0() {
  for (const o of arrTake(cities, 10)) {
    console.log('o', o)
    add_circle(Number(o.lng), Number(o.lat), M.map);
  }
}
async function challenge1() {
  let data = await route_path_json('../base/mapdata/gadm36_AUT_2.json');
  var mapOptions = {
    center: [48.3, 16.3],
    zoom: 10
  }
  var map = new L.map('map', mapOptions);
  var layer = new L.TileLayer(''); //http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png');
  map.addLayer(layer);
  geojson = L.geoJson(data, {}).addTo(map);
  for (const f of data.features) {
    let name = f.properties.NAME_2;
    let fpoly = single_poly_feature(f);
    let center = get_poly_center(fpoly);
    let p = get_circle(center).addTo(map);
    var marker = L.marker(center, { opacity: 0 });
    marker.addTo(map);
    marker.bindTooltip(f.properties.NAME_2, { direction: 'center', permanent: true, className: 'mylabel', offset: L.point({ x: -30, y: 30 }) });
  }
}
function challenge2() {
  let layer = map_add_layer('city', M.map);
  let feature = map_add_circle_to_layer(16, 48, layer);
  feature.data = { hallo: 'Vienna' };
  console.log('source', layer.getSource().getFeatures());
}
function change(arr, n) {
  for (let i = 0; i < n; i++) {
    let mobj = chooseRandom(arr);
  }
}
function change_parent_type_if_needed(n, R) {
  let uiNode = R.uiNodes[n.uid];
  if (!isContainerType(uiNode.type)) {
    uiNode.type = 'panel';
    uiNode.changing = true;
    let uidParent = n.uidParent;
    let area = uidParent ? uidParent : R.baseArea;
    let uiNew = createUi(uiNode, area, R, uiNode.defParams);
  }
}
function changeGameTo(id) {
  if (isdef(id) && id == Gamename) return;
  if (isdef(T)) { saveTable(); }
  loadGame(id);
  loadTable();
}
function changeTableTo(id) {
  id = id.toLowerCase();
  if (isdef(id) && id == Tablename) return;
  if (id != Tablename && isdef(T)) { saveTable(); }
  loadTable(id);
}
function changeTo(newListName) {
  var x = newListName;
  document.getElementById('List').value = "";
  document.getElementById('List').setAttribute('list', x);
}
function changeToForInput(newListName, elid, defaultVal) {
  var x = newListName;
  document.getElementById(elid).value = '';
  document.getElementById(elid).setAttribute('list', x);
}
function changeUserTo(name) {
  if (name != Username) { saveUser(); }
  mBy('spUser').innerHTML = name;
  loadUser(name);
  startUnit();
}
function chat_2handleResult(result) {
  result = JSON.parse(result);
  console.log('chat result:', result);
  ActiveChats[result.userdata.username] = result;
  activateChat(result.userdata.username);
}
function chatStartOrActivate() {
  if (nundef(DA.currentContact) && nundef(DA.activeChat)) {
    console.log('no current contact!');
  } else if (nundef(DA.currentContact)) {
    console.log('no current contact! - activate activeChat!');
    console.log('(nothing to do!)')
  } else if (DA.currentContact == DA.activeChat) {
    console.log('currentContact is already active', DA.currentContact);
    return;
  } else if (isdef(ActiveChats[DA.currentContact])) {
    console.log('messages have been loaded for', DA.currentContact, '- just activate');
    activateChat(DA.currentContact);
    console.log('if another contact was active, deactivate,');
    console.log('activate this new contact');
  } else {
    console.log('new data for', DA.currentContact, 'have to be requested from phphost!');
    let data = { username: Username, currentContact: DA.currentContact, data_type: 'chat' };
    get_request('chat', data);
  }
}
function cheatDevcard() { sendRoute('/cheat/devcard', runToDevdeckAction); }
function check_complete_set(fenlist) {
  if (fenlist.length != 3) return false;
  let [f1, f2, f3] = fenlist;
  console.log('set clicked', f1, f2, f3)
  for (let i = 0; i < f1.length; i++) {
    let [a, b, c] = [f1[i], f2[i], f3[i]];
    console.log('...set clicked', a, b, c)
    let correct = (a == b && b == c) || (a != b && b != c && a != c);
    if (!correct) return false;
  }
  return true;
}
function check_correct_journey(A, fen, uplayer) {
  let items = A.selected.map(x => A.items[x]);
  if (items.length < 2) {
    select_error('please select at least 2 items!'); return [null, null, null];
  }
  let carditems = items.filter(x => is_card(x));
  if (isEmpty(carditems)) {
    select_error('please select at least 1 card!'); return [null, null, null];
  } else if (items.length - carditems.length > 1) {
    select_error('please select no more than 1 journey!'); return [null, null, null];
  }
  let journeyitem = firstCond(items, x => !is_card(x));
  let cards = journeyitem ? jsCopy(journeyitem.o.list) : [];
  cards = cards.concat(carditems.map(x => x.o.key));
  let jlegal = is_journey(cards);
  if (!jlegal || jlegal.length != cards.length) {
    select_error('this is not a legal journey!!'); return [null, null, null];
  }
  return [carditems, journeyitem, jlegal];
}
function check_for_clicks() {
  let cur = get_bar_values();
  let clicks = get_clicks_from_playerdata();
  let newgoals = jsCopy(Z.fen), changed = false;
  for (const k in cur) {
    if (clicks[k] == 0) continue;
    changed = true;
    let newgoal = cur[k] + clicks[k] * 10;
    newgoals[k] = newgoal;
    set_new_goal(k, newgoal);
  }
  Z.fen = newgoals;
  if (changed) {
    phpPost({ friendly: 'feedback', fen: newgoals, newstate: { green: 0, red: 0 } }, 'update_fen');
  } else {
    autopoll();
  }
}
function check_id(specKey, node, R) {
  let akku = {};
  recFindProp(node, '_id', 'self', akku);
  for (const k in akku) { R.addToPlaces(specKey, akku[k], k); }
}
function check_if_church() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  let jacks = fen.market.filter(x => x[0] == 'J');
  let queens = fen.market.filter(x => x[0] == 'Q');
  for (const plname of plorder) {
    let pl = fen.players[plname];
    let pl_jacks = pl.stall.filter(x => x[0] == 'J');
    let pl_queens = pl.stall.filter(x => x[0] == 'Q');
    jacks = jacks.concat(pl_jacks);
    queens = queens.concat(pl_queens);
  }
  let ischurch = false;
  for (const j of jacks) {
    if (firstCond(queens, x => x[1] != j[1])) ischurch = true;
  }
  return ischurch;
}
function check_poll_bot_send_move(obj) {
  console.log('...bot check table status: ', lookup(obj, ['table', 'status']) ?? 'no obj.table.status!!!', obj);
  if (nundef(DA.poll)) return;
  else if (isdef(obj) && isdef(obj.table) && obj.table.status == 'over') {
    DA.poll.onsuccess(obj);
  } else {
    BotTicker = setTimeout(poll, DA.poll.ms);
  }
}
function check_poll_orig() {
  let p = DA.long_polling;
  if (nundef(p)) { console.log('no polling is active!'); return; }
  to_server(p.data, p.type);
}
function check_poll_table_seen(obj) {
  console.assert(isdef(obj.table), 'check_poll_table_seen NO TABLE!!!!');
  let t = obj.table;
  if (t.status == 'seen' || t.status == 'past') {
    DA.poll.onsuccess(obj);
  } else {
    TOTicker = setTimeout(poll, DA.poll.ms);
  }
}
function check_poll_table_show(obj) {
  if (isdef(obj) && !isEmpty(obj.table) && obj.table.status == 'show') {
    DA.poll.onsuccess(obj);
  } else {
    TOTicker = setTimeout(poll, DA.poll.ms);
  }
}
function check_poll_table_started(obj) {
  if (isdef(obj) && !isEmpty(obj.tables)) {
    DA.poll.onsuccess(obj);
  } else {
    let dcheck = document.getElementById('ddd_logout');
    if (!dcheck) {
      present_non_admin_waiting_screen();
    }
    TOTicker = setTimeout(poll, DA.poll.ms);
  }
}
function check_ref(specKey, node, R) {
  let akku = {};
  recFindProp(node, '_ref', 'self', akku);
  for (const k in akku) { R.addToRefs(specKey, akku[k], k); }
}
function check_resolve() {
  let can_resolve = true;
  for (const plname of Z.plorder) {
    let data1 = firstCond(Z.playerdata, x => x.name == plname && !isEmpty(x.state));
    if (nundef(data1)) { can_resolve = false; break; }
  }
  return can_resolve;
}
function CheckAndSet() {
  if (CheckResult() != BOOL.TRUE) {
    GameController.GameOver = BOOL.FALSE;
    $("#GameStatus").text('');
  } else {
    GameController.GameOver = BOOL.TRUE;
    GameController.GameSaved = BOOL.TRUE;
    let win = GameController.winner;
    lookupAddToList(GameController, ['games'], isdef(win) ? win : 0);
  }
  ShowFenPosition();
}
function checkArrowKeys(ev) {
  if (!ev.ctrlKey) return;
  if (ev.keyCode == '13' && boatHighlighted) onClickSelectTuple(null, boatHighlighted);
  else if (ev.keyCode == '38') _highlightPrevBoat();
  else if (ev.keyCode == '40') _highlightNextBoat();
  else if (ev.keyCode == '37') { }
  else if (ev.keyCode == '39') { }
}
function checkAvailable(i) {
  id = getidAvailable(i); document.getElementById(id).checked = true;
}
function CheckBoard() {
  var t_pceNum = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  var t_material = [0, 0];
  var sq64, t_piece, t_pce_num, sq120, colour, pcount;
  for (t_piece = PIECES.wP; t_piece <= PIECES.bK; ++t_piece) {
    for (t_pce_num = 0; t_pce_num < brd_pceNum[t_piece]; ++t_pce_num) {
      sq120 = brd_pList[PCEINDEX(t_piece, t_pce_num)];
      if (brd_pieces[sq120] != t_piece) {
        console.log('Error Pce Lists');
        return BOOL.FALSE;
      }
    }
  }
  for (sq64 = 0; sq64 < 64; ++sq64) {
    sq120 = SQ120(sq64);
    t_piece = brd_pieces[sq120];
    t_pceNum[t_piece]++;
    t_material[PieceCol[t_piece]] += PieceVal[t_piece];
  }
  for (t_piece = PIECES.wP; t_piece <= PIECES.bK; ++t_piece) {
    if (t_pceNum[t_piece] != brd_pceNum[t_piece]) {
      console.log('Error t_pceNum');
      return BOOL.FALSE;
    }
  }
  if (t_material[COLOURS.WHITE] != brd_material[COLOURS.WHITE] || t_material[COLOURS.BLACK] != brd_material[COLOURS.BLACK]) {
    console.log('Error t_material');
    return BOOL.FALSE;
  }
  if (brd_side != COLOURS.WHITE && brd_side != COLOURS.BLACK) {
    console.log('Error brd_side');
    return BOOL.FALSE;
  }
  if (GeneratePosKey() != brd_posKey) {
    console.log('Error brd_posKey');
    return BOOL.FALSE;
  }
  return BOOL.TRUE;
}
function checkBoardEmpty(arr) { for (const x of arr) { if (!empty_func(x)) return false; } return true; }
function checkBoardFull(arr) { for (const x of arr) if (empty_func(x)) return false; return true; }
function checkCleanup() {
  if (!S.vars.firstTime) {
    pageHeaderClearAll();
    restoreBehaviors();
    stopBlinking('a_d_status');
    openTabTesting('London');
    UIS['a_d_status'].clear({ innerHTML: '<div id="c_d_statusText">status</div>' });
    UIS['a_d_actions'].clear({ innerHTML: '<div id="a_d_divSelect" class="sidenav1"></div>' });
    let areaPlayer = isdef(UIS['a_d_player']) ? 'a_d_player' : isdef(UIS['a_d_players']) ? 'a_d_players' : 'a_d_options';
    for (const id of ['a_d_log', 'a_d_objects', areaPlayer, 'a_d_game']) clearElement(id);
    delete S.players;
  } else S.vars.firstTime = false;
}
function checkCleanup_I() {
  if (isdef(UIS)) {
    stopBlinking('a_d_status');
    hide('passToNextPlayerUI');
    hide('freezer');
    stopInteraction();
    clearLog();
    delete G.end;
    delete G.signals.receivedEndMessage;
    delete G.previousPlayer;
    delete G.player;
    collections = {};
    scenarioQ = [];
  }
}
function checkCleanup_II() {
  if (isdef(UIS)) {
    checkCleanup_I();
    pageHeaderClearAll();
    restoreBehaviors();
    openTabTesting('ObjectsTab');
    UIS['a_d_status'].clear({ innerHTML: '<div id="c_d_statusText">status</div>' });
    UIS['a_d_actions'].clear({ innerHTML: '<div id="a_d_divSelect" class="sidenav1"></div>' });
    let areaPlayer = isdef(UIS['a_d_player']) ? 'a_d_player' : isdef(UIS['a_d_players']) ? 'a_d_players' : 'a_d_options';
    for (const id of ['a_d_log', 'a_d_objects', areaPlayer, 'a_d_game']) clearElement(id);
  }
}
function checkCleanup_III() {
  if (isdef(UIS)) {
    checkCleanup_II();
    delete S.players;
  }
}
function checkControlKey(ev) {
  if (ev.key == 'Control') {
    isControlKeyDown = false;
    clearInfoboxes();
  }
}
function checkGameConfigComplete() {
  for (const pl of S.gameConfig.players) {
    if (isEmpty(pl.username)) return false;
  }
  return true;
}
function checkKey(superdi, key, type) {
  let types = ['const', 'var', 'cla', 'func'];
  let itype = types.indexOf(type);
  for (const t in superdi) {
    if (lookup(superdi, [t, key])) {
      let it = types.indexOf(t);
      if (itype > it) { delete superdi[t][key]; return type; }
      else if (it > itype) { return type == 'const' ? t : false; }
      else return type;
    }
  }
  return type;
}
function checkPlayer(i) {
  id = getidNum(i); document.getElementById(id).checked = true;
}
function checkPotentialTTT(arr, rows, cols) { return checkWinnerPossible(arr, rows, cols); }
function CheckResult() {
  if (brd_fiftyMove > 100) {
    $("#GameStatus").text("GAME DRAWN {fifty move rule}");
    return BOOL.TRUE;
  }
  if (ThreeFoldRep() >= 2) {
    $("#GameStatus").text("GAME DRAWN {3-fold repetition}");
    return BOOL.TRUE;
  }
  if (DrawMaterial() == BOOL.TRUE) {
    $("#GameStatus").text("GAME DRAWN {insufficient material to mate}");
    return BOOL.TRUE;
  }
  GenerateMoves();
  var MoveNum = 0;
  var found = 0;
  for (MoveNum = brd_moveListStart[brd_ply]; MoveNum < brd_moveListStart[brd_ply + 1]; ++MoveNum) {
    if (MakeMove(brd_moveList[MoveNum]) == BOOL.FALSE) {
      continue;
    }
    found++;
    TakeMove();
    break;
  }
  $("#currentFenSpan").text(BoardToFen());
  if (found != 0) return BOOL.FALSE;
  var InCheck = SqAttacked(brd_pList[PCEINDEX(Kings[brd_side], 0)], brd_side ^ 1);
  console.log('No Move Found, incheck:' + InCheck);
  if (InCheck == BOOL.TRUE) {
    if (brd_side == COLOURS.WHITE) {
      $("#GameStatus").text("GAME OVER {black mates}");
      GameController.winner = 'black';
      return BOOL.TRUE;
    } else {
      $("#GameStatus").text("GAME OVER {white mates}");
      GameController.winner = 'white';
      return BOOL.TRUE;
    }
  } else {
    $("#GameStatus").text("GAME DRAWN {stalemate}"); return BOOL.TRUE;
  }
  console.log('Returning False');
  return BOOL.FALSE;
}
function checkSudokuRule(matrix) {
  let i = 0;
  for (const arr of matrix) {
    let dd = hasDuplicate(arr);
    if (dd) {
      let err = { type: 'row', row: i, col: dd.i, val: dd.val, info: dd, i: i };
      return err;
    }
    i += 1;
  }
  i = 0;
  for (const arr of bGetCols(matrix)) {
    let dd = hasDuplicate(arr);
    if (dd) {
      let err = { type: 'column', col: i, row: dd.i, val: dd.val, i: i, info: dd };
      return err;
    }
    i += 1;
  }
  let [rows, cols] = [matrix.length, matrix[0].length];
  let rowsEach = rows == 9 ? 3 : 2;
  let colsEach = cols == 4 ? 2 : 3;
  let chunks = bGetChunksWithIndices(matrix, rowsEach, colsEach);
  i = 0;
  for (const arr of chunks) {
    let dd = hasDuplicate(arr);
    if (dd) {
      let val = dd.val;
      let err = { type: 'quadrant', row: val.row, col: val.col, val: val.val, i: i, info: dd };
    }
    i += 1;
  }
  return null;
}
function checkSudokuRule_trial1(matrix) {
  for (const arr of matrix) { let dd = hasDuplicate(arr); if (dd) return { type: 'row', info: dd }; }
  for (const arr of bGetCols(matrix)) { let dd = hasDuplicate(arr); if (dd) return { type: 'column', info: dd }; }
  let chunks = bGetChunks(matrix, 2, 2);
  for (const arr of chunks) { let dd = hasDuplicate(arr); if (dd) return { type: 'quadrant', info: dd }; }
  return null;
}
function checkTimer(G) { if (nundef(GameTimer)) return false; return GameTimer.check(G); }
function CheckUp() {
  if (($.now() - srch_start) > srch_time) srch_stop = BOOL.TRUE;
}
function checkWinner(arr, rows, cols) {
  for (i = 0; i < rows; i++) { let ch = bFullRow(arr, i, rows, cols); if (ch) return ch; }
  for (i = 0; i < cols; i++) { let ch = bFullCol(arr, i, rows, cols); if (ch) return ch; }
  let ch = bFullDiag(arr, rows, cols); if (ch) return ch;
  ch = bFullDiag2(arr, rows, cols); if (ch) return ch;
  return null;
}
function checkWinnerC4(arr, rows = 6, cols = 7, stride = 4) {
  for (i = 0; i < rows; i++) { let ch = bStrideRow(arr, i, rows, cols, stride); if (ch) return ch; }
  for (i = 0; i < cols; i++) { let ch = bStrideCol(arr, i, rows, cols, stride); if (ch) return ch; }
  for (i = 0; i < rows; i++) {
    for (j = 0; j < cols; j++) {
      let ch = bStrideDiagFrom(arr, i, j, rows, cols, stride); if (ch) return ch;
      ch = bStrideDiag2From(arr, i, j, rows, cols, stride); if (ch) return ch;
    }
  }
  return null;
}
function checkWinnerPossible(arr, rows, cols) {
  for (i = 0; i < rows; i++) { let ch = bPartialRow(arr, i, rows, cols); if (ch) return ch; }
  for (i = 0; i < cols; i++) { let ch = bPartialCol(arr, i, rows, cols); if (ch) return ch; }
  let ch = bPartialDiag(arr, rows, cols); if (ch) return ch;
  ch = bPartialDiag2(arr, rows, cols); if (ch) return ch;
  return null;
}
function checkwinners(arr, rows, cols) {
  for (i = 0; i < rows; i++) { let ch = bFullRow(arr, i, rows, cols); if (ch) return ch; }
  for (i = 0; i < cols; i++) { let ch = bFullCol(arr, i, rows, cols); if (ch) return ch; }
  let ch = bFullDiag(arr, rows, cols); if (ch) return ch;
  ch = bFullDiag2(arr, rows, cols); if (ch) return ch;
  return null;
}
function checkwinnersC4(arr, rows = 6, cols = 7, stride = 4) {
  for (i = 0; i < rows; i++) { let ch = bStrideRow(arr, i, rows, cols, stride); if (ch) return ch; }
  for (i = 0; i < cols; i++) { let ch = bStrideCol(arr, i, rows, cols, stride); if (ch) return ch; }
  for (i = 0; i < rows; i++) {
    for (j = 0; j < cols; j++) {
      let ch = bStrideDiagFrom(arr, i, j, rows, cols, stride); if (ch) return ch;
      ch = bStrideDiag2From(arr, i, j, rows, cols, stride); if (ch) return ch;
    }
  }
  return null;
}
function checkwinnersPossible(arr, rows, cols) {
  for (i = 0; i < rows; i++) { let ch = bPartialRow(arr, i, rows, cols); if (ch) return ch; }
  for (i = 0; i < cols; i++) { let ch = bPartialCol(arr, i, rows, cols); if (ch) return ch; }
  let ch = bPartialDiag(arr, rows, cols); if (ch) return ch;
  ch = bPartialDiag2(arr, rows, cols); if (ch) return ch;
  return null;
}
function checkwinnersTTT(arr, rows, cols) { return checkwinners(arr, rows, cols); }
function checkWinnerTTT(arr, rows, cols) { return checkWinner(arr, rows, cols); }
function chessTestPos01() {
  let board = [
    ['bk', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
    ['em', 'bn', 'em', 'wr', 'em', 'wp', 'em', 'em'],
    ['br', 'em', 'bp', 'em', 'em', 'bn', 'wn', 'em'],
    ['em', 'em', 'bp', 'bp', 'bp', 'em', 'wp', 'bp'],
    ['bp', 'bp', 'em', 'bp', 'wn', 'em', 'wp', 'em'],
    ['em', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
    ['em', 'em', 'em', 'wk', 'em', 'em', 'em', 'em'],
    ['em', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
  ];
  console.log(arrToFen(board));
}
function chessTestPos02() {
  let board = [
    ['em', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
    ['em', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
    ['em', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
    ['em', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
    ['em', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
    ['em', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
    ['em', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
    ['em', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
  ];
  console.log(arrToFen(board, 'b'));
}
function choose(arr, n, excepti) { return rChoose(arr, n, null, excepti); }
function choose_dep(arr, n) {
  var result = new Array(n);
  var len = arr.length;
  var taken = new Array(len);
  if (n > len) n = len - 1;
  while (n--) {
    var iRandom = Math.floor(Math.random() * len);
    result[n] = arr[iRandom in taken ? taken[iRandom] : iRandom];
    taken[iRandom] = --len in taken ? taken[len] : len;
  }
  return result;
}
function chooseDeterministicOrRandom(n, arr, condFunc = null) {
  if (n < 0) return chooseRandomElement(arr, condFunc);
  if (condFunc) {
    let best = arr.filter(condFunc);
    if (!empty(best)) return best[n % best.length];
  }
  return arr[n % arr.length];
}
function chooseKeys(dict, n, except) { let keys = Object.keys(dict); let ind = except.map(x => keys.indexOf(x)); return choose(keys, n, ind); }
function chooseRandom(arr) { return rChoose(arr); }
function chooseRandomDictKey(dict, condFunc = null) {
  if (isEmpty(dict)) return null;
  let arr = Object.keys(dict);
  let len = arr.length;
  if (condFunc) {
    let best = arr.filter(condFunc);
    if (!isEmpty(best)) return chooseRandom(best);
  }
  let idx = Math.floor(Math.random() * len);
  return arr[idx];
}
function chooseRandomElement(arr, condFunc = null) {
  let len = arr.length;
  if (condFunc) {
    let best = arr.filter(condFunc);
    if (!empty(best)) return chooseRandomElement(best);
  }
  let idx = Math.floor(Math.random() * len);
  return arr[idx];
}
function chooseRandomKey(dict) { return chooseRandom(Object.keys(dict)); }
function circleCenters(rows, cols, wCell, hCell) {
  let [w, h] = [cols * wCell, rows * hCell];
  let cx = w / 2;
  let cy = h / 2;
  let centers = [{ x: cx, y: cy }];
  let rx = cx + wCell / 2; let dradx = rx / wCell;
  let ry = cy + hCell / 2; let drady = ry / hCell;
  let nSchichten = Math.floor(Math.min(dradx, drady));
  for (let i = 1; i < nSchichten; i++) {
    let [newCenters, wsch, hsch] = oneCircleCenters(i * 2 + 1, i * 2 + 1, wCell, hCell);
    for (const nc of newCenters) {
      centers.push({ x: nc.x + cx - wsch / 2, y: nc.y + cy - hsch / 2 });
    }
  }
  return [centers, wCell * cols, hCell * rows];
}
async function cities_from_csv_and_info(min = 25000) {
  let info = await route_path_yaml_dict('../base/assets/lists/info.yaml');
  let text = await route_path_text('../base/mapdata/cities.csv');
  let cities = M.cities = csv2list(text);
  let capitals = [];
  let new_cities = {};
  let num = 0;
  for (const o of cities) {
    let n = o.population;
    if (nundef(n)) continue;
    n = Number(n);
    if (n < min) continue;
    let w1 = o.city_ascii.toLowerCase();
    if (nundef(o.country)) {
      console.log('missing country', o);
      continue;
    }
    num += 1;
    let land1 = o.country.toLowerCase();
    for (const k of info.capital) {
      let w = k.toLowerCase();
      if (w.includes(w1) && w.includes(land1)) {
        capitals.push(o);
        o.capital = 'capital';
      }
      let name = o.name = o.city_ascii;
      if (isdef(new_cities[name]) && new_cities[name].includes('capital')) continue;
      else if (isdef(new_cities[name]) && Number(stringAfterLast(new_cities[name], ',')) > n) continue;
      new_cities[name] = `${o.lng},${o.lat},${o.country},${o.capital},${o.population}`;
    }
  }
  downloadAsYaml(new_cities, 'cities');
  return new_cities;
}
function clamp(x, min, max) { return Math.min(Math.max(x, min), max); }
function cLandscape(dParent, styles = {}, id) {
  if (nundef(styles.w)) styles.w = Card.sz;
  if (nundef(styles.h)) styles.h = styles.w * .65;
  return cBlank(dParent, styles, id);
}
function classByName(name) { return eval(name); }
function cleanup_or_resplay(oldgroup) {
  if (isdef(oldgroup) && isEmpty(oldgroup.ids)) {
    let oldgroupid = oldgroup.id;
    mRemove(iDiv(oldgroup));
    removeInPlace(DA.TJ, oldgroup);
    delete Items[oldgroupid];
  } else if (isdef(oldgroup)) { oldgroup.ov = .3222; resplay_container(oldgroup, .3222) }
}
function cleanupOldGame() {
  updateUserScore();
  if (isdef(G)) { G.clear(); }
  clearTable();
  clearStats();
  clearFleetingMessage();
}
function clear_ack_variables() {
  let [fen, uplayer, pl] = [Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  delete fen.ack_players;
  delete fen.lastplayer;
  delete fen.nextplayer;
  delete fen.turn_after_ack;
  delete fen.ackstage;
  delete fen.callbackname_after_ack;
  delete fen.keeppolling;
}
function clear_agents() {
  for (const a of M.agents) {
    let marker = a.ui;
    M.map.removeLayer(marker);
  }
  M.agents = [];
}
function clear_all() { for (const id of ['dFiddle', 'dMenu', 'dSearch', 'dSearchResult', 'dTable']) iClear(id); console.log('ids', get_keys(Items)) }
function clear_all_players() {
  console.log('trying to clear!!!')
  let d = mBy('d_players');
  let children = d.getElementsByTagName('input');
  console.log('children', children);
  for (const ch of children) { if (!ch.getAttribute('disabled')) ch.checked = false; }
}
function clear_gametable() {
  if (!isEmpty(DA.gameItems)) {
    let t = iDiv(DA.gameItems[0]).parentNode;
    t.remove();
  }
}
function clear_previous_level() {
  if (!isEmpty(A.items)) {
    console.assert(A.level >= 1, 'have items but level is ' + A.level);
    A.ll.push({ items: A.items, selected: A.selected });
    for (const item of A.items) {
      let bui = mBy(item.idButton);
      remove_hover_ui(bui);
      item.idButton = bui.id = getUID();
      let uid = item.idCard;
      let cui = isdef(uid) ? mBy(uid) : null;
      if (A.selected.includes(item.index)) {
        bui.onclick = null;
        if (cui) { mRemoveClass(cui, 'hoverScale'); cui.onclick = null; }
      } else {
        bui.style.opacity = 0;
        if (cui) { mRemoveClass(cui, 'hoverScale'); cui.onclick = null; }
      }
    }
  }
}
function clear_quick_buttons() {
  if (isdef(DA.bQuick)) { DA.bQuick.remove(); delete DA.bQuick; }
}
function clear_router() { M.map.removeControl(M.router); }
function clear_screen() { mShieldsOff(); clear_status(); clear_title(); for (const ch of arrChildren('dScreen')) mClear(ch); mClassRemove('dTexture', 'wood'); mStyle(document.body, { bg: 'white', fg: 'black' }); }
function clear_select(selected, selstyle = 'selected') {
  for (const item of selected) {
    item.isSelected = false;
    let ui = iDiv(item);
    if (isString(selstyle)) {
      mClassRemove(ui, selstyle);
    } else if (isdef(item.style)) {
      mStyle(ui, item.style);
    } else {
      mStyleUndo(ui, selstyle);
    }
  }
  return [];
}
function clear_selection() {
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  if (nundef(Z.A) || isEmpty(A.selected)) return;
  let selitems = A.selected.map(x => A.items[x]);
  for (const item of selitems) { ari_make_unselected(item); }
  A.selected = [];
}
function clear_status() { if (nundef(mBy('dStatus'))) return; clearTimeout(TO.fleeting); mRemove("dStatus"); }
function clear_table_all() {
  clear_table_events();
  if (isdef(mBy('table'))) clearTable();
  resetUIDs();
  Items = {};
}
function clear_table_events() {
  clear_timeouts();
  STOPAUS = true;
  pauseSound();
  DELAY = 1000;
  uiActivated = aiActivated = false;
  onclick = null;
  clearMarkers();
}
function clear_timeouts() {
  for (const k in TO) clearTimeout(TO[k]);
  stop_simple_timer();
}
function clear_title() { mClear('dTitleMiddle'); mClear('dTitleLeft'); mClear('dTitleRight'); }
function clear_transaction() { DA.simulate = false; DA.transactionlist = []; }
function ClearAllPieces() {
  $(".Piece").remove();
}
function clearBadges() {
  removeBadges(null, 0);
  badges = [];
}
function clearChat() { clearElement(document.getElementById('chatEvent')); }
function clearChatWindow() { clearElement('dChatWindow'); }
function clearDOM() {
}
function clearElement(elem) {
  if (isString(elem)) elem = document.getElementById(elem);
  if (window.jQuery == undefined) { elem.innerHTML = ''; return elem; }
  while (elem.firstChild) {
    $(elem.firstChild).remove();
  }
  return elem;
}
function clearElementFromChildIndex(elem, idx = 0) {
  let charr = arrChildren(elem).slice(idx);
  for (const ch of charr) {
    elem.removeChild(ch);
  }
}
function clearerror() { errormsg(""); }
function clearFleetingMessage() {
  if (isdef(dFleetingMessage)) {
    dFleetingMessage.remove();
    dFleetingMessage = null;
  }
}
function ClearForSearch() {
  var index = 0;
  var index2 = 0;
  for (index = 0; index < 14 * BRD_SQ_NUM; ++index) {
    brd_searchHistory[index] = 0;
  }
  for (index = 0; index < 3 * MAXDEPTH; ++index) {
    brd_searchKillers[index] = 0;
  }
  ClearPvTable();
  brd_ply = 0;
  srch_nodes = 0;
  srch_fh = 0;
  srch_fhf = 0;
  srch_start = $.now();
  srch_stop = BOOL.FALSE;
}
function clearGame() { }
function clearGameTitle() { clearElement(dGameTitle); }
function clearIncludingAttr(elem) {
  if (isString(elem)) elem = document.getElementById(elem);
  elem.innerHTML = '';
  removeAttributes(elem);
  return elem;
}
function clearInfoboxes() {
  let ids = Array.from(getIdsInfobox());
  for (const id of ids) { deleteRSG(id); }
  maxZIndex = 10;
}
function clearInit(elem, startProps = {}) {
  clearElement(elem);
  for (const k in startProps) { elem[k] = startProps[k]; }
}
function clearLevel() { clearElement(dLevel); clearBadges(); }
function clearLog() {
  delete G.log;
  UIS['a_d_log'].clear();
}
function clearMarkers() {
  for (const m of Markers) {
    mRemove(m);
  }
  Markers = [];
}
function clearMessages() { clearElement(document.getElementById('events')); }
function clearPageHeader() {
  UIS['a_d_divPlayerNames'].clear();
}
function ClearPiece(sq) {
  var pce = brd_pieces[sq];
  var col = PieceCol[pce];
  var index = 0;
  var t_pceNum = -1;
  HASH_PCE(pce, sq);
  brd_pieces[sq] = PIECES.EMPTY;
  brd_material[col] -= PieceVal[pce];
  for (index = 0; index < brd_pceNum[pce]; ++index) {
    if (brd_pList[PCEINDEX(pce, index)] == sq) {
      t_pceNum = index;
      break;
    }
  }
  brd_pceNum[pce]--;
  brd_pList[PCEINDEX(pce, t_pceNum)] = brd_pList[PCEINDEX(pce, brd_pceNum[pce])];
}
function ClearPvTable() {
  for (index = 0; index < PVENTRIES; index++) {
    brd_PvTable[index].move = NOMOVE;
    brd_PvTable[index].posKey = 0;
  }
}
function clearScore() { clearElement(dScore) }
function clearStats() {
  clearLevel();
  clearScore();
  clearGameTitle();
}
function clearStatus() { clearFleetingMessage(); }
function clearStep() {
}
function clearTable() {
  clearElement('dTable');
  clearElement('dHistory');
  show_title();
  clearElement('dMessage');
  clearElement('dInstruction');
  clearElement('dTitleRight');
  hide('bPauseContinue');
}
function clearTimeCD() {
  if (nundef(MSTimeTO)) return;
  clearTimeout(MSTimeTO); MSTimeClock = MSTimeDiff = MSTimeStart = MSTimeCallback = MSTimeTO = null;
}
function clearTimeouts() {
  onclick = null;
  clearTimeout(TOMain);
  clearTimeout(TOFleetingMessage);
  clearTimeout(TOTrial);
  if (isdef(TOList)) { for (const k in TOList) { TOList[k].map(x => clearTimeout(x)); } }
}
function clearZones() {
  for (const k in Zones) {
    clearElement(Zones[k].dData);
  }
}
function click_shield_off() { mBy('dShield').style.display = 'none'; }
function click_shield_on(msg) { show_shield(msg); }
function ClickedSquare(pageX, pageY) {
  var position = $("#ChessBoard").position();
  let dBoard = mBy('ChessBoard');
  let rBoard = setRectInt(dBoard);
  let dParent = mBy('ChessBoard').parentNode;
  let r = setRectInt(dParent);
  var workedX = Math.floor(position.left);
  var workedY = Math.floor(position.top);
  var pageX = Math.floor(pageX);
  var pageY = Math.floor(pageY);
  var file = Math.floor((pageX - workedX - r.l) / 60);
  var rank = 7 - Math.floor((pageY - workedY - r.t) / 60);
  var sq = FR2SQ(file, rank);
  if (GameController.BoardFlipped == BOOL.TRUE) {
    sq = MIRROR120(sq);
  }
  SetSqSelected(sq);
  return sq;
}
function cLine(x1, y1, x2, y2, styles = null, ctx = null) {
  if (nundef(ctx)) { ctx = CX; if (!ctx) return; }
  if (styles) cStyle(styles, ctx);
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2)
  ctx.stroke();
}
function cloneIfNecessary(value, optionsArgument) {
  var clone = optionsArgument && optionsArgument.clone === true
  return (clone && isMergeableObject(value)) ? deepmerge(emptyTarget(value), value, optionsArgument) : value
}
function cloneSvg(svg, id) {
  var newPawn = svg.cloneNode(true);
  newPawn.id = id;
  return newPawn;
}
function close_game_options() { mBy('inner_left_panel').innerHTML = ''; }
function close_image(e) {
  e.target.className = "image_off";
}
function close_mini_user_info() {
  setTimeout(() => {
    mBy('user_info_mini').style.display = 'none';
  }, 500);
}
function close_popup() {
  let dpop = mBy('dPopup');
  hide(dpop);
}
function close_sidebar() {
  let d = mBy('left_panel'); d.style.flex = 0;
  DA.left_panel = 'closed';
}
function closeAux() {
  hide(dAux);
  hide('dGo');
  show('dGear');
  show('dTemple');
  if (Settings.hasChanged) { Settings.updateSettings(); dbSaveX(); }
  Settings.hasChanged = false;
  auxOpen = false;
}
function closeGameConfig() {
  hideGameConfig();
  if (USE_SOCKETIO) {
    showEventList();
  }
  setMessage('hi again!');
  show('bJoinGame');
  show('bCreateGame');
  show('bResumeGame');
  hide('bLobbyOk');
  hide('bLobbyCancel');
}
function closeInfoboxesForBoatOids(boat) {
  let oids = boat.o.oids;
  for (const oid of oids) hideInfobox(oid);
}
function closeJoinConfig() {
  hideJoinConfig();
  if (USE_SOCKETIO) {
    showEventList();
  }
  setMessage('hi again!');
  show('bJoinGame');
  show('bCreateGame');
  show('bResumeGame');
  hide('bLobbyJoinOk');
  hide('bLobbyJoinCancel');
}
function closeLeftPane() {
  if (!paneOpen) return 0;
  let right = mBy('dInnerRight');
  mStyle(right, { flex: 2 });
  paneOpen = false;
  return DELAY_PANE;
}
function closeSettings() { setPicsPerLevel(); hide(dSettings); resumeUI(); }
function closeSocket() {
  if (!USE_SOCKETIO) return;
  if (clientData.name !== null && socket !== null) {
    socket.emit('message', clientData.name + ' has left');
    socket.close();
  }
}
function closestParent(elem, selector) {
  for (; elem && elem !== document; elem = elem.parentNode) {
    if (elem.matches(selector)) return elem;
  }
  return null;
}
function cls() {
  clearElement(document.getElementById('g'));
}
function coButtonSidebarDiv_00(dParent, bCaption = '☰', bStyles = { fz: 30 }, sbStyles = { bg: wpink }, divStyles = {}, outerStyles = { matop: 4, bg: wgrey }) {
  let d0 = mDiv100(dParent);
  let b = mButton(bCaption, null, d0, bStyles, 'mybutton');
  outerStyles.position = 'relative';
  let h = getRect(d0).h - (getRect(b).h + outerStyles.matop);
  outerStyles.h = h;
  let d = mDiv(d0, outerStyles);
  let dSide = mDiv(d, sbStyles);
  let dContent = mDiv(d, divStyles);
  let sb = iSidebar(d, dSide, dContent, b, 120, false);
  return { button: b, sidebar: sb, div: dContent };
}
function coin(percent = 50) { return Math.random() * 100 < percent; }
function collapseAll() {
  let coll = document.getElementsByClassName("collapsible");
  for (let i = 0; i < coll.length; i++) {
    let elem = coll[i];
    if (isVisible(getLinkContainerId(elem.id))) fireClick(elem);
  }
}
function collapseSmallLetterAreas(m, d) {
  let rows = m.length;
  let cols = m[0].length;
  let gtc = [];
  for (let c = 0; c < cols; c++) {
    gtc[c] = 'min-content';
    for (let r = 0; r < rows; r++) {
      let sArea = m[r][c];
      if (sArea[0] == sArea[0].toUpperCase()) gtc[c] = 'auto';
    }
  }
  let cres = gtc.join(' ');
  d.style.gridTemplateColumns = gtc.join(' '); //'min-content 1fr 1fr min-content';// 'min-content'.repeat(rows);
  let gtr = [];
  for (let r = 0; r < rows; r++) {
    gtr[r] = 'min-content';
    for (let c = 0; c < cols; c++) {
      let sArea = m[r][c];
      if (sArea[0] == sArea[0].toUpperCase()) gtr[r] = 'auto';
    }
  }
  let rres = gtr.join(' ');
  d.style.gridTemplateRows = gtr.join(' '); //'min-content 1fr 1fr min-content';// 'min-content'.repeat(rows);
}
function collect_data() {
  var myform = mBy("myform");
  var inputs = myform.getElementsByTagName("INPUT");
  var data = {};
  for (var i = inputs.length - 1; i >= 0; i--) {
    var key = inputs[i].name;
    switch (key) {
      case "username":
      case "name":
        let uname = inputs[i].value;
        console.log(`${key} in input is`, uname);
        uname = replaceAllSpecialChars(uname, ' ', '_');
        uname = replaceAllSpecialChars(uname, '&', '_');
        uname = replaceAllSpecialChars(uname, '+', '_');
        uname = replaceAllSpecialChars(uname, '?', '_');
        uname = replaceAllSpecialChars(uname, '=', '_');
        uname = replaceAllSpecialChars(uname, '+', '_');
        uname = replaceAllSpecialChars(uname, '/', '_');
        uname = replaceAllSpecialChars(uname, '\\', '_');
        data[key] = uname.toLowerCase();
        break;
      case "motto":
        data[key] = inputs[i].value.toLowerCase();
    }
  }
  if (DA.imageChanged) {
    sendHtml('imgPreview', Session.cur_user);
  } else {
    let udata = get_current_userdata();
    let changed = false;
    if (DA.colorChanged) { udata.color = DA.newColor; changed = true; }
    if (data.motto != udata.motto) {
      changed = true;
      udata.motto = data.motto;
      mBy('motto').innerHTML = udata.motto;
    }
    if (changed) {
      DA.next = get_login;
      db_save();
    }
  }
}
function collect_game_options() {
  collect_player_list();
  collect_game_specific_options();
}
function collect_game_specific_options(game) {
  let poss = Config.games[game].options;
  if (nundef(poss)) return;
  let di = {};
  for (const p in poss) {
    let fs = mBy(`d_${p}`);
    let val = get_checked_radios(fs)[0];
    di[p] = isNumber(val) ? Number(val) : val;
  }
  return di;
}
function collect_innerHTML(arr, sep = '') { return arr.map(x => iDiv(x).innerHTML).join(sep); }
function collect_player_list() {
  let d = mBy('d_players');
  let checkboxes = d.getElementsByTagName('input');
  Session.game_options.players = [];
  for (const chk of checkboxes) {
    if (chk.checked) {
      Session.game_options.players.push(chk.value);
    }
  }
}
function collectPropFromCss(prop) {
  const styles = document.styleSheets;
  let cssArr = [...styles[0].cssRules].map(x => ({
    class: x.selectorText,
    color: rgbToHex(x.style[prop]),
  }));
  return cssArr;
}
function color_areas(nHues = 2, iButtonHue = 0, areaClass = 'area', gridDiv = 'root') {
  let hue1 = Math.floor(Math.random() * 360);
  let pal = gen_palette(hue1, nHues);
  palette = pal;
  setCSSButtonColors(pal, iButtonHue);
  let areas = document.getElementsByClassName(areaClass);
  let grid = document.getElementById(gridDiv);
  grid.style.backgroundColor = pal[pal.length - 1][0].b;
  idx = 0;
  ihue = 0;
  for (const a of areas) {
    let cb = (a.style.backgroundColor = pal[idx][ihue].b);
    let cf = (a.style.color = pal[idx][ihue].f);
    testHelpers('back', standardize_color(cb));
    let hex = standardize_color(cb);
    let f = complementaryColor(hex);
    a.style.color = f;
    let rgbString = hex2rgb(hex);
    let f2 = getTextColor(rgbString);
    a.style.color = f2;
    let f3 = niceColor(rgbString);
    a.style.color = f3;
    let f4 = blackOrWhite(cb);
    a.style.color = f4;
    let f5 = idealTextColor(hex);
    a.style.color = f5;
    idx += 1;
    if (idx >= pal.length - 2) idx = 0;
    ihue = (ihue + 1) % pal[0].length;
    if (idx % pal[0].length == 0) ihue = (ihue + 1) % pal[0].length;
  }
}
function color2trans(color, alpha = 0.5) {
  let hex = standardize_color(color);
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  result = result
    ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    }
    : null;
  if (result) return `rgba(${result.r},${result.g},${result.b},${alpha})`;
  else return 'rgb(0,0,0,0.5)';
}
function colorA(cAny) {
  let rgb = colorRGB(cAny, true);
  return rgb.a;
}
function colorAreas(fromLocalStorage = true, nColors = 2) {
  let key = chooseRandom(Object.keys(modern_palettes));
  let colors = Object.values(modern_palettes[key]);
  colors = choose(colors, nColors + 1);
  shuffle(colors);
  let pals = colors.map(x => getPalette(x));
  setSYS('pals', pals);
  let ihue = 0;
  let idarkness = 1;
  setCSSVariable('--bgBody', pals[0][2]);
  setCSSButtonColors(pals, 0);
  for (const areaName of getSYS('baseAreaNames')) {
    console.log(areaName, ihue, idarkness);
    let areaInfo = getArea(areaName);
    let a = areaInfo.div;
    let bg = pals[ihue][idarkness];
    a.style.backgroundColor = bg;
    areaInfo.bg = bg;
    let fg = colorIdealText(bg);
    a.style.color = fg;
    areaInfo.fg = fg;
    areaInfo.idarkness = idarkness;
    areaInfo.ihue = ihue;
    idarkness += 1;
    if (idarkness >= pals[0].length - 2) idarkness = 1;
    ihue = (ihue + 1) % 2;
  }
}
function colorAreas_dep(hue0 = 260, nHues = 25, areaClass = 'area', root = 'root') {
  let hue1 = nHues;
  let hues = [hue0, hue1];
  let pals = [];
  for (const hue of hues) {
    let c = colorFrom(colorFromHue(hue));
    let pal = colorPalShade(c);
    pals.push(pal);
  }
  let ihue = 0;
  let idarkness = 1;
  setCSSVariable('--bgBody', pals[0][2]);
  setCSSButtonColors(pals, 0);
  let areas = document.getElementsByClassName(areaClass);
  let grid = document.getElementById(root);
  let areaColors = {};
  for (const a of areas) {
    let bg = (a.style.backgroundColor = pals[ihue][idarkness]);
    a.style.color = colorIdealText(bg);
    areaColors[a.id] = { bg: bg, fg: a.style.color, ihue: ihue, idarkness: idarkness };
    idarkness += 1;
    if (idarkness >= pals[0].length - 2) idarkness = 1;
    ihue = (ihue + 1) % pals.length;
  }
  return { hue0: hue0, nHues: nHues, pals: pals, mode: 'shades', areaColors: areaColors };
}
function colorAreas_wild(fromLocalStorage = true, { className = null } = {}) {
  let hues = getRandomHues(fromLocalStorage);
  let pals = getPaletteFromHues(hues);
  setSYS('pals', pals);
  setSYS('hues', hues);
  let ihue = 0;
  let idarkness = 1;
  setCSSVariable('--bgBody', pals[0][2]);
  setCSSButtonColors(pals, 0);
  let areaNames = [];
  if (isdef(className)) {
    let divs = document.getElementsByClassName(className);
    areaNames = divs.map(x => x.id);
    console.log(divs, areaNames);
  } else {
    areaNames = getSYS('baseAreaNames');
  }
  console.log(areaNames);
  for (const areaName of areaNames) {
    if (isdef(className)) {
      let d = document.getElementById(areaName);
      a.style.backgroundColor = randomColor();
      let fg = colorIdealText(bg);
      continue;
    }
    let areaInfo = getArea(areaName);
    let a = areaInfo.div;
    let bg = pals[ihue][idarkness];
    a.style.backgroundColor = bg;
    areaInfo.bg = bg;
    let fg = colorIdealText(bg);
    a.style.color = fg;
    areaInfo.fg = fg;
    areaInfo.idarkness = idarkness;
    areaInfo.ihue = ihue;
    idarkness += 1;
    if (idarkness >= pals[0].length - 2) idarkness = 1;
    ihue = (ihue + 1) % pals.length;
  }
}
function colorAreasBlend(c1, c2, areaClass = 'area', root = 'root') {
  c1 = colorFrom(c1);
  c2 = colorFrom(c2);
  let pb = colorPalBlend(c1, c2);
  let pals = [];
  for (const c of pb) {
    let pal = colorPalShade(c);
    pals.push(pal);
  }
  let ihue = 0;
  let idarkness = 1;
  setCSSButtonColors(pals, 0);
  let areas = document.getElementsByClassName(areaClass);
  let grid = document.getElementById(root);
  grid.style.backgroundColor = pals[pals.length - 1][0];
  for (const a of areas) {
    let bg = (a.style.backgroundColor = pals[ihue][idarkness]);
    a.style.color = colorIdealText(bg);
    idarkness += 1;
    if (idarkness >= pals[0].length - 2) idarkness = 1;
    ihue = (ihue + 4) % pals.length;
  }
  return pals;
}
function colorAreasN(hue0 = 120, nHues = 25, areaClass = 'area', root = 'root') {
  let hues = [];
  let hueDiff = Math.round(360 / nHues);
  let h = hue0;
  for (let i = 0; i < nHues; i++) {
    hues.push(h);
    h += hueDiff;
  }
  let pals = [];
  for (const hue of hues) {
    let c = colorFrom(colorFromHue(hue));
    let pal = colorPalShade(c);
    pals.push(pal);
  }
  let ihue = 0;
  let idarkness = 1;
  setCSSVariable('--bgBody', pals[0][2]);
  setCSSButtonColors(pals, 0);
  let areas = document.getElementsByClassName(areaClass);
  let grid = document.getElementById(root);
  let areaColors = {};
  for (const a of areas) {
    let bg = (a.style.backgroundColor = pals[ihue][idarkness]);
    a.style.color = colorIdealText(bg);
    areaColors[a.id] = { bg: bg, fg: a.style.color, ihue: ihue, idarkness: idarkness };
    idarkness += 1;
    if (idarkness >= pals[0].length - 2) idarkness = 1;
    ihue = (ihue + 1) % pals.length;
  }
  return { hue0: hue0, nHues: nHues, pals: pals, mode: 'shades', areaColors: areaColors };
}
function colorAreasOppositesBlend(hue = 120, areaClass = 'area', root = 'root') {
  let hueOpp = (hue + 180) % 360;
  let c1 = colorFromHue(hue);
  let c2 = colorFromHue(hueOpp);
  colorAreasBlend(c1, c2, areaClass, root);
}
function colorAreasRandomBlend(areaClass = 'area', root = 'root') {
  let c1 = randomColor();
  let c2 = randomColor();
  colorAreasBlend(c1, c2, areaClass, root);
}
function colorArrToString(r, g, b) {
  return 'rgb(' + r + ',' + g + ',' + b + ')';
}
function colorB(cAny) {
  let rgb = colorRGB(cAny, true);
  return rgb.b;
}
function colorBlend(zero1, c0, c1, log = true) {
  c0 = colorFrom(c0);
  c1 = colorFrom(c1);
  return pSBC(zero1, c0, c1, log);
}
function colorBright(c, percent) {
  let hex = colorHex(c);
  hex = hex.replace(/^\s*#|\s*$/g, '');
  if (hex.length == 3) {
    hex = hex.replace(/(.)/g, '$1$1');
  }
  var r = parseInt(hex.substr(0, 2), 16),
    g = parseInt(hex.substr(2, 2), 16),
    b = parseInt(hex.substr(4, 2), 16);
  return '#' +
    ((0 | (1 << 8) + r + (256 - r) * percent / 100).toString(16)).substr(1) +
    ((0 | (1 << 8) + g + (256 - g) * percent / 100).toString(16)).substr(1) +
    ((0 | (1 << 8) + b + (256 - b) * percent / 100).toString(16)).substr(1);
}
function colorChannelMixer(colorChannelA, colorChannelB, amountToMix) {
  var channelA = colorChannelA * amountToMix;
  var channelB = colorChannelB * (1 - amountToMix);
  return parseInt(channelA + channelB);
}
function colorChildren(strid, setFg = true) {
  for (const spid of strid.ids) {
    colorElem(spid, setFg);
  }
}
function colorChrome() {
  let pals = S.pals;
  setCSSVariable('--bgTabs', pals[0][3]);
  setCSSVariable('--bgBody', pals[0][2]);
  setCSSButtonColors(pals, 0);
}
function colorDark(c, percent = 50, log = true) {
  if (nundef(c)) c = rColor(); else c = colorFrom(c);
  let zero1 = -percent / 100;
  return pSBC(zero1, c, undefined, !log);
}
function colorDarker(c, zero1 = .8, log = true) {
  c = colorFrom(c);
  return pSBC(-zero1, c, undefined, !log);
}
function colorElem(id, setFg = true) {
  let spa = getVisual(id);
  if (!('spa' in spa.isa)) return;
  let bg = S.pals[spa.iPalette][spa.ipal];
  let elem = M.uis[id];
  if (isdef(spa.cssColor)) {
    setCSSVariable(spa.cssColor, bg);
  } else {
    elem.style.backgroundColor = fg;
  }
  if (setFg) {
    let fg = colorIdealText(bg);
    elem.style.color = fg;
  }
}
function colorFrom(cAny, a, allowHsl = false) {
  if (isString(cAny)) {
    if (cAny[0] == '#') {
      if (a == undefined) return cAny;
      cAny = cAny.substring(0, 7);
      return cAny + (a == 1 ? '' : alphaToHex(a));
    } else if (isdef(ColorDi) && lookup(ColorDi, [cAny])) {
      let c = ColorDi[cAny].c;
      if (a == undefined) return c;
      c = c.substring(0, 7);
      return c + (a == 1 ? '' : alphaToHex(a));
    } else if (startsWith(cAny, 'rand')) {
      let spec = capitalize(cAny.substring(4));
      if (isdef(window['color' + spec])) {
        c = window['color' + spec]();
      } else c = rColor();
      if (a == undefined) return c;
      return c + (a == 1 ? '' : alphaToHex(a));
    } else if (startsWith(cAny, 'linear')) {
      return cAny;
    } else if (cAny[0] == 'r' && cAny[1] == 'g') {
      if (a == undefined) return cAny;
      if (cAny[3] == 'a') {
        if (a < 1) {
          return stringBeforeLast(cAny, ',') + ',' + a + ')';
        } else {
          let parts = cAny.split(',');
          let r = firstNumber(parts[0]);
          return 'rgb(' + r + ',' + parts[1] + ',' + parts[2] + ')';
        }
      } else {
        if (a < 1) {
          return 'rgba' + cAny.substring(3, cAny.length - 1) + ',' + a + ')';
        } else {
          return cAny;
        }
      }
    } else if (cAny[0] == 'h' && cAny[1] == 's') {
      if (allowHsl) {
        if (a == undefined) return cAny;
        if (cAny[3] == 'a') {
          if (a < 1) {
            return stringBeforeLast(cAny, ',') + ',' + a + ')';
          } else {
            let parts = cAny.split(',');
            let r = firstNumber(parts[0]);
            return 'hsl(' + r + ',' + parts[1] + ',' + parts[2] + ')';
          }
        } else {
          return a == 1 ? cAny : 'hsla' + cAny.substring(3, cAny.length - 1) + ',' + a + ')';
        }
      } else {
        if (cAny[3] == 'a') {
          cAny = HSLAToRGBA(cAny);
        } else {
          cAny = HSLToRGB(cAny);
        }
        return colorFrom(cAny, a, false);
      }
    } else {
      ensureColorDict();
      let c = ColorDi[cAny];
      if (nundef(c)) {
        if (startsWith(cAny, 'rand')) {
          let spec = cAny.substring(4);
          if (isdef(window['color' + spec])) {
            c = window['color' + spec](res);
          } else c = rColor();
        } else {
          console.log('color not available:', cAny);
          throw new Error('color not found: ' + cAny)
          return '#00000000';
        }
      } else c = c.c;
      if (a == undefined) return c;
      c = c.substring(0, 7);
      return c + (a == 1 ? '' : alphaToHex(a));
    }
  } else if (Array.isArray(cAny)) {
    if (cAny.length == 3 && isNumber(cAny[0])) {
      let r = cAny[0];
      let g = cAny[1];
      let b = cAny[2];
      return a == undefined || a == 1 ? `rgb(${r},${g},${b})` : `rgba(${r},${g},${b},${a})`;
    } else {
      return rChoose(cAny);
    }
  } else if (typeof cAny == 'object') {
    if ('h' in cAny) {
      let hslString = '';
      if (a == undefined || a == 1) {
        hslString = `hsl(${cAny.h},${Math.round(cAny.s <= 1.0 ? cAny.s * 100 : cAny.s)}%,${Math.round(cAny.l <= 1.0 ? cAny.l * 100 : cAny.l)}%)`;
      } else {
        hslString = `hsla(${cAny.h},${Math.round(cAny.s <= 1.0 ? cAny.s * 100 : cAny.s)}%,${Math.round(cAny.l <= 1.0 ? cAny.l * 100 : cAny.l)}%,${a})`;
      }
      if (allowHsl) {
        return hslString;
      } else {
        return colorFrom(hslString, a, allowHsl);
      }
    } else if ('r' in cAny) {
      if (a !== undefined && a < 1) {
        return `rgba(${cAny.r},${cAny.g},${cAny.b},${a})`;
      } else {
        return `rgb(${cAny.r},${cAny.g},${cAny.b})`;
      }
    }
  }
}
function colorFromHSL(hue, sat = 100, lum = 50) {
  return hslToHex(valf(hue, rHue()), sat, lum);
}
function colorFromHue(h, s = 100, l = 50, asObject = false) {
  if (asObject) return { h: h, s: s, l: l }; else return `hsl(${h},${s},${l})`;
}
function colorG(cAny) {
  let rgb = colorRGB(cAny, true);
  return rgb.g;
}
function colorHex(cAny) {
  let c = colorFrom(cAny);
  if (c[0] == '#') {
    return c;
  } else {
    let res = pSBC(0, c, 'c');
    return res;
  }
}
function colorHex_RGBAToHex9(cAny) {
  let c = colorFrom(cAny);
  if (c[0] == '#') {
    return c;
  } else if (c[3] == '(') {
    return RGBToHex7(c);
  } else {
    let res = RGBAToHex9(c);
    return res;
  }
}
function colorHSL(cAny, asObject = false) {
  let res = colorFrom(cAny, undefined, true);
  let shsl = res;
  if (res[0] == '#') {
    if (res.length == 9) {
      shsl = hexAToHSLA(res);
    } else if (res.length == 7) {
      shsl = hexToHSL(res);
    }
  } else if (res[0] == 'r') {
    if (res[3] == 'a') {
      shsl = RGBAToHSLA(res);
    } else {
      shsl = RGBToHSL(res);
    }
  }
  let n = allNumbers(shsl);
  if (asObject) {
    return { h: n[0], s: n[1] / 100, l: n[2] / 100, a: n.length > 3 ? n[3] : 1 };
  } else {
    return shsl;
  }
}
function colorHSLBuild(hue, sat = 100, lum = 50) { let result = "hsl(" + hue + ',' + sat + '%,' + lum + '%)'; return result; }
function colorHue(cAny) { let hsl = colorHSL(cAny, true); return hsl.h; }
function colorHueWheel(contrastTo, minDiff = 25, mod = 30, start = 0) {
  let hc = colorHue(contrastTo);
  let wheel = [];
  while (start < 360) {
    let d1 = Math.abs((start + 360) - hc);
    let d2 = Math.abs((start) - hc);
    let d3 = Math.abs((start - 360) - hc);
    let min = Math.min(d1, d2, d3);
    if (min > minDiff) wheel.push(start);
    start += mod;
  }
  return wheel;
}
function colorIdealText(bg, grayPreferred = false) {
  let rgb = colorRGB(bg, true);
  const nThreshold = 105;
  let r = rgb.r;
  let g = rgb.g;
  let b = rgb.b;
  var bgDelta = r * 0.299 + g * 0.587 + b * 0.114;
  var foreColor = 255 - bgDelta < nThreshold ? 'black' : 'white';
  if (grayPreferred) foreColor = 255 - bgDelta < nThreshold ? 'dimgray' : 'snow';
  return foreColor;
}
function colorLabelDiv(size) { return o => labelDiv(o.label, o.color, size, size); }
function colorLabelRow(pool, loc, o, oid, path, omap) {
  let size = LABEL_SZ, gap = 4;
  let olist = mapOMap(omap);
  if (isEmpty(olist)) return;
  olist = olist.map(item => ({ color: convertToColor(item.key), label: convertToLabel(item.value) }));
  let uis = getUis(olist, colorLabelDiv(size));
  let area = stage2_prepArea(loc);
  let container = stage3_prepContainer(area); mColor(container, 'white');
  stage4_layout(uis, container, size, size, gap, layoutRow);
}
function colorLight(c, percent = 20, log = true) {
  if (nundef(c)) {
    return colorFromHSL(rHue(), 100, 85);
  } else c = colorFrom(c);
  let zero1 = percent / 100;
  return pSBC(zero1, c, undefined, !log);
}
function colorLighter(c, zero1 = .2, log = true) {
  c = colorFrom(c);
  return pSBC(zero1, c, undefined, !log);
}
function colorLum(cAny) {
  let hsl = colorHSL(cAny, true);
  return hsl.l;
}
function colorMap(spec) {
  const Colormap = {
    "jet": [{ "index": 0, "rgb": [0, 0, 131] }, { "index": 0.125, "rgb": [0, 60, 170] }, { "index": 0.375, "rgb": [5, 255, 255] }, { "index": 0.625, "rgb": [255, 255, 0] }, { "index": 0.875, "rgb": [250, 0, 0] }, { "index": 1, "rgb": [128, 0, 0] }],
    "hsv": [{ "index": 0, "rgb": [255, 0, 0] }, { "index": 0.169, "rgb": [253, 255, 2] }, { "index": 0.173, "rgb": [247, 255, 2] }, { "index": 0.337, "rgb": [0, 252, 4] }, { "index": 0.341, "rgb": [0, 252, 10] }, { "index": 0.506, "rgb": [1, 249, 255] }, { "index": 0.671, "rgb": [2, 0, 253] }, { "index": 0.675, "rgb": [8, 0, 253] }, { "index": 0.839, "rgb": [255, 0, 251] }, { "index": 0.843, "rgb": [255, 0, 245] }, { "index": 1, "rgb": [255, 0, 6] }],
    "hot": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.3, "rgb": [230, 0, 0] }, { "index": 0.6, "rgb": [255, 210, 0] }, { "index": 1, "rgb": [255, 255, 255] }],
    "spring": [{ "index": 0, "rgb": [255, 0, 255] }, { "index": 1, "rgb": [255, 255, 0] }],
    "summer": [{ "index": 0, "rgb": [0, 128, 102] }, { "index": 1, "rgb": [255, 255, 102] }],
    "autumn": [{ "index": 0, "rgb": [255, 0, 0] }, { "index": 1, "rgb": [255, 255, 0] }],
    "winter": [{ "index": 0, "rgb": [0, 0, 255] }, { "index": 1, "rgb": [0, 255, 128] }],
    "bone": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.376, "rgb": [84, 84, 116] }, { "index": 0.753, "rgb": [169, 200, 200] }, { "index": 1, "rgb": [255, 255, 255] }],
    "copper": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.804, "rgb": [255, 160, 102] }, { "index": 1, "rgb": [255, 199, 127] }],
    "greys": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 1, "rgb": [255, 255, 255] }],
    "yignbu": [{ "index": 0, "rgb": [8, 29, 88] }, { "index": 0.125, "rgb": [37, 52, 148] }, { "index": 0.25, "rgb": [34, 94, 168] }, { "index": 0.375, "rgb": [29, 145, 192] }, { "index": 0.5, "rgb": [65, 182, 196] }, { "index": 0.625, "rgb": [127, 205, 187] }, { "index": 0.75, "rgb": [199, 233, 180] }, { "index": 0.875, "rgb": [237, 248, 217] }, { "index": 1, "rgb": [255, 255, 217] }],
    "greens": [{ "index": 0, "rgb": [0, 68, 27] }, { "index": 0.125, "rgb": [0, 109, 44] }, { "index": 0.25, "rgb": [35, 139, 69] }, { "index": 0.375, "rgb": [65, 171, 93] }, { "index": 0.5, "rgb": [116, 196, 118] }, { "index": 0.625, "rgb": [161, 217, 155] }, { "index": 0.75, "rgb": [199, 233, 192] }, { "index": 0.875, "rgb": [229, 245, 224] }, { "index": 1, "rgb": [247, 252, 245] }],
    "yiorrd": [{ "index": 0, "rgb": [128, 0, 38] }, { "index": 0.125, "rgb": [189, 0, 38] }, { "index": 0.25, "rgb": [227, 26, 28] }, { "index": 0.375, "rgb": [252, 78, 42] }, { "index": 0.5, "rgb": [253, 141, 60] }, { "index": 0.625, "rgb": [254, 178, 76] }, { "index": 0.75, "rgb": [254, 217, 118] }, { "index": 0.875, "rgb": [255, 237, 160] }, { "index": 1, "rgb": [255, 255, 204] }],
    "bluered": [{ "index": 0, "rgb": [0, 0, 255] }, { "index": 1, "rgb": [255, 0, 0] }],
    "rdbu": [{ "index": 0, "rgb": [5, 10, 172] }, { "index": 0.35, "rgb": [106, 137, 247] }, { "index": 0.5, "rgb": [190, 190, 190] }, { "index": 0.6, "rgb": [220, 170, 132] }, { "index": 0.7, "rgb": [230, 145, 90] }, { "index": 1, "rgb": [178, 10, 28] }],
    "picnic": [{ "index": 0, "rgb": [0, 0, 255] }, { "index": 0.1, "rgb": [51, 153, 255] }, { "index": 0.2, "rgb": [102, 204, 255] }, { "index": 0.3, "rgb": [153, 204, 255] }, { "index": 0.4, "rgb": [204, 204, 255] }, { "index": 0.5, "rgb": [255, 255, 255] }, { "index": 0.6, "rgb": [255, 204, 255] }, { "index": 0.7, "rgb": [255, 153, 255] }, { "index": 0.8, "rgb": [255, 102, 204] }, { "index": 0.9, "rgb": [255, 102, 102] }, { "index": 1, "rgb": [255, 0, 0] }],
    "rainbow": [{ "index": 0, "rgb": [150, 0, 90] }, { "index": 0.125, "rgb": [0, 0, 200] }, { "index": 0.25, "rgb": [0, 25, 255] }, { "index": 0.375, "rgb": [0, 152, 255] }, { "index": 0.5, "rgb": [44, 255, 150] }, { "index": 0.625, "rgb": [151, 255, 0] }, { "index": 0.75, "rgb": [255, 234, 0] }, { "index": 0.875, "rgb": [255, 111, 0] }, { "index": 1, "rgb": [255, 0, 0] }],
    "portland": [{ "index": 0, "rgb": [12, 51, 131] }, { "index": 0.25, "rgb": [10, 136, 186] }, { "index": 0.5, "rgb": [242, 211, 56] }, { "index": 0.75, "rgb": [242, 143, 56] }, { "index": 1, "rgb": [217, 30, 30] }],
    "blackbody": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.2, "rgb": [230, 0, 0] }, { "index": 0.4, "rgb": [230, 210, 0] }, { "index": 0.7, "rgb": [255, 255, 255] }, { "index": 1, "rgb": [160, 200, 255] }],
    "earth": [{ "index": 0, "rgb": [0, 0, 130] }, { "index": 0.1, "rgb": [0, 180, 180] }, { "index": 0.2, "rgb": [40, 210, 40] }, { "index": 0.4, "rgb": [230, 230, 50] }, { "index": 0.6, "rgb": [120, 70, 20] }, { "index": 1, "rgb": [255, 255, 255] }],
    "electric": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.15, "rgb": [30, 0, 100] }, { "index": 0.4, "rgb": [120, 0, 100] }, { "index": 0.6, "rgb": [160, 90, 0] }, { "index": 0.8, "rgb": [230, 200, 0] }, { "index": 1, "rgb": [255, 250, 220] }],
    "alpha": [{ "index": 0, "rgb": [255, 255, 255, 0] }, { "index": 1, "rgb": [255, 255, 255, 1] }],
    "viridis": [{ "index": 0, "rgb": [68, 1, 84] }, { "index": 0.13, "rgb": [71, 44, 122] }, { "index": 0.25, "rgb": [59, 81, 139] }, { "index": 0.38, "rgb": [44, 113, 142] }, { "index": 0.5, "rgb": [33, 144, 141] }, { "index": 0.63, "rgb": [39, 173, 129] }, { "index": 0.75, "rgb": [92, 200, 99] }, { "index": 0.88, "rgb": [170, 220, 50] }, { "index": 1, "rgb": [253, 231, 37] }],
    "inferno": [{ "index": 0, "rgb": [0, 0, 4] }, { "index": 0.13, "rgb": [31, 12, 72] }, { "index": 0.25, "rgb": [85, 15, 109] }, { "index": 0.38, "rgb": [136, 34, 106] }, { "index": 0.5, "rgb": [186, 54, 85] }, { "index": 0.63, "rgb": [227, 89, 51] }, { "index": 0.75, "rgb": [249, 140, 10] }, { "index": 0.88, "rgb": [249, 201, 50] }, { "index": 1, "rgb": [252, 255, 164] }],
    "magma": [{ "index": 0, "rgb": [0, 0, 4] }, { "index": 0.13, "rgb": [28, 16, 68] }, { "index": 0.25, "rgb": [79, 18, 123] }, { "index": 0.38, "rgb": [129, 37, 129] }, { "index": 0.5, "rgb": [181, 54, 122] }, { "index": 0.63, "rgb": [229, 80, 100] }, { "index": 0.75, "rgb": [251, 135, 97] }, { "index": 0.88, "rgb": [254, 194, 135] }, { "index": 1, "rgb": [252, 253, 191] }],
    "plasma": [{ "index": 0, "rgb": [13, 8, 135] }, { "index": 0.13, "rgb": [75, 3, 161] }, { "index": 0.25, "rgb": [125, 3, 168] }, { "index": 0.38, "rgb": [168, 34, 150] }, { "index": 0.5, "rgb": [203, 70, 121] }, { "index": 0.63, "rgb": [229, 107, 93] }, { "index": 0.75, "rgb": [248, 148, 65] }, { "index": 0.88, "rgb": [253, 195, 40] }, { "index": 1, "rgb": [240, 249, 33] }],
    "warm": [{ "index": 0, "rgb": [125, 0, 179] }, { "index": 0.13, "rgb": [172, 0, 187] }, { "index": 0.25, "rgb": [219, 0, 170] }, { "index": 0.38, "rgb": [255, 0, 130] }, { "index": 0.5, "rgb": [255, 63, 74] }, { "index": 0.63, "rgb": [255, 123, 0] }, { "index": 0.75, "rgb": [234, 176, 0] }, { "index": 0.88, "rgb": [190, 228, 0] }, { "index": 1, "rgb": [147, 255, 0] }],
    "cool": [{ "index": 0, "rgb": [125, 0, 179] }, { "index": 0.13, "rgb": [116, 0, 218] }, { "index": 0.25, "rgb": [98, 74, 237] }, { "index": 0.38, "rgb": [68, 146, 231] }, { "index": 0.5, "rgb": [0, 204, 197] }, { "index": 0.63, "rgb": [0, 247, 146] }, { "index": 0.75, "rgb": [0, 255, 88] }, { "index": 0.88, "rgb": [40, 255, 8] }, { "index": 1, "rgb": [147, 255, 0] }],
    "rainbow-soft": [{ "index": 0, "rgb": [125, 0, 179] }, { "index": 0.1, "rgb": [199, 0, 180] }, { "index": 0.2, "rgb": [255, 0, 121] }, { "index": 0.3, "rgb": [255, 108, 0] }, { "index": 0.4, "rgb": [222, 194, 0] }, { "index": 0.5, "rgb": [150, 255, 0] }, { "index": 0.6, "rgb": [0, 255, 55] }, { "index": 0.7, "rgb": [0, 246, 150] }, { "index": 0.8, "rgb": [50, 167, 222] }, { "index": 0.9, "rgb": [103, 51, 235] }, { "index": 1, "rgb": [124, 0, 186] }],
    "bathymetry": [{ "index": 0, "rgb": [40, 26, 44] }, { "index": 0.13, "rgb": [59, 49, 90] }, { "index": 0.25, "rgb": [64, 76, 139] }, { "index": 0.38, "rgb": [63, 110, 151] }, { "index": 0.5, "rgb": [72, 142, 158] }, { "index": 0.63, "rgb": [85, 174, 163] }, { "index": 0.75, "rgb": [120, 206, 163] }, { "index": 0.88, "rgb": [187, 230, 172] }, { "index": 1, "rgb": [253, 254, 204] }],
    "cdom": [{ "index": 0, "rgb": [47, 15, 62] }, { "index": 0.13, "rgb": [87, 23, 86] }, { "index": 0.25, "rgb": [130, 28, 99] }, { "index": 0.38, "rgb": [171, 41, 96] }, { "index": 0.5, "rgb": [206, 67, 86] }, { "index": 0.63, "rgb": [230, 106, 84] }, { "index": 0.75, "rgb": [242, 149, 103] }, { "index": 0.88, "rgb": [249, 193, 135] }, { "index": 1, "rgb": [254, 237, 176] }],
    "chlorophyll": [{ "index": 0, "rgb": [18, 36, 20] }, { "index": 0.13, "rgb": [25, 63, 41] }, { "index": 0.25, "rgb": [24, 91, 59] }, { "index": 0.38, "rgb": [13, 119, 72] }, { "index": 0.5, "rgb": [18, 148, 80] }, { "index": 0.63, "rgb": [80, 173, 89] }, { "index": 0.75, "rgb": [132, 196, 122] }, { "index": 0.88, "rgb": [175, 221, 162] }, { "index": 1, "rgb": [215, 249, 208] }],
    "density": [{ "index": 0, "rgb": [54, 14, 36] }, { "index": 0.13, "rgb": [89, 23, 80] }, { "index": 0.25, "rgb": [110, 45, 132] }, { "index": 0.38, "rgb": [120, 77, 178] }, { "index": 0.5, "rgb": [120, 113, 213] }, { "index": 0.63, "rgb": [115, 151, 228] }, { "index": 0.75, "rgb": [134, 185, 227] }, { "index": 0.88, "rgb": [177, 214, 227] }, { "index": 1, "rgb": [230, 241, 241] }],
    "freesurface-blue": [{ "index": 0, "rgb": [30, 4, 110] }, { "index": 0.13, "rgb": [47, 14, 176] }, { "index": 0.25, "rgb": [41, 45, 236] }, { "index": 0.38, "rgb": [25, 99, 212] }, { "index": 0.5, "rgb": [68, 131, 200] }, { "index": 0.63, "rgb": [114, 156, 197] }, { "index": 0.75, "rgb": [157, 181, 203] }, { "index": 0.88, "rgb": [200, 208, 216] }, { "index": 1, "rgb": [241, 237, 236] }],
    "freesurface-red": [{ "index": 0, "rgb": [60, 9, 18] }, { "index": 0.13, "rgb": [100, 17, 27] }, { "index": 0.25, "rgb": [142, 20, 29] }, { "index": 0.38, "rgb": [177, 43, 27] }, { "index": 0.5, "rgb": [192, 87, 63] }, { "index": 0.63, "rgb": [205, 125, 105] }, { "index": 0.75, "rgb": [216, 162, 148] }, { "index": 0.88, "rgb": [227, 199, 193] }, { "index": 1, "rgb": [241, 237, 236] }],
    "oxygen": [{ "index": 0, "rgb": [64, 5, 5] }, { "index": 0.13, "rgb": [106, 6, 15] }, { "index": 0.25, "rgb": [144, 26, 7] }, { "index": 0.38, "rgb": [168, 64, 3] }, { "index": 0.5, "rgb": [188, 100, 4] }, { "index": 0.63, "rgb": [206, 136, 11] }, { "index": 0.75, "rgb": [220, 174, 25] }, { "index": 0.88, "rgb": [231, 215, 44] }, { "index": 1, "rgb": [248, 254, 105] }],
    "par": [{ "index": 0, "rgb": [51, 20, 24] }, { "index": 0.13, "rgb": [90, 32, 35] }, { "index": 0.25, "rgb": [129, 44, 34] }, { "index": 0.38, "rgb": [159, 68, 25] }, { "index": 0.5, "rgb": [182, 99, 19] }, { "index": 0.63, "rgb": [199, 134, 22] }, { "index": 0.75, "rgb": [212, 171, 35] }, { "index": 0.88, "rgb": [221, 210, 54] }, { "index": 1, "rgb": [225, 253, 75] }],
    "phase": [{ "index": 0, "rgb": [145, 105, 18] }, { "index": 0.13, "rgb": [184, 71, 38] }, { "index": 0.25, "rgb": [186, 58, 115] }, { "index": 0.38, "rgb": [160, 71, 185] }, { "index": 0.5, "rgb": [110, 97, 218] }, { "index": 0.63, "rgb": [50, 123, 164] }, { "index": 0.75, "rgb": [31, 131, 110] }, { "index": 0.88, "rgb": [77, 129, 34] }, { "index": 1, "rgb": [145, 105, 18] }],
    "salinity": [{ "index": 0, "rgb": [42, 24, 108] }, { "index": 0.13, "rgb": [33, 50, 162] }, { "index": 0.25, "rgb": [15, 90, 145] }, { "index": 0.38, "rgb": [40, 118, 137] }, { "index": 0.5, "rgb": [59, 146, 135] }, { "index": 0.63, "rgb": [79, 175, 126] }, { "index": 0.75, "rgb": [120, 203, 104] }, { "index": 0.88, "rgb": [193, 221, 100] }, { "index": 1, "rgb": [253, 239, 154] }],
    "temperature": [{ "index": 0, "rgb": [4, 35, 51] }, { "index": 0.13, "rgb": [23, 51, 122] }, { "index": 0.25, "rgb": [85, 59, 157] }, { "index": 0.38, "rgb": [129, 79, 143] }, { "index": 0.5, "rgb": [175, 95, 130] }, { "index": 0.63, "rgb": [222, 112, 101] }, { "index": 0.75, "rgb": [249, 146, 66] }, { "index": 0.88, "rgb": [249, 196, 65] }, { "index": 1, "rgb": [232, 250, 91] }],
    "turbidity": [{ "index": 0, "rgb": [34, 31, 27] }, { "index": 0.13, "rgb": [65, 50, 41] }, { "index": 0.25, "rgb": [98, 69, 52] }, { "index": 0.38, "rgb": [131, 89, 57] }, { "index": 0.5, "rgb": [161, 112, 59] }, { "index": 0.63, "rgb": [185, 140, 66] }, { "index": 0.75, "rgb": [202, 174, 88] }, { "index": 0.88, "rgb": [216, 209, 126] }, { "index": 1, "rgb": [233, 246, 171] }],
    "velocity-blue": [{ "index": 0, "rgb": [17, 32, 64] }, { "index": 0.13, "rgb": [35, 52, 116] }, { "index": 0.25, "rgb": [29, 81, 156] }, { "index": 0.38, "rgb": [31, 113, 162] }, { "index": 0.5, "rgb": [50, 144, 169] }, { "index": 0.63, "rgb": [87, 173, 176] }, { "index": 0.75, "rgb": [149, 196, 189] }, { "index": 0.88, "rgb": [203, 221, 211] }, { "index": 1, "rgb": [254, 251, 230] }],
    "velocity-green": [{ "index": 0, "rgb": [23, 35, 19] }, { "index": 0.13, "rgb": [24, 64, 38] }, { "index": 0.25, "rgb": [11, 95, 45] }, { "index": 0.38, "rgb": [39, 123, 35] }, { "index": 0.5, "rgb": [95, 146, 12] }, { "index": 0.63, "rgb": [152, 165, 18] }, { "index": 0.75, "rgb": [201, 186, 69] }, { "index": 0.88, "rgb": [233, 216, 137] }, { "index": 1, "rgb": [255, 253, 205] }],
    "cubehelix": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.07, "rgb": [22, 5, 59] }, { "index": 0.13, "rgb": [60, 4, 105] }, { "index": 0.2, "rgb": [109, 1, 135] }, { "index": 0.27, "rgb": [161, 0, 147] }, { "index": 0.33, "rgb": [210, 2, 142] }, { "index": 0.4, "rgb": [251, 11, 123] }, { "index": 0.47, "rgb": [255, 29, 97] }, { "index": 0.53, "rgb": [255, 54, 69] }, { "index": 0.6, "rgb": [255, 85, 46] }, { "index": 0.67, "rgb": [255, 120, 34] }, { "index": 0.73, "rgb": [255, 157, 37] }, { "index": 0.8, "rgb": [241, 191, 57] }, { "index": 0.87, "rgb": [224, 220, 93] }, { "index": 0.93, "rgb": [218, 241, 142] }, { "index": 1, "rgb": [227, 253, 198] }]
  };
  var indicies, fromrgba, torgba, nsteps, cmap, colormap, format, nshades, colors, alpha, i;
  if (!spec) spec = {};
  nshades = (spec.nshades || 72) - 1;
  format = spec.format || 'hex';
  colormap = spec.colormap;
  if (!colormap) colormap = 'jet';
  if (typeof colormap === 'string') {
    colormap = colormap.toLowerCase();
    if (!Colormap[colormap]) {
      throw Error(colormap + ' not a supported colorscale');
    }
    cmap = Colormap[colormap];
  } else if (Array.isArray(colormap)) {
    cmap = colormap.slice();
  } else {
    throw Error('unsupported colormap option', colormap);
  }
  if (cmap.length > nshades + 1) {
    throw new Error(
      colormap + ' map requires nshades to be at least size ' + cmap.length
    );
  }
  if (!Array.isArray(spec.alpha)) {
    if (typeof spec.alpha === 'number') {
      alpha = [spec.alpha, spec.alpha];
    } else {
      alpha = [1, 1];
    }
  } else if (spec.alpha.length !== 2) {
    alpha = [1, 1];
  } else {
    alpha = spec.alpha.slice();
  }
  indicies = cmap.map(c => {
    return Math.round(c.index * nshades);
  });
  alpha[0] = Math.min(Math.max(alpha[0], 0), 1);
  alpha[1] = Math.min(Math.max(alpha[1], 0), 1);
  var steps = cmap.map((c, i) => {
    var index = cmap[i].index
    var rgba = cmap[i].rgb.slice();
    if (rgba.length === 4 && rgba[3] >= 0 && rgba[3] <= 1) {
      return rgba
    }
    rgba[3] = alpha[0] + (alpha[1] - alpha[0]) * index;
    return rgba
  })
  var colors = []
  for (i = 0; i < indicies.length - 1; ++i) {
    nsteps = indicies[i + 1] - indicies[i];
    fromrgba = steps[i];
    torgba = steps[i + 1];
    for (var j = 0; j < nsteps; j++) {
      var amt = j / nsteps
      colors.push([
        Math.round(lerp(fromrgba[0], torgba[0], amt)),
        Math.round(lerp(fromrgba[1], torgba[1], amt)),
        Math.round(lerp(fromrgba[2], torgba[2], amt)),
        lerp(fromrgba[3], torgba[3], amt)
      ])
    }
  }
  colors.push(cmap[cmap.length - 1].rgb.concat(alpha[1]))
  if (format === 'hex') colors = colors.map(rgb2hex);
  else if (format === 'rgbaString') colors = colors.map(rgbaStr);
  else if (format === 'float') colors = colors.map(rgb2float);
  return colors;
}
function colorMellow(c, zero1 = .3, factorLum = .5) {
  hsl = colorHSL(c, true);
  let res = colorFromHue(hsl.h, zero1, hsl.l * factorLum);
  return res;
}
function colorMix(c1, c2, percent = 50) {
  return pSBC(percent / 100, colorHex(c1), colorHex(c2), true);
  let o1 = colorRGB(c1, true); let rgbA = [o1.r, o1.g, o1.b];
  let o2 = colorRGB(c2, true); let rgbB = [o2.r, o2.g, o2.b];
  amountToMix = percent / 100;
  var r = colorChannelMixer(rgbA[0], rgbB[0], amountToMix);
  var g = colorChannelMixer(rgbA[1], rgbB[1], amountToMix);
  var b = colorChannelMixer(rgbA[2], rgbB[2], amountToMix);
  return "rgb(" + r + "," + g + "," + b + ")";
}
function colorMixer(rgbA, rgbB, amountToMix) {
  var r = colorChannelMixer(rgbA[0], rgbB[0], amountToMix);
  var g = colorChannelMixer(rgbA[1], rgbB[1], amountToMix);
  var b = colorChannelMixer(rgbA[2], rgbB[2], amountToMix);
  return "rgb(" + r + "," + g + "," + b + ")";
}
function colorNameToHexString(str) {
  var ctx = document.createElement('canvas').getContext('2d');
  ctx.fillStyle = str;
  return ctx.fillStyle;
}
function colorNameToHslaString(str) {
  let hex = colorNameToHexString(str);
  let rgb = hexToRgb(hex);
  let hsv = rgbToHsv(rgb.r, rgb.g, rgb.b);
  let hsl = hsvToHsl(hsv.h, hsv.s, hsv.v);
  hsla = hslToHslaString(hsl.h, hsl.s, hsl.l, 1);
  return hsla;
}
function colorNameToRgb(str) {
  let hex = colorNameToHexString(str);
  let rgb = hexToRgb(hex);
  return rgb;
}
function colorPalBlend(c1, c2) {
  let res = [];
  for (let frac = 0.1; frac <= 0.9; frac += 0.1) {
    let c = pSBC(frac, c1, c2, true);
    res.push(c);
  }
  return res;
}
function colorPalette(color, type = 'shade') {
  color = colorFrom(color);
  return colorShades(color);
}
function colorPaletteFromImage(img) {
  if (nundef(ColorThiefObject)) ColorThiefObject = new ColorThief();
  let palette0 = ColorThiefObject.getPalette(img);
  let palette = [];
  for (const pal of palette0) {
    let color = colorFrom(pal);
    palette.push(color);
  }
  return palette;
}
function colorPaletteFromUrl(path) {
  let img = mCreateFrom(`<img src='${path}' />`);
  let pal = colorPaletteFromImage(img);
  return pal;
}
function colorPalSet(chStart, nHues = 2, { ch2, lum = 50, sat = 100, lumSatMode = 1, blendMode = 1, a } = {}) {
  let h1 = chStart;
  let h2 = ch2;
  if (!isNumber(chStart)) {
    let hsl = colorHSL(chStart);
    h1 = hsl.h;
    lum = hsl.l;
    sat = hsl.s;
  }
  if (ch2 !== undefined && !isNumber(ch2)) {
    h2 = colorHue(ch2);
  }
  let palettes = [];
  let hueDiff = Math.floor(360 / nHues);
  let pal;
  for (let i = 0; i < nHues; i++) {
    if (h2 !== undefined) {
      pal = colorPalette(h1, { ch2: h2, lum: lum, sat: sat, a: a });
    } else {
      pal = colorPalette(h1, { ch2: undefined, lum: lum, sat: sat, a: a });
    }
    palettes.push(pal);
    h1 += hueDiff;
  }
  return palettes;
}
function colorPalShade(color) {
  let res = [];
  for (let frac = -0.8; frac <= 0.8; frac += 0.2) {
    let c = pSBC(frac, color, undefined, true);
    res.push(c);
  }
  return res;
}
function colorPalShadeX(color, n) {
  let res = [];
  let step = 1.6 / (n - 1);
  for (let frac = -0.8; frac <= 0.8; frac += step) {
    let c = pSBC(frac, color, undefined, true);
    res.push(c);
  }
  return res;
}
function colorPrepper(val) {
  return `<span style="color:${ColorDict[val].c}">${ColorDict[val][G.language].toUpperCase()}</span>`;
}
function colorR(cAny) {
  let rgb = colorRGB(cAny, true);
  return rgb.r;
}
function colorRGB(cAny, asObject = false) {
  let res = colorFrom(cAny);
  let srgb = res;
  if (res[0] == '#') {
    srgb = pSBC(0, res, 'c');
  }
  let n = allNumbers(srgb);
  if (asObject) {
    return { r: n[0], g: n[1], b: n[2], a: n.length > 3 ? n[3] : 1 };
  } else {
    return srgb;
  }
}
function colorRGBArrToHSLObject(rgbArr) {
  var r1 = Number(rgbArr[0]) / 255,
    g1 = Number(rgbArr[1]) / 255,
    b1 = Number(rgbArr[2]) / 255;
  var maxColor = Math.max(r1, g1, b1),
    minColor = Math.min(r1, g1, b1);
  var L = (maxColor + minColor) / 2,
    s = 0,
    H = 0;
  if (maxColor != minColor) {
    if (L < 0.5) {
      s = (maxColor - minColor) / (maxColor + minColor);
    } else {
      s = (maxColor - minColor) / (2.0 - maxColor - minColor);
    }
    if (r1 == maxColor) {
      H = (g1 - b1) / (maxColor - minColor);
    } else if (g1 == maxColor) {
      H = 2.0 + (b1 - r1) / (maxColor - minColor);
    } else {
      H = 4.0 + (r1 - g1) / (maxColor - minColor);
    }
  }
  L = L * 100;
  s = s * 100;
  H = H * 60;
  if (H < 0) {
    H += 360;
  }
  return { h: H, s: s, l: L };
}
function colorRGBArrToString(r, g, b) {
  return 'rgb(' + r + ',' + g + ',' + b + ')';
}
function colorSat(cAny) {
  let hsl = colorHSL(cAny, true);
  return hsl.s;
}
function colorsFromBFA(bg, fg, alpha) {
  if (fg == 'contrast') {
    if (bg != 'inherit') bg = colorFrom(bg, alpha);
    fg = colorIdealText(bg);
  } else if (bg == 'contrast') {
    fg = colorFrom(fg);
    bg = colorIdealText(fg);
  } else {
    if (isdef(bg) && bg != 'inherit') bg = colorFrom(bg, alpha);
    if (isdef(fg) && fg != 'inherit') fg = colorFrom(fg);
  }
  return [bg, fg];
}
function colorShade(plusMinus1, color, log = true) {
  let c = colorFrom(color);
  return pSBC(plusMinus1, c, undefined, !log);
}
function colorShades(color) {
  let res = [];
  for (let frac = -0.8; frac <= 0.8; frac += 0.2) {
    let c = pSBC(frac, color, undefined, true);
    res.push(c);
  }
  return res;
}
function colorSystem() {
  simpleColors(randomColor());
}
function colorToFillStyle(c) {
  var ctx = document.createElement('canvas').getContext('2d');
  ctx.fillStyle = c;
  return ctx.fillStyle;
}
function colorTrans(cAny, alpha = 0.5) {
  return colorFrom(cAny, alpha);
}
function colorTransPalette(color = '#000000') {
  let res = [];
  for (const alpha of [.0, .1, .2, .3, .4, .5, .6, .7, .8, .9, 1]) res.push(colorTrans(color, alpha));
  return res;
}
function colorWheel(contrastTo, n) {
  let hc = colorHue(contrastTo);
  let wheel = [];
  let start = hc;
  let inc = Math.round(360 / (n + 1));
  start += inc;
  for (let i = 0; i < n; i++) {
    wheel.push(start % 360);
    start += inc;
  }
  return wheel.map(x => colorHSLBuild(x));
}
function combine(combiner, f, g) {
  if (typeof f != 'function') f = x => f;
  if (typeof g != 'function') g = x => g;
  return combiner(f, g);
}
function comp_(...arr) {
  return arr.join('_');
}
function comp_1(id) {
  return stringBefore(id, '_');
}
function comp_2(id) {
  return stringBefore(stringAfter(id, '_'), '_');
}
function comp_last(id) {
  return stringAfterLast(id, '_');
}
function compactObjectString(o) {
  let s = '';
  for (const k in o) {
    if (isSimple(o[k]) && !isComplexColor(o[k])) {
      if (isDict(o[k])) { error('!!!!!!!!!!!!!!!!isDict', o[k]); }
      s += k + ':' + o[k] + ' ';
    }
  }
  return s;
}
function compare(expected, actual) {
  let array1 = expected.slice()
  let array2 = actual.slice()
  return array1.length === array2.length && array1.sort().every(function (value, index) { return value === array2.sort()[index] });
}
function complete_cell(board, r, c) {
  let used = [...get_row(board, r), ...get_column(board, c), ...get_square(board, square_coordinates[r][c])]
  let possibilities = []
  for (let p = 1; p <= 9; p++) {
    if (!used.includes(p)) {
      possibilities.push(p)
    }
  }
  if (possibilities.length == 1) {
    board[r][c] = possibilities[0]
    return true
  } else {
    board[r][c] = possibilities
    return false
  }
}
function completelyRemoveServerObjectFromRsg(oid, R) {
  aushaengen(oid, R);
  R.deleteObject(oid);
}
function complexCompare(obj1, obj2) {
  const obj1Keys = Object.keys(obj1);
  const obj2Keys = Object.keys(obj2);
  if (obj1Keys.length !== obj2Keys.length) {
    return false;
  }
  for (let objKey of obj1Keys) {
    if (obj1[objKey] !== obj2[objKey]) {
      if (typeof obj1[objKey] == "object" && typeof obj2[objKey] == "object") {
        if (!isEqual(obj1[objKey], obj2[objKey])) {
          return false;
        }
      }
      else {
        return false;
      }
    }
  }
  return true;
}
function complus(...arr) {
  return arr.join('+');
}
function complus1(id) {
  return stringBefore(id, '+');
}
function complus2(id) {
  return stringBefore(stringAfter(id, '+'), '+');
}
function compluslast(id) {
  return stringAfterLast(id, '+');
}
function component(width, height, color, x, y, type) {
  this.type = type;
  this.score = 0;
  this.width = width;
  this.height = height;
  this.speedX = 0;
  this.speedY = 0;
  this.x = x;
  this.y = y;
  this.gravity = 0;
  this.gravitySpeed = 0;
  this.draw = function () {
    ctx = myGameArea.context;
    if (this.type == 'text') {
      ctx.font = this.width + ' ' + this.height;
      ctx.fillStyle = color;
      ctx.fillText(this.text, this.x, this.y);
    } else {
      ctx.fillStyle = color;
      ctx.fillRect(this.x, this.y, this.width, this.height);
    }
  };
  this.newPos = function () {
    this.gravitySpeed += this.gravity;
    this.x += this.speedX;
    this.y += this.speedY + this.gravitySpeed;
    this.hitBottom();
  };
  this.hitBottom = function () {
    var rockbottom = myGameArea.canvas.height - this.height;
    if (this.y > rockbottom) {
      this.y = rockbottom;
      this.gravitySpeed = 0;
    }
  };
  this.crashWith = function (otherobj) {
    var myleft = this.x;
    var myright = this.x + this.width;
    var mytop = this.y;
    var mybottom = this.y + this.height;
    var otherleft = otherobj.x;
    var otherright = otherobj.x + otherobj.width;
    var othertop = otherobj.y;
    var otherbottom = otherobj.y + otherobj.height;
    var crash = true;
    if (mybottom < othertop || mytop > otherbottom || myright < otherleft || myleft > otherright) {
      crash = false;
    }
    return crash;
  };
}
function compose(itop, ichild, x, y) {
  mPosAbs()
}
function composeFleetingMessage() {
  let lst = inputs;
  let msg = lst.map(x => x.letter).join(',');
  let edecl = lst.length > 1 ? 's ' : ' ';
  let ddecl = lst.length > 1 ? 'den' : 'die';
  let s = (currentLanguage == 'E' ? 'Type the letter' + edecl : 'Tippe ' + ddecl + ' Buchstaben ');
  return s + msg;
}
function compute_elo_ranking(players, game) {
  players = sortBy(players, 'score');
  let buckets = {};
  for (const pl of players) {
    let sc = pl.score;
    if (nundef(buckets[sc])) buckets[sc] = [];
    buckets[sc].push(pl.name);
  }
  let nBuckets = get_keys(buckets).length;
  let elopart = 2 / (nBuckets - 1);
  let val = -1;
  for (const b in buckets) {
    for (const name of buckets[b]) {
      let elo = get_elo(name, game);
      set_elo(name, game, elo + val);
      console.log('user', name, 'with score', b, 'gets', val, 'added to elo!');
    }
    val += elopart;
  }
}
function compute_hidden(plname) {
  let [fen, uplayer] = [Z.fen, Z.uplayer];
  let pl = fen.players[plname];
  let hidden;
  if (isdef(fen.winners)) hidden = false;
  else if (Z.role == 'spectator') hidden = plname != uplayer;
  else if (Z.mode == 'hotseat') hidden = (pl.playmode == 'bot' || plname != uplayer);
  else hidden = plname != Z.uname;
  return hidden;
}
function computeClosure(symlist) {
  let keys = {};
  for (const k in CODE.di) { for (const k1 in CODE.di[k]) keys[k1] = CODE.di[k][k1]; }
  CODE.all = keys;
  CODE.keylist = Object.keys(keys)
  let inter = intersection(Object.keys(keys), Object.keys(window));
  let done = {};
  let tbd = valf(symlist, ['_start']);
  let MAX = 1007, i = 0;
  let alltext = '';
  while (!isEmpty(tbd)) {
    if (++i > MAX) break;
    let sym = tbd[0];
    let o = CODE.all[sym];
    if (nundef(o)) o = getObjectFromWindow(sym);
    if (o.type == 'var' && !o.name.startsWith('d') && o.name == o.name.toLowerCase()) { tbd.shift(); continue; }
    if (o.type != 'func') { tbd.shift(); lookupSet(done, [o.type, sym], o); continue; }
    let olive = window[sym];
    if (nundef(olive)) { tbd.shift(); lookupSet(done, [o.type, sym], o); continue; }
    let text = olive.toString();
    if (!isEmpty(text)) alltext += text + '\r\n';
    let words = toWords(text, true);
    words = words.filter(x => text.includes(' ' + x));
    for (const w of words) {
      if (nundef(done[w]) && w != sym && isdef(CODE.all[w])) addIf(tbd, w);
    }
    tbd.shift();
    lookupSet(done, [o.type, sym], o);
  }
  let tres = '';
  for (const k of ['const', 'var', 'cla', 'func']) {
    console.log('done', k, done[k])
    let o = done[k]; if (nundef(o)) continue;
    let klist = get_keys(o);
    if (k == 'func') klist = sortCaseInsensitive(klist);
    for (const k1 of klist) {
      let code = CODE.justcode[k1];
      if (!isEmptyOrWhiteSpace(code)) tres += code + '\r\n';
    }
  }
}
function computeColor(c) { return (c == 'random') ? randomColor() : c; }
function computeColorX(c) {
  let res = c;
  if (isList(c)) return chooseRandom(c);
  else if (isString(c) && startsWith(c, 'rand')) {
    res = randomColor();
    let spec = c.substring(4);
    if (isdef(window['color' + spec])) {
      console.log('YES!');
      res = window['color' + spec](res);
    }
  }
  return res;
}
function computePresentedKeys(o, isTableObject) {
  let optin = isTableObject ? S.settings.table.optin : S.settings.player.optin;
  if (optin) return intersection(Object.keys(o), optin);
  let optout;
  if (S.settings.useExtendedOptout) {
    let keys = [];
    optout = S.settings.extendedOptout;
    for (const k in o) { if (optout[k]) continue; keys.push(k); }
    return keys;
  }
  optout = isTableObject ? S.settings.table.optout : S.settings.player.optout;
  for (const k in o) { if (optout[k]) continue; keys.push(k); }
  return keys;
}
function consExpand(o, keys, indent = 0) {
  console.log('.'.repeat(indent), o);
  for (const k in o) {
    if (!keys.includes(k)) continue;
    let oNew = o[k];
    console.log('.'.repeat(indent), k + ':')
    if (isList(oNew)) {
      for (const el of oNew) {
        consExpand(el, keys, indent + 2);
      }
    } else if (isDict(oNew)) {
      consExpand(oNew, keys, indent + 2);
    }
  }
}
function consout() {
  if (isTraceOn) console.log(...arguments);
}
function consOutput() { console.log(...arguments); }
function consoutt() {
  if (isTraceOn) console.log(...arguments, getFunctionsNameThatCalledThisFunction());
}
function contacts_2handleResult(result) {
  let d = mBy('dContacts');
  mCenterCenterFlex(d);
  d.innerHTML = JSON.parse(result).message;
}
function containedInAny(el, ll) {
  for (const lst of ll) {
    if (lst.includes(el)) return true;
  }
  return false;
}
function contains(s, sSub) { return s.toLowerCase().includes(sSub.toLowerCase()); }
function containsAll(arr, lst) {
  for (const el of lst) {
    if (!arr.includes(el)) return false;
  }
  return true;
}
function containsAny(arr, lst) {
  for (const x of lst) {
    if (arr.includes(x)) {
      return true;
    }
  }
  return false;
}
function containsColorWord(s) {
  let colors = ['old', 'blond', 'red', 'blue', 'green', 'purple', 'black', 'brown', 'white', 'grey', 'gray', 'yellow', 'orange'];
  for (const c of colors) {
    if (s.toLowerCase().includes(c)) return false;
  }
  return true;
}
function containsSet(arr, lst) {
  return containsAll(arr, lst);
}
function contentHallo(n, r) { return isdef(n.children) ? null : n.uid == '_2' ? 'HALLO' : 'WELT'; }
function contentNoParentContent(x, R) {
  if (nundef(x.children)) return x.uid; else return null;
}
function contentNoParentContentRootExtralong(x, R) {
  if (nundef(x.children)) return x.uid;
  else if (x.uid == R.tree.uid) return 'hallo das ist ein super super super langer string let it go - unclutch!';
  else return null;
}
function contentNoRootContent(x, R) {
  if (x.uid == R.tree.uid) return null; else return x.uid;
}
function contentRootExtralong(x, R) {
  if (x.uid == R.tree.uid) return 'hallo das ist ein besonders langer string!!!';
  else return x.uid;
}
function contentToElement(cont, styles, keepInLine = true) {
  let elem = cont;
  if (isString(cont)) {
    if (cont[0] === '<') {
      elem = createElementFromHtml(cont);
    } else {
      elem = mText(elem);
    }
  }
  if (keepInLine) styles['white-space'] = 'nowrap';
  mStyleX(elem, styles);
  return elem;
}
function continue_after_error() {
  dError.innerHTML = ''; if (isdef(DA.callback)) { DA.callback(); delete (DA.callback); }
}
function continue_game_ending_process() {
  let game = Session.cur_game;
  let winners = Session.winners;
  if (nundef(Session.cur_table.scoring_complete)) {
    console.log('scoring...')
    decrease_handicap_if_winstreak(winners, game);
    Session.cur_table.scoring_complete = true;
  }
  to_server({ tid: Session.cur_tid, uname: Session.cur_user }, 'seen');
}
function convert_from_row(row) {
  for (const k in row) {
    let val = row[k];
    if (isNumber(val)) row[k] = Number(val);
    if (isString(val) && val[0] == '{') { row[k] = JSON.parse(val); }
    if (val == 'null') row[k] = null;
    if (k == 'players' && isString(row[k])) row[k] = val.split(',');
  }
}
function convert_from_server(obj) {
  if (isdef(obj.table)) convert_from_row(obj.table);
  if (isdef(obj.playerdata)) {
    for (const row of obj.playerdata) {
      convert_from_row(row);
    }
  }
  if (isdef(obj.moves)) {
    for (const row of obj.moves) {
      convert_from_row(row);
    }
  }
}
function convert_to_range(x, min1, max1, min2, max2) {
  return (x - min1) * ((max2 - min2) / (max1 - min1)) + min2;
}
function convertGermanUhrzeitToNumbers(w) {
  console.log('...', w)
  let parts = multiSplit(w, ' :');
  console.log('...parts', parts)
  let res = [];
  for (const p of parts) {
    let p1 = p.trim().toLowerCase();
    if (isNumber(p1)) res.push(Number(p1));
    else if (isdef(germanNumbers[p1])) res.push(germanNumbers[p1]);
  }
  return res;
}
function convertTimesAndNumbersToWords(w) {
  if (w.includes(':')) {
    let h = stringBefore(w, ':');
    let m = stringAfter(w, ':');
    let hn = Number(h);
    let mn = Number(m);
    let xlist = allIntegers(w);
    if (xlist.length == 2) {
      if (xlist[1] == 0) xlist = [xlist[0]];
      xlist = xlist.map(n => n.toString());
      let res1 = xlist.join('');
      w = res1;
    }
  }
  if (isNumber(w)) {
    let res = toWordsSpeechS(w);
    return res;
  }
  return w;
}
function convertTimeStringToNumbers(ts) {
  return allIntegers(ts);
}
function convertToColor(x) {
  let res = SPEC.color[x];
  if (!res) {
    res = SPEC.color[x] = randomColor();
  }
  return res;
}
function convertToGraphElements(g1, house) {
  let vertices = house.rooms.map(x => Items[x]);
  let doors = [];
  for (const v of vertices) {
    v.center = getCenter(v.rect);
    v.center.x += v.rect.l - house.rect.l;
    v.center.y += v.rect.t - house.rect.t;
    g1.addNode(v, v.center);
    doors = union(doors, v.doors);
  }
  let centers = g1.getNodes().map(x => x.data('center'));
  g1.storePositions('prest', centers);
  let edges = doors.map(x => Items[x]).filter(x => x.rooms.length == 2);
  for (const e of edges) {
    if (e.rooms.length < 2) continue;
    e.source = e.rooms[0];
    e.target = e.rooms[1];
    g1.addEdge(e.source, e.target, e);
  }
}
function convertToGraphElements_dep(g1, house) {
  let elements = { nodes: [], edges: [] };
  let vertices = house.rooms.map(x => Items[x]);
  let doors = [];
  for (const v of vertices) {
    v.center = getCenter(v.rect);
    elements.nodes.push({ data: v, position: v.center });
    doors = union(doors, v.doors);
  }
  let edges = doors.map(x => Items[x]).filter(x => x.rooms.length == 2);
  for (const e of edges) {
    if (e.rooms.length < 2) continue;
    e.source = e.rooms[0];
    e.target = e.rooms[1];
    elements.edges.push({ data: e });
  }
  return elements;
}
function convertToLabel(x) {
  let res = lookup(SPEC, ['label', x]);
  return res ? res : x;
}
function convertToList(x) {
  if (isList(x)) return x;
  if (isString(x) && x != '') return [x];
  return [];
}
function convertToMS(p) {
  let res = undefined;
  if (isMS(p)) {
    res = p;
  } else if (isEvent(p)) {
    p = p.target;
    res = findParentWithId(p);
    res = MS.byId[res.id];
  } else if (isString(p)) {
    res = MS.byId[p];
  } else {
  }
  return res;
}
function convertToRgba(cAny, alpha = 1) {
  let a = alpha >= 0 && alpha <= 1 ? alpha : alpha / 100;
  testHelpers('type is', typeof cAny);
  if (isString(cAny)) {
    testHelpers('convertToRgba is a String', cAny);
    if (cAny[0] == '#') {
      let rgbObj = hexToRgb(cAny);
      return `rgba(${rgbObj.r},${rgbObj.g},${rgbObj.b},${a})`;
    } else if (startsWith(cAny, 'hsl') || startsWith(cAny, 'rgb')) {
      testHelpers('hsla or rgba color!', cAny);
      return cAny;
    } else if (cAny == 'transparent') {
      return cAny;
    } else {
      testHelpers('should be a color name!!!', cAny);
      let rgbObj = colorNameToRgb(cAny);
      return `rgba(${rgbObj.r},${rgbObj.g},${rgbObj.b},${a})`;
    }
  } else if (Array.isArray(cAny)) {
    if (cAny.length == 3) {
      let r = cAny[0];
      let g = cAny[1];
      let b = cAny[2];
      return `rgba(${r},${g},${b},${a})`;
    } else {
      testHelpers('convertToRgba: ERROR! NOT A COLOR:', cAny);
      return randomColor(100, 70, a);
    }
  }
}
function convertUmlaute(w) {
  w = replaceAll(w, 'ue', 'ü');
  w = replaceAll(w, 'ae', 'ä');
  w = replaceAll(w, 'oe', 'ö');
  w = replaceAll(w, 'UE', 'Ü');
  w = replaceAll(w, 'AE', 'Ä');
  w = replaceAll(w, 'OE', 'Ö');
  w = replaceAll(w, 'ß', 'ss');
  return w;
}
function copyKeys(ofrom, oto, except = {}, only = null) {
  let keys = isdef(only) ? only : Object.keys(ofrom);
  for (const k of keys) {
    if (isdef(except[k])) continue;
    oto[k] = ofrom[k];
  }
  return oto;
}
function copyLinesFromTo(lines, iStart, iEnd, trimStart, trimEnd) {
  let block = isdef(trimStart) ? stringAfter(lines[iStart], '/*') : lines[iStart];
  iStart += 1;
  while (iStart < iEnd) {
    block += '\n' + lines[iStart];
    iStart += 1;
  }
  if (isdef(trimEnd)) block = stringBefore(block, '*/');
  return block.trim();
}
function copySimpleProps(ofrom, oto = {}) { for (const k in ofrom) { if (isLiteral(k)) oto[k] = ofrom[k]; } return oto; }
function correct_handsorting(hand, plname) {
  let pl = Z.fen.players[plname];
  let [cs, pls, locs] = [Clientdata.handsorting, pl.handsorting, localStorage.getItem('handsorting')];
  let s = cs ?? pls ?? locs ?? Config.games[Z.game].defaulthandsorting;
  hand = sort_cards(hand, s == 'suit', 'CDSH', true, Z.func.rankstr);
  return hand;
}
function correctBlanks() {
  let wrong = getWrongWords();
  if (nundef(TOList)) TOList = {};
  Selected.feedbackUI = wrong.map(x => iDiv(x));
  failPictureGoal();
  let t1 = setTimeout(removeMarkers, 1000);
  let t2 = setTimeout(() => wrong.map(x => { correctWordInput(x); animate(iDiv(x), 'komisch', 1300); }), 1000);
  TOList.correction = [t1, t2];
  return 2500;
}
function correctFuncName(specType) {
  switch (specType) {
    case 'list': specType = 'liste'; break;
    case 'dict': specType = 'dicti'; break;
    case undefined: specType = 'panel'; break;
  }
  return specType;
}
function correctNumbersInString(s, dec) {
  let parts = s.split('_');
  for (let i = 0; i < parts.length; i++) {
    let p = parts[i];
    if (isNumber(p)) {
      let n = Number(p);
      n -= dec;
      parts[i] = '' + n;
    }
  }
  let res = parts.join('_');
  return res;
}
function correctPolys(polys, approx = 10) {
  let clusters = [];
  for (const p of polys) {
    for (const pt of p) {
      let found = false;
      for (const cl of clusters) {
        for (const v of cl) {
          let dx = Math.abs(v.x - pt.x);
          let dy = Math.abs(v.y - pt.y);
          if (dx < approx && dy < approx) {
            cl.push(pt);
            found = true;
            break;
          }
        }
        if (found) break;
      }
      if (!found) {
        clusters.push([pt]);
      }
    }
  }
  let vertices = [];
  for (const cl of clusters) {
    let sumx = 0;
    let sumy = 0;
    let len = cl.length;
    for (const pt of cl) {
      sumx += pt.x;
      sumy += pt.y;
    }
    vertices.push({ x: Math.round(sumx / len), y: Math.round(sumy / len) });
  }
  for (const p of polys) {
    for (const pt of p) {
      let found = false;
      for (const v of vertices) {
        let dx = Math.abs(v.x - pt.x);
        let dy = Math.abs(v.y - pt.y);
        if (dx < approx && dy < approx) {
          if (dx != 0 || dy != 0) {
            pt.x = v.x;
            pt.y = v.y;
          }
          found = true;
        }
        if (found) break;
      }
      if (!found) {
        error('point not found in vertices!!! ' + pt.x + ' ' + pt.y);
      }
    }
  }
  return vertices;
}
function correctWordInput(winp) { winp.charInputs.map(x => refillCharInput(x, x.letter)); }
function countAll(s, scount) {
  let letters = toLetters(scount);
  function counter(total, ch) { if (letters.includes(ch)) return total + 1; else return total; }
  let res = [...s].reduce(counter, 0);
  return res;
}
function countIndent(s, ntab = 2) {
  let i = 0;
  let inc;
  while (!isEmpty(s)) {
    if (startsWith(s, '\t')) { i += ntab; inc = ntab; }
    else if (s[0] == ' ') { i += 1; inc = 1; }
    else break;
    s = s.slice(1);
  }
  return i;
}
function countLetters(s, letter) {
  let n = 0;
  for (const ch of s) {
    if (ch == letter) n++;
  }
  return n;
}
function cPortrait(dParent, styles = {}, id) {
  if (nundef(styles.h)) styles.h = Card.sz;
  if (nundef(styles.w)) styles.w = styles.h * .7;
  return cBlank(dParent, styles, id);
}
function create_agent(where, o = {}) {
  let res;
  if (is_map(where)) {
    res = L.marker(valf(o.center, where.options.center)).addTo(where);
  } else {
    res = mDiv(where, o);
  }
  return res;
}
function create_ai_move(data) {
  let newscore = Math.min(Session.winning_score, data.score + 1);
  console.log('AI score is', newscore);
  let newstate = data.state;
  let newdata = {
    tid: data.tid,
    player_status: newscore >= Session.winning_score ? 'done' : 'joined',
    score: newscore,
    state: newstate,
    uname: data.uname
  };
  return newdata;
}
function create_bluff_input1(dParent, arr, units = 1, sz, index) {
  let d = mDiv(dParent, { gap: 5, w: units * sz * 1.35 }); mCenterFlex(d);
  for (const a of arr) {
    let da = mDiv(d, { align: 'center', wmin: 20, padding: 4, cursor: 'pointer', rounding: 4, bg: units == 1 ? '#e4914b' : 'sienna', fg: 'contrast' }, null, a == 'T' ? '10' : a);
    da.onclick = () => input_to_anzeige1(a, index);
  }
  return d;
}
function create_branch(b, angle, len, color) {
  let root = C.root;
  let x = b.p2.x + Math.cos(angle) * len;
  let y = b.p2.y - Math.sin(angle) * len;
  let age = b.age + 1;
  let o = {
    done: false,
    p1: b.p2,
    p2: { x: x, y: y },
    x: x,
    y: y,
    t: 'branch',
    age: age,
    angle: angle,
    len: len,
    thickness: b.thickness * root.dthickness,
    color: color,
  };
  b.done = true;
  return o;
}
function create_card_assets_c52() {
  let ranknames = { A: 'Ace', K: 'King', T: '10', J: 'Jack', Q: 'Queen' };
  let suitnames = { S: 'Spades', H: 'Hearts', C: 'Clubs', D: 'Diamonds' };
  let rankstr = '23456789TJQKA';
  let suitstr = 'SHDC';
  sz = 100;
  let di = {};
  for (const r of toLetters(rankstr)) {
    for (const s of toLetters(suitstr)) {
      let k = r + s;
      let info = di[k] = { key: k, val: 1, irank: rankstr.indexOf(r), isuit: suitstr.indexOf(s), rank: r, suit: s, color: RED, c52key: 'card_' + r + s, w: sz * .7, h: sz, sz: sz, ov: .25, friendly: `${isNumber(r) ? r : ranknames[r]} of ${suitnames[s]}`, short: `${r}${s}` };
      info.isort = info.isuit * 13 + info.irank;
    }
  }
  C52Cards = di;
  return di;
}
function create_div(where, o = {}) {
  let res;
  if (is_map(where)) {
    let icon = L.divIcon({ className: 'my-div-icon' });
    var greenIcon = L.icon({
      iconUrl: 'leaf-green.png',
      shadowUrl: 'leaf-shadow.png',
      iconSize: [38, 95],
      shadowSize: [50, 64],
      iconAnchor: [22, 94],
      shadowAnchor: [4, 62],
      popupAnchor: [-3, -76]
    });
    res = L.marker(o.center, { icon: greenIcon }).addTo(map);
  } else {
    res = mDiv(where, o);
  }
  return res;
}
function create_div_marker(map, html, center, sz, offset) {
  let res = L.marker(center, { icon: L.divIcon({ iconAnchor: offset, className: `custom-div-icon ${sz}`, html: html }) }).addTo(map);
  return res;
}
function create_fa(map, key, center, styles = {}) {
  addKeys({ fz: 30 }, styles);
  let d = mCreate('i');
  mStyle(d, styles);
  mClass(d, `fa fa-${key}`);
  let dp = mCreate('div');
  mAppend(dp, d);
  let html = dp.innerHTML;
  let offset = [styles.fz / 2, styles.fz / 3];
  let className = `custom-div-icon`;
  let res = L.marker(center, { icon: L.divIcon({ iconAnchor: offset, className: className, html: html }) }).addTo(map);
  return res;
}
function create_fen_deck(cardtype, num_decks = 1, num_jokers = 0) {
  let arr = get_keys(C52Cards).map(x => x + cardtype);
  let newarr = [];
  while (num_decks > 0) { newarr = newarr.concat(arr); num_decks--; }
  while (num_jokers > 0) { newarr.push('*H' + cardtype); num_jokers--; }
  return newarr;
}
function create_flower() {
}
function create_leaf(b, root) {
  let o = {
    done: true,
    p: b.p2,
    x: b.p2.x,
    y: b.p2.y,
    t: 'leaf',
    age: b.age + 1,
    len: b.len * root.dlen,
    angle: b.angle,
    thickness: 20,
    color: 'lawngreen',
  };
  b.done = true;
  return o;
}
function create_map(o = {}) {
  addKeys({ maxBounds: [[-89.98155760646617, -180], [89.99346179538875, 180]], key: 'osm', center: Geo.places.tuerkenschanzpark, zoom: 17, id: 'map' }, o);
  let info = Geo.layerInfo[o.key];
  o.layers = [isdef(info) ? L.tileLayer(info.url, info.options) : L.tileLayer('')];
  let map = L.map(o.id, o);
  return map;
}
function create_marker(text) {
  let d = mCreate('div');
  d.innerHTML = text;
  mStyle(d, { position: 'fixed', fz: 50 });
  document.body.appendChild(d);
  Markers.push(d);
  return d;
}
function create_menu(dParent, dir = 'h') {
  let d;
  if (dir == 'h') {
    d = dMenu = mDiv(dParent, { w: '100%', display: 'flex' });
  } else {
    d = dMenu = mDiv(dParent, { padding: 10, gap: 10, h: '100%', display: 'flex', dir: dir });
  }
  mToolbar(['grow', 'clear'], handle_command, d, {}, { vmargin: 5 });
  mTogglebar({ jitter: false }, flag_toggle, { bg: 'lightgreen' }, { bg: '#eee' }, d);
  mLinebreak(dTable, 10);
}
function create_new_table(user, game) {
  user = valf(user, Session.cur_user);
  game = valf(game, Session.cur_game);
  let opt = extract_game_options();
  let t = {};
  t.friendly = generate_friendly_table_name();
  t.game = Session.cur_game;
  t.host = user;
  t.players = opt.players;
  t.fen = GSpotitMulti.start_fen(t.players);
  t.status = 'created';
  t.player_init = '';
  DA.next = get_games;
  to_server(t, 'create_table');
}
function create_new_table_and_join_all(user, game) {
  Session.cut_tid = Session.cur_table = null;
  let t = {};
  t.friendly = generate_friendly_table_name();
  t.game = 'gSpotit';
  t.host = Session.cur_user;
  t.players = valf(lookup(Session, ['game_options', 'players']), get_def_players_for_user(Session.cur_user));
  t.fen = 'noneed';
  t.options = valf(lookup(Session, ['game_options', 'game']), {});
  t.status = 'started';
  t.host_status = 'joined';
  t.player_status = 'joined';
  t.player_init = {};
  to_server(t, 'create_table_and_start');
}
function create_nodes(r, pad, dmin) {
  let [xstart, ystart, w, h] = [r.x + pad, r.y + pad, r.w, r.h];
  let [x, y] = [xstart, ystart];
  let items = []; let [rows, cols, row, col] = [0, 0, 0, 0];
  while (y < h - dmin) {
    while (x < w - dmin) {
      let item = { w: 5, h: 5, iy: row, ix: col, bg: 'blue', position: 'absolute', x: x, y: y };
      x += dmin;
      items.push(item);
      cols++; col++;
    }
    rows++; row++; col = 0;
    x = xstart;
    y += dmin;
  }
  return items;
}
async function create_pic_dict(l, syms) {
  let edict = await route_path_text(`../base/assets/words/${l}dict.txt`);
  console.log('dict', edict);
  let lang = l.toUpperCase();
  let words = l == 'e' ? edict.split('\r\n') : edict.split('\n');
  console.log('words', words);
  console.log('syms', syms);
  let wdi = {};
  for (const w of words) {
    let w1 = w.trim().toLowerCase();
    if (isEmpty(w1)) continue;
    wdi[w1] = true;
  }
  let slist = [];
  for (const skey in syms) {
    let e = syms[skey][lang];
    if (nundef(e)) continue;
    e = e.trim().toLowerCase();
    slist.push({ key: skey, w: e });
  }
  slist_sorted = sortBy(slist, 'w');
  console.log('slist sorted', slist_sorted);
  console.log(wdi);
  let edi = {};
  for (const o of slist_sorted) {
    let [e, skey] = [o.w, o.key];
    if (e in wdi) edi[e] = skey;
    else console.log('word', e, 'from syms not in dict!!!');
  }
  console.log('result', edi, Object.keys(edi).length);
  return edi;
  return;
  for (const skey in syms) {
    let e = syms[skey][lang];
    if (nundef(e)) continue;
    e = e.trim().toLowerCase();
    console.assert(isdef(e) && e == e.toLowerCase(), 'word in syms not lowercasse:' + e);
    if (e in wdi) edi[e] = skey;
    else console.log('word', e, 'from syms not in dict!!!');
  }
  console.log('result', edi, Object.keys(edi).length);
  return edi;
}
async function create_pic_dicts(list = ['e', 'd', 'f', 's']) {
  let syms = await route_path_yaml_dict('../base/assets/allSyms.yaml');
  for (const l of list) {
    let di = await create_pic_dict(l, syms);
    downloadAsYaml(di, l + 'picdict');
  }
  loader_off();
}
function create_random_players(n = 1) {
  let colors = rWheel(n);
  let res = [{ name: 'mimi', playmode: 'human', color: colors[0] }];
  let names = rChoose(MyNames, n - 1);
  if (!isList(names)) names = [names];
  for (let i = 1; i < n; i++) {
    let pl = { name: names[i - 1], playmode: 'bot', color: colors[i], strategy: 'random' };
    res.push(pl);
  }
  return res;
}
function create_score_table() {
  let t = Session.cur_table;
  let fen = t.fen;
  let dParent = mBy('dIntro');
  let d = mDiv(dParent, { margin: 'auto', w: 300, bg: 'red' });
  html = `<div style='text-align:center;margin-top:200px'>
  <table id='customers'><tr><th>player</th><th>score</th></tr>
  `;
  let plparts = fen.split(',');
  for (const pl of plparts) {
    html += `<tr><td>${stringBefore(pl, ':')}</td><td>${stringAfter(pl, ':')}</td></tr>`
  }
  html += '</table></div>';
  d.innerHTML = html;
}
function create_set_card(fen, dParent, card_styles) {
  let myinfo = info_from_fen(fen);
  let info = { shape: 'circle', color: BLUE, num: 1, shading: 'solid', background: 'white', text: 'none' };
  copyKeys(myinfo, info);
  let card = draw_set_card(dParent, info, card_styles);
  card.fen = fen;
  return card;
}
function create_sym(map, key, center, sz, styles) {
  let d1 = mSym(key, null, styles);
  let html = d1.innerHTML;
  let [xoff, yoff] = sz == 'large' ? [136, 150] : sz == 'medium' ? [36, 40] : [16, 18];
  let offset = [xoff, yoff];
  return create_div_marker(map, html, center, sz, offset);
}
function create_table(options, players) {
  Session.cur_tid = Session.cur_table = Selected = null;
  let gname = Session.cur_game;
  let t = {};
  t.friendly = generate_friendly_table_name();
  t.game = Session.cur_game;
  t.host = Session.cur_user;
  t.turn = 'none';
  t.players = valf(players, valf(lookup(Session, ['game_options', 'players']), get_def_players_for_user(Session.cur_user)));
  t.options = valf(options, lookup(Session, ['game_options', 'game']));
  t.pl_options = get_player_options(t.players, gname);
  t.status = 'started';
  t.host_status = 'joined';
  t.player_status = 'joined';
  t.player_init = DB.games[gname].game_type == 'turn' ? null : {};
  if (gname == 'gPreinno') { t.fen = inno_setup(t.players); }
  else if (gname == 'gAristo') { t.fen = ari_setup(t.players); }
  return t;
}
function create_toolbar(map) {
  let d = map._controlContainer;
  console.log('control container', d);
  dMap = mDiv(d, { position: 'absolute', top: 0, left: 50, w: '100%', h: '100%' });
  dMap.style.zIndex = 12000;
  let toolbar = mDiv(dMap, { hmargin: 10, padding: 10, cursor: 'pointer' }, null, null, 'top'); mFlexWrap(toolbar);
  return toolbar;
}
function createAccountContent(userdata) {
  DA.imageChanged = DA.colorChanged = false;
  return `
  <div id="dAccount" style="max-width=500px; margin-top:10px; display:flex; animation: appear1 1s ease;justify-content:center; align-content:center">
    <div id="error">some text</div>
    <div style='text-align:center'>
      <form id="myform" autocomplete="off" style='text-align:center;background:${userdata.color}'>
        <span id='img_dd_instruction' style="font-size:11px;">drag and drop an image to change</span><br>
        <img id="imgPreview" onload='addColorPicker("${userdata.color}");' src='${get_image_path(userdata)}' ondragover="handle_drag_and_drop(event)" ondrop="handle_drag_and_drop(event)" ondragleave="handle_drag_and_drop(event)"
          style="height:200px;margin:10px;" />
        <input id='iUsername' type="text" name="motto" placeholder='motto' value="${userdata.motto}" autofocus
          onkeydown="if (event.keyCode === 13){event.preventDefault();collect_data(event);}" />
        <br />
        <input id='save_settings_button' type="button" value="Submit" onclick="collect_data(event)" ><br>
      </form>
  </div></div>
  `;
}
function createAccountContent1(userdata) {
  var d = mBy("inner_left_panel");
  clearElement(d);
  let d1 = mDiv(d, { w: '100%', matop: 10, animation: 'rotateIntoView 1s ease' });
  mCenterFlex(d1);
  let d2 = mDiv(d1, {}, 'error', 'hallo das ist ein error');
  let d3 = mDiv(d1, { align: 'center', bg: 'yellow' });
  let form = mCreate('form', { align: 'center', bg: 'red' }, 'myform');
  form.id = 'myform';
  form.setAttribute('autocomplete', 'off');
  form.onsubmit = (ev) => { ev.preventDefault(); collect_data(); }
  mAppend(d3, form);
  let sp1 = mSpan(form, { fz: 11 }, null, 'drag and drop an image to change');
  form.innerHTML += '<br>';
  DA.imageChanged = DA.colorChanged = false;
  let img = mImg(userdata.imagePath + '?=' + Date.now(), form, { h: 200, margin: 10 });
  img.onload = () => {
    let inp = mCreate('input');
    mAppend(form, inp);
    inp.setAttribute('type', 'text');
    inp.setAttribute('placeholder', 'username');
    inp.setAttribute('name', 'username');
    inp.setAttribute('id', 'iUsername');
    inp.setAttribute('value', userdata.username);
    inp.setAttribute('autofocus', true);
    inp.onkeydown = ev => {
      if (ev.keyCode === 13) {
        ev.preventDefault();
        console.log('WTF!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
        collect_data(ev);
      }
    };
    form.innerHTML += '<br />';
    let picker = mColorPickerBehavior(U.settings.userColor, img, form,
      (a) => { console.log('new color is', a); DA.newColor = a; DA.colorChanged = true; },
      { w: 322, h: 45, bg: 'green', rounding: 6, margin: 'auto', align: 'center' });
    form.innerHTML += `<input id='save_account_button' type="button" value="Submit" onclick="collect_data(event)" ><br>`;
  };
  img.id = 'imgPreview';
  img.setAttribute('allowDrop', true);
  img.ondragover = img.ondrop = img.ondragleave = handle_drag_and_drop;
}
function createAreas(dGrid, areaNames, prefix, shadeAreaBackgrounds = false, showAreaNames = true) {
  console.log('creating areas', areaNames)
  let SPEC = {}; SPEC.areas = { T: 'dTrick', H: 'dHuman', A: 'dAI' };
  let palette = getTransPalette9();
  let ipal = 1;
  let result = [];
  for (const k in SPEC.areas) {
    let areaName = SPEC.areas[k];
    let dCell = mDiv(dGrid, { h: '100%', w: '100%', bg: 'random', 'grid-area': k, });
    if (shadeAreaBackgrounds) { dCell.style.backgroundColor = palette[ipal]; ipal = (ipal + 1) % palette.length; }
    if (showAreaNames) {
      dCell = mTitledDiv(areaName, dCell, { bg: 'green', }, { h: '100%', w: '100%', bg: 'yellow', }, areaName)
    } else { dCell.id = areaName; }
    result.push({ name: areaName, div: dCell });
  }
  return result;
  for (const areaName of areaNames) {
    let d1 = document.createElement('div');
    let id = (isdef(prefix) ? prefix + '.' : '') + areaName;
    d1.id = id;
    d1.style.gridArea = areaName;
    mStyleX(d1, { bg: 'random' });
    d1.innerHTML = 'hallo'
    if (shadeAreaBackgrounds) { d1.style.backgroundColor = colorPalette[ipal]; ipal = (ipal + 1) % colorPalette.length; }
    if (showAreaNames) { d1.innerHTML = makeAreaNameDomel(areaName); }
    dGrid.appendChild(d1);
  }
}
function createAreas_dep(d, areaNames, prefix, shadeAreaBackgrounds = false, showAreaNames = true) {
  console.log('creating areas', areaNames)
  let palette = getTransPalette9();
  let ipal = 1;
  for (const areaName of areaNames) {
    let d1 = document.createElement('div');
    let id = (isdef(prefix) ? prefix + '.' : '') + areaName;
    d1.id = id;
    d1.style.gridArea = areaName;
    mStyleX(d1, { bg: 'random' });
    d1.innerHTML = 'hallo'
    if (shadeAreaBackgrounds) { d1.style.backgroundColor = colorPalette[ipal]; ipal = (ipal + 1) % colorPalette.length; }
    if (showAreaNames) { d1.innerHTML = makeAreaNameDomel(areaName); }
    d.appendChild(d1);
  }
}
function createArtificialSpecForBoardMemberIfNeeded(oid, o, R) {
  let key = R.getR(oid);
  if (!isEmpty(key)) {
    key = key[0];
  }
  else {
    key = getUID();
    R.lastSpec[key] = { cond: { obj_type: o.obj_type }, type: 'info' };
    R.addR(oid, key);
    R.updateR(key);
  }
  return key;
}
function createBoard(nui, R, area) {
  console.log('nui', nui, 'R', R, 'area', area);
  let [oid, boardType, r0, c0] = detectBoardOidAndType(nui.oid, nui.boardType, R);
  nui.oid = oid;
  nui.boardType = boardType;
  let baseIndex = { r0: r0, c0: c0 };
  nui.bi = window[nui.boardType](R.getO(nui.oid), R, baseIndex);
  generalGrid(nui, R, area);
}
function createCardZone(id, label, labelPos = 'top', hCard = 110) {
  let gap = 2;
  let dZone = mDiv(dTable, { padding: 10, align: 'center', rounding: 20 });
  dZone.id = 'zone_' + id;
  let dLabel;
  if (isdef(label) && labelPos == 'top') {
    dLabel = mText(label, dZone, { display: 'inline-block', maleft: -10 });
  }
  let dData = mDiv(dZone, { h: hCard + gap, align: 'center' });
  dData.id = 'data_' + id;
  if (isdef(label) && labelPos == 'bottom') {
    dLabel = mText(label, dZone, { display: 'inline-block', maleft: -10 });
  }
  let b = getBounds(dZone);
  return { div: dZone, dData: dData, dLabel: dLabel, label: label, labelPos: labelPos, w: b.width, h: b.height, center: actualCenter(dZone) };
}
function createcircle(posx, posy, radius, stroke, fill, filter) {
  var circle = document.createElementNS(svgns, "circle");
  circle.setAttributeNS(null, "id", "c" + circles);
  circle.setAttributeNS(null, "cx", posx);
  circle.setAttributeNS(null, "cy", posy);
  circle.setAttributeNS(null, "r", radius);
  circle.setAttributeNS(null, "stroke-width", stroke);
  circle.setAttributeNS(null, "fill", fill);
  circle.setAttributeNS(null, "filter", filter);
  circle.setAttributeNS(null, "data-posx", posx);
  svg.appendChild(circle);
}
function createClassByName(name, ...a) { var c = eval(name); return new c(...a); }
function createClientBoardNew(o, s) {
  let [layout, wCell, hCell, wGap, hGap] = [s.boardLayout, s.dxCenter, s.dyCenter, s.wGap, s.hGap];
  let dInner = o.dInner;
  mCenterCenterFlex(dInner);
  let [wArea, hArea] = [Math.min(o.wOuter, s.wFieldArea), Math.min(o.hOuter, s.hFieldArea)];
  let dArea = o.dArea = mDiv(dInner, { matop: s.boardMarginTop, maleft: s.boardMarginLeft, w: wArea, h: hArea }, 'dFieldArea');
  mCenterCenterFlex(dArea);
  let [w, h] = [wArea, hArea];
  let isHexLayout = startsWith(layout, 'hex');
  let hline = isHexLayout ? hCell * .75 : hCell;
  let rows, cols;
  if (isdef(s.rows) && layout != 'circle') rows = s.rows; else rows = Math.floor(h / hline);
  if (isdef(s.cols) && layout != 'circle') cols = s.cols; else cols = Math.floor(w / wCell)
  let [centers, wTotal, hTotal] = getCentersFromRowsCols(layout, rows, cols, wCell, hCell);
  let dCells = mDiv(dArea, { w: wTotal, h: hTotal, position: 'relative' });
  mStyleX(dArea, { w: Math.max(wArea, wTotal), h: Math.max(hArea, hTotal) });
  let fields;
  if (isdef(centers)) fields = createFieldsFromCenters(dCells, o, centers, wCell, hCell, wGap, hGap, wTotal, hTotal);
  let bg = valf(s.fieldColor, colorTrans('black', .3));
  fields.map(x => mStyleX(iDiv(x), { bg: bg }));
  if (s.boardRotation != 0) {
    dCells.style.transform = `rotate(${s.boardRotation}deg)`;
  }
}
function createCollapsibles(dv, lst, collapsed) {
  let pageContent = mBy('pageContent');
  for (const item of lst) {
    let path = item;
    let info = dv[path];
    let coll = genCollapsible(path, dv[path]);
    dv[path].collapsible = coll;
    DOC_UIS[coll.id] = dv[path];
    let signatureLinkContainer = mDiv(mBy('menu'));
    signatureLinkContainer.id = getLinkContainerId(coll.id);
    let pathContainer = mDiv(pageContent);
    pathContainer.id = info.idPathContainer;
    let pathTitle = mDiv(pathContainer);
    pathTitle.innerHTML = info.filename;
    pathTitle.classList.add('pathTitle');
    let pathContent = mDiv(pathContainer);
    if (!isEmpty(info.topComment)) addComment(info.topComment, pathContent);
    pathContent.classList.add('comments');
    for (const signature of dv[path].funcIndex) {
      let entry = dv[path].funcDict[signature];
      let comments = entry.comments;
      let l = genLink(signature, signatureLinkContainer);
      let functionName = stringBefore(signature, '(').trim();
      l.id = 'a_' + entry.index + '@' + entry.path;
      entry.idLink = l.id;
      entry.idDiv = 'div' + entry.index + '@' + entry.path;
      let fDiv0 = mDiv(pathContent);
      fDiv0.id = entry.idDiv;
      let fDiv = mCreate('p');
      fDiv0.appendChild(fDiv);
      let fSignature = mDiv(fDiv);
      fSignature.innerHTML = signature;
      fSignature.classList.add('signature');
      let fComments = mDiv(fDiv);
      if (!isEmpty(comments)) addComment(comments, fComments);
      fComments.classList.add('comments');
    }
    hide(pathContainer);
  }
  let coll = document.getElementsByClassName("collapsible");
  for (let i = 0; i < coll.length; i++) {
    coll[i].addEventListener("click", toggleCollapsible);
  }
  if (collapsed) collapseAll();
}
function createContactsContent(myusers, msgs) {
  let mydata = uiGetContactStylesAndStart();
  mydata += uiGetContacts(myusers, msgs);
  return mydata;
}
function createContainers(list, dArea, styles) {
  let i = 0;
  let containers = [];
  let defStyles = { w: 150, h: 200, bg: 'random', rounding: 12, display: 'inline-block', margin: 12 };
  addKeys(defStyles, styles);
  for (const cat of list) {
    let cont = mTitledDiv(cat, dArea, styles, {}, 'c' + i);
    mStyleX(cont, { h: '100%' });
    i += 1;
    containers.push({ label: cat, div: cont });
  }
  return containers;
}
function createDeck() { return DeckA(); }
function createDeckWithJokers() { return _createDeck({ hasJokers: true }); }
function createDiv(id, className, left, top, width, height) {
  var div = document.createElement("div");
  div.id = id;
  div.className = className;
  div.style.left = String(left) + "px";
  div.style.top = String(top) + "px";
  div.style.width = String(width) + "px";
  div.style.height = String(height) + "px";
  return (div);
}
async function createDocs(collapsed = true) {
  let dv = DOC_vault = await createVault();
  DOC_UIS = {};
  let pkeys = Object.keys(dv).map(x => dv[x].filename);
  pkeys.sort();
  let lst = dict2list(dv);
  let sortedlst = lst.sort(fieldSorter(['filename']));
  i = 0;
  for (const item of sortedlst) {
    let id = item.id;
    let x = dv[item.id];
    x.index = i;
    x.idLink = 'a_path_' + i;
    x.idPathContainer = 'div_path_' + i;
    i += 1;
  }
  for (const p in dv) {
    let funcDict = dv[p].funcDict;
    let keys = Object.keys(funcDict);
    keys.sort();
    dv[p].funcIndex = keys;
    for (let i = 0; i < keys.length; i++) { funcDict[keys[i]].index = i; }
  }
  DOC_dvIndex = sortedlst.map(x => x.id);
  createCollapsibles(dv, DOC_dvIndex, collapsed);
  setCurrentPath('assetHelpers.js');
}
function createDragClone(ev, items, onRelease) {
  DragSourceItems = items;
  DragSourceItem = findItemFromEvent(items, ev);
  let elem = DragSource = iDiv(DragSourceItem);
  var clone = DragElem = elem.cloneNode(true);
  clone.id = DragElem.id + '_' + clone;
  DragSource = elem;
  mAppend(document.body, clone);
  mClass(clone, 'dragelem');
  mStyleX(clone, { left: ev.clientX - ev.offsetX, top: ev.clientY - ev.offsetY });
  clone.drag = { offsetX: ev.offsetX, offsetY: ev.offsetY };
  document.body.onmousemove = onMovingCloneAround;
  document.body.onmouseup = onRelease;
}
function createDraggable(id, className, left, top, width, text) {
  var div = document.createElement("div");
  div.innerHTML = String(text);
  div.id = id;
  div.className = className;
  div.style.left = String(left) + "px";
  div.style.top = String(top) + "px";
  div.style.width = String(width) + "px";
  div.draggable = true;
  ondragstart = "drag(event)";
  return (div);
}
function createDragLetters() {
  fz = 60; let word = Goal.label.toUpperCase();
  let dp = createLetterInputsX(word, dTable, { bg: 'silver', display: 'inline-block', fz: fz, w: fz, h: fz * 1.1, margin: 4 });
  scrambleInputs(dp);
  let letters = Array.from(dp.children);
  for (let i = 0; i < letters.length; i++) {
    let l = letters[i]
    l.onmousedown = onMouseDownOnLetter;
    mClass(l, 'draggable');
    l.id = 'letter' + i;
  }
  return letters;
}
function createDragWords(items, handler) {
  let keys = items.map(x => x.key);
  shuffle(keys);
  G.showLabels = true;
  titems = myShowLabels(null, undefined, { rows: 1, showLabels: true }, keys);
  titems.map(x => iDiv(x).style.cursor = 'pointer');
  titems.map(x => iDiv(x).onmousedown = (ev) => {
    createDragClone(ev, titems, dropAndEval);
  });
  return titems;
}
function createDropInputs() {
  let fz = 120; let word = Goal.label.toUpperCase(); let wlen = word.length;
  let dpEmpty = createLetterInputsX(word, dTable, { pabottom: 5, bg: 'grey', display: 'inline-block', fz: fz, w: fz, h: fz * 1.1, margin: 4 });
  let inputs = blankInputs(dpEmpty, range(0, wlen - 1), false);
  DropZones = [];
  for (let i = 0; i < inputs.length; i++) {
    let l = iDiv(inputs[i]);
    l.onmousedown = onMouseDownOnLetter;
    l.onclick = l.innerHTML = '_';
    mClass(l, 'dropzone');
    l.id = 'input' + i;
    DropZones.push(l);
  }
  return inputs;
}
function createDroppable(id, className, left, top, width, height) {
  var div = document.createElement("div");
  div.id = id;
  div.className = className;
  div.style.left = String(left) + "px";
  div.style.top = String(top) + "px";
  div.style.width = String(width) + "px";
  div.style.height = String(height) + "px";
  div.ondrop = "drop(event)";
  div.ondragover = "allowDrop(event)";
  return (div);
}
function createElementFromHTML(htmlString) {
  var div = document.createElement('div');
  div.innerHTML = htmlString.trim();
  return div.firstChild;
}
function createElementFromHtml(s) { return createElementFromHTML(s); }
function createEmoji({ key, w, h, unit = 'px', fg, bg, padding, cat, parent, border, rounding }) {
  let emoji = emojiChars[emojiKeys[key]];
  console.log('emoji', emoji);
  if (nundef(key)) key = getRandomKey(emojiChars);
  let ch = emoji.hexcode;
  console.log('ch', ch)
  let family = 'emoOpen';
  let text = emoji.emoji;
  if (isdef(parent) && isString(parent)) parent = mBy(parent);
  console.log(parent);
  console.log(typeof text, text)
  cat = isdef(cat) ? cat : isdef(parent) ? getTypeOf(parent) == 'div' ? 'd' : 'g' : isdef(cat) ? cat : 'd';
  let domel;
  if (cat == 'd') {
    let d = document.createElement('div');
    d.style.textAlign = 'center';
    if (isdef(bg)) {
      console.log('bg', bg);
      d.style.backgroundColor = bg;
    }
    d.innerHTML = text;
    domel = d;
    if (isdef(padding)) d.style.padding = padding + unit;
    d.style.display = 'inline-block';
    d.style.height = h + 2 * padding + unit;
    d.style.width = d.style.height;
    if (isdef(border)) d.style.border = border;
    if (isdef(rounding)) d.style.borderRadius = rounding + unit;
  } else {
  }
  domel.key = key;
  if (parent) parent.appendChild(domel);
  return domel;
}
function createFakeState() {
  let settings = DB.games.gPerlen2;
  let fakeServer = new FakeServerClass(Socket, PerlenDict, settings, null);
  let state = fakeServer.State;
  return { settings: settings, state: state, perlenDict: PerlenDict };
}
function createFields(s, b, scale) {
  let dCells = b.dCells = mDiv(b.dOuter, { matop: s.boardMarginTop * scale, maleft: s.boardMarginLeft * scale, w: b.wNeeded, h: b.hNeeded, position: 'relative' }, 'dFieldArea');
  let [horDist, vertDist, szField] = [b.dxCenter, b.dyCenter, s.szField * scale];
  let fields = b.fields = [], i = 0, dx = horDist / 2, dy = vertDist / 2;
  let bg = s.fieldColor;
  for (const p of b.centers) {
    let left = p.x - szField / 2;
    let top = p.y - szField / 2;
    let dItem = mDiv(dCells, { position: 'absolute', left: left, top: top, display: 'inline', w: szField, h: szField, rounding: '50%', bg: bg });
    mCenterCenterFlex(dItem)
    let f = { div: dItem, index: i, center: p, isField: true }; i += 1;
    fields.push(f);
  }
  if (s.boardRotation != 0) { dCells.style.transform = `rotate(${s.boardRotation}deg)`; }
}
function createFields_dep(s, b, scale) {
  let dCells = b.dCells = mDiv(b.dOuter, { matop: s.boardMarginTop * scale, maleft: s.boardMarginLeft * scale, w: b.wNeeded, h: b.hNeeded, position: 'relative' });
  let [wCell, hCell, wGap, hGap] = [b.dxCenter, b.dyCenter, s.wGap * scale, s.hGap * scale];
  let fields = b.fields = [], i = 0, dx = wCell / 2, dy = hCell / 2;
  let bg = s.fieldColor;
  for (const p of b.centers) {
    let left = p.x - dx + wGap / 2;
    let top = p.y - dy + hGap / 2;
    let dItem = mDiv(dCells, { position: 'absolute', left: left, top: top, display: 'inline', w: wCell - wGap, h: hCell - hGap, rounding: '50%', bg: bg });
    mCenterCenterFlex(dItem)
    let f = { div: dItem, index: i, center: p, isField: true }; i += 1;
    fields.push(f);
  }
  if (s.boardRotation != 0) { dCells.style.transform = `rotate(${s.boardRotation}deg)`; }
}
function createFilter(svg, posx, posy, sizex, sizey, type, data) {
  var svgns = "http://www.w3.org/2000/svg";
  var defs = document.createElementNS(svgns, "defs");
  svg.appendChild(defs);
  var filter = document.createElementNS(svgns, "filter");
  defs.appendChild(filter);
  filter.setAttribute("id", "filterBlur");
  filter.setAttribute("x", posx);
  filter.setAttribute("y", posy);
  filter.setAttribute("width", sizex);
  filter.setAttribute("height", sizey);
  for (z = 0; z < (data.length / 2); z++) {
    var filter = document.createElementNS(svgns, type[z]);
    filter.setAttributeNS(null, "in", "SourceGraphic");
    filter.setAttributeNS(null, data[2 * z], data[2 * z + 1]);
    document.getElementById("f" + circles).appendChild(filter);
  }
}
function createfilter1(posx, posy, sizex, sizey, type, data) {
  var svg = document.getElementById("canvas");
  var fs = document.getElementById("filters");
  var circles = 0;
  var svgns = "http://www.w3.org/2000/svg";
  var w = window.innerWidth;
  var filter = document.createElementNS(svgns, "filter");
  filter.setAttribute("id", "f" + circles);
  fs.appendChild(filter);
  for (z = 0; z < (data.length / 2); z++) {
    var filter = document.createElementNS(svgns, type[z]);
    filter.setAttributeNS(null, "in", "SourceGraphic");
    filter.setAttributeNS(null, data[2 * z], data[2 * z + 1]);
    document.getElementById("f" + circles).appendChild(filter);
  }
}
function createGamesContent(mygames, tables = {}) {
  let mydata = uiGetGamesStylesAndStart();
  mydata += uiGetGames(mygames, tables);
  return mydata;
}
function createGrid(areaName, idBoard, sBoard, sMemberPool, shape) {
  let board = makeBoard(idBoard, sBoard, areaName);
  board.structInfo = shape == 'hex' ? getHexGridInfo(sBoard.rows, sBoard.cols) : getQuadGridInfo(sBoard.rows, sBoard.cols);
  makeFields(sMemberPool, board, sBoard, shape);
  if (isdef(sBoard.corners)) makeCorners(sMemberPool, board, sBoard);
  if (isdef(sBoard.edges)) makeEdges(sMemberPool, board, sBoard);
  return board;
}
function createGridLayout(d, layout, collapseEmptySmallLetterAreas = false) {
  let s = '';
  let m = [];
  let maxNum = 0;
  let areaNames = [];
  for (const line of layout) {
    let letters = line.split(' ');
    let arr = [];
    for (const l of letters) {
      if (!isEmpty(l)) {
        addIf(areaNames, l);
        arr.push(l);
      }
    }
    m.push(arr);
    if (arr.length > maxNum) maxNum = arr.length;
  }
  for (const line of m) {
    let el = line[line.length - 1];
    while (line.length < maxNum) line.push(el);
    s += '"' + line.join(' ') + '" ';
  }
  d.style.gridTemplateAreas = s;
  if (collapseEmptySmallLetterAreas) { collapseSmallLetterAreas(m, d); }
  else fixedSizeGrid(m, d);
  return areaNames;
}
function createGridLayout_dep(d, layout) {
  let s = '';
  let m = [];
  let maxNum = 0;
  let areaNames = [];
  for (const line of layout) {
    let letters = line.split(' ');
    let arr = [];
    for (const l of letters) {
      if (!isEmpty(l)) {
        addIf(areaNames, l);
        arr.push(l);
      }
    }
    m.push(arr);
    if (arr.length > maxNum) maxNum = arr.length;
  }
  for (const line of m) {
    let el = line[line.length - 1];
    while (line.length < maxNum) line.push(el);
    s += '"' + line.join(' ') + '" ';
  }
  d.style.gridTemplateAreas = s;
  if (SPEC.collapseEmptySmallLetterAreas) { collapseSmallLetterAreas(m, d); }
  else fixedSizeGrid(m, d);
  return areaNames;
}
function createHandler(param, func) {
  return function (ev) {
    let id = evToId(ev);
    console.log(param, 'and', id);
    param.push(getOid(id));
    for (const oid of param) {
      getDefVisual(oid)[func]();
    }
  }
}
function createHexboard(rows = 3, cols = 3, a = 48) {
  let sq3 = Math.sqrt(3);
  let wp = a / 4, hp = a / 4, h = sq3 * a / 2;
  let [xoff, dx, yoff, dy] = [h + wp / 2, 2 * h, hp / 2, a / 2];
  let ys = 2 + 3 * rows;
  let xs = cols;
  let x = xoff, y = yoff;
  let pts = [];
  let infos = [];
  let idx = 0;
  let yEven = true;
  for (let i = 0; i < ys; i++) {
    let tcolOffset = yEven ? 1 : 0;
    let isCenterRow = i >= 2 && ((i - 2) % 3) == 0;
    for (let j = 0; j < xs + (1 - tcolOffset); j++) {
      let pt = { x: x, y: y };
      pts.push(pt);
      infos.push({ index: idx, tcol: tcolOffset + 2 * j, trow: i, x: x, y: y, pt: pt, isCenterRow: isCenterRow, isHexCenter: isCenterRow, isCenterCol: j % 2 == 1 });
      x += dx;
      idx += 1;
    }
    yEven = !yEven;
    y += dy; x = i % 2 ? xoff : wp / 2;
  }
  let byrc = {};
  for (const i of infos) {
    lookupSet(byrc, [i.trow, i.tcol], i.index);
  }
  console.log('byrc', byrc)
  let byxy = {};
  let adjList = [];
  let di = {};
  for (const info of infos) {
    let [r, c] = [info.trow, info.tcol];
    info.nodes = [
      lookup(byrc, [r - 2, c]),
      lookup(byrc, [r - 1, c + 1]),
      lookup(byrc, [r + 1, c + 1]),
      lookup(byrc, [r + 2, c]),
      lookup(byrc, [r + 1, c - 1]),
      lookup(byrc, [r + 1, c - 1]),
    ];
    for (let i = 0; i < 6; i++) {
      let n1 = info.nodes[i];
      if (n1 == null) continue;
      let n2 = info.nodes[(i + 1 % 6)];
      if (n2 == null) continue;
      if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
      lookupSet(di, [n1, n2], true);
      adjList.push([n1, n2]);
    }
    info.neighbors = [
      lookup(byrc, [r - 3, c + 1]),
      lookup(byrc, [r, c + 2]),
      lookup(byrc, [r + 3, c + 1]),
      lookup(byrc, [r + 3, c - 1]),
      lookup(byrc, [r, c - 2]),
      lookup(byrc, [r - 3, c - 1]),
    ];
  }
  return { items: infos, adjList: adjList, rows: rows, cols: cols, dx: dx, dy: dy, sz: a }
}
function createHexboard1(rows = 3, cols = 3, a = 48) {
  let sq3 = Math.sqrt(3);
  let wp = a / 4, hp = a / 4, h = sq3 * a / 2;
  let [xoff, dx, yoff, dy] = [h + wp / 2, 2 * h, hp / 2, a / 2];
  return createHexboardHelper(rows, cols, dy, dx, yoff, xoff, hp, wp, a);
}
function createHexboard2(rows = 3, cols = 3, a = 48) {
  let sq3 = Math.sqrt(3);
  let wp = a / 4, hp = a / 4, h = sq3 * a / 2;
  let [xoff, dx, yoff, dy] = [h + wp / 2, 2 * h, hp / 2, a / 2];
  return createHexboardHelper(rows, cols, dy, dx, yoff, xoff, hp, wp, a);
}
function createHexboardHelper(rows, cols, dy, dx, yoff, xoff, hp, wp, a) {
  let ys = 2 + 3 * rows;
  let xs = cols;
  let x = xoff, y = yoff;
  let pts = [];
  let infos = [];
  let idx = 0;
  let yEven = true;
  for (let i = 0; i < ys; i++) {
    let tcolOffset = yEven ? 1 : 0;
    let isCenterRow = i >= 2 && ((i - 2) % 3) == 0;
    for (let j = 0; j < xs + (1 - tcolOffset); j++) {
      let pt = { x: x, y: y };
      pts.push(pt);
      infos.push({ index: idx, tcol: tcolOffset + 2 * j, trow: i, x: x, y: y, pt: pt, isCenterRow: isCenterRow, isHexCenter: isCenterRow, isCenterCol: j % 2 == 1 });
      x += dx;
      idx += 1;
    }
    yEven = !yEven;
    y += dy; x = i % 2 ? xoff : wp / 2;
  }
  let byrc = {};
  for (const i of infos) {
    lookupSet(byrc, [i.trow, i.tcol], i.index);
  }
  let byxy = {};
  let adjList = [];
  let di = {};
  for (const info of infos) {
    let [r, c] = [info.trow, info.tcol];
    info.nodes = [
      lookup(byrc, [r - 2, c]),
      lookup(byrc, [r - 1, c + 1]),
      lookup(byrc, [r + 1, c + 1]),
      lookup(byrc, [r + 2, c]),
      lookup(byrc, [r + 1, c - 1]),
      lookup(byrc, [r + 1, c - 1]),
    ];
    for (let i = 0; i < 6; i++) {
      let n1 = info.nodes[i];
      if (n1 == null) continue;
      let n2 = info.nodes[(i + 1 % 6)];
      if (n2 == null) continue;
      if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
      lookupSet(di, [n1, n2], true);
      adjList.push([n1, n2]);
    }
    info.neighbors = [
      lookup(byrc, [r - 3, c + 1]),
      lookup(byrc, [r, c + 2]),
      lookup(byrc, [r + 3, c + 1]),
      lookup(byrc, [r + 3, c - 1]),
      lookup(byrc, [r, c - 2]),
      lookup(byrc, [r - 3, c - 1]),
    ];
  }
  return { items: infos, adjList: adjList, rows: rows, cols: cols, dx: dx, dy: dy, sz: a, byrc: byrc }
}
function createImage(filename, styles) {
  let img = mCreateFrom(`<img src='../rechnung/images/${filename}'>`);
  if (isdef(styles.w)) { img.setAttribute('width', styles.w); }
  if (isdef(styles.h)) { img.setAttribute('height', styles.h); }
  mStyle(img, styles);
  return img;
}
function createImg(id, className, zIndex, left, top, width, height, src) {
  var img = document.createElement("img");
  img.id = id;
  img.className = className;
  img.style.zIndex = zIndex;
  img.style.left = String(left) + "px";
  img.style.top = String(top) + "px";
  img.style.width = String(width) + "px";
  img.style.height = String(height) + "px";
  img.src = src;
  return (img);
}
function createIndependentUi(n, area) {
  if (nundef(n.type)) { n.type = inferType(n); }
  R.registerNode(n);
  decodeParams(n, R, {});
  calcIdUiParent(n, R, area);
  let ui;
  if (nundef(RCREATE[n.type])) ui = mDefault(n, area, R);
  else ui = RCREATE[n.type](n, R, area);
  if (nundef(n.uiType)) n.uiType = 'd';
  if (n.uiType == 'NONE') return ui;
  if (n.uiType != 'childOfBoardElement') {
    if (isBoard(n.uid, R)) { delete n.cssParams.padding; }
    applyCssStyles(n.uiType == 'h' ? mBy(n.uidStyle) : ui, n.cssParams);
  }
  if (!isEmpty(n.stdParams)) {
    switch (n.stdParams.show) {
      case 'if_content': if (!n.content) hide(ui); break;
      case 'hidden': hide(ui); break;
      default: break;
    }
  }
  R.setUid(n, ui);
  return ui;
}
function createKeyIndex(di, prop) {
  let res = {};
  for (const k in di) {
    res[di[k][prop]] = k;
  }
  return res;
}
function createLabel_dep(n1, ui, R) {
  let g = ui;
  if (n1.content) {
    let pa = n1.params;
    let transPa = { txt: n1.content };
    let fill = pa.fg;
    if (isdef(fill)) { transPa.fill = fill; }
    else if (isdef(pa.bg)) { transPa.fill = colorIdealText(pa.bg); }
    else {
      transPa.fill = 'white';
    }
    let font = pa.font; if (isdef(font)) transPa.font = font;
    let gt = n1.label = new gText(g);
    gt.text(transPa);
  }
}
function createLayout(dParent, l) {
  console.log('*** createLayout ***', dParent, l);
  let d = mBy(dParent);
  let areaNames = createGridLayout(d, l);
  console.log(areaNames, d)
  createAreas(d, areaNames, dParent);
}
function createLetterInputs(s, dParent, style, idForContainerDiv, colorWhiteSpaceChars = true, preserveColorsBetweenWhiteSpace = true) {
  let d = mDiv(dParent);
  if (isdef(idForContainerDiv)) d.id = idForContainerDiv;
  inputs = [];
  let whiteStyle = jsCopy(style);
  if (!colorWhiteSpaceChars) {
    if (isdef(whiteStyle.fg)) delete whiteStyle.fg;
    if (isdef(whiteStyle.bg)) delete whiteStyle.bg;
    if (isdef(whiteStyle.border)) delete whiteStyle.border;
  }
  let fg, fgOrig, bg, bgOrig;
  fgOrig = style.fg;
  bgOrig = style.bg;
  if (isVariableColor(fgOrig) && isdef(style.fg)) { fg = computeColorX(fgOrig); style.fg = fg; }
  if (isVariableColor(bgOrig) && isdef(style.bg)) { bg = computeColorX(bgOrig); style.bg = bg; }
  for (let i = 0; i < s.length; i++) {
    let d1 = mCreate('div');
    mAppend(d, d1);
    d1.innerHTML = s[i];
    let white = isWhiteSpace2(s[i]);
    if (white) {
      if (isVariableColor(fgOrig) && isdef(style.fg)) { fg = computeColorX(fgOrig); style.fg = fg; }
      if (isVariableColor(bgOrig) && isdef(style.bg)) { bg = computeColorX(bgOrig); style.bg = bg; }
    }
    mStyleX(d1, white ? whiteStyle : style);
  }
  return d;
}
function createLetterInputsX(s, dParent, style, idForContainerDiv) {
  let d = mDiv(dParent);
  if (isdef(idForContainerDiv)) d.id = idForContainerDiv;
  inputs = [];
  for (let i = 0; i < s.length; i++) {
    let d1 = mDiv(d);
    d1.innerHTML = s[i];
    mStyle(d1, style);
  }
  return d;
}
function createLoginContent(userdata) {
  return `
  <div id="dAccount" style="max-width=500px; margin-top:10px; display:flex; animation: appear1 1s ease;justify-content:center; align-content:center">
    <div id="error">some text</div>
    <div style='text-align:center'>
      <form id="myform" autocomplete="off" style='text-align:center;background:${userdata.color}'>
        <img id="imgPreview" src='${get_image_path(userdata)}' style="height:200px;margin:10px;" />
        <input id='iUsername' type="text" name="username" placeholder='username' value="${userdata.name}" autofocus
          onkeydown="if (event.keyCode === 13){event.preventDefault();console.log('WTF!!!!!!!!!!!!!!!!!!!!!!!!!!!!');collect_data(event);}" />
        <br />
        <input id='save_settings_button' type="button" value="Submit" onclick="collect_data(event)" ><br>
      </form>
  </div></div>
  `;
}
function createLoginNewContent(myusers, msgs) {
  let mydata = uiGetLoginNewStylesAndStart();
  mydata += uiGetLoginNewList(myusers, msgs);
  return mydata;
}
function createMarker(markerId) {
  let divs = document.getElementsByClassName('feedbackMarker');
  let d;
  d = mCreate('div');
  d.innerHTML = MarkerText[markerId];
  mClass(d, 'feedbackMarker');
  document.body.appendChild(d);
  Markers.push(d);
  return d;
}
function createMarker_orig(markerId) {
  let divs = document.getElementsByClassName('feedbackMarker');
  let d;
  d = mCreate('div');
  d.innerHTML = MarkerText[markerId];
  mClass(d, 'feedbackMarker');
  document.body.appendChild(d);
  Markers.push(d);
  return d;
}
function createMenuUi(dParent) {
  clearElement(dParent);
  mCenterFlex(dParent);
  mAppend(dParent, createElementFromHTML(`<h1>Choose Game:</h1>`));
  mLinebreak(dParent);
  let dMenuItems = mDiv(dParent, { w: '90%', h: 600 });
  let games = jsCopy(U.avGames); if (!navigator.onLine) { removeInPlace(games, 'gSayPic'); }
  let items = [];
  let outerStyles = {
    display: 'inline-flex', 'flex-direction': 'column',
    'justify-content': 'center', 'align-items': 'center', 'vertical-align': 'top',
    wmin: 140, hmin: 110, margin: 8, rounding: 6
  };
  for (const g of games) {
    let item = { o: DB.games[g], id: g }; iRegister(item, g);
    item.bg = getColorDictColor(item.o.color);
    item.label = capitalize(item.o.friendly);
    item.info = Syms[item.o.logo];
    let d = makeItemDiv(item, {
      outerStyles: outerStyles, ifs: { bg: true },
      picStyles: { fz: 60 },
      showPic: true, showLabels: true, labelBottom: true, handler: onClickMenuItem
    });
    iAdd(item, { div: d });
    mAppend(dMenuItems, d);
    items.push(item);
  }
  if (nundef(G)) return;
  SelectedMenuKey = G.id;
  let selItem = Items[SelectedMenuKey];
  toggleItemSelection(selItem);
}
function createMenuUiNew(dParent, keys, clickMenuHandler, outerStyles = {}, picStyles = {}, labelStyles = {}, hTotal = 600) {
  clearElement(dParent);
  mCenterFlex(dParent);
  mAppend(dParent, createElementFromHTML(`<h1>Choose Game:</h1>`));
  mLinebreak(dParent);
  let dMenuItems = mDiv(dParent, { w: '90%', h: hTotal });
  let games = keys;
  if (!navigator.onLine) { removeInPlace(games, 'gSayPic'); }
  let items = [];
  let defaultOuterStyles = {
    display: 'inline-flex', 'flex-direction': 'column',
    'justify-content': 'center', 'align-items': 'center', 'vertical-align': 'top',
    wmin: hTotal / 4, hmin: hTotal / 6, margin: 8, rounding: 6
  };
  addKeys(defaultOuterStyles, outerStyles);
  let defaultPicStyles = { fz: hTotal / 10, 'line-height': hTotal / 10 + 'px' };
  addKeys(defaultPicStyles, picStyles);
  for (const g of games) {
    let item = { o: DB.games[g], id: g }; iRegister(item, g);
    item.bg = getColorDictColor(item.o.color);
    item.label = capitalize(item.o.friendly);
    item.info = Syms[item.o.logo];
    let d = makeItemDiv(item, {
      outerStyles: outerStyles, ifs: { bg: true },
      picStyles: picStyles,
      labelStyles: labelStyles,
      showPic: true, showLabels: true, labelBottom: true, handler: clickMenuHandler
    });
    iAdd(item, { div: d });
    mAppend(dMenuItems, d);
    items.push(item);
  }
  if (nundef(G)) return;
  SelectedMenuKey = G.id;
  let selItem = Items[SelectedMenuKey];
  toggleItemSelection(selItem);
}
function createMessageContent(messages, me, other) {
  let result = `<div id='messages_holder_parent' onclick='set_seen(event)' style='background:silver;height:680px;'>
  <div id='messages_holder' style='box-sizing:border-box;height:580px;padding:10px;margin-bottom:10px;overflow-y:auto;'>`;
  result += `start of chat with ${other.username} <img src="${other.imagePath}" style="margin-left:10px;display:inline;height:30px;"/><br><br>`;
  for (const m of messages) {
    if (m.sender == me.username) { result += message_right(m, me); } else { result += message_left(m, other); }
  }
  result += message_controls();
  return result;
}
function createMSTree(mobj) {
  let areas = mobj.elem.children;
  for (const ch of [...areas]) {
    if (!ch.id) { continue; }
    let msChild = makeDomArea(ch);
    if (ch.id == 'a_d_settings' || ch.id == 'a_d_main_menu') continue;
    createMSTree(msChild);
  }
}
function createMultiplayerGame() {
  _sendRoute('/restart', d1 => _newGame(game));
}
function createMultipleChoiceElements(correctAnswer, wrongAnswers, dParent, dFeedbackUI, styles) {
  if (nundef(Goal)) Goal = {};
  let choices = wrongAnswers; choices.push(correctAnswer);
  Goal.correctChoice = correctAnswer;
  if (isYesNo(choices)) {
    sortByDescending(choices, 'text');
  } else {
    shuffle(choices);
    if (coin()) shuffle(choices);
  }
  Goal.choices = choices;
  Goal.feedbackUI = dFeedbackUI;
  let idx = 0;
  for (const ch of choices) {
    ////'&frac57;', //'&frac12;', 
    let dButton = mButton(ch.text, onClickChoice, dParent, { wmin: 100, fz: 36, margin: 20, rounding: 4, vpadding: 4, hpadding: 10 }, ['toggleButtonClass']);
    dButton.id = 'bChoice_' + idx; idx += 1;
    if (ch.text == correctAnswer.text) {
      Goal.choice = ch.toString();
      Goal.buttonCorrect = dButton;
    }
  }
}
function createNode(sp, idParent, R) {
  let n = jsCopy(sp);
  n.idParent = idParent;
  let id = n.nid = getUid();
  n.fullPath = R.NODES[idParent].fullPath + '.' + id;
  return n;
}
function createNumberSequence(n, min, max, step, op = 'plus') {
  let fBuild = x => { return op == 'plus' ? (x + step) : op == 'minus' ? (x - step) : x; };
  if (op == 'minus') min += step * (n - 1);
  if (min >= (max - 10)) max = min + 10;
  let seq = getRandomNumberSequence(n, min, max, fBuild, lastPosition);
  lastPosition = seq[0];
  return seq;
}
function createPageDivsFullVisibleArea(above, tableStyles, below, defs = { bg: 'random', fg: 'contrast' }) {
  clearElement(dMain);
  let dRightSide = mDiv(dMain, { display: 'flex', 'flex-direction': 'column', 'flex-grow': 10 });
  let table = mDiv(dRightSide, {}, 'table');
  for (const k in above) {
    let name = 'd' + capitalize(k);
    let ltop = get3ColLine(table, name + 'Left', name, name + 'Right', mergeOverride(defs, above[k]));
  }
  let vals = Object.values(above);
  vals = vals.concat(Object.values(below));
  let sum = arrSum(vals, 'h');
  let sum1 = arrSum(vals, 'hmin');
  console.log('sum', sum, 'sum1', sum1);
  sum += sum1;
  let hTable = percentVh(100) - sum;
  let wTable = percentVw(100) - 20;
  if (nundef(tableStyles)) tableStyles = {};
  tableStyles = mergeOverride({ bg: 'dimgray', w: wTable, h: hTable, vpadding: 0, hpadding: 0 }, tableStyles);
  let ltable = get3ColLine(table, 'dTableLeft', 'dTable', 'dTableRight', tableStyles);
  ltable.id = 'lTable';
  mSize(dTable.parentNode, '100%', '100%');
  mSize(dTable, '100%', '100%');
  console.log('below', below);
  for (const k in below) {
    let name = 'd' + capitalize(k);
    let lbottom = get3ColLine(table, name + 'Left', name, name + 'Right', mergeOverride(defs, below[k]));
  }
  dFooter.innerHTML = 'HALLO';
  let rect = getRect(dTable);
  return rect;
}
function createPanelParentOfObjects(lst, n1, area, R) {
  if (nundef(n1.type)) n1.type = lst.length == 1 ? 'invisible' : 'panel';
  n1.content = null;
  n1.ui = createUi(n1, R, area);
}
function createPeeps() {
  const {
    rows,
    cols
  } = config
  const {
    naturalWidth: width,
    naturalHeight: height
  } = img
  const total = rows * cols
  const rectWidth = width / rows
  const rectHeight = height / cols
  for (let i = 0; i < total; i++) {
    allPeeps.push(new Peep({
      image: img,
      rect: [
        (i % rows) * rectWidth,
        (i / rows | 0) * rectHeight,
        rectWidth,
        rectHeight,
      ]
    }))
  }
}
function createPerle(perle, dParent, sz = 64, wf = 1.3, hf = 0.4, useNewImage = false) {
  let d = makePerleDiv(perle,
    { wmin: sz + 4, h: sz * (1 + hf) + 4 },
    { w: sz, h: sz }, { wmax: sz * wf, hmax: sz * hf, fz: sz / 6 },
    'b', true, null, useNewImage);
  mAppend(dParent, d);
  if (perle.field != null) {
    perle.live.dLabel.remove();
    let img = perle.live.dImg;
    let d = iDiv(perle);
    let rect = getRect(img);
    let szField = G.settings.szField;
    let sz = G.settings.szPerle * szField / 100;
    if (isFarbPerle(perle)) mStyleX(img, { w: 1, h: 1 });
    else mStyleX(img, { w: sz, h: sz });
    mStyleX(d, { bg: 'transparent', w: sz, h: sz });
  } else {
    let d = iDiv(perle);
    mStyleX(d, { opacity: 1 - G.settings.dimming / 100 });
    let sz = G.settings.szPoolPerle;
    if (isdef(sz)) {
      mStyleX(d.firstChild, { w: sz, h: sz });
    }
  }
  return d;
}
function createPerleOverlap(perle, dParent, sz = 64, wf = 1.3, hf = 0.4) {
  let d = makePerleDiv(perle, { wmin: sz + 4, h: sz * hf + 4 }, { w: sz, h: sz }, { wmax: sz * wf, hmax: sz * hf, fz: sz / 6 }, 'b', true);
  mAppend(dParent, d);
  return d;
}
function createPicto({ key, w = 100, h = 100, unit = 'px', fg = 'blue', bg, padding = 10, cat, parent, border, rounding }) {
  if (nundef(key)) key = getRandomKey(iconChars);
  let ch = iconChars[key];
  let family = (ch[0] == 'f' || ch[0] == 'F') ? 'pictoFa' : 'pictoGame';
  let text = String.fromCharCode('0x' + ch);
  cat = isdef(parent) ? getTypeOf(parent) == 'div' ? 'd' : 'g' : isdef(cat) ? cat : 'd';
  let domel;
  if (cat == 'd') {
    let d = document.createElement('div');
    d.style.textAlign = 'center';
    d.style.fontFamily = family;
    d.style.fontWeight = 900;
    d.style.fontSize = h + unit;
    if (isdef(bg)) d.style.backgroundColor = bg;
    if (isdef(fg)) d.style.color = fg;
    d.innerHTML = text;
    domel = d;
    if (isdef(padding)) d.style.padding = padding + unit;
    d.style.display = 'inline-block';
    d.style.height = h + 2 * padding + unit;
    d.style.width = d.style.height;
    console.log('padding', padding, 'unit', unit, 'w', d.style.width, 'h', d.style.height);
    if (isdef(border)) d.style.border = border;
    if (isdef(rounding)) d.style.borderRadius = rounding + unit;
  } else {
  }
  domel.key = key;
  if (parent) parent.appendChild(domel);
  return domel;
}
function createPictoSimple({ key, w, h, unit = 'px', fg, bg, padding, cat, parent, border, rounding }) {
  if (nundef(key)) key = getRandomKey(iconChars);
  let ch = iconChars[key];
  let family = (ch[0] == 'f' || ch[0] == 'F') ? 'pictoFa' : 'pictoGame';
  let text = String.fromCharCode('0x' + ch);
  cat = isdef(cat) ? cat : isdef(parent) ? getTypeOf(parent) == 'div' ? 'd' : 'g' : isdef(cat) ? cat : 'd';
  if (nundef(w)) w = 25;
  if (nundef(h)) h = w;
  let domel;
  if (cat == 'd') {
    let d = document.createElement('div');
    d.style.textAlign = 'center';
    d.style.fontFamily = family;
    d.style.fontWeight = 900;
    d.style.fontSize = h + unit;
    if (isdef(bg)) d.style.backgroundColor = bg;
    if (isdef(fg)) d.style.color = fg;
    d.innerHTML = text;
    domel = d;
    if (isdef(padding)) d.style.padding = padding + unit;
    d.style.display = 'inline-block';
    d.style.height = h + 2 * padding + unit;
    d.style.width = d.style.height;
    if (isdef(border)) d.style.border = border;
    if (isdef(rounding)) d.style.borderRadius = rounding + unit;
  } else {
  }
  domel.key = key;
  if (parent) parent.appendChild(domel);
  return domel;
}
function createPictoX(parent, style, classes, titleOptions, pictoOptions, captionOptions) {
  let d = mDiv(parent);
  if (isdef(style)) mStyle(d, style);
  if (isdef(classes)) mClass(d, ...classes);
  if (isdef(titleOptions)) { titleOptions.parent = d; createText(titleOptions); }
  if (isdef(pictoOptions)) { pictoOptions.parent = d; createPicto(pictoOptions); }
  if (isdef(captionOptions)) { captionOptions.parent = d; createText(captionOptions); }
  return d;
}
function createPlayerZone(pl, namePos = 'top', showColor = false) {
  let id = pl.id;
  let z = createCardZone(id, id, namePos);
  if (showColor) mStyleX(z.div, { bg: pl.color });
  pl.zone = z;
  return z;
}
function createProtoForOidAndKey(oid, o, k, R) {
  let n = R.getSpec(k);
  let n1 = { key: k, oid: oid, uid: getUID() };
  return n1;
}
function createPrototypesForOid(oid, o, R) {
  if (isdef(R.oidNodes[oid])) {
    return;
  }
  let klist = R.getR(oid);
  let nlist = {};
  for (const k of klist) {
    let n1 = createProtoForOidAndKey(oid, o, k, R);
    nlist[k] = n1;
  }
  R.oidNodes[oid] = nlist;
}
function createSampleHex1(rows = 5, topcols = 3, w = 50, h = 50) {
  initTable();
  let styles = {
    outer: { bg: 'pink', padding: 25 },
    inner: { w: 500, h: 400 },
    node: { bg: 'pink', shape: 'hex', w: w, h: h },
    edge: { bg: 'white' }
  };
  let g = hex1Board(dTable, rows, topcols, styles);
  g.addLayoutControls();
  return g;
}
function createServerBoard(layout, filename, rows, cols) {
  let sz = 100;
  return { filename: 'brett10', layout: 'hex', cells: { w: 100, h: 120, wgap: 10, hgap: 10 } };
}
function createServerPoolKeys(perlenDict, settings = {}) { return getRandomPerlenKeys(perlenDict, valf(settings.numPool, 20)); }
function createSettingsUi(dParent) {
  clearElement(dParent);
  let ttag = 'h2';
  mAppend(dParent, createElementFromHTML(`<${ttag}>Common Settings for ${Username}:</${ttag}>`));
  let nGroupNumCommonAllGames = mInputGroup(dParent);
  setzeEineZahl(nGroupNumCommonAllGames, 'samples', 25, ['samplesPerGame']);
  setzeEineZahl(nGroupNumCommonAllGames, 'minutes', 1, ['minutesPerUnit']);
  setzeEineZahl(nGroupNumCommonAllGames, 'correct streak', 5, ['incrementLevelOnPositiveStreak']);
  setzeEineZahl(nGroupNumCommonAllGames, 'fail streak', 2, ['decrementLevelOnNegativeStreak']);
  setzeEinOptions(nGroupNumCommonAllGames, 'show labels', ['toggle', 'always', 'never'], ['toggle', 'always', 'never'], 'toggle', ['showLabels']);
  setzeEinOptions(nGroupNumCommonAllGames, 'language', ['E', 'D', 'S', 'F', 'C'], ['English', 'German', 'Spanish', 'French', 'Chinese'], 'E', ['language']);
  setzeEinOptions(nGroupNumCommonAllGames, 'vocabulary', Object.keys(KeySets), Object.keys(KeySets), 'best25', ['vocab']);
  setzeEineCheckbox(nGroupNumCommonAllGames, 'show time', false, ['showTime']);
  setzeEineCheckbox(nGroupNumCommonAllGames, 'spoken feedback', true, ['spokenFeedback']);
  setzeEineCheckbox(nGroupNumCommonAllGames, 'silent', false, ['silentMode']);
  setzeEineCheckbox(nGroupNumCommonAllGames, 'switch game after level', false, ['switchGame']);
  mLinebreak(dParent);
  let g = DB.games[G.id];
  if (nundef(g)) return;
  mAppend(dParent, createElementFromHTML(`<${ttag}>Settings for <span style='color:${g.color}'>${g.friendly}</span></${ttag}>`));
  let nGroupSpecific = mInputGroup(dParent);
  setzeEineZahl(nGroupSpecific, 'trials', 3, ['trials']);
  setzeEineCheckbox(nGroupSpecific, 'show hint', true, ['showHint']);
}
function createStandardDeck() { return _createDeck(); }
function createStandardItems(onClickPictureHandler, ifs = {}, options = {}, keys, labels) {
  //#region prelim: default ifs and options, keys & infos
  if (nundef(Settings)) Settings = {};
  let infos = keys.map(k => (isdef(Settings.language) ? getRandomSetItem(Settings.language, k) : symbolDict[k]));
  let bg = isdef(options.colorKeys) ? 'white' : (i) => options.sameBackground ? computeColor('random') : 'random';
  let fg = (i, info, item) => colorIdealText(item.bg);
  let defIfs = { bg: bg, fg: fg, label: isdef(labels) ? labels : (i, info) => info.best, contrast: .32, fz: 20, padding: 3 };
  let defOptions = {
    showLabels: Settings.labels == true, shufflePositions: true, sameBackground: true,
    showRepeat: false, repeat: 1, onclick: onClickPictureHandler, iStart: 0
  };
  ifs = deepmergeOverride(defIfs, ifs);
  options = deepmergeOverride(defOptions, options);
  //#endregion
  //#region phase1: make items: hier jetzt mix and match
  let items = zItems(infos, ifs, options);
  if (options.repeat > 1) items = zRepeatEachItem(items, options.repeat, options.shufflePositions);
  if (isdef(options.colorKeys)) items = zRepeatInColorEachItem(items, options.colorKeys);
  items.map(x => x.label = x.label.toUpperCase());
  //#endregion phase1
  return [items, ifs, options];
}
function createStandardItemsS(onClickPictureHandler, ifs = {}, options = {}, keys, labels) {
  if (nundef(Settings)) Settings = {};
  let lang = isdef(Settings.language) ? Settings.language : 'E';
  let defShowLabels = isdef(Settings.labels) && Settings.labels == true;
  let infos = keys.map(k => Syms[k]);
  infos.map(x => x.best = x['best' + lang]);
  console.log(infos.map(x => x.best));
  let bg = isdef(options.colorKeys) ? 'white' : (i) => options.sameBackground ? computeColor('random') : 'random';
  let fg = (i, info, item) => colorIdealText(item.bg);
  let defIfs = { bg: bg, fg: fg, label: isdef(labels) ? labels : (i, info) => info.best, contrast: .32, fz: 20, padding: 10 };
  let defOptions = { showLabels: defShowLabels, shufflePositions: true, sameBackground: true, showRepeat: false, repeat: 1, onclick: onClickPictureHandler, iStart: 0 };
  ifs = deepmergeOverride(defIfs, ifs);
  options = deepmergeOverride(defOptions, options);
  let items = zItems(infos, ifs, options);
  if (options.repeat > 1) items = zRepeatEachItem(items, options.repeat, options.shufflePositions);
  if (isdef(options.colorKeys)) items = zRepeatInColorEachItem(items, options.colorKeys);
  items.map(x => x.label = x.label.toUpperCase());
  return [items, ifs, options];
}
function createStaticUi(area, R) {
  ensureUiNodes(R);
  let n = R.tree;
  recUi(n, R, area);
}
function createSTree(n, idParent, R) {
  n = createNode(n, idParent, R);
  if (isContainerType(n.type)) {
    let prop = RCONTAINERPROP[n.type];
  }
}
function createSubtitledPage(bg = 'silver', title = 'Aristocracy', subtitle = '', footer = 'a game by F. Ludos') {
  setPageBackground(bg);
  createPageDivsFullVisibleArea({
    title: { h: 42, family: 'AlgerianRegular', fz: 36 },
    subtitle: { h: 30, fz: 16 },
    titleLine: { h: 5, bg: '#00000080' },
  }, { bg: '#00000050' }, { footer: { h: 30, fz: 16 } }, {});
  dTitle.innerHTML = title;
  dSubtitle.innerHTML = subtitle;
  dFooter.innerHTML = footer;
  addDummy();
}
function createSuccessMarker(sz) {
  let d = mCreate('div');
  d.innerHTML = 'J';
  mClass(d, 'feedbackMarker');
  document.body.appendChild(d);
  Markers.push(d);
  return d;
}
function createTable() {
  let numPlayers = G.numPlayers;
  if (isdef(numPlayers)) {
    idTable = getNextTableId();
    T = { id: idTable, game: G.id };
    getPlayersIncludingU();
    lookupSet(DB, ['tables', idTable], T);
    return idTable;
  }
  return null;
}
function createTableZone(showColor = false) {
  let z = createCardZone('table');
  if (showColor) mStyleX(z.div, { bg: 'white' });
  return z;
}
function createText({ s, parent, style, classes }) {
  let d = mText(s, parent);
  if (isdef(style)) mStyle(d, style);
  if (isdef(classes)) mClass(d, ...classes);
}
function createTooltip(oid) {
  $('#' + oid).unbind('mouseover mouseout');
  $('#' + oid).mouseover(function (e) {
    e.stopPropagation();
    let id = evToId(e);
    if (TT_JUST_UPDATED != id) {
      TT_JUST_UPDATED = id;
      updateTooltipContent(id);
      $('div#tooltip').css({
        display: 'inline-block',
        top: e.pageY,
        left: e.pageX,
      });
    }
  });
  $('#' + oid).mouseout(function (e) {
    if (TT_JUST_UPDATED == oid) TT_JUST_UPDATED = -1;
    e.stopPropagation();
    $('div#tooltip').css({
      top: 0,
      left: 0,
      display: 'none'
    });
  });
}
function createTooltip_hallo(oid) {
  let id = getMainId(oid);
  let ms = getVisual(oid);
  if (!ms) return;
  let ground = ms.ground;
  if (!ground) return;
  let domel = ground;
  console.log('creating tt', domel)
  $(domel).off('mouseover mouseout');
  $(domel).mouseover(function (e) {
    console.log('mouseover', e, evToId(e));
    return;
    let mainId = evToId(e);
    console.log(ev, 'should show tt for', mainId)
    if (TT_JUST_UPDATED != oid) {
      TT_JUST_UPDATED = oid;
      updateTooltipContent(mainId);
      $('div#tooltip').css({
        display: 'inline-block',
        top: e.pageY,
        left: e.pageX,
      });
    }
  });
  $(domel).mouseout(function (e) {
    if (TT_JUST_UPDATED == oid) TT_JUST_UPDATED = -1;
    e.stopPropagation();
    $('div#tooltip').css({
      top: 0,
      left: 0,
      display: 'none'
    });
  });
}
function createUi(n, R, area) {
  if (nundef(n.type)) { n.type = inferType(n); }
  R.registerNode(n);
  decodeParams(n, R, {});
  calcIdUiParent(n, R, area);
  let ui;
  if (nundef(RCREATE[n.type])) ui = mDefault(n, area, R);
  else ui = RCREATE[n.type](n, R, area);
  if (nundef(n.uiType)) n.uiType = 'd';
  if (n.uiType == 'NONE') return ui;
  if (n.uiType != 'childOfBoardElement') {
    if (isBoard(n.uid, R)) { delete n.cssParams.padding; }
    applyCssStyles(n.uiType == 'h' ? mBy(n.uidStyle) : ui, n.cssParams);
  }
  if (!isEmpty(n.stdParams)) {
    switch (n.stdParams.show) {
      case 'if_content': if (!n.content) hide(ui); break;
      case 'hidden': hide(ui); break;
      default: break;
    }
  }
  R.setUid(n, ui);
  return ui;
}
function createUiTestX(n, R, area) {
  if (nundef(n.type)) { n.type = inferType(n); }
  decodeParams(n, R, {});
  calcIdUiParent(n, R, area);
  let ui;
  if (isdef(RCREATE[n.type])) ui = RCREATE[n.type](n, R, area);
  else ui = mDefault(n, R, area);
  if (nundef(n.uiType)) n.uiType = 'd';
  if (n.uiType == 'NONE') return ui;
  if (n.uiType != 'childOfBoardElement') {
    if (isBoard(n.uid, R)) { delete n.cssParams.padding; }
    applyCssStyles(n.uiType == 'h' ? mBy(n.uidStyle) : ui, n.cssParams);
  }
  if (!isEmpty(n.stdParams)) {
    switch (n.stdParams.show) {
      case 'if_content': if (!n.content) hide(ui); break;
      case 'hidden': hide(ui); break;
      default: break;
    }
  }
  ui.id = n.uid;
  return ui;
}
async function createVault() {
  let sIndex = await fetchFileAsText('/RSG/index.html');
  let lines = sIndex.split('\n');
  let res = skipToLine(lines, 0, '#region loading:');
  let resend = skipToLine(lines, res.index, '#endregion');
  let listOfFiles = lines.slice(res.index, resend.index);
  listOfFiles = listOfFiles.map(x => stringBetween(x, '"'));
  listOfFiles = listOfFiles.filter(x => !isEmpty(x.trim()));
  listOfFiles.sort();
  listOfFiles = Array.from(listOfFiles);
  let files = ['assetHelpers', 'assets', 'helpers', 'helpersX'];
  listOfFiles = files.map(x => '/C/' + x + '.js');
  let vault = await documentVault(listOfFiles);
  return vault;
}
function createVisual(id, areaName, { rings = 3, bg = 'darkslategray', fg = 'lime', label, shape = 'circle', iPalette, ipal, fill, x = 0, y = 0, w = 25, h = 25, sPoints, border = 'green', thickness = 1, rounding, path, txt, fz = 12, sz, overlay = true, draw = true } = {}) {
  let parent = getVisual(areaName);
  if (parent.cat == 'd') {
    if (parent.ids.length != 1) {
      error('DIV cannot have more than 1 G child!!!');
    } else {
      parent = getVisual(parent.ids[0]);
      areaName = parent.id;
    }
  }
  let ms = new __O(id, areaName, 'G');
  let options = {};
  let labelOptions = {};
  if (iPalette && ipal) fill = S.pals[iPalette][ipal];
  if (bg) ms.setBg(bg);
  if (fg) { ms.setFg(fg); }
  if (fill) options.fill = fill;
  if (x) options.x = x;
  if (y) options.y = y;
  if (h) { options.h = h; options.sz = h; }
  if (w) { options.w = w; options.sz = w; }
  if (sz) options.sz = sz;
  if (txt) { options.txt = txt; labelOptions.txt = txt; }
  if (label) { labelOptions.txt = label; }
  if (fz) { options.fz = fz; labelOptions.fz = fz; }
  if (sPoints) options.sPoints = sPoints;
  if (border) options.border = border;
  if (thickness) options.thickness = thickness;
  if (rounding) options.rounding = rounding;
  if (path) options.path = './assets/images/transpng/' + path + '.png';
  if (rings) {
  } else rings = 1;
  dSize = Math.max(w / 6, 5);
  for (let i = 0; i < rings; i++) {
    switch (shape) {
      case 'circle':
        ms.circle(options);
        break;
      case 'hex':
        ms.hex(options);
        break;
      case 'rect':
        ms.rect(options);
        break;
      case 'poly':
        ms.poly(options);
        break;
      case 'image':
        ms.image(options);
        break;
      case 'text':
        ms.text(options);
        break;
      default:
        return null;
    }
    options.w -= dSize;
    options.sz -= dSize;
    options.h -= dSize;
  }
  if (label) {
    ms.text(labelOptions);
  }
  if (h) { options.h = h; options.sz = h; }
  if (w) { options.w = w; options.sz = w; }
  if (sz) options.sz = sz;
  if (overlay) {
    overlayOptions = jsCopy(options);
    overlayOptions.className = 'overlay';
    delete overlayOptions.fill;
    delete overlayOptions.path;
    switch (shape) {
      case 'circle':
        ms.circle(overlayOptions);
        break;
      case 'hex':
        ms.hex(overlayOptions);
        break;
      case 'rect':
        ms.rect(overlayOptions);
        break;
      case 'poly':
        ms.poly(overlayOptions);
        break;
      case 'image':
        ms.rect(overlayOptions);
        break;
      case 'text':
        ms.text(overlayOptions);
        break;
      default:
        return null;
    }
  }
  if (draw) ms.attach();
  return ms;
}
function createWordInputs(words, dParent, idForContainerDiv = 'seqContainer', sep = null, styleContainer = {}, styleWord = {}, styleLetter = {}, styleSep = {}, colorWhiteSpaceChars = true, preserveColorsBetweenWhiteSpace = true) {
  if (isEmpty(styleWord)) {
    let sz = 80;
    styleWord = {
      margin: 10, padding: 4, rounding: '50%', w: sz, h: sz, display: 'flex', fg: 'lime', bg: 'yellow', 'align-items': 'center',
      border: 'transparent', outline: 'none', fz: sz - 25, 'justify-content': 'center',
    };
  }
  let dContainer = mDiv(dParent);
  if (!isEmpty(styleContainer)) mStyleX(dContainer, styleContainer); else mClass(dContainer, 'flexWrap');
  dContainer.id = idForContainerDiv;
  let inputGroups = [];
  let charInputs = [];
  let iWord = 0;
  let idx = 0;
  let numWords = words.length;
  let wheel = getHueWheel(G.color, 40, numWords <= 4 ? 60 : numWords <= 10 ? 30 : 15, 0);
  wheel = wheel.map(x => colorHSLBuild(x, 100, 50));
  wheel = shuffle(wheel);
  let wheel1 = colorPalShadeX(colorFrom(wheel[0]), numWords);
  wheel = jsCopy(wheel1);
  if (G.op == 'plus') wheel.reverse();
  for (const w of words) {
    let dGroup = mDiv(dContainer);
    mStyleX(dGroup, styleWord);
    let bg = wheel[iWord]; // dGroup.style.backgroundColor=randomColorX(G.color,40,60,0,50,50);//'yellow';//randomColorX(G.color,70,80);
    dGroup.style.backgroundColor = bg;
    dGroup.style.color = colorIdealText(bg);
    dGroup.id = idForContainerDiv + '_' + iWord;
    let g = { dParent: dContainer, word: w, iWord: iWord, div: dGroup, oStyle: styleWord, ofg: dGroup.style.color, obg: dGroup.style.backgroundColor };
    inputGroups.push(g);
    let inputs = [];
    let iLetter = 0;
    let wString = w.toString();
    for (const l of wString) {
      let dLetter = mDiv(dGroup);
      if (!isEmpty(styleLetter)) mStyleX(dLetter, styleLetter);
      dLetter.innerHTML = l;
      let inp = { group: g, div: dLetter, letter: l, iLetter: iLetter, index: idx, oStyle: styleLetter, ofg: dLetter.style.color, obg: dLetter.style.backgroundColor };
      charInputs.push(inp);
      inputs.push(inp);
      iLetter += 1; idx += 1;
    }
    g.charInputs = inputs;
    if (iWord < words.length - 1 && isdef(sep)) {
      let dSep = mDiv(dContainer);
      dSep.innerHTML = sep;
      if (isdef(styleSep)) mStyleX(dSep, styleSep);
    }
    iWord += 1;
  }
  return { words: inputGroups, letters: charInputs };
}
function cRect(x, y, w, h, styles = null, ctx = null) {
  if (nundef(ctx)) { ctx = CX; if (!ctx) return; }
  if (styles) cStyle(styles, ctx);
  if (isdef(styles.bg) || nundef(styles.fg)) ctx.fillRect(x, y, w, h);
  if (isdef(styles.fg)) ctx.strokeRect(x, y, w, h);
}
function cropImageCorrectly(img, mindCorners = false) {
  let sz = SZ_UPLOAD_CANVAS;
  let canvas = mBy('canvas1');
  let cw, ch, iw, ih, fw, fh, f, padw, padh, padmin = mindCorners ? sz * .1 : 0;
  cw = ch = sz;
  iw = img.naturalWidth;
  ih = img.naturalHeight;
  fw = cw / iw;
  fh = ch / ih;
  f = Math.min(fw, fh);
  iw *= f;
  ih *= f;
  padw = (cw - iw) / 2;
  padh = (ch - ih) / 2;
  let dx, dy, cwNet, chNet;
  if (padw < padmin && padh < padmin) {
    padw = padh = padmin;
    cwNet = cw - 2 * padmin;
    chNet = ch - 2 * padmin;
    iw = img.naturalWidth;
    ih = img.naturalHeight;
    fw = cwNet / iw;
    fh = chNet / ih;
    f = Math.min(fw, fh);
    iw *= f;
    ih *= f;
  }
  let ctx = canvas.getContext("2d");
  let color = getBackgroundColor(img, ctx);
  ctx.clearRect(0, 0, sz, sz);
  drawColoredCircle(canvas, sz, color, color);
  ctx.drawImage(img, padw, padh, iw, ih);
  ctx.globalCompositeOperation = 'destination-in';
  ctx.beginPath();
  ctx.arc(cw / 2, ch / 2, ch / 2, 0, Math.PI * 2);
  ctx.closePath();
  ctx.fill();
}
function cRound(dParent, styles = {}, id) {
  styles.w = valf(styles.w, Card.sz);
  styles.h = valf(styles.h, Card.sz);
  styles.rounding = '50%';
  return cBlank(dParent, styles, id);
}
function cSetOrigin(ctx, x, y) {
  ctx.translate(x, y);
}
function cShadow(ctx, color, offx, offy, blur) {
  ctx.shadowColor = color;
  ctx.shadowOffsetX = offx;
  ctx.shadowOffsetY = offy;
  ctx.shadowBlur = blur;
}
function cStyle(styles, ctx) {
  if (nundef(ctx)) { ctx = CX; if (nundef(ctx)) { console.log('ctx undefined!!!!!!!'); return; } }
  const di = { bg: 'fillStyle', fill: 'fillStyle', stroke: 'strokeStyle', fg: 'strokeStyle', thickness: 'lineWidth', thick: 'lineWidth', cap: 'lineCap', ending: 'lineCap' };
  if (isdef(styles)) {
    for (const k in styles) { ctx[isdef(di[k]) ? di[k] : k] = styles[k]; }
  }
}
function cStyle_dep(cvx, fill, stroke, wline, cap) {
  cvx.fillStyle = fill;
  if (isdef(stroke)) cvx.strokeStyle = stroke;
  if (isdef(wline)) cvx.lineWidth = wline;
  if (isdef(cap)) cvx.lineCap = cap;
}
function csv_table_example(dParent) {
  mystring = get_csv_example();
  present_table_from_csv(mystring, dParent);
}
function csv2list(allText, hasHeadings = true) {
  var numHeadings = 11;
  var allTextLines = allText.split(/\r\n|\n/);
  var headings = allTextLines[0].split(',');
  numHeadings = headings.length;
  let entries = allTextLines.splice(1);
  var records = [];
  for (const e of entries) {
    let o = {};
    let values = e.split(',');
    for (let i = 0; i < numHeadings; i++) {
      let k = headings[i];
      o[k] = values[i];
    }
    records.push(o);
  }
  return records;
}
function cTest03_2Hands_transfer() {
  let deck1 = DA.h1.deck;
  let deck2 = DA.h2.deck;
  let item = DA.item;
  deck1.addTop(item.val);
  deck2.remove(item.val);
  iPresentHand_test(dTable, DA.h1);
  iPresentHand_test(dTable, DA.h2);
  iSortHand_test(dTable, DA.h1)
}
function cTest03_2Hands_transferStarts() {
  let h1 = DA.h1.iHand;
  let n1 = h1.items.length;
  let h2 = DA.h2.iHand;
  let n2 = h2.items.length;
  let c = chooseRandom(h2.items);
  DA.item = c;
  let w = c.w;
  let ov = w / 4;
  let xOffset = n1 * ov;
  console.log('w', w, 'ov', ov, 'xOffset', xOffset)
  iMoveFromTo(c, h2.div, h1.div, cTest03_2Hands_transfer, { x: xOffset, y: 0 });
}
function cTest03_2HandsRandom() {
  let h1 = iMakeHand_test(dTable, [33, 7, 1, 2, 3, 4], 'h1');
  let h2 = iMakeHand_test(dTable, [13, 14, 15, 16, 17], 'h2');
  setTimeout(cTest03_2Hands_transferStarts, 1000);
}
function cTest04_2HandsRandom() {
  let iarr = [33, 7, 1, 2, 3, 4], dParent = dTable, id = 'h1';
  let data = DA[id] = {};
  let h = data.deck = new DeckClass();
  h.init(iarr);
  let redo = true;
  h = data;
  if (nundef(h.zone)) {
    let nmax = 10, padding = 10;
    let sz = netHandSize(nmax);
    h.zone = mZone(dParent, { w: sz.w, h: sz.h, bg: 'random', padding: padding, rounding: 10 });
  } else {
    clearElement(h.zone);
  }
  if (nundef(h.iHand)) {
    let items = i52(h.deck.cards());
    h.iHand = iSplay(items, h.zone);
  } else if (redo) {
    clearElement(h.zone);
    let items = i52(h.deck.cards());
    h.iHand = iSplay(items, h.zone);
  }
  let h2 = iMakeHand([13, 14, 15, 16, 17], dParent, {}, 'h2');
  setTimeout(cTest03_2Hands_transferStarts, 1000);
}
function cTest05() {
  setBackgroundColor(null, 'random')
  mStyle(dTable, { h: 400, bg: 'black', padding: 10 });
  let SPEC = { layout: ['T T', 'H A'], showAreaNames: true };
  let s = '';
  let m = [];
  for (const line of SPEC.layout) {
    s += '"' + line + '" ';
    let letters = line.split(' ');
    let arr = [];
    for (const l of letters) { if (!isEmpty(l)) arr.push(l); }
    m.push(arr);
  }
  console.log('m', m, '\ns', s); return;
  let rows = SPEC.layout.length;
  let hCard = 110;
  let hTitle = 20;
  let gap = 4;
  let hGrid = rows * (hCard + hTitle) + gap * (rows + 1);
  let wGrid = '80%';
  let dGrid = mDiv(dTable, { h: hGrid, w: wGrid, 'grid-template-areas': s, bg: 'yellow' });
}
function cTest05B() {
  let dGridContainer = mDiv100(dTable, { bg: 'yellow' });
  let areas = mAreas(dGridContainer);
  areas.map(x => mCenterCenterFlex(x.div));
  let dGrid = dGridContainer.children[0];
  mStyle(dGrid, { gap: 5, bg: 'blue', box: true, padding: 5 })
  console.log(dTrick, dGridContainer.children[0]);
  areas.map(x => mStyle(x.div, { h: 110 }));
}
function cTest10() {
  let layout = ['T', 'H A'];
  let x = createGridLayout(dTable, layout);
  console.log('x', x);
}
function cTitleArea(card, h, styles, classes) {
  let dCard = iDiv(card);
  let dTitle = mDiv(dCard, { w: '100%', h: h, overflow: 'hidden', upperRounding: card.rounding });
  let dMain = mDiv(dCard, { w: '100%', h: card.h - h, lowerRounding: card.rounding });
  iAdd(card, { dTitle: dTitle, dMain: dMain });
  if (isdef(styles)) mStyle(dTitle, styles);
  return [dTitle, dMain];
}
function cumulative_distribution(from, to, mean, stdev, n = 0) {
  function cdfNormal(x, mean = 100, standardDeviation = 15) {
    return (1 - math.erf((mean - x) / (Math.sqrt(2) * standardDeviation))) / 2;
  }
  let res;
  if (to < from) { let h = from; from = to; to = h; }
  assertion(from <= to, 'MATH!!!!!!!!!!!!!!!??????????????????????')
  if (from <= mean && to >= mean) {
    let kleiner_als_from = cdfNormal(from, mean, stdev); console.log(kleiner_als_from)
    let kleiner_als_mean = cdfNormal(mean, mean, stdev); console.log(kleiner_als_mean)
    let res1 = kleiner_als_mean - kleiner_als_from; console.log('res1', res1);
    let kleiner_als_to = cdfNormal(to, mean, stdev); console.log(kleiner_als_to)
    let res2 = kleiner_als_to - kleiner_als_mean; console.log('res2', res2);
    console.log(res1 + res2); res = res1 + res2;
  } else {
    let kleiner_als_to = cdfNormal(to, mean, stdev); console.log(kleiner_als_to)
    let kleiner_als_from = cdfNormal(from, mean, stdev); console.log(kleiner_als_from)
    res = kleiner_als_to - kleiner_als_from; console.log('res', res);
  }
  return 100 * res.toFixed(n);
}
function cv_init_origin(canvas, origin) {
  let cv = canvas.cv;
  if (nundef(origin)) origin = 'cc';
  let pt = origin;
  if (isString(origin)) {
    let v = origin[0], h = origin[1];
    let y = v == 't' ? 0 : v == 'c' ? cv.height / 2 : cv.height;
    let x = h == 'l' ? 0 : h == 'c' ? cv.width / 2 : cv.width;
    pt = { x: x, y: y };
  }
  return pt;
}
function cycle(x, min, max) { let d = max - min; return (x - min) % d + min; }
function dachain(ms = 0) {
  console.log('TestInfo', TestInfo)
  if (!isEmpty(DA.chain) && !(DA.test.running && DA.test.step == true)) {
    dachainext(ms);
  } else if (isEmpty(DA.chain)) console.log('DA.chain EMPTY ' + DA.test.iter)
}
function dachain_orig(ms = 0) {
  if (!isEmpty(DA.chain)) {
    dachainext(ms);
  } else console.log('DA.chain EMPTY ' + ITER)
}
function dachainext(ms = 0) {
  let f = DA.chain.shift();
  if (ms > 0) TOMan.TO[getUID('f')] = setTimeout(f, ms);
  else f();
}
function danext() { if (isdef(DA.next)) { let f = DA.next; DA.next = null; f(); } }
function darkerColor(r, g, b) {
  let hsv = rgbToHsv(r, g, b);
  testHelpers(hsv);
  let h = hsv.h;
  let s = hsv.s;
  let v = hsv.v / 2;
  let hsl = hsvToHsl(h, s, v);
  h = hsl.h;
  s = hsl.s * 100;
  let l = hsl.l * 100;
  testHelpers('hsl:', h, s, l);
  return hslToHslaString(h, s, l);
}
function dastaged(r, uname, ms = 0) {
  if (!isEmpty(DA.staged_moves)) {
    let action = DA.staged_moves.shift();
    if (action == 'meld') {
      let a = firstCond(r.actions, x => startsWith(x, `${uname}.hand.`));
      if (!a) { console.log('staged action', action, 'cannot be completed', r.actions); return; } else action = a;
    }
    if (action == 'draw') {
      let a = firstCond(r.actions, x => startsWith(x, `draw.decks.`));
      if (!a) { console.log('staged action', action, 'cannot be completed', r.actions); return; } else action = a;
    }
    if (ms > 0) TOMan.TO[getUID('f')] = setTimeout(() => autoselect_action(r, action, uname), ms);
    else autoselect_action(r, action, uname);
  }
}
function data_from_client(raw) {
  assertion(is_stringified(raw), 'data should be stringified json!!!!!!!!!!!!!!!', raw);
  let js = JSON.parse(raw);
  return js;
}
function date2locale(date) { return date.toLocaleDateString(); }
function db_add_code() {
  let kw = prompt('Enter Keywords');
  let text = dCode.value;
  console.log('saving', kw, text);
  let code = { kw: kw, c: text };
  let data = { table: 'code', item: code };
  lookupAddToList(DB, ['code'], code);
  post_json('http://localhost:3000/db/add/code', code, r => console.log('resp', r));
}
function db_clear_players(friendly) {
  assertion(isdef(GT[friendly]), `table ${friendly} does NOT exist!!!!`);
  let t = GT[friendly];
  for (const pldata of t.playerdata) { pldata.state = null; pldata.player_status = null; }
  return t.playerdata;
}
function db_create(table, rec, db) {
  if (!db) { db = DB; }
  lookupAddToList(db, ['appdata', table], rec);
  return db;
}
function db_delete(table, i, db) {
  if (!db) { db = DB; }
  if (nundef(i)) delete db.appdata[table]; else arrRemovip(lookup(db, ['appdata', table])[i]);
  return db;
}
function db_init(db) { DB = db; return db; }
function db_init_code() {
  let code = [
    { kw: 'post route', c: `post_json('http://localhost:3000/post/json',o,r=>console.log('resp',r));` },
    { kw: 'get yaml route', c: `await route_path_yaml_dict('http://localhost:3000/route')` },
    { kw: 'get json route', c: `await route_path_json('http://localhost:3000/route')` },
  ];
  DB.code = code;
  post_json('http://localhost:3000/db/init/code', code, r => console.log('resp', r));
}
function db_list_code() {
  for (const code of DB.code) {
  }
}
function db_new_table(friendly, game, host, players, fen, options) {
  let table = { friendly, game, host, players, fen, options };
  table.modified = Date.now();
  let playerdata = [];
  for (const plname of players) {
    playerdata.push({ name: `${plname}`, state: null, player_status: null });
  }
  let res = { table, playerdata };
  GT[friendly] = res;
  return res;
}
function db_read_playerdata(friendly) {
  assertion(isdef(GT[friendly]), `table ${friendly} does NOT exist!!!!`);
  return GT[friendly].playerdata;
}
function db_read_table(friendly) {
  assertion(isdef(GT[friendly]), `table ${friendly} does NOT exist!!!!`);
  return GT[friendly].table;
}
function db_readall(db) {
  if (!db) { db = DB; }
  return db;
}
function db_save() {
  if (!is_online()) { console.log('not saving! (no internet)'); return; }
  let txt = jsyaml.dump(DB);
  to_server({ db: txt }, 'dbsave');
}
function db_table_exists(friendly) { return isdef(GT[friendly]); }
function db_update(table, i, rec, save = false) {
  if (isdef(DB)) { let list = lookup(DB, ['appdata', table]); list[i] = rec; }
  if (NODEJS) post_json(SERVERURL + `/update`, { table: table, i: i, rec: rec, save: save }, () => console.log('updated db'));
}
function db_write_fen(friendly, fen, scoring = null) {
  assertion(isdef(GT[friendly]), `table ${friendly} does NOT exist!!!!`);
  let t = GT[friendly];
  let table = t.table;
  table.fen = fen; table.scoring = scoring; table.phase = isdef(scoring) ? 'over' : '';
  table.modified = Date.now();
  return table;
}
function db_write_player(friendly, uname, state, player_status) {
  assertion(isdef(GT[friendly]), `table ${friendly} does NOT exist!!!!`);
  let t = GT[friendly];
  let pldata = firstCond(t.playerdata, x => x.name == uname);
  pldata.state = state;
  pldata.player_status = player_status;
  pldata.checked = Date.now();
  return t.playerdata;
}
async function dbInit(appName, dir = '../DATA/') {
  let users = await route_path_yaml_dict(dir + 'users.yaml');
  let settings = await route_path_yaml_dict(dir + 'settings.yaml');
  let addons = await route_path_yaml_dict(dir + 'addons.yaml');
  let games = await route_path_yaml_dict(dir + 'games.yaml');
  let tables = await route_path_yaml_dict(dir + 'tables.yaml');
  DB = {
    id: appName,
    users: users,
    settings: settings,
    games: games,
    tables: tables,
    addons: addons,
  };
  dbSave(appName);
}
async function dbLoad(appName, callback) {
  let url = SERVERURL;
  fetch(url, {
    method: 'GET',
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    },
  }).then(async data => {
    let sData = await data.json();
    DB = firstCond(sData, x => x.id == appName);
    if (isdef(callback)) callback();
  });
}
async function dbLoadX() { DB = await route_path_yaml_dict('./DB.yaml'); }
function dbSave() {
  if (NODEJS) {
    let route = `/post/json`;
    let o = { filename: 'db', data: DB }
    let callback = () => console.log('saved db');
    post_json(route, o, callback);
    console.log('full route', route);
  } else console.log('not saved - no app running!')
}
async function dbSaveX(callback) {
  if (USELIVESERVER) {
    return;
  }
  if (BlockServerSend1) { setTimeout(() => dbSaveX(callback), 1000); }
  else {
    let path = './MZZ/DB.yaml';
    let resp = await postData('http://localhost:3000/db', { obj: DB, path: path });
    BlockServerSend1 = false;
    if (callback) callback();
  }
}
function ddStart(ev, source, isCopy = true, clearTarget = false) {
  if (!canAct() || isdef(DDInfo.dragStartHandler) && !DDInfo.dragStartHandler(source)) return;
  ev.preventDefault();
  ev.stopPropagation();
  DDInfo.source = source;
  let d = iDiv(source);
  var clone = DragElem = DDInfo.clone = d.cloneNode(true);
  clone.isCopy = isCopy;
  clone.clearTarget = clearTarget;
  mAppend(document.body, clone);
  mClass(clone, 'dragelem');
  mStyle(clone, { left: ev.clientX - ev.offsetX, top: ev.clientY - ev.offsetY });
  DDInfo.dragOffset = clone.drag = { offsetX: ev.offsetX, offsetY: ev.offsetY };
  document.body.onmousemove = onMovingCloneAround;
  document.body.onmouseup = onReleaseClone;
}
function deactivate_ui() { uiActivated = false; DA.ai_is_moving = true; }
function deactivateChat(key) {
  console.log('deactivate chat', key, ActiveChats[key]);
  mClassRemove(ActiveChats[key].div, 'activeChat'); clearChatWindow();
}
function deactivateFocusGroup() {
  if (Goal.iFocus === null) {
    return;
  }
  let g = Goal.words[Goal.iFocus];
  g.div.style.backgroundColor = g.obg;
  Goal.iFocus = null;
}
function deactivateTooltips() {
  for (const oid in G.table) {
    $('#' + oid).unbind('mouseover mouseout');
  }
  for (const oid in G.players) {
    $('#' + oid).unbind('mouseover mouseout');
  }
}
function deactivateTooltips_hallo() {
  for (const oid in G.table) {
    $('#' + oid).unbind('mouseover mouseout');
  }
  for (const oid in G.players) {
    $('#' + oid).unbind('mouseover mouseout');
  }
}
function deactivateUis(R) {
  for (const uid in R.uiNodes) {
    let n = R.uiNodes[uid];
    if (n.oid && n.ui) {
      n.act.deactivate();
    }
  }
  R.isUiActive = false;
}
function deal1(deck, w, h) {
  deck.cards.forEach(function (card, i) {
    card.setSide('front')
    card.animateTo({
      delay: 1000 + i * 2,
      duration: 500,
      ease: 'quartOut',
      x: Math.random() * w - w / 2,
      y: Math.random() * h - h / 2
    })
  });
}
function dec_g_index(i) { set_g_index(G.i - 1); }
function dec_level_on_losestreak() {
  let players = get_values(Session.cur_players);
  let scores = players.map(x => x.score);
  let min = arrMin(scores);
  let losers = players.filter(x => x.score == min).map(x => x.name);
  let game = Session.cur_game;
  for (const w of losers) {
    let o = lookup(DB.users, [w, 'games', game]);
    o.losestreak = DB.users[w].games[game].losestreak = isdef(o.losestreak) ? o.losestreak + 1 : 1;
    if (o.losestreak >= 1) {
      let currentlevel = get_startlevel(w, game);
      lookupSetOverride(DB.users, [w, 'games', game, 'startlevel'], Math.max(currentlevel - 1, 0));
      delete o.losestreak;
    }
  }
}
function Deck() {
  this.cardWidth = 55;
  this.cardHeight = 80;
  this.cardSuit = 13;
  this.cardTotal = 52;
  this.cardURL = "../images/cards2/";
  this.cardReverse = "reverse";
  this.cardName = "";
  this.cardExtension = ".png";
  this.throwed = new Array(this.cardTotal);
  this.throwCard = function () {
    var id = Math.floor(Math.random() * this.throwed.length);
    while (this.throwed[id])
      if (++id == this.throwed.length)
        id = 0;
    this.throwed[id] = true;
    return (id)
  }
  this.cardSrc = function (id, reverse) {
    var srcname = (reverse) ? this.cardReverse : (this.cardName + String(id));
    return (this.cardURL + srcname + this.cardExtension);
  }
}
function deck_add(deck, n, arr) { let els = deck_deal(deck, n); els.map(x => arr.push(x)); return arr; }
function deck_deal(deck, n) { return deck.splice(0, n); }
function deck_deal_safe_ferro(fen, plname, n) {
  if (fen.deck.length < n) {
    fen.deck = fen.deck.concat(fen.deck_discard.reverse());
    fen.deck_discard = [];
  }
  let new_cards = deck_deal(fen.deck, n);
  fen.players[plname].hand.push(...new_cards);
  new_cards.map(x => lookupAddToList(fen.players[plname], ['newcards'], x));
  return new_cards;
}
function deck_deal_safe_fritz(fen, plname, n = 1) {
  if (fen.deck.length < n) {
    fen.deck = create_fen_deck('n', fen.num_decks, 0);
    fen.loosecards.push('*Hn');
  }
  let new_cards = deck_deal(fen.deck, n);
  fen.players[plname].hand.push(...new_cards);
  new_cards.map(x => lookupAddToList(fen.players[plname], ['newcards'], x));
  return new_cards;
}
function deck52Back(card) {
  card.elem.setAttribute('class', 'card');
}
function deck52Prep(card) {
  let elem = card.elem;
  var suitName = iToSuit52_G(card.suit);
  if (card.suitName == 'joker' && card.rank > 3)
    elem.setAttribute('class', 'card joker');
  else elem.setAttribute('class', 'card ' + suitName + ' rank' + card.rank);
}
function deck52Update(card) { deck52Prep(card); }
function deckAPrep(card) {
  let elem = card.elem;
  let i = card.i;
  elem.setAttribute('class', 'card joker');
}
function deckEmptyBack(card) {
  card.elem.setAttribute('class', 'card');
}
function deckEmptyPrep(card) {
  let elem = card.elem;
  elem.setAttribute('class', 'card joker');
}
function deckEmptyUpdate(card) { deckEmptyPrep(card); }
function deckWiseBack(card) {
  card.elem.setAttribute('class', 'card');
}
function deckWiseUpdate(card) { deckEmptyPrep(card); }
function decodeColor(c) {
  let parts = c.split(' ');
  if (parts.length == 1) return c;
  else if (parts.length == 2 && (parts[1][0] == '.' || parts[1][0] == '0')) {
    return colorFrom(parts[0], Number(parts[1]));
  } else {
    let n = Number(parts[1]);
    let lumParam = n / 50 - 1.0;
    let cAltered = colorShade(lumParam, parts[0]);
    if (parts.length > 2) { cAltered = colorFrom(cAltered, Number(parts[2])); }
    return cAltered;
  }
}
function decodeParams(n, R, defParams) {
  if (isdef(n.params) && isdef(n.params._NODE)) {
    let spk = n.params._NODE;
    let oParams = R.getSpec()[spk];
    for (const k in oParams) {
      n.params[k] = oParams[k];
    }
    delete n.params._NODE;
    let r = R.rNodes[n.uid];
    r.params = jsCopy(n.params);
  }
  if (nundef(n.params)) n.params = lookup(R.defs, [n.type, 'params']);
  if (!n.params) n.params = {};
  let inherited = lookup(defParams, [n.type, 'params']);
  let defaults = lookup(R.defs, [n.type, 'params']);
  let defs = n.params.inherit ? inherited : defaults ? defaults : {};
  if (n.type != 'grid') n.params = mergeOverrideArrays(defs, n.params);
  let o = isdef(n.oid) ? R.getO(n.oid) : null;
  let pNew = {};
  if (o) {
    pNew = mapValues(o, n.params, defs, R.getSpec());
    for (const k in pNew) { pNew[k] = calcContentFromData(n.oid, o, pNew[k], R); }
  } else pNew = n.params;
  if (isdef(pNew.bg) || isdef(pNew.fg)) {
    [pNew.bg, pNew.fg] = getExtendedColors(pNew.bg, pNew.fg);
  }
  let pNew1 = {};
  for (const k in pNew) { if (nundef(pNew[k])) continue; pNew1[k] = pNew[k]; }
  pNew = pNew1;
  for (const k in pNew) { if (COLORPARAMNAMES[k]) pNew[k] = decodeColor(pNew[k]); }
  let params = paramsToCss(pNew);
  n.params = pNew;
  n.typParams = params.typ;
  n.cssParams = params.css;
  n.stdParams = params.std;
}
function decodePropertyPath(o, path) {
  if (isString(path) && path[0] == '.') {
    let props = path.split('.').slice(1);
    return lookup(o, props);
  }
}
function decompose_2d_matrix(mat) {
  var a = mat[0];
  var b = mat[1];
  var c = mat[2];
  var d = mat[3];
  var e = mat[4];
  var f = mat[5];
  var delta = a * d - b * c;
  let result = {
    translation: [e, f],
    rotation: 0,
    scale: [0, 0],
    skew: [0, 0],
  };
  if (a != 0 || b != 0) {
    var r = Math.sqrt(a * a + b * b);
    result.rotation = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
    result.scale = [r, delta / r];
    result.skew = [Math.atan((a * c + b * d) / (r * r)), 0];
  } else if (c != 0 || d != 0) {
    var s = Math.sqrt(c * c + d * d);
    result.rotation =
      Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
    result.scale = [delta / s, s];
    result.skew = [0, Math.atan((a * c + b * d) / (s * s))];
  } else {
  }
  return result;
}
function decomposeMatrix(matrix) {
  // @see https://gist.github.com/2052247
  var px = deltaTransformPoint(matrix, { x: 0, y: 1 });
  var py = deltaTransformPoint(matrix, { x: 1, y: 0 });
  var skewX = (180 / Math.PI) * Math.atan2(px.y, px.x) - 90;
  var skewY = (180 / Math.PI) * Math.atan2(py.y, py.x);
  return {
    translateX: matrix.e,
    translateY: matrix.f,
    scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),
    scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),
    scale: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),
    skewX: skewX,
    skewY: skewY,
    rotation: skewX
  };
}
function decorateVisual(ms, { draw = true, rings = 3, bg = 'darkslategray', fg = 'lime', label, shape = 'circle', palette, ipal, fill, x = 0, y = 0, w = 25, h = 25, sPoints, border = 'green', thickness = 1, rounding, path, txt, fz = 12, sz, overlay = true } = {}) {
  console.log('decorate', ms)
  let options = {};
  let labelOptions = {};
  if (palette && ipal) fill = palette[ipal];
  else if (ipal) fill = S.pal[ipal];
  if (bg) ms.setBg(bg);
  if (fg) { ms.setFg(fg); }
  if (fill) options.fill = fill;
  if (x) options.x = x;
  if (y) options.y = y;
  if (h) { options.h = h; options.sz = h; }
  if (w) { options.w = w; options.sz = w; }
  if (sz) options.sz = sz;
  if (txt) { options.txt = txt; labelOptions.txt = txt; }
  if (label) { labelOptions.txt = label; }
  if (fz) { options.fz = fz; labelOptions.fz = fz; }
  if (sPoints) options.sPoints = sPoints;
  if (border) options.border = border;
  if (thickness) options.thickness = thickness;
  if (rounding) options.rounding = rounding;
  if (path) options.path = './assets/images/transpng/' + path + '.png';
  if (rings) {
  } else rings = 1;
  dSize = Math.max(w / 6, 5);
  for (let i = 0; i < rings; i++) {
    switch (shape) {
      case 'circle':
        ms.circle(options);
        break;
      case 'hex':
        ms.hex(options);
        break;
      case 'rect':
        ms.rect(options);
        break;
      case 'poly':
        ms.poly(options);
        break;
      case 'image':
        ms.image(options);
        break;
      case 'text':
        ms.text(options);
        break;
      default:
        return null;
    }
    options.w -= dSize;
    options.sz -= dSize;
    options.h -= dSize;
  }
  if (label) {
    ms.text(labelOptions);
  }
  if (h) { options.h = h; options.sz = h; }
  if (w) { options.w = w; options.sz = w; }
  if (sz) options.sz = sz;
  if (overlay) {
    overlayOptions = jsCopy(options);
    overlayOptions.className = 'overlay';
    delete overlayOptions.fill;
    delete overlayOptions.path;
    switch (shape) {
      case 'circle':
        ms.circle(overlayOptions);
        break;
      case 'hex':
        ms.hex(overlayOptions);
        break;
      case 'rect':
        ms.rect(overlayOptions);
        break;
      case 'poly':
        ms.poly(overlayOptions);
        break;
      case 'image':
        ms.rect(overlayOptions);
        break;
      case 'text':
        ms.text(overlayOptions);
        break;
      default:
        return null;
    }
  }
  if (draw) ms.attach();
  return ms;
}
function decrease_handicap_if_winstreak(winners, game) {
  for (const w of winners) {
    let o = lookupSet(DB.users, [w, 'games', game], {});
    o.winstreak = DB.users[w].games[game].winstreak = isdef(o.winstreak) ? o.winstreak + 1 : 1;
    if (o.winstreak >= 3) {
      lookupSetOverride(DB.users, [w, 'games', game, 'startlevel'], Math.min(o.startlevel + 1, Session.maxlevel));
      delete o.winstreak;
      console.log('...startlevel of', w, 'is increased to', get_startlevel(w, game));
    }
    console.log('user', w, 'db entry', o);
  }
}
function deepmerge(target, source, optionsArgument) {
  var array = Array.isArray(source);
  var options = optionsArgument || { arrayMerge: defaultArrayMerge }
  var arrayMerge = options.arrayMerge || defaultArrayMerge
  if (array) {
    return Array.isArray(target) ? arrayMerge(target, source, optionsArgument) : cloneIfNecessary(source, optionsArgument)
  } else {
    return mergeObject(target, source, optionsArgument)
  }
}
function deepmergeOverride(base, drueber) { return mergeOverrideArrays(base, drueber); }
function deepmergeTest() {
  let o1 = { a: 1, c: 1 };
  let o2 = { a: 2, b: 2 };
  let o3 = deepmerge(o1, o2);
  logVals('___\no1', o1); logVals('o2', o2); logVals('o3', o3);
  o1.a = 11;
  logVals('___\no1', o1); logVals('o2', o2); logVals('o3', o3);
  o2.a = 22;
  logVals('___\no1', o1); logVals('o2', o2); logVals('o3', o3);
  o3.a = 33;
  logVals('___\no1', o1); logVals('o2', o2); logVals('o3', o3);
}
function deepmergeTestArray() {
  let o1 = { a: 1, b: [1, 2, 3], c: 1 };
  let o2 = { a: 2, b: [2, 3, 4, 5] };
  let o3 = deepmerge(o1, o2);
  logVals('___\no1', o1); logVals('o2', o2); logVals('o3', o3);
  o3 = mergeOverrideArrays(o1, o2);
  logVals('___\no1', o1); logVals('o2', o2); logVals('o3', o3);
  o3 = safeMerge(o1, o2);
  logVals('___\no1', o1); logVals('o2', o2); logVals('o3', o3);
}
function default_allowDrop(ev) { ev.preventDefault(); }
function default_item_serializer(o) { return copyKeys(o, {}, { live: true }); }
function defaultArrayMerge(target, source, optionsArgument) {
  var destination = target.slice()
  source.forEach(function (e, i) {
    if (typeof destination[i] === 'undefined') {
      destination[i] = cloneIfNecessary(e, optionsArgument)
    } else if (isMergeableObject(e)) {
      destination[i] = deepmerge(target[i], e, optionsArgument)
    } else if (target.indexOf(e) === -1) {
      destination.push(cloneIfNecessary(e, optionsArgument))
    }
  })
  return destination
}
function defaultPresentationNode(oid, o, R) {
  let nrep = {};
  let objLists = getElementLists(o);
  if (isEmpty(objLists)) {
    let litProp = firstCondDictKV(o, (k, v) => k != 'obj_type' && isLiteral(v));
    let content = litProp ? o[litProp] : o.obj_type + ' ' + oid;
    nrep = { type: 'info', data: content };
  } else {
    let key1 = Object.keys(objLists)[0];
    let list1 = Object.values(objLists)[0];
    console.log('defaultPresentationNode1: first list is:', key1, list1);
    nrep = { type: 'list', pool: list1, elm: '.' + key1 };
  }
  return nrep;
}
function defaultUIFunc(mk) {
  let el = mk.elem = mCreate('div');
  el.style.backgroundColor = randomColor();
  el.innerHTML = formatJson(mk.o);
  el.style.textAlign = 'left';
}
function defaultVisualExists(oid) { return firstCond(oid2ids[oid], x => x[0] == 'd'); }
function degrade_bars(dec) {
  let res = {};
  for (const color in DA.bars) {
    let bar = DA.bars[color];
    let val = Math.max(0, bar.w - dec);
    set_new_goal(color, val, 1);
    res[color] = val;
  }
  return res
}
function delete_current_table() {
  if (nundef(Session.cur_tid)) return;
  to_server(Session.cur_tid, 'delete_table');
  Session.cur_tid = null;
  Session.cur_table = null;
}
function delete_message(e) {
  if (confirm("Are you sure you want to delete this message??")) {
    var msgid = e.target.getAttribute("msgid");
    get_data({
      rowid: msgid
    }, "delete_message");
    get_data({
      username: CURRENT_CHAT_USER,
      seen: SEEN_STATUS
    }, "chats_refresh");
  }
}
function delete_table(friendly) { stop_game(); phpPost({ friendly: friendly }, 'delete_table'); }
function delete_thread(e) {
  if (confirm("Are you sure you want to delete this whole thread??")) {
    get_data({
      username: CURRENT_CHAT_USER
    }, "delete_thread");
    get_data({
      username: CURRENT_CHAT_USER,
      seen: SEEN_STATUS
    }, "chats_refresh");
  }
}
function deleteActions() { deleteAll('d', 'a'); }
function deleteAll(rsgType, idoType) {
  let ids = IdOwner[idoType];
  ids = isdef(IdOwner[idoType]) ? IdOwner[idoType].filter(x => x[0] == rsgType) : []; for (const id of ids) deleteRSG(id);
}
function deleteDefaultObjects() { deleteAll('d', 't'); }
function deleteDefaultPlayers() { deleteAll('d', 'p'); }
function deleteOid(oid) {
  let uids = jsCopy(oid2ids[oid]);
  for (const uid of uids) {
    if (uid[2] == 'r' || uid[2] == 'l') continue;
    if (UIS[uid]) deleteRSG(uid);
  }
}
function deleteRSG(id) {
  let mobj = UIS[id];
  if (nundef(mobj)) {
    error('object that should be deleted does NOT exist!!!! ' + id);
  }
  unhighlightMsAndRelatives(null, mobj)
  unlink(id);
  _deleteFromOwnerList(id);
  mobj.destroy();
  DELETED_IDS.push(id);
  DELETED_THIS_ROUND.push(id);
  delete UIS[id];
}
function deltaTransformPoint(matrix, point) {
  var dx = point.x * matrix.a + point.y * matrix.c + 0;
  var dy = point.x * matrix.b + point.y * matrix.d + 0;
  return { x: dx, y: dy };
}
function describe(d) {
  console.log('_________________');
  console.log('innerHTML', d.innerHTML);
  console.log('firstChild', d.firstChild);
  console.log('d', d)
}
function DeSelectSq(sq) {
  $('.Square').each(function (index) {
    if (PieceIsOnSq(sq, $(this).position().top, $(this).position().left) == BOOL.TRUE) {
      $(this).removeClass('SqSelected');
    }
  });
}
function DeselectSq(sq) {
  if (GameController.BoardFlipped == BOOL.TRUE) {
    sq = MIRROR120(sq);
  }
  $(".Square").each(function (index) {
    if ((RanksBrd[sq] == 7 - Math.round($(this).position().top / 60)) && (FilesBrd[sq] == Math.round($(this).position().left / 60))) {
      $(this).removeClass('SqSelected');
    }
  });
}
function destroyInfoboxFor(oid) { let id = makeIdInfobox(oid); if (UIS[id]) deleteRSG(id); }
function destroySudokuRule(pattern, rows, cols) {
  let sz = Math.min(rows, cols);
  let [r1, r2] = choose(range(0, sz - 1), 2);
  let c = chooseRandom(range(0, sz - 1));
  if (coin(50)) { arrSwap2d(pattern, r1, c, r2, c); }
  else if (coin(50)) { arrSwap2d(pattern, c, r1, c, r2); }
}
function detect_size_from_styles(st = {}, defsize = 50) {
  return [valf(st.w, st.sz, defsize), valf(st.w, st.sz, defsize)];
}
function detectArea(dParent, w, h) {
  let rect = isdef(dParent) ? getRect(dParent) : null;
  if (nundef(w)) { w = rect ? rect.w : window.innerWidth; }
  if (nundef(h)) { h = rect ? rect.h : window.innerHeight; }
  return [w, h];
}
function detectBoard(soDict, loc) {
  timit.showTime('*** board start ***')
  let idBoard = firstCondDict(soDict, x => isBoardObject(x));
  if (isdef(idBoard)) {
    let sBoard = soDict[idBoard];
    let idField0 = sBoard.fields._set[0]._obj;
    let f0 = soDict[idField0];
    let numNei = f0.neighbors.length;
    if (numNei == 6) return _hexGrid(loc, idBoard, sBoard, soDict); else return _quadGrid(loc, idBoard, sBoard, soDict);
  }
  return null;
}
function detectBoardOidAndType(oid, boardType, R) {
  if (!oid) oid = detectFirstBoardObject(R);
  let oBoard = R.getO(oid);
  if (!boardType) boardType = detectBoardType(oBoard, R);
  let fids = getElements(oBoard.fields);
  let r0 = 1000; let c0 = 1000;
  for (const fid of fids) {
    let f = R.getO(fid);
    if (f.row < r0) r0 = f.row;
    if (f.col < c0) c0 = f.col;
  }
  return [oid, boardType, r0, c0];
}
function detectBoardParams(n, R) {
  let allParams = {};
  let boardDefs = R.defs.grid;
  if (isdef(boardDefs)) {
    let specific = R.defs[n.boardType];
    if (isdef(specific)) boardDefs = deepmerge(boardDefs, specific);
    if (isdef(boardDefs.params)) {
      if (isdef(n.params)) allParams = deepmerge(boardDefs.params, n.params);
      else allParams = boardDefs.params;
    }
  }
  n.bi.params = { fields: {}, corners: {}, edges: {} };
  let justBoardParams = jsCopy(allParams);
  for (const name of ['fields', 'corners', 'edges']) {
    n.bi.params[name] = justBoardParams[name];
    delete justBoardParams[name];
  }
  return justBoardParams;
}
function detectBoardType(oBoard, R) {
  let fid0 = getElements(oBoard.fields)[0];
  let nei = R.getO(fid0).neighbors;
  let len = nei.length;
  return len == 6 ? 'hexGrid' : 'quadGrid';
}
function detectDecks(tableObjects, areaName) {
  let deckKeys = allCondDict(tableObjects, x => isDeckObject(x)); if (isEmpty(deckKeys)) return null;
  S.settings.hasCards = true;
  let deckArea = makeDeckArea(areaName, deckKeys.length);
  let msDecks = deckKeys.map(x => makeDeckSuccess(x, tableObjects[x], deckArea.id));
  lineupDecks(msDecks, deckArea);
  return deckKeys;
}
function detectFirstBoardObject(R) {
  for (const oid in R._sd) {
    let o = R.getO(oid);
    if (isdef(o.map) && isdef(o.fields)) return oid;
  }
}
function detectItemInfoKey(itemInfoKey) {
  let item, info, key;
  if (isString(itemInfoKey)) { key = itemInfoKey; info = Syms[key]; item = { info: info, key: key }; }
  else if (isDict(itemInfoKey)) {
    if (isdef(itemInfoKey.info)) { item = itemInfoKey; info = item.info; key = item.info.key; }
    else { info = itemInfoKey; key = info.key; item = { info: info, key: key }; }
  }
  return [item, info, key];
}
function detectItems(n) {
  if (isNumber(n)) n = choose(SymKeys, n);
  if (isString(n[0])) n = n.map(x => Syms[x]);
  if (nundef(n[0].info)) n = n.map(x => infoToItem(x));
  return n;
}
function detectSilben(words) {
  const syllableRegex = /[^aeiouy]*[aeiouy]+(?:[^aeiouy]*$|[^aeiouy](?=[^aeiouy]))?/gi;
  return words.match(syllableRegex);
}
function detectSymbolKey(o) {
  if (isdef(o.name)) return o.name;
  let res = null;
  for (const k in o) {
    if (!isLiteral(o[k]) || k == 'obj_type') continue;
    if (k.toLowerCase().includes('name') && isString(o[k])) return o[k];
  }
  let k = firstCondDict(o, x => isLiteral(o[k]));
  if (isdef(k)) return o[k];
}
function detectType(id) {
  let el = document.getElementById(id);
  return getTypeOf(el);
}
function determine_church_turn_order() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  let initial = [];
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    pl.vps = ari_calc_fictive_vps(fen, plname);
    pl.max_journey_length = ari_get_max_journey_length(fen, plname);
    pl.score = pl.vps * 10000 + pl.max_journey_length * 100 + pl.coins;
    initial.push(pl);
  }
  let sorted = sortByDescending(initial, 'score');
  return sorted.map(x => x.name);
}
function diContent(item) { return isdef(item.live) ? item.live.dContent : null; }
function dict_augment(di, o) { addKeys(o, di); return di; }
function dict_remove(di, keys) {
}
function dict2list(d, keyName = 'id') {
  let res = [];
  for (const key in d) {
    let val = d[key];
    let o;
    if (isDict(val)) { o = jsCopy(val); } else { o = { value: val }; }
    o[keyName] = key;
    res.push(o);
  }
  return res;
}
function dict2olist(d, keyName = 'id') {
  let res = [];
  for (const key in d) {
    let val = d[key];
    let o;
    if (isDict(val)) { o = jsCopy(val); }
    else {
      o = { value: val };
    }
    o[keyName] = key;
    res.push(o);
  }
  return res;
}
function dicti(areaName, oSpec, oid, o) {
  let [num, or, split, bg, fg, id, panels, parent] = getParams(areaName, oSpec, oid);
  parent.style.display = 'inline-grid';
  return parent;
}
function dictOrListToString(x, ifDict = 'keys') {
  let lst = x;
  if (isList(lst) && !isEmpty(lst)) { return lst.join(' '); }
  else if (isDict(lst)) {
    return ifDict == 'keys' ? Object.keys(lst).join(' ')
      : ifDict == 'values' ? Object.keys(lst).join(' ')
        : Object.entries(lst).join(' ');
  }
  else return null;
}
function dictToKeyList(x) { return Object.keys(lst).join(' '); }
function dictToKVList(x) { return Object.entries(lst).join(' '); }
function dictToValueList(x) { return Object.values(lst).join(' '); }
function differInAtMost(req, given, n = 1) {
  let diffs = levDist(req, given);
  return diffs <= n;
}
function diMessage(item) { return isdef(item.live) ? item.live.dMessage : null; }
function disable_bar_ui() {
  for (const k in DA.bars) {
    let bar = DA.bars[k];
    let b = bar.cont.getElementsByTagName('button')[0];
    b.disabled = true;
  }
}
function disable_sidebar() { close_sidebar(); }
function disableButton(id) { disableStyle(id); }
function disableButtonsForMultiplayerGame() {
  if (isReallyMultiplayer) {
    if (iAmStarter()) enableButton('c_b_Restart'); else disableButton('c_b_Restart');
    disableButton('c_b_Step');
    disableButton('c_b_RunToEnd');
  }
}
function disableClick(el) {
  let mobj = 'mobj' in el ? el.mobj : el;
  mobj.clickHandler = null;
  mobj.disable();
}
function disableCreateButton() { disableButton('bCreateGame'); }
function disableHover(el) {
  let mobj = 'mobj' in el ? el.mobj : el;
  mobj.mouseEnterHandler = null;
  mobj.mouseLeaveHandler = null;
  mobj.disable();
}
function disableJoinButton() { disableButton('bJoinGame'); }
function disableResumeButton() {
  disableButton('bResumeGame');
}
function disableStyle(id) {
  if (isString(id)) id = document.getElementById(id);
  id.style.pointerEvents = 'none';
  id.style.opacity = .5;
  id.style.cursor = 'none';
}
function disappear(elem, msDuration = 1000, msStartAfter = 0) {
  if (isString(elem)) elem = mBy(elem);
  if (nundef(elem)) return;
  mStyle(elem, { overflow: 'hidden', animation: `disappear ${msDuration}ms ease` });
  setTimeout(() => { hide(elem); mStyle(elem, { animation: 'unset' }); }, msDuration);
}
function disconnectSocket() {
  if (Socket) { Socket.disconnect(); Socket = null; }
}
function displayWindowSize() {
  var w = document.documentElement.clientWidth;
  var h = document.documentElement.clientHeight;
  for (const msId in elements) {
    elements[msId].center();
  }
}
function distance(x1, y1, x2, y2) { return Math.sqrt(dSquare({ x: x1, y: y1 }, { x: x2, y: y2 })); }
function distribute_innerHTML(arr, s, sep = '') {
  let letters = s.split(sep);
  for (let i = 0; i < letters.length; i++) {
    let d = iDiv(arr[i]);
    let l = letters[i];
    if (l.length > 1) {
      l = '&#x' + l.substring(3) + ';';
    }
    d.innerHTML = l;
  }
  return;
  let i = 0; arr.map(x => { iDiv(x).innerHTML = s[i]; if (i < s.length - 1) i++; });
}
function diTitle(item) { return isdef(item.live) ? item.live.dTitle : null; }
function divInt(a, b) { return Math.trunc(a / b); }
function divKeyFromEv(ev) {
  let id = evToClosestId(ev);
  let div = mBy(id);
  return div.key;
}
function divscrolldown(id) {
  id = '#' + id;
  setTimeout(function () {
    $(id).animate(
      {
        scrollTop: $(id).offset().top
      },
      500
    );
  }, 200);
}
function dixit_activate(fen, plname) {
  console.log('activating for', plname)
}
function dixit_get_card(ckey, index, h = 200) {
  let filename = `${Basepath}assets/games/dixit/img${ckey}.jpg`;
  let clip = 50;
  let html = `<img src='${filename}' height='${h + clip}' style='clip-path:inset(0px 0px ${clip}px 0px)'></img>`;
  let d = mDiv(null, { rounding: 8, bg: 'blue', margin: 10, h: h, w: h * 141 / 200, overflow: 'hidden' }, null, html, 'card');
  mMagnifyOnHoverControl(d)
  let item = { key: ckey, index: index, div: d, html: html, h: h, faceUp: true };
  d.onclick = () => { face_up(item); };
  return item;
}
function dixit_present(fen, dParent, plname) {
  F = {};
  if (isdef(fen.story)) {
    F.story = ui_message(dParent, fen.story);
  }
  if (isdef(fen.instruction) && isdef(plname) && fen.plturn == plname) {
    let dTemp = mBy('dTemp');
    dTemp.style.display = 'block';
    mAppend(dParent, dTemp);
    dTempTitle.innerHTML = 'Write a story';
    dTempForm.onsubmit = ev => dixit_submit_story(mBy('dTempInput').value, ev);
  }
  if (isdef(fen.tablecards)) {
    let d = mDiv(dParent, { fg: 'white', bg: user.color, w: '100%' }, null, 'table'); mFlexWrap(d);
    pl.div = d;
    mLinebreak(d)
    let i = 0; let items = F.tablecards = fen.tablecards.map(x => { i++; return dixit_get_card(x, i) });
    for (const item of items) mAppend(d, iDiv(item));
  }
  let pls = F.players = {};
  for (const uname in fen.players) {
    let pl = pls[uname] = {};
    let fpl = fen.players[uname];
    console.log('dixit_present', user);
    let user = firstCond(Users, x => x.name == uname);
    copyKeys(user, pl)
    console.log('pl', uname, pl);
    if (isdef(plname) && uname != plname) continue;
    let d = mDiv(dParent, { fg: 'white', bg: user.color, w: '100%' }, null, uname); mFlexWrap(d);
    pl.div = d;
    mLinebreak(d)
    let i = 0; let items = pl.hand = fpl.hand.map(x => { i++; return dixit_get_card(x, i) });
    for (const item of items) mAppend(d, iDiv(item));
  }
}
function dixit_setup(players) {
  let fen = {};
  let deck = fen.deck = shuffle(range(0, 435));
  let pls = fen.players = {};
  for (const uname of players) {
    let pl = pls[uname] = {};
    pl.hand = deck_deal(deck, 7);
  }
  fen.plorder = rPlayerOrder(players);
  fen.turn = [fen.plorder[0]];
  fen.round = [];
  fen.iturn = 0;
  fen.phase = 'create';
  fen.instruction = 'write your story';
  return fen;
}
function dixit_submit_story(x, ev) {
  console.log('x', x, 'ev', ev)
}
function dlColor(factor, r, g, b) {
  testHelpers(r, g, b);
  let hsl = rgbToHsl(r, g, b);
  let hsv = hsl2hsv(...hsl);
  let h = hsv[0];
  let s = hsv[1];
  let v = hsv[2];
  v *= factor;
  hsl = hsv2hsl(h, s, v);
  let l = hsl[2];
  let sperc = s * 100;
  let lperc = l * 100;
  testHelpers('h,s,l,v:', h, s, l, v);
  return hslToHslaString(h, sperc, lperc);
}
function dm1(a, b, opt) {
  if (nundef(a)) return b;
  else if (nundef(b)) return a;
  else if (isLiteral(a)) return b;
  else if (isLiteral(b)) return a;
  else if (Array.isArray(b)) {
    return Array.isArray(a) ? mergeArr(a, b, opt) : cloneIfNecessary(b, opt);
  } else {
    return mergeObj(a, b, opt);
  }
}
async function DOCStart() {
  await loadAssets();
  createDocs();
}
async function documentFile(url) {
  let res = await fetchFileAsText(url);
  let regex = new RegExp('\nasync function|\nfunction|\nvar|\nconst|\nclass', 'g');
  let fcode = res.split(regex);
  let code = {};
  for (const w of fcode) {
    let trimmed = w.trim();
    let name = firstWord(trimmed);
    if (!isEmpty(name)) code[name] = trimmed;
  }
  let lines = res.split('\n');
  let i = 0;
  let iFunc = 0;
  let akku = {};
  let lastKey;
  let topComment = '';
  while (i < lines.length) {
    let result = skipToLine(lines, i, ['function', '/' + '/#r' + 'egion doc ']);
    if (nundef(result.option)) {
      break;
    } else if (result.option == 'function') {
      let line = lines[result.index];
      let lineTrimmed = line.trim();
      if (startsWith(lineTrimmed, 'function') || startsWith(lineTrimmed, 'async')) {
        let line1 = stringAfter(line, 'function ');
        if (line1.includes(')')) line1 = stringBefore(line1, ')').trim() + ')';
        let entry = akku[line1] = { name: firstWord(line1), index: iFunc, comments: '', path: url };
        if (isdef(code[entry.name])) entry.code = code[entry.name];
        iFunc += 1;
        lastKey = line1;
      }
    } else {
      let iStart = result.index + 1;
      let resend = skipToLine(lines, iStart, ['//#endregion']);
      let iEnd = resend.index;
      let block = copyLinesFromTo(lines, iStart, iEnd, '/*', '*/');
      if (lastKey) akku[lastKey].comments = block;
      else topComment = block;
      lastKey = null;
    }
    i = result.index + 1;
  }
  return { funcDict: akku, topComment: topComment };
}
async function documentVault(pathlist) {
  let res = {};
  for (const p of pathlist) {
    let fileInfo = await documentFile(p);
    res[p] = { filename: stringAfterLast(p, '/'), funcDict: fileInfo.funcDict, topComment: fileInfo.topComment };
  }
  return res;
}
function doit(secs, f, interval) {
  if (get_now() - DA.start < secs * 1000) setTimeout(() => { f(); doit(secs, f, interval); }, interval);
  else console.log('DONE!!!');
}
function dom(o, { loc, pool, params }) {
  console.log(o, loc, pool, params);
  let res = mCreate(params.tag ? params.tag : 'div');
  let sep = params.separator ? params.separator : ',';
  if (params.optin) res.innerHTML = params.optin.map(x => o.o[x]).join(sep);
  console.log('content:', res.innerHTML);
  return res;
}
function domId(id) { return document.getElementById(id) }
async function doNext(series, index, mexIndex) {
  recVerify(series, index + 1, maxIndex);
}
function doPerlenPoolChanges() {
  let s = G.perlenOptions;
  console.log('options:', s);
  Socket.emit('perlenOptions', s);
}
function dots(ms, n, { UL = false, UR = true, sz = 10, pos, dir, colors } = {}) {
  let dim = ms.bounds;
  let x, y, dx, dy;
  if (UR) {
    if (nundef(sz)) sz = dim.h / (2 * n);
    x = dim.w / 2 + -2 * sz;
    y = -dim.h / 2 + 2 * sz;
    dx = 0;
    dy = 2 * sz;
  } else if (UL) {
    return;
  }
  for (let i = 0; i < n; i++) {
    let color = isdef(colors) ? colors[i] : ms.fg;
    ms.circle({ sz: sz, x: x, y: y, fill: color });
    x += dx;
    y += dy;
  }
}
function download(jsonObject, fname) {
  json_str = JSON.stringify(jsonObject);
  saveFile(fname + '.json', 'data:application/json', new Blob([json_str], { type: '' }));
}
function download_all_functions() { downloadAsText(CODE.text, 'hallo', 'js'); }
function downloadAsText(s, filename, ext = 'txt') {
  saveFileAtClient(
    filename + "." + ext,
    "data:application/text",
    new Blob([s], { type: "" }));
}
function downloadAsYaml(o, filename) {
  let y = jsyaml.dump(o);
  downloadAsText(y, filename, 'yaml');
}
function downloadCodebase(superdi) {
  let text = '';
  for (const type of ['var', 'const', 'cla', 'func']) {
    let keys = get_keys(superdi[type]);
    if (type != 'const') sortCaseInsensitive(keys);
    for (const k of keys) {
      let code = superdi[type][k].code;
      if (!isEmptyOrWhiteSpace(code)) {
        text += code;
        if (code.trim() == '}') text += '\r\n';
      }
    }
  }
  downloadAsText(text, 'hallo', 'js');
  downloadAsYaml(superdi, 'hallo');
}
function downloadFile(jsonObject, filenameNoExt) {
  json_str = JSON.stringify(jsonObject);
  saveFileAtClient(
    filenameNoExt + ".json",
    "data:application/json",
    new Blob([json_str], { type: "" }));
}
function downloadHtmlFile(html, filenameNoExt) {
  saveFileAtClient(
    filenameNoExt + ".html",
    "data:application/html",
    new Blob([html], { type: "" }));
}
function downloadJson(o, filename) {
  if (filename.indexOf('.') < 0) filename = filename.json;
  let txt = (typeof o == 'object') ? encodeURIComponent(JSON.stringify(o)) : o;
  let dl = document.getElementById('downloadAnchorElement');
  if (nundef(dl)) dl = mCreateFrom(`<a id="downloadAnchorElem" style="display:none"></a>`);
  var dataStr = "data:text/json;charset=utf-8," + txt;
  dl.setAttribute("href", dataStr);
  dl.setAttribute("download", "_aaa\\scene.json");
  dl.click();
}
function downloadKeySet() {
  let keys = Pictures.filter(x => x.isSelected).map(x => x.info.key);
  downloadAsYaml(keys, 'keyset');
}
function downloadTextFile(s, filenameNoExt, ext = 'txt') {
  saveFileAtClient(
    filenameNoExt + "." + ext,
    "data:application/text",
    new Blob([s], { type: "" }));
}
function dPP(o, plist, R) {
  if (isEmpty(plist)) return o;
  if (isList(o) && isNumber(plist[0])) {
    let i = Number(plist[0]);
    return dPP(o[i], plist.slice(1), R);
  }
  if (!isDict(o)) {
    let o1 = R.getO(o);
    if (isdef(o1)) return dPP(o1, plist, R);
    console.log('dPP ERROR!!! o', o, 'plist', plist, '\no1', o1);
    return null;
  }
  let k1 = plist[0];
  let o1 = o[k1];
  if (nundef(o1)) return null;
  let plist1 = plist.slice(1);
  if (o1._set) {
    o1 = o1._set;
    if (plist1.length > 0 && isNumber(plist1[0])) {
      let i = Number(plist1[0]);
      return dPP(o1[i], plist1.slice(1), R);
    } else {
      return o1.map(x => dPP(x, plist1, R));
    }
  }
  if (o1._player) { o1 = R.getO(o1._player); }
  else if (o1._obj) { o1 = R.getO(o1._obj); }
  return dPP(o1, plist1, R);
}
function dPP1(o, plist, R) {
  if (isEmpty(plist)) {
    let res = isdef(o._player) ? [o._player] : isdef(o._obj) ? [o._obj] : o;
    return res;
  }
  if (isList(o) && isNumber(plist[0])) {
    let i = Number(plist[0]);
    return dPP1(o[i], plist.slice(1), R);
  }
  if (!isDict(o)) {
    let o1 = R.getO(o);
    if (isdef(o1)) return dPP1(o1, plist, R);
    console.log('dPP1 ERROR!!! o', o, 'plist', plist, '\no1', o1);
    return null;
  }
  let k1 = plist[0];
  let o1 = isdef(o._player) ? R.getO(o._player)[k1]
    : isdef(o._obj) ? R.getO(o._obj)[k1]
      : o[k1];
  if (nundef(o1)) return null;
  let plist1 = plist.slice(1);
  if (o1._set) {
    o1 = o1._set;
    if (plist1.length > 0 && !isNumber(plist1[0])) {
      return o1.map(x => dPP1(x, plist1, R));
    }
  }
  return dPP1(o1, plist1, R);
}
function drag(ev) {
  let elem = ev.target;
  dragStartOffset = getRelCoords(ev, $(elem));
  draggedElement = elem;
}
function dragKey(ev) {
  ev.dataTransfer.setData("text", ev.target.id);
  dragStartOffset = getRelCoords(ev, $(this));
}
function dragover_fritz(ev) {
  ev.preventDefault();
  ev.dataTransfer.dropEffect = "move";
  let target_id = evToClosestId(ev);
  let d = mBy(target_id);
  mStyle(d, { bg: 'red' });
  if (target_id == 'dOpenTable') {
  } else if (isdef(Items[target_id])) {
    let targetcard = Items[target_id];
    let targetgroup = Items[targetcard.groupid];
  } else {
  }
}
function dragStartPreventionOnSidebarOpen() {
  if (isdef(mBy('drop-region'))) {
    alert('please close sidebar (by DOUBLECLICK on it) before proceeding!');
    return false;
  }
  return true;
}
function dragX(ev) {
  let elem = ev.target;
  dragStartOffset = getRelCoordsX(ev, elem);
  draggedElement = elem;
}
function dragX2(ev) {
  let elem = ev.target;
  dragStartOffset = getRelCoordsX(ev, elem);
  draggedElement = elem;
}
function draw() {
  background(51);
  for (let i = 0; i < tree.length; i++) {
    tree[i].show();
    if (jittering) tree[i].jitter();
  }
  for (let i = 0; i < leaves.length; i++) {
    let l = leaves[i].current;
    noStroke();
    fill(0, 255, 100, 100);
    ellipse(l.x, l.y, 8, 8);
    if (jittering) leaves[i].current.y += random(0, 2);
  }
}
function draw_canvas(item) {
  let r = getRect(dTable);
  let c = mCanvas(d, { w: r.w, h: r.h, rounding: 0, bg: 'white' }); let [cv, cx] = [c.cv, c.cx];
  for (const item of items) {
    let d1 = item.div = cRect(item.x, item.y, item.w, item.h, { bg: item.bg }, cx);
  }
}
function draw_car(canvas, item) {
  let cx = canvas.cx;
  cRect(0 - item.w / 2, 0 - item.h / 2, item.w, item.h, { bg: item.color }, cx);
  cRect(item.w - item.w / 2, 0 - item.h / 2, 10, item.h, { bg: 'yellow' }, cx);
}
function draw_dom(item) {
  if (item.init) { item.init = false; iAdd(item, { div: mDiv(valf(dParent, item.container, dTable)) }); }
  if (item.refresh) { item.refresh = false; mStyle(iDiv(item.id), item.styles); }
}
function draw_from_deck_to(deck, arr) { top_elem_from_to(deck, arr); }
function draw_from_deck_to_board(deck, arr) { top_elem_from_to_top(deck, arr); }
function draw_gaussian(canvas, mean, stdev, color, thick, legendcolor, legend) {
  canvas.draw_axes();
  canvas.scale = 40;
  let f = gaussian_amp(canvas, 1)
  canvas.plot(f, color, thick);
  draw_ticks_gaussian(canvas, f, mean, stdev, legendcolor);
  draw_text(canvas, legend, { fg: legendcolor, pos: 'tr', hmargin: 25, vmargin: 12 });
}
function draw_label(canvas, item) {
  let cx = canvas.cx;
  cx.textAlign = 'center';
  cx.font = `${valf(item.fz, 16)}px Arial`;
  cx.fillStyle = item.color;
  cx.fillText(`  ${item.label}`, 0, 0);
}
function draw_on_canvas(cx, item) {
  if (isdef(item.draw)) { item.draw(cx, item); }
  else {
    cx.save();
    let st = item.styles;
    let [x, y, w, h, a, color] = [valf(st.x, 0), valf(st.y, 0), valf(st.w, 30), valf(st.h, 30), valf(st.a, 0), valf(st.bg, RED)];
    cx.translate(x, y);
    cx.rotate(toRadian(a));
    cEllipse(0, 0, w, h, { bg: colorFrom(color) }, 0, cx);
    cx.restore();
  }
}
function draw_on_div(dParent, item) {
  if (isdef(item.draw)) { item.draw(dParent, item); }
  else {
    let d = mDiv(dParent, item.styles);
    iAdd(item, { div: d });
  }
}
function draw_perlin_x(item) {
  let [cv, cx] = [item.live.cv, item.live.cx];
  cClear(cv, cx);
  let r = rPerlin(item.x);
  item.r = map_range(r, 0, 1, -item.w / 2, item.w / 2);
  cEllipse(item.r, 0, 25, 25, { bg: 'white' }, 0, cx);
  item.x += .02;
}
function draw_perlin_xy(item) {
  let [cv, cx] = [item.live.cv, item.live.cx];
  cClear(cv, cx);
  item.randx = valf(item.randx, 0) + .01;
  item.randy = valf(item.randy, 10000) + .02;
  item.x = map_range(rPerlin(item.randx), 0, 1, -item.w / 2, item.w / 2);
  item.y = map_range(rPerlin(item.randy), 0, 1, -item.h / 2, item.h / 2);
  cEllipse(item.x, item.y, 25, 25, { bg: 'white' }, 0, cx);
}
function draw_point(canvas, item) {
  let cx = canvas.cx;
  cx.font = `${valf(item.fz, 16)}px Arial`;
  cx.fillStyle = item.color;
  if (isdef(item.label)) cx.fillText(`  ${item.label}`, 0, 0);
  cEllipse(0, 0, item.w, item.h, { bg: item.color }, 0, cx);
}
function draw_random_walk(item) {
  let [cv, cx] = [item.live.cv, item.live.cx];
  cClear(cv, cx);
  cEllipse(rInc(item, 'x', -2, 2), rInc(item, 'y', -2, 2), 30, 20, { bg: 'blue', fg: 'green' }, 0, cx);
}
function draw_rect(canvas, item) {
  let cx = canvas.cx;
  cRect(0 - item.w / 2, 0 - item.h / 2, item.w, item.h, { bg: item.color }, cx);
}
function draw_set_card(dParent, info, card_styles) {
  let card = cLandscape(dParent, card_styles);
  card.info = info;
  let d = iDiv(card);
  mCenterCenterFlex(d);
  let sz = card.sz / 2.8;
  let bg, shape = info.shape, text;
  switch (info.shading) {
    case 'solid': bg = info.color; break;
    case 'gradient': bg = `linear-gradient(${info.color}, silver)`; break;
    case 'empty': bg = `repeating-linear-gradient(
      45deg,
      ${info.color},
      ${info.color} 10px,
      silver 10px,
      silver 20px
    )`; break;
  }
  mStyle(d, { bg: info.background });
  switch (info.text) {
    case 'none': text = null; break;
    case 'letter': text = randomLetter(); break;
    case 'number': text = '' + randomDigit(); break;
  }
  let styles = { w: sz, h: sz, margin: sz / 10 };
  for (let i = 0; i < info.num; i++) {
    let d1 = drawShape(shape, d, styles);
    if (info.shading == 'gradient') { d1.style.backgroundColor = info.color; mClass(d1, 'polka-dot'); } else mStyle(d1, { bg: bg });
    if (shape == 'circle') console.log('circle', d1);
    if (isdef(text)) { mCenterCenterFlex(d1); mText(text, d1, { fz: sz / 1.75, fg: 'black', family: 'impact' }); }
  }
  return card;
}
function draw_set_card_test(dParent) {
  let card = cLandscape(dParent, { w: 120 });
  let d = iDiv(card, { h: '100%' });
  mCenterCenterFlex(d);
  let sz = card.sz / 4;
  let styles = { w: sz, h: sz, bg: `linear-gradient(${RED},black`, margin: sz / 10, border: `solid 3px ${GREEN}` };
  let d1 = drawShape('circle', d, styles); mCenterCenterFlex(d1); mText('A', d1, { fz: sz / 4, fg: 'white' });
  drawShape('circle', d, styles);
  drawShape('circle', d, styles);
}
function draw_text(canvas, text, styles = {}) {
  let cx = canvas.cx;
  addKeys({ x: 0, y: 0, family: 'opensans', fz: 36 }, styles);
  styles.bg = styles.fg;
  styles.font = `${styles.fz}px ${styles.family}`;
  cStyle(styles, cx);
  let [x, y, offx, offy] = [styles.x, styles.y, valf(styles.hmargin, styles.margin, 4), valf(styles.vmargin, styles.margin, 4)];
  if (isdef(styles.pos)) {
    let pos = styles.pos;
    if (pos[0] == 't') {
      y += canvas.miny + offy;
      cx.textBaseline = 'hanging';
    } else if (pos[0] == 'c') {
      y += offy;
      cx.textBaseline = 'middle';
    } else {
      y += canvas.maxy - offy;
      cx.textBaseline = 'top';
    }
    if (pos[1] == 'l') {
      x += canvas.minx + offx;
      cx.textAlign = 'start';
    } else if (pos[1] == 'c') {
      x += offx;
      cx.textAlign = 'center';
    } else {
      x += canvas.maxx - offx;
      cx.textAlign = 'end';
    }
  } else {
    cx.textAlign = 'center';
    cx.textBaseline = 'middle';
  }
  if (isdef(styles.al)) {
    let a = ' ' + styles.al;
    console.log('a', a);
    cx.textAlign = a.includes(' s') ? 'start' : a.includes(' e') ? 'end' : a.includes(' r') ? 'right' : a.includes(' l') ? 'left' : 'center';
    cx.textBaseline = a.includes(' b') ? 'bottom' : a.includes(' t') ? 'top' : a.includes(' h') ? 'hanging' : a.includes(' a') ? 'alpjabetic' : a.includes(' i') ? 'ideographic' : 'middle';
  }
  if (isdef(styles.offy)) {
    if (isNumber(styles.offy)) y += styles.offy;
    else {
      let ws = toWords(styles.offy);
      let di = { below: 'hanging', above: 'bottom', ontop: 'bottom', onbottom: 'hanging', unterhalb: 'hanging', oberhalb: 'bottom', unten: 'hanging', oben: 'bottom' };
      for (const w of ws) {
        if (isNumber(w)) y += Number(w);
        else if (isdef(di[w])) cx.textBaseline = di[w];
        else if (w.length == 1) {
          cx.textBaseline = w == 'b' ? 'bottom' : w == 't' ? 'top' : w == 'a' ? 'alphabetic' : w == 'i' ? 'ideographic' : w == 'm' ? 'middle' : 'hanging';
        } else cx.textBaseline = w;
      }
    }
  }
  if (isdef(styles.offx)) {
    if (isNumber(styles.offx)) y += styles.offx;
    else {
      let ws = toWords(styles.offx);
      for (const w of ws) {
        if (isNumber(w)) x += Number(w);
        else if (w.length == 1) {
          cx.textAlign = w == 's' ? 'start' : w == 'e' ? 'end' : w == 'l' ? 'left' : w == 'r' ? 'right' : 'center';
        } else cx.textAlign = w;
      }
    }
  }
  console.log('x', x, 'y', y, 'elign', cx.textAlign, 'baseline', cx.textBaseline)
  cx.fillText(text, x, y);
}
function draw_ticks(canvas, f) {
  let sc = canvas.scale;
  let x_end = search_end_point(f, 0, canvas.maxx, 0.02);
  let y_end = f(x_end);
  canvas.pp(x_end * sc, -y_end * sc, `${Math.round(x_end * sc)}`, 'red', 'tc');
  console.log('endpoint x', x_end, 'y', y_end, canvas.minx, canvas.maxx);
  console.log('stdev', x_end / 3);
  let label = 100, dx = x_end / 3, x = 0;
  for (let i = 0; i <= 3; i++) {
    let x1 = Math.round(convert_to_range(x, -x_end, x_end, 50, 150));
    let x2 = Math.round(convert_to_range(-x, -x_end, x_end, 50, 150));
    canvas.pp(x * sc, 0, `${label + i * 15}`);
    if (x) canvas.pp(-x * sc, 0, `${label - i * 15}`);
    x += dx;
  }
}
function draw_ticks_gaussian(canvas, f, mean, dev, color) {
  let sc = canvas.scale;
  let x_end = search_end_point(f, 0, canvas.maxx, .005, .02);
  let dx = x_end / 3, x = 0;
  for (let i = 0; i <= 3; i++) {
    canvas.pp(x * sc, 0, `${mean + i * dev}`, { bg: color });
    if (x) canvas.pp(-x * sc, 0, `${mean - i * dev}`, { bg: color });
    x += dx;
  }
}
function drawBee(c) { return drawSym('bee', c); }
function drawBox() {
  c.lineWidth = 1;
  c.strokeRect(0.5, 0.5, canvas.width - 1, canvas.height - 1);
}
function drawcard(key, dParent, sz) {
  let d1;
  let card = ari_get_card(key, sz);
  mAppend(dParent, iDiv(card));
  let d = iDiv(card); mStyle(d, { position: 'relative', margin: 20 });
  let h = sz * .6;
  let w = h / 6.5;
  let left = sz >= 300 ? 7 : sz >= 200 ? 5 : sz >= 100 ? 3 : 3;
  let bottom = sz >= 300 ? 0 : sz >= 200 ? -1 : sz >= 100 ? -2 : -3;
  let matop = (sz - h) / 2;
  let html = `<img height=${sz / 3} src="./base/assets/images/icons/deco0.svg" style="transform:scaleX(-1);">`;
  d1 = mDiv(d, { position: 'absolute', bottom: bottom, left: left, opacity: .5 }, null, html);
  let dt = mDiv(d, { family: 'Algerian' }, null, 'luxury');
  mPlace(dt, 'tc', 0, '50%')
}
function drawCenteredBee(c) { return drawCenteredSym('bee', c); }
function drawCenteredPlainCircle(c) {
  let item = iContainer(dMain, { fz: 8, fg: 'black', bg: 'grey', padding: 1 });
  let d = iDiv(item);
  let rect = getRect(d);
  console.log('rect', rect)
  mPos(d, c.x - rect.w / 2, c.y - rect.h / 2);
  return item;
}
function drawCenteredSym(sym, c) {
  let item = mPic(sym, dMain, { w: 80, h: 80, box: true, fz: 25, rounding: '50%', vpadding: 14, hpadding: 4 });
  let d = iDiv(item);
  let rect = getRect(d);
  console.log('rect', rect)
  mPos(d, c.x - rect.w / 2, c.y - rect.h / 2);
  return item;
}
function drawCircle() {
  c.beginPath();
  c.arc(circle.x, circle.y, radius - lineWidth / 2, 0, 2 * Math.PI, false);
  c.fillStyle = '00F0FF';
  c.fill();
  c.lineWidth = 4;
  c.strokeStyle = 'black';
  c.stroke();
}
function drawColoredCircle(canvas, sz, color, stroke = 'black') {
  var context = canvas.getContext('2d');
  var centerX = canvas.width / 2;
  var centerY = canvas.height / 2;
  var radius = sz / 2;
  context.beginPath();
  context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
  context.fillStyle = color;
  context.fill();
}
function drawElems(idlist) {
  for (const id of idlist) {
    EID[id].ms.draw();
  }
}
function drawFlatHex(dParent, styles, classes, sizing) {
  if (nundef(styles)) styles = { w: 100, h: 100, bg: 'blue' };
  if (nundef(classes)) classes = ['frameOnHover'];
  if (nundef(sizing)) sizing = { hgrow: true, wgrow: true };
  let d = mDiv(dParent, styles, null, null, classes, sizing);
  mStyle(d, { 'clip-path': 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)' });
  return d;
}
function drawHex(dParent, styles, classes, sizing) {
  if (nundef(styles)) styles = { w: 100, h: 100, bg: 'blue' };
  if (nundef(classes)) classes = ['frameOnHover'];
  if (nundef(sizing)) sizing = { hgrow: true, wgrow: true };
  let d = mDiv(dParent, styles, null, null, classes, sizing);
  mStyle(d, { 'clip-path': 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)' });
  return d;
}
function drawLineToMouse() {
  c.lineWidth = 2;
  c.moveTo(circle.x, circle.y);
  c.lineTo(mouse.x, mouse.y);
  c.stroke();
}
function drawloop() { G.items.map(x => { if (isdef(x.draw)) x.draw(x); }); }
function DrawMaterial() {
  if (brd_pceNum[PIECES.wP] != 0 || brd_pceNum[PIECES.bP] != 0) return BOOL.FALSE;
  if (brd_pceNum[PIECES.wQ] != 0 || brd_pceNum[PIECES.bQ] != 0 || brd_pceNum[PIECES.wR] != 0 || brd_pceNum[PIECES.bR] != 0) return BOOL.FALSE;
  if (brd_pceNum[PIECES.wB] > 1 || brd_pceNum[PIECES.bB] > 1) { return BOOL.FALSE; }
  if (brd_pceNum[PIECES.wN] > 1 || brd_pceNum[PIECES.bN] > 1) { return BOOL.FALSE; }
  if (brd_pceNum[PIECES.wN] != 0 && brd_pceNum[PIECES.wB] != 0) { return BOOL.FALSE; }
  if (brd_pceNum[PIECES.bN] != 0 && brd_pceNum[PIECES.bB] != 0) { return BOOL.FALSE; }
  return BOOL.TRUE;
}
function drawPlainCircle(c) {
  let item = mPic('heart', dMain, { fz: 8, bg: 'red', rounding: '50%', padding: 1 });
  mPos(iDiv(item), c.x, c.y);
  return item;
}
function drawShape(key, dParent, styles, classes, sizing) {
  if (nundef(styles)) styles = { w: 96, h: 96, bg: 'random' };
  if (nundef(sizing)) sizing = { hgrow: true, wgrow: true };
  let d = mDiv(dParent, styles, null, null, classes, sizing);
  if (key == 'circle' || key == 'ellipse') mStyle(d, { rounding: '50%' });
  else mStyle(d, { 'clip-path': PolyClips[key] });
  return d;
}
function drawSym(sym, c) {
  let item = mPic(sym, dMain, { fz: 25, bg: 'skyblue', rounding: '50%', padding: 4 });
  mPos(iDiv(item), c.x, c.y);
  return item;
}
function drawTest(board, num) {
  clearElement(board.elem);
  let d = 10;
  let coll = [];
  for (let row = 0; row < board.h; row += d) {
    for (let col = 0; col < board.w; col += d) {
      let y = row - board.h / 2 + d / 2;
      let x = col - board.w / 2 + d / 2;
      let mobj = makeDrawingElement('el1', 'board');
      mobj.x = x; mobj.y = y;
      coll.push(mobj);
    }
  }
  timit.showTime('nach compute: number of elements=' + coll.length);
  const colors = ['red', 'green', 'yellow', 'blue', 'orange', 'violet', 'skyblue', 'sienna'];
  let keys = Object.keys(iconChars);
  let numPictos = Math.min(coll.length, keys.length);
  for (let i = 0; i < numPictos; i++) {
    let mobj = coll[i];
    let c = chooseRandom(colors);
    let key = keys[i];
    mobj._picto(key, mobj.x, mobj.y, d, d, c);
    //   let key = keys[i];//chooseRandom(Object.keys(faIcons));//'clock';
  }
  timit.showTime('nach shape');
  for (const mobj of coll) {
    mobj.attach();
  }
  timit.showTime('nach attach');
  if (num > 0) setTimeout(() => drawTest(board, num - 1), 0);
  else return coll;
}
function drawText(text, c) {
  let item = mText(text, dMain, { fz: 16, bg: 'skyblue', rounding: '50%', padding: 4 });
  mPos(iDiv(item), c.x, c.y);
  return item;
}
function drawTriangle(dParent, styles, classes, sizing) {
  if (nundef(styles)) styles = { w: 100, h: 100, bg: 'blue' };
  if (nundef(classes)) classes = ['frameOnHover'];
  if (nundef(sizing)) sizing = { hgrow: true, wgrow: true };
  let d = mDiv(dParent, styles, null, null, classes, sizing);
  mStyle(d, { 'clip-path': 'polygon(50% 0%, 100% 100%, 0% 100%)' });
  return d;
}
function drop(ev) {
  ev.preventDefault();
  let targetElem = findDragTarget(ev);
  targetElem.appendChild(draggedElement);
  setDropPosition(ev, draggedElement, targetElem, isdef(draggedElement.dropPosition) ? draggedElement.dropPosition : dropPosition);
}
function drop_card_fritz(ev) {
  ev.preventDefault();
  evNoBubble(ev);
  if (isdef(mBy('ddhint'))) mRemove(mBy('ddhint'));
  var data = ev.dataTransfer.getData("text");
  let card = Items[data];
  let target_id = evToClosestId(ev);
  if (card.source == 'discard') {
    let [discard, loose] = arrSplitAtIndex(UI.deck_discard.items, card.index);
    c = loose[0];
    loose = loose.slice(1);
    assertion(c == card, 'NEEEEEEEE');
    for (const c of loose) {
      console.log('card', c.key, 'source', c.source)
      if (c.source == 'discard') frnew(c, { target: 'dummy' });
    }
  }
  if (target_id == 'dOpenTable') {
    frnew(card, ev);
  } else if (isdef(Items[target_id])) {
    let targetcard = Items[target_id];
    let targetgroup = Items[targetcard.groupid];
    fradd(card, targetgroup, targetcard);
  } else {
  }
}
function drop_old(ev) {
  if (ev.cancel) return;
  ev.preventDefault();
  var data = ev.dataTransfer.getData("text");
  let dElem = document.getElementById(data);
  let dTarget1 = ev.target;
  let targetElem = dTarget1;
  while (!targetElem.ondragover) targetElem = targetElem.parentNode;
  targetElem.appendChild(dElem);
  console.log('dropping', dElem.id, 'onto', targetElem.id);
  var elm = $(targetElem);
  x = ev.pageX - elm.offset().left - dragStartOffset.x;
  y = ev.pageY - elm.offset().top - dragStartOffset.y;
  posXY(dElem, targetElem, x, y);
  ev.cancel = true;
}
function dropAndEval(ev) {
  cancelBubble = true;
  let els = allElementsFromPoint(ev.clientX, ev.clientY);
  if (nundef(DragElem)) return;
  let targetItem = DropZoneItem = firstCond(DropZoneItems, x => els.includes(iDiv(x)));
  if (nundef(targetItem)) { cancelDD(); return; }
  let droppedItem = DragSourceItem;
  addLabel1(targetItem, droppedItem.label);
  cancelDD();
}
function dropDD(ev) {
  ev.stopPropagation();
  ev.preventDefault();
  var data = ev.dataTransfer.getData("text");
  let dElem = document.getElementById(data);
  let targetElem = ev.target;
  while (!targetElem.ondragover) targetElem = targetElem.parentNode;
  if (isdef(dElem.dd) && dElem.dd != targetElem.dd) {
    console.log('wrong association dd', dElem.dd, targetElem.dd);
    return;
  }
  targetElem.appendChild(dElem);
  console.log('dropping', dElem.id, 'onto', targetElem.id);
  var elm = $(targetElem);
  x = ev.pageX - elm.offset().left - dragStartOffset.x;
  y = ev.pageY - elm.offset().top - dragStartOffset.y;
  posXY(dElem, targetElem, x, y);
  ev.cancel = true;
}
function dropKey(ev) {
  ev.stopPropagation();
  ev.preventDefault();
  var data = ev.dataTransfer.getData("text");
  let dElem = document.getElementById(data);
  let targetElem = ev.target;
  while (!targetElem.ondragover) targetElem = targetElem.parentNode;
  if (isdef(dElem.dd) && dElem.dd != targetElem.dd) {
    console.log('wrong association dd', dElem.dd, targetElem.dd);
    return;
  }
  targetElem.appendChild(dElem);
  console.log('dropping', dElem.id, 'onto', targetElem.id);
  var elm = $(targetElem);
  x = ev.pageX - elm.offset().left - dragStartOffset.x;
  y = ev.pageY - elm.offset().top - dragStartOffset.y;
  posXY(dElem, targetElem, x, y);
  ev.cancel = true;
}
function dropLast(s) { return s.substring(0, s.length - 1); }
function dropX(ev) {
  ev.preventDefault();
  let targetElem = findDragTarget(ev);
  if (nundef(draggedElement.dropPosition) || typeof (draggedElement.dropPosition) != 'function') targetElem.appendChild(draggedElement);
  setDropPosition(ev, draggedElement, targetElem, isdef(draggedElement.dropPosition) ? draggedElement.dropPosition : dropPosition);
}
function dropX2(ev) {
  ev.preventDefault();
  let targetElem = findDragTarget(ev);
  if (nundef(draggedElement.dropPosition) || typeof (draggedElement.dropPosition) != 'function') targetElem.appendChild(draggedElement);
  setDropPosition(ev, draggedElement, targetElem, isdef(draggedElement.dropPosition) ? draggedElement.dropPosition : dropPosition);
}
function dSquare(pos1, pos2) {
  let dx = pos1.x - pos2.x;
  dx *= dx;
  let dy = pos1.y - pos2.y;
  dy *= dy;
  return dx + dy;
}
function dummy_reaction(ev) { console.log('clicked', ev.target) }
function dump(...arr) {
  for (const a of arr) {
  }
}
function dynamicArea(areaName, oSpec, oid, o) {
  func = correctFuncName(oSpec.type);
  oSpec.ui = window[func](areaName, oSpec, oid, o);
}
function each_hand_of_one(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    pl.hand = [rChoose(['4Hn', '5Hn', 'QHn', 'KHn', 'AHn'])];
    pl.goals['33'] = true; pl.roundgoal = '33';
    pl.journeys.push(['4Hn', '4Sn', '*Hn'], ['5Hn', '5Sn', '*Hn'], ['QHn', 'QSn', '*Hn']);
  }
  fen.players[uplayer].hand = ['4Cn'];
}
function editableUsernameUi(dParent) {
  let inp = mEditableInput(dParent, 'user: ', Username);
  inp.id = 'spUser';
  inp.addEventListener('focusout', () => { changeUserTo(inp.innerHTML.toLowerCase()); });
  return inp;
}
async function editLayoutTests() {
  DB = await route_path_yaml_dict('./PERLENDATA/data.yaml');
  lastState = await route_path_yaml_dict('./PERLENDATA/lastState.yaml');
  G = { settings: lastState.settings, dParent: dTable, clientBoard: {} };
  applyStandard(G.dParent, G.settings);
  onClickEditLayout();
}
function einhaengen(oid, o, R) {
  let topUids;
  let success = false;
  let successKeys = [];
  for (const key of R.getR(oid)) {
    let specNode = R.getSpec(key);
    if (o.loc && nundef(R.Locations[key]) && nundef(specNode._ref)) {
      if (nundef(R.Locations[key])) {
        topUids = addOidByLocProperty(oid, key, R);
      } else {
        console.log('impossible to add!!! key bound to location', R.locations[key]);
      }
    } else if (isdef(R.Locations[key])) {
      topUids = addOidByParentKeyLocation(oid, key, R);
    } else {
      topUids = [];
    }
    if (isEmpty(topUids)) { continue; }
    else { successKeys.push(key); success = true; }
    for (const top of topUids) {
      let uiParent = R.uiNodes[top.uidParent];
      let rParent = R.rNodes[top.uidParent];
      if (isdef(uiParent)) {
        uiParent.adirty = true;
        uiParent.children = rParent.children.map(x => x);
      }
      recUi(R.rNodes[top.uid], R, top.uidParent, oid, key);
    }
  }
  return success ? successKeys : false;
}
function elem_from_to(el, arr1, arr2) { removeInPlace(arr1, el); arr2.push(el); }
function elem_from_to_top(el, arr1, arr2) { removeInPlace(arr1, el); arr2.unshift(el); }
function ellipsis(text, font, width, padding) {
  let textLength = getTextWidth(text, font);
  let ellipsisLength = 0;
  ellipsisLength = getTextWidth('...', font);
  let maxw = width - 2 * padding;
  while (textLength + ellipsisLength > maxw && text.length > 0) {
    text = text.slice(0, -1).trim();
    textLength = getTextWidth(text, font);
  }
  return ellipsisLength > 0 ? text + '...' : text;
}
function empty(arr) {
  let result = arr === undefined || !arr || (isString(arr) && (arr == 'undefined' || arr == '')) || (Array.isArray(arr) && arr.length == 0) || emptyDict(arr);
  testHelpers(typeof arr, result ? 'EMPTY' : arr);
  return result;
}
function empty_func(x) { nundef(x) || x == ' '; }
function emptyCard() {
  return cardFace({ key: 'empty' });
}
function emptyDict(obj) {
  let test = Object.entries(obj).length === 0 && obj.constructor === Object;
  return test;
}
function emptyTarget(val) {
  return Array.isArray(val) ? [] : {}
}
function enableButton(id) { enableStyle(id) }
function enableClick(el, handler) {
  let mobj = 'mobj' in el ? el.mobj : el;
  mobj.clickHandler = handler;
  mobj.enable();
}
function enableCreateButton() { enableButton('bCreateGame'); }
function enableDD(sources, targets, dropHandler, isCopy, clearTarget, dragStartHandler) {
  DDInfo = { sources: sources, targets: targets, dropHandler: dropHandler, dragStartHandler };
  let sourceDivs = sources.map(x => iDiv(x));
  for (let i = 0; i < sources.length; i++) {
    let source = sources[i];
    let d = sourceDivs[i];
    d.onmousedown = (ev) => ddStart(ev, source, isCopy, clearTarget);
  }
}
function enableDragForDeck(d) {
  d.cards.forEach(function (card, i) {
    card.enableDragging();
  });
}
function enableFlipForDeck(d) {
  d.cards.forEach(function (card, i) {
    card.enableFlipping();
  });
}
function enableHover(el, enterHandler, leaveHandler) {
  let mobj = 'mobj' in el ? el.mobj : el;
  mobj.mouseEnterHandler = enterHandler;
  mobj.mouseLeaveHandler = leaveHandler;
  mobj.enable();
}
function enableJoinButton() { enableButton('bJoinGame'); }
function enableResumeButton() {
  enableButton('bResumeGame');
}
function enableStyle(id) {
  if (isString(id)) id = document.getElementById(id);
  id.style.pointerEvents = null;
  id.style.opacity = 1;
  id.style.cursor = 'pointer';
}
function end_of_round_ferro() {
  let [plorder, stage, A, fen, uplayer] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer];
  calc_ferro_score(uplayer);
  if (Z.options.phase_order == 'anti') {
    for (const plname of plorder) {
      let pl = fen.players[plname];
      if (!pl.roundgoal) pl.goals[get_round_goal()] = true;
    }
  }
  ari_history_list([`${uplayer} wins the round`], 'round');
  fen.round_winner = uplayer;
  [Z.stage, Z.turn] = ['round_end', [Z.host]];
  take_turn_fen();
}
function end_of_round_fritz(plname) {
  let [A, fen, uplayer, plorder] = [Z.A, Z.fen, Z.uplayer, Z.plorder];
  let pl = fen.players[uplayer];
  calc_fritz_score();
  ari_history_list([`${plname} wins the round`], 'round over');
  fen.round_winner = plname;
  plorder = fen.plorder = jsCopy(fen.roundorder);
  if (Z.round >= fen.maxrounds) {
    fen.winners = find_players_with_min_score();
    ari_history_list([`game over: ${fen.winners.join(', ')} win${fen.winners.length == 1 ? 's' : ''}`], 'game over');
    Z.stage = 'game_over';
    console.log('end of game: stage', Z.stage, '\nplorder', fen.plorder, '\nturn', Z.turn);
  } else {
    let starter = fen.starter = get_next_in_list(fen.starter, plorder);
    console.log('starter', starter);
    Z.turn = [starter];
    Z.round += 1;
    fritz_new_table(fen, Z.options);
    fritz_new_player_hands(fen, Z.turn[0], Z.options);
  }
}
function end_of_turn_fritz() {
  //#region prelim
  let [A, fen, uplayer, plorder] = [Z.A, Z.fen, Z.uplayer, Z.plorder];
  let pl = fen.players[uplayer];
  clear_quick_buttons();
  let ms = fen.players[uplayer].time_left = stop_timer();
  //#endregion
  //#region TJ group processing
  let ploose = {};
  fen.journeys = [];
  fen.loosecards = [];
  for (const plname in fen.players) { fen.players[plname].loosecards = []; }
  for (const group of DA.TJ) {
    let ch = arrChildren(iDiv(group));
    let cards = ch.map(x => Items[x.id]);
    let set = Z.options.overlapping == 'yes' ? is_overlapping_set(cards, Z.options.jokers_per_group, 3, false)
      : ferro_is_set(cards, Z.options.jokers_per_group, 3, false);
    if (!set) {
      for (const card of cards) {
        if (is_joker(card)) {
          fen.loosecards.push(card.key);
          continue;
        }
        let owner = valf(card.owner, uplayer);
        lookupAddToList(ploose, [owner], card.key);
      }
    } else {
      let j = set;
      fen.journeys.push(j);
    }
  }
  for (const plname in ploose) {
    fen.players[plname].loosecards = ploose[plname];
  }
  let discard = UI.deck_discard.items.filter(x => x.source == 'discard');
  fen.deck_discard = discard.map(x => x.key);
  if (!isEmpty(A.selected)) {
    let ui_discarded_card = A.selected.map(x => A.items[x].o)[0];
    removeInPlace(UI.players[uplayer].hand.items, ui_discarded_card);
    ckey = ui_discarded_card.key;
    elem_from_to(ckey, fen.players[uplayer].hand, fen.deck_discard);
    ari_history_list([`${uplayer} discards ${ckey}`], 'discard');
  }
  let uihand = UI.players[uplayer].hand.items;
  let fenhand_vorher = fen.players[uplayer].hand;
  let fenhand = fen.players[uplayer].hand = uihand.filter(x => x.source == 'hand').map(x => x.key);
  //#endregion
  if (isEmpty(fenhand) && isEmpty(fen.players[uplayer].loosecards)) {
    end_of_round_fritz(uplayer);
  } else if (ms <= 100) {
    console.log(`time is up for ${uplayer}!!!`);
    ari_history_list([`${uplayer} runs out of time`], 'timeout');
    if (fen.plorder.length <= 1) { end_of_round_fritz(uplayer); }
    else { Z.turn = [get_next_player(Z, uplayer)]; deck_deal_safe_fritz(fen, Z.turn[0]); removeInPlace(fen.plorder, uplayer); }
  } else { Z.turn = [get_next_player(Z, uplayer)]; deck_deal_safe_fritz(fen, Z.turn[0]); }
  take_turn_fen();
}
function endit() { throw new Error("*** THE END ***"); }
function endsWith(s, sSub) { let i = s.indexOf(sSub); return i >= 0 && i == s.length - sSub.length; }
function endTurn() {
  present();
  let el = T.trick[0].div;
  let res = indexOfMax(T.trick, 'rank');
  let winnerOfTrick = T.players[res.i];
  winnerOfTrick.hand.add(T.trick);
  let pos = actualCenter(el);
  let targetPos = actualCenter(Zones[winnerOfTrick.id].div);
  console.log('from', pos, 'to', targetPos);
  el.style.position = 'fixed';
  el.style.left = pos.x + 'px';
  el.style.top = pos.y + 'px';
  setTimeout(() => { el.style.left = targetPos.x + 'px'; el.style.top = targetPos.y + 'px' }, 2000);
  showHands();
  return;
  let losers = [], winners = [];
  for (const pl of T.players) {
    if (pl.hand.count() == 0) { losers.push(pl); } else { winners.push(pl); }
  }
  if (winners.length == 1) {
    console.log('*** game over *** winner', winners[0]); return;
  } else {
    console.log('game goes on');
    showHands();
  }
  setTimeout(startRound, 2000);
}
function engine_go(e) {
  const matrix = {
    a: {
      click: () => add_agent_at(M.map, [e.latlng.lat, e.latlng.lng]),
      route: () => { M.event = 'route', M.state = 'r'; engine_go() }
    },
    r: {
    },
  }
  switch (M.state) {
    case 'a':
      switch (event) {
        case 'click': break;
        case 'route': M.state = 'r'; break;
        case 'clear': break;
      }
      break;
    case 'r':
      break;
    default:
      break;
  }
}
function enQ(f, parr = null, msBefore = null, msAfter = null, callback = null) {
  if (nundef(Q)) restartQ();
  Q.push({ f: f, parr: parr, msBefore: msBefore, msAfter: msAfter, callback: callback });
}
function ensure_actions(fen) { fen.actionsCompleted = []; }
function ensure_assets(obj) {
  if (nundef(DB)) {
    DB = jsyaml.load(obj.db);
    symbolDict = Syms = jsyaml.load(obj.syms);
    SymKeys = Object.keys(Syms);
    ByGroupSubgroup = jsyaml.load(obj.symGSG);
    WordP = jsyaml.load(obj.allWP);
    C52 = jsyaml.load(obj.c52);
    Cinno = jsyaml.load(obj.cinno);
    FenPositionList = csv2list(obj.fens);
    KeySets = getKeySets();
  }
  console.assert(isdef(DB), 'NO DB!!!!!!!!!!!!!!!!!!!!!!!!!!!');
}
function ensure_assets_old(obj) {
  DB = jsyaml.load(obj.db);
  symbolDict = Syms = jsyaml.load(obj.syms);
  SymKeys = Object.keys(Syms);
  ByGroupSubgroup = jsyaml.load(obj.symGSG);
  WordP = jsyaml.load(obj.allWP);
  C52 = jsyaml.load(obj.c52);
  Cinno = jsyaml.load(obj.cinno);
  inno_create_card_assets();
  ari_create_card_assets('rbgyop');
  FenPositionList = csv2list(obj.fens);
  KeySets = getKeySets();
  if (isdef(obj.edict)) { Dictionary = { E: to_words(obj.edict), S: to_words(obj.sdict), F: to_words(obj.fdict), D: to_words(obj.ddict) } };
  console.assert(isdef(DB), 'NO DB!!!!!!!!!!!!!!!!!!!!!!!!!!!');
}
function ensure_buttons_visible_ferro() {
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  if (fen.players[uplayer].hand.length <= 1) return;
  let dbPlayer = mBy('dbPlayer');
  if (nundef(dbPlayer)) {
    let d = iDiv(UI.players[uplayer]);
    mStyle(d, { position: 'relative' })
    dbPlayer = mDiv(d, { position: 'absolute', bottom: 2, left: 100, height: 25 }, 'dbPlayer');
  }
  let styles = { rounding: 6, bg: 'silver', fg: 'black', border: 0, maleft: 10 };
  if (Z.game == 'ferro') {
    let b = mButton('clear selection', onclick_clear_selection_ferro, dbPlayer, styles, 'enabled', 'bClearSelection');
    if (isEmpty(A.selected)) hide(b);
  }
}
function ensure_buttons_visible_for(plname) {
  if (Z.role == 'spectator' || isdef(mBy('dbPlayer'))) return;
  let fen = Z.fen;
  let pl = fen.players[plname];
  let plui = UI.players[plname];
  if (pl.hand.length <= 1) return;
  let d = iDiv(plui);
  mStyle(d, { position: 'relative' })
  let dbPlayer = mDiv(d, { position: 'absolute', bottom: 2, left: 100, height: 25 }, 'dbPlayer');
  let styles = { rounding: 6, bg: 'silver', fg: 'black', border: 0, maleft: 10 };
  let bByRank = mButton('by rank', onclick_by_rank_ferro, dbPlayer, styles, 'enabled');
  let bBySuit = mButton('by suit', onclick_by_suit_ferro, dbPlayer, styles, 'enabled');
}
function ensure_clientstate() {
  if (nundef(Clientdata.state)) {
    Clientdata.state = {};
    for (const k in DA.bars) Clientdata.state[k] = 0;
  }
}
function ensure_market(fen, n) { fen.stallSelected = []; deck_add(fen.deck, n - fen.market.length, fen.market); }
function ensure_player_id_name_index_type_color(pls) {
  let i = 0;
  pls.map(x => {
    x.id = getUID();
    x.name = (i == 0 ? Username : randomBotName()).toLowerCase();
    x.index = i;
    x.type = (i == 0 ? 'human' : 'ai');
    x.colorName = (i == 0 ? U.settings.userColor : Object.values(PlayerColors)[i]);
    x.color = (i == 0 ? U.settings.userColor : Object.keys(PlayerColors)[i]);
    i++;
  });
}
function ensure_polling() { }
function ensure_score(plname) {
  let sc = 0;
  if (isdef(Z.playerdata)) {
    let pldata = valf(firstCond(Z.playerdata, x => x.name == plname), { name: plname, state: { score: 0 } });
    sc = isdef(pldata.state) ? pldata.state.score : 0;
  } else Z.playerdata = Z.plorder.map(x => [{ name: x, state: { score: 0 } }]);
  lookupSet(Z.fen, ['players', plname, 'score'], sc);
}
function ensure_stall(fen, uplayer, n) { let pl = fen.players[uplayer]; deck_add(fen.deck, n - pl.stall.length, pl.stall); }
function ensure_stallSelected(fen) { if (nundef(fen.stallSelected)) fen.stallSelected = []; }
function ensure_winnerlist(game) { return lookupSet(DB.games, [game, 'winnerlist'], []); }
function ensure_Z() {
  if (nundef(Z)) Z = {};
  copyKeys(Serverdata, Z);
  if (isdef(Serverdata.table)) { copyKeys(Serverdata.table, Z); copyKeys(Serverdata.table.fen, Z); }
}
async function ensureAllAssets() { ensureAllAssets(true, true, true, true); }
function ensureAllGames(callbacks = []) {
  if (allGames == null) {
    sendGetAllGames(d => {
      allGames = d;
      console.log('allGames', allGames);
      if (!isEmpty(callbacks)) callbacks[0](arrFromIndex(callbacks, 1));
    });
  } else if (!isEmpty(callbacks)) callbacks[0](arrFromIndex(callbacks, 1));
}
async function ensureAssets() {
  if (nundef(Syms)) {
    Syms = await route_path_yaml_dict(`${Basepath}assets/allSyms.yaml`);
    SymKeys = get_keys(Syms);
    ByGroupSubgroup = await route_path_yaml_dict(`${Basepath}assets/symGSG.yaml`);
    KeySets = getKeySets();
    C52 = await route_path_yaml_dict(`${Basepath}assets/c52.yaml`);
    ari_create_card_assets('rb');
  }
}
function ensureColorDict() {
  if (isdef(ColorDi)) return;
  ColorDi = {};
  let names = getColorNames();
  let hexes = getColorHexes();
  for (let i = 0; i < names.length; i++) {
    ColorDi[names[i].toLowerCase()] = { c: '#' + hexes[i] };
  }
  const newcolors = {
    black: { c: '#000000', D: 'schwarz' },
    blue: { c: '#0000ff', D: 'blau' },
    BLUE: { c: '#4363d8', E: 'blue', D: 'blau' },
    BLUEGREEN: { c: '#004054', E: 'bluegreen', D: 'blaugrün' },
    BROWN: { c: '#96613d', E: 'brown', D: 'braun' },
    deepyellow: { c: '#ffed01', E: 'yellow', D: 'gelb' },
    FIREBRICK: { c: '#800000', E: 'darkred', D: 'rotbraun' },
    gold: { c: 'gold', D: 'golden' },
    green: { c: 'green', D: 'grün' },
    GREEN: { c: '#3cb44b', E: 'green', D: 'grün' },
    grey: { c: 'grey', D: 'grau' },
    lightblue: { c: 'lightblue', D: 'hellblau' },
    LIGHTBLUE: { c: '#42d4f4', E: 'lightblue', D: 'hellblau' },
    lightgreen: { c: 'lightgreen', D: 'hellgrün' },
    LIGHTGREEN: { c: '#afff45', E: 'lightgreen', D: 'hellgrün' },
    lightyellow: { c: '#fff620', E: 'lightyellow', D: 'gelb' },
    NEONORANGE: { c: '#ff6700', E: 'neonorange', D: 'neonorange' },
    NEONYELLOW: { c: '#efff04', E: 'neonyellow', D: 'neongelb' },
    olive: { c: 'olive', D: 'oliv' },
    OLIVE: { c: '#808000', E: 'olive', D: 'oliv' },
    orange: { c: 'orange', D: 'orange' },
    ORANGE: { c: '#f58231', E: 'orange', D: 'orange' },
    PINK: { c: 'deeppink', D: 'rosa' },
    pink: { c: 'pink', D: 'rosa' },
    purple: { c: 'purple', D: 'lila' },
    PURPLE: { c: '#911eb4', E: 'purple', D: 'lila' },
    red: { c: 'red', D: 'rot' },
    RED: { c: '#e6194B', E: 'red', D: 'rot' },
    skyblue: { c: 'skyblue', D: 'himmelblau' },
    SKYBLUE: { c: 'deepskyblue', D: 'himmelblau' },
    teal: { c: '#469990', D: 'blaugrün' },
    TEAL: { c: '#469990', E: 'teal', D: 'blaugrün' },
    transparent: { c: '#00000000', E: 'transparent', D: 'transparent' },
    violet: { c: 'violet', E: 'violet', D: 'violett' },
    VIOLET: { c: 'indigo', E: 'violet', D: 'violett' },
    white: { c: 'white', D: 'weiss' },
    yellow: { c: 'yellow', D: 'gelb' },
    yelloworange: { c: '#ffc300', E: 'yellow', D: 'gelb' },
    YELLOW: { c: '#ffe119', E: 'yellow', D: 'gelb' },
  };
  for (const k in newcolors) {
    let cnew = newcolors[k];
    if (cnew.c[0] != '#' && isdef(ColorDi[cnew.c])) cnew.c = ColorDi[cnew.c].c;
    ColorDi[k] = cnew;
  }
}
function ensureColorNames() {
  if (isdef(ColorNames)) return;
  ColorNames = {};
  let names = getColorNames();
  let hexes = getColorHexes();
  for (let i = 0; i < names.length; i++) {
    ColorNames[names[i].toLowerCase()] = '#' + hexes[i];
  }
}
function ensureDictionary() {
  if (nundef(Dictionary)) { Dictionary = { E: {}, S: {}, F: {}, C: {}, D: {} } };
  for (const k in Syms) {
    for (const lang of ['E', 'D', 'F', 'C', 'S']) {
      let w = Syms[k][lang];
      if (nundef(w)) continue;
      Dictionary[lang][w.toLowerCase()] = Dictionary[lang][w.toUpperCase()] = k;
    }
  }
}
function ensureInView(container, element) {
  let cTop = container.scrollTop;
  let cBottom = cTop + container.clientHeight;
  let eTop = element.offsetTop;
  let eBottom = eTop + element.clientHeight;
  if (eTop < cTop) {
    container.scrollTop -= cTop - eTop;
  } else if (eBottom > cBottom) {
    container.scrollTop += eBottom - cBottom;
  }
}
function ensureKeys(o, def) {
  addKeys(def, o);
}
function ensureRtree(R) {
  if (nundef(R.tree) || isEmpty(R.tree)) {
    if (isdef(R.lastSpec.ROOT.cond)) {
      R.tree = { uid: getUID(), uidParent: null, here: 'ROOT', type: 'invisible' };
      if (R.lastSpec.ROOT.chanav) R.tree.chanav = R.lastSpec.ROOT.chanav;
      R.rNodes[R.tree.uid] = R.tree;
      R.Locations.ROOT = [R.tree.uid];
    } else {
      R.tree = recTree(R.lastSpec.ROOT, null, R);
      R.rNodes[R.tree.uid] = R.tree;
    }
  } else {
    console.log('(tree present!)');
  }
}
async function ensureSvgDict() {
  if (nundef(svgDict)) {
    svgDictC = await vidCache.load('svgDict', route_svgDict, true, false);
    svgDict = vidCache.asDict('svgDict');
    svgKeys = Object.keys(svgDict);
    svgList = dict2list(svgDict);
  }
}
function ensureSymByHex() {
  if (nundef(symByHex)) {
    symByHex = {};
    symKeysByHex = [];
    for (const k in symbolDict) {
      let info = symbolDict[k];
      symByHex[info.hexcode] = info;
    }
    symKeysByHex = Object.keys(symByHex);
  }
}
function ensureSymBySet() { if (nundef(symBySet)) { makeEmoSetIndex(); } }
function ensureSymByType() {
  if (nundef(symByType)) {
    symByType = { emo: {}, eduplo: {}, icon: {}, iduplo: {} };
    symKeysByType = { emo: [], eduplo: [], icon: [], iduplo: [] };
    symListByType = { emo: [], eduplo: [], icon: [], iduplo: [] };
    for (const k in symbolDict) {
      let info = symbolDict[k];
      if (info.type == 'emo' && info.isDuplicate) { symByType.eduplo[k] = info; symListByType.eduplo.push(info); symKeysByType.eduplo.push(k); }
      else if (info.type == 'icon' && info.isDuplicate) { symByType.iduplo[k] = info; symListByType.iduplo.push(info); symKeysByType.iduplo.push(k); }
      else if (info.type == 'emo') { symByType.emo[k] = info; symListByType.emo.push(info); symKeysByType.emo.push(k); }
      else if (info.type == 'icon') { symByType.icon[k] = info; symListByType.icon.push(info); symKeysByType.icon.push(k); }
    }
  }
}
function ensureUiNodes(R) { if (nundef(R.uiNodes)) R.uiNodes = {}; }
function ensureUIS() { if (nundef(UIS)) { UIS = {}; IdOwner = {}; id2oids = {}; oid2ids = {}; id2uids = {}; path2mainIds = {}; } }
function enter_pressed(e) { if (e.keyCode == 13) { send_message(e); } set_seen(); }
function enterInterruptState() {
  clearTimeouts();
  if (isdef(G.instance)) G.instance.clear();
  auxOpen = true;
}
function enterLobby() {
  console.assert(isdef(DB) && isdef(U), 'ENTERLOBBY DB U NOT CORRECT!!!')
  if (JUST_PERLEN_GAME) { simplestPerlenGame(); }
}
function enterOnlineIDFormSubmit() {
  var form = document.getElementById("EnterOnlineIDForm");
  let userid = mBy("enterID-input");
  let pwd = mBy('tlpvt-passcode-input');
  onclick_submit_boa_login();
}
function enterWaitingLoop() {
  setStatus('waiting for more players!!!');
}
function eraseSpaces(s) {
  let i = 0;
  while (s.includes('  ')) {
    s = s.replace('  ', ' ');
    s = s.replace(' {', '{');
    s = s.replace(' (', '(');
    s = s.replace('\n ', ' ');
    s = s.replace('\n{', '{');
    s = s.replace('\n}', '}');
  }
  return s;
}
function errlog() { console.log('ERROR!', ...arguments); }
function error(msg) {
  let fname = getFunctionsNameThatCalledThisFunction();
  console.log(fname, 'ERROR!!!!! ', msg);
}
function errormsg(ms) { $('#msg').innerHTML = ms; }
function establishUsername(username) {
  hide(dLogin);
  Username = username;
  initSocket();
}
function ev_to_gname(ev) { evNoBubble(ev); return evToTargetAttribute(ev, 'gamename'); }
function eval_approx_derivative(f, xfrom, xto, dx) { }
function eval_approx_integral(f, xfrom, xto, dx) { }
function eval_normal_cdf(x, mean, stdev) { let f = get_normal_cdf(mean, stdev); return f(x); }
function eval_normal_pdf(x, mean, stdev) { let f = get_normal_pdf(mean, stdev); return f(x); }
function evalCond(o, condKey, condVal) {
  let func = FUNCTIONS[condKey];
  if (isString(func)) func = window[func];
  if (nundef(func)) {
    if (nundef(o[condKey])) return null;
    if (isList(condVal)) {
      for (const v of condVal) if (o[condKey] == v) return true;
      return null;
    } else {
      return isdef(o[condKey]) ? o[condKey] == condVal : null;
    }
  }
  return func(o, condVal);
}
function evalConds(o, conds) {
  for (const [f, v] of Object.entries(conds)) {
    if (!evalCond(o, f, v)) return false;
  }
  return true;
}
function evalExp() { }
function EvalInit() {
  var index = 0;
  for (index = 0; index < 10; ++index) {
    PawnRanksWhite[index] = 0;
    PawnRanksBlack[index] = 0;
  }
}
function evalML(word) {
  let answer = normalize(word, currentLanguage);
  let reqAnswer = normalize(bestWord, currentLanguage);
  if (answer == reqAnswer) return true;
  else if (currentLanguage == 'D' && isEnglishKeyboardGermanEquivalent(reqAnswer, answer)) {
    return true;
  } else {
    return false;
  }
}
function EvalPosition() {
  var pce;
  var pceNum;
  var sq;
  var score = brd_material[COLOURS.WHITE] - brd_material[COLOURS.BLACK];
  var file;
  var rank;
  if (0 == brd_pceNum[PIECES.wP] && 0 == brd_pceNum[PIECES.bP] && MaterialDraw() == BOOL.TRUE) {
    return 0;
  }
  PawnsInit();
  pce = PIECES.wP;
  for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
    sq = brd_pList[PCEINDEX(pce, pceNum)];
    score += PawnTable[SQ64(sq)];
    file = FilesBrd[sq] + 1;
    rank = RanksBrd[sq];
    if (PawnRanksWhite[file - 1] == RANKS.RANK_8 && PawnRanksWhite[file + 1] == RANKS.RANK_8) {
      score += PawnIsolated;
    }
    if (PawnRanksBlack[file - 1] <= rank && PawnRanksBlack[file] <= rank && PawnRanksBlack[file + 1] <= rank) {
      score += PawnPassed[rank];
    }
  }
  pce = PIECES.bP;
  for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
    sq = brd_pList[PCEINDEX(pce, pceNum)];
    score -= PawnTable[MIRROR64(SQ64(sq))];
    file = FilesBrd[sq] + 1;
    rank = RanksBrd[sq];
    if (PawnRanksBlack[file - 1] == RANKS.RANK_1 && PawnRanksBlack[file + 1] == RANKS.RANK_1) {
      score -= PawnIsolated;
    }
    if (PawnRanksWhite[file - 1] >= rank && PawnRanksWhite[file] >= rank && PawnRanksWhite[file + 1] >= rank) {
      score -= PawnPassed[7 - rank];
    }
  }
  pce = PIECES.wN;
  for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
    sq = brd_pList[PCEINDEX(pce, pceNum)];
    score += KnightTable[SQ64(sq)];
  }
  pce = PIECES.bN;
  for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
    sq = brd_pList[PCEINDEX(pce, pceNum)];
    score -= KnightTable[MIRROR64(SQ64(sq))];
  }
  pce = PIECES.wB;
  for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
    sq = brd_pList[PCEINDEX(pce, pceNum)];
    score += BishopTable[SQ64(sq)];
  }
  pce = PIECES.bB;
  for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
    sq = brd_pList[PCEINDEX(pce, pceNum)];
    score -= BishopTable[MIRROR64(SQ64(sq))];
  }
  pce = PIECES.wR;
  for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
    sq = brd_pList[PCEINDEX(pce, pceNum)];
    score += RookTable[SQ64(sq)];
    file = FilesBrd[sq] + 1;
    if (PawnRanksWhite[file] == RANKS.RANK_8) {
      if (PawnRanksBlack[file] == RANKS.RANK_1) {
        score += RookOpenFile;
      } else {
        score += RookSemiOpenFile;
      }
    }
  }
  pce = PIECES.bR;
  for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
    sq = brd_pList[PCEINDEX(pce, pceNum)];
    score -= RookTable[MIRROR64(SQ64(sq))];
    file = FilesBrd[sq] + 1;
    if (PawnRanksBlack[file] == RANKS.RANK_1) {
      if (PawnRanksWhite[file] == RANKS.RANK_8) {
        score -= RookOpenFile;
      } else {
        score -= RookSemiOpenFile;
      }
    }
  }
  pce = PIECES.wQ;
  for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
    sq = brd_pList[PCEINDEX(pce, pceNum)];
    score += RookTable[SQ64(sq)];
    file = FilesBrd[sq] + 1;
    if (PawnRanksWhite[file] == RANKS.RANK_8) {
      if (PawnRanksBlack[file] == RANKS.RANK_1) {
        score += QueenOpenFile;
      } else {
        score += QueenSemiOpenFile;
      }
    }
  }
  pce = PIECES.bQ;
  for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
    sq = brd_pList[PCEINDEX(pce, pceNum)];
    score -= RookTable[MIRROR64(SQ64(sq))];
    file = FilesBrd[sq] + 1;
    if (PawnRanksBlack[file] == RANKS.RANK_1) {
      if (PawnRanksWhite[file] == RANKS.RANK_8) {
        score -= QueenOpenFile;
      } else {
        score -= QueenSemiOpenFile;
      }
    }
  }
  pce = PIECES.wK;
  sq = brd_pList[PCEINDEX(pce, 0)];
  if ((brd_material[COLOURS.BLACK] <= ENDGAME_MAT)) {
    score += KingE[SQ64(sq)];
  } else {
    score += KingO[SQ64(sq)];
  }
  pce = PIECES.bK;
  sq = brd_pList[PCEINDEX(pce, 0)];
  if ((brd_material[COLOURS.WHITE] <= ENDGAME_MAT)) {
    score -= KingE[MIRROR64(SQ64(sq))];
  } else {
    score -= KingO[MIRROR64(SQ64(sq))];
  }
  if (brd_pceNum[PIECES.wB] >= 2) score += BishopPair;
  if (brd_pceNum[PIECES.bB] >= 2) score -= BishopPair;
  if (brd_side == COLOURS.WHITE) {
    return score;
  } else {
    return -score;
  }
}
function evalSP(speechResult) {
  if (isEmpty(speechResult)) {
    return false;
  }
  Selected = {}
  let answer = Goal.answer = Selected.answer = normalize(speechResult, currentLanguage);
  let reqAnswer = Goal.reqAnswer = normalize(bestWord, currentLanguage);
  if (answer == reqAnswer) return true;
  else if (matchesAnyWordOrSound(Goal.info, answer)) return true;
  else if (matchingNumberOrTime(Goal.info, answer)) {
    return true;
  } else if (isAcceptableAnswerButNewSound(Goal.info, reqAnswer, answer)) {
    addAsSoundToDatabase(Goal.info, answer);
    return true;
  } else {
    return false;
  }
}
function evalSPA(speechResult) {
  if (isEmpty(speechResult)) {
    console.log('empty speechResult')
    return false;
  }
  Selected = {}
  let answer = Goal.answer = Selected.answer = normalize(speechResult, currentLanguage);
  let reqAnswer = Goal.reqAnswer = normalize(bestWord, currentLanguage);
  if (answer == reqAnswer) return true;
  else if (matchesAnyWordOrSound(Goal.info, answer)) return true;
  else if (matchingNumberOrTime(Goal.info, answer)) {
    return true;
  } else if (isAcceptableAnswerButNewSound(Goal.info, reqAnswer, answer)) {
    addAsSoundToDatabase(Goal.info, answer);
    return true;
  } else {
    return false;
  }
}
function evalSpecPath(n, relpath, R) {
  if (isEmpty(relpath)) return null;
  if (relpath == '.') return n;
  let iNext = firstNumber(relpath);
  nNext = n.sub[iNext];
  let newPath = stringAfter(relpath, '.' + iNext);
  if (isEmpty(newPath)) return nNext;
  else return evalSpecPath(nNext, newPath, R);
}
function evalTC(ev) {
  let id = evToClosestId(ev);
  ev.cancelBubble = true;
  let i = firstNumber(id);
  let item = Pictures[i];
  Selected = { pic: item, feedbackUI: item.div };
  if (item == Goal) { return true; } else { return false; }
}
function evalTP(ev) {
  let id = evToClosestId(ev);
  ev.cancelBubble = true;
  let i = firstNumber(id);
  let item = Pictures[i];
  Selected = { pic: item, feedbackUI: item.div, sz: getBounds(item.div).height };
  if (item.label == bestWord) { return true; } else { return false; }
}
function evaluate() {
  if (!canAct()) return;
  uiActivated = false; clearTimeouts();
  IsAnswerCorrect = G.instance.eval(...arguments);
  if (IsAnswerCorrect === undefined) { promptNextTrial(); return; }
  G.trialNumber += 1;
  if (!IsAnswerCorrect && G.trialNumber < G.trials && !calibrating()) { promptNextTrial(); return; }
  if (calibrating()) { DELAY = 300; if (IsAnswerCorrect) G.successFunc(false); else G.failFunc(); }
  else if (IsAnswerCorrect) { DELAY = Settings.spokenFeedback ? 1500 : 300; G.successFunc(); }
  else { DELAY = G.correctionFunc(); G.failFunc(); }
  setTimeout(removeMarkers, 1500);
  let nextLevel = scoring(IsAnswerCorrect);
  if (Score.gameChange) {
    setNextGame();
    if (unitTimeUp()) {
      setTimeout(() => gameOver('Great job! Time for a break!'), DELAY);
    } else {
      TOMain = setTimeout(startGame, DELAY);
    }
  } else if (Score.levelChange && nextLevel <= G.maxLevel) {
    G.level = nextLevel;
    setBadgeLevel(G.level);
    TOMain = setTimeout(startLevel, DELAY);
  } else {
    TOMain = setTimeout(startRound, DELAY);
  }
}
function evaluateBoard(move, prevSum, color) {
  var from = [8 - parseInt(move.from[1]), move.from.charCodeAt(0) - 'a'.charCodeAt(0)];
  var to = [8 - parseInt(move.to[1]), move.to.charCodeAt(0) - 'a'.charCodeAt(0)];
  if (prevSum < -1500) {
    if (move.piece === 'k') { move.piece = 'k_e' }
    else if (move.captured === 'k') { move.captured = 'k_e' }
  }
  if ('captured' in move) {
    if (move.color === color) {
      prevSum += (weights[move.captured] + pstOpponent[move.color][move.captured][to[0]][to[1]]);
    }
    else {
      prevSum -= (weights[move.captured] + pstSelf[move.color][move.captured][to[0]][to[1]]);
    }
  }
  if (move.flags.includes('p')) {
    move.promotion = 'q';
    if (move.color === color) {
      prevSum -= (weights[move.piece] + pstSelf[move.color][move.piece][from[0]][from[1]]);
      prevSum += (weights[move.promotion] + pstSelf[move.color][move.promotion][to[0]][to[1]]);
    }
    else {
      prevSum += (weights[move.piece] + pstSelf[move.color][move.piece][from[0]][from[1]]);
      prevSum -= (weights[move.promotion] + pstSelf[move.color][move.promotion][to[0]][to[1]]);
    }
  }
  else {
    if (move.color !== color) {
      prevSum += pstSelf[move.color][move.piece][from[0]][from[1]];
      prevSum -= pstSelf[move.color][move.piece][to[0]][to[1]];
    }
    else {
      prevSum -= pstSelf[move.color][move.piece][from[0]][from[1]];
      prevSum += pstSelf[move.color][move.piece][to[0]][to[1]];
    }
  }
  return prevSum;
}
function evalWP(wp) {
  let title = wp.title;
  if (title.includes('Adding') && !titla.includes('Fractions')) {
  }
}
function evenFloor(x) { let n = Math.floor(x); return n % 2 ? n - 1 : n; }
function everyinterval(n) {
  if ((myGameArea.frameNo / n) % 1 == 0) {
    return true;
  }
  return false;
}
function evNoBubble(ev) { ev.preventDefault(); ev.cancelBubble = true; }
function evStop(ev) {
  ev.preventDefault();
  ev.stopPropagation();
  ev.stopImmediatePropagation();
  ev.cancelBubble = true;
}
function evToClass(ev, className) {
  let elem = findParentWithClass(className);
  return elem;
}
function evToClosestId(ev) {
  let elem = findParentWithId(ev.target);
  return elem.id;
}
function evToId(ev) {
  let elem = findParentWithId(ev.target);
  return elem.id;
}
function evToId_g_(ev) {
  let elem = findParentWithId(ev.target);
  let s = elem.id;
  return s[0] == 'g' && s[1] == '_' ? stringAfter(s, '_') : s;
}
function evToIdParent(ev) {
  let elem = findParentWithId(ev.target);
  return elem;
}
function evToIdTNT(ev) {
  let elem = findParentWithId(ev.target);
  return elem.id;
}
function evToItem(ev) {
  let id = evToId(ev);
  let item = Items[id];
  return item;
}
function evToItemC(ev) { ev.cancelBubble = true; return evToItem(ev); }
function evToO(ev) {
  return getVisual(evToId(ev));
}
function evToProp(ev, prop) {
  let x = ev.target;
  while (isdef(x) && nundef(x.getAttribute(prop))) x = x.parentNode;
  return isdef(x) ? x.getAttribute(prop) : null;
}
function evToTargetAttribute(ev, attr) {
  let val = ev.target.getAttribute(attr);
  if (nundef(val)) { val = ev.target.parentNode.getAttribute(attr); }
  return val;
}
function ex00_sidebar(sidebar) {
  let styles = { hpadding: 12, vpadding: 4, fz: 20 };
  for (const link of ['short', 'link3super superlang dasdasdas', 'short']) {
    sidebar.addContent(`<a href='#'>${link}</a>`, styles);
  }
  sidebar.open(null, false);
}
function ex01_table(dContent) {
  console.log('dContent', dContent);
  mStyle(dContent, { bg: wyellow, position: 'relative' });
  let dTable = mDiv100(dContent);
  let d3 = mDiv(dTable, { position: 'absolute', left: 40, top: 4, bg: 'pink', w: 300, h: 300 });
}
function ex02_table(dContent) {
  console.log('dContent', dContent);
  mStyle(dContent, { bg: wyellow, position: 'relative', hmin: 1600 });
  let dTable = mDiv100(dContent);
}
function exchange_by_index(arr1, i1, arr2, i2) {
  let temp = arr1[i1];
  arr1[i1] = arr2[i2];
  arr2[i2] = temp;
}
function exchange_items_in_fen(fen, o0, o1) {
  let p0 = o0.path.split('.'); if (isdef(fen.players[p0[0]])) p0.unshift('players');
  let p1 = o1.path.split('.'); if (isdef(fen.players[p1[0]])) p1.unshift('players');
  let list0 = lookup(fen, p0);
  let list1 = lookup(fen, p1);
  if (isDict(list0) && isdef(list0.list)) list0 = list0.list;
  if (isDict(list1) && isdef(list1.list)) list1 = list1.list;
  elem_from_to(o0.key, list0, list1);
  elem_from_to(o1.key, list1, list0);
}
function executeFrame() {
  if (animate)
    requestAnimFrame(executeFrame);
  incrementSimulation();
  c.clearRect(0, 0, canvas.width, canvas.height);
  drawBox();
  drawCircle();
  if (mouse.down)
    drawLineToMouse();
}
function executeFunctionByName(functionName, context) {
  var args = Array.prototype.slice.call(arguments, 2);
  var namespaces = functionName.split('.');
  var func = namespaces.pop();
  for (var i = 0; i < namespaces.length; i++) {
    context = context[namespaces[i]];
  }
  return context[func].apply(context, args);
}
function executeMapping(mapping, otype, oid, o) {
  let mKey = mapping.id;
  let path = stringAfter(mKey, '.');
  let omap = parsePropertyPath(o, stringAfter(mKey, '.'));
  if (nundef(omap)) return;
  let func = mapping.type;
  let loc = mapping.loc;
  if (stringBefore(loc, '.') == 'this') {
    loc = parsePropertyPath(o, stringAfter(loc, '.'));
  }
  let mkLoc = UIS[loc];
  if (mkLoc && mkLoc.maxHeightFunc) {
    let hMax = mkLoc.maxHeightFunc();
    mkLoc.elem.style.setProperty('height', hMax + 'px');
  }
  let structObject = window[func](serverData.table, loc, o, oid, path, omap);
}
function existingPlayers(callback) { callback({ response: 'hallo' }); }
function exitToAddon(callback) {
  AD.callback = callback;
  enterInterruptState(); auxOpen = false;
  AD.run();
}
function exp_church(options) { return options.church == 'yes'; }
function exp_commissions(options) { return options.commission == 'yes'; }
function exp_dep(data) {
  if (isDict(data) && 'type' in data) {
    return [data];
  }
  if (is_Set(data) && data._set.length == 1) {
    return exp(data._set[0]);
  }
  if (is_Set(data) && data._set.length > 1) {
    return data._set.map(exp);
  }
  if (is_Tuple(data) && data._tuple.length == 1) {
    return exp(data._tuple[0]);
  }
  if (is_Tuple(data) && data._tuple.length > 1) data = data._tuple;
  if (isList(data) && empty(data)) return [];
  if (isList(data) && data.length == 1) return exp(data[0])
  if (isList(data)) {
    let a = exp(data[0]);
    let rest = data.slice(1);
    let tlist = exp(rest);
    return carteset(a, tlist);
  }
}
function exp_journeys(options) { return options.journey == 'yes'; }
function exp_rumors(options) { return options.rumors == 'yes'; }
function expand(e) {
  console.log('e', e)
  let res = [];
  let e2 = expand1(e);
  console.log('e2', e2)
  for (const el of e2) {
    if (isll(el)) el.map(x => res.push(x));
    else res.push(el);
  }
  return res;
}
function expand1(x) {
  if (isEmpty(x)) return [];
  if (isLiteral(x)) return [x.toString()];
  if (isActionElement(x)) return [x];
  if (isSingleton(x)) return expand1(firstElement(x));
  if (is_Set(x)) return x._set.map(el => expand1(el));
  if (isSet(x)) return x.set.map(el => expand1(el));
  if (is_Tuple(x)) {
    x = x._tuple;
    let a = expand1(firstElement(x));
    let b = x.slice(1);
    let c = expand1(x.slice(1));
    let d = extractActionLists(c);
    return carteset(a, d);
  }
  if (isTuple(x)) {
    let a = expand1(firstElement(x));
    let b = x.slice(1);
    let c = expand1(x.slice(1));
    let d = extractStringLists(c);
    testHelpers('a=', fj(a), 'b=', fj(b), 'c=', fj(c));
    testHelpers('d=', fj(d));
    return carteset(a, d);
  }
}
function expand1_99(x) {
  if (isList(x)) {
  }
  if (isDict(x)) {
    if ('_set' in x) {
      return handleSet(x._set);
    } else if ('_tuple' in x) {
      return handleTuple(x._tuple);
    } else if ('type' in x) {
      return handleAction(x);
    } else { error('IMPOSSIBLE OBJECT', x); return null; }
  } else { error('IMPOSSIBLE TYPE', x); return null; }
}
function expand99(e) {
  let res = [];
  e = expand1_99(e);
  for (const el of e) {
    if (isll(el)) el.map(x => res.push(x));
    else res.push(el);
  }
  return res;
}
function expandBoard(board, rNew, cNew, iInsert) {
  let [boardArrOld, rOld, cOld] = [board.fields.map(x => isdef(x.item) ? x.item.index : null), board.rows, board.cols];
  let boardArrNew = new Array(rNew * cNew);
  for (let r = 0; r < rNew; r++) {
    for (let c = 0; c < cNew; c++) {
      let i = iFromRowCol(r, c, rNew, cNew);
      let x = (rOld != rNew) ? r : c;
      if (x < iInsert) {
        let iOld = iFromRowCol(r, c, rOld, cOld);
        boardArrNew[i] = boardArrOld[iOld];
      }
      else if (x == iInsert) boardArrNew[i] = null;
      else {
        let [ir, ic] = (rOld != rNew) ? [r - 1, c] : [r, c - 1];
        let iOld = iFromRowCol(ir, ic, rOld, cOld);
        boardArrNew[i] = boardArrOld[iOld];
      }
    }
  }
  return { rows: rNew, cols: cNew, boardArr: boardArrNew, extras: [] };
}
function expandX(e) {
  console.log('e', e)
  let res = [];
  let e2 = expandX1(e);
  console.log('e2', e2)
  for (const el of e2) {
    if (isll(el)) el.map(x => res.push(x));
    else res.push(el);
  }
  return res;
}
function expandX1(x) {
  console.log('expand1', cnt, x); cnt += 1;
  if (is_Set(x) && x._set.length == 1) return x._set.map(el => expandX1(el));
  if (isDict(x) || isActionElement(x) || isLiteral(x)) return [x];
  if (is_Tuple(x)) x = x._tuple;
  if (Array.isArray(x)) {
    if (isEmpty(x)) return [];
    let a = expandX1(firstElement(x));
    let b = x.slice(1);
    let c = expandX1(b);
    console.log(c);
    let d = extractActionLists(c);
    console.log('a=', fj(a));
    console.log('b=', fj(b));
    console.log('c=', fj(c));
    console.log('d=', fj(d));
    return flat(cartesi(a, d));
  }
}
function explode(deck, w, h) {
  deck.cards.forEach(function (card, i) {
    card.setSide('front')
    card.animateTo({
      delay: 1000 + i * 2,
      duration: 500,
      ease: 'quartOut',
      x: Math.random() * w - w / 2,
      y: Math.random() * h - h / 2
    })
  });
}
function extendedObjectString(o, indent, simple, lstShow, lstOmit) {
  let s = ' '.repeat(indent) + (o.id ? o.id + ': ' : ' _ : ');
  for (const k in o) {
    if (k == 'id') continue;
    if (lstShow && lstShow.includes(k)
      || lstOmit && !lstOmit.includes(k)
      || simple && isSimple(o[k]) && !isComplexColor(o[k])) {
      if (isDict(o[k])) {
        s += '(' + extendedObjectString(o[k], indent, simple, lstShow, lstOmit) + ') ';
      } else s += k + ':' + o[k] + ' ';
    }
  }
  return s;
}
function extendPath(path, postfix) { return path + (endsWith(path, '.') ? '' : '.') + postfix; }
function extendRect(r4) { r4.l = r4.x; r4.t = r4.y; r4.r = r4.x + r4.w; r4.b = r4.t + r4.h; }
function extendWidth(w) { return replaceEvery(w, 'w', 2); }
function extract_game_options() {
  let opt = Session.game_options;
  return Session.game_options;
}
function extract_polygon(f) {
  var polygon = L.polygon(f.geometry.coordinates);
  if (f.geometry.type == 'MultiPolygon') {
    let max_area_polygon;
    let max_area = 0;
    for (poly in (f.geometry.coordinates)) {
      let polygon1 = turf.polygon((f.geometry.coordinates)[poly])
      area = turf.area(polygon1);
      if (area > max_area) {
        max_area = area
        max_area_polygon = polygon1;
      }
    }
    console.log('turf', turf)
    console.log('polymax', max_area_polygon)
    polygon = L.polygon(max_area_polygon.geometry.coordinates);
  }
  return polygon;
}
function extractActionLists(lst) {
  let res = [];
  for (const l of lst) {
    if (isListOfActionElements(l)) res.push(l);
    else if (isActionElement(l)) res.push([l]);
    else {
      let r2 = extractStringLists(l);
      r2.map(x => res.push(x));
    }
  }
  return res;
}
function extractActions(lst) {
  let res = [];
  for (const l of lst) {
    if (isListOfActionElements(l)) res.push(l);
    else if (isActionElement(l)) res.push([l]);
    else {
      let r2 = extractStringLists(l);
      r2.map(x => res.push(x));
    }
  }
  return res;
}
function extractColorsFromCss() {
  let arr = collectPropFromCss('background-color');
  var di = {};
  for (const o of arr) {
    let sarr = splitAtAnyOf(o.class, ' .-:,');
    let sColor = null;
    for (const w of sarr) {
      if (['w3', 'text', 'hover', 'border'].includes(w)) continue;
      sColor = w;
      break;
    }
    if (sColor && o.color) {
      di[sColor] = o.color; //"'" + o.color + "'"; //'hallo'; //o.color.toString();
    }
  }
  return di;
}
function extractKeywords(text) {
  let words = toWords(text, true);
  let res = [];
  for (const w of words) { if (isdef(CODE.all[w])) addIf(res, w); }
  return res;
}
function extractPixel(str) {
  if (isNumber(str)) return str;
  else return firstNumber(str);
}
function extractStringLists(lst) {
  console.log(lst);
  let res = [];
  for (const l of lst) {
    if (isListOfLiterals(l)) res.push(l);
    else if (isLiteral(l)) res.push([l]);
    else {
      let r2 = extractStringLists(l);
      r2.map(x => res.push(x));
    }
  }
  return res;
}
function extractTuples(x) {
  if (isList(x))
    if (isListOfListOfActions(x)) return x;
  return isList(x) && x.length > 0 ? stripSet(x[0]) : x;
}
function extractUniqueStrings(tupleList) {
  let idlist = [];
  tupleList.map(x => x.map(y => addIf_dep(y, idlist)));
  return idlist;
}
function face_down(item, color, texture) {
  if (!item.faceUp) return;
  if (isdef(texture) || lookup(item, ['live', 'dCover'])) {
    face_down_alt(item, color, texture);
  } else {
    let svgCode = C52.card_2B;
    item.div.innerHTML = svgCode;
    if (nundef(color)) color = item.color;
    if (isdef(item.color)) item.div.children[0].children[1].setAttribute('fill', item.color);
  }
  item.faceUp = false;
}
function face_down_alt(item, bg, texture_name) {
  let dCover = item.live.dCover;
  if (nundef(dCover)) {
    let d = iDiv(item);
    dCover = item.live.dCover = mDiv(d, { background: bg, rounding: mGetStyle(d, 'rounding'), position: 'absolute', width: '100%', height: '100%', left: 0, top: 0 });
    let t = get_texture(texture_name);
    dCover.style.backgroundImage = t;
    dCover.style.backgroundRepeat = 'repeat';
  } else mStyle(dCover, { display: 'block' });
}
function face_up(item) {
  if (item.faceUp) return;
  if (lookup(item, ['live', 'dCover'])) mStyle(item.live.dCover, { display: 'none' });
  else item.div.innerHTML = isdef(item.c52key) ? C52[item.c52key] : item.html;
  item.faceUp = true;
}
function faChar(key) {
  return String.fromCharCode('0x' + faChars[key]); //'f520');
}
function fadder(f, g) { return x => f(x) - g(x); }
async function faicon_list() {
  let txt = await route_path_text('../base/alibs/fa.min.css');
  txt = '.fa-0' + stringAfter(txt, '.fa-0');
  txt = stringBefore(txt, 'sr-only');
  let parts = txt.split(':before');
  console.log('parts', parts.length);
  let list = [];
  for (const p of parts) {
    let word = stringAfter(p, '.fa-').trim();
    list.push(word);
  }
  arrRemoveLast(list);
  list.sort();
  console.log('list', list);
  downloadJson({ l: list }, 'liste');
}
async function fail_yt() {
  let url = `http://gdata.youtube.com/feeds/api/videos`; //blocked by CORS
  let result = await route_path_text(url);
  console.log('result', result);
  let res = `
    http://gdata.youtube.com/feeds/api/videos
    ?v=2
    &author=SesameStreet
    &q=rubber+ducky
    &orderby=viewCount
    &start-index=1
    &max-results=10
    &alt=json-in-script
    &callback=myCallbackFunction
    &prettyprint=true
  `;
}
function failPictureGoal(withComment = false) {
  if (withComment && G.spokenFeedback) {
    const comments = (G.language == 'E' ? ['too bad'] : ["aber geh'"]);
    sayRandomVoice(chooseRandom(comments));
  }
  if (isdef(Selected) && isdef(Selected.feedbackUI)) {
    let uilist = isList(Selected.feedbackUI) ? Selected.feedbackUI : [Selected.feedbackUI];
    let sz = getRect(uilist[0]).h;
    for (const ui of uilist) {
      mpOver(markerFail(), ui, sz * (1 / 2), 'red', 'openMojiTextBlack');
    }
  }
}
function failSomePictures(withComment = false) {
  if (withComment && G.spokenFeedback) {
    const comments = (G.language == 'E' ? ['too bad'] : ["aber geh'"]);
    sayRandomVoice(chooseRandom(comments));
  }
  for (const p of Pictures) {
    let ui = iDiv(p);
    let sz = getRect(ui).h;
    if (p.isCorrect == false) mpOver(markerFail(), ui, sz * (1 / 2), 'red', 'openMojiTextBlack');
    else mpOver(markerSuccess(), ui, sz * (4 / 5), 'limegreen', 'segoeBlack');
  }
}
function failThumbsDown(withComment = false) {
  if (withComment && G.spokenFeedback) {
    const comments = (G.language == 'E' ? ['too bad'] : ["aber geh'"]);
    sayRandomVoice(chooseRandom(comments));
  }
  let p1 = firstCond(Pictures, x => x.key == 'thumbs down');
  iDiv(p1).style.opacity = 1;
  let p2 = firstCond(Pictures, x => x.key == 'thumbs up');
  iDiv(p2).style.display = 'none';
}
function failThumbsDownPlus(withComment = false) {
  if (withComment && G.spokenFeedback) {
    const comments = (G.language == 'E' ? ['too bad'] : ["aber geh'"]);
    sayRandomVoice(chooseRandom(comments));
  }
  let p1 = firstCond(Pictures, x => x.key == 'thumbs down');
  iDiv(p1).style.opacity = 1;
  let p2 = firstCond(Pictures, x => x.key == 'thumbs up');
  iDiv(p2).style.display = 'none';
  if (isdef(Selected) && isdef(Selected.feedbackUI)) {
    let uilist = isList(Selected.feedbackUI) ? Selected.feedbackUI : [Selected.feedbackUI];
    let sz = getRect(uilist[0]).h;
    for (const ui of uilist) mpOver(markerFail(), ui, sz * (1 / 2), 'red', 'openMojiTextBlack');
  }
}
function fakeInitSocket() { ClientId = '12345'; fakeLogin(Username); }
async function fakeLogin(username) {
  DB = await route_path_yaml_dict('./data.yaml');
  PerlenDict = await route_path_yaml_dict('./perlenDict.yaml');
  initSocket();
  setUserData(username);
  enterLobby();
}
function fcomposer(f, g) { return x => f(g(x)); }
function fderivative(exp) {
  return nerdamer(`diff(${exp},x)`).buildFunction();
}
function feedback() { }
function feedback_disable_ui() {
  for (const k in DA.bars) {
    let bar = DA.bars[k];
    let b = bar.cont.getElementsByTagName('button')[0];
    b.disabled = true;
  }
}
function feedback_present() {
  dTable = mBy('dTable'); mStyle(dTable, { padding: 20 });
  DA.no_shield = true;
  feedback_stats(dTable);
  let dgreen = get_plus_progressbar(dTable, 'green');
  mLinebreak(dTable);
  let dred = get_plus_progressbar(dTable, 'red');
  mLinebreak(dTable);
  DA.bars = {
    green: dgreen,
    red: dred,
  };
  set_bar('green'); set_bar('red');
  if (Z.role == 'spectator') {
    feedback_disable_ui();
    mButton('JOIN AS PLAYER', onclick_join_as_player, dTable, { h: 40, w: 200 });
  } else if (i_am_host()) {
    let [uname, fen, options, uplayer] = [Z.uname, Z.fen, Z.options, Z.uplayer];
    mButton('reset', onclick_reset_progressbars, dTable, { h: 30, w: 100 });
    feedback_disable_ui();
    let playerlist = Z.playerlist;
    let pldatalist = Z.playerdata.map(x => x.name);
    console.log('playerlist', playerlist, 'pldatalist', pldatalist);
    for (const plname of pldatalist) {
      if (!playerlist.includes(plname)) {
        console.log('plname', plname, 'not in playerlist', playerlist);
        fen.players[plname] = { score: 0, name: plname, color: get_user_color(plname) };
      }
    }
    if (playerlist.length != pldatalist.length) {
      phpPost({ friendly: Z.friendly, uname: Z.uplayer, players: pldatalist, fen: fen }, 'add_players');
    }
    fen.decrement = 0;
    start_downgrade_ticker();
  } else {
    assertion(Z.playerlist.includes(Z.uname), `${Z.uname} not in playerlist ${Z.playerlist} and not spectator`);
  }
}
function feedback_stats(d) {
  let players = Z.fen.players;
  let d1 = mDiv(d, { display: 'flex', 'justify-content': 'center', 'align-items': 'space-evenly' });
  for (const plname in players) {
    let pl = players[plname];
    let sz = 50;
    let bcolor = 'silver';
    let border = pl.playmode == 'bot' ? `double 5px ${bcolor}` : `solid 5px ${bcolor}`;
    let rounding = pl.playmode == 'bot' ? '0px' : '50%';
    let d2 = mDiv(d1, { margin: 4, align: 'center' }, null, `<img src='../base/assets/images/${plname}.jpg' style="border-radius:${rounding};display:block;border:${border};box-sizing:border-box" class='img_person' width=${sz} height=${sz}>`);
  }
}
function feedback_update_fen() {
  let fen = Z.fen;
  fen.barvalues = {};
  for (const pldata of Z.playerdata) {
    if (isdef(pldata.state)) {
      for (const color in pldata.state) {
        let value = pldata.state[color];
        if (isdef(fen.barvalues[color])) {
          fen.barvalues[color] += value;
        } else {
          fen.barvalues[color] = value;
        }
      }
    }
  }
  for (const k in fen.barvalues) {
    let val = fen.barvalues[k] - fen.decrement;
    if (val < 0) val = 0;
    fen.barvalues[k] = val;
  }
}
function felix_sends_timed_move_at_mimi_slot() {
  let [fen, pl] = [Z.fen, Z.pl];
  let slot = fen.players.mimi.slot;
  slot = busy_wait_until_slot(slot);
}
function fen_from_info(info) {
  let all_attrs = gSet_attributes();
  let keys = get_keys(all_attrs);
  let fen = '';
  for (const prop of keys) {
    let val = info[prop];
    let i = all_attrs[prop].indexOf(val);
    fen += '' + i;
  }
  return fen;
}
function fentest_wise() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('wise', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function fentest0_min_items() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  let pl = fen.players[uplayer];
  [pl.hand, pl.stall, Z.stage, Z.phase] = [['JSn', '2Hn', '3Hn', '3Dn', '3Cn', '4Hn'], ['QSn', 'KHn'], 5, 'king'];
  ensure_actions(fen);
  take_turn_fen();
}
function fentest1_auction() {
  Z.stage = 12;
  Z.phase = 'jack';
  ensure_market(Z.fen, 3);
  take_turn_fen();
}
function fentest10_ferro_end_of_round_goals() {
  let [game, A, fen, uplayer, plorder] = [Z.game, Z.A, Z.fen, Z.uplayer, Z.plorder];
  let pl = fen.players[plorder[0]];
  pl.hand = ['3Hn', '3Hn', '3Hn', '3Hn'];
  pl = fen.players[plorder[1]];
  pl.journeys = [['3Cn', '3Hn', '3Hn', '3Hn']];
  pl.goals['4'] = true;
  pl.hand = ['3Hn', 'KSn'];
  take_turn_fen();
}
function fentest2_build() {
  Z.stage = 5;
  Z.phase = 'king';
  ensure_stall(Z.fen, Z.uplayer, 4);
  ensure_actions(Z.fen);
  take_turn_fen();
}
function fentest4_visit() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  fen.actionsCompleted = [];
  for (const plname of fen.plorder) {
    add_a_schwein(fen, plname);
  }
  Z.stage = 5;
  Z.phase = 'queen';
  take_turn_fen();
}
function fentest5_market_opens() {
  Z.stage = 3;
  Z.phase = 'king';
  take_turn_fen();
}
function fentest6_endgame() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  fen.actionsCompleted = [];
  for (const plname of fen.plorder) {
    add_a_correct_building_to(fen, plname, 'chateau');
    add_a_correct_building_to(fen, plname, rChoose(['farm', 'estate', 'chateau']));
    if (coin()) add_a_correct_building_to(fen, plname, rChoose(['farm', 'estate', 'chateau']));
    fen.actionsCompleted.push(plname);
  }
  fen.pl_gameover = [];
  for (const plname of fen.plorder) {
    let bcorrect = ari_get_correct_buildings(fen.players[plname].buildings);
    let can_end = ari_check_end_condition(bcorrect);
    if (can_end) fen.pl_gameover.push(plname);
  }
  if (isEmpty(fen.pl_gameover)) { console.log('try again!!!!!!!!!!!'); return; }
  Z.stage = 10;
  Z.phase = 'king';
  take_turn_fen(true);
}
function fentest7_gameover() {
  let [game, A, fen, uplayer] = [Z.game, Z.A, Z.fen, Z.uplayer];
  if (game == 'aristo') fentest6_endgame();
  else if (game == 'spotit') {
    for (const plname in fen.players) { fen.players[plname].score = Z.options.winning_score - 1; }
    take_turn_fen();
  } else if (game == 'bluff') {
    let pl = fen.players[uplayer];
    while (pl.handsize < Z.options.max_handsize) inc_handsize(fen, uplayer);
    deck_add(fen.deck, 1, pl.hand);
    take_turn_fen();
  }
}
function fentest8_ferro_transation_error() {
  let [game, A, fen, uplayer] = [Z.game, Z.A, Z.fen, 'mimi'];
  let pl = fen.players[uplayer];
  pl.goals['3'] = true;
  pl.hand.push('3Hn', '3Hn', '3Hn');
  Z.turn = ['mimi'];
  take_turn_fen();
}
function fentest9_ferro_transation_error() {
  let [game, A, fen, uplayer] = [Z.game, Z.A, Z.fen, 'mimi'];
  let pl = fen.players[uplayer];
  pl.goals['3'] = true;
  pl.goals['4'] = true;
  pl.goals['5'] = true;
  pl.hand = ['3Hn', '3Hn', '3Hn', '2Cn', '2Cn', '2Cn', '*Cn', 'ACn', '*Cn'];
  Z.turn = ['mimi'];
  let other = firstCond(Z.playerlist, x => x != uplayer);
  pl = fen.players[other];
  pl.goals['4'] = true;
  pl.journeys = [['3Hn', '3Hn', '3Hn'], ['AHn', 'ACn', 'ACn', '*Cn']];
  take_turn_fen();
}
function ferro() {
  const rankstr = '23456789TJQKA*';
  function setup(players, options) {
    let fen = { players: {}, plorder: jsCopy(players), history: [] };
    options.jokers_per_group = 1;
    fen.allGoals = ['7R', '55', '5', '44', '4', '33', '3'];
    fen.availableGoals = options.maxrounds == 1 ? [rChoose(fen.allGoals)] : options.maxrounds < 7 ? rChoose(fen.allGoals, options.maxrounds) : fen.allGoals;
    fen.availableGoals.sort((a, b) => fen.allGoals.indexOf(a) - fen.allGoals.indexOf(b));
    fen.roundGoals = arrReverse(fen.availableGoals);
    let n = players.length;
    let num_decks = fen.num_decks = 2 + (n >= 9 ? 2 : n >= 7 ? 1 : 0);
    let deck = fen.deck = create_fen_deck('n', num_decks, 4 * num_decks);
    let deck_discard = fen.deck_discard = [];
    shuffle(deck);
    if (DA.TESTING != true) { shuffle(fen.plorder); shuffle(fen.plorder); }
    let starter = fen.plorder[0];
    let handsize = valf(Number(options.handsize), 11);
    for (const plname of players) {
      let pl = fen.players[plname] = {
        hand: deck_deal(deck, plname == starter ? handsize + 1 : handsize),
        journeys: [],
        roundgoal: false,
        coins: options.coins,
        vps: 0,
        score: 0,
        name: plname,
        color: get_user_color(plname),
      };
      pl.goals = {};
      for (const g of fen.availableGoals) { pl.goals[g] = 0; }
    }
    fen.phase = '';
    [fen.stage, fen.turn] = ['card_selection', [starter]];
    return fen;
  }
  function activate_ui() { ferro_activate_ui(); }
  function check_gameover() { return isdef(Z.fen.winners) ? Z.fen.winners : false; }
  function clear_ack() {
    if (Z.stage == 'round_end') { start_new_round_ferro(); take_turn_fen(); }
    else if (Z.stage != 'card_selection') {
      for (const plname of Z.fen.canbuy) {
        let pldata = firstCond(Z.playerdata, x => x.name == plname);
        if (isdef(pldata) && lookup(pldata, ['state', 'buy']) == true) {
          Z.fen.buyer = plname;
          break;
        }
      }
      Z.stage = 'can_resolve';
      ferro_change_to_card_selection();
    }
  }
  function present(dParent) { ferro_present(dParent); }
  function stats(dParent) { ferro_stats(dParent); }
  function state_info(dParent) { ferro_state(dParent); }
  return { rankstr, setup, activate_ui, check_gameover, clear_ack, present, state_info, stats };
}
function ferro_ack_uplayer() { if (Z.mode == 'multi') { ferro_ack_uplayer_multi(); } else { ferro_ack_uplayer_hotseat(); } }
function ferro_ack_uplayer_hotseat() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  let buy = !isEmpty(A.selected) && A.selected[0] == 0;
  if (buy || uplayer == fen.lastplayer) { fen.buyer = uplayer;[Z.turn, Z.stage] = [[get_multi_trigger()], 'can_resolve']; }
  else { Z.turn = [get_next_in_list(uplayer, fen.canbuy)]; }
  take_turn_fen();
}
function ferro_ack_uplayer_multi() {
  let [A, uplayer] = [Z.A, Z.uplayer];
  stopPolling();
  let o_pldata = Z.playerdata.find(x => x.name == uplayer);
  Z.state = o_pldata.state = { buy: !isEmpty(A.selected) && A.selected[0] == 0 };
  let can_resolve = ferro_check_resolve();
  if (can_resolve) {
    assertion(Z.stage == 'buy_or_pass', 'stage is not buy_or_pass when checking can_resolve!');
    Z.stage = 'can_resolve';
    [Z.turn, Z.stage] = [[get_multi_trigger()], 'can_resolve'];
    take_turn_fen_write();
  } else { take_turn_multi(); }
}
function ferro_activate_ui() { ferro_pre_action(); }
function ferro_change_to_ack_round() {
  let [plorder, stage, A, fen, uplayer] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer];
  let nextplayer = get_next_player(Z, uplayer);
  let newturn = jsCopy(plorder); while (newturn[0] != nextplayer) { newturn = arrCycle(newturn, 1); }
  let buyerlist = fen.canbuy = [];
  for (const plname of newturn) {
    let pl = fen.players[plname];
    if (plname == uplayer) { pl.buy = false; continue; }
    else if (pl.coins > 0) { pl.buy = false; buyerlist.push(plname); }
  }
  start_simple_ack_round('buy_or_pass', buyerlist, nextplayer, 'ferro_change_to_turn_round');
}
function ferro_change_to_buy_pass() {
  let [plorder, stage, A, fen, uplayer] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer];
  let nextplayer = get_next_player(Z, uplayer);
  let newturn = jsCopy(plorder); while (newturn[0] != nextplayer) { newturn = arrCycle(newturn, 1); }
  fen.canbuy = newturn.filter(x => x != uplayer && fen.players[x].coins > 0);
  fen.trigger = uplayer;
  fen.buyer = null;
  fen.nextturn = [nextplayer];
  if (isEmpty(fen.canbuy)) { Z.stage = 'can_resolve'; ferro_change_to_card_selection(); return; }
  else if (Z.mode == 'multi') { [Z.stage, Z.turn] = ['buy_or_pass', fen.canbuy]; fen.keeppolling = true; take_turn_fen_clear(); }
  else {
    fen.canbuy.map(x => fen.players[x].buy = 'unset');
    fen.lastplayer = arrLast(fen.canbuy);
    [Z.stage, Z.turn] = ['buy_or_pass', [fen.canbuy[0]]];
    take_turn_fen();
  }
}
function ferro_change_to_card_selection() {
  let [fen, stage] = [Z.fen, Z.stage];
  assertion(stage != 'card_selection', "ALREADY IN TURN ROUND!!!!!!!!!!!!!!!!!!!!!!");
  assertion(stage == 'can_resolve', "change to card_selection: NOT IN can_resolve stage!!!!!!!!!!!!!!!!!!!!!!");
  assertion(Z.uplayer == 'mimi' || Z.uplayer == fen.trigger, "mixup uplayer in change_to_card_selection!!!!!!!!!!!!!!!!!!!!!!");
  if (isdef(fen.buyer)) {
    let plname = fen.buyer;
    let pl = fen.players[plname];
    let card = fen.deck_discard.shift();
    pl.hand.push(card);
    lookupAddToList(pl, ['newcards'], card);
    deck_deal_safe_ferro(fen, plname, 1);
    pl.coins -= 1;
    ari_history_list([`${plname} bought ${card}`], 'buy');
  }
  let nextplayer = fen.nextturn[0];
  deck_deal_safe_ferro(fen, nextplayer, 1);
  Z.turn = fen.nextturn;
  Z.stage = 'card_selection';
  for (const k of ['buyer', 'canbuy', 'nextturn', 'trigger', 'lastplayer']) delete fen[k];
  delete fen.keeppolling;
  clear_transaction();
  take_turn_fen();
}
function ferro_change_to_turn_round() {
  let [z, A, fen, stage, uplayer, ui] = [Z, Z.A, Z.fen, Z.stage, Z.uplayer, UI];
  assertion(stage == 'buy_or_pass', "ALREADY IN TURN ROUND!!!!!!!!!!!!!!!!!!!!!!");
  for (const plname of fen.canbuy) {
    let pl = fen.players[plname];
    if (pl.buy == true) {
      let card = fen.deck_discard.shift();
      pl.hand.push(card);
      deck_deal_safe_ferro(fen, plname, 1);
      pl.coins -= 1;
      ari_history_list([`${plname} bought ${card}`], 'buy');
      break;
    }
  }
  deck_deal_safe_ferro(fen, fen.nextplayer, 1);
  Z.turn = fen.turn_after_ack;
  Z.stage = 'card_selection';
  clear_ack_variables();
  for (const k of ['canbuy']) delete fen[k];
  for (const plname of fen.plorder) { delete fen.players[plname].buy; }
  clear_transaction();
}
function ferro_check_resolve() {
  let [pldata, stage, A, fen, plorder, uplayer, deck, turn] = [Z.playerdata, Z.stage, Z.A, Z.fen, Z.plorder, Z.uplayer, Z.deck, Z.turn];
  let pl = fen.players[uplayer];
  assertion(stage == 'buy_or_pass', "check_resolve NOT IN buy_or_pass stage!!!!!!!!!");
  assertion(isdef(pldata), "no playerdata in buy_or_pass stage!!!!!!!!!!!!!!!!!!!!!!!");
  let done = true;
  for (const plname of turn) {
    let data = firstCond(pldata, x => x.name == plname);
    assertion(isdef(data), 'no pldata for', plname);
    let state = data.state;
    if (isEmpty(state)) done = false;
    else if (state.buy == true) fen.buyer = plname;
    else continue;
    break;
  }
  return done;
}
function ferro_get_card(ckey, h, w, ov = .25) {
  let type = ckey[2];
  let info = ckey[0] == '*' ? get_joker_info() : jsCopy(C52Cards[ckey.substring(0, 2)]);
  info.key = ckey;
  info.cardtype = ckey[2];
  let [r, s] = [info.rank, info.suit];
  info.val = r == '*' ? 50 : r == 'A' ? 20 : 'TJQK'.includes(r) ? 10 : Number(r);
  info.color = RED;
  info.sz = info.h = valf(h, Config.ui.card.h);
  info.w = valf(w, info.sz * .7);
  info.irank = '23456789TJQKA*'.indexOf(r);
  info.isuit = 'SHCDJ'.indexOf(s);
  info.isort = info.isuit * 14 + info.irank;
  let card = cardFromInfo(info, h, w, ov);
  return card;
}
function ferro_is_set(cards, max_jollies_allowed = 1, seqlen = 7, group_same_suit_allowed = true) {
  if (cards.length < 3) return false;
  let num_jollies_in_cards = cards.filter(x => is_joker(x)).length;
  if (num_jollies_in_cards > max_jollies_allowed) return false;
  cards = sortCardItemsByRank(cards.map(x => x), rankstr = '23456789TJQKA*');
  let rank = cards[0].rank;
  let isgroup = cards.every(x => x.rank == rank || is_joker(x));
  let suits = cards.filter(x => !is_joker(x)).map(x => x.suit);
  let num_duplicate_suits = suits.filter(x => suits.filter(y => y == x).length > 1).length;
  if (isgroup && !group_same_suit_allowed && num_duplicate_suits > 0) return false;
  else if (isgroup) return cards.map(x => x.key);
  let suit = cards[0].suit;
  if (!cards.every(x => is_jolly(x.key) || x.suit == suit)) return false;
  let keys = cards.map(x => x.key);
  if (keys.length != new Set(keys).size) return false;
  let at_most_jollies = Math.min(num_jollies_in_cards, max_jollies_allowed);
  let num_jolly = sortCardItemsToSequence(cards, rankstr = '23456789TJQKA', at_most_jollies);
  let cond1 = num_jolly <= at_most_jollies;
  let cond2 = cards.length >= seqlen;
  if (cond1 && cond2) return cards.map(x => x.key); else return false;
}
function ferro_pre_action() {
  let [stage, A, fen, plorder, uplayer, deck] = [Z.stage, Z.A, Z.fen, Z.plorder, Z.uplayer, Z.deck];
  switch (stage) {
    case 'can_resolve': if (Z.options.auto_weiter) ferro_change_to_card_selection(); else { select_add_items(ui_get_string_items(['weiter']), ferro_change_to_card_selection, 'may click to continue', 1, 1, Z.mode == 'multi'); select_timer(2000, ferro_change_to_card_selection); } break;
    case 'buy_or_pass': if (!is_playerdata_set(uplayer)) { select_add_items(ui_get_buy_or_pass_items(), ferro_ack_uplayer, 'may click discard pile to buy or pass', 1, 1); if (uplayer != 'nasi') select_timer(Z.options.thinking_time * 1000, ferro_ack_uplayer); } break;
    case 'card_selection': select_add_items(ui_get_ferro_items(uplayer), fp_card_selection, 'must select one or more cards', 1, 100); break;
    default: console.log('stage is', stage); break;
  }
}
function ferro_present(dParent) {
  if (DA.simulate == true) show('bRestartMove'); else hide('bRestartMove');
  let [fen, ui, uplayer, stage, pl] = [Z.fen, UI, Z.uplayer, Z.stage, Z.pl];
  let [dOben, dOpenTable, dMiddle, dRechts] = tableLayoutMR(dParent);
  ferro_stats(dRechts);
  show_history(fen, dRechts);
  let deck = ui.deck = ui_type_deck(fen.deck, dOpenTable, { maleft: 12 }, 'deck', 'deck', ferro_get_card);
  let deck_discard = ui.deck_discard = ui_type_deck(fen.deck_discard, dOpenTable, { maleft: 12 }, 'deck_discard', '', ferro_get_card);
  if (!isEmpty(deck_discard.items)) face_up(deck_discard.get_topcard());
  order = get_present_order();
  for (const plname of order) {
    let pl = fen.players[plname];
    let playerstyles = { w: '100%', bg: '#ffffff80', fg: 'black', padding: 4, margin: 4, rounding: 10, border: `2px ${get_user_color(plname)} solid` };
    let d = mDiv(dMiddle, playerstyles, null, get_user_pic_html(plname, 25));
    mFlexWrap(d);
    mLinebreak(d, 10);
    let hidden = compute_hidden(plname);
    ferro_present_player(plname, d, hidden);
  }
  Z.isWaiting = false;
  if (Z.stage == 'round_end') {
    show_waiting_for_ack_message();
    if (Z.role == 'active' || i_am_host()) {
      show('bClearAck');
    }
  } else if (Z.stage == 'buy_or_pass' && uplayer == fen.trigger && ferro_check_resolve()) {
    assertion(Z.stage == 'buy_or_pass', 'stage is not buy_or_pass when checking can_resolve!');
    Z.stage = 'can_resolve';
    [Z.turn, Z.stage] = [[get_multi_trigger()], 'can_resolve'];
    take_turn_fen(); return;
  } else if (Z.stage == 'buy_or_pass' && (Z.role != 'active' || is_playerdata_set(uplayer))) {
    assertion(isdef(Z.playerdata), 'playerdata is not defined in buy_or_pass (present ferro)');
    let pl_not_done = Z.playerdata.filter(x => Z.turn.includes(x.name) && isEmpty(x.state)).map(x => x.name);
    show_waiting_message(`waiting for possible buy decision...`);
    Z.isWaiting = true;
  }
  show_handsorting_buttons_for(Z.mode == 'hotseat' ? Z.uplayer : Z.uname, { bottom: -2 });
  new_cards_animation();
}
function ferro_present_new(z, dParent, uplayer) {
  let [fen, ui, stage] = [z.fen, UI, z.stage];
  let [dOben, dOpenTable, dMiddle, dRechts] = tableLayoutMR(dParent);
  ferro_stats_new(z, dRechts);
  show_history(fen, dRechts);
  let deck = ui.deck = ui_type_deck(fen.deck, dOpenTable, { maleft: 12 }, 'deck', 'deck', ferro_get_card);
  let deck_discard = ui.deck_discard = ui_type_deck(fen.deck_discard, dOpenTable, { maleft: 12 }, 'deck_discard', '', ferro_get_card);
  if (!isEmpty(deck_discard.items)) face_up(deck_discard.get_topcard());
  let uname_plays = fen.plorder.includes(Z.uname);
  let show_first = uname_plays && Z.mode == 'multi' ? Z.uname : uplayer;
  order = arrCycle(fen.plorder, fen.plorder.indexOf(show_first));
  for (const plname of order) {
    let pl = fen.players[plname];
    let playerstyles = { w: '100%', bg: '#ffffff80', fg: 'black', padding: 4, margin: 4, rounding: 10, border: `2px ${get_user_color(plname)} solid` };
    let d = mDiv(dMiddle, playerstyles, null, get_user_pic_html(plname, 25));
    mFlexWrap(d);
    mLinebreak(d, 10);
    let hidden = compute_hidden(plname);
    ferro_present_player_new(z, plname, d, hidden);
  }
}
function ferro_present_player(plname, d, ishidden = false) {
  let fen = Z.fen;
  let pl = fen.players[plname];
  let ui = UI.players[plname] = { div: d };
  Config.ui.card.h = ishidden ? 100 : 150;
  Config.ui.container.h = Config.ui.card.h + 30;
  if (!ishidden) pl.hand = correct_handsorting(pl.hand, plname);
  let hand = ui.hand = ui_type_hand(pl.hand, d, {}, `players.${plname}.hand`, 'hand', ferro_get_card);
  if (ishidden) { hand.items.map(x => face_down(x)); }
  ui.journeys = [];
  let i = 0;
  for (const j of pl.journeys) {
    let jui = ui_type_lead_hand(j, d, { maleft: 12, h: 130 }, `players.${plname}.journeys.${i}`, '', ferro_get_card);
    i += 1;
    ui.journeys.push(jui);
  }
}
function ferro_present_player_new(g, plname, d, ishidden = false) {
  let fen = g.fen;
  let pl = fen.players[plname];
  let ui = UI.players[plname] = { div: d };
  Config.ui.card.h = ishidden ? 100 : 150;
  Config.ui.container.h = Config.ui.card.h + 30;
  if (isdef(pl.handsorting)) {
    let bysuit = pl.handsorting.by == 'suit';
    let [arr1, arr2] = arrSplitAtIndex(pl.hand, pl.handsorting.n - 1);
    pl.hand = sort_cards(arr1, bysuit, 'CDSH', true, '23456789TJQKA*').concat(arr2);
  }
  let hand = ui.hand = ui_type_hand(pl.hand, d, {}, `players.${plname}.hand`, 'hand', ferro_get_card);
  if (ishidden) { hand.items.map(x => face_down(x)); }
  else {
    ensure_buttons_visible_for(Z.mode == 'hotseat' ? Z.uplayer : Z.uname);
  }
  ui.journeys = [];
  let i = 0;
  for (const j of pl.journeys) {
    let jui = ui_type_lead_hand(j, d, { maleft: 12, h: 130 }, `players.${plname}.journeys.${i}`, '', ferro_get_card);
    i += 1;
    ui.journeys.push(jui);
  }
}
function ferro_process_discard() {
  let [plorder, stage, A, fen, uplayer] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer];
  let pl = fen.players[uplayer];
  if (!isEmpty(pl.journeys) && !pl.roundgoal) {
    let goal = is_fixed_goal() ? get_round_goal() : calc_ferro_highest_goal_achieved(pl);
    pl.roundgoal = goal;
    pl.goals[goal] = true;
    ari_history_list([`${pl.name} achieved goal ${pl.roundgoal}`], 'achieve');
  }
  let c = A.selectedCards[0].key;
  elem_from_to_top(c, fen.players[uplayer].hand, fen.deck_discard);
  ari_history_list([`${uplayer} discards ${c}`], 'discard');
  if (fen.players[uplayer].hand.length == 0) { end_of_round_ferro(); } else ferro_change_to_buy_pass();
}
function ferro_process_jolly(key, j) {
  let [plorder, stage, A, fen, uplayer] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer];
  let a = key;
  let b = j.find(x => x[0] == '*');
  arrReplace1(fen.players[uplayer].hand, a, b);
  replace_jolly(key, j);
  ari_history_list([`${uplayer} replaces for jolly`], 'jolly');
  Z.stage = 'card_selection';
}
function ferro_process_set(keys) {
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  if (is_group(keys)) {
    keys = sort_cards(keys, true, 'CDSH', true, '23456789TJQKA*');
  }
  let j = [];
  keys.map(x => elem_from_to(x, fen.players[uplayer].hand, j));
  fen.players[uplayer].journeys.push(j);
  ari_history_list([`${uplayer} reveals ${j.join(', ')}`], 'auflegen');
  Z.stage = 'card_selection';
}
function ferro_state(dParent) {
  if (DA.TEST0 == true) {
    let html = `${Z.stage}`;
    if (isdef(Z.playerdata)) {
      let trigger = get_multi_trigger();
      if (trigger) html += ` trigger:${trigger}`;
      for (const data of Z.playerdata) {
        if (data.name == trigger) continue;
        let name = data.name;
        let state = data.state;
        let s_state = object2string(state);
        html += ` ${name}:'${s_state}'`;
      }
      dParent.innerHTML += ` ${Z.playerdata.map(x => x.name)}`;
    }
    dParent.innerHTML = html;
    return;
  }
  if (Z.stage == 'round_end') {
    dParent.innerHTML = `Round ${Z.round} ended by &nbsp;${get_user_pic_html(Z.fen.round_winner, 30)}`;
  } else if (is_fixed_goal()) {
    let goal = get_round_goal();
    console.log('goal', goal);
    let goal_html = `<div style="font-weight:bold;border-radius:50%;background:white;color:red;line-height:100%;padding:4px 8px">${goal}</div>`;
    dParent.innerHTML = `Round ${Z.round}:&nbsp;&nbsp;minimum:&nbsp;${goal_html}`;
  } else {
    let user_html = get_user_pic_html(Z.stage == 'buy_or_pass' ? Z.fen.nextturn[0] : Z.turn[0], 30);
    dParent.innerHTML = `Round ${Z.round}:&nbsp;${Z.stage == 'buy_or_pass' ? 'next ' : ''}turn: ${user_html} `;
  }
}
function ferro_state_new(dParent) {
  if (is_fixed_goal()) {
    let goal = get_round_goal();
    let goal_html = `<div style="font-weight:bold;border-radius:50%;background:white;color:red;line-height:100%;padding:4px 8px">${goal}</div>`;
    dParent.innerHTML = `Round ${Z.round}:&nbsp;&nbsp;minimum:&nbsp;${goal_html}`;
  } else {
    let user_html = get_user_pic_html(Z.stage == 'buy_or_pass' ? Z.fen.turn_after_ack[0] : Z.turn[0], 30);
    dParent.innerHTML = `Round ${Z.round}:&nbsp;${Z.stage == 'buy_or_pass' ? 'next ' : ''}turn: ${user_html} `;
  }
}
function ferro_stats(dParent) {
  let player_stat_items = UI.player_stat_items = ui_player_info(dParent);
  let fen = Z.fen;
  for (const plname in fen.players) {
    let pl = fen.players[plname];
    let item = player_stat_items[plname];
    let d = iDiv(item); mCenterFlex(d); mStyle(d, { wmin: 150 }); mLinebreak(d);
    player_stat_count('coin', pl.coins, d);
    player_stat_count('pinching hand', pl.hand.length, d);
    if (!compute_hidden(plname)) player_stat_count('hand with fingers splayed', calc_hand_value(pl.hand), d);
    player_stat_count('star', pl.score, d);
    mLinebreak(d, 4);
    if (!is_fixed_goal()) {
      let d2 = mDiv(d, { padding: 4, display: 'flex' }, `d_${plname}_goals`);
      if (fen.availableGoals.length < 4) { mStyle(d2, { wmin: 120 }); mCenterFlex(d2); }
      let sz = 16;
      let styles_done = { h: sz, fz: sz, maleft: 6, fg: 'grey', 'text-decoration': 'line-through green', weight: 'bold' };
      let styles_todo = { h: sz, fz: sz, maleft: 6, border: 'red', weight: 'bold', padding: 4, 'line-height': sz };
      for (const k of fen.roundGoals) {
        mText(k, d2, pl.goals[k] ? styles_done : styles_todo);
      }
    }
    if (fen.turn.includes(plname)) { show_hourglass(plname, d, 30, { left: -3, top: 0 }); }
  }
}
function ferro_stats_new(z, dParent) {
  let player_stat_items = UI.player_stat_items = ui_player_info(z, dParent);
  let fen = z.fen;
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    let item = player_stat_items[plname];
    let d = iDiv(item); mCenterFlex(d); mLinebreak(d);
    player_stat_count('coin', pl.coins, d);
    player_stat_count('pinching hand', pl.hand.length, d);
    if (!compute_hidden(plname)) player_stat_count('hand with fingers splayed', calc_hand_value(pl.hand), d);
    player_stat_count('star', pl.score, d);
    mLinebreak(d, 4);
    if (!is_fixed_goal()) {
      let d2 = mDiv(d, { padding: 4, display: 'flex' }, `d_${plname}_goals`);
      let sz = 16;
      let styles_done = { h: sz, fz: sz, maleft: 6, fg: 'grey', 'text-decoration': 'line-through green', weight: 'bold' };
      let styles_todo = { h: sz, fz: sz, maleft: 6, border: 'red', weight: 'bold', padding: 4, 'line-height': sz };
      for (const k in pl.goals) {
        mText(k, d2, pl.goals[k] ? styles_done : styles_todo);
      }
    }
    if (fen.turn.includes(plname)) { show_hourglass(plname, d, 30, { left: -3, top: 0 }); }
  }
}
function ferro_transaction_error() {
  let d = mDiv(dError, { padding: 10, align: 'center' }, null, `Illegal turn sequence - transaction cannot be completed!!!<br>press reload and try again!<br>`);
  mButton('RELOAD', onclick_reload, d, { margin: 10 });
  clear_transaction();
}
function ferro_ut0_create_staged() {
  console.log('*** test ferro 0: buy_or_pass with no coins ***');
  DA.test.number = 0;
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let otherplayer = firstCond(fen.plorder, (p) => p != uplayer);
  let pl = fen.players[otherplayer];
  pl.coins = 0;
  DA.fen0 = fen;
  DA.auto_moves = [[],
  [['visit'], ['last'], [0]],
  [['visit'], ['last'], [1]],
  [['pass']],
  ];
  return [fen, player_names];
}
async function fetch_wrapper(url) { return await fetch(url); }
async function fetch_wrapper_NO(url) {
  route_counter += 1;
  if (SHOW_SERVER_ROUTE) consOutput(route_counter + ': route:' + url);
  let res = await fetch(url).then((response) => {
    if (response.status === 200) {
      if (SHOW_SERVER_RETURN) consOutput(route_counter + ': return:', response);
    } else {
      throw new Error('Something went wrong');
    }
  }).catch((error) => {
    console.log(error)
  });
  return res;
}
async function fetchFileAsText(url) {
  let f = await fetch(url);
  let txt = await f.text();
  return txt;
}
function fiddleAdd(dParent, content, idx) {
  let ta = AU.ta = mTextarea(3, null, dParent, { fz: 16, padding: 10, family: 'tahoma', w: '100%', box: true });
  ta.addEventListener('keydown', fiddleControlHandler);
  ta.addEventListener('keydown', fiddleEnterResize);
  DA.tribute.attach(ta);
  DA.tas.push(ta);
  ta.addEventListener('tribute-replaced', fiddleMessageHandler);
  if (isdef(content)) ta.value = content;
  if (isdef(idx)) mInsertAt(dParent, ta, idx);
  ta.focus();
}
function fiddleControlHandler(ev) {
  if (ev.ctrlKey) {
    let instance = DA.tribute;
    instance.isActive = false;
    instance.hideMenu();
    if (ev.key == 'Enter') {
      runcode(ev.target.value);
    } else if (ev.key == '+' || ev.key == '=') {
      evStop(ev);
      fiddleAdd(dFiddle);
    } else if (ev.key == '-' || ev.key == '_') {
      evStop(ev);
      let empty = DA.tas.filter(x => isEmptyOrWhiteSpace(x.value));
      let elfocus = document.activeElement;
      let nofocus = false;
      for (const ta of empty) { if (ta == elfocus) nofocus = true; ta.remove(); }
      DA.tas = arrMinus(DA.tas, empty);
      if (isEmpty(DA.tas)) fiddleAdd(dFiddle);
      else if (nofocus) { AU.ta = DA.tas[0]; AU.ta.focus(); }
    } else if (ev.key == 'ArrowDown') {
      let ta = AU.ta = arrNext(DA.tas, AU.ta);
      ta.focus();
    } else if (ev.key == 'ArrowUp') {
      let ta = AU.ta = arrPrev(DA.tas, AU.ta);
      ta.focus();
    }
  }
}
function fiddleEnterResize(ev) {
  if (ev.key == 'Enter') {
    console.log('hallo!');
    let ta = ev.target;
    let x = ta.value;
    let lines = x.split('\n');
    let min = lines.length + 1;
    let coords = getCaretCoordinates(ta, ta.selectionEnd);
    console.log('coords', coords, 'window height', window.innerHeight)
    if (coords.top + 60 < window.innerHeight && (nundef(ta.rows) || ta.rows < min)) ta.rows = min;
  }
}
function fiddleInit(dParent, dParentConsole) {
  dFiddle = valf(dParent, dTable);
  dMessage = mDiv(dFiddle, { w: '100%', bg: 'dimgray', fg: 'yellow', box: true, hpadding: 10 }, 'dMessage', 'enter code:');
  getGlobals();
  let list = Globals.function.map(x => ({ key: x.key, value: x.key + '(' }));
  DA.tas = [];
  var tributeAttributes = {
    autocompleteMode: true,
    //noMatchTemplate: '', //null, //' ',
    noMatchTemplate: () => {
      return '<span style:"visibility: hidden;"></span>';
    },
    values: fiddleSearch,
    selectTemplate: function (item) {
      if (typeof item === 'undefined') return null;
      if (this.range.isContentEditable(this.current.element)) {
        return '<span contenteditable="false"><a>' + item.original.key + '</a></span>';
      }
      return item.original.value;
    },
    menuItemTemplate: function (item) {
      return item.string;
    },
    replaceTextSuffix: '(',
    menuShowMinLength: 1,
  };
  var trib = DA.tribute = new Tribute(Object.assign({ menuContainer: dParent, }, tributeAttributes));
  let saved = localStorage.getItem('codelist');
  let codelist = saved ? JSON.parse(saved) : [];
  if (codelist.length == 0) codelist = [`console.log('hallo');`];
  for (const code of codelist) {
    fiddleAdd(dFiddle, code);
  }
  setTimeout(() => dFiddle.children[0].focus(), 100);
}
function fiddleMessageHandler(ev) {
  let key = ev.detail.item.original.key;
  let item = window[key];
  if (typeof item == 'function') {
    let d = mBy('dMessage');
    d.innerHTML = stringBefore(item.toString(), ') {') + ')';
  }
}
function fiddleSave() {
  if (isdef(dFiddle)) {
    let codelist = arrChildren(dFiddle).slice(1).filter(x => !isEmptyOrWhiteSpace(x.value)).map(x => x.value);
    localStorage.setItem('codelist', JSON.stringify(codelist));
    lookupSetOverride(DB, ['env', 'fiddle'], codelist);
  } else console.log('fiddle closed - not saved')
}
function fiddleSearch(text, callback) {
  console.log('text', text)
  let list = Globals.function;
  let list1 = list.filter(x => startsWith(x.key, text));
  callback(list1);
}
function fillCharInput(inp, ch) {
  let d = iDiv(inp);
  d.innerHTML = ch;
  mRemoveClass(d, 'blink');
}
function fillColarr(colarr, items) {
  let i = 0;
  let result = [];
  for (const r of colarr) {
    let arr = [];
    for (let c = 0; c < r; c++) {
      arr.push(items[i]); i++;
    }
    result.push(arr);
  }
  return result;
}
function fillout_boa_login() {
  let data = DIBOA.bw_info.boa;
  let elem_userid = get_boa_userid_input();
  let elem_pwd = get_boa_pwd_input();
  elem_userid.value = data.userid;
  elem_pwd.value = data.pwd;
}
function filter_codebase() {
  let words = toWords(mBy('iKeywords').value);
  console.log('filter_codebase: keywords are', words);
  let di = CODE.funcs;
  let di_values = get_values(di);
  let records = di_values.filter(x => x.body.includes(words[0]));
  console.log('records', records)
  AU.ta.value = '';
  for (const r of records) {
    let k = r.name;
    AU.ta.value += di[k].body + '\n';
  }
}
function filter_list() {
  let words = toWords(mBy('iKeywords').value);
  console.log('filter_list: keywords are', words);
  let di = CODE.funcs;
  let di_values = get_values(di);
  let records = di_values.filter(x => x.body.includes(words[0]));
  console.log('records', records)
  mClear(dSidebar)
  for (const rec of records) {
    let key = rec.name;
    let d = mDiv(dSidebar, { cursor: 'pointer', wmin: 100 }, null, key, 'hop1')
    let info = rec.body;
    d.onclick = () => AU.ta.value = info;
  }
}
function filter_sig() {
  let words = toWords(mBy('iKeywords').value);
  console.log('filter_sig: keywords are', words);
  let di = CODE.funcs;
  let di_values = get_values(di);
  let records = di_values.filter(x => x.body.includes(words[0]));
  console.log('records', records)
  AU.ta.value = '';
  for (const r of records) {
    let k = r.name;
    AU.ta.value += di[k].sig + '\n';
  }
}
function filterByKey(o, desiredKeys) {
  let o1 = {};
  for (const k of desiredKeys) {
    if (isdef(o[k])) {
      o1[k] = o[k];
    }
  }
  return o1;
}
function filterByLength(w, min, max, allowSpaces = false) { return w.length <= max && w.length >= min && (allowSpaces || !w.includes(' ')); }
function filterByNoKey(o, undesiredKeys) {
  let o1 = {};
  for (const k in o) {
    if (undesiredKeys.includes(k)) continue;
    o1[k] = o[k];
  }
  return o1;
}
function filterDistinctLetters(s) {
  let arr = [];
  for (let i = 0; i < s.length; i++) {
    let ch = s[i];
    if (isLetter(ch) && !arr.includes(ch)) arr.push(ch);
  }
  return arr;
}
function filterStringFromTuples(strings, tuples) {
  let result = [];
  for (const t of tuples) {
    for (const s of t) {
      if (strings.includes(s)) {
        result.push(s);
      }
    }
  }
  return result;
}
function filterWordByLengthG(g, k, w, allowSpaces = false) {
  if (nundef(g.minWordLength)) g.minWordLength = 0;
  if (nundef(g.maxWordLength)) g.maxWordLength = 50;
  return filterByLength(w, g.minWordLength, g.maxWordLength, allowSpaces);
}
function find_card(index, ui_item) { return ui_item.items[index]; }
function find_common_ancestor(d1, d2) { return dTable; }
function find_index_of_jolly(j) { return j.findIndex(x => is_jolly(x)); }
function find_jolly_rank(j, rankstr = 'A23456789TJQKA') {
  let jolly_idx = find_index_of_jolly(j);
  if (jolly_idx == -1) return false;
  if (jolly_idx > 0) {
    let rank_before_index = j[jolly_idx - 1][0];
    let rank_needed = rankstr[rankstr.indexOf(rank_before_index) + 1];
    return rank_needed;
  } else {
    let rank_after_index = j[jolly_idx + 1][0];
    let rank_needed = rank_after_index == 'A' ? 'K' : rankstr[rankstr.indexOf(rank_after_index) - 1];
    return rank_needed;
  }
}
function find_journeys(fen, uplayer) {
  let h = fen.players[uplayer].hand;
  let seqs = find_sequences(h, 2, 'A23456789TJQK');
  if (!isEmpty(seqs)) return seqs;
  let existing_journeys = aggregate_player(fen, 'journeys');
  for (const j of existing_journeys) {
    let h1 = j.concat(h);
    let seqs1 = find_sequences(h1, j.length + 1, 'A23456789TJQK');
    if (!isEmpty(seqs1)) return seqs1;
  }
  return seqs;
}
function find_minimum(array) {
  let min = array[0];
  for (let i = 1; i < array.length; i++) {
    if (array[i] < min) min = array[i];
  }
  return min;
}
function find_minimum_by_function(array, func) {
  let min = func(array[0]);
  for (let i = 1; i < array.length; i++) {
    if (func(array[i]) < func(min)) min = array[i];
  }
  return min;
}
function find_next_loc_oid_with_existing_parent(locOids, sdata, R) {
  for (const oid of locOids) {
    let o = sdata[oid];
    let loc = o.loc;
    let parentID = loc;
    if (!isEmpty(R.rNodesOidKey[parentID])) return oid;
  }
  return null;
}
function find_players_with_max_score() {
  let [plorder, stage, A, fen, uplayer] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer];
  let maxscore = -Infinity;
  let maxscorepls = [];
  for (const plname of plorder) {
    let pl = fen.players[plname];
    if (pl.score > maxscore) { maxscore = pl.score; maxscorepls = [plname]; }
    else if (pl.score == maxscore) maxscorepls.push(plname);
  }
  return maxscorepls;
}
function find_players_with_min_score() {
  let [plorder, stage, A, fen, uplayer] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer];
  let minscore = Infinity;
  let minscorepls = [];
  for (const plname of plorder) {
    let pl = fen.players[plname];
    if (pl.score < minscore) { minscore = pl.score; minscorepls = [plname]; }
    else if (pl.score == minscore) minscorepls.push(plname);
  }
  return minscorepls;
}
function find_players_with_potential_journey(fen) {
  let res = [];
  for (const uplayer of fen.plorder) {
    if (isdef(fen.passed) && fen.passed.includes(uplayer)) continue;
    let j = find_journeys(fen, uplayer);
    if (!isEmpty(j)) res.push(uplayer);
  }
  return res;
}
function find_sequences(blatt, n = 2, rankstr = '23456789TJQKA', allow_cycle = false) {
  let suitlists = get_suitlists_sorted_by_rank(blatt, rankstr, true);
  let seqs = [];
  for (const lst of get_values(suitlists)) {
    let len = lst.length;
    if (len < n) continue;
    let l = allow_cycle ? lst.concat(lst) : lst;
    for (let istart = 0; istart < len; istart++) {
      let seq = [l[istart]];
      let i = istart;
      while (i + 1 < l.length && follows_in_rank(l[i], l[i + 1], rankstr)) {
        seq.push(l[i + 1]);
        i++;
      }
      if (seq.length >= n) seqs.push(seq);
    }
  }
  return seqs;
}
function find_shared_keys(keylist, keylists) {
  let shared = [];
  for (const keylist2 of keylists) {
    for (const key of keylist) {
      if (keylist2.includes(key)) {
        shared.push(key);
      }
    }
  }
  return shared;
}
function findAddress(kSelf, x, path) {
  let path1 = stringAfter(path, 'self');
  path1 = kSelf + path1;
  if (path1[0] != '.') path1 = '.' + path1;
  let x1 = calcAddressWithin(x, path1);
  return [x1.key, x1.obj];
}
function findAncestorElemOfType(el, type) {
  while (el) {
    let t = getTypeOf(el);
    if (t == type) break;
    el = el.parentNode;
  }
  return el;
}
function findAncestorElemWithParentOfType(el, type) {
  while (el && el.parentNode) {
    let t = getTypeOf(el);
    let tParent = getTypeOf(el.parentNode);
    if (tParent == type) break;
    el = el.parentNode;
  }
  return el;
}
function findAttributeInAncestors(elem, attr) {
  let val;
  while (elem && nundef(val = elem.getAttribute(attr))) { elem = elem.parentNode; }
  return val;
}
function findChildOfType(type, parentElem) {
  let children = arrChildren(parentElem);
  for (const ch of children) {
    if (getTypeOf(ch) == type) return ch;
  }
  return null;
}
function findChildrenOfType(type, parentElem) {
  let children = arrChildren(parentElem);
  let res = [];
  for (const ch of children) {
    if (getTypeOf(ch) == type) res.push(ch);
  }
  return res;
}
function findChildWithClass(className, parentElem) {
  testHelpers(parentElem);
  let children = arrChildren(parentElem);
  for (const ch of children) {
    if (ch.classList.includes(className)) return ch;
  }
  return null;
}
function findChildWithId(id, parentElem) {
  testHelpers(parentElem);
  let children = arrChildren(parentElem);
  for (const ch of children) {
    if (ch.id == id) return ch;
  }
  return null;
}
function findClosestTile(fMetric, goalTile, tilenames) {
  let distances = tilenames.map(x => fMetric(x, goalTile));
  const indexOfMin = distances.indexOf(Math.min(...distances));
  let best = tilenames[indexOfMin];
  return best;
}
function findClosestTupleForItem(tuples, item, assets) {
  tuples = tuples.filter(x => x[0] == item.id);
  if (tuples.length == 0) return null;
  let tilenames = tuples.map(x => x[1]);
  let closestTile = findClosestTile((a, b) => assets.distanceBetweenTiles(a, b), item.goalTile, tilenames);
  let dCurrent = assets.distanceBetweenTiles(item.tile, item.goalTile);
  let dNew = assets.distanceBetweenTiles(closestTile, item.goalTile);
  if (dNew > dCurrent) {
    return null;
  }
  return firstCond(tuples, x => x[1] == closestTile);
}
function findClosestUnit(fMetric, goalTile, units) {
  let distances = units.map(x => fMetric(x.tile, goalTile));
  const indexOfMin = distances.indexOf(Math.min(...distances));
  let best = units[indexOfMin];
  return best;
}
function findCommonPrefix(s1, s2) {
  let i = 0;
  let res = '';
  while (i < s1.length && i < s2.length) {
    if (s1[i] != s2[i]) break; else res += s1[i];
    i += 1;
  }
  return res;
}
function findDescendantOfType(type, parent) {
  if (getTypeOf(parent) == type) return parent;
  let children = arrChildren(parent);
  if (isEmpty(children)) return null;
  for (const ch of children) {
    let res = findDescendantOfType(type, ch);
    if (res) return res;
  }
  return null;
}
function findDescendantWithId(id, parent) {
  if (parent.id == id) return parent;
  let children = arrChildren(parent);
  if (isEmpty(children)) return null;
  for (const ch of children) {
    let res = findDescendantWithId(id, ch);
    if (res) return res;
  }
  return null;
}
function findDOMAncestorOfType(elem, t = 'div') {
  let anc = elem.parentNode;
  while (MSCATS[getTypeOf(anc)] != t) { anc = anc.parentNode; }
  return anc;
}
function findDragTarget(ev) {
  let targetElem = ev.target;
  while (!targetElem.ondragover) targetElem = targetElem.parentNode;
  return targetElem;
}
function findFirst(arr, attr, val) {
  let matches = arr.filter(x => attr in x && x[attr] == val);
  return empty(matches) ? null : matches[0];
}
function findFirstListKey(o, childrenKeys) {
  for (const k in o) {
    let val = o[k];
    if (childrenKeys && childrenKeys.includes(k) || isList(val)) {
      return k;
    }
  }
  return null;
}
function findFreeWall(r1, walls) {
  r1 = isString(r1) ? Items[r1] : r1;
  if (nundef(walls)) {
    walls = [];
    for (const dir in r1.walls) {
      walls = walls.concat(r1.walls[dir]);
    }
  }
  walls = walls.filter(x => !x.door);
  return isEmpty(walls) ? null : chooseRandom(walls);
}
function findItemFromElem(items, elem) { let item = firstCond(items, x => iDiv(x) == elem); return item; }
function findItemFromEvent(items, ev) { return evToItemC(ev); }
function findItemFromKey(items, key) { return firstCond(items, x => x.key == key); }
function findKey(dict, val) { for (const k in dict) { if (dict[k] == val) return k; } }
function findKeys(s) { return SymKeys.filter(x => contains(x, s) || contains(Syms[x].E, s) || isdef(Syms[x].D) && contains(Syms[x].D, s)); }
function findLongestWord(arr) { return arr[arrMinMax(arr, x => x.length).imax]; }
function findMatch(odict, condList) {
  if (isListOfLiterals(condList)) condList = [condList];
  let Board = lastCondDictPlusKey(odict, x => {
    for (const tuple of condList) {
      if (x[tuple[0]] != tuple[1]) return false;
    }
    return true;
  });
  return Board;
}
function findOrCreateKeysForObjTypes(oids, R) {
  let keysForOids = {};
  for (const oid of oids) {
    let key = R.getR(oid);
    if (!isEmpty(key)) {
      keysForOids[oid] = key[0];
    } else {
      key = getUID();
      let o = R.getO(oid);
      let nSpec = R.lastSpec[key] = { cond: { obj_type: o.obj_type }, type: 'info' };
      R.addR(oid, key);
      let otype = o.obj_type;
      let sameTypeOids = oids.filter(x => R.getO(x).obj_type == otype);
      let oSuper = {};
      for (const oid1 of sameTypeOids) {
        let o1 = R.getO(oid1);
        for (const k1 in o1) {
          if (k1 == 'obj_type' || k1 == 'oid' || !isLiteral(o1[k1])) continue;
          if (isdef(oSuper[k1])) continue;
          oSuper[k1] = '.' + k1;
        }
      }
      let dataKeys = Object.keys(oSuper);
      if (dataKeys.length == 0) oSuper = 'X';
      else if (dataKeys.length == 1) oSuper = '.' + dataKeys[0];
      nSpec.data = oSuper;
      keysForOids[oid] = key;
      R.updateR(key);
    }
  }
  return keysForOids;
}
function findParentWithClass(elem, className) { while (elem && !mHasClass(elem, className)) { elem = elem.parentNode; } return elem; }
function findParentWithId(elem) { while (elem && !(elem.id)) { elem = elem.parentNode; } return elem; }
function findPool(id) {
  if (G.players[id]) return G.playersAugmented;
  else if (G.table[id]) return G.table;
}
function findSameSet(llst, lst) {
  for (const l of llst) {
    if (sameList(l, lst)) return l;
  }
  return null;
}
function findSuitableVoice(text, voiceDesc) {
  let voiceKey = 'david';
  if (currentLanguage == 'D') {
    voiceKey = 'deutsch';
  } else if (text.includes('bad')) {
    voiceKey = 'zira';
  } else if (voiceDesc == 'random') {
    voiceKey = chooseRandom(['david', 'zira', 'us', 'ukFemale', 'ukMale']);
  } else if (isdef(voiceNames[voiceDesc])) {
    voiceKey = voiceDesc;
  } else if (isdef(voiceDesc)) {
    let tryVoiceKey = firstCondDict(voiceNames, x => startWith(x, voiceDesc));
    if (tryVoiceKey) voiceKey = tryVoiceKey;
  }
  let voiceName = voiceNames[voiceKey];
  let voice = firstCond(voices, x => startsWith(x.name, voiceName));
  return [voiceKey, voice];
}
function findTable(createNew = false) {
  let idTables = U.tables;
  if (isdef(idTables)) {
    for (const id of idTables) {
      let t = DB.tables[id];
      if (t.game == Gamename) return id;
    }
  }
  return createNew ? createTable() : null;
}
function findWall(r1, r2) {
  for (const dir in r1.walls) {
    let walls = r1.walls[dir];
    for (const wall of walls) {
      if (wall.r2 == r2.id) return wall;
    }
  }
  return null;
}
function fintegral(exp) {
  return nerdamer(`integrate(${exp},x)`).buildFunction();
}
function fireClick(elem) {
  const evt = new Event("click", { "bubbles": true, "cancelable": false });
  elem.dispatchEvent(evt);
}
function fireKey(k, { control, alt, shift } = {}) {
  console.log('fireKey called!' + document.createEvent)
  if (document.createEvent) {
    console.log('fireKey: createEvent and node.dispatchEvent exist!!!', k, control, alt, shift);
    window.dispatchEvent(new KeyboardEvent('keypress', { key: '+', ctrlKey: true }));
  } else if (document.createEventObject) {
    console.log('fireClick: createEventObject and node.fireEvent exist!!!', node)
    node.fireEvent('onclick');
  } else if (typeof node.onclick == 'function') {
    console.log('fireClick: node.onclick exists!!!', node)
    node.onclick();
  }
}
function fireWheel(node) {
  if (document.createEvent) {
    var evt = document.createEvent('MouseEvents');
    evt.initEvent('wheel', true, false);
    console.log('fireClick: createEvent and node.dispatchEvent exist!!!', node)
    node.dispatchEvent(evt);
  } else if (document.createEventObject) {
    console.log('fireClick: createEventObject and node.fireEvent exist!!!', node)
    node.fireEvent('onclick');
  } else if (typeof node.onclick == 'function') {
    console.log('fireClick: node.onclick exists!!!', node)
    node.onclick();
  }
}
function first(arr) {
  return arr.length > 0 ? arr[0] : null;
}
function firstCond(arr, func) {
  if (nundef(arr)) return null;
  for (const a of arr) {
    if (func(a)) return a;
  }
  return null;
}
function firstCond_super_inefficient(arr, func) {
  let res = arr.filter(x => func(x));
  return res.length > 0 ? res[0] : null;
}
function firstCondDict(dict, func) {
  for (const k in dict) { if (func(dict[k])) return k; }
  return null;
}
function firstCondDictKey() { return firstCondDictKeys(...arguments); }
function firstCondDictKeys(dict, func) {
  for (const k in dict) { if (func(k)) return k; }
  return null;
}
function firstCondDictKV(dict, func) {
  for (const k in dict) { if (func(k, dict[k])) return k; }
  return null;
}
function firstCondDictReturnVal(dict, func) {
  for (const k in dict) { if (func(dict[k])) return dict[k]; }
  return null;
}
function firstCondX(ad, func, keysSorted) {
  if (nundef(ad)) return null;
  else if (isDict(ad)) {
    if (isdef(keysSorted)) {
      for (const k of keysSorted) {
        let v = ad[k];
        if (func(v)) { if (nundef(v.key)) v.key = k; return v; }
      }
    } else {
      for (const k in ad) {
        let v = ad[k];
        if (func(v)) { if (nundef(v.key)) v.key = k; return v; }
      }
    }
  } else {
    for (const a of ad) { if (func(a)) return a; }
  }
  return null;
}
function firstElement(x) {
  if (isSet(x)) return x.set[0];
  else if (isTuple(x)) return x[0];
  else return null;
}
function firstFloat(s) {
  if (s) {
    let m = s.match(/-?.?\d+/);
    if (m) {
      let sh = m.shift();
      if (sh) { return Number(sh); }
    }
  }
  return null;
}
function firstNCond(n, arr, func) {
  if (nundef(arr)) return [];
  let result = [];
  let cnt = 0;
  for (const a of arr) {
    cnt += 1; if (cnt > n) break;
    if (func(a)) result.push(a);
  }
  return result;
}
function firstNumber(s) {
  if (s) {
    let m = s.match(/-?\d+/);
    if (m) {
      let sh = m.shift();
      if (sh) { return Number(sh); }
    }
  }
  return null;
}
function firstPositiveNumber(s) {
  return s ? Number(s.match(/\d+/).shift()) : -1;
}
function firstWord(s, allow_ = false) { return toWords(s, allow_)[0]; }
function firstWordAfter(s, sub, allow_ = false) {
  let s1 = stringAfter(s, sub);
  let s2 = toWords(s1, allow_)[0]
  return s2;
}
function fisherYates(arr) {
  if (arr.length == 2 && coin()) { return arr; }
  var rnd, temp;
  let last = arr[0];
  for (var i = arr.length - 1; i; i--) {
    rnd = Math.random() * i | 0;
    temp = arr[i];
    arr[i] = arr[rnd];
    arr[rnd] = temp;
  }
  return arr;
}
function fit_points(map, pts, padding = true) {
  let latlngs = to_lat_lng(pts);
  let o = L.latLngBounds(latlngs);
  map.fitBounds(o, { padding: padding ? [25, 25] : [0, 0] });
}
function fitbit_open(item) {
  console.log('FITBIT OPEN!!!!!!!!!!!!!!!')
  let d = iDiv(item);
  let d2 = mGrid(2, 1, d, { gap: 3, matop: 22 });
  let arr = DB.appdata.fitbit;
  let days = arr.length;
  let sum = arrSum(arr, 'steps');
  let opt = DB.apps.fitbit.options;
  let min_per_day = opt.min;
  let avg_per_day = opt.avg;
  let req_sum = avg_per_day * (days + 1);
  let req_today = Math.max(req_sum - sum, opt.min);
  let avg = sum / days;
  let davg = mDiv(d2, {}, null, `avg: ${avg.toFixed(1)}K`);
  let dtoday = mDiv(d2, {}, null, `req: ${Math.ceil(req_today)}K`);
}
function fitFont(text, fz = 20, w2 = 200, h2 = 100) {
  let e1, e2, r1, r2;
  e1 = mDiv(dTable, { w: w2, h: h2, display: 'inline-block' });
  do {
    e2 = mDiv(e1, { fz: fz, display: 'inline-block' }, null, text);
    r1 = getRect(e1);
    r2 = getRect(e2);
    e2.remove();
    fz -= 1;
  } while (r1.w * r1.h < r2.w * r2.h);
  e1.remove();
  return [fz + 1, r2.w, r2.h];
}
function fitSvg(el) {
  const box = el.querySelector('text').getBBox();
  el.style.width = `${box.width}px`;
  el.style.height = `${box.height}px`;
}
function fitText(text, rect, dParent, styles, classes) {
  let l = rect.cx - (rect.w / 2);
  let t = rect.cy - (rect.h / 2);
  if (dParent.style.position != 'absolute') dParent.style.position = 'relative';
  let d = mDivPosAbs(l, t, dParent);
  styles.display = 'inline-block';
  styles.w = rect.w;
  let fz = 20; if (isdef(styles.fz)) fz = styles.fz;
  let over = textCorrectionFactor(text, styles, rect.w, rect.h, fz); let MAX = 20; let cnt = 0;
  let oldFz = 0; let oldOldFz = 0;
  while (over > 0 && fz >= 8) {
    cnt += 1; if (cnt > MAX) { console.log('MAX reached!!!'); break; }
    if (over == 0) break;
    oldOldFz = oldFz;
    oldFz = fz;
    fz = Math.round(fontTransition(fz, over));
    if (oldFz == fz || oldOldFz == fz) break;
    let newOver = textCorrectionFactor(text, styles, rect.w, rect.h, fz);
    over = newOver;
  }
  d.innerHTML = text;
  mStyleX(d, styles);
  return d;
}
function fitWord(text, rect, dParent, styles, classes) {
  let d = mDiv(dParent)
  styles.display = 'inline-block';
  let fz = rect.h;
  let over = wordCorrectionFactor(text, styles, rect.w, rect.h, fz); let MAX = 20; let cnt = 0;
  let oldFz = 0; let oldOldFz = 0;
  while (over > 0 && fz >= 8) {
    cnt += 1; if (cnt > MAX) { console.log('MAX reached!!!'); break; }
    if (over == 0) break;
    oldOldFz = oldFz;
    oldFz = fz;
    fz = Math.round(fontTransition(fz, over));
    if (oldFz == fz || oldOldFz == fz) break;
    let newOver = wordCorrectionFactor(text, styles, rect.w, rect.h, fz);
    over = newOver;
  }
  d.innerHTML = text;
  mStyleX(d, styles);
  return d;
}
function fixedSizeGrid(m, d) {
  let rows = m.length;
  let cols = m[0].length;
  d.style.gridTemplateColumns = 'repeat(' + cols + ',1fr)'; // gtc.join(' '); //'min-content 1fr 1fr min-content';// 'min-content'.repeat(rows);
  d.style.gridTemplateRows = 'repeat(' + rows + ',1fr)'; // //'min-content 1fr 1fr min-content';// 'min-content'.repeat(rows);
}
function fj(x) {
  return formatjson(x);
}
function flag_reset(prop) { G[prop] = false; }
function flag_set(prop) { G[prop] = true; }
function flag_toggle(name) { if (G[name]) flag_reset(name); else flag_set(name); }
function fleetingMessage(msg, d, styles, ms, fade) {
  if (isString(msg)) {
    dFleetingMessage.innerHTML = msg;
    mStyle(dFleetingMessage, styles);
  } else {
    mAppend(dFleetingMessage, msg);
  }
  if (fade) Animation1 = mAnimate(dFleetingMessage, 'opacity', [1, .4, 0], null, ms, 'ease-in', 0, 'both');
  return dFleetingMessage;
}
function flower_draw(x, y, color, angle = 0, petalCount = 1, lineWidth = 3, sz = 10) {
  function createPetal(length, width) {
    const path = new Path2D();
    path.moveTo(0, 0);
    path.lineTo(length * 0.3, -width);
    path.lineTo(length * 0.8, -width);
    path.lineTo(length, 0);
    path.lineTo(length * 0.8, width);
    path.lineTo(length * 0.3, width);
    path.closePath();
    path.moveTo(0, 0);
    path.lineTo(length, 0);
    return path;
  }
  function drawPetals(x, y, count, startAt, petal) {
    const step = (Math.PI * 2) / count;
    CX.setTransform(1, 0, 0, 1, x, y);
    CX.rotate(startAt);
    for (var i = 0; i < count; i += 1) {
      CX.stroke(petal);
      CX.rotate(step);
    }
    CX.setTransform(1, 0, 0, 1, 0, 0);
  }
  CX.strokeStyle = color;
  CX.lineWidth = lineWidth;
  const size = 50;
  drawPetals(x, y, petalCount, angle, createPetal(sz, sz * .2));
  CX.beginPath();
  CX.arc(x, y, sz * .15, 0, Math.PI * 2);
  CX.fillStyle = color;
  CX.fill();
}
function fmultiplier(f, g) { return x => f(x) * g(x); }
function focusNextSiblingOrSubmitOnEnter(ev, id) {
  if (ev.key === 'Enter') {
    ev.preventDefault();
    let el = mBy(id); let tag = el.tagName.toLowerCase();
    if (tag == 'input') el.focus();
    else if (tag == 'form') {
      el.submit();
    }
  }
}
function follows_in_rank(c1, c2, rankstr) {
  return get_rank_index(c2, rankstr) - get_rank_index(c1, rankstr) == 1;
  let i1 = rankstr.indexOf(c1[0]);
  let i2 = rankstr.indexOf(c2[0]);
  console.log('follows?', c1, i1, c2, i2, i2 - i1)
  return rankstr.indexOf(c2[0]) - rankstr.indexOf(c1[0]) == 1;
}
function forAll(arr, func) { for (const a of arr) if (!func(a)) return false; return true; }
function format_currency(num) {
  return '$' + num.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}
function format_date(date) {
  let d = new Date(date);
  let month = '' + (d.getMonth() + 1);
  let day = '' + d.getDate();
  let year = d.getFullYear();
  if (month.length < 2) month = '0' + month;
  if (day.length < 2) day = '0' + day;
  return [month, day, year].join('/');
}
function format_datetime(timestamp, str = 'y-m-d_h:i:s.r') {
  if (isString(timestamp)) timestamp = Number(timestamp);
  const plus0 = num => `0${num.toString()}`.slice(-2)
  const d = new Date(timestamp)
  const year = d.getFullYear()
  const monthTmp = d.getMonth() + 1
  const month = plus0(monthTmp)
  const date = plus0(d.getDate())
  const hour = plus0(d.getHours())
  const minute = plus0(d.getMinutes())
  const second = plus0(d.getSeconds())
  const rest = timestamp.toString().slice(-5)
  let res = '';
  str = str.toLowerCase();
  for (let i = 0; i < str.length; i++) {
    let ch = str[i];
    res += (ch == 'y' ? year : ch == 'm' ? month : ch == 'd' ? date : ch == 'h' ? hour : ch == 'i' ? minute : ch == 's' ? second : ch == 'r' ? rest : ch);
  }
  return res;
}
function format2Digits(i) { return (i < 10) ? "0" + i : i; }
function formatDate(d) {
  const date = isdef(d) ? d : new Date();
  const month = ('0' + date.getMonth()).slice(0, 2);
  const day = date.getDate();
  const year = date.getFullYear();
  const dateString = `${month}/${day}/${year}`;
  return dateString;
}
function formatDate1(d) {
  if (nundef(d)) d = Date.now();
  let ye = new Intl.DateTimeFormat('en', { year: 'numeric' }).format(d);
  let mo = new Intl.DateTimeFormat('en', { month: 'short' }).format(d);
  let da = new Intl.DateTimeFormat('en', { day: '2-digit' }).format(d);
  return `${da}-${mo}-${ye}`;
}
function formatDate2(d) { if (nundef(d)) d = new Date(); return d.toISOString().slice(0, 19).replace("T", " "); }
function formatDate3(d) { if (nundef(d)) d = new Date(); return d.toISOString().slice(0, 19).replace(/-/g, "/").replace("T", " "); }
function formatJson(o) {
  let s = '';
  for (const k in o) {
    if (isSimple(o[k])) s += k + ':' + o[k] + ' ';
  }
  return s;
}
function formatjson(j) {
  let s = JSON.stringify(j);
  s = s.replace(/\s/g, '');
  return s;
}
function formatll(ll) {
  if (!isll(ll)) return 'NOT list of lists!';
  let s = '[';
  for (const l of ll) {
    let content = isllPlus(l) ? formatll(l) : l.toString();
    s += '[' + content + ']';
  }
  s += ']';
  testHelpers(s);
}
function formatNow() { return new Date().toISOString().slice(0, 19).replace("T", " "); }
function formula0(x, mean, stdev) {
  let v = stdev * stdev;
  let t = Math.sqrt(Math.PI * 2) * stdev;
  let t1 = 1 / t;
  let t2 = (x - mean) ** 2;
  let t3 = 2 * v;
  let t4 = -t2 / t3;
  let t5 = Math.E ** t4;
  return t1 * t5;
}
function formula1(x) {
  return formula0(x, 100, 15);
}
function foscillator(exp, vars) {
  for (const v of vars) {
    [v.val, v.step] = oscillate_between(v.val, v.min, v.max, vstep);
    exp = replaceAll(exp, v.name, v.val);
  }
  return nerdamer('exp').buildFunction();
}
function fp_card_selection() {
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  let selitems = A.selectedCards = A.selected.map(x => A.items[x]);
  let cards = selitems.map(x => x.o);
  let cmd = A.last_selected.key;
  if (cmd == 'discard') {
    if (selitems.length != 1) { select_error('select exactly 1 hand card to discard!'); return; }
    let item = selitems[0];
    if (!item.path.includes(`${uplayer}.hand`)) { select_error('select a hand card to discard!', () => { ari_make_unselected(item); A.selected = []; }); return; }
    assertion(DA.transactionlist.length == 0 || DA.simulate, '!!!!!!!!!!!!!!!!transactionlist is not empty!');
    if (DA.transactionlist.length > 0) {
      console.log('VERIFYING TRANSACTION............')
      let legal = verify_min_req();
      clear_transaction();
      if (legal) {
        ferro_process_discard();
      } else {
        ferro_transaction_error();
      }
    } else {
      ferro_process_discard();
    }
  } else if (cmd == 'jolly') {
    if (selitems.length != 2) { select_error('select a hand card and the jolly you want!'); return; }
    let handcard = selitems.find(x => !is_joker(x.o) && x.path.includes(`${uplayer}.hand`));
    let jolly = selitems.find(x => is_joker(x.o) && !x.path.includes(`${uplayer}.hand`));
    if (!isdef(handcard) || !isdef(jolly)) { select_error('select a hand card and the jolly you want!'); return; }
    let key = handcard.key;
    let j = path2fen(fen, jolly.path);
    if (!jolly_matches(key, j)) { select_error('your card does not match jolly!'); return; }
    if (pl.journeys.length == 0) { add_transaction(cmd); }
    ferro_process_jolly(key, j);
    take_turn_fen();
  } else if (cmd == 'auflegen') {
    if (selitems.length < 3) { select_error('select cards to form a group!'); return; }
    else if (pl.hand.length == selitems.length) { select_error('you need to keep a card for discard!!', clear_selection); return; }
    let newset = ferro_is_set(cards, Z.options.jokers_per_group);
    if (!newset) { select_error('this is NOT a valid set!'); return; }
    let is_illegal = is_correct_group_illegal(cards);
    if (is_illegal) { select_error(is_illegal); return; }
    if (pl.journeys.length == 0) { add_transaction(cmd); }
    let keys = newset;
    ferro_process_set(keys);
    take_turn_fen();
  } else if (cmd == 'anlegen') {
    if (selitems.length < 1) { select_error('select at least 1 hand card and the first card of a group!'); return; }
    else if (pl.hand.length == selitems.length - 1) { select_error('you need to keep a card for discard!!', clear_selection); return; }
    let handcards = selitems.filter(x => !is_joker(x.o) && x.path.includes(`${uplayer}.hand`));
    let groupcard = selitems.find(x => !is_joker(x.o) && !x.path.includes(`${uplayer}.hand`));
    if (isEmpty(handcards) || !isdef(groupcard)) { select_error('select 1 or more hand cards and the first card of a group!'); return; }
    let hand_rank = handcards[0].key[0];
    let handcards_same_rank = handcards.every(x => x.key[0] == hand_rank);
    let j = path2fen(fen, groupcard.path);
    if (is_group(j)) {
      if (!handcards_same_rank) { select_error('all hand cards must have the same rank!'); return; }
      let group_rank = groupcard.key[0];
      if (group_rank == hand_rank) {
        for (const h of handcards) {
          elem_from_to(h.key, fen.players[uplayer].hand, j);
        }
        if (pl.journeys.length == 0) { add_transaction(cmd); }
        take_turn_fen();
        return;
      } else {
        select_error('hand cards do not match the group!');
        return;
      }
    } else {
      let suit = get_sequence_suit(j);
      let handkeys = handcards.map(x => x.key);
      if (firstCond(handkeys, x => x[1] != suit)) { select_error('hand card suit does not match the group!'); return; }
      let ij = j.findIndex(x => is_jolly(x));
      let j_has_jolly = ij > -1;
      let rank_to_be_relaced_by_jolly = j_has_jolly ? find_jolly_rank(j) : null;
      let r = rank_to_be_relaced_by_jolly;
      if (r) {
        j[ij] = r + suit + 'n';
      }
      keys = handkeys.concat(j);
      let allcards = keys.map(x => ferro_get_card(x));
      let jneeded = sortCardItemsToSequence(allcards, undefined, 0);
      if (jneeded == 0) {
        let seq = allcards.map(x => x.key);
        if (r) { arrReplace1(seq, r + suit + 'n', '*Hn'); }
        j.length = 0;
        j.push(...seq);
        for (const k of handkeys) { removeInPlace(fen.players[uplayer].hand, k); }
        if (pl.journeys.length == 0) { add_transaction(cmd); }
        take_turn_fen();
      } else {
        if (r != null) { j[ij] = '*Hn'; }
        select_error('hand cards cannot be added to sequence!');
        return;
      }
    }
  }
}
function fpowerer(f, g) { return x => Math.pow(f(x), g(x)); }
function fprime(exp) {
  return x => math.derivative(exp, 'x').evaluate({ x: x });
}
function FR2SQ(f, r) { return ((21 + (f)) + ((r) * 10)); }
function fractionConvert(wp, diop) {
  let n = wp.result.number;
  let t = typeof n;
  if (isFractionType(n)) {
    wp.isFractionResult = true;
    wp.result.text = getTextForFraction(n.n, n.d);
  }
}
function fractionsUnder1ByDenominator() {
  let fr = {
    2: [1],
    3: [1, 2],
    4: [1, 3],
    5: [1, 2, 3, 4],
    6: [1, 5],
    7: [1, 2, 3, 4, 5, 6],
    8: [1, 3, 5, 7],
    9: [1, 2, 4, 5, 7, 8],
  };
  return fr;
}
function fradd(card, targetgroup, targetcard) {
  let [oldgroup, oldindex] = untie_card(card);
  assertion(isdef(targetgroup.id), 'NO ID IN fradd!!!!!!!', targetgroup);
  add_card_to_group(card, oldgroup, oldindex, targetcard, targetgroup);
  if (targetgroup != oldgroup) cleanup_or_resplay(oldgroup);
}
function freezeUI() {
  if (frozen) return;
  frozen = true;
  show('tempFreezer');
}
function fritz() {
  const rankstr = 'A23456789TJQK*';
  function setup(players, options) {
    let fen = { players: {}, plorder: jsCopy(players), history: [], maxrounds: options.cycles * players.length };
    let n = players.length;
    fen.num_decks = 2 + (n >= 9 ? 2 : n >= 7 ? 1 : 0);
    fritz_new_table(fen, options);
    let deck = fen.deck;
    shuffle(fen.plorder);
    let starter = fen.starter = fen.plorder[0];
    fen.roundorder = jsCopy(fen.plorder);
    let handsize = valf(Number(options.handsize), 11);
    for (const plname of players) {
      let pl = fen.players[plname] = {
        hand: deck_deal(deck, plname == starter ? handsize + 1 : handsize),
        loosecards: [],
        time_left: options.seconds_per_game * 1000,
        score: 0,
        name: plname,
        color: get_user_color(plname),
      };
    }
    [fen.phase, fen.stage, fen.turn] = ['', 'card_selection', [starter]];
    return fen;
  }
  function activate_ui() { fritz_activate_ui(); }
  function check_gameover() { return isdef(Z.fen.winners) ? Z.fen.winners : false; }
  function present(dParent) { fritz_present(dParent); }
  function stats(dParent) { fritz_stats(dParent); }
  function state_info(dParent) { fritz_state_info(dParent); }
  return { rankstr, setup, activate_ui, check_gameover, present, state_info, stats };
}
function fritz_activate_ui() {
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  A.autosubmit = false;
  new_cards_animation(1);
  round_change_animation(1);
  select_add_items(ui_get_hand_items(uplayer), end_of_turn_fritz, 'must drag drop cards to assemble groups, then discard 1 hand card', 0, 1);
  A.items.map(x => iDiv(x).onclick = ev => {
    let card = Items[x.id];
    let item = x;
    clear_quick_buttons();
    select_last(item, select_toggle, ev);
    if (item.index == A.selected[0]) {
      let pos = get_mouse_pos(ev);
      let b = DA.bQuick = mButton('discard', ev => {
        b.remove();
        end_of_turn_fritz();
      }, document.body, { position: 'absolute', left: pos.x - 40, top: pos.y - 10 }, 'selectbutton');
    }
  });
  UI.timer = select_timer(fen.players[uplayer].time_left + Z.options.seconds_per_move * 1000, end_of_turn_fritz);
}
function fritz_card(ckey, h, w, ov, draggable) {
  let type = ckey[2];
  let info = ckey[0] == '*' ? get_joker_info() : jsCopy(C52Cards[ckey.substring(0, 2)]);
  info.key = ckey;
  info.cardtype = ckey[2];
  let [r, s] = [info.rank, info.suit];
  info.val = r == '*' ? 25 : r == 'A' ? 1 : 'TJQK'.includes(r) ? 10 : Number(r);
  info.color = RED;
  info.sz = info.h = valf(h, Config.ui.card.h);
  info.w = valf(w, info.sz * .7);
  info.irank = '23456789TJQKA*'.indexOf(r);
  info.isuit = 'SHCDJ'.indexOf(s);
  info.isort = info.isuit * 14 + info.irank;
  let card = cardFromInfo(info, h, w, ov);
  card.id = iDiv(card).id = getUID('c');
  Items[card.id] = card;
  if (draggable && Z.role == 'active') mDraggable(card);
  return card;
}
function fritz_get_card(ckey, h, w, ov = .25) { return fritz_card(ckey, h, w, ov, true); }
function fritz_get_hint_card(ckey) { return fritz_card(ckey, 50, 30, .25, false); }
function fritz_new_player_hands(fen, starter, options) {
  let handsize = options.handsize;
  let deck = fen.deck;
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    pl.hand = deck_deal(deck, plname == starter ? handsize + 1 : handsize);
    pl.loosecards = [];
    pl.time_left = options.seconds_per_game * 1000;
    pl.roundchange = true;
    delete pl.handsorting;
    delete pl.newcards;
  }
}
function fritz_new_table(fen, options) {
  fen.deck = create_fen_deck('n', fen.num_decks, 0);
  fen.deck_discard = [];
  fen.journeys = [];
  fen.loosecards = arrRepeat(options.jokers, '*Hn');
  shuffle(fen.deck);
}
function fritz_present(dParent) {
  DA.hovergroup = null;
  let [fen, ui, uplayer, stage, pl] = [Z.fen, UI, Z.uplayer, Z.stage, Z.pl];
  let [dOben, dOpenTable, dMiddle, dRechts] = tableLayoutMR(dParent); mFlexWrap(dOpenTable)
  Config.ui.card.h = 130;
  Config.ui.container.h = Config.ui.card.h + 30;
  if (isEmpty(fen.deck_discard)) {
    mText('discard pile is empty!', dOpenTable);
    ui.deck_discard = { items: [] }
  } else {
    mText('discard pile:', dOpenTable); mLinebreak(dOpenTable);
    let deck_discard = ui.deck_discard = ui_type_hand(fen.deck_discard, dOpenTable, { maright: 25 }, 'deck_discard', null, fritz_get_card, true);
    let i = 0; deck_discard.items.map(x => { x.source = 'discard'; x.index = i++ });
  }
  mLinebreak(dOpenTable);
  mDiv(dOpenTable, { box: true, w: '100%' }, null, '<hr>');
  let ddarea = UI.ddarea = mDiv(dOpenTable, { border: 'dashed 1px black', bg: '#eeeeee80', box: true, hmin: 162, wmin: 245, padding: '5px 50px 5px 5px', margin: 5 });
  mDroppable(ddarea, drop_card_fritz, dragover_fritz); ddarea.id = 'dOpenTable'; Items[ddarea.id] = ddarea;
  mFlexWrap(ddarea)
  fritz_stats(dRechts);
  show_history(fen, dRechts);
  DA.TJ = [];
  for (const j of fen.journeys) {
    let cards = j.map(x => fritz_get_card(x));
    frnew(cards[0], { target: 'hallo' });
    for (let i = 1; i < cards.length; i++) { fradd(cards[i], Items[cards[0].groupid]); }
  }
  let loosecards = ui.loosecards = jsCopy(fen.loosecards).map(c => fritz_get_card(c));
  for (const plname of fen.plorder) {
    let cards = fen.players[plname].loosecards.map(c => fritz_get_card(c));
    cards.map(x => x.owner = plname);
    loosecards = loosecards.concat(cards);
  }
  for (const looseui of loosecards) {
    let card = looseui;
    frnew(card, { target: 'hallo' });
  }
  for (const group of DA.TJ) {
    assertion(isdef(group.id), 'no group id', group);
    let d = iDiv(group);
    let ch = arrChildren(iDiv(group));
    let cards = ch.map(x => Items[x.id]);
    cards.map(x => mDroppable(x, drop_card_fritz, dragover_fritz));
  }
  if (arrChildren(ddarea).length == 0) {
    let d = mDiv(ddarea, { 'pointer-events': 'none', maleft: 45, align: 'center', hmin: 40, w: '100%', fz: 12, fg: 'dimgray' }, 'ddhint', 'drag and drop cards here');
  }
  ui.players = {};
  let uname_plays = fen.plorder.includes(Z.uname);
  let plmain = uname_plays && Z.mode == 'multi' ? Z.uname : uplayer;
  fritz_present_player(plmain, dMiddle);
  if (TESTING) {
    for (const plname of arrMinus(fen.plorder, plmain)) {
      fritz_present_player(plname, dMiddle);
    }
  }
  show_handsorting_buttons_for(Z.mode == 'hotseat' ? Z.uplayer : Z.uname, { left: 58, bottom: -1 });
}
function fritz_present_new(z, dParent, uplayer) {
  DA.hovergroup = null;
  let [fen, ui, stage] = [z.fen, UI, z.stage];
  console.log('role', Z.role)
  let [dOben, dOpenTable, dMiddle, dRechts] = tableLayoutMR(dParent); mFlexWrap(dOpenTable)
  Config.ui.card.h = 130;
  Config.ui.container.h = Config.ui.card.h + 30;
  if (isEmpty(fen.deck_discard)) {
    mText('discard empty', dOpenTable);
    ui.deck_discard = { items: [] }
  } else {
    let deck_discard = ui.deck_discard = ui_type_hand(fen.deck_discard, dOpenTable, { maright: 25 }, 'deck_discard', 'discard', fritz_get_card, true);
    let i = 0; deck_discard.items.map(x => { x.source = 'discard'; x.index = i++ });
  }
  mLinebreak(dOpenTable);
  let ddarea = UI.ddarea = mDiv(dOpenTable, { border: 'dashed 1px black', bg: '#eeeeee80', box: true, hmin: 162, wmin: 245, padding: '5px 50px 5px 5px', margin: 5 });
  mDroppable(ddarea, drop_card_fritz); ddarea.id = 'dOpenTable'; Items[ddarea.id] = ddarea;
  mFlexWrap(ddarea)
  fritz_stats_new(z, dRechts);
  show_history(fen, dRechts);
  DA.TJ = [];
  for (const j of fen.journeys) {
    let cards = j.map(x => fritz_get_card(x));
    frnew(cards[0], { target: 'hallo' });
    for (let i = 1; i < cards.length; i++) { fradd(cards[i], Items[cards[0].groupid]); }
  }
  let loosecards = ui.loosecards = jsCopy(fen.loosecards).map(c => fritz_get_card(c));
  for (const plname of fen.plorder) {
    let cards = fen.players[plname].loosecards.map(c => fritz_get_card(c));
    cards.map(x => x.owner = plname);
    loosecards = loosecards.concat(cards);
  }
  for (const looseui of loosecards) {
    let card = looseui;
    frnew(card, { target: 'hallo' });
  }
  for (const group of DA.TJ) {
    assertion(isdef(group.id), 'no group id', group);
    let d = iDiv(group);
    let ch = arrChildren(iDiv(group));
    let cards = ch.map(x => Items[x.id]);
    cards.map(x => mDroppable(x, drop_card_fritz));
  }
  if (arrChildren(ddarea).length == 0) {
    let d = mDiv(ddarea, { 'pointer-events': 'none', maleft: 45, align: 'center', hmin: 40, w: '100%', fz: 12, fg: 'dimgray' }, 'ddhint', 'drag and drop cards here');
  }
  ui.players = {};
  let uname_plays = fen.plorder.includes(Z.uname);
  let plmain = uname_plays && Z.mode == 'multi' ? Z.uname : uplayer;
  fritz_present_player(plmain, dMiddle);
  if (TESTING) {
    for (const plname of arrMinus(fen.plorder, plmain)) {
      fritz_present_player(plname, dMiddle);
    }
  }
}
function fritz_present_player(playername, dMiddle) {
  let [fen, ui, stage] = [Z.fen, UI, Z.stage];
  let pl = fen.players[playername];
  let playerstyles = { w: '100%', bg: '#ffffff80', fg: 'black', padding: 4, margin: 4, rounding: 10, border: `2px ${get_user_color(playername)} solid` };
  let d = mDiv(dMiddle, playerstyles, null, get_user_pic_html(playername, 25)); mFlexWrap(d); mLinebreak(d, 10);
  //#region old handsorting code
  //#endregion
  pl.hand = correct_handsorting(pl.hand, playername);
  let upl = ui.players[playername] = { div: d };
  upl.hand = ui_type_hand(pl.hand, d, {}, `players.${playername}.hand`, 'hand', fritz_get_card);
  upl.hand.items.map(x => x.source = 'hand');
  let ploose = pl.loosecards;
  if (!isEmpty(ploose)) {
    upl.loose = ui_type_market(ploose, d, {}, `players.${playername}.loose`, 'untouchables', fritz_get_hint_card);
    upl.loose.items.map(x => x.source = 'loose');
  } else {
  }
}
function fritz_state_info(dParent) {
  let user_html = get_user_pic_html(Z.uplayer, 30);
  dParent.innerHTML = `Round ${Z.round}:&nbsp;player: ${user_html} `;
}
function fritz_stats(dParent) {
  let player_stat_items = UI.player_stat_items = ui_player_info(dParent);
  let fen = Z.fen;
  console.log('players', get_keys(fen.players));
  for (const plname in fen.players) {
    let pl = fen.players[plname];
    console.log('uname', plname);
    let item = player_stat_items[plname];
    let d = iDiv(item); mCenterFlex(d); mLinebreak(d);
    player_stat_count('hand with fingers splayed', calc_hand_value(pl.hand.concat(pl.loosecards), fritz_get_card), d);
    player_stat_count('star', pl.score, d);
    if (fen.turn.includes(plname)) { show_hourglass(plname, d, 30, { left: -3, top: 0 }); }
    else if (!fen.plorder.includes(plname)) mStyle(d, { opacity: 0.5 });
  }
}
function fritz_stats_new(z, dParent) {
  let player_stat_items = UI.player_stat_items = ui_player_info(z, dParent);
  let fen = z.fen;
  for (const uname in fen.players) {
    let pl = fen.players[uname];
    let item = player_stat_items[uname];
    let d = iDiv(item); mCenterFlex(d); mLinebreak(d);
    player_stat_count('hand with fingers splayed', calc_hand_value(pl.hand.concat(pl.loosecards), fritz_get_card), d);
    player_stat_count('star', pl.score, d);
    if (fen.turn.includes(uname)) { show_hourglass(uname, d, 30, { left: -3, top: 0 }); }
    else if (!fen.plorder.includes(uname)) mStyle(d, { opacity: 0.5 });
  }
}
function frnew(card, ev) {
  let [oldgroup, oldindex] = untie_card(card);
  let id = getUID('g');
  let d = mDiv(Items.dOpenTable, { display: 'grid', margin: 10 }, id);
  let targetgroup = { div: d, id: id, ids: [], ov: .5222 };
  assertion(isdef(DA.TJ), 'DA.TJ undefined in frnew!!!');
  DA.TJ.push(targetgroup);
  Items[id] = targetgroup;
  assertion(isdef(targetgroup.id), 'NO ID IN frnew!!!!!!!', targetgroup);
  add_card_to_group(card, oldgroup, oldindex, null, targetgroup);
  if (targetgroup != oldgroup) cleanup_or_resplay(oldgroup);
}
function from_lat_lng(p) { return [p.lat, p.lng]; }
function from_lat_long(p) { return from_lat_lng(p); }
function from_server(result, type) {
  if (type == "modify_table") { console.log('______from server:', type, '\nresult:', result); }
  if (result.trim() == "") return;
  var obj = JSON.parse(result);
  convert_from_server(obj);
  switch (type) {
    case "intro": got_intro(obj); break;
    case 'non_admin_reload': got_non_admin_reload(obj); break;
    case "games": got_games(obj); break;
    case "play_start": got_play_start(obj); break;
    case "play": got_play(obj); break;
    case 'modify_table': got_modify_table(obj); break;
    case 'create_table_and_start': got_create_table(obj); break;
    case 'send_move': got_send_move(obj); break;
    case 'seen': poll_for_table_seen_or_deleted(); break;
    case 'standard_assets':
    case 'assets': assets_parse(obj.response); break;
    case 'dictionary': got_dictionary(obj); break;
    case "get_tables": got_tables(obj); break;
    case "get_user_game_tables": got_user_game_tables(obj); break;
    case "poll_table_started": check_poll_table_started(obj); break;
    case "poll_table_show": check_poll_table_show(obj); break;
    case "poll_table_seen": check_poll_table_seen(obj); break;
    case "get_past_tables": test_user_endscreen(obj); break;
    case "contacts": present_contacts(obj); break;
    case "login": present_login(obj); break;
    case "dbsave": console.log('db has been saved to server:'); break;
    case 'delete_table': get_games(obj); break;
    case 'save_and_delete': alert(`${obj.message}, ranking:${obj.fen}`);
      console.assert(is_admin(), 'SAVE_AND_DELETE NOT SENT BEI ADMIN!!!!');
      get_games();
      break;
    //#region sequence if dont join players automatically
    case 'create_table':
      Session.cur_tid = obj.table.id;
      Session.cur_table = obj.table;
      break;
    case "join_table":
      status_message('You have joined the game! Wait for the host to start it!');
      update_cur_table(obj, 'red');
      break;
    case "toggle_join":
      let t = obj.table;
      let st = obj.player_status;
      update_cur_table(obj, st == 'joined' ? 'red' : 'orange');
      status_message(`You have ${st == 'joined' ? 'joined' : 'left'} the game! Wait for the host to start it!`);
      break;
    case "start_table":
      update_cur_table(obj, 'green');
      status_message('You have started the game! ', obj.table.status);
      break;
    //#endregion
    default: break;
  }
  danext();
}
function fromArray(arr) {
  return colorArrToString(...arr);
}
function fromArrayDarker(arr) {
  let c = fromArray(arr);
  return pSBC(-0.4, c);
}
function fromArrayLighter(arr) {
  let c = fromArray(arr);
  return pSBC(0.4, c);
}
function fromLocalStorage(name = '_all') { return JSON.parse(localStorage.getItem(name)); }
function fromRCMxToNumArrSq(f, r) {
  return ((21 + (f)) + ((r) * 10));
}
function FROMSQ(m) { return (m & 0x7F); }
function fromUmlaut(w) {
  if (isList(w)) {
    let res = [];
    for (const w1 of w) res.push(fromUmlaut(w1));
    return res;
  } else {
    w = replaceAll(w, 'ü', 'ue');
    w = replaceAll(w, 'ä', 'ae');
    w = replaceAll(w, 'ö', 'oe');
    w = replaceAll(w, 'Ü', 'UE');
    w = replaceAll(w, 'Ä', 'AE');
    w = replaceAll(w, 'Ö', 'OE');
    return w;
  }
}
function fromYaml(x) { return jsyaml.load(x); }
function fsubtracter(f, g) { return x => f(x) - g(x); }
function fullViewObjects() { let ids = getDefaultObjectIds(); ids.map(x => UIS[x].maximize()); }
function fun1(x) { return Math.sin(x); }
function fun2(x) { return Math.cos(3 * x); }
function fundef(x) {
  return x === undefined || !x;
}
function funGraph(ctx, axes, func, color, thick) {
  var xx, yy, dx = 4, x0 = axes.x0, y0 = axes.y0, scale = axes.scale;
  var iMax = Math.round((ctx.canvas.width - x0) / dx);
  var iMin = axes.doNegativeX ? Math.round(-x0 / dx) : 0;
  ctx.beginPath();
  ctx.lineWidth = thick;
  ctx.strokeStyle = color;
  for (var i = iMin; i <= iMax; i++) {
    xx = dx * i; yy = scale * func(xx / scale);
    if (i == iMin) ctx.moveTo(x0 + xx, y0 - yy);
    else ctx.lineTo(x0 + xx, y0 - yy);
  }
  ctx.stroke();
}
function G_clear() { gameloop_stop(); clear_timeouts(); mClear('dTable'); C = G = CV = CX = null; }
function G_init(name) {
  if (CV) G_clear();
  [dLeft, dCenter] = mColFlex(dTable, [0, 5]);
  let res = mCanvas(dCenter, { w: 500, h: 500, bg: '#222', rounding: 10 });
  [CV, CX] = [res.cv, res.cx];
  let bpp = _mPlayPause(dCenter, { fz: 28, fg: 'lightgreen', display: 'flex', ajcenter: true }, onclick_playpause);
  G = { running: false, bPP: bpp };
  C = { changed: true, name: name, items: {}, root: get_func(name, 'init')() };
}
function g4(x, mean, stdev) {
  let variance = stdev * stdev;
  var y = mean / Math.E ** (((x) ** 2) / (2 * variance)); return y;
}
function g5(x, mean, stdev) {
  x = (x - mean) / stdev;
  return Math.pow(Math.E, -Math.pow(x, 2) / 2) / Math.sqrt(2 * Math.PI);
}
function g6(x, mean, stdev) {
  x = (x - mean) / stdev;
  return Math.E ** (-(x ** 2) / 2) / Math.sqrt(2 * Math.PI);
}
function g7(x, mean, stdev) {
  x = (x - mean);
  let v = stdev * stdev;
  return Math.E ** (-(x ** 2) / (2 * v)) / Math.sqrt(v * 2 * Math.PI);
}
function g8(x, mean, stdev) {
  const dividend = Math.E ** -((x - mean) ** 2 / (2 * stdev ** 2));
  const divisor = stdev * Math.sqrt(2 * Math.PI); return dividend / divisor;
}
function g9(x, mean, stdev) {
  let f = new Gaussian(mean, stdev ** 2);
  console.log('f', f)
  return f.pdf(x);
}
function gaChar(key) {
  return String.fromCharCode('0x' + gaChars[key]); //'f520');
}
function game_add_default_item(ev) {
  evNoBubble(ev);
  let sz = 50;
  let [x, y] = [ev.clientX - sz / 2, ev.clientY - sz / 2];
  let item = { styles: { position: 'absolute', x: x, y: y, w: sz, h: sz, bg: 'random', fg: 'contrast' }, init: true, refresh: true, draw: draw_dom };
  game_add_item(item);
}
function game_add_item(item) {
  addKeys({ init: true, refresh: true, draw: draw_dom }, item);
  G.items.push(item);
}
function game_interrupt() {
  if (!mBy('radio_play').checked) return;
  interrupt();
  GAME_PLAY_UI = null;
}
function game_resume_or_start() {
  if (isdef(Session.game)) mBy("inner_left_panel").innerHTML = game.screen;
  else { game_start_new(); }
  game.run();
}
function game_start_new() {
  console.log('start a new game')
}
function GameButton(label) {
  this.clicked = false;
  this.button = document.createElement("button");
  this.button.setAttribute("type", "button");
  this.button.innerHTML = label;
  this.button.style.position = "absolute";
  this.button.style.left = "0px";
  this.button.style.top = "0px";
  this.button.onmousedown = function () {
    this.clicked = true;
  }
  this.button.ontouchstart = function () {
    this.clicked = true;
  }
  this.button.onmouseup = function () {
    this.clicked = false;
  }
  this.isClicked = function () {
    return this.button.clicked;
  }
  this.setPos = function (left, top) {
    this.button.style.left = left + "px";
    this.button.style.top = top + "px";
  }
  this.setPosition = function (left, top) {
    this.setPos(left, top);
  }
  this.setSize = function (width, height) {
    this.button.style.width = width + "px";
    this.button.style.height = height + "px";
  }
  document.body.appendChild(this.button);
}
function GameFunc() {
  this.panel = new Panel();
  this.run = function () {
    this.panel.start();
  }
}
function gameItem(name, color) { return mItem(name2id(name), null, { color: isdef(color) ? color : randomColor(), name: name }); }
function gameloop() {
  for (const item of G.items) {
    let changed = item.update();
    if (changed) item.draw();
  }
}
function gameloop_start() { TO.ivdraw = setInterval(gameloop, 1000 / FR); G.items.map(x => x.draw()); G.running = true; }
function gameloop_stop() { clear_timeouts(); if (G) G.running = false; }
function gameloop_toggle() { if (G.running === true) gameloop_stop(); else gameloop_start(); }
function gameOver(msg, silent = false) { TOMain = setTimeout(aniGameOver(msg, silent), DELAY); }
function gameStep(data) {
  DELETED_THIS_ROUND = [];
  processData(data);
  if (flags.specAndDOM) specAndDOM([gameStepII]); else gameStepII();
}
function gamestep() {
  show_admin_ui();
  DA.running = true; clear_screen(); dTable = mBy('dTable'); mClass('dTexture', 'wood');
  if (Z.game == 'aristo') { if (Z.role != Clientdata.role || Z.mode == 'multi' && Z.role != 'active') mFall(dTable); Clientdata.role = Z.role; }
  else mFall(dTable);
  shield_off();
  show_title();
  show_role();
  Z.func.present(dTable);
  if (isdef(Z.scoring.winners)) { show_winners(); animatedTitle('GAMEOVER!'); }
  else if (Z.func.check_gameover(Z)) {
    let winners = show_winners();
    Z.scoring = { winners: winners }
    sendgameover(winners[0], Z.friendly, Z.fen, Z.scoring);
  } else if (is_shield_mode()) {
    staticTitle();
    if (!DA.no_shield == true) { hide('bRestartMove'); shield_on(); }
    autopoll();
  } else {
    Z.A = { level: 0, di: {}, ll: [], items: [], selected: [], tree: null, breadcrumbs: [], sib: [], command: null, autosubmit: Config.autosubmit };
    copyKeys(jsCopy(Z.fen), Z);
    copyKeys(UI, Z);
    activate_ui(Z);
    Z.func.activate_ui();
    if (Z.isWaiting == true || Z.mode != 'multi') staticTitle(); else animatedTitle();
    if (Z.options.zen_mode != 'yes' && Z.mode != 'hotseat' && Z.fen.keeppolling && Z.uplayer_data.player_status != 'stop') {
      autopoll();
      console.log('gamestep autopoll');
    }
  }
  if (TESTING == true) landing();
}
function gameStep1(data) {
  G.serverData = data;
  DELETED_THIS_ROUND = [];
  processData(data);
  if (flags.specAndDOM) specAndDOM([gameStepII]); else gameStepII();
}
function gameStepII() {
  if (S_useSimpleCode) { presentTableSimple(); presentPlayersSimple(); }
  else { presentTable(); presentPlayers(); }
  presentStatus();
  presentLog();
  if (G.end) { presentEnd(); return; }
  if (G.tupleGroups) {
    presentActions();
    startInteraction();
  } else presentWaitingFor();
}
function gameView() {
  setIsReallyMultiplayer();
  if (!isReallyMultiplayer) {
    hide('c_b_PollStatus');
  }
  document.title = GAME + ' ' + USERNAME;
  view = 'game'; isPlaying = true;
  hideLobby(); hideLogin(); showGame();
  removeAllGlobalHandlers();
  addGameViewHandlers();
}
function gAnagram() {
  function anagram_fen() {
    return { key: Goal.key, lang: Goal.lang, inputs: collect_innerHTML(Goal.inputs, ':'), letters: collect_innerHTML(Goal.letters, ':') };
  }
  function anagram_prompt(g, fen) {
    let [vocab, lang, min, max] = [g.vocab, isdef(fen) ? fen.lang : g.lang, g.minWordLength, g.maxWordLength];
    let keypool = KeySets[vocab];
    keypool = keypool.filter(x => { let w = Syms[x][lang]; let l = w.length; return w.indexOf(' ') < 0 && l >= min && l <= max; });
    let key = isdef(fen) ? fen.key : chooseRandom(keypool); //'carpentry saw'; 
    let pic = mSym(key, dTable, { fz: 100, opacity: g.hidden ? 0 : 1 });
    if (g.hidden) {
      let d = pic;
      let r = getRect(d, dTable);
      let dHint = mDiv(dTable, { opacity: 0, position: 'absolute', align: 'center', left: 0, w: '100%', top: r.t + r.h / 2 }, null, 'category: ' + Syms[key].subgroup);
      animatePropertyX(dHint, 'opacity', [0, 0, 1], 2000, 'both', 'ease-in', 6000);
    }
    let word = Syms[key][lang].toUpperCase();
    Goal = { div: pic, key: key, word: word, lang: lang };
    mLinebreak(dTable, 12);
    let wTotal = getRect(mBy('table')).w;
    Goal.inputs = show_letter_inputs(word, dTable, wTotal);
    mLinebreak(dTable, 12);
    Goal.letters = show_dd_click_letters(word, dTable, wTotal);
    if (isdef(fen) && isdef(fen.inputs)) {
      distribute_innerHTML(Goal.inputs, fen.inputs, ':');
      distribute_innerHTML(Goal.letters, fen.letters, ':');
    } else {
      mLinebreak(dTable, 12);
      Goal.bDone = mButton('Done!', anagram_eval, dTable, { fz: 28, matop: 10, rounding: 10, hpadding: 16, border: 8 }, ['buttonClass']);
    }
  }
  function anagram_eval() {
    if (!canAct()) return;
    uiActivated = false; clear_timeouts();
    let answer = collect_innerHTML(Goal.inputs);
    let is_correct = answer == Goal.word;
    let is_word;
    if (!is_correct && answer.length == Goal.word.length && is_a_word(answer.toLowerCase(), Session.lang)) is_word = true;
    Selected = { answer: answer, reqAnswer: Goal.word, feedbackUI: Goal.inputs.map(x => iDiv(x)) };
    race_set_fen();
    race_update_my_score(is_correct ? 1 : is_word ? 0 : -1);
    let delay = anagram_feedback(is_correct, is_word);
    setTimeout(() => {
      in_game_open_prompt_off();
      clear_table_events();
      race_send_move();
    }, delay);
  }
  function anagram_feedback(is_correct, is_word, show_feedback = true) {
    let delay = !is_correct && show_feedback ? 1000 : 300;
    let d = iDiv(Goal);
    mStyle(d, { opacity: 1 });
    if (!is_correct) {
      for (let i = 0; i < Goal.word.length; i++) {
        let ch = Goal.word[i];
        let dl = iDiv(Goal.letters[i]);
        dl.innerHTML = ch;
        animate(dl, 'onPulse1', 600);
        if (!is_word) {
          let dwrong = iDiv(Goal.inputs[i]);
          if (dwrong.innerHTML != ch) { mXit(dwrong, 90); }
        }
      }
    } else {
      mCheckit(d, 100);
    }
    return delay;
  }
  return {
    prompt: anagram_prompt,
    fen: anagram_fen,
  }
}
function gatherItems(n, options) {
  let items = null;
  while (!items) { items = Pictures = pickSuitableItems(n, options); }
  let l = items[0].letter;
  for (let i = 0; i < n; i++) {
    let item1 = items[i];
    let item2 = items[(i + 1) % n];
    let label = item1.origLabel = item1.label;
    let idx = item1.iLetter;
    item1.label = replaceAtString(label, idx, item2.letter);
    if (isWord(item1.label)) {
      item2.iLetter = (item2.iLetter + 1) % item2.label.length;
      item2.letter = item2.label[item2.iLetter];
      item1.label = replaceAtString(label, idx, item2.letter);
      if (isWord(item1.label)) return gatherItems(n, options);
    }
    item1.swaps = {};
    item1.swaps[idx] = {
      swapped: { itemId: item2.id, index: item2.iLetter, l: item2.letter },
      correct: { itemId: item1.id, index: item1.iLetter, l: item1.letter },
      temp: null,
    };
  }
  return items;
}
function gauss(x, mean, standardDeviation) {
  return (1 / standardDeviation * Math.sqrt(2 * (3, 14))) * Math.pow(Math.E, -Math.pow(x - mean, 2) / (2 * (standardDeviation * standardDeviation)));
}
function gaussian_amp(canvas, stdev) {
  let v = stdev * stdev;
  function formula(x, v, amp) { return amp * Math.E ** (-(x ** 2) / (2 * v)) / Math.sqrt(v * 2 * Math.PI); }
  let y = 1 / Math.sqrt(v * 2 * Math.PI);
  let amp = .9 * (-canvas.miny) / (canvas.scale * y);
  let f = formula(2, amp);
  f = x => formula(x, v, amp);
  return f;
}
function gaussian1(x, m = 0, stdev = 2, amp = 1) {
  let v = stdev * stdev;
  return amp * Math.E ** (-((x - m) ** 2) / (2 * v)) / Math.sqrt(v * 2 * Math.PI);
}
function gaussianRand() {
  var rand = 0;
  for (var i = 0; i < 6; i += 1) { rand += Math.random(); }
  return rand / 6;
}
function gaussianRandom(start, end) { return Math.floor(start + gaussianRand() * (end - start + 1)); }
function gBg(g, color) { g.setAttribute('fill', color); }
function gCanvas(area, w, h, color, originInCenter = true) {
  let dParent = mBy(area);
  let div = stage3_prepContainer(dParent);
  div.style.width = w + 'px';
  div.style.height = h + 'px';
  let svg = gSvg();
  let style = `margin:0;padding:0;position:absolute;top:0px;left:0px;width:100%;height:100%;`
  svg.setAttribute('style', style);
  mColor(svg, color);
  div.appendChild(svg);
  let g = gG();
  if (originInCenter) g.style.transform = "translate(50%, 50%)";
  svg.appendChild(g);
  return g;
}
function gCreate(tag) { return document.createElementNS('http:/' + '/www.w3.org/2000/svg', tag); }
function gcsAuto() {
  gcs = {};
  for (const gName in allGames) {
    let info = allGames[gName]
    let nPlayers = info.num_players[0];
    let pls = [];
    for (let i = 0; i < nPlayers; i++) {
      let pl = { id: info.player_names[i], playerType: 'me', agentType: null, username: USERNAME + (i > 0 ? i : '') };
      pls.push(pl);
    }
    gcs[gName] = { numPlayers: nPlayers, players: pls };
  }
}
function geht(sp) {
  POOLS.augData = makeDefaultPool(sData);
  annotate(sp);
  dynSpec = sp;
  let pool = POOLS.augData;
  for (const oid in pool) {
    let o = pool[oid];
    if (nundef(o.RSG)) continue;
    let info = mergeIncludingPrototype(oid, o);
    INFO[oid] = info;
  }
}
function gEllipse(w, h) { let r = gCreate('ellipse'); r.setAttribute('rx', w / 2); r.setAttribute('ry', h / 2); return r; }
function gen_palette(hue = 0, nHues = 2, sat = 100, a = 1) {
  let hues = [];
  let hueDiff = 360 / nHues;
  for (let i = 0; i < nHues; i++) {
    hues.push(hue);
    hue += hueDiff;
  }
  let pal = [];
  for (l of [15, 25, 35, 50, 65, 75, 85]) {
    let palHues = [];
    for (const h of hues) {
      cb = `hsla(${h},${sat}%,${l}%,${a})`;
      hopp = (h + 180) % 360;
      cf = `hsla(${hopp},${sat}%,${l < 18 ? 100 : 0}%,${a})`;
      let hex = standardize_color(cb);
      let f5 = idealTextColor(hex);
      palHues.push({ b: cb, f: f5 });
    }
    pal.push(palHues);
  }
  testHelpers('pal.length:', pal.length, ', pal[0].length:', pal[0].length, ', pal:', pal);
  return pal;
}
function genCard() {
  let names = '23456789TJQKA';
  let s = chooseRandom(names);
  if (isNumber(s)) s = Number(s);
  return { obj_type: 'card', short_name: s, oid: getUID() };
}
function genCard52Key() {
  let rank = '23456789TJQKA';
  let suit = 'CDHS';
  let specialRank = '12';
  let specialSuit = 'BJ';
  let isSpecial = tossCoin(25);
  let s;
  if (isSpecial) {
    s = chooseRandom(specialRank) + chooseRandom(specialSuit);
  } else {
    s = chooseRandom(rank) + chooseRandom(suit);
  }
  return { obj_type: 'card', cardKey: s, oid: getUID() };
}
function genCats(n) {
  let di = {};
  let cats = Object.keys(Categories);
  for (let i = 0; i < n; i++) {
    let cat = chooseRandom(cats);
    let incompat = DA.incompatibleCats[cat];
    cats = arrMinus(cats, incompat);
    removeInPlace(cats, cat);
    di[cat] = Categories[cat];
  }
  return di;
}
function genCollapsible(path, info) {
  let caption = stringAfterLast(path, '/');
  let classes = ['collapsible'];
  let dParent = mBy('menu');
  let b = mButton(caption, null, dParent, {}, classes);
  b.id = info.idLink;
  let bView = maPicButton('search', e => showCollapsibleContent(e), b, { float: 'right', w: 25, padding: 2, margin: 2, rounding: 4 });
  bView.addEventListener('mouseenter', ev => {
    ev.stopPropagation = true;
  });
  bView.addEventListener('mouseleave', ev => {
    ev.stopPropagation = true;
  });
  b.style.padding = '4px';
  return b;
}
function generalGrid(nuiBoard, R, area) {
  let bParams = nuiBoard.params = detectBoardParams(nuiBoard, R);
  let ui = nuiBoard.ui = createUi(nuiBoard, R, area);
  let rtreeParent = R.rNodes[nuiBoard.uid];
  let uidBoard = nuiBoard.uid;
  nuiBoard.params.sizes = nuiBoard.bi.sizes = { f: 0, c: 0, e: 0 };
  for (const name of ['fields', 'edges', 'corners']) {
    let groupParams = lookup(DEFS, ['grid', 'params', name]); if (!groupParams) groupParams = {};
    groupParams = safeMerge(groupParams, nuiBoard.bi.params[name]);
    let group = nuiBoard.bi[name];
    let groupSize = nuiBoard.params.sizes[name[0]] = groupParams.size;
    for (const oid in group) {
      let n1 = group[oid];
      let o = n1.o;
      delete n1.o;
      let key = createArtificialSpecForBoardMemberIfNeeded(oid, o, R);
      let ntree, nui;
      ntree = instantOidKey(oid, key, uidBoard, R);
      ntree.params = isdef(ntree.params) ? safeMerge(groupParams, ntree.params) : groupParams;
      if (ntree.params.size != groupSize) groupSize = nuiBoard.params.sizes[name[0]] = ntree.params.size;
      n1.info.size = groupSize;
      ntree.info = n1.info;
      nui = recUi(ntree, R, uidBoard, oid, key);
    }
  }
  nuiBoard.children = rtreeParent.children;
  nuiBoard.adirty = true;
}
function generate() {
  numgen++; if (numgen > system.max) {
    clearInterval(interval_id);
    console.log('done!');
    return;
  }
  len *= factor;
  let nextSentence = '';
  for (let i = 0; i < sentence.length; i++) {
    let current = sentence.charAt(i);
    let done = false;
    for (const rule of rules) {
      if (current == rule.aus) {
        nextSentence += rule.mach;
        done = true;
        break;
      }
    }
    if (!done) nextSentence += current;
  }
  sentence = nextSentence;
  createP(sentence);
  turtle();
}
function generate_friendly_table_name(game, players) {
  const europe_capitals = 'Amsterdam,  Ankara,  Astana,  Athens,  Baku,  Belgrade,  Berlin,  Bern,  Bratislava,  Brussels,  Bucharest,  Budapest,  Chisinau,  Copenhagen,  Dublin,  Helsinki,  Kiev,  Lisbon,  Ljubljana,  London,  Luxembourg,  Madrid,  Minsk,  Monaco,  Moscow,  Nicosia,  Oslo,  Paris,  Podgorica,  Prague,  Reykjavík,  Riga,  Rome,  San Marino,  Sarajevo,  Skopje,  Sofia,  Stockholm,  Tallinn,  Tbilisi,  Tirana,  Vaduz,  Valletta,  Vatican City,  Vienna,  Vilnius,  Warsaw,  Yerevan,  Zagreb';
  const asia_capitals = 'Abu Dhabi,  Amman,  Ankara,  Ashgabat,  Astana,  Baghdad,  Baku,  Bangkok,  Beijing,  Beirut,  Bishkek,  Cairo,  Colombo,  Damascus,  Dhaka,  Dili,  Doha,  Dushanbe,  Hanoi,  Islamabad,  Jakarta,  Jerusalem,  Kabul,  Kathmandu,  Kuala Lumpur,  Kuwait City,  Malé,  Manama,  Manila,  Moscow,  Muscat,  Naypyidaw,  New Delhi,  Nicosia,  Phnom Penh,  Pyongyang,  Ramallah,  Riyadh,  Sana’a,  Seoul,  Singapore,  Taipei,  Tashkent,  Tbilisi,  Tehran,  Thimphu,  Tokyo,  Ulaanbaatar,  Vientiane,  Yerevan';
  return 'Battle of ' + chooseRandom(coin() ? europe_capitals.split(',\t') : asia_capitals.split(',\t'));
}
function generate_skype_contacts(n) {
  let date = new Date();
  let res = [{ num: `+${rNumber(11111, 99999)}`, date: date, color: rChoose([ORANGE, PURPLE, 'deepskyblue', 'hotpink']), msg: `<#>'BofA': DO NOT share this S...` }];
  for (let i = 1; i < n; i++) {
    date = rDate(date, new Date(2022, 1, 1));
    let istext = coin();
    let [num, msg] = istext ? [`+${rNumber(11111, 99999)}`, `<#>${rChoose(['BofA', 'Prudential'])}: DO NOT share this S...`]
      : [`+1425${rNumber(1111111, 9999999)}`, `Missed Call`];
    let c = { num: num, date: date, color: rChoose([ORANGE, PURPLE, 'deepskyblue', 'hotpink']), msg: msg };
    res.push(c);
  }
  return res;
}
function generate_statement(dParent, boacc, brand) {
  let brand_colors = {
    usbank: 'navy', prime: 'skyblue', citibank: 'silver', wellsfargo: RED, BofA_rgb: 'navy', chase_bank: BLUE,
    comcast: 'orange', oasis: GREEN, PSE: 'gold', redmond: 'grey'
  };
  let date = new Date();
  let acc = { index: boacc.index, creditline: rNumber(0, 10) * 100, holder: 'Gunter Yang Lee', num: 242948572348, due: rDate(addWeekToDate(date, 4), addWeekToDate(date, 2)) }
  let nums = { prevbalance: rNumber(0, 100), payments: rNumber(100, 1000) + rNumber(0, 100) / 100, fees: rNumber(0, 100) };
  nums.balance = nums.prevbalance + nums.payments + nums.fees;
  acc.cashadvance = acc.creditline / 4;
  acc.num = acc.num.toString();
  acc.num = acc.num.substring(0, acc.num.length - 4) + boacc.sub.substring(1);
  acc.num = parseInt(acc.num);
  let [color, fromdate, todate] = [valf(brand_colors[brand], 'random'), addWeekToDate(date, -5), addWeekToDate(date, -1)];
  //#region header
  let d;
  if (nundef(dParent)) {
    let dpop = mBy('dPopup'); show(dpop); mClear(dpop); mStyle(dpop, { top: 50, right: 10 });
    d = mDiv(dpop, { padding: 10, border: '1px solid #ddd', bg: 'white', fg: 'black' });
  } else {
    mStyle(dParent, { 'justify-content': 'start' });
    d = mDiv(dParent);
  }
  mStyle(d, { bg: 'white', position: 'fixed', top: 50, right: 0, padding: 10 });
  let d1 = mDiv(d, { bg: color, h: 5, w: '100%' });
  let dheader = mDiv(d, { fz: 12 });
  let [dl, dr] = mColFlex(dheader, [1, 3]);
  let logo = createImage(`${brand}.png`, { hmax: 90, wmax: 300 });
  let dl1 = mDiv(dl, { hmax: 90, wmax: 400 }); mAppend(dl1, logo);
  let dr1 = mDiv(dr, { align: 'right', paright: 10 });
  mDiv(dr1, {}, null, `Account Holder: ${acc.holder}`);
  mDiv(dr1, {}, null, `Account Number: ${acc.num}`);
  mDiv(dr1, {}, null, `Statement Period: ${date2locale(fromdate)} - ${date2locale(todate)}`);
  mDiv(dr1, {}, null, `Due Date: ${date2locale(acc.due)}`);
  mDiv(d, {}, null, '<br>');
  //#endregion
  let dmain = mDiv(d, { wmax: 600 });
  let [dlm, drm] = mColFlex(dmain, [1, 1.25]);
  let dlm1 = mDiv(dlm, { hmargin: 10, }, null, `ACCOUNT SUMMARY`);
  let dsum = mDiv(dlm, { hmargin: 10, rounding: 12, padding: 10, border: '1px solid #ccc', bg: 'white', fg: 'black' });
  mDivLR(dsum, { w: '100%' }, null, [`Previous Balance:`, `${format_currency(nums.prevbalance)}`]);
  mDivLR(dsum, { w: '100%' }, null, [`Payments and Credits:`, `${format_currency(nums.payments)}`]);
  mDivLR(dsum, { w: '100%' }, null, [`Purchases:`, `${format_currency(nums.payments)}`]);
  mDivLR(dsum, { w: '100%' }, null, [`Balance Transfers:`, `${format_currency(0)}`]);
  mDivLR(dsum, { w: '100%' }, null, [`Cash Advances:`, `${format_currency(0)}`]);
  mDivLR(dsum, { w: '100%' }, null, [`Fees Charged:`, `${format_currency(nums.fees)}`]);
  mDivLR(dsum, { w: '100%' }, null, [`Interest Charged:`, `${format_currency(0)}`]);
  mDivLR(dsum, { w: '100%' }, null, [`New Balance:`, `${format_currency(nums.balance)}`]);
  mDiv(dsum, { fz: 9, align: 'center' }, null, 'see interest charge calculation section following the Transactions section for detailed APR information');
  mLine(dsum, { fz: 10, align: 'center' });
  mDivLR(dsum, { w: '100%' }, null, [`Credit Line:`, `${format_currency(acc.creditline)}`]);
  mDivLR(dsum, { w: '100%' }, null, [`Credit Line Available:`, `${format_currency(acc.creditline)}`]);
  mDivLR(dsum, { w: '100%' }, null, [`Cash Advance Credit Line:`, `${format_currency(acc.cashadvance)}`]);
  mDivLR(dsum, { w: '100%' }, null, [`Cash Advance Credit Line Available:`, `${format_currency(acc.cashadvance)}`]);
  mDiv(dsum, {}, null, 'You may be able to avoid interest on purchases. See reverse for details');
  let drm1 = mDiv(drm, { hmargin: 10, }, null, `PAYMENT INFORMATION`);
  let dpay = mDiv(drm, { hmargin: 10, rounding: 12, padding: 10, border: '1px solid #ccc', bg: 'white', fg: 'black' });
  mDivLR(dpay, { w: '100%', weight: 'bold' }, null, [`New Balance:`, `${format_currency(nums.balance)}`]);
  mLine(dpay, { fz: 10, align: 'center' });
  mDivLR(dpay, { w: '100%' }, null, [`Minimum Payment Due:`, `${format_currency(nums.balance / 10)}`]);
  mDivLR(dpay, { w: '100%', weight: 'bold' }, null, [`Payment Due Date:`, `${date2locale(acc.due)}`]);
  mDiv(dpay, { fz: 9, matop: 10 }, null, '<b>Late Payment Warning:</b> If we do not receive your minimum payment by the date listed above, you may have to pay a fee of up to $10.00.');
  let drm2 = mDiv(drm, { matop: 10, hmargin: 10, }, null, `REWARDS`);
  let drewards = mDiv(drm, { hmargin: 10, rounding: 12, padding: 10, border: '1px solid #ccc', bg: 'white', fg: 'black' });
  mDivLR(drewards, { w: '100%', weight: 'bold' }, null, [`Cashback Bonus*:`, `Anniversary Month`]);
  mDivLR(drewards, { w: '100%' }, null, [`Opening Balance:`, `${format_currency(0)}`]);
  mDivLR(drewards, { w: '100%' }, null, [`New Cashback Bonus this Period:`, `${format_currency(4.98)}`]);
  mDivLR(drewards, { w: '100%' }, null, [`Redeemed this Period:`, `${format_currency(0)}`]);
  mLine(drewards, { fz: 10, align: 'center' });
  mDivLR(drewards, { w: '100%', weight: 'bold' }, null, [`Cashback Bonus Balance:`, `${format_currency(4.98)}`]);
  mDiv(drewards, { fz: 10 }, null, `<b>to learn more log in to www.${brand}.com</b>`);
  mDiv(d, { matop: 25, maleft: 6 }, null, img_html('statement2.jpg'));
  mDiv(d, {}, null, '<br>');
  let dbla1 = mDiv(d, { hmargin: 10, rounding: 12, padding: 10, border: '1px solid #ccc', bg: 'white', fg: 'black' });
  mAppend(dbla1, createImage('statement1.jpg', {}));
  mAppend(d, createImage('statementfooter.jpg', {}));
  return { div: d, nums: nums, acc: acc, topay: nums.balance, brand: brand, boacc: boacc };
}
function generate_table_id(gamename) {
  return gamename + '_' + get_timestamp();
}
function generate_table_name(n) {
  let existing = Serverdata.tables.map(x => x.friendly);
  while (true) {
    let cap = rChoose(Info.capital);
    let parts = cap.split(' ');
    if (parts.length == 2) cap = stringBefore(cap, ' '); else cap = stringBefore(cap, '-');
    cap = cap.trim();
    let s = (n == 2 ? 'duel of ' : rChoose(['battle of ', 'war of '])) + cap;
    if (!existing.includes(s)) return s;
  }
}
function GenerateCaptures() {
  brd_moveListStart[brd_ply + 1] = brd_moveListStart[brd_ply];
  var pceType;
  var pceNum;
  var pceIndex;
  var pce;
  var sq;
  var tsq;
  var index;
  if (brd_side == COLOURS.WHITE) {
    pceType = PIECES.wP;
    for (pceNum = 0; pceNum < brd_pceNum[pceType]; ++pceNum) {
      sq = brd_pList[PCEINDEX(pceType, pceNum)];
      if (SQOFFBOARD(sq + 9) == BOOL.FALSE && PieceCol[brd_pieces[sq + 9]] == COLOURS.BLACK) {
        AddWhitePawnCaptureMove(sq, sq + 9, brd_pieces[sq + 9]);
      }
      if (SQOFFBOARD(sq + 11) == BOOL.FALSE && PieceCol[brd_pieces[sq + 11]] == COLOURS.BLACK) {
        AddWhitePawnCaptureMove(sq, sq + 11, brd_pieces[sq + 11]);
      }
      if (brd_enPas != SQUARES.NO_SQ) {
        if (sq + 9 == brd_enPas) {
          AddEnPassantMove(MOVE(sq, sq + 9, PIECES.EMPTY, PIECES.EMPTY, MFLAGEP));
        }
        if (sq + 11 == brd_enPas) {
          AddEnPassantMove(MOVE(sq, sq + 11, PIECES.EMPTY, PIECES.EMPTY, MFLAGEP));
        }
      }
    }
    pceType = PIECES.wN;
  } else {
    pceType = PIECES.bP;
    for (pceNum = 0; pceNum < brd_pceNum[pceType]; ++pceNum) {
      sq = brd_pList[PCEINDEX(pceType, pceNum)];
      if (SQOFFBOARD(sq - 9) == BOOL.FALSE && PieceCol[brd_pieces[sq - 9]] == COLOURS.WHITE) {
        AddBlackPawnCaptureMove(sq, sq - 9, brd_pieces[sq - 9]);
      }
      if (SQOFFBOARD(sq - 11) == BOOL.FALSE && PieceCol[brd_pieces[sq - 11]] == COLOURS.WHITE) {
        AddBlackPawnCaptureMove(sq, sq - 11, brd_pieces[sq - 11]);
      }
      if (brd_enPas != SQUARES.NO_SQ) {
        if (sq - 9 == brd_enPas) {
          AddEnPassantMove(MOVE(sq, sq - 9, PIECES.EMPTY, PIECES.EMPTY, MFLAGEP));
        }
        if (sq - 11 == brd_enPas) {
          AddEnPassantMove(MOVE(sq, sq - 11, PIECES.EMPTY, PIECES.EMPTY, MFLAGEP));
        }
      }
    }
    pceType = PIECES.bN;
  }
  pceIndex = LoopSlideIndex[brd_side];
  pce = LoopSlidePce[pceIndex++];
  while (pce != 0) {
    for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
      sq = brd_pList[PCEINDEX(pce, pceNum)];
      for (index = 0; index < DirNum[pce]; ++index) {
        dir = PceDir[pce][index];
        t_sq = sq + dir;
        while (SQOFFBOARD(t_sq) == BOOL.FALSE) {
          if (brd_pieces[t_sq] != PIECES.EMPTY) {
            if (PieceCol[brd_pieces[t_sq]] == brd_side ^ 1) {
              AddCaptureMove(MOVE(sq, t_sq, brd_pieces[t_sq], PIECES.EMPTY, 0));
            }
            break;
          }
          t_sq += dir;
        }
      }
    }
    pce = LoopSlidePce[pceIndex++];
  }
  pceIndex = LoopNonSlideIndex[brd_side];
  pce = LoopNonSlidePce[pceIndex++];
  while (pce != 0) {
    for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
      sq = brd_pList[PCEINDEX(pce, pceNum)];
      for (index = 0; index < DirNum[pce]; ++index) {
        dir = PceDir[pce][index];
        t_sq = sq + dir;
        if (SQOFFBOARD(t_sq) == BOOL.TRUE) {
          continue;
        }
        if (brd_pieces[t_sq] != PIECES.EMPTY) {
          if (PieceCol[brd_pieces[t_sq]] == brd_side ^ 1) {
            AddCaptureMove(MOVE(sq, t_sq, brd_pieces[t_sq], PIECES.EMPTY, 0));
          }
          continue;
        }
      }
    }
    pce = LoopNonSlidePce[pceIndex++];
  }
}
function generateCard(hasOwner = true, hasContent = true, visibleToN = 1) {
  let id = "action_" + unitTestId;
  unitTestId += 1;
  let o = JSON.parse(`
  {
    "wildcard": "Isolationism",
    "season": "Fall",
    "priority": "H",
    "value": 8,
    "obj_type": "action_card",
    "visible": {
      "xset": [
        "Axis"
      ]
    },
    "owner": "Axis",
    "_id": "action_48"
  }
  `);
  if (!hasContent) {
    o = JSON.parse(`
    {
    "obj_type": "action_card",
    "visible": {
      "xset": [
        "Axis"
      ]
    },
    "owner": "Axis",
    "_id": "action_48"
  }
  `);
  }
  o._id = id;
  if (!hasOwner) {
    delete o.owner;
  }
  if (visibleToN == 0) {
    o.visible.xset = [];
  } else if (visibleToN == 2) {
    o.visible.xset.push("West");
  } else if (visibleToN == 3) {
    o.visible.xset = ["Axis", "West", "USSR"];
  }
  return { id: id, o: o };
}
function generateDocs(s = 'halo') {
  let output = `<html><body>${s}</body></html>`;
  downloadFile();
}
function generateExpAnswers() { }
function generateFontString(fz, family, weight = 900) {
  let s = '' + weight + ' ' + fz + 'px ' + family;
  return s.trim();
}
function GenerateMoves() {
  brd_moveListStart[brd_ply + 1] = brd_moveListStart[brd_ply];
  var pceType;
  var pceNum;
  var pceIndex;
  var pce;
  var sq;
  var tsq;
  var index;
  if (brd_side == COLOURS.WHITE) {
    pceType = PIECES.wP;
    for (pceNum = 0; pceNum < brd_pceNum[pceType]; ++pceNum) {
      sq = brd_pList[PCEINDEX(pceType, pceNum)];
      if (brd_pieces[sq + 10] == PIECES.EMPTY) {
        AddWhitePawnQuietMove(sq, sq + 10);
        if (RanksBrd[sq] == RANKS.RANK_2 && brd_pieces[sq + 20] == PIECES.EMPTY) {
          AddQuietMove(MOVE(sq, (sq + 20), PIECES.EMPTY, PIECES.EMPTY, MFLAGPS));
        }
      }
      if (SQOFFBOARD(sq + 9) == BOOL.FALSE && PieceCol[brd_pieces[sq + 9]] == COLOURS.BLACK) {
        AddWhitePawnCaptureMove(sq, sq + 9, brd_pieces[sq + 9]);
      }
      if (SQOFFBOARD(sq + 11) == BOOL.FALSE && PieceCol[brd_pieces[sq + 11]] == COLOURS.BLACK) {
        AddWhitePawnCaptureMove(sq, sq + 11, brd_pieces[sq + 11]);
      }
      if (brd_enPas != SQUARES.NO_SQ) {
        if (sq + 9 == brd_enPas) {
          AddEnPassantMove(MOVE(sq, sq + 9, PIECES.EMPTY, PIECES.EMPTY, MFLAGEP));
        }
        if (sq + 11 == brd_enPas) {
          AddEnPassantMove(MOVE(sq, sq + 11, PIECES.EMPTY, PIECES.EMPTY, MFLAGEP));
        }
      }
    }
    if (brd_castlePerm & CASTLEBIT.WKCA) {
      if (brd_pieces[SQUARES.F1] == PIECES.EMPTY && brd_pieces[SQUARES.G1] == PIECES.EMPTY) {
        if (SqAttacked(SQUARES.E1, COLOURS.BLACK) == BOOL.FALSE && SqAttacked(SQUARES.F1, COLOURS.BLACK) == BOOL.FALSE) {
          AddQuietMove(MOVE(SQUARES.E1, SQUARES.G1, PIECES.EMPTY, PIECES.EMPTY, MFLAGCA));
        }
      }
    }
    if (brd_castlePerm & CASTLEBIT.WQCA) {
      if (brd_pieces[SQUARES.D1] == PIECES.EMPTY && brd_pieces[SQUARES.C1] == PIECES.EMPTY && brd_pieces[SQUARES.B1] == PIECES.EMPTY) {
        if (SqAttacked(SQUARES.E1, COLOURS.BLACK) == BOOL.FALSE && SqAttacked(SQUARES.D1, COLOURS.BLACK) == BOOL.FALSE) {
          AddQuietMove(MOVE(SQUARES.E1, SQUARES.C1, PIECES.EMPTY, PIECES.EMPTY, MFLAGCA));
        }
      }
    }
    pceType = PIECES.wN;
  } else {
    pceType = PIECES.bP;
    for (pceNum = 0; pceNum < brd_pceNum[pceType]; ++pceNum) {
      sq = brd_pList[PCEINDEX(pceType, pceNum)];
      if (brd_pieces[sq - 10] == PIECES.EMPTY) {
        AddBlackPawnQuietMove(sq, sq - 10);
        if (RanksBrd[sq] == RANKS.RANK_7 && brd_pieces[sq - 20] == PIECES.EMPTY) {
          AddQuietMove(MOVE(sq, (sq - 20), PIECES.EMPTY, PIECES.EMPTY, MFLAGPS));
        }
      }
      if (SQOFFBOARD(sq - 9) == BOOL.FALSE && PieceCol[brd_pieces[sq - 9]] == COLOURS.WHITE) {
        AddBlackPawnCaptureMove(sq, sq - 9, brd_pieces[sq - 9]);
      }
      if (SQOFFBOARD(sq - 11) == BOOL.FALSE && PieceCol[brd_pieces[sq - 11]] == COLOURS.WHITE) {
        AddBlackPawnCaptureMove(sq, sq - 11, brd_pieces[sq - 11]);
      }
      if (brd_enPas != SQUARES.NO_SQ) {
        if (sq - 9 == brd_enPas) {
          AddEnPassantMove(MOVE(sq, sq - 9, PIECES.EMPTY, PIECES.EMPTY, MFLAGEP));
        }
        if (sq - 11 == brd_enPas) {
          AddEnPassantMove(MOVE(sq, sq - 11, PIECES.EMPTY, PIECES.EMPTY, MFLAGEP));
        }
      }
    }
    if (brd_castlePerm & CASTLEBIT.BKCA) {
      if (brd_pieces[SQUARES.F8] == PIECES.EMPTY && brd_pieces[SQUARES.G8] == PIECES.EMPTY) {
        if (SqAttacked(SQUARES.E8, COLOURS.WHITE) == BOOL.FALSE && SqAttacked(SQUARES.F8, COLOURS.WHITE) == BOOL.FALSE) {
          AddQuietMove(MOVE(SQUARES.E8, SQUARES.G8, PIECES.EMPTY, PIECES.EMPTY, MFLAGCA));
        }
      }
    }
    if (brd_castlePerm & CASTLEBIT.BQCA) {
      if (brd_pieces[SQUARES.D8] == PIECES.EMPTY && brd_pieces[SQUARES.C8] == PIECES.EMPTY && brd_pieces[SQUARES.B8] == PIECES.EMPTY) {
        if (SqAttacked(SQUARES.E8, COLOURS.WHITE) == BOOL.FALSE && SqAttacked(SQUARES.D8, COLOURS.WHITE) == BOOL.FALSE) {
          AddQuietMove(MOVE(SQUARES.E8, SQUARES.C8, PIECES.EMPTY, PIECES.EMPTY, MFLAGCA));
        }
      }
    }
    pceType = PIECES.bN;
  }
  pceIndex = LoopSlideIndex[brd_side];
  pce = LoopSlidePce[pceIndex++];
  while (pce != 0) {
    for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
      sq = brd_pList[PCEINDEX(pce, pceNum)];
      for (index = 0; index < DirNum[pce]; ++index) {
        dir = PceDir[pce][index];
        t_sq = sq + dir;
        while (SQOFFBOARD(t_sq) == BOOL.FALSE) {
          if (brd_pieces[t_sq] != PIECES.EMPTY) {
            if (PieceCol[brd_pieces[t_sq]] == brd_side ^ 1) {
              AddCaptureMove(MOVE(sq, t_sq, brd_pieces[t_sq], PIECES.EMPTY, 0));
            }
            break;
          }
          AddQuietMove(MOVE(sq, t_sq, PIECES.EMPTY, PIECES.EMPTY, 0));
          t_sq += dir;
        }
      }
    }
    pce = LoopSlidePce[pceIndex++];
  }
  pceIndex = LoopNonSlideIndex[brd_side];
  pce = LoopNonSlidePce[pceIndex++];
  while (pce != 0) {
    for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
      sq = brd_pList[PCEINDEX(pce, pceNum)];
      for (index = 0; index < DirNum[pce]; ++index) {
        dir = PceDir[pce][index];
        t_sq = sq + dir;
        if (SQOFFBOARD(t_sq) == BOOL.TRUE) {
          continue;
        }
        if (brd_pieces[t_sq] != PIECES.EMPTY) {
          if (PieceCol[brd_pieces[t_sq]] == brd_side ^ 1) {
            AddCaptureMove(MOVE(sq, t_sq, brd_pieces[t_sq], PIECES.EMPTY, 0));
          }
          continue;
        }
        AddQuietMove(MOVE(sq, t_sq, PIECES.EMPTY, PIECES.EMPTY, 0));
      }
    }
    pce = LoopNonSlidePce[pceIndex++];
  }
}
function GeneratePosKey() {
  var sq = 0;
  var finalKey = 0;
  var piece = PIECES.EMPTY;
  for (sq = 0; sq < BRD_SQ_NUM; ++sq) {
    piece = brd_pieces[sq];
    if (piece != PIECES.EMPTY && piece != SQUARES.OFFBOARD) {
      finalKey ^= PieceKeys[(piece * 120) + sq];
    }
  }
  if (brd_side == COLOURS.WHITE) {
    finalKey ^= SideKey;
  }
  if (brd_enPas != SQUARES.NO_SQ) {
    finalKey ^= PieceKeys[brd_enPas];
  }
  finalKey ^= CastleKeys[brd_castlePerm];
  return finalKey;
}
async function generateTree(source, context) {
  if (source == 'test') {
    let fStruct = context.fStruct;
    let options = context.options;
    T = R = makeTableTreeX(fStruct, options);
  } else if (source == 'main' || source == 'direct') {
    T = R = new RSG(context.spec, context.defs);
    R.initialChannels = [];
    ensureRtree(R);
    R.baseArea = 'table';
    createStaticUi(R.baseArea, R);
    addNewlyCreatedServerObjects(context.sdata, R);
    R.presentationStrategy = context.defs.defaultPresentationStrategy;
  }
  let uidRoot = R.uidRoot = R.tree.uid;
  R.rRoot = R.rNodes[uidRoot];
  R.uiRoot = R.root = R.uiNodes[uidRoot];
  return R;
}
function generateUnitList() {
  data = {
    created: {
      "246": {
        nationality: "Britain",
        tile: "London",
        type: "Fleet",
        cv: 4,
        obj_type: "unit",
        visible: {
          xset: ["West"]
        },
        _id: 246
      },
      "246": {
        nationality: "Britain",
        tile: "London",
        type: "Fleet",
        cv: 4,
        obj_type: "unit",
        visible: {
          xset: ["West"]
        },
        _id: 246
      },
      "247": {
        nationality: "Britain",
        tile: "Gibraltar",
        type: "Fortress",
        cv: 1,
        obj_type: "unit",
        visible: {
          xset: ["West"]
        },
        _id: 247
      },
      "248": {
        nationality: "Britain",
        tile: "Karachi",
        type: "Fortress",
        cv: 1,
        obj_type: "unit",
        visible: {
          xset: ["West"]
        },
        _id: 248
      }
    }
  };
  return data;
}
function generateWordFiles() {
  let i = 0; let n = 13000; let len = symbolKeys.length;
  while (i < len) {
    wordsFromToText(i, n);
    i += n;
  }
}
function generic_present(d, g) {
  let ui = ui_type_tile(g, d); return;
}
function genG(area, R) {
  console.log('before gen10 habe', R.gens.G.length, R.getSpec());
  R.gen10();
  R.gen11();
  R.gen12();
  R.gen13();
  R.gen14();
  R.gen21(area);
  presentRoot_dep(R.getSpec().ROOT, 'tree');
}
function geniales_sin_ease(canvas, item) {
  let [cv, ctx, astep, a, bstep, b, func, axes] = [canvas.cv, canvas.cx, item.astep, item.a, item.bstep, item.b, item.func, item.axes];
  cClear(cv, ctx);
  showAxes(ctx, axes);
  [a, astep] = oscillate_between(a, 0, 5, astep);
  [b, bstep] = oscillate_between(b, 0, 5, bstep);
  [item.astep, item.a, item.bstep, item.b] = [astep, a, bstep, b];
  funGraph(ctx, axes, x => b * func(a * x), "rgb(11,153,11)", 1);
  return false;
}
function genItems(n, options) { let keys = genKeys(n, options); let items = genItemsFromKeys(keys, options); return items; }
function genItemsFromKeys(keys, options = {}) {
  let items = [];
  for (const k of keys) {
    console.assert(isdef(Syms[k]), 'key not found: ' + k);
    let info = Syms[k];
    let item = infoToItem(info);
    items.push(item);
  }
  addLabels(items, options.language, options.luc);
  items = _extendItemsAndOptions(items, options);
  return items;
}
function genItemsFromObjects(list, keyProp, labelProp, options) {
  let keys = [];
  for (const l of list) keys.push(l[keyProp]);
  let items = list.map(x => infoToItem(Syms[x[keyProp]]));
  let i = 0, luc = options.luc;
  for (const item of items) {
    let label = list[i][labelProp];
    item.o = list[i];
    item.label = luc == 'c' ? toNoun(label) : luc == 'l' ? label : label.toUpperCase();
    i += 1;
  }
  items = _extendItemsAndOptions(items, options);
  return items;
}
function genKeys(n, options) {
  let [maxlen, lang, keySet] = [options.maxlen, valf(options.language, 'E'), valf(options.keySet, 'all')];
  let cond = isdef(maxlen) ? ((x) => x[lang].length <= maxlen) : null;
  let keys = _getKeysCond(n, cond, keySet);
  return keys;
}
function genLink(fname, dParent) {
  let content = stringBefore(fname, '(');
  let b = mLink(content, '#' + content, dParent, { padding: '0px 2px' }, null);
  b.addEventListener('click', showSignatureContent);
  return b;
}
function genMapData(rows, cols, shape, letters = ['X']) {
  let res = []; let topcols = cols;
  if (shape == 'reghex') {
    imiddleRow = (rows - 1) / 2;
    let colarr = _calc_hex_col_array(rows, cols);
    let maxColIndex = 2 * colarr[imiddleRow] - 1;
    let cmiddle = Math.floor(maxColIndex / 2);
    let isMiddleEmpty = (cols % 2 == 0);
    let line = isMiddleEmpty ? ' ' : chooseRandom(letters);
    for (let r = 0; r < rows; r++) {
      let rest = '';
      let isLetter = (line == ' ');
      let numLetters = Math.floor(colarr[r] / 2);
      for (let c = cmiddle + 1; c < maxColIndex; c++) {
        if (isLetter && numLetters > 0) {
          rest += chooseRandom(letters);
          numLetters -= 1;
        }
        else { rest += ' '; }
        isLetter = (!isLetter);
      }
      let revrest = reverseString(rest);
      revrest = replaceNonEmptyByRandom(revrest, letters);
      res.push(revrest + line + rest);
      line = line == ' ' ? chooseRandom(letters) : ' ';
    }
    let line0 = res[0];
    topcols = 0; for (const letter of line0) { if (letter != ' ') cols += 1; }
  } else if (shape == 'regquad') {
    for (let r = 0; r < rows; r++) {
      let line = '';
      for (let c = 0; c < cols; c++) {
        line += chooseRandom(letters);
      }
      res.push(line);
    }
  }
  return [res, topcols];
}
function genPicto() {
  let key = chooseRandom(iconKeys);
  return { obj_type: 'picto', key: key, oid: getUID() };
}
function genServerDataCards(n = 3) {
  let sdata = {};
  for (let i = 0; i < n; i++) { let c = genCard(); sdata[c.oid] = c; }
  return sdata;
}
function genServerDataCards52(n = 3) {
  let sdata = {};
  for (let i = 0; i < n; i++) { let c = genCard52Key(); sdata[c.oid] = c; }
  return sdata;
}
function genServerDataCatan(rows = 3, cols = 1) {
  let resources = { W: 'wood', Y: 'wheat', B: 'brick', O: 'ore', S: 'sheep' };
  let [mapData, topcols] = genMapData(rows, cols, 'reghex', Object.keys(resources));
  cols = topcols;
  let shape = 'hex';
  let line0 = mapData[0];
  cols = 0; for (const letter of line0) { if (letter != ' ') cols += 1; }
  rows = mapData.length;
  let b1 = new SimpleGrid('b1', {
    mapData: mapData,
    shape: shape,
    rows: rows,
    cols: cols,
    hasEdges: true,
    hasNodes: true,
    randomizeIds: true,
    mapData: mapData,
  });
  let sdata = {};
  let oidBoard = getUID();
  let board = simpleGridToServerData(b1);
  sdata[oidBoard] = board;
  board.oid = oidBoard;
  let fields = Object.values(b1.objects).filter(x => x.obj_type == 'field');
  let numbers = arrRange(2, 12);
  for (const oid in b1.objects) {
    let o = jsCopy(b1.objects[oid]);
    o.oid = o.id; delete o.id;
    o.obj_type = capitalize(o.obj_type); //.toCapital(); //toUpperCase(); //'Field';
    if (o.obj_type == 'Field') {
      o.letter = b1.mapData[o.row][o.col];
      o.res = resources[o.letter];
      o.num = chooseRandom(numbers);
    } else { delete o.row; delete o.col; }
    if (isdef(o.neighbors)) o.neighbors = o.neighbors.map(x => (x ? { _obj: x } : null));
    if (isdef(o.edges)) o.edges = o.edges.map(x => (x ? { _obj: x } : null));
    if (isdef(o.corners)) o.corners = o.corners.map(x => (x ? { _obj: x } : null));
    if (isdef(o.fields)) o.fields = o.fields.map(x => (x ? { _obj: x } : null));
    sdata[o.oid] = o;
  }
  Object.values(sdata).map(x => stripObject(x, ['x', 'y', 'x1', 'x2', 'y1', 'y2', 'thickness', 'w', 'h', 'done', 'rightField', 'leftField', 'startNode', 'endNode', 'poly']))
  return sdata;
}
function genServerDataGeneralBoard(rows = 3, cols = 1, shape = 'quad', hasNodes = true, hasEdges = false, { mapVariant = 'reg', fieldContent = { A: 'hallo', B: 'heduda' }, nodeContent, edgeContent } = {}) {
  let mapSpec = isdef(mapVariant) ? mapVariant + shape : shape;
  let [mapData, topcols] = genMapData(rows, cols, mapSpec, Object.keys(fieldContent));
  rows = mapData.length;
  let b1 = new SimpleGrid('b1', {
    mapData: mapData,
    shape: shape,
    rows: rows,
    cols: topcols,
    hasEdges: hasEdges,
    hasNodes: hasNodes,
    randomizeIds: true,
    mapData: mapData,
  });
  let sdata = {};
  let oidBoard = getUID();
  let board = simpleGridToServerData(b1);
  sdata[oidBoard] = board;
  board.oid = oidBoard;
  let fields = Object.values(b1.objects).filter(x => x.obj_type == 'field');
  for (const oid in b1.objects) {
    let o = jsCopy(b1.objects[oid]);
    o.oid = o.id; delete o.id;
    o.obj_type = capitalize(o.obj_type); //.toCapital(); //toUpperCase(); //'Field';
    if (o.obj_type == 'Field' && isdef(fieldContent)) {
      o.mapKey = b1.mapData[o.row][o.col];
      o.content = fieldContent[o.mapKey];
    } else { delete o.row; delete o.col; }
    if (isdef(o.neighbors)) o.neighbors = o.neighbors.map(x => (x ? { _obj: x } : null));
    if (isdef(o.edges)) o.edges = o.edges.map(x => (x ? { _obj: x } : null));
    if (isdef(o.corners)) o.corners = o.corners.map(x => (x ? { _obj: x } : null));
    if (isdef(o.fields)) o.fields = o.fields.map(x => (x ? { _obj: x } : null));
    if (o.obj_type == 'Corner' && isdef(nodeContent)) {
      o.content = chooseRandom(Object.values(nodeContent));
    } else if (o.obj_type == 'Edge' && isdef(edgeContent)) {
      o.content = chooseRandom(Object.values(edgeContent));
      console.log('edge:', o)
    }
    sdata[o.oid] = o;
  }
  Object.values(sdata).map(x => stripObject(x, ['x', 'y', 'x1', 'x2', 'y1', 'y2', 'thickness', 'w', 'h', 'done', 'rightField', 'leftField', 'startNode', 'endNode', 'poly']))
  return sdata;
}
function genServerDataPicto(n = 3) {
  let sdata = {};
  for (let i = 0; i < n; i++) { let c = genPicto(); sdata[c.oid] = c; }
  return sdata;
}
function genServerDataTtt(rows = 3, cols = 3) {
  let [mapData, topcols] = genMapData(rows, cols, 'regquad', ['X']);
  let shape = 'quad';
  let b1 = new SimpleGrid('b1', {
    mapData: mapData,
    shape: shape,
    rows: rows,
    cols: cols,
    hasEdges: false,
    hasNodes: false,
    randomizeIds: true,
    mapData: mapData,
  });
  let sdata = {};
  let oidBoard = getUID();
  let board = simpleGridToServerData(b1);
  sdata[oidBoard] = board;
  board.oid = oidBoard;
  let fields = Object.values(b1.objects).filter(x => x.obj_type == 'field');
  let numbers = arrRange(2, 12);
  for (const oid in b1.objects) {
    let o = jsCopy(b1.objects[oid]);
    o.oid = o.id; delete o.id;
    o.obj_type = capitalize(o.obj_type); //.toCapital(); //toUpperCase(); //'Field';
    if (o.obj_type == 'Field') {
      o.letter = b1.mapData[o.row][o.col];
    } else { delete o.row; delete o.col; }
    if (isdef(o.neighbors)) o.neighbors = o.neighbors.map(x => (x ? { _obj: x } : null));
    if (isdef(o.edges)) o.edges = o.edges.map(x => (x ? { _obj: x } : null));
    if (isdef(o.corners)) o.corners = o.corners.map(x => (x ? { _obj: x } : null));
    if (isdef(o.fields)) o.fields = o.fields.map(x => (x ? { _obj: x } : null));
    sdata[o.oid] = o;
  }
  Object.values(sdata).map(x => stripObject(x, ['x', 'y', 'x1', 'x2', 'y1', 'y2', 'thickness', 'w', 'h', 'done', 'rightField', 'leftField', 'startNode', 'endNode', 'poly']))
  return sdata;
}
function germanize(s) { return toUmlaut(s); }
function get_account() {
  let udata = get_current_userdata();
  mBy("inner_left_panel").innerHTML = present_account(udata);
}
function get_account_dep() { get_data({}, "account"); }
function get_account_info() { get_data({}, "account"); }
function get_admin_player(list) {
  let res = valf(firstCond(list, x => x == 'mimi'), firstCond(list, x => ['felix', 'amanda', 'lauren'].includes(x)));
  return res ?? list[0];
}
function get_app_presenter(id) {
  let di = {};
  return di[id] || generic_present;
}
function get_approx_derivative(f, dx) { }
function get_approx_integral(f, dx) { }
function get_auction_history(fen) {
  let lines = [];
  let revorder = jsCopy(fen.plorder).reverse();
  for (const uplayer of revorder) {
    if (nundef(fen.buy[uplayer])) continue;
    lines.push(`${uplayer} buys ${fen.buy[uplayer].a} for ${fen.second_most}`);
  }
  lines.push(`auction winner(s)${fen.maxplayers.length > 1 ? 's' : ''}: ${fen.maxplayers.join(', ')}`);
  for (const uplayer of revorder) {
    lines.push(`${uplayer} bids ${fen.auction[uplayer]}`);
  }
  return lines;
}
function get_available_goals(plname) {
  return Z.fen.availableGoals.filter(x => !Z.fen.players[plname].goals[x]);
}
function get_bar_values() {
  let res = {};
  for (const color in DA.bars) {
    let bar = DA.bars[color];
    res[color] = bar.w;
  }
  return res;
}
function get_boa_footer1() {
  return mCreateFrom(img_html('boa_footer.jpg', fulldim = 'width'));
}
function get_boa_footer2() {
  let d = mDiv(null, { matop: 25, padding: 10, box: true });
  mAppend(d, mCreateFrom(img_html('boa_footer2.jpg', fulldim = 'width')));
  return d;
}
function get_boa_pwd_input() { return document.getElementById('tlpvt-passcode-input'); }
function get_boa_start_content() {
  let img = `<img src='../rechnung/images/boa_start_pic.JPG' width='100%'>`;
  return mCreateFrom(img);
}
function get_boa_userid_input() { return document.getElementById('enterID-input'); }
function get_boalogin_html() {
  let html = `
    <div id="dBoaLogin" class="fsd-layout fsd-2c-700lt-layout">
      <div class="fsd-border">
        <div class="center-content">
          <div class="columns">
            <div class="flex-col lt-col">
              <div class="online-id-vipaa-module">
                <div class="enter-skin phoenix">
                  <form
                    class="simple-form collector-form-marker"
                    name="enter-online-id-form"
                    id="EnterOnlineIDForm"
                    method=""
                    action="javascript:onclick_submit_boa_login();"
                    autocomplete="off"
                    novalidate="novalidate"
                  >
                    <div class="online-id-section">
                      <label for="enterID-input">
                        User ID
                        <span class="ada-hidden">Must be at least 6 characters long</span>
                      </label>
                      <input
                        type="text"
                        id="enterID-input"
                        name="dummy-onlineId"
                        maxlength="32"
                        value=""
                        autocomplete="off"
                        class="cs-enterID-input"
                        autocapitalize="none"
                        autocorrect="off"
                        spellcheck="false"
                      />
                      <div class="remember-info">
                        <input type="checkbox" id="remID" name="saveMyID" class="cs-remID" autocapitalize="none" autocorrect="off" spellcheck="false" />
                        <label for="remID">Save this User ID</label>
                        <a
                          class="boa-dialog force-xlarge info-layer-help-fsd dotted"
                          href="javascript:void(0);"
                          name="online-id-help"
                          rel="help-content"
                          title="Help"
                        >
                          <span class="ada-hidden">Online ID Help</span>
                          <span class="boa-ada-text ada-hidden">&nbsp;layer</span>
                        </a>
                        <div class="clearboth"></div>
                      </div>
                    </div>
                    <input
                      aria-hidden="true"
                      type="password"
                      class="tl-private cs-input"
                      name="new-passcode"
                      maxlength="20"
                      style="display: none"
                      value=""
                      autocapitalize="none"
                      autocorrect="off"
                      spellcheck="false"
                    />
                    <label for="tlpvt-passcode-input" class="mtop-15">
                      Password
                      <span class="ada-hidden">is unavailable. Please enter atleast 6 characters of online id to enable Passcode</span>
                    </label>
                    <div class="TL_NPI_Pass">
                      <input
                        type="password"
                        class="tl-private fl-lt cs-tlpvt-passcode-input"
                        id="tlpvt-passcode-input"
                        name="dummy-passcode"
                        maxlength="20"
                        value=""
                        autocomplete="off"
                        autocapitalize="none"
                        autocorrect="off"
                        spellcheck="false"
                      />
                    </div>
                    <a href="#" class="fl-lt forgot-passcode" name="forgot-your-passcode">Forgot your Password?</a>
                    <div class="clearboth"></div>
                    <a
                      href="javascript:void(0);"
                      onclick="enterOnlineIDFormSubmit();"
                      title="Log In"
                      class="btn-bofa btn-bofa-blue btn-bofa-small behbio btn-bofa-noRight"
                      name="enter-online-id-submit"
                    >
                      <span class="btn-bofa-blue-lock">Log In</span>
                    </a>
                    <a href="javascript:void(0);" id="signin-mobile-app" name="signin-mobile-app" class="displayNone">Log In with mobile app</a>
                    <a href="javascript:void(0);" id="signin-with-passcode" name="signin-with-passcode" class="hidden">Log In with Password</a>
                    <a href="javascript:void(0);" id="signin-with-windows-hello" name="signin-with-windows-hello" class="bold hidden">
                      Log in with Windows Hello
                    </a>
                    <div class="digital-id-notify phoenix hidden" id="digital-id-success-message">
                      <div class="digital-id-head">Check your mobile device</div>
                      <span class="circle-animation">
                        <div class="circle-inline">Loading</div>
                        <div class="loading-circle circle-inline">
                          <div class="circle-bounce1"></div>
                          <div class="circle-bounce2"></div>
                          <div class="circle-bounce3"></div>
                        </div>
                      </span>
                      <p class="digital-id-msg">
                        We sent a notification to your registered device. Verify your identity in the app now to log in to Online Banking.
                      </p>
                      <a href="javascript:void(0);" class="digital-id-link send-notification-again">Send notification again</a>
                      <a href="javascript:void(0);" class="digital-id-link sign-in-with-passcode-instead">Log In with Password instead</a>
                    </div>
                    <div class="digital-id-notify phoenix hidden" id="digital-id-general-error">
                      <div class="digital-id-head">Check your mobile device</div>
                      <p class="digital-id-msg">
                        If you're enrolled in this security feature, we sent a notification to your registered device. Verify your identity in the app now to
                        log in to Online Banking.
                      </p>
                      <a href="javascript:void(0);" class="digital-id-link send-notification-again">Send notification again</a>
                      <a href="javascript:void(0);" class="digital-id-link sign-in-with-passcode-instead">Log In with Password instead</a>
                    </div>
                    <div class="digital-id-notify phoenix hidden" id="digital-id-max-error">
                      <div class="digital-id-head">Check your mobile device</div>
                      <p class="digital-id-msg">We can't identify you at this time. Please use your User ID/Password to log in.</p>
                      <a href="javascript:void(0);" class="digital-id-link sign-in-with-passcode-instead">Log In with Password instead</a>
                    </div>
                    <div class="clearboth"></div>
                    <input type="hidden" name="_ia" id="_iaID" class="cs-_iaID" autocapitalize="none" autocorrect="off" spellcheck="false" />
                    <input
                      type="hidden"
                      name="_u2support"
                      id="u2supportID"
                      value="1"
                      class="cs-u2supportID"
                      autocapitalize="none"
                      autocorrect="off"
                      spellcheck="false"
                    />
                    <input
                      type="hidden"
                      name="webAuthAPI"
                      id="webAuthAPIID"
                      value="true"
                      class="cs-webAuthAPIID"
                      autocapitalize="none"
                      autocorrect="off"
                      spellcheck="false"
                    />
                  </form>
                  <!-- #region nach form -->
                  <div id="fpContainer" class="" style="width: 50%"></div>
                  <!-- Mobile CTA: Borneo version of 'Get the app' widget on the signOnV2 page -->
                  <!-- Normal Scenario -->
                  <div class="mobile-cta-section vertical-dotted-line fl-rt">
                    <p class="cnx-regular title enroll-color-gray mbtm-10">Stay connected with our app</p>
                    <img height="208" width="149" src="../rechnung/images/mobile_llama.png" alt="Mobile banking Llama" class="fl-lt" />
                    <div class="get-app-content-section">
                      <div class="cnx-regular title enroll-color-gray mcta-bubble">Secure, convenient banking anytime</div>
                      <a
                        id="choose-device-get-the-app"
                        name="choose-device-get-the-app"
                        class="choose-device-get-the-app-modal btn-bofa btn-bofa-red btn-bofa-noRight cnx-regular"
                        href="javascript:void(0);"
                        rel="mobile-app-download-choose-device"
                      >
                        <span>Get the app</span>
                        <span class="ada-hidden">&nbsp; link opens a new info modal layer</span>
                      </a>
                    </div>
                  </div>
                  <!-- #endregion -->
                </div>
              </div>
              <!-- #region body rest -->
              <div class="modal-mobile-module hide">
                <div class="get-app-skin aps-mobile-products">
                  <h3>{title}</h3>
                  <div class="content-wrapper three-col">
                    <div class="{storeLogo}">
                      <div class="column app-box">
                        <h4 class="sprite sprite-I5 sprited">
                          Download directly to your mobile device.
                          <div class="spr"></div>
                        </h4>
                        <a
                          class="sprite store-icon {storeLogo} sprited"
                          name="{storeName}"
                          href="#"
                          id="{storeId}"
                          target="_blank"
                        >
                          <span class="ada-hidden">{storeLinkText}</span>
                          <div class="spr"></div>
                        </a>
                        <p class="{notice}">{noticeText}</p>
                      </div>
                      <div class="column comm-box {text}{email}">
                        <h4 class="sprite sprite-J5 {text} sprited">
                          We'll text you a link to download the app.
                          <div class="spr"></div>
                        </h4>
                        <h4 class="sprite sprite-L5 row-2 {email} sprited">
                          We'll email you a link to download the app.
                          <div class="spr"></div>
                        </h4>
                        <form action="" id="mobile_app_download_url">
                          <div id="field-level-error" role="alert"><span class="ada-hidden"></span></div>
                          <div class="{text}">
                            <label
                              class="ada-hidden"
                              for="tlpvt-mob_app_download_phone_num"
                              name="mobile_app_download_phone_prompt"
                              id="mobile_app_download_phone_prompt"
                            >
                              {placeholderText}
                            </label>
                            <input
                              type="text"
                              name="mobile_app_download_phone_number"
                              id="tlpvt-mob_app_download_phone_num"
                              class="phone-input {text} tl-private cs-tlpvt-mob_app_download_phone_num"
                              placeholder="{placeholderText}"
                              autocapitalize="none"
                              autocorrect="off"
                              spellcheck="false"
                            />
                          </div>
                          <div class="{email}">
                            <label
                              class="ada-hidden"
                              for="tlpvt-mob_app_download_email_id"
                              name="mobile_app_download_email_prompt"
                              id="mobile_app_download_email_prompt"
                            >
                              {emailPlaceholderText}
                            </label>
                            <input
                              type="text"
                              name="mobile_app_download_email_id"
                              id="tlpvt-mob_app_download_email_id"
                              class="email-input {email} tl-private cs-tlpvt-mob_app_download_email_id"
                              placeholder="{emailPlaceholderText}"
                              autocapitalize="none"
                              autocorrect="off"
                              spellcheck="false"
                            />
                          </div>
                          <a
                            href="javascript:void(0);"
                            name="anc-send-email-button"
                            class="btn-bofa btn-bofa-small btn-bofa-noRight"
                            id="mobile_app_download_send_button"
                            onclick="onclick_button_line_844()"
                          >
                            Send
                          </a>
                          <div class="clearboth"></div>
                          <p class="{text}">
                            By providing your mobile number you are consenting to receive a text message. Text message fees may apply from your carrier. Text
                            messages may be transmitted automatically.
                          </p>
                        </form>
                      </div>
                      <div class="column info-box">
                        <h4 class="sprite sprite-K5 sprited">
                          Visit bankofamerica.com in your mobile web browser for a link to download the app.
                          <div class="spr"></div>
                        </h4>
                      </div>
                    </div>
                    <div class="other-device-info {deviceStatus}">
                      <div>
                        <p>Our mobile app is not available for all devices</p>
                        <a
                          href="#"
                          class="style-link guillemet-right"
                          name="anc_learn_more_about_phone_banking"
                        >
                          Learn about your Banking by Phone options&nbsp;
                          <span class="guillemet ls-n1 f-11 ls-n2 guillement-set">��</span>
                        </a>
                      </div>
                    </div>
                    <div class="confirmation-screen hide">
                      <div class="inline-ack-msg sprite sprite-D7 sprited">
                        <span class="ada-hidden"></span>
                        <span class="message"></span>
                        <span id="inputHolder" class="TL_NPI_L1"></span>
                        <div class="spr"></div>
                      </div>
                      <div class="button-wrapper">
                        <a href="javascript:;" class="btn-bofa btn-bofa-blue btn-bofa-small" name="anc-close-button" id="confirmModalCloseButton">Close</a>
                        <a href="javascript:;" class="btn-bofa btn-bofa-small btn-bofa-noRight" name="anc-send-another-link" id="confirmModalSendAnotherLink">
                          Send another link
                        </a>
                      </div>
                    </div>
                    <div class="processing hide">
                      <span class="ada-hidden">Please wait. Your request is being processed.</span>
                      <span class="modal-skin-processing-text">Please wait...</span>
                    </div>
                    <div class="clearboth"></div>
                  </div>
                </div>
              </div>
              <div id="mobile-app-download-flex-modal" class="aps-mobile-products"></div>
              <style type="text/css">
                .aps-mobile-products .sprite .spr {
                  background-image: url('/content/images/ContextualSiteGraphics/Instructional/en_US/aps-mobile-products-icon-sprite-dev.png');
                  background-size: 700px 550px;
                }
              </style>
              <div class="mobile-app-download-module hide" id="mobile-app-download-choose-device">
                <div class="choose-device-modal-skin">
                  <h3>Select your device</h3>
                  <div class="flex-modal-main-content">
                    <p>Please select your device to continue:</p>
                    <label for="device-pulldown" class="ada-hidden">Select your device. Press TAB to continue after making selection.</label>
                    <select id="device-pulldown" name="device-pulldown" class="select-bofa">
                      <option value="Select your device">Select your device</option>
                      <option value="iPhone">iPhone</option>
                      <option value="iPad">iPad</option>
                      <option value="Android">Android</option>
                      <option value="Other">Other</option>
                    </select>
                    <div class="clearboth"></div>
                    <a
                      href="javascript:void(0);"
                      id="choose-device"
                      class="btn-bofa btn-bofa-red btn-disabled get-app-modal-trigger btn-bofa-noRight"
                      name="choose-device"
                      rel="choose-device-modal"
                    >
                      Continue
                      <span class="ada-hidden">&nbsp; link opens a new info modal layer</span>
                    </a>
                  </div>
                </div>
              </div>
              <style type="text/css">
                .aps-mobile-products .sprite-D5 > .spr {
                  width: 50px !important;
                  left: 25px !important;
                  top: -5px !important;
                }
                .aps-mobile-products .sprite-J8 > .spr {
                  height: 51px;
                  width: 50px !important;
                  background-position: -522px -410px !important;
                  left: 30px !important;
                }
                .aps-mobile-products .sprite-F5 > .spr {
                  width: 50px !important;
                  left: 25px !important;
                  top: -5px !important;
                }
              </style>
              <!-- #endregion body rest -->
            </div>
            <div class="flex-col rt-col">
              <div class="side-well-vipaa-module">
                <div class="fsd-ll-skin">
                  <h2>Login help</h2>
                  <ul class="li-pbtm-15">
                    <li>
                      <a class="arrow" href="#" name="Forgot ID/Password?">Forgot ID/Password?</a>
                    </li>
                    <li>
                      <a class="arrow" href="#" name="Problem logging in?">Problem logging in?</a>
                    </li>
                  </ul>
                </div>
                <div class="fsd-ll-skin">
                  <h2>Not using Online Banking?</h2>
                  <ul class="li-pbtm-15">
                    <li>
                      <a class="arrow" href="#" name="Enroll_now">
                        Enroll now
                        <span class="ada-hidden">for online Banking</span>
                      </a>
                    </li>
                    <li>
                      <a class="arrow" href="#" name="Learn_more_about_Online_Banking_dotcom">
                        Learn more about Online Banking
                      </a>
                    </li>
                    <li>
                      <a class="arrow" href="#" name="Service_Agreement_dotcom">
                        Service Agreement
                      </a>
                    </li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="clearboth"></div>
          </div>
        </div>
      </div>
    </div>
  `;
  return mCreateFrom(html);
}
function get_bstp() {
  const actions = {
    obst: 'apfel orange assorted plum granat',
    veggie: 'karotte kartoffel purree kohlsprossen zwiebel knoblauch assorted',
    backen: 'almondhorn gugelhupf vanillekipferl striezelteig apfelmus marm',
    kochen: 'purree hameggs omelette soup mushroom pizza',
    spaz: 'femto micro macro standard 104 tennis HS safeway libTJ',
    klavier: 'op111 wald1 mond3 etude nocturne ballade ital mozartB mozartKKC kk3_3 kk5_2',
    putzen: 'herd counter kueche eingang guklo stiege loft/guzi wohnzi',
    erltm: 'post zahlen scan emailtm discordtm termin',
    deconstruction: 'video sleep walkthink libthink starbucksthink',
  };
  let time = rNumber(1, 5);
  let points = rNumber(1, 3);
  let key = rChoose(get_keys(actions));
  let val = rChoose(actions[key]);
  console.log('val', val);
}
function get_building_with_rumor(fen, plname) {
  let buildings = fen.players[plname].buildings;
  for (const type in buildings) {
    let i = 0;
    for (const b of buildings[type]) {
      if (isdef(b.rumors)) {
        b.type = type;
        b.path = `players.${plname}.buildings.${type}.${i}`;
        return b;
      }
      i++;
    }
  }
  return null;
}
function get_card_div(R1 = '1', SB = 'B') {
  let key52 = get_card_key52(R1, SB);
  let svgCode = C52['card_1B'];
  svgCode = '<div>' + svgCode + '</div>';
  let el = mCreateFrom(svgCode);
  [w, h] = [isdef(w) ? w : Card.w, isdef(h) ? h : Card.sz];
  mSize(el, w, h);
  return el;
}
function get_card_key52(R1 = '1', SB = 'B') {
  return `card_${Rank1}${SuitB}`;
}
function get_center(d) { let r = getRect(d); return [r.w / 2, r.h / 2]; }
function get_chat(e) { get_data({ username: CURRENT_CHAT_USER }, "chats"); }
function get_chats(e) { get_data({ username: CURRENT_CHAT_USER }, "chats"); }
function get_checked_radios(rg) {
  let inputs = rg.getElementsByTagName('INPUT');
  let list = [];
  for (const ch of inputs) {
    let checked = ch.getAttribute('checked');
    if (ch.checked) list.push(ch.value);
  }
  return list;
}
function get_circle(center, styles = {}) {
  addKeys({ opacity: isdef(styles.bg) ? 1 : 0, sz: 10, fg: 'black' }, styles)
  styles = styles_to_leaflet_options(styles);
  styles.x = center.lon; styles.y = center.lat; styles.center = center;
  return L.circle(center, styles);
}
async function get_cities_and_capitals() {
  let cities = await route_path_yaml_dict('../base/assets/cities.yaml');
  let cont_by_country = {};
  for (const continent in Geo.continents) {
    for (const country of Geo.continents[continent]) {
      cont_by_country[country] = continent;
    }
  }
  let res = {}; let capitals = [];
  for (const c in cities) {
    let s = cities[c];
    let ws = s.split(',').map(x => x.trim());
    let o = { name: c, lon: Number(ws[0]), lat: Number(ws[1]), country: ws[2], type: ws[3], pop: Number(ws[4]) };
    o.center = [o.lat, o.lon];
    if (o.type == 'capital') capitals.push(c);
    o.continent = cont_by_country[o.country];
    if (nundef(o.continent)) { console.log('no continent for', o.country); break; }
    res[c.toLowerCase()] = o;
  }
  Geo.cities = res;
  Geo.capitals = capitals;
}
function get_clicks_from_playerdata() {
  let clicks = { green: 0, red: 0 };
  for (const pl of Z.playerdata) {
    let state = pl.state;
    if (!isEmpty(state)) {
      for (const k of ['green', 'red']) {
        if (state[k] > 0) {
          clicks[k] += state[k];
        }
      }
    }
  }
  return clicks;
}
function get_column(board, column) {
  var col = []
  for (let row = 0; row < 9; row++) {
    col.push(board[row][column]);
  }
  return col
}
function get_contacts(e) { get_data({}, "contacts"); }
function get_contacts_dep(e) { get_data({}, "contacts"); }
function get_container_styles(styles = {}) { let defaults = valf(Config.ui.container, {}); defaults.position = 'relative'; addKeys(defaults, styles); return styles; }
function get_containertitle_styles(styles = {}) { let defaults = valf(Config.ui.containertitle, {}); defaults.position = 'absolute'; addKeys(defaults, styles); return styles; }
function get_create_staged(fen, options, player_names) {
  let t = create_table(options, player_names);
  t.fen = fen;
  to_server({ table: t }, 'delete_and_create_staged');
}
function get_create_table(user, game) {
  Session.cur_tid = Session.cur_table = null;
  Session.scoring_complete = false;
  let t = {};
  t.friendly = generate_friendly_table_name();
  t.game = Session.cur_game;
  t.host = Session.cur_user;
  t.players = valf(lookup(Session, ['game_options', 'players']), get_def_players_for_user(Session.cur_user));
  t.fen = 'noneed';
  t.options = valf(lookup(Session, ['game_options', 'game']), {});
  t.status = 'started';
  t.host_status = 'joined';
  t.player_status = 'joined';
  t.player_init = {};
  t.fen = get_start_data_fen(t.players, t.game);
  to_server(t, 'create_table_and_start');
}
function get_csv_example() {
  let csv = `"Model","mpg","cyl","disp","hp","drat","wt","qsec","vs","am","gear","carb"
  "Mazda RX4",21,6,160,110,3.9,2.62,16.46,0,1,4,4
  "Mazda RX4 Wag",21,6,160,110,3.9,2.875,17.02,0,1,4,4
  "Datsun 710",22.8,4,108,93,3.85,2.32,18.61,1,1,4,1
  "Hornet 4 Drive",21.4,6,258,110,3.08,3.215,19.44,1,0,3,1
  "Hornet Sportabout",18.7,8,360,175,3.15,3.44,17.02,0,0,3,2
  "Valiant",18.1,6,225,105,2.76,3.46,20.22,1,0,3,1
  "Duster 360",14.3,8,360,245,3.21,3.57,15.84,0,0,3,4
  "Merc 240D",24.4,4,146.7,62,3.69,3.19,20,1,0,4,2
  "Merc 230",22.8,4,140.8,95,3.92,3.15,22.9,1,0,4,2
  "Merc 280",19.2,6,167.6,123,3.92,3.44,18.3,1,0,4,4
  "Merc 280C",17.8,6,167.6,123,3.92,3.44,18.9,1,0,4,4
  "Merc 450SE",16.4,8,275.8,180,3.07,4.07,17.4,0,0,3,3
  "Merc 450SL",17.3,8,275.8,180,3.07,3.73,17.6,0,0,3,3
  "Merc 450SLC",15.2,8,275.8,180,3.07,3.78,18,0,0,3,3
  "Cadillac Fleetwood",10.4,8,472,205,2.93,5.25,17.98,0,0,3,4
  "Lincoln Continental",10.4,8,460,215,3,5.424,17.82,0,0,3,4
  "Chrysler Imperial",14.7,8,440,230,3.23,5.345,17.42,0,0,3,4
  "Fiat 128",32.4,4,78.7,66,4.08,2.2,19.47,1,1,4,1  `;
  return csv;
}
function get_cur_menu() { if (isdef(Session.cur_menu)) window['get_' + Session.cur_menu](); }
function get_current_userdata() { return DB.users[Session.cur_user]; }
function get_data(find, type) {
  var xml = new XMLHttpRequest();
  var loader_holder = mBy("loader_holder");
  loader_holder.className = "loader_on";
  xml.onload = function () {
    if (xml.readyState == 4 || xml.status == 200) {
      loader_holder.className = "loader_off";
      handle_result(xml.responseText, type);
    }
  }
  var data = {};
  data.find = find;
  data.data_type = type;
  data = JSON.stringify(data);
  xml.open("POST", "test.php", true);
  xml.send(data);
}
function get_data_offline_orig(find, type) {
  let response = {};
  switch (type) {
    case 'user_info':
    case 'account':
      if (nundef(find.user)) find.user = Session.cur_user;
      let u = response.message = DB.users[find.user];
      response.name = u.username;
      break;
    case 'contacts':
      let usernames = Object.keys(DB.users).filter(x => x != Session.cur_user);
      response.myusers = usernames.map(x => DB.users[x]);
      break;
  }
  response.data_type = type;
  handle_result(JSON.stringify(response), type);
}
function get_data_online_orig(find, type) {
  var xml = new XMLHttpRequest();
  var loader_holder = mBy("loader_holder");
  loader_holder.className = "loader_on";
  xml.onload = function () {
    if (xml.readyState == 4 || xml.status == 200) {
      loader_holder.className = "loader_off";
      handle_result(xml.responseText, type);
    }
  }
  var data = {};
  data.find = find;
  data.data_type = type;
  data = JSON.stringify(data);
  xml.open("POST", "server/api.php", true);
  xml.send(data);
}
function get_data_orig(find, type) {
  if (is_online()) {
    get_data_online(find, type);
  } else {
    if (type == 'chat') {
      alert('no internet!');
      mClassReplace(mBy("label_chat"), 'enabled', 'disabled');
    }
    get_data_offline(find, type);
  }
}
function get_def_players_for_user(uname, list) {
  if (nundef(list)) list = Session.def_players;
  removeInPlace(list, uname);
  list.unshift(uname);
  Session.def_players = list;
  return list;
}
function get_default_options(gamename) {
  let options = {};
  for (const k in Config.games[gamename].options) options[k] = arrLast(Config.games[gamename].options[k]);
  return options;
}
function get_dictionary() {
  let u = DB.users[Session.cur_user];
  let lang = valf(u.lang, 'E');
  if (isdef(Dictionary) && isdef(Dictionary[lang])) return;
  to_server(lang, 'dictionary');
}
function get_distance(from, to) {
  var fromLatLng = L.latLng(from);
  var toLatLng = L.latLng(to);
  var dis = fromLatLng.distanceTo(toLatLng);
  console.log('distance in meters', dis);
  return dis;
}
function get_elo(user, game) { return lookup(DB.users, [user, 'games', game, 'elo']) ?? 100; }
function get_fake_boa_data() { if (nundef(DA.boadata)) DA.boadata = DIBOA.boa_data; return DA.boadata; }
function get_fake_boa_data_list() { if (nundef(DA.boadata)) DA.boadata = dict2list(DIBOA.boa_data, 'key'); return DA.boadata; }
function get_fake_bw_cards() {
  const cards = {
    'amazon': { sub: '*5555', logo: 'visa.png' },
    'amex': { sub: '*4554', logo: 'amex.png' },
    'becu': { sub: '*1331', logo: 'mastercard.png' },
    'becu other': { sub: '*7575', logo: 'mastercard.png' },
    'boa debit': { sub: '*8585', logo: 'visa.png' },
    'boa leprop': { sub: '*0898', logo: 'visa.png' },
    'costco': { sub: '*6565', logo: 'visa.png' },
    'disco': { sub: '*1324', logo: 'discover.png' },
    'fidel rewards': { sub: '*6456', logo: 'visa.png' },
    'flexper': { sub: '*9789', logo: 'visa.png' },
    'heritage': { sub: '*3131', logo: 'mastercard.png' },
    'premblue': { sub: '*0898', logo: 'visa.png' },
    'visa2': { sub: '*0797', logo: 'visa.png' },
    'zz credit': { sub: '*1432', logo: 'visa.png' },
  };
  return cards;
}
function get_fake_bw_logins() {
  const logins = {
    'bw': { link: '', sub: 'gilee144', p: '', acc: '*5555', logo: 'bw.png' },
    'boa': { link: '', sub: 'gilee144', p: 'boa.png', acc: '*5555', logo: 'boa.png' },
    'authy': { link: '', sub: 'agfil22', p: 'authy.png', acc: '*5555', logo: 'authy.png' },
    'authenticator': { link: '', sub: 'amf234', p: '', acc: '*5555', logo: 'authenticator.png' },
    'skype': { link: '', sub: 'agile34', p: '', acc: '*5555', logo: 'skype.png' },
    'onedrive': { link: '', sub: 'agand23', p: '', acc: '*5555', logo: 'onedrive.png' },
  }
  return logins;
}
function get_first_player(otree) { return otree.player_names[0]; }
function get_func(itemtype, cmd) { return window[`${itemtype}_${cmd}`]; }
function get_game_color(game) { return colorFrom(Config.games[game].color); }
function get_game_option(g, key) {
  let set_option = lookup(Session, ['cur_table', 'options', key]);
  if (set_option) return set_option;
  let opts = g.options[key];
  let defval = opts.split(',')[0];
  return defval;
}
function get_game_or_user_option(g, key) {
  let opts = g.options[key].split(',');
  let defval = opts[0];
  let userval = lookup(DB.users, [Session.cur_user, key]);
  if (userval && opts.includes(userval)) return userval;
  let set_option = lookup(Session, ['cur_table', 'options', key]);
  if (set_option) return set_option;
  return defval;
}
function get_games() {
  let d = mBy('inner_left_panel');
  d.innerHTML = "GAMES ARE DISPLAYED HERE!";
  get_data({ assets: nundef(Syms) }, 'games');
}
function get_games_dep() {
  let d = mBy('inner_left_panel');
  d.innerHTML = "GAMES ARE DISPLAYED HERE!";
  get_data({ assets: nundef(Syms) }, 'games');
}
function get_group_rank(j) { let non_jolly_key = firstCond(j, x => !is_jolly(x)); return non_jolly_key[0]; }
function get_header_top(nebenLogo, links) {
  let html = `
    <div class="header-module">
      <div class="fsd-secure-esp-skin">
        <img height="28" width="230" alt="Bank of America" src="../rechnung/images/BofA_rgb.png" />
        <div class="page-type cnx-regular">${nebenLogo}</div>
        <div class="right-links">
          <div class="secure-area">Secure Area</div>
          <div class="clearboth"></div>
        </div>
        <div class="clearboth"></div>
      </div>
    </div>
  `;
  return mCreateFrom(html);
}
function get_image_path(userdata) {
  let p = '../base/assets/images/';
  if (userdata.image) p += userdata.name; else p += 'unknown_user';
  p += '.jpg';
  if (is_online()) p += '?=' + Date.now();
  return p;
}
function get_img_html(path, styles, classes) {
  let img = mImage(path, null, styles, classes);
  let x = img.outerHTML;
  return img.outerHTML;
}
function get_index_in_plorder(otree, uname) { return otree.plorder.indexOf(uname); }
function get_input_value(id) {
  let inp = mBy(id);
  let val = inp.value;
  return val;
}
function get_intro() { to_server(Session.cur_user, "intro"); }
function get_joker_info() {
  return {
    c52key: `card_0J`, //'card_1J', //`card_${1+n%2}`,
    color: "#e6194B",
    friendly: "Joker",
    key: '*Hn',
    h: 100,
    irank: 14,
    isort: 100,
    isuit: 3,
    ov: 0.25,
    rank: "*",
    short: "J",
    suit: "H",
    sz: 100,
    val: 1,
    w: 70,
  };
}
function get_keys(o) { return Object.keys(o); }
function get_layer(key, options) {
  let o = Geo.layerInfo[key];
  if (nundef(o)) o = Geo.layerInfo.empty;
  copyKeys(options, o.options);
  let l = L.tileLayer(o.url, o.options);
  addKeys(options, l);
  return l;
}
function get_layer_options() {
  return {
    "OSM": osmBase,
    "OpenCycleMap": OpenCycleMap,
    "StamenWatercolor": StamenWatercolor,
  };
  return {
    'OpenStreetMap Default': L.tileLayer.provider('OpenStreetMap.Mapnik'),
    'OpenStreetMap German Style': L.tileLayer.provider('OpenStreetMap.DE'),
    'OpenStreetMap H.O.T.': L.tileLayer.provider('OpenStreetMap.HOT'),
    'Thunderforest OpenCycleMap': L.tileLayer.provider('Thunderforest.OpenCycleMap', { apikey: '87e7668535754c798ef4870cadbeb2ab' }),
    'Thunderforest Landscape': L.tileLayer.provider('Thunderforest.Landscape', { apikey: '87e7668535754c798ef4870cadbeb2ab' }),
    'Thunderforest Atlas': L.tileLayer.provider('Thunderforest.Atlas', { apikey: '87e7668535754c798ef4870cadbeb2ab' }),
    'Thunderforest Transport': L.tileLayer.provider('Thunderforest.Transport', { apikey: '87e7668535754c798ef4870cadbeb2ab' }),
    'Stamen Toner': L.tileLayer.provider('Stamen.Toner'),
    'Stamen Terrain': L.tileLayer.provider('Stamen.Terrain'),
    'Stamen Watercolor': L.tileLayer.provider('Stamen.Watercolor'),
    'Jawg Streets': L.tileLayer.provider('Jawg.Streets', { apikey: 'DBmQfjladcdInyiIKKel1mAI428eYlXfZG26VCU6PvwEGLQ1QvoIqCl0k7I41eAv' }),
    'Jawg Terrain': L.tileLayer.provider('Jawg.Terrain', { apikey: 'DBmQfjladcdInyiIKKel1mAI428eYlXfZG26VCU6PvwEGLQ1QvoIqCl0k7I41eAv' }),
    'Jawg Test': L.tileLayer.provider('Jawg.Test', { apikey: 'DBmQfjladcdInyiIKKel1mAI428eYlXfZG26VCU6PvwEGLQ1QvoIqCl0k7I41eAv' }),
    'Esri WorldStreetMap': L.tileLayer.provider('Esri.WorldStreetMap'),
    //'Esri DeLorme': L.tileLayer.provider('Esri.DeLorme'), max zoom 12
    'Esri WorldTopoMap': L.tileLayer.provider('Esri.WorldTopoMap'),
    'Esri WorldImagery': L.tileLayer.provider('Esri.WorldImagery'),
    'Esri NatGeoWorldMap': L.tileLayer.provider('Esri.NatGeoWorldMap'),
    'Esri WorldGrayCanvas': L.tileLayer.provider('Esri.WorldGrayCanvas'),
  }
}
function get_lobby(tid) {
  let game = DB.games[Session.cur_game];
  let resume_or_create = isdef(tid) ? 'resume' : 'create';
  let html = `
  <div id="lobby_holder" class="layout_lobby">
    <div id="lobby_header"><div class='logo'>⛱</div>Settings for ${game.friendly}</div>
    <div id="lobby_main">
        <div id='d_game_options' class='vCenterChildren'>
        </div>
        <div class="button_wrapper">
          <button class='button' onclick='onclick_${resume_or_create}_game_button()'>${resume_or_create} game</button>
        </div>
      </div>
    </div>
  `;
  return html;
}
function get_login(php = true) { to_server(Session.cur_user, "login", php); }
function get_login_new(php = true) { to_server(Session.cur_user, "login_new", php); }
function get_logout_button() {
  let html = `<a id="aLogout" href="javascript:onclick_logout()">logout</a>`;
  return mCreateFrom(html);
}
function get_make_payments_button() {
  let html = `
    <a
      href="javascript:void(0);"
      onclick="make_payments();"
      class="btn-bofa btn-bofa-blue btn-bofa-small behbio btn-bofa-noRight"
      name="make-payments-submit"
      >
      <span class="btn-bofa  btn-bofa-blue-lock">Make Payments</span>
    </a>
  `;
}
function get_map_dims_in_lat_lng() { return get_map_dims_in_lat_long(); }
function get_map_dims_in_lat_long() {
  let map = M.map;
  const se = map.getBounds().getSouthEast();
  const ne = map.getBounds().getNorthEast();
  const nw = map.getBounds().getNorthWest();
  return [Math.abs(se.lat - ne.lat), Math.abs(ne.lng - nw.lng)];
}
function get_map_dims_in_meters() {
  let map = M.map;
  const southEastPoint = map.getBounds().getSouthEast();
  const northEastPoint = map.getBounds().getNorthEast();
  const northWestPoint = map.getBounds().getNorthWest();
  const h = southEastPoint.distanceTo(northEastPoint);
  const w = northWestPoint.distanceTo(northEastPoint);
  return [w, h];
}
function get_map_dims_in_pixel() {
  let container = M.map.getContainer();
  let rect = getRect(container);
  return [rect.w, rect.h];
}
function get_marker(map, center, options = {}) {
  let path;
  if (isdef(options.user)) path = '../base/assets/users/' + options.user + '.jpg';
  else if (isdef(options.icon)) path = '../base/assets/icons/' + options.icon + '.png';
  else if (isdef(options.path)) path = options.path;
  let marker;
  if (nundef(path)) {
    marker = L.marker(center, options);
  } else {
    let [w, h] = [valf(options.w, options.sz, 50), valf(options.h, options.sz, 50)];
    addKeys({ w: w, h: h, border: `solid medium ${BLUE}`, bg: colorTrans(BLUE, .5), rounding: '50%', box: true }, options);
    let myIcon = L.divIcon({
      className: 'custom-div-icon',
      html: get_img_html(path, options),
      tooltipAnchor: [5, h / 4],
      popupAnchor: [w / 2 - 5, -5],
    });
    copyKeys({ icon: myIcon }, options)
    marker = L.marker(center, options);
  }
  if (isdef(options.tooltip)) { marker.bindTooltip(options.tooltip).addTo(map); }
  if (isdef(options.tooltip)) { marker.bindPopup(options.popup).addTo(map); }
  return marker.addTo(map);
}
function get_meters_per_pixel() {
  let map = M.map;
  const southEastPoint = map.getBounds().getSouthEast();
  const northEastPoint = map.getBounds().getNorthEast();
  const mapHeightInMetres = southEastPoint.distanceTo(northEastPoint);
  const mapHeightInPixels = map.getSize().y;
  return mapHeightInMetres / mapHeightInPixels;
}
function get_middle_point(p1, p2) { return [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2]; }
function get_modify_table() {
  let uname = Session.cur_user;
  let table = Session.cur_table;
  if (nundef(table)) { alert('no table available!'); return; }
  let game = Session.cur_game = table.game;
  let tid = Session.cur_tid = table.id;
  Session.scoring_complete = false;
  let t = {};
  t.id = Session.cur_tid;
  t.players = valf(lookup(Session, ['game_options', 'players']), table.players);
  t.options = valf(lookup(Session, ['game_options', 'game']), {});
  t.player_init = {};
  t.fen = get_start_data_fen(table.players, game);
  to_server(t, 'modify_table');
}
function get_mouse_pos(ev) {
  let x = ev.pageX - document.body.scrollLeft;
  let y = ev.pageY - document.body.scrollTop;
  return ({ x: x, y: y });
}
function get_multi_trigger() { return lookup(Z, ['fen', 'trigger']); }
function get_next_human_player(plname) {
  if (nundef(plname)) return null;
  let [prevturn, mode, turn, uname, plorder, fen, host] = [Z.prev.turn, Z.mode, Z.turn, Z.uname, Z.plorder, Z.fen, Z.host];
  let same = isString(plname) && isList(prevturn) && sameList(prevturn, turn);
  if (!same) return null;
  let plnew = get_next_player(Z, plname);
  while (fen.players[plnew].playmode == 'bot') {
    plnew = get_next_player(Z, plnew);
    if (plnew == plname) break;
  }
  return plnew;
}
function get_next_in_list(el, list) {
  let iturn = list.indexOf(el);
  let nextplayer = list[(iturn + 1) % list.length];
  return nextplayer;
}
function get_next_player(g, uname) {
  let plorder = g.fen.plorder;
  let iturn = plorder.indexOf(uname);
  let nextplayer = plorder[(iturn + 1) % plorder.length];
  return nextplayer;
}
function get_non_admin_reload() { to_server(Session.cur_user, 'non_admin_reload'); }
function get_normal_cdf(mean, stdev) { }
function get_normal_pdf(mean, stdev) { }
function get_now() { return Date.now(); }
function get_now_milliseconds() {
  return Date.now();
}
function get_num_players(otree) { return otree.player_names.length; }
function get_pay_history(payment, uplayer) { return [`${uplayer} pays with ${payment}`]; }
function get_play(e) {
  get_data({ username: Username, gamename: CURRENT_GAME, assets: nundef(Syms) }, "play");
}
function get_play_dep(e) {
  get_data({ username: Session.cur_user, gamename: Session.cur_game, assets: nundef(Syms) }, "play");
}
function get_play_NOP(step, move) {
  Session.cur_menu = 'games';
  let data = { uname: Session.cur_user, tid: Session.cur_tid };
  if (isdef(step) && isdef(move)) { data.step = step; data.move = move; }
  to_server(data, "play");
}
function get_play_start() { Session.cur_menu = 'play'; to_server({ uname: Session.cur_user, tid: Session.cur_tid }, 'play_start'); }
function get_player_options(players, game) { return players.map(x => `${x}:${get_startlevel(x, game)}:${get_preferred_lang(x)}`).join(','); }
function get_player_score(plname) { ensure_score(plname); return Z.fen.players[plname].score; }
function get_playmode(uname) { return Z.fen.players[uname].playmode; }
function get_plus_progressbar(dParent, color, id) {
  if (nundef(id)) id = getUID();
  let d = mDiv(dParent, {}, id, null, 'grid_progressbar');
  let button = mButton('+', () => onclick_plus(color, 10), d);
  let d1 = mDiv(d, {}, null, null, 'progressbar');
  let winit = DA.winit = 10;
  let dbar = mDiv(d1, { bg: color, w: winit + '%' }, 'b_' + color, null, 'barstatus');
  return { w: winit, cont: d, div: dbar, ti: null };
}
function get_poly_center(fpoly) {
  let c2 = my_poly_center(fpoly);
  if (!c2) {
    console.log('NEIN!!!!!!!!!!!');
    let polygon = L.polygon(fpoly.geometry.coordinates);
    let bounds = polygon.getBounds();
    let center = bounds.getCenter();
    center = [center.lng, center.lat];
    c2 = center;
  }
  return c2;
}
function get_polygon_centroid(pts) {
  var first = pts[0], last = pts[pts.length - 1];
  if (first.x != last.x || first.y != last.y) pts.push(first);
  var twicearea = 0,
    x = 0, y = 0,
    nPts = pts.length,
    p1, p2, f;
  for (var i = 0, j = nPts - 1; i < nPts; j = i++) {
    p1 = pts[i]; p2 = pts[j];
    f = p1.x * p2.y - p2.x * p1.y;
    twicearea += f;
    x += (p1.x + p2.x) * f;
    y += (p1.y + p2.y) * f;
  }
  f = twicearea * 3;
  return { x: x / f, y: y / f };
}
function get_preferred_lang(uname) { return lookup(DB.users, [uname, 'lang']) ?? 'E'; }
function get_present_order() {
  let [fen, uplayer, uname] = [Z.fen, Z.uplayer, Z.uname];
  let uname_plays = fen.plorder.includes(Z.uname);
  let show_first = uname_plays && Z.mode == 'multi' ? Z.uname : uplayer;
  return arrCycle(Z.fen.plorder, Z.fen.plorder.indexOf(show_first));
}
function get_progressbar(dParent, color, sym) {
  let id = getUID();
  let d = mDiv(dParent, {}, id, null, 'grid_progressbar');
  let button = mButton(sym, () => onclick_plus_minus(color), d);
  let d1 = mDiv(d, {}, null, null, 'progressbar');
  let bar = mDiv(d1, { bg: color, w: 10 + '%' }, 'b_' + color, null, 'barstatus');
  return { bar: bar, button: button, color: color, container: d };
}
function get_quadrant(a) { return a > 270 ? 4 : a > 180 ? 3 : a > 90 ? 2 : 1; }
function get_random_attr_val(attr_list) {
  let all_attrs = gSet_attributes();
  return attr_list.map(x => chooseRandom(all_attrs[x]));
}
function get_random_player_order(otree) { let res = jsCopy(otree.player_names); shuffle(res); return res; }
function get_rank_index(ckey, rankstr = '23456789TJQKA') { return rankstr.indexOf(ckey[0]); }
function get_red_header(title, show_login_button = false) {
  let html = `
    <div class="page-title-module h-100" id="skip-to-h1">
      <div class="red-grad-bar-skin sup-ie" style="display:flex;align-items:center;justify-content:space-between">
        <h1 id="dRedTitle" class="cnx-regular">${title}</h1>`;
  if (show_login_button) {
    html += `
      <div class="title-button">
        <a id="bLoginToOnline" href="javascript:onclick_bigredloginbutton()" class="spa-btn spa-btn--small spa-btn--white-border">Log in to Online Banking</a>
      </div>
            `;
  }
  html += `
      </div>
    </div>
  `;
  return mCreateFrom(html);
}
function get_request(type, data) {
  var xmlhttp = new XMLHttpRequest();
  xmlhttp.onreadystatechange = function () {
    if (this.readyState == 4 && this.status == 200) {
      handle_result(type, this.responseText);
    }
  };
  let url = `php/${type}.php`;
  let isFirst = true;
  for (const k in data) {
    url += (isFirst ? '?' : '&') + k + '=' + data[k];
    isFirst = false;
  }
  xmlhttp.open("GET", url, true);
  xmlhttp.send();
}
function get_robot_personality(name) { return { erratic: 20, bluff: 20, random: 20, risk: 20, passive: 20, clairvoyant: 20, aggressive: 20 }; }
function get_round_goal() { return Z.fen.roundGoals[Z.round - 1]; }
function get_route_control(map, p1, p2) {
  return L.Routing.control({
    waypoints: [
      L.latLng(p1[0], p1[1]),
      L.latLng(p2[0], p2[1])
    ],
    waypointNameFallback: function (latLng) {
      function zeroPad(n) {
        n = Math.round(n);
        return n < 10 ? '0' + n : n;
      }
      function sexagesimal(p, pos, neg) {
        var n = Math.abs(p),
          degs = Math.floor(n),
          mins = (n - degs) * 60,
          secs = (mins - Math.floor(mins)) * 60,
          frac = Math.round((secs - Math.floor(secs)) * 100);
        return (n >= 0 ? pos : neg) + degs + '°' +
          zeroPad(mins) + '\'' +
          zeroPad(secs) + '.' + zeroPad(frac) + '"';
      }
      return sexagesimal(latLng.lat, 'N', 'S') + ' ' + sexagesimal(latLng.lng, 'E', 'W');
    },
    routeWhileDragging: true
  }).addTo(map);
}
function get_row(board, row) {
  return board[row]
}
function get_schweine(fenbuilding) { return fenbuilding.schweine; }
function get_schweine_ui(uibuilding) { return uibuilding.schweine; }
function get_score_fen_from_cur_players() {
  let players = get_values(Session.cur_players);
  let sorted = sortByDescending(players, 'score');
  let list = sorted.map(x => `${x.name}:${x.score}`);
  let fen = list.join(',');
  return fen;
}
function get_scores_from_cur_players() {
  let players = get_values(Session.cur_players);
  let sorted = sortByDescending(players, 'score');
  let list = sorted.map(x => `${x.name}:${x.score}`);
  let fen = list.join(',');
  return fen;
}
function get_screen_distance(child, newParent) {
  child = toElem(child);
  newParent = toElem(newParent);
  const parentOriginal = child.parentNode;
  let children = arrChildren(parentOriginal);
  let iChild = children.indexOf(child);
  let sibling = iChild == children.length - 1 ? null : children[iChild + 1];
  const x0 = child.getBoundingClientRect().left;
  const y0 = child.getBoundingClientRect().top;
  newParent.appendChild(child);
  const x1 = child.getBoundingClientRect().left;
  const y1 = child.getBoundingClientRect().top;
  if (sibling) parentOriginal.insertBefore(child, sibling); else parentOriginal.appendChild(child);
  return [x1 - x0, y1 - y0];
}
function get_selected_ui_item(ev) {
  ev.cancelBubble = true;
  if (!canAct()) { console.log('no act'); return null; }
  uiActivated = false;
  let id = evToId(ev);
  if (nundef(Items[id])) { return null; console.log('clicked on element') }
  let item = Items[id];
  return item;
}
function get_send_move() {
  let me = Session.cur_players[Session.cur_user];
  let o = { tid: Session.cur_tid, player_status: me.player_status, score: me.score, state: me.state, uname: me.name };
  to_server(o, 'send_move');
}
function get_send_move_old() {
  let me = Session.cur_players[Session.cur_user];
  if (me.player_status == 'lamov') me.player_status = 'done';
  let o = { tid: Session.cur_tid, player_status: me.player_status, score: me.score, state: me.state, uname: me.name };
  to_server(o, 'send_move');
}
function get_sequence_suit(j) { let non_jolly_key = firstCond(j, x => !is_jolly(x)); return non_jolly_key[1]; }
function get_skype_expanded_message(msg) {
  if (msg[0] == 'M') { return msg; }
  return msg.slice(0, msg.length - 4) + `ign In code. We will NEVER call you or text you for it. Code ${rNumber(111111, 999999)}. Reply HELP if you didn't request it. `;
}
function get_skype_phone_icon(color) {
  let html = `
  <svg width="20" height="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#0090B8" gradientcolor1="#0090B8" gradientcolor2="#0090B8"><path d="M14.75 13.666a2.75 2.75 0 00-2.745-2.745 2.75 2.75 0 00-2.744 2.745 2.75 2.75 0 002.744 2.744 2.75 2.75 0 002.744-2.744zm-4.117 0c0-.761.622-1.373 1.372-1.373.75 0 1.372.612 1.372 1.373 0 .75-.621 1.372-1.372 1.372-.75 0-1.372-.622-1.372-1.372zm7.547-.466a.69.69 0 00-.686.686v4.121a.69.69 0 01-.686.686H7.203a.69.69 0 01-.686-.686v-4.121a.69.69 0 00-.686-.686.69.69 0 00-.686.686v4.121c0 1.136.922 2.058 2.058 2.058h9.605a2.059 2.059 0 002.058-2.058v-4.121a.69.69 0 00-.686-.686z"></path><path d="M12 3.6c3.998-.005 6.703 1.53 8.585 3.192.792.699 1.154 1.75.966 2.736l-.19.995c-.177.932-1.048 1.558-2.036 1.463l-1.965-.19c-.856-.082-1.491-.708-1.76-1.596-.365-1.206-.6-2.1-.6-2.1-.897-.368-1.784-.6-3-.6s-2.085.258-3 .6c0 0-.245.895-.6 2.1-.237.805-.605 1.508-1.444 1.592l-1.953.197c-.975.098-1.91-.522-2.187-1.45l-.297-.996c-.296-.99-.032-2.033.693-2.736C4.922 5.147 8.008 3.605 12 3.6zm4.17 4.232l.03.114.119.43c.103.367.25.884.43 1.476.163.541.466.725.726.75l1.965.19c.415.04.69-.213.743-.493l.19-.995c.105-.557-.097-1.185-.582-1.613C18.08 6.182 15.648 4.795 12 4.8c-3.69.005-6.474 1.43-7.953 2.868-.395.383-.55.957-.38 1.532l.298.995c.11.368.505.641.917.6l1.954-.197a.156.156 0 00.064-.015.231.231 0 00.06-.06c.084-.106.183-.307.288-.662a138.653 138.653 0 00.55-1.923l.033-.116c.123-.44.55-.747.748-.846.983-.368 2.003-.676 3.42-.676 1.398 0 2.44.273 3.455.69.182.075.579.341.706.805l.002.009.007.028z"></path></svg>
  `;
  html = `
    <div role="none" style="position: relative; display: flex; flex-direction: row; flex-grow: 0; flex-shrink: 0; overflow: hidden; align-items: center; background: linear-gradient(135deg, rgb(240, 252, 255), rgb(199, 238, 255)) rgb(0, 120, 212); width: 40px; height: 40px; border-radius: 20px; justify-content: center;"><div role="none" aria-hidden="true" style="position: relative; display: flex; flex-direction: column; flex-grow: 0; flex-shrink: 0; overflow: hidden; align-items: stretch; background-color: rgba(0, 0, 0, 0);"><svg width="20" height="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#0090B8" gradientcolor1="#0090B8" gradientcolor2="#0090B8"><path d="M14.75 13.666a2.75 2.75 0 00-2.745-2.745 2.75 2.75 0 00-2.744 2.745 2.75 2.75 0 002.744 2.744 2.75 2.75 0 002.744-2.744zm-4.117 0c0-.761.622-1.373 1.372-1.373.75 0 1.372.612 1.372 1.373 0 .75-.621 1.372-1.372 1.372-.75 0-1.372-.622-1.372-1.372zm7.547-.466a.69.69 0 00-.686.686v4.121a.69.69 0 01-.686.686H7.203a.69.69 0 01-.686-.686v-4.121a.69.69 0 00-.686-.686.69.69 0 00-.686.686v4.121c0 1.136.922 2.058 2.058 2.058h9.605a2.059 2.059 0 002.058-2.058v-4.121a.69.69 0 00-.686-.686z"></path><path d="M12 3.6c3.998-.005 6.703 1.53 8.585 3.192.792.699 1.154 1.75.966 2.736l-.19.995c-.177.932-1.048 1.558-2.036 1.463l-1.965-.19c-.856-.082-1.491-.708-1.76-1.596-.365-1.206-.6-2.1-.6-2.1-.897-.368-1.784-.6-3-.6s-2.085.258-3 .6c0 0-.245.895-.6 2.1-.237.805-.605 1.508-1.444 1.592l-1.953.197c-.975.098-1.91-.522-2.187-1.45l-.297-.996c-.296-.99-.032-2.033.693-2.736C4.922 5.147 8.008 3.605 12 3.6zm4.17 4.232l.03.114.119.43c.103.367.25.884.43 1.476.163.541.466.725.726.75l1.965.19c.415.04.69-.213.743-.493l.19-.995c.105-.557-.097-1.185-.582-1.613C18.08 6.182 15.648 4.795 12 4.8c-3.69.005-6.474 1.43-7.953 2.868-.395.383-.55.957-.38 1.532l.298.995c.11.368.505.641.917.6l1.954-.197a.156.156 0 00.064-.015.231.231 0 00.06-.06c.084-.106.183-.307.288-.662a138.653 138.653 0 00.55-1.923l.033-.116c.123-.44.55-.747.748-.846.983-.368 2.003-.676 3.42-.676 1.398 0 2.44.273 3.455.69.182.075.579.341.706.805l.002.009.007.028z"></path></svg></div></div>  
  `;
  html = `
    <div
      role="none"
      style="
        position: relative;
        display: flex;
        flex-direction: row;
        flex-grow: 0;
        flex-shrink: 0;
        overflow: hidden;
        align-items: center;
        background: linear-gradient(135deg, white, ${colorLight(color, .5)}, ${colorLight(color, .25)});
        width: 40px;
        height: 40px;
        border-radius: 20px;
        justify-content: center;
      "
    >
      <div
        role="none"
        aria-hidden="true"
        style="
          position: relative;
          display: flex;
          flex-direction: column;
          flex-grow: 0;
          flex-shrink: 0;
          overflow: hidden;
          align-items: stretch;
          background-color: rgba(0, 0, 0, 0);
        "
      >
        <svg width="20" height="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="${color}" gradientcolor1="${color}" gradientcolor2="${color}">
          <path
            d="M14.75 13.666a2.75 2.75 0 00-2.745-2.745 2.75 2.75 0 00-2.744 2.745 2.75 2.75 0 002.744 2.744 2.75 2.75 0 002.744-2.744zm-4.117 0c0-.761.622-1.373 1.372-1.373.75 0 1.372.612 1.372 1.373 0 .75-.621 1.372-1.372 1.372-.75 0-1.372-.622-1.372-1.372zm7.547-.466a.69.69 0 00-.686.686v4.121a.69.69 0 01-.686.686H7.203a.69.69 0 01-.686-.686v-4.121a.69.69 0 00-.686-.686.69.69 0 00-.686.686v4.121c0 1.136.922 2.058 2.058 2.058h9.605a2.059 2.059 0 002.058-2.058v-4.121a.69.69 0 00-.686-.686z"
          ></path>
          <path
            d="M12 3.6c3.998-.005 6.703 1.53 8.585 3.192.792.699 1.154 1.75.966 2.736l-.19.995c-.177.932-1.048 1.558-2.036 1.463l-1.965-.19c-.856-.082-1.491-.708-1.76-1.596-.365-1.206-.6-2.1-.6-2.1-.897-.368-1.784-.6-3-.6s-2.085.258-3 .6c0 0-.245.895-.6 2.1-.237.805-.605 1.508-1.444 1.592l-1.953.197c-.975.098-1.91-.522-2.187-1.45l-.297-.996c-.296-.99-.032-2.033.693-2.736C4.922 5.147 8.008 3.605 12 3.6zm4.17 4.232l.03.114.119.43c.103.367.25.884.43 1.476.163.541.466.725.726.75l1.965.19c.415.04.69-.213.743-.493l.19-.995c.105-.557-.097-1.185-.582-1.613C18.08 6.182 15.648 4.795 12 4.8c-3.69.005-6.474 1.43-7.953 2.868-.395.383-.55.957-.38 1.532l.298.995c.11.368.505.641.917.6l1.954-.197a.156.156 0 00.064-.015.231.231 0 00.06-.06c.084-.106.183-.307.288-.662a138.653 138.653 0 00.55-1.923l.033-.116c.123-.44.55-.747.748-.846.983-.368 2.003-.676 3.42-.676 1.398 0 2.44.273 3.455.69.182.075.579.341.706.805l.002.009.007.028z"
          ></path>
        </svg>
      </div>
    </div>
  `;
  return mCreateFrom(html);
}
function get_slot_diff(fen) { return Math.floor(100 / fen.plorder.length); }
function get_splay_number(wsplay) { return wsplay == 'none' ? 0 : wsplay == 'left' ? 1 : wsplay == 'right' ? 2 : wsplay == 'up' ? 3 : 4; }
function get_splay_word(nsplay) { return nsplay == 0 ? 'none' : nsplay == 1 ? 'left' : nsplay == 2 ? 'right' : dsplay == 3 ? 'up' : 'deck'; }
function get_square(board, square) {
  let cells = []
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      if (square == square_coordinates[r][c]) {
        cells.push(board[r][c])
      }
    }
  }
  return cells
}
function get_start_data_fen(players, game) { return players.map(x => `${x}:${get_startlevel(x, game)}:${get_preferred_lang(x)}`).join(','); }
function get_startlevel(user, game) { return lookup(DB.users, [user, 'games', game, 'startlevel']) ?? lookup(DB.games, [game, 'def_startlevel']) ?? 0; }
function get_suitlists_sorted_by_rank(blatt, rankstr = '23456789TJQKA', remove_duplicates = false) {
  let di = {};
  for (const k of blatt) {
    let suit = k[1];
    if (nundef(di[suit])) di[suit] = [];
    if (remove_duplicates) addIf(di[suit], k); else di[suit].push(k);
  }
  for (const s in di) {
    sortByRank(di[s], rankstr);
  }
  return di;
}
function get_tables() { to_server(Session.cur_user, "get_tables"); }
function get_tax_history(tax) {
  let hlines = [];
  console.log('tax', tax);
  for (const uplayer in tax) {
    hlines.push(`player ${uplayer} paid ${tax[uplayer]} in tax`);
  }
  return hlines;
}
function get_texture(name) { return `url(../base/assets/textures/${name}.png)`; }
function get_timestamp() { return Date.now(); }
function get_toolbar(list) {
  if (nundef(list)) list = ['home', 'boa', 'bw', 'authenticator', 'authy', 'onedrive', 'skype'];
  let d = mBy('dTop');
  mFlex(d);
  mStyle(d, { 'justify-content': 'space-between', padding: 10 });
  let dleft = mDiv(d, { display: 'flex', gap: 10 }, 'dTopLeft'); let dright = mDiv(d, { display: 'flex', gap: 10 }, 'dTopRight');
  for (const k of list) {
    let o = DIBOA[k];
    if (nundef(o)) { console.log('missing toolbar item: ' + k); continue; }
    let d1 = o.align == 'left' ? dleft : dright;
    let dsym = mDiv(d1, {}, `tb${k}`, `<a href="javascript:${o.pop ? 'onclick_popup' : 'onclick_location'}('${k}')"><img src="../rechnung/images/${o.img}" height="30"/></a>`);
    if (k == 'bw') {
      mStyle(dsym, { position: 'relative' });
      let elem = mCreateFrom(`<i class="fa fa-car"></i>`);
      mAppend(dsym, elem);
      let offset = 6;
      mStyle(elem, { fg: 'transparent', fz: 10, position: 'absolute', bottom: offset - 1, right: offset + 1 });
      if (!is_bw_loggedin()) toggle_bw_symbol(dsym);
    }
  }
}
function get_trade_history(uplayer, i0, i1) {
  if (i1.path.includes(uplayer)) { let h = i0; i0 = i1; i1 = h; }
  return [`${uplayer} trades ${i0.key} (from own stall) for ${i1.key} (from ${i1.path == 'market' ? 'market' : stringBetween(i1.path, '.', '.')})`];
}
function get_user(name) {
  if (nundef(name)) { get_data(queryStringToJson(), 'user_info'); }
  else { get_data({ user: name }, 'user_info'); }
}
function get_user_color(uname) { let u = firstCond(Serverdata.users, x => x.name == uname); return colorFrom(u.color); }
function get_user_game_tables() { to_server({ uname: Session.cur_user, game: Session.cur_game }, "get_user_game_tables"); }
function get_user_in_intro_screen(username) {
  load_user(username);
  get_dictionary();
  got_user_in_intro_screen();
}
function get_user_names() { return Object.keys(DB.users); }
function get_user_pic(uname, sz = 50, border = 'solid medium white') {
  let html = get_user_pic_html(uname, sz, border);
  return mCreateFrom(html);
}
function get_user_pic_and_name(uname, dParent, sz = 50, border = 'solid medium white') {
  let html = `
      <div username='${uname}' style='text-align:center;font-size:${sz / 2.8}px'>
        <img src='../base/assets/users/${uname}.jpg' width='${sz}' height='${sz}' class='img_person' style='margin:0;border:${border}'>
        <div style='margin-top:${-sz / 6}px'>${uname}</div>
      </div>`;
  let elem = mCreateFrom(html);
  mAppend(dParent, elem);
  return elem;
}
function get_user_pic_html(uname, sz = 50, border = 'solid medium white') {
  return `<img src='../base/assets/users/${uname}.jpg' width='${sz}' height='${sz}' class='img_person' style='margin:0px 4px;border:${border}'>`
}
function get_user_tables() { to_server(Session.cur_user, "get_user_tables"); }
function get_values(o) { return Object.values(o); }
function get_waiting_html(sz = 30) { return `<img src="../base/assets/icons/active_player.gif" height="${sz}" style="margin:0px ${sz / 3}px" />`; }
function get_weekday(date) {
  let d = new Date(date);
  return d.getDay();
}
function get_winnerlist(game) { return lookupSet(DB.games, [game, 'winnerlist'], []); }
function get_with_prob(probs) {
  let sum = arrSum(probs, 'p');
  let r = Math.random() * sum;
  console.log('sum', sum);
  let np = []; let sofar = 0;
  for (const el of probs) {
    sofar += el.p;
    np.push({ val: el.val, p: el.p, akk: sofar });
    if (r <= sofar) return el.val;
  }
  return arrLast(probs.val);
}
function get2Points(v1, v2) {
  let dx = v2.x - v1.x;
  let dy = v2.y - v1.y;
  let alpha;
  if (dx == 1) alpha = dy > 0 ? 270 : 90;
  else alpha = 180 * Math.atan(dy / dx) / Math.PI;
  let beta = (alpha + 90) % 360;
  let stroke = 10;
  let radius = 5;
  let rbeta = beta * Math.PI / 180;
  let x1 = radius * Math.cos(rbeta);
  let y1 = radius * Math.sin(rbeta);
  let x2 = -radius * Math.cos(rbeta);
  let y2 = -radius * Math.sin(rbeta);
  return { p1: { x: x1 + v1.x, y: y1 + v1.y }, p2: { x: x2 + v1.x, y: y2 + v1.y }, p3: { x: x1 + v2.x, y: y1 + v2.y }, p4: { x: x2 + v2.x, y: y2 + v2.y } };
}
function get2Points_mod(v1, v2) {
  let dx = v2.x - v1.x;
  let dy = v2.y - v1.y;
  let alpha;
  if (dx == 1) alpha = dy > 0 ? 270 : 90;
  else alpha = 180 * Math.atan(dy / dx) / Math.PI;
  let beta = (alpha + 90) % 360;
  let stroke = 10;
  let radius = 5;
  let rbeta = beta * Math.PI / 180;
  let x1 = radius * Math.cos(rbeta);
  let y1 = radius * Math.sin(rbeta);
  let x2 = -radius * Math.cos(rbeta);
  let y2 = -radius * Math.sin(rbeta);
  return { p1: { x: x1 + v1.x, y: y1 + v1.y }, p2: { x: x2 + v1.x, y: y2 + v1.y }, p3: { x: x1 + v2.x, y: y1 + v2.y }, p4: { x: x2 + v2.x, y: y2 + v2.y } };
}
function get3ColLine(dParent, idleft, idmiddle, idright, styles = {}) {
  let dOuter = mDiv(dParent);
  let middleStyles = { fz: styles.fz, family: styles.family };
  delete styles.fz; delete styles.family;
  styles = mergeOverride({ wmin: '100%', hmin: 30, vpadding: 4, hpadding: 10, box: true }, styles);
  mStyleX(dOuter, styles);
  let dInner = mDiv(dOuter, { position: 'relative' });
  let l = mDiv(dInner, { family: 'arial', fz: 16, display: 'inline-block', position: 'absolute', wmin: 20 }, idleft)
  let m = mDiv(dInner, { fz: middleStyles.fz, family: middleStyles.family, w: '100%', align: 'center' }, idmiddle);
  let r = mDiv(dInner, { family: 'arial', fz: 16, display: 'inline-block', position: 'absolute', wmin: 20, top: 0, right: 0 }, idright);
  return dOuter;
}
function get3ColLineName(dParent, name, styles = {}) {
  name = 'd' + capitalize(name);
  let dLine = get3ColLine(dParent, name + 'Left', name, name + 'Right', styles);
  return dLine;
}
function get3FractionVariants(fr, sameNum = false, sameDenom = true) {
  let num = fr.n;
  let rnd1 = randomNumber(1, 2);
  let rnd2 = rnd1 + randomNumber(1, 3);
  let rnd3 = rnd2 + randomNumber(1, 5);
  let nums = sameNum ? [num, num, num, num] : [num, num + rnd1, num > 5 ? (num - rnd2) : num + rnd2, num + rnd3];
  let den = fr.d;
  let denoms = sameDenom ? [den, den, den, den] : sameNum ? [den, den + 1, den + 2, den > 2 ? den - 1 : den + 3]
    : [den, den + 1, den + 2, den];
  let frlist = [];
  for (let i = 0; i < 4; i++) {
    frlist.push(math.fraction(nums[i], denoms[i]));
  }
  return frlist;
}
function getActualText(item) {
  if (isdef(item.live.dLabel)) return item.live.dLabel.innerHTML;
}
function getAllItems(cond, keySet = 'all') { return getItems(10000, cond, keySet); }
function getAnimals() {
  let gr = 'Animals & Nature';
  let result = [];
  for (const sg in ByGroupSubgroup[gr]) {
    if (startsWith(sg, 'anim')) result = result.concat(ByGroupSubgroup[gr][sg]);
  }
  return result;
}
function getArea(dParent, styles, id) {
  let defStyles = { display: 'inline-block' };
  styles = mergeOverride(defStyles, styles);
  let d = mDiv(dParent, styles, id);
  return d;
}
function getAreaId(key) { return 'm_A_' + key; }
function getAreaName(id) { return startsWith(id, 'm_A') ? id.substring(4) : id; }
function getAsInt(mobj, styleInfo, prop) {
  let h = styleInfo.getPropertyValue(prop);
  h = trim(h);
  if (h[h.length - 1] == '%') {
    let perc = firstNumber(h);
    let parent = UIS[mobj.idParent];
    h = parent.h * perc / 100;
    h = Math.round(h);
  } else if (h[h.length - 1] == 'x') {
    h = h.substring(0, h.length - 2);
    h = Number(h);
    h = Math.round(h);
  } else if (h == 'auto') {
    h = UIS[mobj.idParent].h;
  }
  return h;
}
function getAux() { return getAuxIds.map(x => UIS[x]); }
function getAuxIds() { return getList(IdOwner.l); }
function getAuxVisuals(id) { return getVisuals(id, 'aux') }
function getAvatar(username) { let d = Avatars[username]; if (nundef(d)) d = makeUserAvatar(username); return d; }
function getBackgroundColor(img, ctx) {
  ctx.drawImage(img, 0, 0);
  var p = ctx.getImageData(1, 1, 1, 1).data;
  let rgb = `rgb(${p[0]},${p[1]},${p[2]})`;
  let color = colorFrom(rgb);
  return color;
}
function getBadgeStyles(sContainer, sPic, sText, w, h, picPercent, paddingTop, paddingBot, family, bg = 'blue', bgPic = 'random', fgPic = 'white', fgText = 'white', hasText = true) {
  let fact = 55 / picPercent;
  let [ptop, pbot] = [(isdef(paddingTop) ? paddingTop : (80 - picPercent) * 3 / 5),
  (isdef(paddingBot) ? paddingBot : (80 - picPercent) * 2 / 5)];
  let pText = 100 - picPercent - ptop - pbot;
  let numbers = hasText ? [fact * ptop, picPercent, 0, fact * pText, fact * pbot] : [15, 70, 0, 0, 15];
  numbers = numbers.map(x => h * x / 100);
  let [patop, szPic, zwischen, szText, pabot] = numbers;
  patop = Math.max(patop, paddingTop);
  pabot = Math.max(pabot, paddingBot);
  fzText = fact * (100 - picPercent - pabot - patop) * h * 3 / 400;
  let styles = { h: h, bg: bg, fg: isdef(fgText) ? fgText : 'contrast', patop: patop, pabottom: pabot, align: 'center', 'box-sizing': 'border-box' };
  let textStyles = { family: family, fz: fzText };
  let picStyles = { h: szPic, bg: bgPic, fg: isdef(fgPic) ? fgPic : 'contrast' };
  if (w > 0) styles.w = w; else styles.paleft = styles.paright = Math.max(padding, 4);
  for (const k in sContainer) { if (k != 'w' && nundef(styles[k])) styles[k] = sContainer[k]; }
  for (const k in sPic) { if (k != 'w' && nundef(picStyles[k])) picStyles[k] = sPic[k]; }
  for (const k in sText) { if (k != 'w' && nundef(textStyles[k])) textStyles[k] = sText[k]; }
  return [styles, picStyles, textStyles];
}
function getBaseLog(x, b) { return Math.log(x) / Math.log(b); }
function getBestMove(game, color, currSum) {
  positionCount = 0;
  var depth = G.searchDepth;
  var d = new Date().getTime();
  var [bestMove, bestMoveValue] = minimax(game, depth, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, true, currSum, color);
  var d2 = new Date().getTime();
  var moveTime = (d2 - d);
  var positionsPerS = (positionCount * 1000 / moveTime);
  return [bestMove, bestMoveValue];
}
function getBestWord(info, lang) {
  let w = info[lang];
  let best = stringAfterLast(w, '|');
  if (isEmpty(best)) best = info.annotation;
  return best;
}
function getBlinkingLetter(item) {
  if (nundef(item.letters)) return null;
  return firstCond(item.letters, x => x.isBlinking);
}
function getBoardBackgroundPicker(b) {
  let palette = getPaletteFromImage(b.img);
  let picker = mColorPicker3(b.d0, palette, c => setLinearBackground(b.d0, c, 10), cornerColor);
  b.colorPicker = picker;
}
function getBoardElementStandardType(mobj) {
  return mobj.isa.corner ? 'corner' : mobj.isa.field ? 'field' : 'edge';
}
function getBoardImagePath(boardFilename) {
  console.assert(boardFilename.includes('.'), 'getImagePath: not a filename!!!', boardFilename)
  return PERLENPATH_FRONT + 'bretter/' + boardFilename;
}
function getBoardMemberColors(board, fieldColor, nodeColor, edgeColor, iPalette, ipals = [3, 4, 5]) {
  let isPalField = nundef(fieldColor) || isNumber(fieldColor) && fieldColor >= 0 && fieldColor <= 8;
  let isPalCorner = isdef(board.structInfo.corners) && (nundef(nodeColor) || isNumber(nodeColor) && nodeColor >= 0 && nodeColor <= 8);
  let isPalEdge = isdef(board.structInfo.edges) && (nundef(edgeColor) || isNumber(edgeColor) && edgeColor >= 0 && edgeColor <= 8);
  if (!iPalette && (isPalField || isPalCorner || isPalEdge)) iPalette = board.getIPalette();
  if (iPalette) {
    board.iPalette = iPalette;
    board.ipal = 2;
    board.structInfo.ipals = ipals;
    let pal = S.pals[iPalette];
    if (isPalField) fieldColor = pal[ipals[0]];
    if (isPalCorner) nodeColor = pal[ipals[1]];
    if (isPalEdge) edgeColor = pal[ipals[2]];
    _register(board, 'paletteUpdates', updateColors);
  }
  return [iPalette, fieldColor, isPalField, nodeColor, isPalCorner, edgeColor, isPalEdge];
}
function getBoardScaleFactors(board, { factors, opt, f2nRatio, w, h, margin } = {}) {
  let [fw, fh, nw, nh, ew] = isdef(factors) ? factors : [43, 50, 12, 12, 10];
  if (startsWith(opt, 'fit')) {
    if (w == 0) {
      let g = document.getElementById(board.id);
      let transinfo = getTransformInfo(g);
      w = transinfo.translateX * 2;
      h = transinfo.translateY * 2;
    }
    let divBy = 2 * (f2nRatio - 2);
    fw = Math.floor((w - margin) / (board.structInfo.w + board.structInfo.wdef / divBy));
    fh = Math.floor((h - margin) / (board.structInfo.h + board.structInfo.hdef / divBy));
    let maintainRatio = (opt[3] == 'R');
    if (maintainRatio) {
      let ff = Math.min(fw, fh);
      fw = ff;
      fh = ff;
    }
    nw = Math.floor(fw / f2nRatio);
    nh = Math.floor(fh / f2nRatio);
  }
  return [fw, fh, nw, nh, ew];
}
function getBoat(idx) { return UIS[getBoatId(idx)]; }
function getBoatId(idx) { return firstCond(getList(IdOwner.a), x => pureId(x) == idx.toString()); }
function getBoatIdByIdx(idx) {
  if (!IdOwner.a || isEmpty(IdOwner.a)) return null;
  if (idx < 0) idx += IdOwner.a.length;
  idx = idx % IdOwner.a.length;
  return IdOwner.a[idx];
}
function getBoatIds() { return getList(IdOwner.a); }
function getBoats() { return getBoatIds().map(x => UIS[x]); }
function getBoatWith(lst, isGood = true) {
  let boats = getBoats();
  if (!isGood) {
    let goodBoats = [];
    for (const b of boats) {
      if (isEmpty(lst.filter(x => b.o.text.includes(x)))) goodBoats.push(b);
    }
    return goodBoats.length > 0 ? chooseRandom(goodBoats) : null;
  } else {
    for (const b of boats) {
      if (!isEmpty(lst.filter(x => b.o.text.includes(x)))) return b;
    }
  }
  return null;
}
function getBorderPropertyForDirection(dir) { return { 0: 'border-top', 1: 'border-right', 2: 'border-bottom', 3: 'border-left' }[dir]; }
function getBounds(elem, relToParent = false, relativeToElem) {
  if (isString(elem)) elem = document.getElementById(elem);
  if (relToParent) return getRelBounds(elem, getParent(elem));
  else if (isdef(relativeToElem)) return getRelBounds(elem, relativeToElem);
  else return elem.getBoundingClientRect();
}
function getBrightness(c) {
  function luminance(r, g, b) {
    var a = [r, g, b].map(function (v) {
      v /= 255;
      return v <= 0.03928
        ? v / 12.92
        : Math.pow((v + 0.055) / 1.055, 2.4);
    });
    return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;
  }
  let x = colorRGB(c, true);
  return luminance(x.r, x.g, x.b);
}
function getC52Key(i) {
  if (i > 52) return 'card_J1';
  let rank = getC52Rank(i);
  let suit = getC52Suit(i);
  return 'card_' + rank + suit;
}
function getC52Rank(i) {
  let rank = 1 + (i % 13);
  if (rank == 1) rank = 'A';
  else if (rank >= 10) rank = ['T', 'J', 'Q', 'K'][rank - 10];
  return rank;
}
function getC52Suit(i) {
  return ['S', 'H', 'D', 'C'][divInt(i, 13)];
}
function getCanvasPixelColor(c, x, y) {
  var coord = "x=" + x + ", y=" + y;
  var p = c.getImageData(x, y, 1, 1).data;
  var hex = "#" + ("000000" + rgbToHex(p[0], p[1], p[2])).slice(-6);
  console.log('pixel', coord, 'has color', hex);
}
function getCaretCoordinates(element, position, options) {
  var properties = [
    'direction',
    'boxSizing',
    'width',
    'height',
    'overflowX',
    'overflowY',
    'borderTopWidth',
    'borderRightWidth',
    'borderBottomWidth',
    'borderLeftWidth',
    'borderStyle',
    'paddingTop',
    'paddingRight',
    'paddingBottom',
    'paddingLeft',
    'fontStyle',
    'fontVariant',
    'fontWeight',
    'fontStretch',
    'fontSize',
    'fontSizeAdjust',
    'lineHeight',
    'fontFamily',
    'textAlign',
    'textTransform',
    'textIndent',
    'textDecoration',
    'letterSpacing',
    'wordSpacing',
    'tabSize',
    'MozTabSize'
  ];
  var isBrowser = (typeof window !== 'undefined');
  var isFirefox = (isBrowser && window.mozInnerScreenX != null);
  if (!isBrowser) {
    throw new Error('textarea-caret-position#getCaretCoordinates should only be called in a browser');
  }
  var debug = options && options.debug || false;
  if (debug) {
    var el = document.querySelector('#input-textarea-caret-position-mirror-div');
    if (el) el.parentNode.removeChild(el);
  }
  var div = document.createElement('div');
  div.id = 'input-textarea-caret-position-mirror-div';
  document.body.appendChild(div);
  var style = div.style;
  var computed = window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle;
  var isInput = element.nodeName === 'INPUT';
  style.whiteSpace = 'pre-wrap';
  if (!isInput) style.wordWrap = 'break-word';
  style.position = 'absolute';
  if (!debug) style.visibility = 'hidden';
  properties.forEach(prop => {
    if (isInput && prop === 'lineHeight') {
      if (computed.boxSizing === "border-box") {
        var height = parseInt(computed.height);
        var outerHeight =
          parseInt(computed.paddingTop) +
          parseInt(computed.paddingBottom) +
          parseInt(computed.borderTopWidth) +
          parseInt(computed.borderBottomWidth);
        var targetHeight = outerHeight + parseInt(computed.lineHeight);
        if (height > targetHeight) {
          style.lineHeight = height - outerHeight + "px";
        } else if (height === targetHeight) {
          style.lineHeight = computed.lineHeight;
        } else {
          style.lineHeight = 0;
        }
      } else {
        style.lineHeight = computed.height;
      }
    } else {
      style[prop] = computed[prop];
    }
  });
  if (isFirefox) {
    if (element.scrollHeight > parseInt(computed.height))
      style.overflowY = 'scroll';
  } else {
    style.overflow = 'hidden';
  }
  div.textContent = element.value.substring(0, position);
  if (isInput)
    div.textContent = div.textContent.replace(/\s/g, '\u00a0');
  var span = document.createElement('span');
  span.textContent = element.value.substring(position) || '.';
  div.appendChild(span);
  var coordinates = {
    top: span.offsetTop + parseInt(computed['borderTopWidth']),
    left: span.offsetLeft + parseInt(computed['borderLeftWidth']),
    height: parseInt(computed['lineHeight'])
  };
  if (debug) {
    span.style.backgroundColor = '#aaa';
  } else {
    document.body.removeChild(div);
  }
  return coordinates;
}
function getCenter(elem) { let r = isdef(elem.x) ? elem : getRect(elem); return { x: (r.w) / 2, y: (r.h) / 2 }; }
function getCenters(layout, rows, cols, wCell, hCell,) {
  if (layout == 'quad') { return quadCenters(rows, cols, wCell, hCell); }
  else if (layout == 'hex') { return hexCenters(rows, cols, wCell, hCell); }
  else if (layout == 'circle') { return circleCenters(rows, cols, wCell, hCell); }
}
function getCentersFromAreaSize(layout, wBoard, hBoard, wCell, hCell) {
  let info;
  if (layout == 'quad') { info = quadCenters(rows, cols, wCell, hCell); }
  else if (layout == 'hex') { info = hexCenters(rows, cols, wCell, hCell); }
  else if (layout == 'hex1') { info = hex1Centers(rows, cols, wCell, hCell); }
  else if (layout == 'circle') { info = circleCenters(rows, cols, wCell, hCell); }
  return info;
}
function getCentersFromRowsCols(layout, rows, cols, wCell, hCell) {
  let info;
  if (layout == 'quad') { info = quadCenters(rows, cols, wCell, hCell); }
  else if (layout == 'hex') { info = hexCenters(rows, cols, wCell, hCell); }
  else if (layout == 'hex1') { info = hex1Centers(rows, cols, wCell, hCell); }
  else if (layout == 'circle') { info = circleCenters(rows, cols, wCell, hCell); }
  return info;
}
function getChildren(elem) { return [...elem.children]; }
function getCirclePoints(rad, n, disp = 0) {
  let pts = [];
  let i = 0;
  let da = 360 / n;
  let angle = disp;
  while (i < n) {
    let px = rad * Math.cos(toRadian(angle));
    let py = rad * Math.sin(toRadian(angle));
    pts.push({ X: px, Y: py });
    angle += da;
    i++;
  }
  return pts;
}
function getClass(el) { return el.classList.value; }
function getClassG(el) { return el.getAttribute('class'); }
function getCollectionArea(key, msParentArea) {
  let a = UIS[getIdArea(key)];
  if (nundef(a)) {
    a = makeCollectionArea(key, msParentArea.id);
  }
  let idHand = a.id;
  return idHand;
}
function getCollections(oid, propName) { return isdef(propName) ? lookup(collections, [oid, propName]) : collections[oid]; }
function getColorDictColor(c) { return isdef(ColorDict[c]) ? ColorDict[c].c : c; }
function getColorHexes(x) {
  return [
    'f0f8ff',
    'faebd7',
    '00ffff',
    '7fffd4',
    'f0ffff',
    'f5f5dc',
    'ffe4c4',
    '000000',
    'ffebcd',
    '0000ff',
    '8a2be2',
    'a52a2a',
    'deb887',
    '5f9ea0',
    '7fff00',
    'd2691e',
    'ff7f50',
    '6495ed',
    'fff8dc',
    'dc143c',
    '00ffff',
    '00008b',
    '008b8b',
    'b8860b',
    'a9a9a9',
    'a9a9a9',
    '006400',
    'bdb76b',
    '8b008b',
    '556b2f',
    'ff8c00',
    '9932cc',
    '8b0000',
    'e9967a',
    '8fbc8f',
    '483d8b',
    '2f4f4f',
    '2f4f4f',
    '00ced1',
    '9400d3',
    'ff1493',
    '00bfff',
    '696969',
    '696969',
    '1e90ff',
    'b22222',
    'fffaf0',
    '228b22',
    'ff00ff',
    'dcdcdc',
    'f8f8ff',
    'ffd700',
    'daa520',
    '808080',
    '808080',
    '008000',
    'adff2f',
    'f0fff0',
    'ff69b4',
    'cd5c5c',
    '4b0082',
    'fffff0',
    'f0e68c',
    'e6e6fa',
    'fff0f5',
    '7cfc00',
    'fffacd',
    'add8e6',
    'f08080',
    'e0ffff',
    'fafad2',
    'd3d3d3',
    'd3d3d3',
    '90ee90',
    'ffb6c1',
    'ffa07a',
    '20b2aa',
    '87cefa',
    '778899',
    '778899',
    'b0c4de',
    'ffffe0',
    '00ff00',
    '32cd32',
    'faf0e6',
    'ff00ff',
    '800000',
    '66cdaa',
    '0000cd',
    'ba55d3',
    '9370db',
    '3cb371',
    '7b68ee',
    '00fa9a',
    '48d1cc',
    'c71585',
    '191970',
    'f5fffa',
    'ffe4e1',
    'ffe4b5',
    'ffdead',
    '000080',
    'fdf5e6',
    '808000',
    '6b8e23',
    'ffa500',
    'ff4500',
    'da70d6',
    'eee8aa',
    '98fb98',
    'afeeee',
    'db7093',
    'ffefd5',
    'ffdab9',
    'cd853f',
    'ffc0cb',
    'dda0dd',
    'b0e0e6',
    '800080',
    '663399',
    'ff0000',
    'bc8f8f',
    '4169e1',
    '8b4513',
    'fa8072',
    'f4a460',
    '2e8b57',
    'fff5ee',
    'a0522d',
    'c0c0c0',
    '87ceeb',
    '6a5acd',
    '708090',
    '708090',
    'fffafa',
    '00ff7f',
    '4682b4',
    'd2b48c',
    '008080',
    'd8bfd8',
    'ff6347',
    '40e0d0',
    'ee82ee',
    'f5deb3',
    'ffffff',
    'f5f5f5',
    'ffff00',
    '9acd32'
  ];
}
function getColorHint(o) {
  for (const k in o) {
    if (k.toLowerCase() == 'color') return o[k];
    if (isDict(o[k]) && isdef(o[k]._player)) return getPlayerColor(o[k]._player);
  }
  return null;
}
function getColorLabelInstruction(cmd, color, label) {
  if (nundef(color)) color = Goal.color;
  let colorWord = color[G.language];
  let colorSpan = `<span style='color:${color.c}'>${colorWord.toUpperCase()}</span>`;
  if (nundef(label)) label = Goal.label;
  let labelSpan = `<b>${label.toUpperCase()}</b>`;
  let eCommand, dCommand;
  switch (cmd) {
    case 'click': eCommand = cmd + ' the'; dCommand = cmd; break
    case 'then': eCommand = cmd + ' the'; dCommand = 'dann'; break
  }
  let eInstr = `${eCommand} ${colorWord} ${label}`;
  let dInstr = `${dCommand} ${label} in ${colorWord}`;
  let spoken = G.language == 'E' ? eInstr : dInstr;
  let written = spoken.replace(colorWord, colorSpan).replace(label, labelSpan);
  console.log('spoken', spoken, 'written', written);
  return [written, spoken];
}
function getColorNames() {
  return [
    'AliceBlue',
    'AntiqueWhite',
    'Aqua',
    'Aquamarine',
    'Azure',
    'Beige',
    'Bisque',
    'Black',
    'BlanchedAlmond',
    'Blue',
    'BlueViolet',
    'Brown',
    'BurlyWood',
    'CadetBlue',
    'Chartreuse',
    'Chocolate',
    'Coral',
    'CornflowerBlue',
    'Cornsilk',
    'Crimson',
    'Cyan',
    'DarkBlue',
    'DarkCyan',
    'DarkGoldenRod',
    'DarkGray',
    'DarkGrey',
    'DarkGreen',
    'DarkKhaki',
    'DarkMagenta',
    'DarkOliveGreen',
    'DarkOrange',
    'DarkOrchid',
    'DarkRed',
    'DarkSalmon',
    'DarkSeaGreen',
    'DarkSlateBlue',
    'DarkSlateGray',
    'DarkSlateGrey',
    'DarkTurquoise',
    'DarkViolet',
    'DeepPink',
    'DeepSkyBlue',
    'DimGray',
    'DimGrey',
    'DodgerBlue',
    'FireBrick',
    'FloralWhite',
    'ForestGreen',
    'Fuchsia',
    'Gainsboro',
    'GhostWhite',
    'Gold',
    'GoldenRod',
    'Gray',
    'Grey',
    'Green',
    'GreenYellow',
    'HoneyDew',
    'HotPink',
    'IndianRed',
    'Indigo',
    'Ivory',
    'Khaki',
    'Lavender',
    'LavenderBlush',
    'LawnGreen',
    'LemonChiffon',
    'LightBlue',
    'LightCoral',
    'LightCyan',
    'LightGoldenRodYellow',
    'LightGray',
    'LightGrey',
    'LightGreen',
    'LightPink',
    'LightSalmon',
    'LightSeaGreen',
    'LightSkyBlue',
    'LightSlateGray',
    'LightSlateGrey',
    'LightSteelBlue',
    'LightYellow',
    'Lime',
    'LimeGreen',
    'Linen',
    'Magenta',
    'Maroon',
    'MediumAquaMarine',
    'MediumBlue',
    'MediumOrchid',
    'MediumPurple',
    'MediumSeaGreen',
    'MediumSlateBlue',
    'MediumSpringGreen',
    'MediumTurquoise',
    'MediumVioletRed',
    'MidnightBlue',
    'MintCream',
    'MistyRose',
    'Moccasin',
    'NavajoWhite',
    'Navy',
    'OldLace',
    'Olive',
    'OliveDrab',
    'Orange',
    'OrangeRed',
    'Orchid',
    'PaleGoldenRod',
    'PaleGreen',
    'PaleTurquoise',
    'PaleVioletRed',
    'PapayaWhip',
    'PeachPuff',
    'Peru',
    'Pink',
    'Plum',
    'PowderBlue',
    'Purple',
    'RebeccaPurple',
    'Red',
    'RosyBrown',
    'RoyalBlue',
    'SaddleBrown',
    'Salmon',
    'SandyBrown',
    'SeaGreen',
    'SeaShell',
    'Sienna',
    'Silver',
    'SkyBlue',
    'SlateBlue',
    'SlateGray',
    'SlateGrey',
    'Snow',
    'SpringGreen',
    'SteelBlue',
    'Tan',
    'Teal',
    'Thistle',
    'Tomato',
    'Turquoise',
    'Violet',
    'Wheat',
    'White',
    'WhiteSmoke',
    'Yellow',
    'YellowGreen'
  ];
}
function getColors(n = 3) {
  let key = chooseRandom(Object.keys(modern_palettes));
  let colors = Object.values(modern_palettes[key]);
  colors = choose(colors, n);
  shuffle(colors);
  console.log('*** new palette:', key, 'colors:', colors.toString())
  return colors;
}
function getColorWheel(contrastTo, n) {
  let hc = colorHue(contrastTo);
  let wheel = [];
  let start = hc;
  let inc = Math.round(360 / (n + 1));
  start += inc;
  for (let i = 0; i < n; i++) {
    wheel.push(start % 360);
    start += inc;
  }
  return wheel.map(x => colorHSLBuild(x));
}
function getCombNodeName(namelist) {
  return namelist.join('_');
}
function getConsonants(w, except = []) {
  w = w.toLowerCase();
  let vowels = 'aeiouy' + except.join('');
  let res = [];
  for (let i = 0; i < w.length; i++) {
    if (!vowels.includes(w[i])) res.push({ i: i, letter: w[i] });
  }
  return res;
}
function getContrast(rgb1, rgb2) {
  var lum1 = luminance(rgb1[0], rgb1[1], rgb1[2]);
  var lum2 = luminance(rgb2[0], rgb2[1], rgb2[2]);
  var brightest = Math.max(lum1, lum2);
  var darkest = Math.min(lum1, lum2);
  return (brightest + 0.05)
    / (darkest + 0.05);
}
function getContrastingHue(contrastColor, minDiff = 25, mod = 30) {
  let hc = colorHue(contrastColor);
  let rnd1 = randomNumber(0, 360);
  let d = Math.floor(rnd1 / mod);
  let rnd = d * mod;
  let diff = Math.abs(rnd - hc);
  if (diff < minDiff) rnd = (rnd + 180) % 360;
  return rnd;
}
function getContrastingHueX(contrastColor, minDiff = 25, mod = 30, startWheel = 0) {
  let wheel = getHueWheel(contrastColor, minDiff, mod, startWheel);
  return chooseRandom(wheel);
}
function getCornerPixelColor(img) {
  let canvas = mCreate('canvas');
  let ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);
  var p = ctx.getImageData(1, 1, 1, 1).data;
  let rgb = `rgb(${p[0]},${p[1]},${p[2]})`;
  let x = 1, y = 1;
  var coord = "x=" + x + ", y=" + y;
  let color = colorFrom(rgb);
  return color;
}
function getCornerRooms(house) {
  let rooms = house.rooms.map(x => Items[x]);
  let result = [];
  for (const r of rooms) {
    if (isCornerRoom(house, r)) {
      result.push(r.id);
    }
  }
  return result;
}
function getCornerRoomsDict(house) {
  let rooms = house.rooms.map(x => Items[x]);
  let result = {};
  for (const r of rooms) {
    let isN = r.isN = isNorthRoom(house, r);
    let isS = r.isS = isSouthRoom(house, r);
    let isW = r.isW = isWestRoom(house, r);
    let isE = r.isE = isEastRoom(house, r);
    if (isN && isW) result.NW = r.id;
    else if (isN && isE) result.NE = r.id;
    else if (isS && isE) result.SE = r.id;
    else if (isS && isW) result.SW = r.id;
  }
  return result;
}
function getCorners(board, func) {
  let fids = board.strInfo.corners;
  let res = [];
  for (const id of board.strInfo.corners) {
    if (func(G.table[id]) || func(getVisual(id))) {
      let o = getVisual(id);
      for (const prop in G.table[id]) {
        o[prop] = G.table[id][prop];
      }
      res.push(o);
    }
  }
  return res;
}
function getCornerVertices(centers, w = 100, h = 100) {
  let polys = [];
  for (const pt of centers) {
    let poly = getHexPoly(pt.x, pt.y, w, h);
    polys.push(poly);
  }
  let vertices = correctPolys(polys, 1);
  return vertices;
}
function getCorrectlyAnsweredWords() { return getQWords().filter(x => getInputStringOfWord(x) == x.word); }
function getCorrectPrefix(label, text) {
  let req = label.toLowerCase();
  let answer = text.toLowerCase();
  let res1 = removeNonAlphanum(req);
  let res2 = removeNonAlphanum(answer);
  let req1 = res1.alphas;
  let answer1 = res2.alphas;
  let whites = res1.whites;
  let common = findCommonPrefix(req1, answer1);
  let nletters = common.length;
  let ireal = 0;
  let icompact = 0;
  let iwhites = 0;
  let correctPrefix = '';
  while (icompact < nletters) {
    if (req[ireal] == common[icompact]) { correctPrefix += label[ireal]; icompact += 1; }
    else if (whites[iwhites] == req[ireal]) { correctPrefix += label[ireal]; iwhites += 1; }
    else break;
    ireal += 1;
  }
  return correctPrefix;
}
function getCorrectWords() { return Goal.seq; }
function getCorrectWordString(sep = ' ') { return getCorrectWords().join(sep); }
function getCssVar(varname) { return getComputedStyle(document.body).getPropertyValue(varname); }
function getCSSVariable(varname) { return getCssVar(varname); }
function getCurrentFileName() {
  let currentFilePath = document.scripts[document.scripts.length - 1].src;
  let fileName = currentFilePath.split('/').pop();
  return fileName;
}
function getDefaultObjectIds() { return _getChildrenOf(S.settings.table.defaultArea); }
function getDefaultObjects() { return getDefaultObjectIds(x => UIS[x]); }
function getDefaultPlayerIds() { return _getChildrenOf(S.settings.player.defaultArea); }
function getDefaultPlayers() { return getDefaultPlayerIds(x => UIS[x]); }
function getDefaultVisual(oid) { return UIS[getDefId(oid)]; }
function getDefId(oid) { return firstCond(oid2ids[oid], x => x[0] == 'd'); }
function getDefVisual(oid) { return UIS[getDefId(oid)]; }
function getDiagonallyOpposedCornerRooms(house) {
  if (coin()) return [getRoomNW(house), getRoomSE(house)]; else return [getRoomSW(house), getRoomNE(house)];
}
function getDiagRoomPairs(house) {
  return [[getRoomNW(house), getRoomSE(house)], [getRoomSW(house), getRoomNE(house)]];
}
function getDirList() {
  let dirlist = [
    'C:\\DATA\\dev\\js\\02harris\\_global',
    'C:\\DATA\\dev\\js\\02harris\\manyCars',
    'C:\\DATA\\dev\\js\\02harris\\wipgame',
    'C:\\DATA\\dev\\js\\02harris\\ch9',
    'C:\\DATA\\dev\\js\\03seidlin\\ch12\\scripts',
    'C:\\DATA\\dev\\js\\06verou',
    'C:\\DATA\\dev\\js\\07joeames\\js',
    'C:\\DATA\\dev\\js\\08cardGame1\\script',
    'C:\\DATA\\dev\\js\\16kaefer\\js',
    'C:\\DATA\\dev\\js\\19lifeGame\\version1',
    'C:\\DATA\\dev\\js\\20testPongApp',
    'C:\\DATA\\dev\\js\\23Animations_CSS_JS\\_my\\clock\\js',
    'C:\\DATA\\dev\\js\\23Animations_CSS_JS\\_my\\learning\\final\\js',
    'C:\\DATA\\dev\\js\\24memory',
    'C:\\DATA\\dev\\js\\25nnImage\\scripts',
    'C:\\DATA\\dev\\js\\26udaCanvas',
    'C:\\DATA\\dev\\js\\28cards\\test02',
    'C:\\DATA\\dev\\js\\31p0',
    'C:\\DATA\\dev\\js\\32t0\\grid',
    'C:\\DATA\\dev\\js\\33cardGameStarter',
    'C:\\DATA\\dev\\js\\40cardSolitaire\\cg01',
    'C:\\DATA\\dev\\js\\42deckOfCards\\test02',
    'C:\\DATA\\dev_2020\\CBII\\zLastVid\\work2',
    'C:\\DATA\\dev_2020\\CBII\\zLastVid\\work',
    'C:\\DATA\\dev_2020\\CBII\\zLastVid\\wCOMMON\\js',
    'C:\\DATA\\dev_2020\\CBII\\zLastVid\\wCOMMON\\js\\rsgTypes',
    'C:\\DATA\\dev_2020\\CBII\\zLastVid\\vid2\\js',
    'C:\\DATA\\dev_2020\\CBII\\zLastVid\\vid2\\rsg',
    'C:\\DATA\\dev_2020\\CBII\\zLastVid\\vid0\\static\\front\\js',
    'C:\\DATA\\dev_2020\\CBII\\zLastVid\\vid0\\static\\rsg\\js',
    'C:\\DATA\\dev_2020\\CODEBASE\\tnt_code\\_front\\asimple\\js',
    'C:\\DATA\\dev_2020\\CODEBASE\\tnt_code\\_front\\front_console\\js',
    'C:\\DATA\\dev_2020\\CODEBASE\\okt21\\static\\js',
    'C:\\DATA\\dev_2020\\CODEBASE\\work\\nov08\\js',
    'C:\\Users\\tawzz\\OneDrive\\dev\\CODEBASE\\rsg93\\static\\js',
    'C:\\Users\\tawzz\\OneDrive\\dev\\CODEBASE\\okt21\\static\\js',
    'C:\\Users\\tawzz\\OneDrive\\dev\\CBII\\CODE_SAFE\\CODE\\js',
    'C:\\Users\\tawzz\\OneDrive\\dev\\CODEBASE\\gsm2_tictactoe\\js',
    'C:\\Users\\tawzz\\OneDrive\\dev\\CODEBASE\\tnt_code\\_front\\asimple\\js',
    'C:\\Users\\tawzz\\OneDrive\\dev\\CODEBASE\\tntCode\\js',
    'C:\\D\\a00\\git_archive\\testing\\BASE\\features',
    'C:\\D\\a00\\git_archive\\testing\\BASE',
    'C:\\D\\a00\\git_archive\\test01\\public\\BASE',
    'C:\\D\\a00\\git_archive\\test01\\public\\t99',
    'C:\\D\\a00\\FLASK\\step4\\base\\js',
    'C:\\D\\a00\\FLASK\\step4\\base\\features',
    'C:\\D\\a00\\git_archive\\vid_old\\static\\rsg\\js',
    'C:\\D\\a00\\git_archive\\vid_old\\static\\front\\js',
    'C:\\D\\a00\\git_archive\\vid\\frontend\\static\\rsg\\js',
    'C:\\D\\a00\\git_archive\\vid\\frontend\\static\\front\\js',
    'C:\\D\\a00\\git_archive\\gsmTester\\C',
    'C:\\D\\a00\\git_archive\\gsmTester\\DIE',
    'C:\\D\\a00\\git_archive\\gsmTester\\DOC',
    'C:\\D\\a00\\git_archive\\gsmTester\\RSG\\js\\done',
    'C:\\D\\a00\\git_archive\\gsmTester\\RSG\\js\\measureArrange',
    'C:\\D\\a00\\git_archive\\gsmTester\\RSG\\js\\R',
    'C:\\D\\a00\\git_archive\\gsmTester\\RSG\\js\\testing',
    'C:\\D\\a00\\git_archive\\gsmTester\\RSG\\js\\types',
    'C:\\D\\a00\\git_archive\\gsmTester\\RSG\\js\\uiCreation',
    'C:\\D\\a00\\git_archive\\gsmTester\\RSG\\js',
    'C:\\D\\a00\\git_archive\\gsmTester\\SPGAME',
    'C:\\D\\a00\\git_archive\\gsmTester\\SPNEW',
    'C:\\D\\a00\\git_archive\\cardTests\\_test\\ex03',
    'C:\\D\\a00\\git_archive\\cardTests\\simple01',
    'C:\\D\\a00\\git_archive\\cardTests\\ex06_fromScratch',
    'C:\\D\\a00\\git_archive\\eximple\\static',
    'C:\\D\\a00\\git_archive\\eximple\\static\\games',
    'C:\\D\\a00\\git_archive\\dycon_ui_test\\base\\js',
    'C:\\D\\a00\\git_archive\\course-player-socketio\\public\\t99',
    'C:\\D\\a00\\git_archive\\asstest\\CODE',
    'C:\\D\\a00\\git_archive\\asstest\\SIMPLE',
    'C:\\D\\a00\\git_archive\\animaludos\\public\\work',
    'C:\\D\\a00\\git_archive\\animaludos\\public\\work\\done',
    'C:\\D\\a00\\git_archive\\also\\MZZ',
    'C:\\D\\a00\\git_archive\\also\\BASE',
    'C:\\D\\a00\\git_archive\\also\\BASE\\features',
    'C:\\D\\a00\\git_archive\\animaludos\\public',
    'C:\\D\\a00\\git_archive\\animaludos\\public\\BASE',
    'C:\\D\\a00\\git_archive\\animaludos\\public\\BASE\\features',
    'C:\\D\\a00\\git_archive\\abra',
    'C:\\D\\a00\\hive\\hive',
    'C:\\D\\a00\\TESTING\\base\\js',
    'C:\\D\\a00\\TESTING\\cosensus',
    'C:\\D\\a00\\TESTING\\easy',
    'C:\\D\\a00\\TESTING\\feedback',
    'C:\\D\\a00\\TESTING\\games',
    'C:\\D\\a00\\TESTING\\index_palette',
    'C:\\D\\a00\\videmo\\frontend\\static\\front\\js',
    'C:\\D\\a00\\videmo\\frontend\\static\\rsg\\js',
    'C:\\D\\a00\\videmo\\games\\catan\\_rsg',
    'C:\\D\\a00\\videmo\\games\\ttt\\_rsg',
    'C:\\D\\a00\\vid\\vid0\\static\\front\\js',
    'C:\\D\\a00\\vid\\vid0\\static\\rsg\\js',
    'C:\\D\\a00\\vid\\work2',
    'C:\\D\\a00\\vid\\wCOMMON\\js\\rsgTypes',
    'C:\\D\\a00\\vid\\wCOMMON\\js',
    'C:\\D\\a00\\vid\\vid2\\js',
    'C:\\D\\a00\\vid\\vid2\\rsg',
    'C:\\D\\a01\\chatApp\\public\\BASE',
    'C:\\D\\a01\\chatApp\\public\\BASE\\features',
    'C:\\D\\a01\\chatApp\\public\\work',
    'C:\\D\\a01\\chatApp\\public\\work\\done',
    'C:\\D\\a01\\chatApp\\public',
    'C:\\D\\a01\\chess',
    'C:\\xampp\\htdocs\\aroot\\_other\\perlen\\work\\done',
    'C:\\xampp\\htdocs\\aroot\\_other\\perlen\\work',
    'C:\\xampp\\htdocs\\aroot\\_other\\perlen',
    'C:\\xampp\\htdocs\\aroot\\_other\\bella\\js',
    'C:\\xampp\\htdocs\\aroot\\_other\\bg\\js',
    'C:\\xampp\\htdocs\\aroot\\_other\\bg4\\js',
    'C:\\xampp\\htdocs\\aroot\\_other\\canyonglen',
    'C:\\xampp\\htdocs\\aroot\\_other\\cards',
    'C:\\xampp\\htdocs\\aroot\\_other\\caristo',
    'C:\\xampp\\htdocs\\aroot\\_other\\chatas\\js',
    'C:\\xampp\\htdocs\\aroot\\_other\\chatas2',
    'C:\\xampp\\htdocs\\aroot\\_other\\chmultOrig\\js',
    'C:\\xampp\\htdocs\\aroot\\_other\\feedback',
    'C:\\xampp\\htdocs\\aroot\\_other\\frontend',
    'C:\\xampp\\htdocs\\aroot\\_other\\happy',
    'C:\\xampp\\htdocs\\aroot\\_other\\hive',
    'C:\\xampp\\htdocs\\aroot\\_other\\klavier',
    'C:\\xampp\\htdocs\\aroot\\_other\\phpchat\\public\\socket.io-client\\lib',
    'C:\\xampp\\htdocs\\aroot\\_other\\simply\\js',
    'C:\\xampp\\htdocs\\aroot\\_other\\v0_chatas',
    'C:\\xampp\\htdocs\\aroot\\base\\js',
    'C:\\xampp\\htdocs\\aroot\\base\\code',
    'C:\\xampp\\htdocs\\aroot\\belinda\\js',
    'C:\\xampp\\htdocs\\aroot\\belinda\\features',
    'C:\\xampp\\htdocs\\aroot\\cosensus',
    'C:\\xampp\\htdocs\\aroot\\easy',
    'C:\\xampp\\htdocs\\aroot\\iconViewer\\js',
    'C:\\xampp\\htdocs\\aroot\\rechnung',
    'C:\\xampp\\htdocs\\aroot\\simple',
    'C:\\xampp\\htdocs\\aroot\\videos\\js',
    'C:\\D\\a03\\nodemaster\\all\\caba',
    'C:\\D\\a03\\nodemaster\\all\\canvas\\lib',
    'C:\\D\\a03\\nodemaster\\all\\canvas\\noc',
    'C:\\D\\a03\\nodemaster\\all\\canvas\\smooth',
    'C:\\D\\a03\\nodemaster\\all\\cita',
    'C:\\D\\a03\\nodemaster\\all\\coding\\public\\javascripts',
    'C:\\D\\a03\\nodemaster\\all\\favicontester',
    'C:\\D\\a03\\nodemaster\\all\\fileupload\\public',
    'C:\\D\\a03\\nodemaster\\all\\fractals\\nature',
    'C:\\D\\a03\\nodemaster\\all\\fractals\\nn\\031_FlappyBird\\P5',
    'C:\\D\\a03\\nodemaster\\all\\fractals\\plant',
    'C:\\D\\a03\\nodemaster\\all\\fractals\\tree',
    'C:\\D\\a03\\nodemaster\\all\\leaflet\\leaf',
    'C:\\D\\a03\\nodemaster\\all\\leaflet\\leaf90',
    'C:\\D\\a03\\nodemaster\\all\\leaflet\\leaf91',
    'C:\\D\\a03\\nodemaster\\all\\leaflet\\leafp',
    'C:\\D\\a03\\nodemaster\\all\\leaflet\\leaf94',
    'C:\\D\\a03\\nodemaster\\all\\leaflet\\leafstreetview',
    'C:\\D\\a03\\nodemaster\\all\\leaflet\\mapgame',
    'C:\\D\\a03\\nodemaster\\all\\leaflet\\routing',
    'C:\\D\\a03\\nodemaster\\all\\mybrary\\public\\javascripts',
    'C:\\D\\a03\\nodemaster\\all\\openlayers\\map',
    'C:\\D\\a03\\nodemaster\\all\\openlayers\\mapTEXT',
    'C:\\xampp\\htdocs\\aroot\\games',
    'C:\\D\\a03\\nodemaster\\basejs',
    'C:\\D\\a03\\nodemaster\\cai',
    'C:\\D\\a03\\nodemaster\\noc',
    'C:\\D\\a03\\nodemaster\\socketstarter',
    'C:\\D\\a04\\basejs',
    'C:\\D\\a04\\game',
  ];
}
function getDistinctVals(list, prop) {
  let res = [];
  for (const item of list) {
    let val = item[prop];
    addIf(res, val);
  }
  return res;
}
function getDivisors(n) {
  let x = Math.floor(Math.sqrt(n));
  let res = [];
  for (let i = 2; i <= x; i++) {
    let q = n / i;
    if (q == Math.round(q)) res.push(i);
  }
  return res;
}
function getDoorId(r1, r2) { return r1 + '_' + r2 + '_' + r1; }
function getDraggedElem(ev) {
  console.log(ev)
  if (isdef(ev.dataTransfer)) return document.getElementById(ev.dataTransfer.getData("text"));
  return null;
}
function getDynamicBaseArea(info, oid) {
  let loc = info.loc;
  let areaName = getDynId(info.loc, oid);
  if (!AREAS[areaName]) {
    let uiNode = AREAS[loc];
    let group = info.pool;
    prepParentForChildren(loc, group.length);
    for (const oid of group) {
      addPanel(loc, oid);
    }
  }
  return areaName;
}
function getDynId(loc, oid) { return loc + '@' + oid; }
function getEdgeCorners(o) {
  let cornerIds = o.corners.map(x => x._obj);
  return cornerIds.map(x => isdef(x) ? G.table[x] : x);
}
function getElementLists(o, elKey = '_obj', arrKey = '_set') {
  let res = {};
  if (!o) return [];
  for (const k in o) {
    let o1 = o[k];
    if (isLiteral(o1)) continue;
    let els = getElements(o1, elKey, arrKey);
    if (!isEmpty(els)) res[k] = els;
  }
  return res;
}
function getElements(o, elKey = '_obj', arrKey = '_set') {
  if (!o) return [];
  let res = o[arrKey] ? o[arrKey] : o;
  if (isList(res) && res.length > 0) return res[0][elKey] ? res.map(x => x[elKey]) : res;
  else return [];
}
function getElemSize(elem) {
  var d = document.createElement("div");
  document.body.appendChild(d);
  let cStyles = { position: 'fixed', opacity: 0, top: '-9999px' };
  mStyleX(d, cStyles);
  mAppend(d, elem);
  height = d.clientHeight;
  width = d.clientWidth;
  d.parentNode.removeChild(d);
  return { w: width, h: height };
}
function getEllipsePoints(radx, rady, n, disp = 0) {
  let pts = [];
  let i = 0;
  let da = 360 / n;
  let angle = disp;
  while (i < n) {
    let px = radx * Math.cos(toRadian(angle));
    let py = rady * Math.sin(toRadian(angle));
    pts.push({ X: px, Y: py });
    angle += da;
    i++;
  }
  return pts;
}
function getExtendedColors(bg, fg) {
  //#region doc 
  //#endregion 
  bg = computeColor(bg);
  fg = computeColor(fg);
  if (bg == 'inherit' && (nundef(fg) || fg == 'contrast')) {
    fg = 'inherit';
  } else if (fg == 'contrast' && isdef(bg) && bg != 'inherit') fg = colorIdealText(bg);
  else if (bg == 'contrast' && isdef(fg) && fg != 'inherit') { bg = colorIdealText(fg); }
  return [bg, fg];
}
function getFieldEdges(o) {
  let edgeIds = o.edges.map(x => x._obj);
  return edgeIds.map(x => isdef(x) ? G.table[x] : x);
}
function getFields(board) {
  let fids = board.strInfo.fields;
  return fids.map(x => G.table[x]);
}
function getFilename(path, withExt = true) {
  let fname = stringAfterLast(path, '/');
  let name = stringBefore(fname, '.');
  let ext = stringAfter(fname, '.');
  if (isEmpty(ext)) ext = 'png';
  let result = withExt ? (name + '.' + ext) : name;
  console.log(`filename (ext:${withExt}): ${result}`);
  return result;
}
function getFirstBoat() { if (!IdOwner.a || isEmpty(IdOwner.a)) return null; return UIS[getFirstBoatId()]; }
function getFirstBoatId() { if (!IdOwner.a || isEmpty(IdOwner.a)) return null; return IdOwner.a[0]; }
function getFirstId(path) { let ids = path2mainIds[path]; return ids && ids.length > 0 ? ids[0] : null; }
function getFirstKey(o) { return Object.keys(o)[0]; }
function getFirstVisual(oid) { let res = getVisual(oid); return res ? res : getDefVisual(oid); }
function getFloatLeftDiv() {
  let d = document.createElement('div');
  d.style.float = 'left';
  return d;
}
function getFontString(params) {
  let f = params.font;
  if (nundef(f)) return null;
  if (isString(f)) return f;
  else {
    let fz = f.size; if (isNumber(fz)) fz = '' + fz + 'px';
    let ff = f.family;
    let fv = f.variant;
    let fw = isdef(f.bold) ? 'bold' : isdef(f.light) ? 'light' : f.weight;
    let fs = isdef(f.italic) ? 'italic' : f.style;
    if (nundef(fz) || nundef(ff)) return null;
    let s = fz + ' ' + ff;
    if (isdef(fw)) s = fw + ' ' + s;
    if (isdef(fv)) s = fv + ' ' + s;
    if (isdef(fs)) s = fs + ' ' + s;
    return s;
  }
}
function getFractionVariantsTrial1(res) {
  let num = getRandomFractions(res, 8);
  let resInList = firstCond(nums, x => x.n == res.n && x.d == res.d);
  if (!resInList) nums.push(res);
  let finalNums = nums.filter(x => x.n == res.n);
  let otherNums = nums.filter(x => x.n != res.n);
  if (finalNums.length < 4) {
    let nMissing = 4 - finalNums.length;
    let additional = choose(otherNums, nMissing);
    finalNums = finalNums.concat(additional);
  }
  nums = finalNums;
  return nums;
}
function getFruid(pref = '') {
  const alpha = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
  FRUIDCounter += 1;
  if (FRUIDCounter < alpha.length) return pref + alpha[FRUIDCounter];
  return pref + FRUIDCounter - alpha.length;
}
function getFuncName() {
  return getFuncName.caller.name;
}
function getFunctionCallerName() {
  return new Error().stack.match(/at (\S+)/g)[1].slice(3);
}
function getFunctionSignature(firstline, key) {
  let sig;
  if (firstline.includes(') {')) sig = stringBefore(firstline, ') {') + ')';
  else if (firstline.includes('){')) sig = stringBefore(firstline, '){') + ')';
  else sig = `function ${key}()`;
  sig += '{}';
  return sig;
}
function getFunctionsNameThatCalledThisFunction() {
  let c1 = getFunctionsNameThatCalledThisFunction.caller;
  if (nundef(c1)) return 'no caller!';
  let c2 = c1.caller;
  if (nundef(c2)) return 'no caller!';
  return c2.name;
}
function getGameOrLevelInfo(k, defval) {
  let val = lookup(DB.games, [G.id, 'levels', G.level, k]);
  if (!val) val = lookupSet(DB.games, [G.id, k], defval);
  return val;
}
function getGamePlayer() {
  for (const k in G.playersAugmented) {
    o = G.playersAugmented[k];
    if (o.obj_type == 'GamePlayer') return o;
  }
}
function getGames() { return U.avGames; }
function getGameValues() {
  let user = U.id;
  let game = G.id;
  let level = G.level;
  let settings = { numColors: 1, numRepeat: 1, numPics: 1, numSteps: 1, colors: ColorList };
  settings = mergeOverride(settings, DB.settings);
  if (isdef(U.settings)) settings = mergeOverride(settings, U.settings);
  if (isdef(DB.games[game])) settings = mergeOverride(settings, DB.games[game]);
  let next = lookup(DB.games, [game, 'levels', level]); if (next) settings = mergeOverride(settings, next);
  next = lookup(U, ['games', game]); if (next) settings = mergeOverride(settings, next);
  next = lookup(U, ['games', game, 'levels', level]); if (next) settings = mergeOverride(settings, next);
  delete settings.levels;
  Speech.setLanguage(settings.language);
  return settings;
}
function getGlobalColors() { return Object.keys(ColorDict).map(x => x.E); }
function getGlobals() {
  let di = {};
  let keys = get_keys(window); keys.sort();
  for (const k of keys) {
    let o = window[k];
    let type = typeof o;
    lookupAddToList(di, [type], { key: k, o: o, value: k, type: type });
  }
  Globals = di;
  return di;
}
function getGSGElements(gCond, sCond) {
  let keys = [];
  let byg = ByGroupSubgroup;
  for (const gKey in byg) {
    if (!gCond(gKey)) continue;
    for (const sKey in byg[gKey]) {
      if (!sCond(sKey)) continue;
      keys = keys.concat(byg[gKey][sKey]);
    }
  }
  return keys.sort();
}
function getHarmoniousStyles(sz, family, bg = 'blue', fg = 'random', hasText = true) {
  let fpic = 2 / 3; let ffont = 1 / 8; let ftop = 1 / 9; let fbot = 1 / 12;
  let styles = { w: sz, h: sz, bg: bg, fg: 'contrast', patop: sz * ftop, pabottom: sz * fbot, align: 'center', 'box-sizing': 'border-box' };
  let textStyles = { family: family, fz: Math.floor(sz * ffont) };
  let picStyles = { h: sz * fpic, bg: fg };
  return [styles, picStyles, textStyles];
}
function getHarmoniousStyles1(w, h, padding, family, bg = 'blue', fg = 'random', hasText = true) {
  let numbers = hasText ? [15, 55, 0, 20, 10] : [15, 70, 0, 0, 15];
  numbers = numbers.map(x => h * x / 100);
  [patop, szPic, zwischen, szText, pabot] = numbers;
  patop = Math.max(patop, padding);
  pabot = Math.max(pabot, padding);
  let styles = { h: h, bg: bg, fg: 'contrast', patop: patop, pabottom: pabot, align: 'center', 'box-sizing': 'border-box' };
  let textStyles = { family: family, fz: Math.floor(szText * 3 / 4) };
  let picStyles = { h: szPic, bg: fg };
  if (w > 0) styles.w = w; else styles.paleft = styles.paright = Math.max(padding, 4);
  return [styles, picStyles, textStyles];
}
function getHarmoniousStylesPlus(sContainer, sPic, sText, w, h, padding, family, bg = 'blue', fg = 'random', hasText = true) {
  let numbers = hasText ? [15, 55, 0, 20, 10] : [15, 70, 0, 0, 15];
  numbers = numbers.map(x => h * x / 100);
  [patop, szPic, zwischen, szText, pabot] = numbers;
  patop = Math.max(patop, padding);
  pabot = Math.max(pabot, padding);
  let styles = { h: h, bg: bg, fg: 'contrast', patop: patop, pabottom: pabot, align: 'center', 'box-sizing': 'border-box' };
  let textStyles = { family: family, fz: Math.floor(szText * 3 / 4) };
  let picStyles = { h: szPic, bg: fg };
  if (w > 0) styles.w = w; else styles.paleft = styles.paright = Math.max(padding, 4);
  for (const k in sContainer) { if (k != 'w' && nundef(styles[k])) styles[k] = sContainer[k]; }
  for (const k in sPic) { if (k != 'w' && nundef(picStyles[k])) picStyles[k] = sPic[k]; }
  for (const k in sText) { if (k != 'w' && nundef(textStyles[k])) textStyles[k] = sText[k]; }
  return [styles, picStyles, textStyles];
}
function getHarmoniousStylesPlusPlus(sContainer, sPic, sText, w, h, picPercent, padding, family, bg = 'blue', bgPic = 'random', fgPic = 'white', fgText = 'white', hasText = true) {
  let fact = 55 / picPercent;
  let [ptop, pbot] = [(80 - picPercent) * 3 / 5, (80 - picPercent) * 2 / 5];
  let numbers = hasText ? [fact * 15, picPercent, 0, fact * 20, fact * 10] : [15, 70, 0, 0, 15];
  numbers = numbers.map(x => h * x / 100);
  [patop, szPic, zwischen, szText, pabot] = numbers;
  patop = Math.max(patop, padding);
  pabot = Math.max(pabot, padding);
  let styles = { h: h, bg: bg, fg: isdef(fgText) ? fgText : 'contrast', patop: patop, pabottom: pabot, align: 'center', 'box-sizing': 'border-box' };
  let textStyles = { family: family, fz: Math.floor(szText * 3 / 4) };
  let picStyles = { h: szPic, bg: bgPic, fg: isdef(fgPic) ? fgPic : 'contrast' };
  if (w > 0) styles.w = w; else styles.paleft = styles.paright = Math.max(padding, 4);
  for (const k in sContainer) { if (k != 'w' && nundef(styles[k])) styles[k] = sContainer[k]; }
  for (const k in sPic) { if (k != 'w' && nundef(picStyles[k])) picStyles[k] = sPic[k]; }
  for (const k in sText) { if (k != 'w' && nundef(textStyles[k])) textStyles[k] = sText[k]; }
  return [styles, picStyles, textStyles];
}
function getHarmoniousStylesX(sz, family, bg = 'blue', fg = 'random', hasText = true, setWidth = false) {
  let numbers = hasText ? [15, 55, 0, 20, 10] : [15, 70, 0, 0, 15];
  numbers = numbers.map(x => sz * x / 100);
  [patop, szPic, zwischen, szText, pabot] = numbers;
  console.log(patop, szPic, zwischen, szText, pabot);
  let styles = { h: sz, bg: bg, fg: 'contrast', patop: patop, pabottom: pabot, align: 'center', 'box-sizing': 'border-box' };
  let textStyles = { family: family, fz: Math.floor(szText * 3 / 4) };
  let picStyles = { h: szPic, bg: fg };
  if (setWidth) styles.w = sz; else styles.paleft = styles.paright = 4;
  return [styles, picStyles, textStyles];
}
function getHarmoniousStylesXX(w, h, padding, family, bg = 'blue', fg = 'random', hasText = true) {
  let numbers = hasText ? [15, 55, 0, 20, 10] : [15, 70, 0, 0, 15];
  numbers = numbers.map(x => h * x / 100);
  [patop, szPic, zwischen, szText, pabot] = numbers;
  patop = Math.max(patop, padding);
  pabot = Math.max(pabot, padding);
  let styles = { h: h, bg: bg, fg: 'contrast', patop: patop, pabottom: pabot, align: 'center', 'box-sizing': 'border-box' };
  let textStyles = { family: family, fz: Math.floor(szText * 3 / 4) };
  let picStyles = { h: szPic, bg: fg };
  if (w > 0) styles.w = w; else styles.paleft = styles.paright = Math.max(padding, 4);
  return [styles, picStyles, textStyles];
}
function getHexFieldInfo(boardInfo, row, col) {
  let info = {
    shape: 'hex',
    memType: 'field',
    row: row,
    col: col,
    x: -boardInfo.w / 2 + (col - boardInfo.minCol) * boardInfo.dx + boardInfo.wdef / 2,
    y: -boardInfo.h / 2 + boardInfo.hdef / 2 + (row - boardInfo.minRow) * boardInfo.dy,
    w: boardInfo.wdef,
    h: boardInfo.hdef,
  };
  info.poly = getHexPoly(info.x, info.y, info.w, info.h);
  return info;
}
function getHexGridInfo(rows, cols) {
  [wdef, hdef] = [4, 4];
  [dx, dy] = [wdef / 2, (hdef * 3) / 4];
  let info = {
    structType: 'hexGrid',
    rows: rows,
    cols: cols,
    wdef: 4,
    hdef: 4,
    dx: dx,
    dy: dy,
    w: wdef + (cols - 1) * dx,
    h: hdef + (rows - 1) * dy,
    minRow: 0,
    minCol: 0,
  };
  return info;
}
function getHexPoly(x, y, w, h) {
  let hex = [[0, -0.5], [0.5, -0.25], [0.5, 0.25], [0, 0.5], [-0.5, 0.25], [-0.5, -0.25]];
  return getPoly(hex, x, y, w, h);
}
function getHue(cssHSLA) {
  let h = firstNumber(cssHSLA);
  return h;
}
function getHueWheel(contrastTo, minDiff = 25, mod = 30, start = 0) {
  let hc = colorHue(contrastTo);
  let wheel = [];
  while (start < 360) {
    let d1 = Math.abs((start + 360) - hc);
    let d2 = Math.abs((start) - hc);
    let d3 = Math.abs((start - 360) - hc);
    let min = Math.min(d1, d2, d3);
    if (min > minDiff) wheel.push(start);
    start += mod;
  }
  return wheel;
}
function getIdArea(areaName) {
  if (startsWith(areaName, 'a_d_')) {
    return areaName;
  } else if (startsWith(areaName, 'm_A_')) {
    return areaName;
  } else {
    return 'm_A_' + areaName;
  }
}
function getidAvailable(i) { return 'c_b_mm_plj' + i; }
function getIdForOid(oid) { return 'm_t_' + oid; }
function getidNum(i) { return 'c_b_mm_pln' + i; }
function getidPlayermode(mode) { return 'c_b_mm_' + mode; }
function getIds(id, type = 'all') {
  let res = id2uids[id];
  if (nundef(res)) return [];
  if (isEmpty(res) || type == 'all') return res;
  return res.filter(x => isdef(x[type]));
}
function getIdsInfobox() { return IdOwner.i ? IdOwner.i : []; }
function getidSpan(i) { return 'sppl' + i; }
function getidSpanJoin(i) { return 'spplj' + i; }
function getidType(i) { return 'c_b_mm_plt' + i; }
function getIfDict(o, key, defval) {
  let entry = o[key];
  if (nundef(entry) && isdef(defval)) {
    o[key] = defval;
  }
  return o[key];
}
function getIndicesCondi(arr, func) {
  let res = [];
  for (let i = 0; i < arr.length; i++) {
    if (func(arr[i], i)) res.push(i);
  }
  return res;
}
function getIndicesOfCorrectlyAnsweredWords() { return getCorrectlyAnsweredWords().map(x => x.iWord); }
function getIndicesOfWrongChars() { return getWrongChars().map(x => x.index); }
function getIndicesOfWrongWords() { return getWrongWords().map(x => x.iWord); }
function getInfos(cats, lang,
  { minlen, maxlen, wShort = false, wLast = false, wExact = false, sorter = null }) {
  let keys = setCategories(cats);
  let infos = [];
  if (isdef(minlen && isdef(maxlen))) {
    keys = keys.filter(k => {
      let info = jsCopy(symbolDict[k]);
      let exact = CorrectWordsExact[lang][k];
      if (wExact && nundef(exact)) return false;
      let ws = wExact ? [exact.req] : wLast ? [lastOfLanguage(k, lang)] : wordsOfLanguage(k, lang);
      if (wShort) ws = [getShortestWord(ws, false)];
      info.words = [];
      for (const w of ws) {
        if (w.length >= minlen && w.length <= maxlen) {
          info.words.push(w);
          info.best = w;
        }
      }
      if (!isEmpty(info.words)) { infos.push(info); return true; } else return false;
    });
  }
  if (isdef(sorter)) sortByFunc(infos, sorter);
  return infos;
}
function getInputStringOfChar(inp) { return iDiv(inp).innerHTML; }
function getInputStringOfChari(index) { return getInputStringOfChar(Goal.chars[index]); }
function getInputStringOfWord(winp) { return winp.charInputs.map(x => iDiv(x).innerHTML).join(''); }
function getInputStringOfWordi(iWord) { return getInputStringOfWord(Goal.words[iWord]); }
function getInputValue(id) { const input = document.getElementById(id); const text = input.value; input.value = ''; return text; }
function getInputWords() { return Goal.words.map(x => getInputStringOfWord(x)); }
function getInputWordString(sep = ' ') { return getInputWords().join(sep); }
function getInstance(G) {
  return new (Daat.GameClasses[G.id])(G.id);
}
function getInstrGeoJson(instr, coord) {
  console.log('instr', instr, 'coord', coord);
  var formatter = new L.Routing.Formatter();
  var instrPts = {
    type: "FeatureCollection",
    features: []
  };
  for (var i = 0; i < instr.length; ++i) {
    var g = {
      "type": "Point",
      "coordinates": [coord[instr[i].index].lng, coord[instr[i].index].lat]
    };
    var p = {
      "instruction": formatter.formatInstruction(instr[i])
    };
    instrPts.features.push({
      "geometry": g,
      "type": "Feature",
      "properties": p
    });
  }
  return instrPts;
}
function getItem(k) { return infoToItem(Syms[k]); }
function getItemOfSameIndexAsIn(val, arr, items) {
  let i = arr.indexOf(val);
  return items[i];
}
function getItems(n, cond, keySet = 'all') {
  if (isNumber(n)) { n = _getKeysCond(n, cond, keySet); }
  if (isString(n[0])) n = n.map(x => Syms[x]);
  if (nundef(n[0].info)) n = n.map(x => infoToItem(x));
  return n;
}
function getItemsMaxLen(n, len, keySet = 'all', lang = 'E', luc = 'c') { return getItemsMaxWordLength(...arguments); }
function getItemsMaxWordLength(n, len, keySet = 'all', lang = 'E', luc = 'c') {
  let items = getItems(n, x => x[lang].length <= len, keySet);
  addLabels(items, lang, luc);
  return items;
}
function getItemWithMax(d, propName) {
  testHelpers('getItemWithMax dict:', d, 'propName:', propName);
  let max = 0;
  let kmax = null;
  for (const key in d) {
    let val = d[key][propName];
    if (val > max) {
      max = val;
      kmax = key;
    }
  }
  return [kmax, d[kmax], max];
}
function getItemWithMaxValue(d) {
  let k = Object.keys(d).reduce((a, b) => (d[a] >= d[b] ? a : b));
  return [k, d[k]];
}
function getKeys(dict) { return Object.keys(dict); }
function getKeySet(groupName, language, maxlength) {
  let keys = setGroup(groupName);
  keys = isdef(maxlength) && maxlength > 0 ?
    keys.filter(x => lastOfLanguage(x, language).length <= maxlength)
    : keys;
  return keys;
}
function getKeySets() {
  makeCategories();
  let res = {};
  for (const k in Syms) {
    let info = Syms[k];
    if (nundef(info.cats)) continue;
    for (const ksk of info.cats) {
      lookupAddIfToList(res, [ksk], k);
    }
  }
  res.animals = getAnimals();
  res.nature = getNature();
  localStorage.setItem('KeySets', JSON.stringify(res));
  return res;
}
function getKeySetSimple(cats, lang, minlen, maxlen, wLast = false, wExact = false, sorter = null) {
  let keys = setCategories(cats);
  if (isdef(minlen && isdef(maxlen))) {
    keys = keys.filter(k => {
      let exact = CorrectWordsExact[k];
      if (wExact && nundef(exact)) return false;
      let ws = wLast ? [lastOfLanguage(k, lang)] : wordsOfLanguage(k, lang);
      for (const w of ws) {
        if (w.length >= minlen && w.length <= maxlen
          && (!wExact || isdef(exact) && w.toLowerCase() == exact.req && !exact.danger))
          return true;
      }
      return false;
    });
  }
  if (isdef(sorter)) sortByFunc(keys, sorter);
  return keys;
}
function getKeySetsX() {
  let ks = localStorage.getItem('KeySets');
  if (isdef(ks)) return JSON.parse(ks);
  let res = {};
  for (const k in Syms) {
    let info = Syms[k];
    if (nundef(info.cats)) continue;
    for (const ksk of info.cats) {
      lookupAddIfToList(res, [ksk], k);
    }
  }
  localStorage.setItem('KeySets', JSON.stringify(res));
  return res;
}
function getKeySetX(categories, language, minlength, maxlength, bestOnly = false, sortAccessor = null, correctOnly = false, reqOnly = false) {
  let keys = setCategories(categories);
  if (isdef(minlength && isdef(maxlength))) {
    keys = keys.filter(k => {
      let ws = bestOnly ? [lastOfLanguage(k, language)] : wordsOfLanguage(k, language);
      for (const w of ws) {
        if (w.length >= minlength && w.length <= maxlength
          && (!correctOnly || isdef(CorrectWordsExact[k]))
          && (!reqOnly || w.toLowerCase() == CorrectWordsExact[k].req))
          return true;
      }
      return false;
    });
  }
  if (isdef(sortAccessor)) sortByFunc(keys, sortAccessor);
  return keys;
}
function getLastBoatId() { if (!IdOwner.a || isEmpty(IdOwner.a)) return null; return IdOwner.a[IdOwner.a.length - 1]; }
function getLayoutSample(n) {
  if (G.level > 4) {
  }
  let samples = {
    1: '"a"',
    2: '"a b"', //'"a" "b"',
    3: ['"a b c"', '"a a" "b c"', '"a b" "c c"'],
    4: ['"z z d" "a a c" "a a c"', '"a b" "c d"'],
    5: ['"a b e" "c c d"', '"a a b" "c d e"', '"a b e" "c d e"'],
    6: ['"a b b c" "d d e f"', '"a b b c" "a d e f"', '"a b b b" "c d e f"'],
    7: ['"a b c d" "a b e f"', '"a b b c" "a d e c" "a d f g"'],
    8: ['"a a b c" "d d e c" "f g e h"', '"a b b c" "a d e c" "f g e h"'],
    9: ['"a a b b" "c d d e" "f g h i"', '"a d e b" "c d e b" "f g h i"'],
    10: '"j a b b" "c d d e" "f g h i"',
    11: '"j a a b b" "j c d d e" "f g h i k"',
    12: '"j a a b b l" "j c d d e l" "f g h i k k"',
    13: '"j a a b b" "j c d d e" "f g h i k" "l l m m k"',
    14: '"n j a a b b" "n j c d d e" "f g h i i k" "l l m m m k"',
    15: '"n j o o b b" "n j a a b b" "n j c d d e" "f g h i i k" "l l m m m k"',
    16: [
      '"a b c d e" "f f g h e" "o p i h j" "k l i m n"',
      '"a b b d e" "n f p g e" "i j j o k" "l l c m h"',
      '"a a p g c h" "a a b b c h" "n d d e e f" "o i j k l m"',
      '"a b c o d e" "f b c p g e" "f i i j g k" "n l m j h k"'
    ],
    17: [
      '"a b c d e" "f g h i j" "k l m i o" "p n q q o"',
      '"a a c d e" "f g h i j" "k l m i o" "p n q b o"',
      '"a b c d e" "f b h i j" "k l m i o" "p n m q g"'
    ],
    18: [
      '"a b c d e" "a g h i j" "k l m n o" "p q r f o"',
      '"a b b c d e" "a g h h i j" "k l l m n o" "p q q r f o"',
      '"a b b c d e" "a g g h i j" "k g g m n o" "p q l r f o"',
      '"a b b c d e" "a g h h i j" "k k l m n o" "p q l r f o"',
    ],
    19: [
      '"a b c d e" "f b h i j" "k l m s o" "p n q g r"',
      '"a a b c d e" "f h b i i j" "k l m m s o" "p n q g g r"',
      '"a a b c d e" "f h b i l j" "k h m m s o" "p n q g g r"',
      '"a q b c d e" "f h b i l j" "k h m m s o" "p n m m g r"',
      '"a q b c d e" "f h b i l j" "k h m m s o" "p n m m g r"',
    ],
    20: [
      '"a b c d e" "f g h i j" "k l m n o" "p q r s t"',
      '"a b b c d e" "f g h h i j" "k k l m n o" "p q r s s t"',
      '"a b b c d e" "f g h h i j" "k k l m i o" "p q r n s t"',
      '"a f b c d e" "a g h h i j" "k k l m i o" "p q r n s t"',
    ],
    21: [
      '"a b b c d e" "f g h h i j" "k u l m n o" "p q r s s t"',
      '"a b b c d e" "f u g h i j" "k u l m n o" "p q r s n t"',
      '"a b b c d e" "f g h u i j" "k k l m i o" "p q r n s t"',
      '"a f b c d e" "a g h h i j" "k u l m i o" "p q r n s t"',
    ],
    22: [
      '"a v b c d e" "f g h h i j" "k u l m n o" "p q r s s t"',
      '"a b b c d e e" "f u g h i j v" "k u l m n o v" "p q r s n t t"',
      '"a b b c d e e" "f u g h i j j" "k u l m n o v" "p q r s n t t"',
      '"a b b c d d e" "m b b c i j e" "f u g h i j v" "k u l l n o v" "p q r s n t t"',
    ],
    23: [
      '"a v b c d e" "f g h h i j" "k u l m n o" "p q r w s t"',
      '"a w b c d e e" "f u g h i j v" "k u l m n o o" "p q r s n t t"',
      '"a b b c d e e" "f w g h i j j" "k u l m n o v" "p q r s n t t"',
    ],
    24: [
      '"a v b c d e" "f g h x i j" "k u l m n o" "p q r w s t"',
      '"a v v b c d e" "f g h x x i j" "k u l l n o m" "p q r w s t m"',
    ],
    25: ['"a b c d e f g" "a h i k l m g" "o p n r s m u" "v w x y q t j"'],
    26: ['"a a c d e f g" "h i b k l j n" "o p q r s m u" "v w x y z t u"'],
    27: ['"a b c d e f g" "h i j k l m n" "o p q r s t u" "v w x y z A u"'],
    28: ['"a b c d e f g" "h i j k l m n" "o p q r s t u" "v w x y z A B"'],
    29: ['"a b c d e f g h" "i j k d m n o p" "q r r t u v w x" "y z A B C s l l"'],
    30: ['"a b c d e f g h" "i j k d m n o p" "q r s t u v w x" "y z A B C D l l"'],
    31: ['"a b c d e f g h" "i j k l m n o p" "q r s t u v w x" "y z A B C D E E"'],
    32: ['"a b c d e f g h" "i j k l m n o p" "q r s t u v w x" "y z A B C D E F"'],
  };
  let s;
  if (nundef(n)) {
    let l = chooseRandom(Object.keys(samples));
    s = samples[l];
  } else {
    s = samples[n];
  }
  s = isList(s) ? chooseRandom(s) : s;
  s = getLetterSwapEncoding(s);
  return s;
}
function getLbl(key, sz, bg, label) {
  let items, ifs = { bg: bg }, options = { sz: sz };
  if (isdef(label)) options.showLabels = true; else options.showLabels = false;
  [items, ifs, options] = createStandardItems(null, ifs, options, [key], isdef(label) ? [label] : undefined);
  prepDims(items, options);
  prepLbls(items, ifs, options);
  return items[0];
}
function getLbls(onClickPictureHandler, ifs = {}, options = {}, keys, labels) {
  let items;
  [items, ifs, options] = createStandardItems(onClickPictureHandler, ifs, options, keys, labels);
  prepDims(items, options);
  prepLbls(items, ifs, options);
  return items;
}
function getLettersExcept(w, except = []) {
  w = w.toLowerCase();
  let res = [];
  for (let i = 0; i < w.length; i++) {
    if (!except.includes(w[i])) res.push({ i: i, letter: w[i] });
  }
  return res;
}
function getLetterSwapEncoding(s) {
  let di = getRandomLetterMapping(s);
  let result = '';
  for (let i = 0; i < s.length; i++) {
    result += s[i] in di ? di[s[i]] : s[i];
  }
  return result;
}
function getLines(s) {
  var str = s;
  var res = str.split('\n');
  return res;
}
function getLinkContainerId(linkId) { return 'd' + linkId; }
function getList(lst) { return isdef(lst) ? lst : []; }
function getListsContainingAll(ll, l) {
  let res = [];
  for (const l1 of ll) {
    if (containsAll(l1, l)) res.push(l1);
  }
  return res;
}
function getLuminosity(cssHSLA) {
  let ints = allNumbers(cssHSLA);
  return ints[2];
}
function getMainArea(dParent, styles = {}) {
  clearElement(dParent);
  let dArea = getArea(dParent, styles);
  return dArea;
}
function getMainAreaPadding(dParent, padding = 10, bg = 'grey', styles = {}) {
  let aTable = percentOf(dParent, 100, 100);
  let defAreaStyles = { margin: padding, w: aTable.w - 2 * padding, h: aTable.h - 2 * padding, bg: bg, layout: 'hcc', };
  clearElement(dParent);
  let dArea = getArea(dParent, mergeOverride(defAreaStyles, styles));
  return dArea;
}
function getMainAreaPercent(dParent, bg = 'grey', wPercent = 94, hPercent = 96, id) {
  clearElement(dParent);
  let aTable = percentOf(dParent, wPercent, hPercent);
  let dArea = getArea(dParent, { w: aTable.w, h: aTable.h, layout: 'hcc', bg: bg }, id);
  return dArea;
}
function getMainId(oid) { return firstCond(oid2ids[oid], x => x[0] == 'm'); }
function getMainVisual(oid) { return UIS[oid]; }
function getMatchingPictoKey(o, key) {
  let sym = o.obj_type;
  if (sym in S.settings.symbols) { sym = S.settings.symbols[sym]; }
  if (!(sym in iconChars)) {
    symNew = Object.keys(iconChars)[randomNumber(5, 120)];
    S.settings.symbols[sym] = symNew;
    sym = symNew;
  }
}
function getMissingIndices(arr, len) {
  let i = 0;
  let a = arr[i];
  let j = 0;
  let res = [];
  while (j < len) {
    while (j < a) {
      testHelpers(j, a, 'adding j');
      res.push(j);
      j += 1;
    }
    i += 1;
    j = a + 1;
    a = i < arr.length ? arr[i] : len;
  }
  return res;
}
function getMixedNumber(num, denom) {
  const quotient = Math.floor(num / denom);
  const remainder = num % denom;
  if (remainder === 0) {
    return { full: quotient, frac: null, n: null, d: null };
  } else {
    return { full: quotient, frac: math.fraction(remainder, denom), n: remainder, d: denom };
  };
}
function getMouseObject(e) {
  return (e ? e.target : window.event.srcElement);
}
function getMouseX(e) {
  return (e ? e.clientX : window.event.clientX);
}
function getMouseY(e) {
  return (e ? e.clientY : window.event.clientY);
}
function getNamedUID(name) {
  if (!(name in NAMED_UIDS)) {
    NAMED_UIDS[name] = 0;
  }
  NAMED_UIDS[name] += 1;
  return name[0] + NAMED_UIDS[name];
}
function getNature() {
  let gr = 'Animals & Nature';
  let result = [];
  for (const sg in ByGroupSubgroup[gr]) {
    result = result.concat(ByGroupSubgroup[gr][sg]);
  }
  return result;
}
function getNColors(n) {
  return choose(getColorNames(), n);
}
function getNextIndexOfMissingNumber(iStart = 0) {
  for (let i = iStart; i < G.seq.length; i++) {
    if (Goal.words[i].hasBlanks) return i;
  }
  return null;
}
function getNextStartBoat() {
  let mobj = null;
  let sb = startBoats[0];
  if (G.phase == 'setup') {
    let boats = getBoats();
    for (const b of boats) {
      for (const id of startBoats) {
        for (const t of b.o.text) {
          if (t.includes(id)) {
            sb = id;
            mobj = b;
            removeInPlace(startBoats, sb);
            return mobj;
          }
        }
      }
    }
  }
  return mobj;
}
function getNextTableId() {
  let ids = nundef(DB.tables) ? [] : Object.keys(DB.tables);
  ids = ids.map(x => Number(x));
  let max = Math.max(ids);
  return '' + (max + 1);
}
function getNItemsPerKeylist(n, keylists, options = {}) {
  let items = [];
  for (const list of keylists) {
    options.keySet = list.keys;
    let cat = list.cat;
    let newItems = genItems(n, options);
    newItems.map(x => { x.cat = cat; items.push(x) });
  }
  return items;
}
function getNumCards(deck) { return deck.cards.length; }
function getNumSeqHint() {
  let l = G.op == 'plus' ? 'to' : 'from';
  let msg = `${G.op} ${G.step} ${l} the previous number`;
  msg = `${G.oop.cmd} ${G.step} ${G.oop.link} the previous number`;
  return msg;
}
function getNumSeqHintString(i) {
  console.log('i', i, 'trial#', G.trialNumber)
  let cmd = G.op;
  let m = G.step;
  let lstSpoken, lstWritten;
  if (i == 0) {
    lstSpoken = [G.oop.cmd, m];
  } else if (i == 1) {
    let decl = G.op == 'plus' ? 'to' : G.op == 'minus' ? 'from' : 'by';
    let phrase = decl + ' the previous number';
    lstSpoken = [G.oop.cmd, m, G.oop.link, ' the previous number'];
  } else if (i == 2) {
    let iBlank = getNextIndexOfMissingNumber();
    let iPrevious = iBlank - 1;
    let n = G.seq[iPrevious];
    lstSpoken = ['the previous number', 'is', n];
  } else if (i >= 3) {
    let iBlank = getNextIndexOfMissingNumber();
    let iPrevious = iBlank - 1;
    let n = G.seq[iPrevious];
    let oop = OPS[cmd];
    let erg = i >= 4 ? Goal.words[iBlank].word : '?';
    lstSpoken = ['', n, oop.sp, m, 'equals', erg];
    lstWritten = [n, oop.wr, m, '=', erg];
  } else {
    let iBlank = getNextIndexOfMissingNumber();
    lstSpoken = ['enter', Goal.words[iBlank].word];
  }
  if (G.language == 'D') lstSpoken = lstSpoken.map(x => translateToGerman(x));
  if (nundef(lstWritten)) lstWritten = lstSpoken;
  return [lstSpoken.join(' '), lstWritten.join(' ')];
}
function getO(n, R) { let oid = n.oid; if (isdef(oid)) return R.getO(oid); else return null; }
function getObject(id) { return G.table[id]; }
function getObjectFromWindow(key) {
  let code, sig, type;
  let f = window[key];
  if (typeof f != 'function') return null;
  code = f.toString();
  sig = getFunctionSignature(stringBefore(code, '\n'), key);
  type = 'func';
  let o = { name: key, code: code, sig: sig, region: type, filename: '', path: '', type: type };
  CODE.justcode[key] = code;
  CODE.all[key] = CODE.di[type][key] = o;
  return o;
}
function getObjectsWithSame(olist, props, o, up = true, breakWhenDifferent = true) {
  let res = [];
  let val = lookup(o, props);
  if (up) {
    for (let i = 0; i <= olist.length - 1; i++) {
      let val1 = lookup(olist[i], props);
      if (val1 == val) res.push(olist[i]); else if (breakWhenDifferent) return res;
    }
  } else {
    for (let i = olist.length - 1; i >= 0; i--) {
      let val1 = lookup(olist[i], props);
      if (val1 == val) res.push(olist[i]); else if (breakWhenDifferent) return res;
    }
  }
  return res;
}
function getOidForMainId(id) { return id[0] == 'm' ? id.substring(4) : null; }
function getOlist() {
  let keyList = ['female', 'male', 'spy', 'frog', 'fairy'];
  let olist = [];
  for (const k of keyList) {
    olist.push({ key: k, label: k, color: randomColor() });
  }
  return olist;
}
function getOperand(type) { let x = OPS[type]; return randomNumber(Math.max(2, x.min), x.max); }
function getOperationHintString(i) {
  if (i == 0) {
    let spOp = G.oop.sp; if (G.language == 'D') spOp = DD[spOp];
    let sSpoken = [G.operand, spOp, G.step].join(' ');
    let sWritten = visOperation(G.op, G.operand, G.step, null, '?');
    return [sSpoken, sWritten];
  } else {
    let result = G.oop.f(G.operand, G.step);
    let lstSpoken = i == 1 ? result == 0 ? [result] : ['count', 'the red dots'] : [G.operand, G.oop.sp, G.step, 'equals', result];
    if (G.language == 'D') lstSpoken = lstSpoken.map(x => translateToGerman(x));
    let sSpoken = lstSpoken.join(' ');
    let sWritten = visOperation(G.op, G.operand, G.step, null);
    return [sSpoken, sWritten];
  }
}
function getOppDir(dir) { return { e: 'w', w: 'e', n: 's', s: 'n' }[dir]; }
function getOptionsMinimalistic(dParent, handler, w = 0, h = 0, ifs = {}, options = {}, g) {
  [w, h] = detectArea(dParent, w, h);
  let defOptions = {
    isRegular: true, hugeFont: true, szPic: { w: 200, h: 200 }, gap: 15, shufflePositions: true,
    showPic: true, showLabels: true, luc: 'l', labelPos: 'bottom', language: g.language, keySet: g.vocab,
    w: w, h: h, fz: 24, fzText: 24, fzPic: 96, ifs: ifs, handler: handler, ifs: ifs, handler: handler,
  };
  addSimpleProps(g, options);
  addKeys(defOptions, options);
  if (options.numRepeat > 1 && nundef(options.ifs.bg)) {
    let bg = isdef(options.colorKeys) ? 'white' : (i) => options.sameBackground ? computeColor('random') : 'random';
    let fg = isdef(options.colorKeys) ? 'black' : 'contrast';
    options.ifs.bg = bg;
    options.ifs.fg = fg;
  }
  return options;
}
function getOrdinal(i) { return G.numRepeat == 1 ? '' : G.language == 'E' ? ordinal_suffix_of(i) : '' + i + '. '; }
function getOrdinalColorLabelInstruction(cmd, ordinal, color, label) {
  if (nundef(ordinal)) ordinal = getOrdinal(Goal.iRepeat);
  if (nundef(color)) color = Goal.color;
  let colorWord = '', colorSpan = '';
  if (isdef(color)) {
    colorWord = nundef(color) ? '' : nundef(color[G.language]) ? color.E : color[G.language];
    if (G.language == 'D' && !isEmpty(ordinal) && !['lila', 'rosa'].includes(colorWord)) colorWord += 'e';
    colorSpan = `<span style='color:${color.c}'>${colorWord.toUpperCase()}</span>`;
  }
  if (nundef(label)) label = Goal.label;
  let labelSpan = `<b>${label.toUpperCase()}</b>`;
  let eCommand, dCommand;
  switch (cmd) {
    case 'click': eCommand = cmd + ' the'; dCommand = cmd; break
    case 'then': eCommand = cmd + ' the'; dCommand = 'dann'; break
  }
  let eInstr = `${eCommand} ${ordinal} ${colorWord} ${label}`;
  let dInstr = ordinal == '' ? `${dCommand} ${label} ${colorWord == '' ? '' : 'in ' + colorWord}`
    : `${dCommand} ${ordinal} ${colorWord} ${label}`;
  let ecorr = `${ordinal} ${colorWord} ${label}`
  let dcorr = ordinal == '' ? `${label} ${colorWord == '' ? '' : 'in ' + colorWord}`
    : `${ordinal} ${colorWord} ${label}`;
  let corr = G.language == 'E' ? ecorr : dcorr;
  let spoken = G.language == 'E' ? eInstr : dInstr;
  let written = spoken.replace(colorWord, colorSpan).replace(label, labelSpan);
  return [written, spoken, corr];
}
function getOuterDivForMenuStyle() {
  return createElementFromHtml(`<div style='max-height:430px;text-align: center; animation: appear 4s ease'>`);
}
function getPageHeaderDivForPlayer(oid) { return document.getElementById('c_c_' + G.playersAugmented[oid].username); }
function getPal(ipal, pal) {
  return pal[ipal % pal.length];
}
function getpal(ipal_dep = -1, ihue = 0, bOrf = 'b', pal) {
  let p = empty(pal) || !pal || pal == undefined ? palette : pal;
  if (!p) return randomColor();
  nHues = p[0].length;
  nShades = p.length;
  if (ipal_dep < -1) ipal_dep = randomNumber(0, nShades);
  else if (ipal_dep >= nShades) ipal_dep %= nShades;
  if (ihue < -1) ihue = randomNumber(0, nHues);
  else if (ihue >= nHues) ihue %= nHues;
  return p[ipal_dep][ihue][bOrf];
}
function getPalette(color, type = 'shade') {
  color = colorFrom(color);
  return colorPalShade(color);
}
function getPaletteFromHues(hues) {
  let colors = hues.map(h => colorFromHue(h));
  return colors.map(x => getPalette(x));
}
function getPaletteFromImage(img) {
  let palette0 = ColorThiefObject.getPalette(img);
  let palette = [];
  for (const pal of palette0) {
    let color = colorFrom(pal);
    palette.push(color);
  }
  return palette;
}
function getPara(msg, float) {
  let pl = document.createElement('div');
  if (isdef(float)) pl.style.float = float;
  pl.innerHTML = msg;
  return pl;
}
function getParams(areaName, oSpec, oid) {
  let params = oSpec.params ? oSpec.params : {};
  let panels = oSpec.panels ? oSpec.panels : [];
  let num = panels.length;
  let or = params.orientation ? params.orientation == 'h' ? 'rows'
    : 'columns' : DEF_ORIENTATION;
  let split = params.split ? params.split : DEF_SPLIT;
  let bg = oSpec.color ? oSpec.color : randomColor();
  let fg = bg ? colorIdealText(bg) : null;
  let id = oSpec.id ? oSpec.id : areaName;
  if (oid) { id = getDynId(id, oid); }
  let parent = mBy(areaName);
  if (oSpec.id) {
    parent.id = id;
    addAREA(id, oSpec);
    parent.innerHTML = id;
  }
  if (bg) { mColor(parent, bg, fg); }
  return [num, or, split, bg, fg, id, panels, parent];
}
function getParamsForMaPicStyle(desc = 'segoeBlack') {
  desc = desc.toLowerCase();
  switch (desc) {
    case 'twittertext': return { isText: true, isOmoji: false };
    case 'twitterimage': return { isText: false, isOmoji: false };
    case 'openmojitext': return { isText: true, isOmoji: true };
    case 'openmojiimage': return { isText: false, isOmoji: true };
    case 'openmojiblacktext': return { isText: true, isOmoji: 'openmoBlack' };
    case 'segoe': return { isText: true, isOmoji: 'segoe ui emoji' };
    case 'segoeblack': return { isText: true, isOmoji: 'segoe ui symbol' };
    default: return { isText: true, isOmoji: false };
  }
}
function getParent(elem) { return elem.parentElement; }
function getParentOfScript() {
  var thisScript = document.scripts[document.scripts.length - 1];
  var parent = thisScript.parentElement;
  return parent;
}
function getParentRNode(n, R) { return n.uidParent ? R.rNodes(n.uidParent) : null; }
function getParentUi(n) { return n.idUiParent ? mBy(n.idUiParent) : null; }
function getParentUiNodes(n, R) { return n.uidParent ? R.uiNodes(n.uidParent) : null; }
function getPic(key, sz, bg, label) {
  let items, ifs = { bg: bg }, options = { sz: sz };
  if (isdef(label)) options.showLabels = true; else options.showLabels = false;
  [items, ifs, options] = createStandardItems(null, ifs, options, [key], isdef(label) ? [label] : undefined);
  prepDims(items, options);
  prepPics(items, ifs, options);
  return items[0];
}
function getPics(onClickPictureHandler, ifs = {}, options = {}, keys, labels) {
  let items;
  [items, ifs, options] = createStandardItems(onClickPictureHandler, ifs, options, keys, labels);
  prepDims(items, options);
  prepPics(items, ifs, options);
  return items;
}
function getPicsS(onClickPictureHandler, ifs = {}, options = {}, keys, labels) {
  let items;
  [items, ifs, options] = createStandardItemsS(onClickPictureHandler, ifs, options, keys, labels);
  console.log(items)
  prepDims(items, options);
  options.showPics = true;
  _createDivs(items, ifs, options);
  return items;
}
function getPlayer(id) { return G.playersAugmented[id]; }
function getPlayerArea(pid) {
  let areaName = defaultGameplayerAreaName + '_' + pid;
  let msPlayer = getMainArea(areaName);
  if (!msPlayer) { msPlayer = _makeGameplayerArea(areaName, 'a_d_game'); }
  return msPlayer;
}
function getPlayerColor(id) { return G.playersAugmented[id].color }
function getPlayerColorString(id) { return G.playersAugmented[id].altName }
function getPlayerInfo(i) { return currentPlayersById[plidByIndex[i]]; }
function getPlayermodeRadio(mode) {
  return document.getElementById(getidNum(mode));
}
function getPlayerRadio(n) {
  return document.getElementById(getidNum(n));
}
function getPlayersIncludingU() {
  if (!isList(G.numPlayers)) G.numPlayers = [G.numPlayers];
  let n = G.numPlayers[0];
  let ids = chooseKeys(DB.users, n, ['guest0', 'test0']);
  if (!ids.includes(Username)) ids.splice(0, 1, Username);
  T.players = ids.map(x => new Player(x, DB.users[x].settings.color));
  ids.map(x => lookupAddToList(DB.users, [x, 'tables'], T.id));
}
function getPlayerTypeInput(n) {
  return document.getElementById(getidType(n));
}
function getPlid(username) {
  console.log(playerConfig[GAME].players, username);
  let res = firstCondDict(playerConfig[GAME].players, x => x.username == username);
  console.log(res)
  return res;
}
function getPlidForUsername(username) {
  let players = S.gameConfig.players;
  let pl = firstCond(players, x => x.username == username);
  let res = pl.id;
  return res;
}
function getPoly(offsets, x, y, w, h) {
  let poly = [];
  for (let p of offsets) {
    let px = Math.round(x + p[0] * w);
    let py = Math.round(y + p[1] * h);
    poly.push({ x: px, y: py });
  }
  return poly;
}
function getPrefixHint() {
  let oldHintLength = isdef(G.hintLength) ? G.hintLength : 0;
  if (nundef(G.hintLength)) G.hintLength = 0;
  G.input.value = G.correctPrefix;
  let progress = G.correctPrefix.length > G.nCorrect;
  if (G.correctPrefix.length > G.nCorrect) {
    G.hintLength = 1;
    G.nCorrect = G.correctPrefix.length;
  } else if (G.hintLength < G.goal.label.length - G.nCorrect) G.hintLength += 1;
  if (G.hintLength == 0) G.hintLength = 1;
  let wr = substringOfMinLength(G.goal.label, G.correctPrefix.length, G.hintLength);
  let sp = oldHintLength == G.hintLength && !progress ? G.lastHintPrompt : null;
  return [wr, sp];
}
function getProfileImagePath(userrecord) {
  let dir = '../base/assets/images/';
  let path = dir + (userrecord.hasImage ? userrecord.username : 'unknown_user') + '.jpg';
  return path;
}
function getPublicPath(filename) {
  let result = './public/' + getFilename(filename);
  console.log('pubPath', result);
  return result;
}
function GetPvLine(depth) {
  ;
  var move = ProbePvTable();
  var count = 0;
  while (move != NOMOVE && count < depth) {
    if (MoveExists(move)) {
      MakeMove(move);
      brd_PvArray[count++] = move;
    } else {
      break;
    }
    move = ProbePvTable();
  }
  while (brd_ply > 0) {
    TakeMove();
  }
  return count;
}
function getQChars() {
  return Goal.qCharIndices.map(x => Goal.chars[x]);
}
function getQuadFieldInfo(boardInfo, row, col) {
  let info = {
    shape: 'rect',
    memType: 'field',
    row: row,
    col: col,
    x: -boardInfo.w / 2 + (col - boardInfo.minCol) * boardInfo.dx + boardInfo.wdef / 2,
    y: -boardInfo.h / 2 + (row - boardInfo.minRow) * boardInfo.dy + boardInfo.hdef / 2,
    w: boardInfo.wdef,
    h: boardInfo.hdef,
  };
  info.poly = getQuadPoly(info.x, info.y, info.w, info.h);
  return info;
}
function getQuadGridInfo(rows, cols) {
  [wdef, hdef] = [4, 4];
  let info = {
    structType: 'grid',
    rows: rows,
    cols: cols,
    wdef: 4,
    hdef: 4,
    dx: wdef,
    dy: hdef,
    w: wdef * cols,
    h: hdef * rows,
    minRow: 1,
    minCol: 1,
  };
  return info;
}
function getQuadPoly(x, y, w, h) {
  q = [[0.5, -0.5], [0.5, 0.5], [-0.5, 0.5], [-0.5, -0.5]];
  return getPoly(q, x, y, w, h);
}
function getQWords() { return Goal.qWordIndices.map(x => Goal.words[x]); }
function getRandomBoat() { return UIS[chooseRandom(getBoatIds())]; }
function getRandomCard({ rank, suit, type } = {}) {
  if (isdef(rank) || isdef(suit)) return card52(rank, suit);
  else if (type == 'c52') return card52();
  else if (type == 'inno') return cardInno();
}
function getRandomCards(n, { rank, suit, type, age, color } = {}) {
  if (type == 'inno') {
    let allKeys = Object.keys(cinno);
    let keys = isdef(age) ? allKeys.filter(x => cinno[x].age == age) : allKeys;
    keys = isdef(color) ? keys.filter(x => cinno[x].color == color) : keys;
    let nKeys = choose(keys, n);
    return nKeys;
  }
}
function getRandomConsonant(w, except = []) { let cons = getConsonants(w, except); return chooseRandom(cons); }
function getRandomFraction(num, denom) {
  if (isdef(denom)) {
    if (nundef(num)) num = randomNumber(1, denom - 1);
    return math.fraction(num, denom);
  } else if (isdef(num)) {
    denom = randomNumber(2, 9);
    return math.fraction(num, denom);
  }
  let flist = all2DigitFractionsUnder1Expanded();
  let fr = chooseRandom(flist);
  return math.fraction(Number(fr.numer), Number(fr.denom));
}
function getRandomFractions(n) {
  let flist = all2DigitFractionsUnder1Expanded();
  let frlist = choose(flist, n);
  return frlist.map(x => math.fraction(Number(x.numer), Number(x.denom)));
}
function getRandomHues(fromLocalStorage = true) {
  let hue1 = randomNumber(0, 360);
  if (hue1 > 165 && hue1 < 195) hue1 += 60;
  if (hue1 > 270 && hue1 < 325) hue1 = (hue1 + 120) % 360;
  let hue2 = randomNumber(0, 360);
  if (hue2 > 168 && hue2 < 192) hue2 += 70;
  if (hue2 > 270 && hue2 < 325) hue2 = (hue2 + 120) % 360;
  if (Math.abs(hue1 - hue2) < 20) {
    hue1 = randomNumber(-30, 160);
    hue2 = randomNumber(200, 280);
  }
  if (fromLocalStorage) {
    let info = localStorage.getItem('palette');
    if (info) {
      let ns = allNumbers(info);
      hue1 = ns[0];
      hue2 = ns[1];
    }
  }
  return [hue1, hue2];
}
function getRandomItems(n, keyOrSet, text = true, pic = true, styles = {}) {
  let keys = getRandomKeys(n, keyOrSet);
  if (pic == true) return getPics(() => console.log('click'), styles, { showLabels: text }, keys);
  else return getLbls(() => console.log('click'), styles, { showLabels: text }, keys);
}
function getRandomKey(dict) {
  let keys = Object.keys(dict);
  return chooseRandom(keys);
}
function getRandomKeys(n, kSetOrList) { return choose(isList(kSetOrList) ? kSetOrList : KeySets[kSetOrList], n); }
function getRandomKeysFromGKeys(n) { return getRandomKeys(n, G.keys); }
function getRandomKeysIncluding(n, k, kSetOrList) {
  let keys = getRandomKeys(n, kSetOrList);
  if (!keys.includes(k)) {
    let i = randomNumber(0, keys.length - 1);
    keys.splice(i, 1, k);
  }
  shuffle(keys);
  return keys;
}
function getRandomLetter(w, except = []) { let cons = getLettersExcept(w, except); return chooseRandom(cons); }
function getRandomLetterMapping(s) {
  if (nundef(s)) s = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
  let alphabet = filterDistinctLetters(s);
  let alphabet2 = shuffle(jsCopy(alphabet));
  let di = {};
  for (let i = 0; i < alphabet.length; i++) {
    di[alphabet[i]] = alphabet2[i];
  }
  return di;
}
function getRandomNodeThatCanBeAdded(R) {
  let nonEmpty = allCondDict(R.oidNodes, x => !isEmpty(x));
}
function getRandomNumberSequence(n, minStart, maxStart, fBuild, exceptStart) {
  let nStart = randomNumber(minStart, maxStart - n + 1);
  if (exceptStart) {
    let att = 10;
    while (att >= 0 && nStart == exceptStart) { att -= 1; nStart = randomNumber(minStart, maxStart - n + 1); }
  }
  if (isNumber(fBuild)) return range(nStart, nStart + (n - 1) * fBuild, fBuild);
  else {
    let res = [], x = nStart;
    for (let i = 0; i < n; i++) {
      res.push(x);
      x = fBuild(x);
    }
    return res;
  }
}
function getRandomPerlenKeys(di, n) { return choose(Object.keys(di), n); }
function getRandomPicto() { let key = getRandomKey(iconChars); }
function getRandomPixelColor(img) {
  let canvas = mCreate('canvas');
  let ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);
  let [rx, ry] = [randomNumber(1, 100), randomNumber(1, 50)];
  console.log('______________', rx, ry)
  var p = ctx.getImageData(rx, ry, 1, 1).data;
  console.log('p', p)
  let rgb = `rgb(${p[0]},${p[1]},${p[2]})`;
  let x = rx, y = ry;
  var coord = "x=" + x + ", y=" + y;
  let color = colorFrom(rgb);
  console.log('pixel', coord, 'has color', color);
  return color;
}
function getRandomSetItem(lang = 'E', key, keylist) {
  if (nundef(keylist)) keylist = setCategories(['animal']);
  if (nundef(key)) key = chooseRandom(keylist);
  //#region individual keys for test
  //#endregion
  let info = jsCopy(picInfo(key));
  let valid, words;
  let oValid = info[lang + '_valid_sound'];
  if (isEmpty(oValid)) valid = []; else valid = sepWordListFromString(oValid, ['|']);
  let oWords = info[lang];
  if (isEmpty(oWords)) words = []; else words = sepWordListFromString(oWords, ['|']);
  let dWords = info.D;
  if (isEmpty(dWords)) dWords = []; else dWords = sepWordListFromString(dWords, ['|']);
  let eWords = info.E;
  if (isEmpty(eWords)) eWords = []; else eWords = sepWordListFromString(eWords, ['|']);
  words = isEnglish(lang) ? eWords : dWords;
  info.eWords = eWords;
  info.dWords = dWords;
  info.words = words;
  info.best = Syms[key][Settings.language];
  info.valid = valid;
  currentLanguage = lang;
  return info;
}
function getRandomShape() { return chooseRandom(['ellipse', 'roundedRect', 'rect', 'hex']); }
function getRandomUidNodeWithAct(R) {
  let cands = Object.values(R.uiNodes).filter(x => isdef(x.act) && isdef(x.oid));
  if (isEmpty(cands)) return null;
  let n = chooseRandom(cands);
  return n;
}
function getRandomVowel(w, except = []) { let vowels = getVowels(w, except); return chooseRandom(vowels); }
function getRandomWP(min = 0, max = 35) { let n = randomNumber(min, max); console.log('wp', n); return jsCopy(WordP[n]); }
function getRect(elem, relto) {
  if (isString(elem)) elem = document.getElementById(elem);
  let res = elem.getBoundingClientRect();
  if (isdef(relto)) {
    let b2 = relto.getBoundingClientRect();
    let b1 = res;
    res = {
      x: b1.x - b2.x,
      y: b1.y - b2.y,
      left: b1.left - b2.left,
      top: b1.top - b2.top,
      right: b1.right - b2.right,
      bottom: b1.bottom - b2.bottom,
      width: b1.width,
      height: b1.height
    };
  }
  let r = { x: res.left, y: res.top, w: res.width, h: res.height };
  addKeys({ l: r.x, t: r.y, r: r.x + r.w, b: r.t + r.h }, r);
  return r;
}
function getRectInt(elem, relto) {
  if (isString(elem)) elem = document.getElementById(elem);
  let res = elem.getBoundingClientRect();
  if (isdef(relto)) {
    let b2 = relto.getBoundingClientRect();
    let b1 = res;
    res = {
      x: b1.x - b2.x,
      y: b1.y - b2.y,
      left: b1.left - b2.left,
      top: b1.top - b2.top,
      right: b1.right - b2.right,
      bottom: b1.bottom - b2.bottom,
      width: b1.width,
      height: b1.height
    };
  }
  let r4 = { x: Math.round(res.left), y: Math.round(res.top), w: Math.round(res.width), h: Math.round(res.height) };
  extendRect(r4);
  return r4;
}
function getRelativeIds(id) { return getList(id2ids[id]); }
function getRelBounds(elem, elRel) {
  let b1 = elem.getBoundingClientRect();
  if (!elRel) return b1;
  let b2 = elRel.getBoundingClientRect();
  return {
    x: b1.x - b2.x,
    y: b1.y - b2.y,
    left: b1.left - b2.left,
    top: b1.top - b2.top,
    right: b1.right - b2.right,
    bottom: b1.bottom - b2.bottom,
    width: b1.width,
    height: b1.height
  };
}
function getRelCoords(ev, elem) {
  let x = ev.pageX - elem.offset().left;
  let y = ev.pageY - elem.offset().top;
  return { x: x, y: y };
}
function getRelCoordsX(ev, elem) {
  let x = ev.pageX - elem.getBoundingClientRect().left;
  let y = ev.pageY - elem.getBoundingClientRect().top;
  return { x: x, y: y };
}
function getRoomNE(house) { return firstCond(house.rooms, x => isNorthRoom(house, Items[x]) && isEastRoom(house, Items[x])); }
function getRoomNW(house) { return firstCond(house.rooms, x => isNorthRoom(house, Items[x]) && isWestRoom(house, Items[x])); }
function getRoomSE(house) {
  let rooms = house.rooms.map(x => Items[x]);
  for (const r of rooms) {
    let isSouth = isSouthRoom(house, r);
    let isEast = isEastRoom(house, r);
  }
  return firstCond(house.rooms, x => isSouthRoom(house, Items[x]) && isEastRoom(house, Items[x]));
}
function getRoomSW(house) { return firstCond(house.rooms, x => isSouthRoom(house, Items[x]) && isWestRoom(house, Items[x])); }
function getScaledSizeCss(sz, scale) { return `${sz.w * scale}px ${sz.h * scale}px`; }
function getServerObject(oid) { return serverData.table[oid] ? serverData.table[oid] : serverData.players[oid]; }
function getSet(o, key) {
  if (!(key in o) || (!('set' in o[key]) && !('xset' in o[key]))) return null;
  else if ('set' in o[key]) return o[key].set;
  else return o[key].xset;
}
function getShortestWord(list, preferFirst = true) {
  let res = list[0];
  if (preferFirst) {
    for (let i = 1; i < list.length; i++) {
      if (list[i].length < res.length) res = list[i];
    }
  } else {
    for (let i = 1; i < list.length; i++) {
      if (list[i].length <= res.length) res = list[i];
    }
  }
  return res;
}
function getSignalColor() { if (currentLevel != 4 && currentLevel != 7 && currentLevel != 10 && currentLevel != 3) return 'red'; else return 'yellow'; }
function getSimpleSetElements(o) { return getValueArray(o); }
function getSimpleStyles(sz, family, bg, fg) {
  let styles = { bg: bg, fg: 'contrast', align: 'center', 'box-sizing': 'border-box', padding: 4, margin: 2 };
  let textStyles = { family: family };
  let picStyles = { w: sz, h: sz, bg: fg };
  return [styles, picStyles, textStyles];
}
function getSize(elem) { let r = getRectInt(elem); return { w: r.w, h: r.h, sz: Math.min(r.w, r.h) }; }
function getSizeNeeded(elem) {
  var d = elem.cloneNode(true);
  d.style.width = 'auto';
  document.body.appendChild(d);
  let cStyles = {};
  cStyles.position = 'fixed';
  cStyles.opacity = 0;
  cStyles.top = '-9999px';
  mStyle(d, cStyles);
  height = d.clientHeight;
  width = d.clientWidth;
  d.parentNode.removeChild(d);
  return { w: Math.round(width), h: Math.round(height) };
}
function getSizeWithStyles(text, styles) {
  var d = document.createElement("div");
  document.body.appendChild(d);
  let cStyles = jsCopy(styles);
  cStyles.position = 'fixed';
  cStyles.opacity = 0;
  cStyles.top = '-9999px';
  mStyleX(d, cStyles);
  d.innerHTML = text;
  height = d.clientHeight;
  width = d.clientWidth;
  d.parentNode.removeChild(d);
  return { w: width, h: height };
}
function getSizeWithStylesX(text, styles, wmax, hmax) {
  var d = document.createElement("div");
  document.body.appendChild(d);
  let cStyles = jsCopy(styles);
  cStyles.position = 'fixed';
  cStyles.opacity = 0;
  cStyles.top = '-9999px';
  if (isdef(wmax)) cStyles.width = wmax;
  if (isdef(hmax)) cStyles.height = wmax;
  mStyleX(d, cStyles);
  d.innerHTML = text;
  height = d.clientHeight;
  width = d.clientWidth;
  let x = getBounds(d)
  d.parentNode.removeChild(d);
  let res = { w: x.width, h: x.height };
  return res;
}
function getSizing(n, R, currentSizing) {
  return isdef(n.params) && isdef(n.params.sizing) ? n.params.sizing
    : isdef(currentSizing) ? currentSizing : R.defs.defaultSizing;
}
function getStandardAreaNameForKey(key) { return 'm_A_' + key; }
function getStandardAreaNameForPlayerProp(pid, propName) { return 'area_' + pid + '_' + propName; }
function getStandardFz(wi, hi, showPic, showLabels, wLongest) {
  let hText = showPic ? hi / 3 : hi;
  return showLabels ? idealFontSize(wLongest, wi, hText) : 0;
}
function getStandardFzPic(wi, hi, showLabels) { return Math.min(wi * .8, showLabels ? hi * .6 : hi * .75); }
function getStartLevels(user) {
  let udata = lookup(DB, ['users', user]);
  if (!udata) return 'not available';
  let res = [];
  let res2 = {};
  for (const g in udata.games) {
    res2[g] = udata.games[g].startLevel;
    res.push(g + ': ' + udata.games[g].startLevel);
  }
  return res2;
}
function getStyledItems(words, bgFunc, fgFunc = 'contrast', fzFunc) {
  let items = [];
  if (isString(bgFunc)) { bgFunc = () => bgFunc; }
  if (isLiteral(fzFunc)) { fzFunc = () => fzFunc; }
  if (isString(fgFunc)) { fgFunc = () => fgFunc; }
  else if (nundef(fgFunc)) fgFunc = (i, w, bg) => colorIdealText(bg);
  for (let i = 0; i < words.length; i++) {
    let w = words[i];
    let bg = bgFunc(i, w);
    let fg = fgFunc(i, w, bg);
    let item = { w: w, bg: bg, fg: fg, i: i, fz: fzFunc(i, w) };
    items.push(item)
  }
  return items;
}
function getStyledItems1(words, bgFunc, fgFunc = 'contrast', fzFunc) {
  let items = [];
  if (isString(bgFunc)) { bgFunc = () => bgFunc; }
  if (isLiteral(fzFunc)) { fzFunc = () => fzFunc; }
  if (isString(fgFunc)) { fgFunc = () => fgFunc; }
  else if (nundef(fgFunc)) fgFunc = (i, w, bg) => colorIdealText(bg);
  for (let i = 0; i < words.length; i++) {
    let w = words[i];
    let bg = bgFunc(i, w);
    let fg = fgFunc(i, w, bg);
    let item = { w: w, bg: bg, fg: fg, i: i, fz: fzFunc(i, w) };
    items.push(item)
  }
  return items;
}
function getStyleProp(elem, prop) { return getComputedStyle(elem).getPropertyValue(prop); }
function getSudokuPattern(r, c) {
  let patterns = {
    44: [
      [[0, 1, 2, 3], [2, 3, 0, 1], [3, 0, 1, 2], [1, 2, 3, 0]],
      [[0, 1, 2, 3], [3, 2, 0, 1], [2, 3, 1, 0], [1, 0, 3, 2]],
      [[0, 1, 2, 3], [2, 3, 0, 1], [1, 0, 3, 2], [3, 2, 1, 0]],
    ],
  };
  return chooseRandom(patterns['' + r + c]);
}
function getSudokuPatternFromDB(r, c, index) {
  let key = '' + r + 'x' + c;
  let numSamples = Object.keys(DB.games.gColoku.samples[key]).length;
  if (nundef(index)) index = randomNumber(0, numSamples - 1); else if (index >= numSamples) index = 1;
  let sample = DB.games.gColoku.samples[key][index];
  let pattern = sudokuSampleToIndexMatrix(sample.sol, r, c);
  let puzzle = sudokuSampleToIndexMatrix(sample.min, r, c);
  return { pattern: pattern, puzzle: puzzle };
}
function getSuitName(suit) {
  return suit === 0 ? 'spades' : suit === 1 ? 'hearts' : suit === 2 ? 'clubs' : suit === 3 ? 'diamonds' : 'joker';
}
function getSym(key, lang = 'E') {
  let info = jsCopy(picInfo(key));
  if (nundef(info.bestD)) { info.bestE = info.E.key; return info; }
  let valid, words;
  let oValid = info[lang + '_valid_sound'];
  if (isEmpty(oValid)) valid = []; else valid = sepWordListFromString(oValid, ['|']);
  let oWords = info[lang];
  if (isEmpty(oWords)) words = []; else words = sepWordListFromString(oWords, ['|']);
  let dWords = info.D;
  if (isEmpty(dWords)) dWords = []; else dWords = sepWordListFromString(dWords, ['|']);
  let eWords = info.E;
  if (isEmpty(eWords)) eWords = []; else eWords = sepWordListFromString(eWords, ['|']);
  words = isEnglish(lang) ? eWords : dWords;
  info.eWords = eWords;
  info.dWords = dWords;
  info.words = words;
  info.best = arrLast(words);
  info.valid = valid;
  currentLanguage = lang;
  return info;
}
function getTables() { return U.tables; }
function getTabletopCardsArea() {
  let msTable = getMainArea(defaultTabletopCardsAreaName);
  if (!msTable) { msTable = _makeTabletopCardsArea('a_d_game'); }
  return msTable;
}
function getTextAreaCurrentLine(el) {
  let line = '';
  if (el instanceof HTMLTextAreaElement) {
    line = el.value.slice(el.value.lastIndexOf('\n', el.selectionStart - 1) + 1,
      ((end = el.value.indexOf('\n', el.selectionStart)) => end > -1 ? end : undefined)());
  }
  return line;
}
function getTextAreaCurrentWord(el) {
  let line = '', w = '', prefix = '';
  if (el instanceof HTMLTextAreaElement) {
    let s = el.value;
    let i_caret = el.selectionEnd;
    let i_last_break_before_caret = s.lastIndexOf('\n', i_caret - 1); if (i_last_break_before_caret < 0) i_last_break_before_caret = 0;
    let i_next_break = s.indexOf('\n', i_caret); if (i_next_break < 0) i_next_break = s.length - 1;
    let i_caret_within_line = i_caret - i_last_break_before_caret;
    line = s.slice(i_last_break_before_caret + 1, i_next_break);
    let pos = i_caret_within_line - 2;
    console.log('_________\nline:', line, '\ni_caret=' + i_caret, 'i_in_line=' + pos);
    for (let i = pos; i >= 0; i--) {
      let ch = line[i];
      if (isAlphaNum(ch)) w = ch + w; else break;
    }
    prefix = w;
    for (let i = pos + 1; i < line.length; i++) {
      let ch = line[i];
      if (isAlphaNum(ch)) w = w + ch; else break;
    }
  }
  return [w, prefix];
}
function getTextColor(c) {
  let rgb = c
    .substring(4, c.indexOf(')'))
    .split(', ')
    .map(x => parseInt(x));
  let o = Math.round((parseInt(rgb[0]) * 299 + parseInt(rgb[1]) * 587 + parseInt(rgb[2]) * 114) / 1000);
  return o > 125 ? 'black' : 'white';
}
function getTextForFraction(num, denom) {
  let s = '' + num + '&frasl;' + denom; return s;
}
function getTextForFractionX(num, denom) {
  if (num == denom) return '1';
  else if (denom == 1) return num;
  else if (num / denom > 2) {
    let mixed = getMixedNumber(num, denom);
    return getTextForMixed(mixed.full, mixed.n, mixed.d);
  } else {
    let s = '' + num + '&frasl;' + denom; return s;
  }
}
function getTextForMixed(full, num, denom) {
  let s = '' + full;
  if (isdef(num) && isdef(denom)) s += ' ' + num + '&frasl;' + denom;
  return s;
}
function getTextSize(s = 'hallo', parentDivOrId) {
  var newDiv = document.createElement("div");
  newDiv.innerHTML = s;
  newDiv.style.cssText = "position:fixed; top:-9999px; opacity:0;"
  if (isdef(parentDivOrId)) {
    if (isString(parentDivOrId)) parentDivOrId = document.getElementById(parentDivOrId);
    parentDivOrId.appendChild(newDiv);
  } else {
    document.body.appendChild(newDiv);
  }
  height = newDiv.clientHeight;
  width = newDiv.clientWidth;
  newDiv.parentNode.removeChild(newDiv)
  return { w: width, h: height };
}
function getTextSizeX(text, fz, family, weight = 900, parentDivOrId = null, styles = {}) {
  var d = document.createElement("div");
  styles.fz = fz;
  styles.family = family;
  styles['font-weight'] = weight;
  styles.position = 'fixed';
  styles.opacity = 0;
  styles.top = '-9999px';
  styles.w = 200;
  mStyleX(d, styles);
  d.innerHTML = text;
  if (isdef(parentDivOrId)) {
    if (isString(parentDivOrId)) parentDivOrId = document.getElementById(parentDivOrId);
    parentDivOrId.appendChild(d);
  } else {
    document.body.appendChild(d);
  }
  height = d.clientHeight;
  width = d.clientWidth;
  d.parentNode.removeChild(d)
  return { w: width, h: height };
}
function getTextSizeX1(text, fz, family, weight = 900, parentDivOrId = null, styles = {}) {
  var d = document.createElement("div");
  styles.fz = fz;
  styles.family = family;
  styles['font-weight'] = weight;
  styles.position = 'fixed';
  styles.opacity = 0;
  styles.top = '-9999px';
  mStyleX(d, styles);
  d.innerHTML = text;
  if (isdef(parentDivOrId)) {
    if (isString(parentDivOrId)) parentDivOrId = document.getElementById(parentDivOrId);
    parentDivOrId.appendChild(d);
  } else {
    document.body.appendChild(d);
  }
  height = d.clientHeight;
  width = d.clientWidth;
  return { w: width, h: height, d: d };
}
function getTextWidth(text, font) {
  var canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement('canvas'));
  var context = canvas.getContext('2d');
  context.font = font;
  var metrics = context.measureText(text);
  return metrics.width;
}
function getTimeElapsed() { return TimeElapsed + msElapsedSince(TimestampStarted); }
function getTransformInfo(gElement) {
  var matrix = gElement.getCTM();
  let info = decomposeMatrix(matrix);
  return info;
}
function getTransformInfoDOM(d) {
  let info = parseComplexStyleProperty(d.style.transform);
  if (info.translate) {
    let s = info.translate.split(',');
    info.translateX = s[0].trim();
    info.translateY = s.length > 1 ? s[1].trim() : s[0].trim();
  }
  if (!isdef(info.translateX)) info.translateX = '0px';
  if (!isdef(info.translateY)) info.translateY = '0px';
  if (info.scale) {
    let s = info.scale.split(',');
    info.scaleX = s[0].trim();
    info.scaleY = s.length > 1 ? s[1].trim() : s[0].trim();
  }
  if (!isdef(info.scaleX)) info.scaleX = '1';
  if (!isdef(info.scaleY)) info.scaleY = '1';
  if (!isdef(info.rotation)) info.rotation = '0';
  for (const k in info) {
    if (!isNumber(info[k])) info[k] = firstNumber(info[k]);
  }
  return info;
}
function getTranslateX(myElement) {
  var style = window.getComputedStyle(myElement);
  var matrix = new WebKitCSSMatrix(style.webkitTransform);
  console.log('translateX: ', matrix.m41);
}
function getTranslateY(myElement) {
  var style = window.getComputedStyle(myElement);
  var matrix = new WebKitCSSMatrix(style.webkitTransform);
  console.log('translateX: ', matrix.m41);
}
function getTransPalette(color = '#000000') {
  let res = [];
  for (const alpha of [.0, .1, .2, .3, .4, .5, .6, .7, .8, .9, 1]) res.push(colorTrans(color, alpha));
  return res;
}
function getTransPalette9(color = '#000000') {
  let res = [];
  for (const alpha of [.1, .2, .3, .4, .5, .6, .7, .8, .9]) res.push(colorTrans(color, alpha));
  return res;
}
function getTriangleDownPoly(x, y, w, h) {
  let tridown = [[-0.5, 0.5], [0.5, 0.5], [-0.5, 0.5]];
  return getPoly(tridown, x, y, w, h);
}
function getTriangleUpPoly(x, y, w, h) {
  let triup = [[0, -0.5], [0.5, 0.5], [-0.5, 0.5]];
  return getPoly(triup, x, y, w, h);
}
function getTupleGroups() {
  let act = G.serverData.options;
  let tupleGroups = [];
  for (const desc in act) {
    let tg = { desc: desc, tuples: [] };
    let tuples = expand1_99(act[desc].actions);
    if (tuples.length == 1 && !isList(tuples[0])) tuples = [tuples];
    tg.tuples = tuples;
    tupleGroups.push({ desc: desc, tuples: tuples });
  }
  return tupleGroups;
}
function getTuples(data) {
  let tuples = [];
  if ('actions' in data) {
    tuples = expand(data.actions);
    tuples.sort();
    if (!empty(tuples) && tuples.length == 1 && !Array.isArray(tuples[0])) {
      tuples = [tuples];
    }
  }
  return tuples;
}
function getTurnPlayer() {
  return T.players[T.index];
}
function getTypeOf(param) {
  let type = typeof param;
  if (type == 'string') {
    return 'string';
  }
  if (type == 'object') {
    type = param.constructor.name;
    if (startsWith(type, 'SVG')) type = stringBefore(stringAfter(type, 'SVG'), 'Element').toLowerCase();
    else if (startsWith(type, 'HTML')) type = stringBefore(stringAfter(type, 'HTML'), 'Element').toLowerCase();
  }
  let lType = type.toLowerCase();
  if (lType.includes('event')) type = 'event';
  return type;
}
function getUID(pref = '') {
  UIDCounter += 1;
  return pref + '_' + UIDCounter;
}
function getUIObject(id) { return UIS[id]; }
function getUis(olist, func) { return olist.map(o => func(o)); }
function getUnitOwner(nationality) {
  if (nationality == 'Germany' || nationality == 'Italy') {
    return 'Axis';
  } else if (nationality == 'USSR') {
    return 'USSR';
  } else if (nationality == 'Britain' || nationality == 'France' || nationality == 'USA') {
    return 'West';
  } else {
    return 'Minor';
  }
}
function getUser(idPlayer) { return G.playersAugmented[idPlayer].username; }
function getuser_1send() {
  get_data('getuser', {});
}
function getuser_2handleResult(result) {
  Userdata = JSON.parse(result);
  Userdata.image = Userdata.username + '.jpg';
  Username = Userdata.username;
  let d = mBy('dUserInfo');
  clearElement(d);
  let dParent = mDiv(d);
  let dir = '../base/assets/images/';
  let path = dir + (Userdata.hasImage ? Username : 'unknown_user') + '.jpg';
  let size = 100;
  let styles = { 'object-fit': 'cover', rounding: '50%', margin: 10, h: size, w: size, border: '2px solid white' };
  let dUserImage = mImg(path, dParent, styles);
  dUserImage.id = 'dUserImage';
  let dUserName = mText(Username, d, { fz: 14, family: 'opensans' });
  dUserName.id = 'dUserName';
  let dUserEmail = mText(Userdata.email, d, { fz: 12, opacity: .5, family: 'opensans' });
  dUserEmail.id = 'dUserEmail';
}
function getUsername(idPlayer) { return getUser(idPlayer); }
function getUsernameForPlayer(id) {
  let players = S.gameConfig.players;
  let pl = firstCond(players, x => x.id == id);
  let uname = pl.username;
  return uname;
}
function getUsernameForPlid(id) { return playerConfig[GAME].players[id].username; }
function getUsers() { return Object.keys(DB.users); }
function getUserStartLevel(game) { return valf(lookup(U, ['games', game, 'startLevel']), 0); }
function getUserStartLevel_dep(game) { gInfo = U.games[game]; level = isdef(gInfo) && isdef(gInfo.startLevel) ? gInfo.startLevel : 0; return level; }
function getValueArray(o, elKey = 'obj', arrKey = '_set') {
  let raw = jsCopy(o);
  if (isdef(o[arrKey])) {
    raw = raw[arrKey];
  }
  if (isDict(raw)) {
    raw = odict2olist(raw);
  }
  if (!isList(raw)) return [];
  if (raw.length > 0 && raw[0][elKey]) {
    raw = raw.map(x => x[elKey]);
  }
  return raw;
}
function getValueInPixel(val, relto) {
  if (isNumber(val)) return val;
  val = firstNumber(val);
  return val * relto / 100;
}
function getVerticalOverflow(element) { return element.scrollHeight - element.clientHeight; }
function getVisibleChild(id) { for (const ch of mBy(id).children) if (ch.style.display != 'none') return ch.id; }
function getVisibleList(o) {
  return o.visible._set;
}
function getVisibleSet(o) {
  return getSet(o, 'visible');
  if (!('visible' in o) || (!('set' in o.visible) && !('xset' in o.visible))) return null;
  else if ('set' in o.visible) return o.visible.set;
  else return o.visible.xset;
}
function getVisual(oid) { return UIS[getMainId(oid)]; }
function getVisuals(oid) {
  let mk = UIS[getMainId(oid)];
  if (mk || USE_OLD_GRID_FUNCTIONS) return mk;
  let oids = oid2ids[oid];
  if (!oids || !IdOwner.m) return null;
  return intersection(IdOwner.m, oid2ids[oid]).map(x => UIS[x]);
}
function getVowels(w, except = []) {
  w = w.toLowerCase();
  let vowels = 'aeiouy';
  let res = [];
  for (let i = 0; i < w.length; i++) {
    if (vowels.includes(w[i]) && !except.includes(w[i])) res.push({ i: i, letter: w[i] });
  }
  return res;
}
function getWordSize(text, fz, family, weight = 900) {
  let st = {
    fz: fz,
    display: 'inline-block',
    bg: 'green',
    family: family,
    weight: weight, //900, //'bold', //weight, //'bold',
  };
  return getSizeWithStyles(text, st);
}
function getWordSize_dep(text, fz, family, weight = 900) {
  console.log('hier!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
  var d = document.createElement("div");
  document.body.appendChild(d);
  d.innerHTML = text;
  d.style.fontSize = fz + 'px';
  d.style.position = 'fixed';
  d.style.fontFamily = family;
  d.style.fontWeight = 900;
  let b = getBounds(d);
  height = d.clientHeight;
  width = d.clientWidth;
  return { w: width, h: height };
}
function getWordSize2(text, fz, family, weight = 900) {
  var d = document.createElement("div");
  document.body.appendChild(d);
  d.style.fontSize = fz + 'px';
  d.style.opacity = 0;
  d.style.position = 'fixed';
  d.style.top = '-9999px';
  d.style.display = 'inline-block';
  d.style.backgroundColor = 'green';
  d.style.fontFamily = family;
  d.style.fontWeight = weight; //'bold';
  d.innerHTML = text;
  height = d.clientHeight;
  width = d.clientWidth;
  d.parentNode.removeChild(d)
  return { w: width, h: height };
}
function getWrongChars() { return getQChars().filter(x => getInputStringOfChar(x) != x.letter); }
function getWrongWords() { return getQWords().filter(x => getInputStringOfWord(x) != x.word); }
function getZoomFactor(gElement) {
  var matrix = gElement.getCTM();
  let info = decomposeMatrix(matrix);
  return info.scale;
}
function gFg(g, color, thickness) { g.setAttribute('stroke', color); if (thickness) g.setAttribute('stroke-width', thickness); }
function gG() { return gCreate('g'); }
function gHex(w, h) { let pts = size2hex(w, h); return gPoly(pts); }
function gInfo(n, R, uidParent) {
  let pf = n.params;
  n.uiType = 'g';
  let ui = gShape(pf.shape, pf.size, pf.size, pf.bg, pf.rounding);
  let gParent = findAncestorElemWithParentOfType(mBy(uidParent), 'svg');
  gParent.appendChild(ui);
  n.idUiParent = gParent.id;
  if (n.content) {
    let bgText = pf.bgText ? pf.bgText : null;
    let color = nundef(pf.fg) ? nundef(pf.bgText) ? null : colorIdealText(pf.bgText) : pf.fg;
    n.label = agText(ui, n.content, color, bgText, pf.font);
    calcRays(n, gParent, R);
  }
  if (pf.border) {
    let th = isdef(pf.thickness) ? pf.thickness : 1;
    let color = decodeColor(pf.border);
    let ch = ui.children[0];
    ch.setAttribute('stroke', color);
    ch.setAttribute('stroke-width', th);
  }
  positionGElement(ui, uidParent, gParent);
  return ui;
}
function giRep(gi, dParent, styles, shape, prefix, content) {
  gi = isString(gi) ? gi[1] == '_' ? Items[gi] : Items[name2id(gi)] : gi;
  let id = gi.id;
  let name = gi.name;
  let d = mShape(shape, dParent, styles);
  d.id = (isdef(prefix) ? prefix : '') + id;
  let key = isdef(prefix) ? prefix : 'div';
  d.innerHTML = content;
  let di = {}; di[key] = d; iAdd(gi, di);
  return d;
}
function give_each_jolly_group(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    pl.journeys.push(['4Hn', '4Sn', '*Hn']);
    pl.goals['3'] = true; pl.roundgoal = '3';
  }
  fen.players[uplayer].hand.push('4Cn');
}
function give_one_player_0_coins(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let otherplayer = firstCond(fen.plorder, (p) => p != uplayer);
  let pl = fen.players[otherplayer];
  pl.coins = 0;
}
function give_other_blackmailed_building(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let b1 = stage_building(fen, 1, 'farm'); b1.rumors = ['KHr'];
  b1.isblackmailed = true;
  set_queen_phase(o);
}
function give_other_jolly_group(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let otherplayer = firstCond(fen.plorder, (p) => p != uplayer);
  let pl = fen.players[otherplayer];
  pl.journeys.push(['2Hn', '2Sn', '*Hn']);
  pl.goals['3'] = true; pl.roundgoal = '3';
  fen.players[uplayer].hand.push('2Cn');
}
function give_other_jolly_sequence(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let otherplayer = firstCond(fen.plorder, (p) => p != uplayer);
  let pl = fen.players[otherplayer];
  pl.journeys.push(['KHn', 'AHn', '*Hn', '3Hn', '4Hn', '5Hn', '6Hn']);
  pl.goals['7R'] = true; pl.roundgoal = '7R';
  fen.players[uplayer].hand.push('2Hn', '5Hn', 'JHn', 'QHn');
}
function give_other_various_buildings(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let other = firstCond(o.fen.plorder, (p) => p != uplayer);
  return give_various_buildings_to(o, other);
}
function give_player_7R(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let pl = fen.players[uplayer];
  pl.hand = ['7Cn', '8Cn', 'TCn', 'JCn', 'QCn', 'KCn', 'ACn', '*Hn', '8Cn', '2Hn', '2Sn', '2Hn'];
  let otherplayer = firstCond(fen.plorder, (p) => p != uplayer);
  let plother = fen.players[otherplayer];
  plother.hand.unshift('9Cn', '2Sn', '2Hn', '6Cn', '5Cn');
}
function give_player_achieve_5(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let pl = fen.players[uplayer];
  pl.hand = ['6Hn', '6Hn', '6Hn', '6Hn', '*Hn', '4Cn', '4Cn', '4Cn', '3Dn', '3Dn', '2Sn', 'KHn', 'QSn'];
  for (const plname of fen.plorder) {
    if (plname == uplayer) continue;
    let pl1 = fen.players[plname];
    pl1.journeys = [['2Cn', '2Hn', '*Hn']];
  }
}
function give_player_group(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let pl = fen.players[uplayer];
  pl.journeys = [['2Hn', '2Sn', '2Hn']];
}
function give_player_hand_group(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let pl = fen.players[uplayer];
  pl.hand = ['2Hn', '2Sn', '2Hn', '3Hn', '3Sn', '3Hn', '4Hn', '4Sn', '*Hn'];
}
function give_player_hand_groups(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let pl = fen.players[uplayer];
  pl.hand = ['2Hn', '2Hn', '2Sn', '2Cn', '3Sn', '3Hn', '4Hn', '4Sn', '*Hn'];
}
function give_player_jolly(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let pl = fen.players[uplayer];
  pl.hand.push('*Hn');
}
function give_player_jolly_sequence(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let pl = fen.players[uplayer];
  pl.journeys.push(['KHn', 'AHn', '*Hn', '3Hn', '4Hn', '5Hn', '6Hn']);
  pl.goals['7R'] = true; pl.roundgoal = '7R';
  fen.players[uplayer].hand.push('2Hn', 'JHn', 'QHn');
}
function give_player_king(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  fen.players[uplayer].hand.push('KHn');
}
function give_player_luxury_cards(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  fen.players[uplayer].hand.push('AHl', 'AHl', 'AHl');
}
function give_player_multiple_commission_cards(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let pl = fen.players[uplayer];
  pl.hand.push('QCn', 'QHn');
  pl.stall.push('QDn', 'QSn');
  pl.commissions.push('QCc');
}
function give_player_one_ferro_set(o) {
  o.fen.players[o.fen.turn[0]].hand = ['*Hn', 'KHn', 'KCn'];
}
function give_player_only_4_cards(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  fen.players[uplayer].hand = ['AHn', 'AHn'];
  fen.players[uplayer].stall = ['ACn', 'ASn'];
}
function give_player_only_one_card(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let pl = fen.players[uplayer];
  pl.hand = ['4Hn'];
}
function give_player_queen(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  fen.players[uplayer].hand.push('QHn');
}
function give_player_sequence(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let pl = fen.players[uplayer];
  pl.hand = ['2Sn', '3Sn', '4Sn', '5Sn', '6Sn', '7Sn', '8Sn', '9Sn', 'ASn'];
}
function give_player_two_ferro_sets(o) {
  o.fen.players[o.fen.turn[0]].hand = ['*Hn', 'KHn', 'KCn', 'QHn', 'QCn', 'QDn'];
}
function give_player_various_buildings(o) {
  let plname = o.fen.turn[0];
  return give_various_buildings_to(o, plname);
}
function give_players_buildings(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  stage_correct_buildings(fen, { mimi: { estate: 1 }, amanda: { chateau: 1 } });
  fen.stage = 5;
  fen.phase = 'king';
}
function give_players_buildings_plus(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let di = {};
  for (const plname of fen.plorder) { di[plname] = { estate: 1, farm: 1, chateau: 1 }; }
  stage_correct_buildings(fen, di);
  ari_add_harvest_cards(fen);
  fen.stage = o.stage = 5;
  fen.phase = 'king';
}
function give_players_empty_stalls(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let n = rChoose([2, 3]);
  fen.market = deck_deal(fen.deck, 2);
  fen.stage = 4, fen.actionsCompleted = [], fen.stallSelected = jsCopy(fen.plorder);
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    pl.stall = [];
    pl.stall_value = 0;
  }
}
function give_players_hand_A2(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    pl.hand = ['ACn', '2Cn', '3Cn', '5Hn', '7Hn', '7Sn', '7Cn', '7Dn'];
  }
  [fen.stage, fen.turn] = set_journey_or_stall_stage(fen, o.options, fen.phase);
}
function give_players_hand_journey(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    arrExtend(pl.hand, ['ACn', '2Cn', '3Cn']);
  }
}
function give_players_schwein(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  for (let i = 0; i < fen.plorder.length; i++) {
    let b = stage_building(fen, i, 'farm');
    b.h = 'KHn';
    b.schweine = [2];
    let b1 = stage_building(fen, i, 'estate');
  }
  [fen.turn, fen.stage] = [[uplayer], 5];
  fen.phase = 'king';
}
function give_players_schwein_old(o, isOpen = true) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let b = stage_building(fen, 1, 'farm');
  b.h = 'KHn';
  if (isOpen) b.schweine = [b.list[2]];
  fen.stage = 5;
  fen.phase = 'king';
}
function give_players_schweine_variety(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let b = stage_building_new(fen, 1, 'farm', 1, 1);
  b = stage_building_new(fen, 1, 'farm', 1, 0);
  b = stage_building_new(fen, 1, 'farm', 0, 0);
  b = stage_building_new(fen, 1, 'farm', 0, 1);
  b = stage_building_new(fen, 1, 'farm', 0, 2);
  b = stage_building(fen, 0, 'farm'); b.h = 'KHn'; b.schweine = [2];
  [fen.turn, fen.stage] = [[uplayer], 5];
  fen.phase = 'king';
}
function give_players_stalls(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let n = rChoose([2, 3]);
  fen.market = deck_deal(fen.deck, 2);
  fen.stage = 4, fen.actionsCompleted = [], fen.stallSelected = jsCopy(fen.plorder);
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    for (let i = 0; i < n; i++)  top_elem_from_to(pl.hand, pl.stall);
    pl.stall_value = calc_stall_value(fen, plname);
  }
}
function give_various_buildings_to(o, plname) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let i = fen.plorder.indexOf(plname);
  let b1 = stage_building(fen, i, 'farm'); b1.rumors = ['KHr'];
  let b2 = stage_building(fen, i, 'farm');
  let lead = b2.lead;
  b2.rumors = ['4Cr', `${lead[0]}Cr`];
  let b3 = stage_building(fen, i, 'farm');
  return plname;
}
function glabel(el, val, { bg, fg, contrastBackground = false, force = true, shrinkFont = false, wrap = false, fz = 20 } = {}) {
  let mobj = el.mobj;
  if (contrastBackground) {
    unitTestMS('.................fill black!!!');
    mobj.text({ txt: val, force: force, shrinkFont: shrinkFont, wrap: wrap, fz: fz, bg: 'white', fill: 'black' });
  } else {
    mobj.text({ txt: val, force: force, shrinkFont: shrinkFont, wrap: wrap, fz: fz, bg: bg, fill: fg });
  }
}
function glabels(board, ids, func, { bg, fg, contrastBackground = false, force = true, shrinkFont = false, wrap = false, fz = 20 } = {}) {
  for (const id of ids) {
    let el = board.objects[id];
    let val = func(el);
    glabel(el, val, { bg: bg, fg: fg, contrastBackground: contrastBackground, force: force, shrinkFont: shrinkFont, wrap: wrap, fz: fz });
  }
}
function gLine(x1, y1, x2, y2) { let r = gCreate('line'); r.setAttribute('x1', x1); r.setAttribute('y1', y1); r.setAttribute('x2', x2); r.setAttribute('y2', y2); return r; }
function gMaze() {
  function maze_fen() { return 'nix'; }
  function maze_prompt(g, fen) {
    let [rows, cols, sz, gap] = [g.rows, g.cols, g.sz, g.gap];
    clear_graph();
    let maze = new MazeGraph(dTable, rows, cols, sz, gap);
    setRectInt(maze.dGraph);
    mLinebreak(dTable, 12);
    let cellStart = maze.getTopLeftCell();
    mCellContent(iDiv(cellStart), { w: '60%', h: '60%', fz: '50%', padding: '5%', bg: 'green', fg: 'white', rounding: '50%' }, 'A');
    let cellGoal = maze.getBottomRightCell();
    mCellContent(iDiv(cellGoal), { w: '60%', h: '60%', fz: '50%', padding: '5%', bg: 'red', fg: 'white', rounding: '50%' }, 'B');
    let [roomFrom, roomTo] = [cellStart.nodeId, cellGoal.nodeId];
    if (isdef(fen)) {
      let instruction = mText('game over!', dTable, { fz: 24, display: 'inline-block' });
      return;
    }
    let instruction = mText('is there a path from A to B?', dTable, { fz: 24, display: 'inline-block' });
    mLinebreak(dTable);
    let path = maze.getShortestPathFromTo(roomFrom, roomTo);
    console.assert(path.length < Infinity, 'WAAAAAAAAAAAAAAS?');
    if (coin()) maze.cutPath(path, .5, .75);
    let len = maze.getLengthOfShortestPath(roomFrom, roomTo);
    let is_yes = len != Infinity;
    let byes = mButton('yes', (ev) => maze_eval(is_yes, ev), dTable, { fz: 20 }, ['donebutton', 'buttonClass']);
    let bno = mButton('no', (ev) => maze_eval(!is_yes, ev), dTable, { fz: 20 }, ['donebutton', 'buttonClass']);
    if (is_yes) { Goal = { b_correct: byes, b_wrong: bno, is_yes: true, maze: maze, path: path }; }
    else { Goal = { b_correct: bno, b_wrong: byes, is_yes: false, maze: maze, path: path }; }
    animatePropertyX(dTable, 'opacity', [0, 0, 1], 500, 'both', 'ease', 0);
  }
  function maze_eval(is_correct, ev) {
    if (!canAct()) return;
    uiActivated = false; clear_timeouts();
    let button_clicked = ev.target;
    race_set_fen();
    race_update_my_score(is_correct ? 1 : -1);
    let delay = maze_feedback(is_correct, button_clicked);
    setTimeout(() => {
      in_game_open_prompt_off();
      clear_table_events();
      race_send_move();
    }, delay);
  }
  function clear_graph() { if (nundef(Goal)) return; let cy = lookup(Goal, ['maze', 'cy']); if (cy) cy.destroy(); }
  function maze_feedback(is_correct, button_clicked, show_feedback = true) {
    let delay = !is_correct && show_feedback ? 1000 : 100;
    if (!is_correct) {
      mStyle(Goal.b_correct, { bg: 'green' });
      animate(Goal.b_correct, 'komisch', 1000);
      if (Goal.is_yes) Goal.maze.breadCrumbs(Goal.path); else Goal.maze.colorComponents();
    }
    if (is_correct) { mStyle(button_clicked, { bg: 'green' }); mCheckit(button_clicked, 100); }
    else { mXit(button_clicked); }
    return delay;
  }
  return {
    prompt: maze_prompt,
    fen: maze_fen,
  }
}
function go_offline() { DA.internet = false; }
function go_online() { DA.internet = true; }
function goalHasNumber() {
  let ws = Goal.info.words;
  return firstCond(ws, x => isNumber(x));
}
function goalHasNumberOrTimeString() {
  return goalHasNumber() || goalHasTimeString();
}
function goalHasTimeString() {
  let ws = Goal.info.words;
  return firstCond(ws, x => isTimeString(x));
}
function got_create_table(obj) { Session.cur_tid = obj.table.id; Session.cur_table = obj.table; present_table(obj); }
function got_dictionary(obj) {
  let lang = obj.lang;
  let x = obj.dict;
  Dictionary[lang] = to_words(x);
  return;
  let keys = get_keys(obj).filter(x => endsWith(x, 'dict'));
  console.log('keys', keys)
  if (isEmpty(keys)) return;
  if (nundef(Dictionary)) Dictionary = {};
  let l = obj.lang;
  for (const k of keys) {
    if (nundef(Dictionary[l])) {
      Dictionary[l] = to_words(obj[k]);
    }
  }
}
function got_games(obj) {
  let tables = obj.tables;
  let bygame = set_tables_by_game(obj, false);
  set_most_recent_table_as_cur_tid(tables);
  present_games();
}
function got_intro(obj) {
  Session.users = obj.users;
  Session.users_by_name = {};
  for (const u of Session.users) {
    Session.users_by_name[u.username] = u;
    if (isdef(DB.users[u.username])) { copyKeys(DB.users[u.username], u); }
  }
  present_intro();
}
function got_modify_table(obj) { Session.cur_tid = obj.table.id; Session.cur_table = obj.table; present_table(obj); }
function got_non_admin_reload(obj) {
  in_game_off();
  in_game_open_prompt_off();
  console.log('got_non_admin reload: obj', obj)
  set_tables_by_game(obj);
  tables = obj.tables;
  if (isEmpty(tables)) {
    console.assert(nundef(Session.cur_tid), 'reload no table still cur_tid!!!!!')
    get_user_in_intro_screen();
  } else {
    get_play_start();
  }
}
function got_play(obj) { present_table(obj); }
function got_play_start(obj) {
  console.log('got_play_start', obj);
  let table = obj.table;
  console.log('fen', table.fen);
  let lang = get_preferred_lang(Session.cur_user);
  set_start_data_from_fen(obj.table.fen, obj.table.game);
  let lang2 = get_preferred_lang(Session.cur_user);
  if (lang != lang2) get_dictionary();
  present_table(obj);
}
function got_send_move(obj) { present_table(obj); }
function got_tables(obj) {
  set_tables_by_game(obj);
  if (isdef(Session.cur_tid)) { get_play(); } else get_games();
}
function got_user_game_tables(obj) {
  let tables = obj.tables;
  if (!isEmpty(tables)) { Session.cur_tid = tables[0].id; Session.cur_table = tables[0]; }
}
function got_user_in_intro_screen() {
  show('dIntro'); clearElement('dIntro');
  intro_show_user_image(Session.cur_user);
  present_wait_for_table_to_start();
}
function gotNumberOrTimeString(answer) {
  if (isNumber(answer) || isTimeString(answer)) return true; else return false;
}
function gPanel(n, R, area) {
  gParent = mBy(area);
  n.idUiParent = gParent.id;
  if (isdef(n.ui)) {
    delete n.changing;
    return n.ui;
  }
  let ui = agG(gParent);
  n.uiType = 'g';
  return ui;
}
function gPoly(pts) { let r = gCreate('polygon'); if (pts) r.setAttribute('points', pts); return r; }
function gPos(g, x, y) { g.style.transform = `translate(${x}px, ${y}px)`; }
function gRect(w, h) { let r = gCreate('rect'); r.setAttribute('width', w); r.setAttribute('height', h); r.setAttribute('x', -w / 2); r.setAttribute('y', -h / 2); return r; }
function gRectPartOnArea() {
  let g = new MMS({ parent: UIS.a_d_game }).setDefaults({ bg: 'powderBlue' }).attach();
  let ms = new MMS({ parent: g }).rect({ w: 50, h: 50, bg: 'blue' }).attach();
  console.log(ms.elem)
}
function grid(id, rows, cols, size, bg = 'blue') {
  visualStructures[id] = [];
  let w = size * cols;
  let h = size * rows;
  let ms = new MS(id, 'g')
    .setbg(getpal(3))
    .rect({ w: w, h: h });
  ms.tag('layout', 'grid');
  visualStructures[id].push(ms);
  return (r, c) => {
    return {
      x: c * size - w / 2 + size / 2,
      y: r * size - h / 2 + size / 2,
      id: id,
      ms: ms
    };
  };
}
function gridLabeled(list, picLabelStyles) {
  let dGrid = mDiv(mBy('table'));
  let elems = [];
  let isText = true;
  let isOmoji = false;
  let pictureSize = 200;
  let stylesForLabelButton = { rounding: 10, margin: pictureSize / 8 };
  for (const k of list) {
    let info = symbolDict[k];
    let label = info.type == 'emo' ? (isdef(info.bestE) ? info.bestE : lastOfLanguage(k, 'E')) + ' ' + lastIndex
      : k;
    let el = maPicLabelButtonFitText(info, label,
      { w: pictureSize, h: pictureSize, bgPic: 'random', shade: null, contrast: null },
      onClickIVPicture, dGrid, stylesForLabelButton, 'frameOnHover', isText, isOmoji);
    el.id = 'pic' + lastIndex;
    elems.push(el);
    Pictures.push({ div: el, info: info, label: label, isSelected: false });
    lastIndex += 1;
  }
  let gridStyles = { 'place-content': 'center', gap: 4, margin: 4, padding: 4, bg: 'silver', rounding: 5 };
  let size = layoutGrid(elems, dGrid, gridStyles, { rows: 10, isInline: true });
  console.log('lastIndex', lastIndex)
}
function gridLabeledX(keyList, labelList, dParent, { rows, layout } = {}, clickHandler) {
  let dGrid = mDiv(dParent);
  let elems = [];
  let isText = true;
  let isOmoji = false;
  let pictureSize = 200;
  let stylesForLabelButton = { rounding: 10, margin: pictureSize / 8 };
  let pics = [];
  for (let i = 0; i < keyList.length; i++) {
    let k = keyList[i];
    let info = symbolDict[k];
    let label = labelList[i];
    let el = maPicLabelButtonFitText(info, label,
      { w: pictureSize, h: pictureSize, bgPic: 'random', shade: null, contrast: null },
      clickHandler, dGrid, stylesForLabelButton, 'frameOnHover', isText, isOmoji);
    el.id = 'pic' + lastIndex;
    elems.push(el);
    pics.push({ div: el, info: info, label: label, isSelected: false });
    lastIndex += 1;
  }
  let gridStyles = { 'place-content': 'center', gap: 4, margin: 4, padding: 4, bg: 'silver', rounding: 5 };
  let func = (layout == 'flex' ? layoutFlex : layoutGrid);
  let size = func(elems, dGrid, gridStyles, { rows: rows, isInline: true });
  return pics;
}
function gridLayout(nuiBoard, R) {
  calcBoardDimensionsX(nuiBoard, R);
  let [fw, fh] = [nuiBoard.fw, nuiBoard.fh];
  let boardDiv = mBy(nuiBoard.uidDiv);
  let svg = mBy(nuiBoard.uidSvg);
  let g = mBy(nuiBoard.uid);
  mStyle(boardDiv, { 'min-width': nuiBoard.wTotal, 'min-height': nuiBoard.hTotal });
  nuiBoard.sizeMeasured = { w: nuiBoard.wTotal, h: nuiBoard.hTotal };
  nuiBoard.size = jsCopy(nuiBoard.sizeMeasured);
  for (const fid of nuiBoard.children) {
    let f = R.uiNodes[fid];
    if (f.params.shape == 'line') {
      let line = f.ui.firstChild;
      if (nundef(line)) {
        agLine(f.ui, f.info.x1 * fw, f.info.y1 * fw, f.info.x2 * fw, f.info.y2 * fw);
      } else {
        line.setAttribute('x1', f.info.x1 * fw);
        line.setAttribute('y1', f.info.y1 * fw);
        line.setAttribute('x2', f.info.x2 * fw);
        line.setAttribute('y2', f.info.y2 * fw);
      }
      f.pos = { x: (f.info.x1 * fw + f.info.x2 * fw) / 2, y: (f.info.y1 * fw + f.info.y2 * fw) / 2 };
    } else {
      f.pos = { x: (fw * f.info.x), y: (fh * f.info.y) };
      gPos(f.ui, fw * f.info.x, fh * f.info.y);
    }
  }
  g.style = `transform: translate(${nuiBoard.wTotal / 2}px, ${nuiBoard.hTotal / 2}px)`;
}
function gridSkeleton(omap, R, gridInfoFunc, fieldInfoFunc) {
  let board = { o: omap, info: gridInfoFunc(omap.rows, omap.cols) };
  let fields = {};
  for (const fid of getElements(omap.fields)) {
    let o = R.getO(fid);
    fields[fid] = { oid: fid, o: o, info: fieldInfoFunc(board.info, o.row, o.col) };
  }
  board.info.vertices = correctPolys(Object.values(fields).map(x => x.info.poly), 1);
  let dhelp = {};
  let corners = {};
  for (const fid in fields) {
    let f = fields[fid];
    let i = 0;
    for (const cid of getElements(f.o.corners)) {
      if (cid && nundef(dhelp[cid])) {
        let pt = f.info.poly[i];
        corners[cid] = { oid: cid, o: R.getO(cid), info: { shape: 'circle', memType: 'corner', x: pt.x, y: pt.y, w: 1, h: 1 } };
        dhelp[cid] = true;
      }
      i += 1;
    }
  }
  dhelp = {};
  let edges = {};
  for (const fid in fields) {
    let f = fields[fid];
    for (const eid of getElements(f.o.edges)) {
      if (eid && nundef(dhelp[eid])) {
        let el = R.getO(eid);
        let n1 = corners[el.corners[0]._obj];
        let n2 = corners[el.corners[1]._obj];
        let [x1, y1, x2, y2] = [n1.info.x, n1.info.y, n2.info.x, n2.info.y];
        edges[eid] = { oid: eid, o: el, info: { shape: 'line', memType: 'edge', x1: x1, y1: y1, x2: x2, y2: y2, x: (x1 + x2) / 2, y: (y1 + y2) / 2, thickness: 1, w: 1, h: 1 } };
        dhelp[eid] = true;
      }
    }
  }
  return { board: board, fields: fields, corners: corners, edges: edges };
}
function gRounding(r, rounding) {
  r.setAttribute('rx', rounding);
  r.setAttribute('ry', rounding);
}
function groupSizes() {
  ensureSymBySet();
  for (const gname in symKeysBySet) {
    console.log('group', gname + ': ' + symKeysBySet[gname].length);
  }
}
function growIfDefaultMainAreaWidth(mobj) {
  let wElem = mobj.parts.table.offsetWidth;
  let areaName = mobj.idParent;
  if (isdef(wElem) && isdef(AREAS[areaName])) {
    let wNeeded = wElem + 40;
    let wArea = UIS[areaName].w;
    if (wArea < wNeeded || wArea > wNeeded + 100) {
      setAreaWidth(areaName, wNeeded);
    }
  }
}
function growIfDefaultPlayerAreaWidthblablabla_UNUSED(mobj) {
  let wElem = mobj.parts.table.offsetWidth;
  let areaName = mobj.idParent;
  if (isdef(wElem) && isdef(AREAS[areaName])) {
    let wNeeded = wElem + 40;
    let wArea = UIS[areaName].w;
    if (wArea < wNeeded || wArea > wNeeded + 100) {
      setAreaWidth(areaName, wNeeded);
    }
  }
}
function gSet() {
  function set_fen() {
    let items = Session.items;
    let fen = items.map(x => x.fen).join(',');
    return fen;
  }
  function set_prompt(g, fen) {
    let [n, rows, cols] = [g.num_attrs, g.rows, g.cols];
    let all_attrs = gSet_attributes();
    let attrs_in_play = arrTake(get_keys(all_attrs), n);
    let deck = g.deck = make_set_deck(n);
    shuffle(deck);
    let goal = Goal = { set: make_goal_set(deck, g.prob_different), cards: [] };
    let dCards = stdRowsColsContainer(dTable, cols, styles = { bg: 'transparent' });
    let card_styles = { w: cols > 4 ? 130 : 160 };
    let items = g.items = [];
    let deck_rest = arrWithout(deck, goal.set);
    let fens = choose(deck_rest, rows * cols - 3);
    let all_fens = goal.set.concat(fens);
    shuffle(all_fens);
    if (isdef(fen)) { all_fens = fen.split(','); }
    for (const f of all_fens) {
      let item = create_set_card(f, dCards, card_styles);
      let d = iDiv(item);
      mStyle(d, { cursor: 'pointer' });
      d.onclick = set_interact;
      if (Goal.set.includes(item.fen)) Goal.cards.push(item);
      items.push(item);
    }
    g.selected = [];
    return items;
  }
  function set_interact(ev) {
    ev.cancelBubble = true;
    if (!canAct()) { console.log('no act'); return; }
    let id = evToId(ev);
    if (isdef(Items[id])) {
      let item = Items[id];
      toggleSelectionOfPicture(item, Session.selected);
      if (Session.selected.length == 3) {
        let correct = check_complete_set(Session.selected.map(x => x.fen));
        if (correct) {
          Selected = { isCorrect: true, feedbackUI: Session.selected.map(x => iDiv(x)) };
        } else {
          Selected = { isCorrect: false, correctUis: Goal.cards.map(x => iDiv(x)), feedbackUI: null, animation: 'onPulse1' };
        }
        set_eval();
      }
    }
  }
  function set_eval() {
    if (!canAct()) return;
    uiActivated = false; clear_timeouts();
    IsAnswerCorrect = Selected.isCorrect;
    race_set_fen();
    race_update_my_score(IsAnswerCorrect ? 1 : 0);
    let delay = show_feedback(IsAnswerCorrect);
    setTimeout(() => {
      in_game_open_prompt_off();
      clear_table_events();
      race_send_move();
    }, delay);
  }
  return {
    prompt: set_prompt,
    fen: set_fen,
  }
}
function gSet_attributes() {
  const all_attrs = {
    shape: ['circle', 'triangle', 'square'],
    color: [RED, BLUE, GREEN],
    num: [1, 2, 3],
    shading: ['solid', 'empty', 'gradient'],
    background: ['white', 'grey', 'black'],
    text: ['none', 'letter', 'number'],
  };
  return all_attrs;
}
function gShape(shape, w = 20, h = 20, color = 'green', rounding) {
  let el = gG();
  if (nundef(shape)) shape = 'rect';
  if (shape != 'line') agColoredShape(el, shape, w, h, color);
  else gStroke(el, color, w);
  if (isdef(rounding) && shape == 'rect') {
    let r = el.children[0];
    gRounding(r, rounding);
  }
  return el;
}
function gSize(g, w, h, shape = null, iChild = 0) {
  let el = (getTypeOf(g) != 'g') ? g : g.children[iChild];
  let t = getTypeOf(el);
  switch (t) {
    case 'rect': el.setAttribute('width', w); el.setAttribute('height', h); el.setAttribute('x', -w / 2); el.setAttribute('y', -h / 2); break;
    case 'ellipse': el.setAttribute('rx', w / 2); el.setAttribute('ry', h / 2); break;
    default:
      if (shape) {
        switch (shape) {
          case 'hex': let pts = size2hex(w, h); el.setAttribute('points', pts); break;
        }
      }
  }
  return el;
}
function gSizeToContent(svg) {
  var bbox = svg.getBBox();
  svg.setAttribute("width", bbox.x + bbox.width + bbox.x);
  svg.setAttribute("height", bbox.y + bbox.height + bbox.y);
}
function gSpotit() {
  function spotit_fen() {
    let items = Session.items;
    console.log('items', items)
    let fen = items.map(x => x.keys.join(' ')).join(',');
    let item_fens = [];
    for (const item of items) {
      let arr = arrFlatten(item.pattern);
      let ifen = arr.map(x => `${x.key}:${x.scale}`).join(' ');
      item_fens.push(ifen);
    }
    fen = item_fens.join(',');
    return fen;
  }
  function spotit_prompt(g, fen) {
    g.items = spotit_deal(g.num_cards, g.rows, g.cols, g.vocab, g.lang, g.min_scale, g.max_scale, fen);
  }
  function spotit_interact(ev) {
    ev.cancelBubble = true;
    if (!canAct()) { console.log('no act'); return; }
    let keyClicked = evToProp(ev, 'key');
    let id = evToId(ev);
    if (isdef(keyClicked) && isdef(Items[id])) {
      let item = Items[id];
      if (Object.values(item.shares).includes(keyClicked)) {
        let otherCard = spotitFindCardSharingSymbol(item, keyClicked);
        let cardSymbol = ev.target;
        let otherSymbol = spotitFindSymbol(otherCard, keyClicked);
        Selected = { isCorrect: true, feedbackUI: [cardSymbol, otherSymbol] };
      } else {
        let cardSymbol = ev.target;
        Selected = { isCorrect: false, feedbackUI: [cardSymbol], correctUis: spotit_get_shared_symbols(), correctionDelay: Session.items.length * 1500 };
      }
      spotit_eval();
    }
  }
  function spotit_eval() {
    if (!canAct()) return;
    uiActivated = false; clear_timeouts();
    IsAnswerCorrect = Selected.isCorrect;
    race_set_fen();
    race_update_my_score(IsAnswerCorrect ? 1 : 0);
    let delay = show_feedback(IsAnswerCorrect);
    setTimeout(() => {
      in_game_open_prompt_off();
      clear_table_events();
      race_send_move();
    }, delay);
  }
  function spotit_card(info, dParent, cardStyles, onClickSym) {
    CSZ = 300;
    copyKeys({ w: CSZ, h: CSZ }, cardStyles);
    let card = cRound(dParent, cardStyles, info.id);
    addKeys(info, card);
    let d = iDiv(card);
    let zipped = [];
    for (let i = 0; i < card.keys.length; i++) {
      zipped.push({ key: card.keys[i], scale: card.scales[i] });
    }
    card.pattern = fillColarr(card.colarr, zipped);
    let symStyles = { sz: CSZ / (card.rows + 1), fg: 'random', hmargin: 8, vmargin: 4, cursor: 'pointer' };
    let syms = [];
    mRowsX(iDiv(card), card.pattern, symStyles, { 'justify-content': 'center' }, { 'justify-content': 'center' }, syms);
    for (let i = 0; i < info.keys.length; i++) {
      let key = card.keys[i];
      let sym = syms[i];
      card.live[key] = sym;
      sym.setAttribute('key', key);
      sym.onclick = onClickSym;
    }
    return card;
  }
  function spotit_deal(numCards, rows, cols, vocab, lang, min_scale, max_scale, fen) {
    lang = valf(lang, 'E');
    let colarr = _calc_hex_col_array(rows, cols);
    if (rows == 3 && cols == 1) { colarr = [1, 3, 1]; }
    else if (rows == 2 && cols == 1) { colarr = [1, 2]; }
    else if (rows == 4 && cols == 1) { rows = 3; colarr = [2, 3, 1]; }
    else if (rows == 5 && cols == 1) { rows = 4; cols = 1; colarr = [1, 3, 3, 1]; }
    else if (rows == 5 && cols == 3) { rows = 5; cols = 1; colarr = [1, 3, 4, 3, 1]; }
    else if (rows == 6 && cols == 2) { rows = 5.5; colarr = [2, 4, 5, 4, 2]; }
    else if (rows == 6 && cols == 3) { rows = 5.8; colarr = [2, 4, 5, 4, 3]; }
    let perCard = arrSum(colarr);
    let nShared = (numCards * (numCards - 1)) / 2;
    let nUnique = perCard - numCards + 1;
    let numKeysNeeded = nShared + numCards * nUnique;
    let nMin = numKeysNeeded + 3;
    let keypool = setKeys({ nMin: nMin, lang: valf(lang, 'E'), key: valf(vocab, 'animals'), keySets: KeySets, filterFunc: (_, x) => !x.includes(' ') });
    let keys = choose(keypool, numKeysNeeded);
    let dupls = keys.slice(0, nShared);
    let uniqs = keys.slice(nShared);
    let infos = [];
    for (let i = 0; i < numCards; i++) {
      let keylist = uniqs.slice(i * nUnique, (i + 1) * nUnique);
      let info = { id: getUID(), shares: {}, keys: keylist, rows: rows, cols: cols, colarr: colarr, num_syms: perCard };
      infos.push(info);
    }
    let iShared = 0;
    for (let i = 0; i < numCards; i++) {
      for (let j = i + 1; j < numCards; j++) {
        let c1 = infos[i];
        let c2 = infos[j];
        let dupl = dupls[iShared++];
        c1.keys.push(dupl);
        c1.shares[c2.id] = dupl;
        c2.shares[c1.id] = dupl;
        c2.keys.push(dupl);
      }
    }
    for (const info of infos) { shuffle(info.keys); }
    for (const info of infos) {
      info.scales = info.keys.map(x => chooseRandom([.5, .75, 1, 1.25]));
    }
    if (!isEmpty(fen)) {
      let ks_for_cards = fen.split(',');
      for (let i = 0; i < infos.length; i++) {
        let info = infos[i];
        let ks_list = ks_for_cards[i].split(' ');
        info.keys = ks_list.map(x => stringBefore(x, ':'));
        info.scales = ks_list.map(x => stringAfter(x, ':')).map(x => Number(x));
      }
    }
    let items = [];
    for (const info of infos) {
      let item = spotit_card(info, dTable, { margin: 20 }, spotit_interact);
      items.push(item);
    }
    return items;
  }
  function spotit_get_shared_symbols() {
    let result = [];
    for (const item of Session.items) {
      for (const id in item.shares) {
        let k = item.shares[id];
        let ui = iGetl(item, k);
        result.push(ui);
      }
    }
    return result;
  }
  //#region future: verbessere die art wie symbols auf card verteilt (unused)
  function spotit_colarr_settings(num) {
    let di = {
      3: { rows: 2, colarr: [1, 2] },
      4: { rows: 2, colarr: [2, 2] },
      5: { rows: 2.5, colarr: [2, 3] },
      6: { rows: 3, colarr: [1, 2] },
      7: { rows: 3, colarr: [1, 2] },
      8: { rows: 3.2, colarr: [1, 2] },
      9: { rows: 2, colarr: [1, 2] },
      10: { rows: 2, colarr: [1, 2] },
      11: { rows: 2, colarr: [1, 2] },
      12: { rows: 2, colarr: [1, 2] },
      13: { rows: 2, colarr: [1, 2] },
      14: { rows: 2, colarr: [1, 2] },
      15: { rows: 2, colarr: [1, 2] },
    }
    let colarr = _calc_hex_col_array(rows, cols);
    if (rows == 3 && cols == 1) { colarr = [1, 3, 1]; }
    else if (rows == 2 && cols == 1) { colarr = [1, 2]; }
    else if (rows == 4 && cols == 1) { rows = 3; colarr = [2, 3, 1]; }
    else if (rows == 5 && cols == 1) { rows = 4; cols = 1; colarr = [1, 3, 3, 1]; }
    else if (rows == 3 && cols == 3) { rows = 3; cols = 3; colarr = [1, 3, 3, 1]; }
    else if (rows == 5 && cols == 3) { rows = 5; cols = 1; colarr = [1, 3, 4, 3, 1]; }
    else if (rows == 6 && cols == 2) { rows = 5.5; colarr = [2, 4, 5, 4, 2]; }
  }
  function spotit_deal_new_not_yet(numCards, rows, colarr, vocab, lang, min_scale, max_scale, fen) {
    lang = valf(lang, 'E');
    let perCard = arrSum(colarr);
    let nShared = (numCards * (numCards - 1)) / 2;
    let nUnique = perCard - numCards + 1;
    let numKeysNeeded = nShared + numCards * nUnique;
    let nMin = numKeysNeeded + 3;
    let keypool = setKeys({ nMin: nMin, lang: valf(lang, 'E'), key: valf(vocab, 'animals'), keySets: KeySets, filterFunc: (_, x) => !x.includes(' ') });
    let keys = choose(keypool, numKeysNeeded);
    let dupls = keys.slice(0, nShared);
    let uniqs = keys.slice(nShared);
    let infos = [];
    for (let i = 0; i < numCards; i++) {
      let keylist = uniqs.slice(i * nUnique, (i + 1) * nUnique);
      let info = { id: getUID(), shares: {}, keys: keylist, rows: rows, cols: cols, colarr: colarr, num_syms: perCard };
      infos.push(info);
    }
    let iShared = 0;
    for (let i = 0; i < numCards; i++) {
      for (let j = i + 1; j < numCards; j++) {
        let c1 = infos[i];
        let c2 = infos[j];
        let dupl = dupls[iShared++];
        c1.keys.push(dupl);
        c1.shares[c2.id] = dupl;
        c2.shares[c1.id] = dupl;
        c2.keys.push(dupl);
      }
    }
    for (const info of infos) { shuffle(info.keys); }
    for (const info of infos) {
      info.scales = info.keys.map(x => chooseRandom([.6, .75, 1, 1.25]));
    }
    if (!isEmpty(fen)) {
      let ks_for_cards = fen.split(',');
      for (let i = 0; i < infos.length; i++) {
        let info = infos[i];
        let ks_list = ks_for_cards[i].split(' ');
        info.keys = ks_list.map(x => stringBefore(x, ':'));
        info.scales = ks_list.map(x => stringAfter(x, ':')).map(x => Number(x));
      }
    }
    let items = [];
    for (const info of infos) {
      let item = spotit_card(info, dTable, { margin: 20 }, spotit_interact);
      items.push(item);
    }
    return items;
  }
  //#endregion
  return {
    prompt: spotit_prompt,
    fen: spotit_fen,
  }
}
function gStroke(g, color, thickness) { g.setAttribute('stroke', color); if (thickness) g.setAttribute('stroke-width', thickness); }
function gSvg() { return gCreate('svg'); }
function gTest00() {
  let g = new AbsGraph1();
  let nid1 = g.addNode();
  let nid2 = g.addNode();
  let eid1 = g.addEdge(nid1, nid2);
  console.log('g', g.getNodeIds(), g.getEdgeIds());
}
function gTest01() {
  let g = new AbsGraph1();
  let nids = g.addNodes(10);
  let eids = g.addEdges(15);
  console.log('g', g.getNodeIds(), g.getEdgeIds());
}
function gTest02() {
  initTable();
  let d = mDiv(dTable, { w: 500, h: 300, bg: 'blue', align: 'left' });
  let g = new SimpleGraph(d);
  let nids = g.addNodes(10);
  let eids = g.addEdges(15);
  console.log('g', g.getNodeIds(), g.getEdgeIds());
  g.cose();
  g.addLayoutControls();
}
function gTest03() {
  initTable();
  let d = mDiv(dTable, { w: 500, h: 360, bg: 'blue', align: 'left' });
  let g = new AbsGraph1(d);
  upgradeToSimpleGraph(g, d);
  let nids = g.addNodes(10);
  let eids = g.addEdges(15);
  console.log('g', g.getNodeIds(), g.getEdgeIds());
  g.cose();
  g.addLayoutControls();
}
function gTest04() {
  initTable();
  let d = mDiv(dTable, { w: 500, h: 360, bg: 'blue', align: 'left' });
  let g = new AbsGraph1(d);
  g.addVisual(d);
  let nids = g.addNodes(10);
  let eids = g.addEdges(15);
  console.log('g', g.getNodeIds(), g.getEdgeIds());
  g.cose();
  g.addLayoutControls(d);
}
function gTest05() {
  initTable();
  let hexPoints = [0, -1, 1, -0.5, 1, 0.5, 0, 1, -1, 0.5, -1, -0.5];
  let styles = {
    outer: { bg: 'pink', padding: 25 },
    inner: { w: 500, h: 400 },
    node: { shape: 'polygon', 'shape-polygon-points': hexPoints, w: 90, h: 100, bg: 'black', fg: 'red', fz: 40 }
  };
  let g = new UIGraph(dTable, styles);
  let nids = g.addNodes(7);
  console.log('g', g.getNodeIds(), g.getEdgeIds());
  g.hex1(3, 2, styles.node.w + 2, styles.node.h + 2);
  g.addLayoutControls();
  g.disableDD();
  g.nodeEvent('click', x => { let id = x.id(); console.log('clicked ' + id); g.mStyle(id, { bg: 'yellow', fg: 'blue' }); });
}
function gTest06() {
  initTable();
  let hexPoints = [0, -1, 1, -0.5, 1, 0.5, 0, 1, -1, 0.5, -1, -0.5];
  let styles = {
    outer: { bg: 'pink', padding: 25 },
    inner: { w: 500, h: 400 },
    node: { bg: 'pink' },
    edge: { bg: 'blue' }
    //'node.field':  { shape: 'polygon', 'shape-polygon-points': hexPoints, w: 90, h: 100, bg: 'black', fg: 'red', fz: 40 },
  };
  let g = new UIGraph(dTable, styles);
  let cy = g.cy;
  let nids = g.addNodes(10);
  let eids = g.addEdges(10);
  let node = g.getNodes()[0];
  node.addClass('high');
  g.cose();
  cy.style().selector('node.field').style('color', 'black');
  cy.style().selector('node.city').style('shape', 'hexagon');
  let node1 = g.getNodes()[1];
  node.addClass('city');
  node1.addClass('field');
}
function gTest07() {
  initTable();
  let hexPoints = [0, -1, 1, -0.5, 1, 0.5, 0, 1, -1, 0.5, -1, -0.5];
  let styles = {
    outer: { bg: 'pink', padding: 25 },
    inner: { w: 500, h: 400 },
    node: { bg: 'pink', shape: 'hex' },
    edge: { bg: 'blue' }
    //'node.field':  { shape: 'polygon', 'shape-polygon-points': hexPoints, w: 90, h: 100, bg: 'black', fg: 'red', fz: 40 },
  };
  let g = new UIGraph(dTable, styles);
  let cy = g.cy;
  let nids = g.addNodes(10);
  let eids = g.addEdges(10);
  let node = g.getNodes()[0];
  node.addClass('high');
  g.cose();
  cy.style().selector('node.field').style('color', 'black');
  cy.style().selector('node.city').style('shape', 'hexagon');
  let node1 = g.getNodes()[1];
  node.addClass('city');
  node1.addClass('field');
}
function gTest08() {
  initTable();
  let styles = {
    outer: { bg: 'pink', padding: 25 },
    inner: { w: 500, h: 400 },
    node: { bg: 'pink', shape: 'hex' },
    edge: { bg: 'green' }
  };
  let g = new UIGraph(dTable, styles);
  let nids = g.addNodes(10);
  let eids = g.addEdges(10);
  g.cose();
  g.addLayoutControls();
  let nodes = g.getNodes();
  console.log('nodes', nodes[0]);
  g.mStyle(nodes[0], { shape: 'ellipse', bg: 'black' });
}
function gTest09() {
  initTable();
  let [w, h] = [50, 50];
  let styles = {
    outer: { bg: 'pink', padding: 25 },
    inner: { w: 500, h: 400 },
    node: { bg: 'pink', shape: 'hex', w: w, h: h },
    edge: { bg: 'green' }
  };
  let g = new UIGraph(dTable, styles);
  let [rows, topcols] = [5, 3];
  let total = hex1Count(rows, topcols);
  console.log('for rows', rows, 'and cols', topcols, 'need', total, 'nodes')
  let nids = g.addNodes(total);
  g.hex1(rows, topcols, w + 4, h + 4);
  let indices = hex1Indices(rows, topcols);
  console.log('indices', indices);
  let ids = g.getNodeIds();
  console.log('node ids:', ids);
  let di = {};
  for (let i = 0; i < ids.length; i++) {
    let [row, col] = [indices[i].row, indices[i].col];
    let id = ids[i];
    lookupSet(di, [row, col], id);
    g.setProp(id, 'row', row);
    g.setProp(id, 'col', col);
    g.setProp(id, 'label', `${row},${col}`);
  }
  let labels = g.getNodes().map(x => x.data().label);
  console.log('labels', labels);
  let label = g.cy.getElementById(ids[1]).data('label');
  for (let i = 0; i < ids.length; i++) {
    let [row, col] = [indices[i].row, indices[i].col];
    let id = ids[i];
    let nid2 = lookup(di, [row, col + 2]); if (nid2) g.addEdge(id, nid2);
    nid2 = lookup(di, [row + 1, col - 1]); if (nid2) g.addEdge(id, nid2);
    nid2 = lookup(di, [row + 1, col + 1]); if (nid2) g.addEdge(id, nid2);
  }
  let deg = g.getDegree(ids[1]);
  let deg1 = g.getDegree(ids[10]);
  let deg2 = g.getDegree(ids[18]);
  console.log('das geht: label', label, deg, deg1, deg2);
}
function gTest10() {
  initTable();
  let [rows, topcols, w, h] = [7, 10, 50, 50];
  let styles = {
    outer: { bg: 'pink', padding: 25 },
    inner: { w: 500, h: 400 },
    node: { bg: 'pink', shape: 'hex', w: w, h: h },
    edge: { bg: 'green' }
  };
  let g = hex1Board(dTable, rows, topcols, styles);
}
function gTest11() {
  let g = createSampleHex1();
  let ids = g.getNodeIds();
  let id = ids[0];
  console.log('size', g.getSize(id), g.cy.getElementById(id).bb());
  let n = g.cy.getElementById(id);
  n.css({ width: '40px', height: '40px' });
  g.zoom(false);
  let bb = g.cy.elements().bb();
  console.log('gesamt graph braucht:', bb)
}
function gTest12() {
  let g = createSampleHex1(21, 11); let ids = g.getNodeIds(); let id = ids[0];
  g.showExtent();
}
function gTest13() {
  let g = createSampleHex1(3, 2, 100, 100); let ids = g.getNodeIds(); let id = ids[0]; g.showExtent();
  let center = g.getProp(id, 'center');
  console.log('center prop', center);
  center = g.posDict['preset'][id];
  console.log('center', center);
  let size = g.getSize(id);
  console.log('size', size);
  let pN = { x: center.x, y: size.y1 };
  let node = g.getNode(id);
  let b = node.renderedBoundingBox();
  pN = { x: b.x1 + b.w / 2, y: b.y1 };
  let nNew = g.addNode({ width: 25, height: 25 }, pN);
  console.log('new node', nNew);
  let n1 = g.getNode(nNew);
  n1.css('background-color', 'blue');
  let st = { bg: 'red', shape: 'ellipse', w: 25, h: 25 };
  let st1 = mStyleToCy(st);
  n1.css(st1);
}
function guest_update() {
  assertion(isdef(Z.fen), 'no fen');
  show_status();
  let mydata = firstCond(Z.playerdata, x => x.name == Clientdata.uid);
  if (isdef(mydata) && isdef(mydata.state) && isNumber(mydata.state.green)) {
    console.log('mydata.state', mydata.state);
    assertion(isdef(mydata.state), 'no state');
    for (const k of ['green', 'red']) {
      assertion(isNumber(mydata.state[k]), 'NAN state[' + k + ']');
      Clientdata.state[k] = Math.ceil((mydata.state[k] + Clientdata.state[k]) / 2);
    }
  }
  for (const k in Z.fen) {
    set_new_goal(k, Z.fen[k]);
  }
  autopoll();
}
function gZone(d, gid, vAnchor, hAnchor, wPercent, hPercent, bg, fg) {
  let svg1 = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  let wd = d.style.width;
  let hd = d.style.height;
  // let g1 = document.createElementNS('http://www.w3.org/2000/svg', 'g');
}
function h2rgb(h) {
  let r = Math.abs(h * 6 - 3) - 1;
  let g = 2 - Math.abs(h * 6 - 2);
  let b = 2 - Math.abs(h * 6 - 4);
  return saturate(float3(r, g, b));
}
function hackPhaseAndPlayerTest(msg) {
  testHelpers(msg);
  let res = stringAfterLast(msg, 'Beginning ');
  let phase = stringBefore(res, ' ');
  testHelpers(res, 'phase=' + phase);
  let res1 = stringAfter(res, '<br>');
  let player = stringBefore(res1, ' ');
  testHelpers(res1, 'player=' + player);
}
function hallo(control, map) {
  control.on('routeselected', function (e) {
    var coord = e.route.coordinates;
    var instr = e.route.instructions;
    L.geoJson(getInstrGeoJson(instr, coord)).addTo(map);
  });
}
function halloIchZeichneJetzt() {
  let isDrawing = false;
  let x = 0;
  let y = 0;
  const canvas = document.getElementById('sheet');
  let r = getRect(G.clientBoard.dOuter); r.left = r.x; r.top = r.y;
  console.log('rectBoard', r);
  canvas.width = r.w;
  canvas.height = r.h;
  var context = canvas.getContext('2d');
  canvas.onmousedown = e => {
    x = e.offsetX;
    y = e.offsetY;
    isDrawing = true;
  };
  canvas.onmousemove = e => {
    if (isDrawing === true) {
      drawLine(context, x, y, e.offsetX, e.offsetY);
      x = e.offsetX;
      y = e.offsetY;
    }
  };
  canvas.onmouseup = e => {
    if (isDrawing === true) {
      drawLine(context, x, y, e.offsetX, e.offsetY);
      x = 0;
      y = 0;
      isDrawing = false;
    }
  };
  var socket = io();
  socket.on('update_canvas', function (data) {
    let { x1, y1, x2, y2, color } = JSON.parse(data);
    drawLine(context, x1, y1, x2, y2, color, true);
  });
  function drawLine(context, x1, y1, x2, y2, color = selected_color, from_server = false) {
    if (!from_server)
      socket.emit('update_canvas', JSON.stringify({ x1, y1, x2, y2, color }));
    context.beginPath();
    context.strokeStyle = color;
    context.lineWidth = 5;
    context.lineCap = 'round'
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.stroke();
    context.closePath();
  }
}
function hand_select() {
  let res = prompt('enter player names: ');
  let parts = splitAtAnyOf(res, ' ,');
  let list = [];
  for (const p of parts) {
    let name = p.toLowerCase().trim();
    if (isdef(DB.users[name])) addIf(list, name);
  }
  list.sort(); list.unshift(Session.cur_user);
  populate_players(list);
}
function handLayout(n, R) {
  let uis = n.children.map(x => R.uiNodes[x].ui);
  let area = n.uid;
  let ch0 = R.uiNodes[n.children[0]];
  let size = ch0.params.size;
  console.log('I am in handLayout!!!!!!!!!!!!!!')
  if (nundef(size)) size = { w: 70, h: 110 };
  let [w, h, gap] = [size.w, size.h, 4];
  if (isEmpty(uis)) return [0, 0];
  let x = y = gap;
  let ov = n.params.overlap;
  ov /= 100;
  if (nundef(ov) || isNaN(ov)) ov = .20;
  let overlap = ov * w;
  let dParent = mBy(area);
  dParent.style.position = 'relative';
  console.log('_______________', x, y, gap, w, ov)
  uis.map(d => {
    mAppend(dParent, d);
    d.style.position = 'absolute';
    d.style.borderRadius = '12px';
    d.style.padding = '4px';
    mPos(d, x, y);
    x += overlap;
  });
  let sz = { w: x - overlap + w + gap, h: y + h + gap };
  console.log('x', x, 'w', w, 'y', y, 'h', h, 'gap', gap, 'sz', sz)
  dParent.style.minHeight = (sz.h) + 'px';
  dParent.style.minWidth = (sz.w) + 'px';
  return sz;
}
function handLayout_Wrapper(n, R) {
  let uis = n.children.map(x => R.uiNodes[x].ui.parentNode);
  let area = n.uid;
  let ch0 = R.uiNodes[n.children[0]];
  let size = ch0.params.size;
  let [w, h, gap] = [size.w, size.h, 4];
  if (isEmpty(uis)) return [0, 0];
  let x = y = gap;
  let ov = n.params.overlap / 100;
  if (nundef(ov)) ov = .20;
  console.log('overlap', ov, n.params);
  let overlap = .1 * w;
  let dParent = mBy(area);
  dParent.style.position = 'relative';
  uis.map(d => {
    mAppend(dParent, d);
    d.style.position = 'absolute';
    mPos(d, x, y);
    x += overlap;
  });
  let sz = { w: x - overlap + w + gap, h: y + h + gap };
  console.log('x', x, 'w', w, 'y', y, 'h', h, 'gap', gap, 'sz', sz)
  dParent.style.minHeight = (sz.h) + 'px';
  dParent.style.minWidth = (sz.w) + 'px';
  return sz;
}
function handle_bid() {
  let [z, A, fen, uplayer, ui] = [Z, Z.A, Z.fen, Z.uplayer, UI];
  let oldbid = jsCopy(fen.oldbid);
  let bid = jsCopy(fen.newbid);
  let ranks = '23456789TJQKA';
  bid = normalize_bid(bid);
  let higher = is_bid_higher_than(bid, oldbid);
  if (bid[2] == 0) bid[2] = '_';
  if (!higher) {
    select_error('the bid you entered is not high enough!');
  } else {
    fen.lastbid = fen.players[uplayer].lastbid = bid;
    fen.lastbidder = uplayer;
    delete fen.oldbid; delete fen.newbid;
    Z.turn = [get_next_player(Z, uplayer)];
    take_turn_fen();
  }
}
function handle_command(cmd) {
  switch (cmd) {
    case 'clear': G.selist = clear_select(G.selist); toolbar_check(); break;
    case 'next': push_hist(); inc_g_index(); break;
    case 'back': pop_hist(); dec_g_index(); break;
    default: console.log('do not know how to handle ***', cmd, '***'); break;
  }
  console.log('history', G.hist)
  console.log('current selection', G.selist.map(x => x.name));
}
function handle_connect(id) { console.log('connected', id); io.emit('message', 'someone logged in!'); }
function handle_disconnect(x) { console.log('disconnected', x); io.emit('message', x); }
function handle_drag_and_drop(e) {
  if (e.type == "dragover") {
    e.preventDefault();
    mClass(e.target, "dragging");
  } else if (e.type == "dragleave") {
    mClassRemove(e.target, "dragging");
  } else if (e.type == "drop") {
    let target = e.target;
    let id = target.id;
    mClassRemove(e.target, "dragging");
    console.log('===>dropped on target:', e.target);
    e.preventDefault();
    DA.imageChanged = true;
    mClassRemove(e.target, "dragging");
    mDropImage(e, e.target);
  } else {
    mClassRemove(e.target, "dragging");
  }
}
function handle_gamestate(gamestate) {
  if (!in_game_screen) {
    return;
  }
  gamestate = JSON.parse(gamestate);
  requestAnimationFrame(() => paint_game(gamestate));
}
function handle_gehtHoch() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  let [bid, bidder] = [fen.lastbid, fen.lastbidder];
  let diff = calc_bid_minus_cards(fen, bid);
  let aufheber = uplayer;
  let loser = diff > 0 ? bidder : aufheber;
  let war_drin = fen.war_drin = diff <= 0;
  let loser_handsize = inc_handsize(fen, loser);
  new_deal(fen);
  let nextplayer;
  if (loser_handsize > Z.options.max_handsize) {
    nextplayer = get_next_player(Z, loser)
    let plorder = fen.plorder = remove_player(fen, loser);
  } else {
    nextplayer = loser;
  }
  fen.loser = loser; fen.bidder = bidder; fen.aufheber = aufheber;
  bluff_change_to_ack_round(fen, nextplayer);
  take_turn_fen();
}
function handle_message(x) {
  console.log('from server:', x.msg);
}
function handle_result(result, cmd) {
  if (verbose) console.log('cmd', cmd, '\nresult', result);
  if (result.trim() == "") return;
  let obj;
  try { obj = JSON.parse(result); } catch { console.log('ERROR:', result); }
  if (Clientdata.AUTORESET) { Clientdata.AUTORESET = false; if (result.auto == true) { console.log('message bounced'); return; } }
  DA.result = jsCopy(obj);
  processServerdata(obj, cmd);
  switch (cmd) {
    case "assets": load_assets(obj); start_with_assets(); break;
    case "users": show_users(); break;
    case "tables": show_tables(); break;
    case "delete_table":
    case "delete_tables": show_tables(); break;
    case "table1":
      update_table();
      console.log('cmd', cmd)
      console.log('obj', obj)
      for (const k in obj) { if (isLiteral(obj[k])) { console.log(k, obj[k]); } }
      clear_timeouts();
      gamestep();
      break;
    case "gameover":
    case "table":
    case "startgame":
      update_table();
      if (Z.skip_presentation) { Z.func.state_info(mBy('dTitleLeft')); autopoll(); return; }
      clear_timeouts();
      gamestep();
      break;
  }
}
function handle_result_orig(result, type) {
  if (result.trim() == "") return;
  var obj = JSON.parse(result);
  if ('contacts chats games play account'.includes(type)) Session.cur_menu = type;
  switch (obj.data_type) {
    case "user_info":
      ensure_assets_old(obj);
      start_with_basic_assets();
      break;
    case "contacts":
      var inner_left_panel = mBy("inner_left_panel");
      inner_left_panel.innerHTML = createContactsContent(obj.myusers, obj.msgs);
      Session.others = obj.myusers.map(x => x.id);
      for (const u of obj.myusers) { add_live_user(u); }
      break;
    case "games":
      ensure_assets(obj);
      mBy('inner_left_panel').innerHTML = createGamesContent(dict2list(DB.games), obj.tables);
      mCenterCenterFlex(mBy('game_menu'));
      break;
    case "chats":
      if (isEmpty(Session.cur_chatter)) Session.cur_chatter = obj.other.username;
      console.log('CURRENT_CHAT_USER', Session.cur_chatter);
      SEEN_STATUS = false;
      var inner_left_panel = mBy("inner_left_panel");
      inner_left_panel.innerHTML = obj.mydata;
      inner_left_panel.innerHTML = createMessageContent(obj.messages, obj.me, obj.other);
      var messages_holder = mBy("messages_holder");
      setTimeout(function () {
        messages_holder.scrollTo(0, messages_holder.scrollHeight);
        var message_text = mBy("message_text");
        message_text.focus();
      }, 100);
      break;
    case "play":
      ensure_assets(obj);
      game_resume_or_start();
      break;
    case 'account':
      mBy("inner_left_panel").innerHTML = is_online() ? createAccountContent(obj.message) : createAccountContentNoDD(obj.message);
      break;
    case "send_message":
      sent_audio.play();
      get_chat();
      break;
    case "dbsave":
      break;
    case "send_image":
      alert(obj.message);
      get_chat();
      break;
    case "chats_refresh":
      SEEN_STATUS = false;
      var messages_holder = mBy("messages_holder");
      messages_holder.innerHTML = obj.messages;
      if (typeof obj.new_message != 'undefined') {
        if (obj.new_message) {
          received_audio.play();
          setTimeout(function () {
            messages_holder.scrollTo(0, messages_holder.scrollHeight);
            var message_text = mBy("message_text");
            message_text.focus();
          }, 100);
        }
      }
      break;
    case 'save_account':
      throw ("NEEEEEEEEEEEEEEEEEIIIIIIIIIIIIIIIIIIIIIIIIIN");
      if (obj.changed) window.location = "index.html?user=" + obj.message.username;
      else console.log('STILL SAME USERNAME', obj.message.username);
      break;
  }
}
function handle_settings(x) {
  console.log('message from server:', x.msg);
  settings = x.settings;
  defaults = x.defaults;
  console.log('settings:', settings);
  console.log('defaults:', defaults);
}
function handle_update(x) { console.log('got update', x); io.emit('update', x); }
function handleAction(x) {
  return [[x]];
}
function handleClientIdSendLogin(data) {
  logClientReceive('clientId', data);
  ClientId = data.clientId;
  sendLogin(valf(Username, 'hansi'));
}
function handleDB(data) {
  DB = data.DB;
  setUserData(Username);
  enterLobby();
}
function handleDbUpdate(data) { logClientReceive('dbUpdate', data); DB.standardSettings = data.standardSettings; }
function handleGameCode(gameCode) {
  gameCodeDisplay.innerText = gameCode;
}
function handleGameOver(data) {
  if (!gameActive) {
    return;
  }
  data = JSON.parse(data);
  gameActive = false;
  if (data.winner === playerNumber) {
    alert('You Win!');
  } else {
    alert('You Lose :(');
  }
}
function handleGameState(data) { logClientReceive('gameState', data); G.presentGameState(data); }
function handleHide(data) { hideMouseAvatar(data.username); }
function handleInitialPosition(data) {
  console.log('initial position:', data);
}
function handleListOfConstants(lst, n1, area, R) {
  for (const oid1 of lst) {
    let o1 = R.getO(oid1);
    let key = keysForOids[oid1];
    let ntree, nui;
    ntree = instantOidKey(oid1, key, n1.uid, R);
    nui = recUi(ntree, n1.uid, R, oid1, key);
  }
}
function handleListOfObjectIds(lst, n1, area, R) {
  createPanelParentOfObjects(lst, n1, area, R);
  let keysForOids = findOrCreateKeysForObjTypes(lst, R);
  for (const oid1 of lst) {
    let o1 = R.getO(oid1);
    let key = keysForOids[oid1];
    let ntree, nui;
    ntree = instantOidKey(oid1, key, n1.uid, R);
    nui = recUi(ntree, R, n1.uid, oid1, key);
  }
}
function handleMessage(data) {
  if (isdef(data.data)) data = data.data;
  logClientReceive('userMessage', data);
  if (isString(data)) {
    data.type = messageTypes.LEFT;
  } else if (data.author === U.username) {
    data.type = messageTypes.RIGHT;
  } else {
    data.type = messageTypes.LEFT;
  }
  messages.push(data);
  displayMessages();
  let chatWindow = mBy('dLobby')
  chatWindow.scrollTop = chatWindow.scrollHeight;
}
function handleMouse(data) {
  let [x, y] = [data.x, data.y];
  x += $('#dFieldArea').offset().left - $(window).scrollLeft();
  y += $('#dFieldArea').offset().top - $(window).scrollTop();
  moveAvatar(data.username, x, y);
}
function handleSet(x) {
  let irgend = x.map(expand1_99);
  let res = stripSet(irgend);
  return res;
}
function handleShow(data) { showMouseAvatar(data.username); }
function handleTooManyPlayers() {
  reset();
  alert('This game is already in progress');
}
function handleTuple(x) {
  let irgend = x.map(expand1_99);
  return multiCartesi(...irgend);
}
function handleUnknownCode() {
  reset();
  alert('Unknown Game Code')
}
function handleUserJoined(data) {
  logClientReceive('userJoined', data.username)
}
function handleUserLeft(data) {
  logClientReceive('userLeft', data.id)
}
function handleUserMessage(data) {
  logClientReceive('userMessage', data.username);
}
function has_at_most_n_jolly(j, n = 1) { return j.filter(x => is_jolly(x)).length <= n; }
function has_farm(uname) { return firstCond(UI.players[uname].buildinglist, x => x.type == 'farm'); }
function has_jolly(j) { return firstCond(j, x => is_jolly(x)); }
function has_schweine(fenbuilding) { return !isEmpty(fenbuilding.schweine); }
function hasChildren(n) {
  let ch = RCONTAINERPROP[n.type];
  if (nundef(ch)) ch = 'ch';
  return isdef(n[ch]);
}
function hasClickedUI() { uiPaused |= hasClickedMask; }
function hasDuplicate(arr, efunc) {
  let di = {};
  if (nundef(efunc)) efunc = x => { return x === ' ' };
  let i = -1;
  for (const a of arr) {
    i += 1;
    if (efunc(a)) continue;
    if (a in di) return { i: i, val: a };
    di[a] = true;
  }
  return false;
}
function HASH_CA() { brd_posKey ^= CastleKeys[brd_castlePerm]; }
function HASH_EP() { brd_posKey ^= PieceKeys[brd_enPas]; }
function HASH_PCE(pce, sq) { brd_posKey ^= PieceKeys[pce * 120 + sq]; }
function HASH_SIDE() { brd_posKey ^= SideKey; }
function hasId(o) { return isdef(o._id); }
function hasSameProps(o1, o2) {
  let diff = propDiff(o1, o2);
  return !diff.hasChanged;
}
function hasWhiteSpace(s) { return /\s/g.test(s); }
function helleFarbe(contrastTo, minDiff = 25, mod = 30, start = 0) {
  let wheel = getHueWheel(contrastTo, minDiff, mod, start);
  let hue = chooseRandom(wheel);
  let hsl = colorHSLBuild(hue, 100, 50);
  return hsl;
}
function hex1Board(dParent, rows, topcols, styles = {}) {
  let g = new UIGraph(dParent, styles);
  let [w, h] = [valf(lookup(styles, ['node', 'w']), 50), valf(lookup(styles, ['node', 'h']), 50)];
  let total = hex1Count(rows, topcols);
  let nids = g.addNodes(total);
  g.hex1(rows, topcols, w + 4, h + 4);
  let indices = hex1Indices(rows, topcols);
  let ids = g.getNodeIds();
  let di = {};
  for (let i = 0; i < ids.length; i++) {
    let [row, col] = [indices[i].row, indices[i].col];
    let id = ids[i];
    lookupSet(di, [row, col], id);
    g.setProp(id, 'row', row);
    g.setProp(id, 'col', col);
    g.setProp(id, 'label', `${row},${col}`);
  }
  for (let i = 0; i < ids.length; i++) {
    let [row, col] = [indices[i].row, indices[i].col];
    let id = ids[i];
    let nid2 = lookup(di, [row, col + 2]); if (nid2) g.addEdge(id, nid2);
    nid2 = lookup(di, [row + 1, col - 1]); if (nid2) g.addEdge(id, nid2);
    nid2 = lookup(di, [row + 1, col + 1]); if (nid2) g.addEdge(id, nid2);
  }
  let byrc = {};
  for (const r in di) {
    byrc[r] = {};
    for (const c in di[r]) {
      byrc[r][c] = g.getNode(di[r][c]).data();
    }
  }
  g.di = di;
  g.byrc = byrc;
  g.rc = (i, j, f) => (isdef(f)) ? f(g.getNode(di[i][j])) : g.getNode(di[i][j]);
  return g;
}
function hex1Centers(rows, cols, wCell = 100, hCell = null) {
  let colarr = _calc_hex_col_array(rows, cols);
  let maxcols = arrMax(colarr);
  if (nundef(hCell)) hCell = (hCell / .866);
  let hline = hCell * .75;
  let offX = wCell / 2, offY = hCell / 2;
  let centers = [];
  let x = 0; y = 0;
  for (let r = 0; r < colarr.length; r++) {
    let n = colarr[r];
    for (let c = 0; c < n; c++) {
      let dx = (maxcols - n) * wCell / 2;
      let dy = r * hline;
      let center = { x: dx + c * wCell + offX, y: dy + offY };
      centers.push(center);
    }
  }
  return [centers, wCell * maxcols, hCell / 4 + rows * hline];
}
function hex1Count(rows, topcols) {
  let colarr = _calc_hex_col_array(rows, topcols);
  let total = 0;
  for (let r = 0; r < colarr.length; r++) { total += colarr[r]; }
  return total;
}
function hex1Indices(rows, topcols) {
  let colarr = _calc_hex_col_array(rows, topcols);
  let iStart = Math.floor(rows / 2);
  let inc = -1;
  let res = [];
  for (let r = 0; r < colarr.length; r++) {
    let n = colarr[r];
    for (let c = 0; c < n; c++) {
      let icol = iStart + 2 * c;
      let irow = r;
      res.push({ row: irow, col: icol });
    }
    if (iStart == 0) inc = 1;
    iStart += inc;
  }
  return res;
}
function hex2rgb(hex) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  result = result
    ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    }
    : null;
  if (result) return `rgb(${result.r},${result.g},${result.b})`;
  else return 'rgb(0,0,0)';
}
function hexAToHSLA(H) {
  let ex = /^#([\da-f]{4}){1,2}$/i;
  if (ex.test(H)) {
    let r = 0,
      g = 0,
      b = 0,
      a = 1;
    if (H.length == 5) {
      r = '0x' + H[1] + H[1];
      g = '0x' + H[2] + H[2];
      b = '0x' + H[3] + H[3];
      a = '0x' + H[4] + H[4];
    } else if (H.length == 9) {
      r = '0x' + H[1] + H[2];
      g = '0x' + H[3] + H[4];
      b = '0x' + H[5] + H[6];
      a = '0x' + H[7] + H[8];
    }
    r /= 255;
    g /= 255;
    b /= 255;
    let cmin = Math.min(r, g, b),
      cmax = Math.max(r, g, b),
      delta = cmax - cmin,
      h = 0,
      s = 0,
      l = 0;
    if (delta == 0) h = 0;
    else if (cmax == r) h = ((g - b) / delta) % 6;
    else if (cmax == g) h = (b - r) / delta + 2;
    else h = (r - g) / delta + 4;
    h = Math.round(h * 60);
    if (h < 0) h += 360;
    l = (cmax + cmin) / 2;
    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
    s = +(s * 100).toFixed(1);
    l = +(l * 100).toFixed(1);
    a = (a / 255).toFixed(3);
    return 'hsla(' + h + ',' + s + '%,' + l + '%,' + a + ')';
  } else {
    return 'Invalid input color';
  }
}
function hexBoard(dParent, rows = 13, cols = 5, wHex = 100) {
  let hline = (wHex / .866) * .75;
  dParent = mDiv(dParent, { position: 'relative', w: wHex * cols, h: hline * (rows + .5), display: 'inline-block' });
  let hlist = [];
  let xOffset = 0;
  for (let r = 0; r < rows; r++) {
    let curCols = r % 2 ? cols - 1 : cols;
    let dx = r % 2 ? wHex / 2 : 0;
    dx += xOffset;
    for (let c = 0; c < curCols; c++) {
      let [dOuter, dInner] = oneHex(dParent, wHex, wHex, '#ffffff10');
      mStyleX(dOuter, { position: 'absolute', left: dx + c * wHex, top: r * hline });
      hlist.push(dInner);
    }
  }
  function oneHex(dParent, w, h, bg) {
    let d1 = mDiv(dParent, { w: w, h: h, display: 'inline', position: 'relative' });
    let d2 = mDiv(d1, { w: w, h: h, display: 'inline', position: 'absolute', left: 0, top: 0 });
    let g = aSvgg(d2);
    let wgap = 8, hgap = 0;
    let hex1 = agShape(g, 'hex', w - 2 * wgap, h - 2 * hgap, bg);
    let offx = 16;
    let offy = 20;
    let d3 = mDiv(d1, { w: w, h: h, display: 'inline', position: 'absolute', left: 0, top: 0 });
    let d4 = mDiv(d3, { left: `${offx / 2}%`, top: `${offy / 2}%`, w: `${100 - offx}%`, h: `${100 - offy}%`, rounding: '50%', display: 'inline', position: 'absolute' });
    return [d1, d4];
  }
  return hlist;
}
function hexBoardNO(dParent, rows = 3, cols = 5, sz = 100) {
  let hline = (sz / .866) * .75;
  dParent = mDiv(dParent, { position: 'relative', w: sz * cols, h: hline * (rows + .5), display: 'inline-block' });
  let fields = [];
  for (let r = 0; r < rows; r++) {
    let curCols = r % 2 ? cols - 1 : cols;
    let dx = r % 2 ? sz / 2 : 0;
    for (let c = 0; c < curCols; c++) {
      let [dOuter, dInner] = oneHex(dParent, sz, sz, 'yellow');
      mStyleX(dOuter, { position: 'absolute', left: dx + c * sz, top: r * hline });
      fields.push(dInner);
    }
    return fields;
  }
  function oneHex(dParent, w, h, bg) {
    let d1 = mDiv(dParent, { w: w, h: h, display: 'inline', position: 'relative' });
    let d2 = mDiv(d1, { w: w, h: h, display: 'inline', position: 'absolute', left: 0, top: 0 });
    let g = aSvgg(d2);
    let wgap = 8, hgap = 0;
    let hex1 = agShape(g, 'hex', w - 2 * wgap, h - 2 * hgap, bg);
    let offx = 16;
    let offy = 20;
    let d3 = mDiv(d1, { w: w, h: h, rounding: '50%', display: 'inline', position: 'absolute', left: 0, top: 0 });
    let d4 = mDiv(d3, { left: `${offx / 2}%`, top: `${offy / 2}%`, w: `${100 - offx}%`, h: `${100 - offy}%`, rounding: '50%', bg: 'random', display: 'inline', position: 'absolute' });
    return [d1, d4];
  }
}
function hexBoardTests() {
  let w = window.innerWidth;
  let sz = 100;
  let cols = math.floor(w / 100);
  let dBoard = mDiv(dTable);
  mCenterFlex(dTable);
  hexBoard(dBoard, 5, cols - 1, 100);
}
function hexCenters(rows, cols, wCell = 100, hCell) {
  if (nundef(hCell)) hCell = (hCell / .866);
  let hline = hCell * .75;
  let offX = wCell / 2, offY = hCell / 2;
  let centers = [];
  let startSmaller = Math.floor(rows / 2) % 2 == 1;
  let x = 0; y = 0;
  for (let r = 0; r < rows; r++) {
    let isSmaller = startSmaller && r % 2 == 0 || !startSmaller && r % 2 == 1;
    let curCols = isSmaller ? cols - 1 : cols;
    let dx = isSmaller ? wCell / 2 : 0;
    dx += offX;
    for (let c = 0; c < curCols; c++) {
      let center = { x: dx + c * wCell, y: offY + r * hline };
      centers.push(center);
    }
  }
  return [centers, wCell * cols, hCell / 4 + rows * hline];
}
function hexCornerNodes(g) {
  let nodes = g.getNodes();
  let centers = nodes.map(x => x.data('center'));
  let vertices = getCornerVertices(centers);
  for (const f of nodes) {
    let center = f.data('center');
    console.log('center', center)
  }
}
function hexDigitToDecimal(hex) {
  let n = firstNumber(hex);
  if (nundef(n)) {
    hex = hex.toLowerCase();
    return hex == 'f' ? 15 : hex == 'e' ? 14 : hex == 'd' ? 13 : hex == 'c' ? 12 : hex == 'b' ? 11 : 10;
  } else return n;
}
function hexgrid(id, rows, topcols, wFieldTotal, wFieldGap = 4, ipal = 2, visibility = ['board', 'fields'], interactivity = 'hover') {
  visualStructures[id] = [];
  rows = rows % 2 != 0 ? rows : rows + 1;
  let cols = topcols;
  let colarr = calc_hex_col_array(rows, cols);
  let maxcols = Math.max(...colarr);
  let wField = wFieldTotal;
  let hField = (2 * wField) / 1.73;
  let w = wField * maxcols;
  let h = hField * rows * 0.75 + hField / 4;
  let ilist = [];
  let clist = [];
  let fields = {};
  let imiddleRow = (rows - 1) / 2;
  for (let irow = 0; irow < colarr.length; irow++) {
    let colstart = maxcols - colarr[irow];
    fields[irow] = {};
    let y = hField * 0.75 * (irow - imiddleRow);
    for (let j = 0; j < colarr[irow]; j++) {
      var icol = colstart + 2 * j;
      let x = (icol * wField) / 2 + wField / 2 - w / 2;
      ilist.push({ row: irow, col: icol });
      clist.push({ x: x, y: y });
      fields[irow][icol] = { x: x, y: y };
      x += wField;
    }
  }
  for (option of visibility) {
    if (option == 'board') {
      let msField = new MS(id, 'g')
        .setbg(getpal(ipal))
        .rect({ w: w + 4, h: h + 4 })
        .draw();
      msField.tag('layout', 'hex');
      msField.tag('points', fields);
      visualStructures[id].push(msField);
    }
    ipal += 1;
    if (option == 'fields') {
      for (const r in fields) {
        let polyRow = fields[r];
        for (const c in polyRow) {
          let field = fields[r][c];
          let msField = visual('hex', { id: id + '_' + r + '_' + c, w: wField - wFieldGap, x: field.x, y: field.y }).setbg(getpal(ipal));
          msField.tag('row', r);
          msField.tag('col', c);
          fields[r][c].ms = msField;
          visualStructures[id].push(msField);
        }
      }
    }
  }
  return (r, c) => {
    testHexgrid(r, c);
    return {
      x: fields[r][c] ? fields[r][c].x : null,
      y: fields[r][c] ? fields[r][c].y : null,
      id: id
    };
  };
}
function hexGrid(soDict, loc, condList) {
  let [idBoard, sBoard] = findMatch(soDict, condList);
  return _hexGrid(loc, idBoard, sBoard, soDict);
}
function hexGrid_old(soDict, loc, sBoard, idBoard) {
  let res = _hexGrid(loc, idBoard, sBoard, soDict);
  timit.showTime('old hexGrid done!');
  return res;
}
function hexStringToDecimal(hex) {
  let len = hex.length;
  let fact = 1;
  let num = 0;
  for (let i = len - 1; i >= 0; i--) {
    num += hexDigitToDecimal(hex[i]) * fact;
    fact *= 16;
  }
  return num;
}
function hextest() {
  let [centers, wCont, hCont] = hexCenters(5, 4, 100, 100);
  console.log('centers', centers);
  let dCont = mDiv(dMain, { position: 'relative', w: wCont, h: hCont });
  for (const pt of centers) {
    let d = drawShape('hex', dCont);
    mCenterAt(d, pt.x, pt.y);
  }
  return dCont;
}
function hexTest00() {
  let dParent = dTable;
  let styles = { margin: 3 };
  styles = { padding: 4 };
  let h1 = mHex00(dParent, styles);
}
function hexTest01() {
  let dParent = dTable;
  let styles = { margin: 3 };
  styles = { padding: 4 };
  let h1 = mHex01(dParent, styles);
  let h2 = mHex01(dParent, styles);
}
function hexTest02() {
  let dParent = dTable;
  dParent = mDiv(dTable, { bg: 'random', w: 800, h: 500 });
  mCenterFlex(dParent);
  let whexBrut = 100;
  dParent = mDiv(dParent, { position: 'relative', w: whexBrut * 4, h: 300, bg: 'violet', display: 'inline-block' });
  let hlist = [];
  for (let i = 0; i < 4; i++) {
    let h = mHex02(dParent, whexBrut);
    mStyleX(h, { position: 'absolute', left: i * whexBrut, top: 0 });
    hlist.push(h);
  }
}
function hexTest03() {
  let dParent = dTable;
  dParent = mDiv(dTable, { bg: 'random', w: 800, h: 500 });
  mCenterFlex(dParent);
  let whexBrut = 100;
  let hline = (whexBrut / .866) * .75;
  dParent = mDiv(dParent, { position: 'relative', w: whexBrut * 4, h: 300, bg: 'violet', display: 'inline-block' });
  let hlist = [];
  for (let i = 0; i < 4; i++) {
    let h = mHex03(dParent, whexBrut, 'yellow');
    mStyleX(h, { position: 'absolute', left: i * whexBrut, top: 0 });
    hlist.push(h);
  }
  for (let i = 0; i < 3; i++) {
    let h = mHex03(dParent, whexBrut, 'yellow');
    mStyleX(h, { position: 'absolute', left: whexBrut / 2 + i * whexBrut, top: hline });
    hlist.push(h);
  }
}
function hexTest04() {
  let dParent = dTable;
  let rows = 5, cols = 5;
  let whexBrut = 100;
  let hline = (whexBrut / .866) * .75;
  dParent = mDiv(dParent, { position: 'relative', w: whexBrut * cols, h: hline * (rows + .5), display: 'inline-block' });
  let hlist = [];
  for (let r = 0; r < rows; r++) {
    let curCols = r % 2 ? cols - 1 : cols;
    let dx = r % 2 ? whexBrut / 2 : 0;
    for (let c = 0; c < curCols; c++) {
      let h = mHex04(dParent, whexBrut, 'yellow');
      mStyleX(h, { position: 'absolute', left: dx + c * whexBrut, top: r * hline });
      hlist.push(h);
    }
  }
}
function hexTest05() {
  let dParent = dTable;
  let rows = 4, cols = 9;
  let whexBrut = 100;
  let hline = (whexBrut / .866) * .75;
  dParent = mDiv(dParent, { position: 'relative', w: whexBrut * cols, h: hline * (rows + .5), display: 'inline-block' });
  let hlist = [];
  for (let r = 0; r < rows; r++) {
    let curCols = r % 2 ? cols - 1 : cols;
    let dx = r % 2 ? whexBrut / 2 : 0;
    for (let c = 0; c < curCols; c++) {
      let h = mHex05(dParent, whexBrut, 'yellow');
      mStyleX(h, { position: 'absolute', left: dx + c * whexBrut, top: r * hline });
      hlist.push(h);
    }
  }
}
function hexTest06() {
  let sz = 200;
  let d1 = mDiv(dTable, { w: sz, h: sz, bg: 'random', display: 'inline', position: 'relative' });
  let d2 = mDiv(d1, { w: 200, h: 200, bg: 'random', display: 'inline', position: 'absolute', left: 0, top: 0 });
  let g = aSvgg(d2);
  let gap = 2;
  let hex1 = agShape(g, 'hex', sz - 2 * gap, sz - 2 * gap, 'red');
  let offx = 10;
  let offy = 20;
  let d3 = mDiv(d1, { w: 200, h: 200, rounding: '50%', display: 'inline', position: 'absolute', left: 0, top: 0 });
  let d4 = mDiv(d3, { left: `${offx / 2}%`, top: `${offy / 2}%`, w: `${100 - offx}%`, h: `${100 - offy}%`, rounding: '50%', bg: 'random', display: 'inline', position: 'absolute' });
  return d4;
}
function hexTest07() {
  let dParent = dTable;
  let rows = 4, cols = 5;
  let whexBrut = 100;
  let hline = (whexBrut / .866) * .75;
  dParent = mDiv(dParent, { position: 'relative', w: whexBrut * cols, h: hline * (rows + .5), display: 'inline-block' });
  let hlist = [];
  for (let r = 0; r < rows; r++) {
    let curCols = r % 2 ? cols - 1 : cols;
    let dx = r % 2 ? whexBrut / 2 : 0;
    for (let c = 0; c < curCols; c++) {
      let h = oneHex(dParent, whexBrut, whexBrut, 'yellow');
      mStyleX(h, { position: 'absolute', left: dx + c * whexBrut, top: r * hline });
      hlist.push(h);
    }
  }
  function oneHex(dParent, w, h, bg) {
    let d1 = mDiv(dParent, { w: w, h: h, display: 'inline', position: 'relative' });
    let d2 = mDiv(d1, { w: w, h: h, display: 'inline', position: 'absolute', left: 0, top: 0 });
    let g = aSvgg(d2);
    let wgap = 8, hgap = 0;
    let hex1 = agShape(g, 'hex', w - 2 * wgap, h - 2 * hgap, bg);
    let offx = 16;
    let offy = 20;
    let d3 = mDiv(d1, { w: w, h: h, rounding: '50%', display: 'inline', position: 'absolute', left: 0, top: 0 });
    let d4 = mDiv(d3, { left: `${offx / 2}%`, top: `${offy / 2}%`, w: `${100 - offx}%`, h: `${100 - offy}%`, rounding: '50%', bg: 'random', display: 'inline', position: 'absolute' });
    return d1;
  }
}
function hexTest08(dParent, rows = 13, cols = 5, wHex = 100) {
  let hline = (wHex / .866) * .75;
  dParent = mDiv(dParent, { position: 'relative', w: wHex * cols, h: hline * (rows + .5), display: 'inline-block' });
  let hlist = [];
  let xOffset = 0;
  for (let r = 0; r < rows; r++) {
    let curCols = r % 2 ? cols - 1 : cols;
    let dx = r % 2 ? wHex / 2 : 0;
    dx += xOffset;
    for (let c = 0; c < curCols; c++) {
      let [dOuter, dInner] = oneHex(dParent, wHex, wHex, '#ffffff10');
      mStyleX(dOuter, { position: 'absolute', left: dx + c * wHex, top: r * hline });
      hlist.push(dInner);
    }
  }
  function oneHex(dParent, w, h, bg) {
    let d1 = mDiv(dParent, { w: w, h: h, display: 'inline', position: 'relative' });
    let d2 = mDiv(d1, { w: w, h: h, display: 'inline', position: 'absolute', left: 0, top: 0 });
    let g = aSvgg(d2);
    let wgap = 8, hgap = 0;
    let hex1 = agShape(g, 'hex', w - 2 * wgap, h - 2 * hgap, bg);
    let offx = 16;
    let offy = 20;
    let d3 = mDiv(d1, { w: w, h: h, display: 'inline', position: 'absolute', left: 0, top: 0 });
    let d4 = mDiv(d3, { left: `${offx / 2}%`, top: `${offy / 2}%`, w: `${100 - offx}%`, h: `${100 - offy}%`, rounding: '50%', display: 'inline', position: 'absolute' });
    return [d1, d4];
  }
  return hlist;
}
function hextestNewBROKEN() {
  let info = createHexboard2(3, 4, 50);
  console.log('info', info);
  let [centers, maxx, maxy] = [[], 0, 0];
  let [wCell, hCell] = [100, 100];
  for (const item of info.items) {
    if (item.isHexCenter) {
      let [x, y] = [item.x, item.y];
      maxx = Math.max(maxx, x); maxy = Math.max(maxy, y);
      centers.push({ x: x, y: y });
    }
  }
  let wCont = maxx + wCell / 2;
  let hCont = maxy + hCell / 2;
  let resultOfHexCenters = [centers, wCont, hCont];
  console.log('centers', centers);
  let dCont = mDiv(dMain, { position: 'relative', w: wCont, h: hCont, bg: 'pink' });
  for (const pt of centers) {
    let d = drawShape('hex', dCont);
    mCenterAt(d, pt.x, pt.y);
  }
}
function hexToHSL(H) {
  let ex = /^#([\da-f]{3}){1,2}$/i;
  if (ex.test(H)) {
    let r = 0,
      g = 0,
      b = 0;
    if (H.length == 4) {
      r = '0x' + H[1] + H[1];
      g = '0x' + H[2] + H[2];
      b = '0x' + H[3] + H[3];
    } else if (H.length == 7) {
      r = '0x' + H[1] + H[2];
      g = '0x' + H[3] + H[4];
      b = '0x' + H[5] + H[6];
    }
    r /= 255;
    g /= 255;
    b /= 255;
    let cmin = Math.min(r, g, b),
      cmax = Math.max(r, g, b),
      delta = cmax - cmin,
      h = 0,
      s = 0,
      l = 0;
    if (delta == 0) h = 0;
    else if (cmax == r) h = ((g - b) / delta) % 6;
    else if (cmax == g) h = (b - r) / delta + 2;
    else h = (r - g) / delta + 4;
    h = Math.round(h * 60);
    if (h < 0) h += 360;
    l = (cmax + cmin) / 2;
    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
    s = +(s * 100).toFixed(1);
    l = +(l * 100).toFixed(1);
    return 'hsl(' + h + ',' + s + '%,' + l + '%)';
  } else {
    return 'Invalid input color';
  }
}
function hexToRgb(hex) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result
    ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    }
    : null;
}
function hFunc(content, funcname, arg1, arg2, arg3) {
  let html = `<a style='color:blue' href="javascript:${funcname}('${arg1}','${arg2}','${arg3}');">${content}</a>`;
  return html;
}
function hide(elem) {
  if (isString(elem)) elem = document.getElementById(elem);
  if (nundef(elem)) return;
  if (isSvg(elem)) {
    elem.setAttribute('style', 'visibility:hidden;display:none');
  } else {
    elem.style.display = 'none';
  }
}
function hide_buildings() {
  let uplayer = Z.uplayer;
  let buildings = UI.players[uplayer].buildinglist;
  for (const b of buildings) {
    for (let i = 1; i < b.items.length; i++) {
      let card = b.items[i];
      if (b.schweine.includes(card)) continue;
      face_down(b.items[i]);
    }
  }
}
function hide_history_popup() { let d = mBy('dHistoryPopup'); if (isdef(d)) { mAppend(UI.dHistoryParent, UI.dHistory); mRemove(d); } }
function hide_motto() { mClear('dMotto') }
function hide_options_popup() { let d = mBy('dOptions'); if (isdef(d)) mRemove(d); }
function hide0(id) { mBy(id).style.display = "none"; }
function hideBoat(id) { let ms = UIS[id]; ms.hide(); ms.o.weg = true; }
function hideCurrent() {
  if (dCurrent) {
    if (dCurrent.id == 'dChat') disappear(mBy('dChatWindow'), DELAY_DISAPPEAR);
    disappear(dCurrent, DELAY_DISAPPEAR);
    dCurrent = null;
    return DELAY_DISAPPEAR;
  } else return 0;
}
function hideElems(idlist) {
  for (const id of idlist) {
    EID[id].ms.hide();
  }
}
function hideEventList() { document.getElementById('events').style.display = 'none'; }
function hideGame() { document.getElementById('R_d_root').style.display = 'none'; }
function hideGameConfig() { document.getElementById('gameConfig').style.display = 'none'; }
function hideInfobox(oid) { let id = makeIdInfobox(oid); if (UIS[id]) UIS[id].hide(); }
function hideJoinConfig() { hide('joinConfig'); }
function hideLoader() { mBy('dLoader').style.display = "none"; }
function hideLobby() { document.getElementById('a_d_lobby').style.display = 'none'; }
function hideLog(pl) { let d = LOG[pl]; if (d) hide(d); }
function hideLogin() { document.getElementById('a_d_login').style.display = 'none'; }
function hideMenu(desc) {
  let d = mBy('div' + desc);
  if (isVisible(d)) {
    let b = mBy('b' + desc);
    hide(d);
    b.innerHTML = '+' + desc[0];
  }
}
function hideMouse() {
  var x = dTable.getElementsByTagName("DIV");
  for (const el of x) { el.prevCursor = el.style.cursor; }
  for (const p of Pictures) {
    mRemoveClass(iDiv(p), 'frameOnHover'); iDiv(p).style.cursor = 'none';
    for (const ch of iDiv(p).children) ch.style.cursor = 'none';
  }
  for (const el of x) { mClass(el, 'noCursor'); }
}
function hideMouseAvatar(username) { hide(getAvatar(username)); }
function hideOuterDoors(house) {
  for (const did of jsCopy(house.doors)) {
    let door = Items[did];
    hide(iDiv(door));
  }
}
function hidePlayer(i) {
  let id;
  id = getidNum(i); hide(id);
  id = getidSpan(i); hide(id);
  id = getidType(i); hide(id);
}
function hideShield() { setTimeout(() => { mBy('dShield').style.display = 'none' }, 500); }
function hideSvg(elem) {
  elem.setAttribute('style', 'visibility:hidden;display:none');
}
function hideTooltip() { $('div#tooltip').css({ display: 'none' }); }
function highAll(oid) { mapSafe('high', getVisuals, oid); }
function highAux(oid) { mapSafe('high', getAuxVisuals, oid); }
function highlight(x) {
  let msList = getVisuals(x);
  for (const ms of msList) {
    ms.high();
  }
}
function highlight_player(uname) { mHigh(`d_${uname}`); mHigh(iDiv(Items[uname])); }
function highlightBoat(id) {
  if (id === null) return;
  if (boatHighlighted) {
    if (boatHighlighted.id == id) return;
    else unhighlightBoat();
  }
  boatHighlighted = UIS[id];
  boatHighlighted.elem.scrollIntoView(false);
  highlightMsAndRelatives(null, boatHighlighted);
  openInfoboxesForBoatOids(boatHighlighted);
}
function highlightContentIds(b) {
  let s = b.innerHTML;
  let ids = s.split(/[ ,:;]+/);
  for (const id of ids) {
    if (id == '_') continue;
    let msList = getVisuals(id);
    for (const ms of msList) ms.high();
  }
}
function highlightMsAndRelatives(ev, mobj, partName) {
  let id = mobj.id;
  mobj.high(partName);
  if (mobj.isa.infobox) bringInfoboxToFront(mobj);
  let relativeIds = id2uids[id];
  if (nundef(relativeIds)) return;
  for (const idRel of relativeIds) {
    let msRel = UIS[idRel];
    msRel.high('title');
  }
}
function highlightNextBoat() {
  if (!boatHighlighted) highlightBoat(getFirstBoatId());
  else {
    let idx = boatHighlighted.o.iTuple + 1;
    highlightBoat(getBoatIdByIdx(boatHighlighted.o.iTuple + 1));
  }
}
function highlightPrevBoat() {
  if (!boatHighlighted) highlightBoat(getLastBoatId()); else highlightBoat(getBoatIdByIdx(boatHighlighted.o.iTuple - 1));
}
function highMain(oid) { mapSafe('high', getVisual, oid); }
function highSelfAndRelatives(uid, R) {
  for (const oid of R.uid2oids[uid]) {
    for (const uid1 of R.oid2uids[oid]) {
      let ui = R.getUI(uid1);
      mHigh(ui);
    }
  }
  let n = R.uiNodes[uid];
  if (n.potentialOverlap) {
    let ui = R.getUI(uid);
    bringToFront(ui);
  }
}
function HintAnimation(sq, ms = 2000) {
  if (GameController.BoardFlipped == BOOL.TRUE) { sq = MIRROR120(sq); }
  $(".Square").each(function (index) {
    if ((RanksBrd[sq] == 7 - Math.round($(this).position().top / 60)) && (FilesBrd[sq] == Math.round($(this).position().left / 60))) {
      animateProperty(this, 'opacity', '1', '0', '1', ms);
    }
  });
}
function hintEngineStart(hintFunc, hintlist, initialDelay) {
  G.hintFunc = hintFunc;
  recShowHints(hintlist, QContextCounter, initialDelay, d => initialDelay + 2000);
}
function horLayout(n, R) {
  console.log('n', n, n.ui);
  let uids = n.children;
  let dims = calcTotalDims(n, uids, R);
  let margin = dims.margin;
  console.log('dims', dims);
  let x = margin;
  let y = margin;
  let uiParent = n.ui;
  uiParent.style.position = 'relative';
  console.log(uiParent);
  for (const ch of uids) {
    let n = R.uiNodes[ch];
    let w = n.size.w;
    let h = n.size.h;
    n.pos = { x: x, y: y };
    let ui = n.ui;
    ui.style.position = 'absolute';
    ui.style.display = 'inline-block';
    ui.style.boxSizing = 'border-box';
    ui.style.left = x + 'px';
    ui.style.top = y + 'px';
    ui.style.margin = 'auto';
    x += w + 2;
  }
  uiParent.style.width = dims.w + 'px';
  uiParent.style.minHeight = dims.h + 'px';
}
function host_update() {
  assertion(isdef(Z.fen), 'no fen');
  check_for_clicks();
  show_status();
}
function houseTest00() {
  let s = '"a a b c" "d d e c" "f g e h"'; console.log(getRandomLetterMapping(s)); console.log('_____\n', s, '\n', getLetterSwapEncoding(s));
}
function howto_close(item) { toggle_fiddle(); }
function howto_open(item) {
  iClear('dTable')
  if (nundef(item)) item = DB.apps.howto;
  dSearch = mBy('dSearch'); mClear(dSearch);
  show_sidebar(Object.keys(CODE.justcode), show_code);
  mStyle(dSearch, { bg: item.color });
  mInputLineWithButtons(dSearch, { Code: filter_codebase, Signatures: filter_sig })
}
function HPLayout() {
  if (isdef(UI.DRR)) UI.DRR.remove();
  mInsert(UI.dRechts, UI.dHistory);
  Clientdata.historyLayout = 'hp';
}
function hRoute(content, route, arg1, arg2, arg3) {
  let html = `<a href="/${route}"`;
  if (isdef(arg1)) html += `/${arg1}`;
  if (isdef(arg2)) html += `/${arg2}`;
  if (isdef(arg3)) html += `/${arg3}`;
  html += `">${content}</a>`;
  return html;
}
function HRPLayout() {
  let dr = UI.dRechts;
  dr.remove();
  let drr = UI.DRR = mDiv(dTable);
  mAppend(drr, UI.dHistory);
  mAppend(dTable, dr);
  Clientdata.historyLayout = 'hrp';
}
function hsl2hsv(hue, sat, light) {
  sat *= light < 0.5 ? light : 1 - light;
  return [
    hue,
    (2 * sat) / (light + sat),
    light + sat
  ];
}
function hsl2rgb(h, s, l) {
  let RGB = h2rgb(h);
  let C = (1 - Math.abs(2 * l - 1)) * s;
  return (RGB - 0.5) * C + l;
}
function HSLAToRGBA(hsla, isPct) {
  let ex = /^hsla\(((((([12]?[1-9]?\d)|[12]0\d|(3[0-5]\d))(\.\d+)?)|(\.\d+))(deg)?|(0|0?\.\d+)turn|(([0-6](\.\d+)?)|(\.\d+))rad)(((,\s?(([1-9]?\d(\.\d+)?)|100|(\.\d+))%){2},\s?)|((\s(([1-9]?\d(\.\d+)?)|100|(\.\d+))%){2}\s\/\s))((0?\.\d+)|[01]|(([1-9]?\d(\.\d+)?)|100|(\.\d+))%)\)$/i;
  if (ex.test(hsla)) {
    let sep = hsla.indexOf(',') > -1 ? ',' : ' ';
    hsla = hsla
      .substr(5)
      .split(')')[0]
      .split(sep);
    if (hsla.indexOf('/') > -1) hsla.splice(3, 1);
    isPct = isPct === true;
    let h = hsla[0],
      s = hsla[1].substr(0, hsla[1].length - 1) / 100,
      l = hsla[2].substr(0, hsla[2].length - 1) / 100,
      a = hsla[3];
    if (h.indexOf('deg') > -1) h = h.substr(0, h.length - 3);
    else if (h.indexOf('rad') > -1) h = Math.round((h.substr(0, h.length - 3) / (2 * Math.PI)) * 360);
    else if (h.indexOf('turn') > -1) h = Math.round(h.substr(0, h.length - 4) * 360);
    if (h >= 360) h %= 360;
    let c = (1 - Math.abs(2 * l - 1)) * s,
      x = c * (1 - Math.abs(((h / 60) % 2) - 1)),
      m = l - c / 2,
      r = 0,
      g = 0,
      b = 0;
    if (0 <= h && h < 60) {
      r = c;
      g = x;
      b = 0;
    } else if (60 <= h && h < 120) {
      r = x;
      g = c;
      b = 0;
    } else if (120 <= h && h < 180) {
      r = 0;
      g = c;
      b = x;
    } else if (180 <= h && h < 240) {
      r = 0;
      g = x;
      b = c;
    } else if (240 <= h && h < 300) {
      r = x;
      g = 0;
      b = c;
    } else if (300 <= h && h < 360) {
      r = c;
      g = 0;
      b = x;
    }
    r = Math.round((r + m) * 255);
    g = Math.round((g + m) * 255);
    b = Math.round((b + m) * 255);
    let pctFound = a.indexOf('%') > -1;
    if (isPct) {
      r = +((r / 255) * 100).toFixed(1);
      g = +((g / 255) * 100).toFixed(1);
      b = +((b / 255) * 100).toFixed(1);
      if (!pctFound) {
        a *= 100;
      } else {
        a = a.substr(0, a.length - 1);
      }
    } else if (pctFound) {
      a = a.substr(0, a.length - 1) / 100;
    }
    return 'rgba(' + (isPct ? r + '%,' + g + '%,' + b + '%,' + a + '%' : +r + ',' + +g + ',' + +b + ',' + +a) + ')';
  } else {
    return 'Invalid input color';
  }
}
function hslToHex(h, s, l) {
  l /= 100;
  const a = s * Math.min(l, 1 - l) / 100;
  const f = n => {
    const k = (n + h / 30) % 12;
    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return Math.round(255 * color).toString(16).padStart(2, '0');
  };
  return `#${f(0)}${f(8)}${f(4)}`;
}
function hslToHslaString(h, s, l, a = 1) {
  return 'hsla(' + h + ', ' + s + '%, ' + l + '%, ' + a + ')';
}
function hslToHsv(h, s, l) {
  let newh = h;
  l /= 100.0;
  s /= 100.0;
  testHelpers(h, s, l);
  let newv = (2 * l + s * (1 - Math.abs(2 * l - 1))) / 2;
  let news = (2 * (newv - l)) / newv;
  testHelpers(newh, news, newv);
  let rgb = hsvToRgb(newh, news, newv);
  let result = [h, s, l, newh, news, newv];
  result.push(rgbToHex(rgb[0], rgb[1], rgb[2]));
  return result;
}
function HSLToRGB(hsl, isPct) {
  let ex = /^hsl\(((((([12]?[1-9]?\d)|[12]0\d|(3[0-5]\d))(\.\d+)?)|(\.\d+))(deg)?|(0|0?\.\d+)turn|(([0-6](\.\d+)?)|(\.\d+))rad)((,\s?(([1-9]?\d(\.\d+)?)|100|(\.\d+))%){2}|(\s(([1-9]?\d(\.\d+)?)|100|(\.\d+))%){2})\)$/i;
  if (ex.test(hsl)) {
    let sep = hsl.indexOf(',') > -1 ? ',' : ' ';
    hsl = hsl
      .substr(4)
      .split(')')[0]
      .split(sep);
    isPct = isPct === true;
    let h = hsl[0],
      s = hsl[1].substr(0, hsl[1].length - 1) / 100,
      l = hsl[2].substr(0, hsl[2].length - 1) / 100;
    if (h.indexOf('deg') > -1) h = h.substr(0, h.length - 3);
    else if (h.indexOf('rad') > -1) h = Math.round((h.substr(0, h.length - 3) / (2 * Math.PI)) * 360);
    else if (h.indexOf('turn') > -1) h = Math.round(h.substr(0, h.length - 4) * 360);
    if (h >= 360) h %= 360;
    let c = (1 - Math.abs(2 * l - 1)) * s,
      x = c * (1 - Math.abs(((h / 60) % 2) - 1)),
      m = l - c / 2,
      r = 0,
      g = 0,
      b = 0;
    if (0 <= h && h < 60) {
      r = c;
      g = x;
      b = 0;
    } else if (60 <= h && h < 120) {
      r = x;
      g = c;
      b = 0;
    } else if (120 <= h && h < 180) {
      r = 0;
      g = c;
      b = x;
    } else if (180 <= h && h < 240) {
      r = 0;
      g = x;
      b = c;
    } else if (240 <= h && h < 300) {
      r = x;
      g = 0;
      b = c;
    } else if (300 <= h && h < 360) {
      r = c;
      g = 0;
      b = x;
    }
    r = Math.round((r + m) * 255);
    g = Math.round((g + m) * 255);
    b = Math.round((b + m) * 255);
    if (isPct) {
      r = +((r / 255) * 100).toFixed(1);
      g = +((g / 255) * 100).toFixed(1);
      b = +((b / 255) * 100).toFixed(1);
    }
    return 'rgb(' + (isPct ? r + '%,' + g + '%,' + b + '%' : +r + ',' + +g + ',' + +b) + ')';
  } else {
    return 'Invalid input color';
  }
}
function hsv2hsl(hue, sat, val) {
  return [
    hue,
    (sat * val) / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue),
    hue / 2
  ];
}
function hsvToHsl(h, s, v) {
  let newh = h;
  s /= 100.0;
  v /= 100.0;
  testHelpers(h, s, v);
  let newl = 0.5 * v * (2 - s);
  let news = (v * s) / (1 - Math.abs(2 * s - 1));
  testHelpers(newh, news, newl);
  return {
    h: newh,
    s: news,
    l: newl
  };
}
function hsvToRgb(h, s, v) {
  let f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [Math.floor(f(5) * 255), Math.floor(f(3) * 255), Math.floor(f(1) * 255)];
}
function html_to_umlaut(html) {
  console.log('html', html);
  if (html == 'u00c4') { return 'Ä'; }
  else return html;
}
function hue(h) {
  var r = Math.abs(h * 6 - 3) - 1;
  var g = 2 - Math.abs(h * 6 - 2);
  var b = 2 - Math.abs(h * 6 - 4);
  return [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)];
}
function i_am_acting_host() { return U.name == Z.fen.acting_host; }
function i_am_host() { return U.name == Z.host; }
function i_am_trigger() { return is_multi_trigger(U.name); }
function i52(i) { return isList(i) ? i.map(x => Card52.getItem(x)) : Card52.getItem(i); }
function iAdd(item, liveprops, addprops) {
  let id, l;
  if (isString(item)) { id = item; item = valf(Items[id], {}); }
  let el = valf(liveprops.div, liveprops.ui, iDiv(item), null);
  id = valnwhite(item.id, (el ? el.id : getUID()), getUID());
  item.id = id; if (nundef(Items[id])) Items[id] = item; if (el) el.id = id;
  if (nundef(item.live)) item.live = {};
  l = item.live;
  for (const k in liveprops) {
    let val = liveprops[k];
    if (nundef(val)) { continue; }
    l[k] = val;
    if (isdef(val.id) && val.id != id) { lookupAddIfToList(val, ['memberOf'], id); }
  }
  if (isdef(addprops)) copyKeys(addprops, item);
  return item;
}
function iAddContent(item, d) { let dm = diContent(item); if (isdef(dm)) mAppend(dm, d); }
function iAmInGame() {
  let gc = S.gameConfig;
  let players = gc.players;
  let me = firstCond(players, x => startsWith(x.username, USERNAME));
  return me !== null;
}
function iAmStarter() { return S.gameConfig.players[0].username == USERNAME; }
function iAppend(dParent, i) { mAppend(iDiv(dParent), iDiv(i)); }
function iAppend52(i, dParent, faceUp) {
  let item = i52(i);
  iFace(item, faceUp);
  mAppend(dParent, item.div);
  return item;
}
function iBounds(i, irel) {
  if (isdef(i.div)) i = i.div;
  if (isdef(irel) && isdef(irel.div)) irel = irel.div;
  isParent = (i.parentNode == irel);
  let b = getBounds(i, isParent, irel);
  let [x, y, w, h] = [Math.round(b.left), Math.round(b.top), Math.round(b.width), Math.round(b.height)];
  return { x: x, y: y, w: w, h: h };
}
function iButtonSidebarDiv(dParent, bCaption = '☰', bStyles = { fz: 30 }, sbStyles = { bg: wpink }, divStyles = {}, outerStyles = { matop: 4, bg: wgrey }) {
  let d0 = mDiv100(dParent);
  let b = mButton(bCaption, null, d0, bStyles, 'mybutton', getUID('b'));
  outerStyles.position = 'relative';
  let h = getRect(d0).h - (getRect(b).h + outerStyles.matop);
  outerStyles.h = h;
  let d = mDiv(d0, outerStyles);
  let dSide = mDiv(d, sbStyles);
  let dContent = mDiv(d, divStyles, getUID());
  let sb = iSidebar(dSide, dContent, b, 120, false);
  let item = mItem(getUID('comp'), { div: d0, button: b, sidebar: sb, dContent: dContent }, { type: 'component' });
  return item;
}
function iCenter(item, offsetX, offsetY) { let d = iDiv(item); mCenterAbs(d, offsetX, offsetY); }
function iClear(item) {
  if (nundef(item)) return;
  if (isString(item)) { let id = item; if (isdef(Items[id])) item = Items[id]; else item = toElem(id); }
  let d = iDiv(item);
  if (isdef(d)) {
    let desc = Array.from(d.querySelectorAll('[id]:not([id=""])')); //'[id]:not([id]="")');
    desc = desc.filter(x => isdef(Items[x.id]))
    for (const item1 of desc) iDelete(item1.id);
    mClear(d);
  }
}
function iCollect(tags = ['div']) {
  for (const t of tags) {
    let divs = Array.from(document.getElementsByTagName(t)).filter(d => !isEmptyOrWhiteSpace(d.id) && !isEmpty(d.innerHTML));
    for (const d of divs) {
      iAdd({}, { div: d });
    }
  }
}
function iContainer(dParent, styles, classes, id, inner) {
  let item = { id: isdef(id) ? id : getUID(), type: 'plain' };
  let dOuter = mDiv(dParent);
  let dInner = mDiv100(dOuter);
  mCenterCenterFlex(dInner);
  if (isdef(inner)) d.innerHTML = inner;
  if (nundef(styles)) styles = {};
  styles.display = 'inline-block';
  mStyle(dOuter, styles);
  if (isdef(classes)) mClass(dOuter, classes);
  iAdd(item, { div: dOuter, dInner: dInner });
  item.add = elem => mAppend(dInner, elem);
  return item;
}
function iconViewer(keys) {
  onclick = show100;
  IconSet = isdef(keys) ? keys : symKeysBySet['nosymbols'];
  lastIndex = 0;
  Pictures = [];
  show100();
}
function iconViewerTestKeysets() {
  let allKeys = symKeysBySet.nosymbols;
  let keys = allKeys.filter(x => isdef(symbolDict[x].best100));
  let keys1 = allKeys.filter(x => isdef(symbolDict[x].best100) && isdef(symbolDict[x].bestE));
  let keys2 = allKeys.filter(x => isdef(symbolDict[x].best50));
  let keys3 = allKeys.filter(x => isdef(symbolDict[x].best25));
  console.log(keys3);
  iconViewer(keys3);
}
function id2name(id) { id.substring(2).split('_').join(' '); }
function idealFontDims(txt, wmax, hmax, fz = 22, fzmin = 6, weight) {
  let tStyles = { fz: fz, family: 'arial' };
  if (isdef(weight)) tStyles.weight = weight;
  while (true) {
    let tSize = getSizeWithStyles(txt, tStyles);
    if (tSize.h <= hmax && tSize.w <= wmax || tStyles.fz <= fzmin) return { w: tSize.w, h: tSize.h, fz: tStyles.fz, family: 'arial' };
    else tStyles.fz -= 1;
  }
}
function idealFontSize(txt, wmax, hmax, fz = 22, fzmin = 6, weight) { return idealFontDims(...arguments).fz; }
function idealFontsize(txt, wmax, hmax, fz, fzmin, weight) {
  let tStyles = { fz: fz, family: 'arial' };
  if (isdef(weight)) tStyles.weight = weight;
  while (true) {
    let tSize = getSizeWithStyles(txt, tStyles);
    if (tSize.h <= hmax && tSize.w <= wmax || tStyles.fz <= fzmin) return { w: tSize.w, h: tSize.h, fz: tStyles.fz, family: 'arial' };
    else tStyles.fz -= 1;
  }
}
function idealFontsizeX(elem, wmax, hmax, fz, fzmin) {
  let tStyles = { w: wmax, fz: fz, family: 'arial' };
  let i = 0;
  while (i < 100) {
    i += 1;
    mStyleX(elem, tStyles);
    let tSize = getElemSize(elem);
    if (tSize.h <= hmax || tStyles.fz <= fzmin) {
      return { w: tSize.w, h: tSize.h, fz: tStyles.fz };
    } else tStyles.fz -= 1;
  }
}
function idealTextColor(bg, grayPreferred = false) {
  const nThreshold = 105;
  if (bg.substring(0, 1) != '#') bg = colorNameToHexString(bg);
  rgb = hexToRgb(bg);
  r = rgb.r;
  g = rgb.g;
  b = rgb.b;
  var bgDelta = r * 0.299 + g * 0.587 + b * 0.114;
  var foreColor = 255 - bgDelta < nThreshold ? 'black' : 'white';
  if (grayPreferred) foreColor = 255 - bgDelta < nThreshold ? 'dimgray' : 'snow';
  return foreColor;
}
function iDelete(id) {
  delete Items[id];
}
function identifyCardByRank(key, rank) {
  if (key == 'market') {
  }
}
function iDetect(itemInfoKey) {
  let item, info, key;
  if (isString(itemInfoKey)) { key = itemInfoKey; info = Syms[key]; item = infoToItem(info); }
  else if (isDict(itemInfoKey)) {
    if (isdef(itemInfoKey.info)) { item = itemInfoKey; info = item.info; key = item.info.key; }
    else { info = itemInfoKey; key = info.key; item = infoToItem(info); }
  }
  return [item, info, key];
}
function iDiv(i) { return isdef(i.live) ? i.live.div : isdef(i.div) ? i.div : i; }
function iDivs(ilist) { return isEmpty(ilist) ? [] : isItem(ilist[0]) ? ilist.map(x => iDiv(x)) : ilist; }
function iDoor(r1, dir, r2, styles = {}) {
  r1 = isString(r1) ? Items[r1] : r1;
  let house = Items[r1.house];
  r2 = isdef(r2) ? isString(r2) ? Items[r2] : r2 : null;
  let wall = r2 ? findWall(r1, r2) : isdef(dir) ? findFreeWall(r1, r1.walls[dir]) : findFreeWall(r1);
  if (wall.door) { errlog('there is already a door between', r1.id, 'and', r2); return; }
  let szDoor = valf(styles.szDoor, house.szDoor);
  let bg = valf(styles.bg, house.bg);
  let dParent = iDiv(house);
  let wr = wall.rect;
  if (nundef(r2) && wall.room) { r2 = Items[wall.room]; }
  let dr = jsCopy(wr);
  let or = wall.dir == 'e' || wall.dir == 'w' ? 'v' : 'h';
  if (or == 'v') {
    let len = wr.h;
    let offy = (len - szDoor) / 2;
    dr.y = dr.t = dr.t + offy;
    dr.h = szDoor;
  } else {
    let len = wr.w;
    let offx = (len - szDoor) / 2;
    dr.x = dr.l = dr.l + offx;
    dr.w = szDoor;
  }
  let id = getDoorId(r1.id, r2 ? r2.id : house.id);
  let door = { rooms: [r1.id], rect: dr, id: id, or: or };
  if (r2) { r2.doors.push(id); door.rooms.push(r2.id); } else { house.doors.push(id); }
  r1.doors.push(id);
  let stylesPlus = { position: 'absolute', left: dr.x, top: dr.y, w: dr.w, h: dr.h, bg: bg };
  copyKeys(stylesPlus, styles);
  d = mDiv(dParent, styles);
  iAdd(door, { div: d });
  return door;
}
function iDov(item) { return isdef(item.live) ? item.live.overlay : null; }
function if_hotseat_autoswitch(result) {
  if (isdef(result.table) && isdef(Z) && Z.mode == 'hotseat') {
    let turn = lookup(result, ['table', 'fen', 'turn']);
    assertion(isdef(turn), 'turn is NOT defined (_sendSIMSIM) !!!!');
    let uname = turn.length == 1 ? turn[0] : arrNext(turn, U.name);
    if (uname != U.name) switch_uname(uname);
  }
}
function if_plural(n) { return n == 1 ? '' : 's'; }
function if_stringified(obj) { return is_stringified(obj) ? JSON.parse(obj) : obj; }
function if_stringified_or_dict(obj) { return nundef(obj) ? {} : is_stringified(obj) ? JSON.parse(obj) : obj; }
function if_stringified_or_list(obj) { return nundef(obj) ? [] : is_stringified(obj) ? JSON.parse(obj) : obj; }
function if_stringified_or_string(obj) { return nundef(obj) ? '' : is_stringified(obj) ? JSON.parse(obj) : obj; }
function iFace(item, faceUp) { if (isdef(faceUp)) faceUp ? iFaceUp(item) : iFaceDown(item); }
function iFaceDown(item) { Card52.turnFaceDown(item); }
function iFaceUp(item) { Card52.turnFaceUp(item); }
function iFromRowCol(row, col, rows, cols) { return row * cols + col; }
function iG(i) { return isdef(i.live) ? i.live.g : isdef(i.g) ? i.g : i; }
function iGet(item, key) { return item[key]; }
function iGetl(item, key) { return item.live[key]; }
function iGrid(rows, cols, dParent, styles) {
  styles.display = 'inline-block';
  let items = [];
  let index = 0;
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      let d = mDiv(dParent, styles);
      let item = { row: i, col: j, index: index };
      index += 1;
      iAdd(item, { div: d });
      items.push(item);
    }
    mLinebreak(dParent);
  }
  return items;
}
function iH00(iarr, dParent, styles, id) {
  function iH00Zone(dTable, nmax = 7, padding = 10) {
    let sz = netHandSize(nmax);
    return mZone(dTable, { wmin: sz.w, h: sz.h, padding: padding });
  }
  let h = isdef(Items[id]) ? Items[id] : { arr: iarr, styles: styles, id: id };
  if (nundef(h.zone)) h.zone = iH00Zone(dParent); else clearElement(h.zone);
  let items = i52(iarr);
  h.iHand = iSplay(items, h.zone);
  return h;
}
function iH00_dep(iarr, dParent, styles, id) {
  function iH00Zone(dTable, nmax = 3, padding = 10) {
    let sz = netHandSize(nmax);
    return mZone(dTable, { wmin: sz.w, h: sz.h, padding: padding, rounding: 10 });
  }
  let data = DA[id] = {};
  let h = data.deck = new DeckClass();
  h.init(iarr);
  h = data;
  if (nundef(h.zone)) h.zone = iH00Zone(dParent); else clearElement(h.zone);
  if (nundef(h.iHand)) {
    let items = i52(h.deck.cards());
    h.iHand = iSplay(items, h.zone);
  } else if (redo) {
    clearElement(h.zone);
    let items = i52(h.deck.cards());
    h.iHand = iSplay(items, h.zone);
  }
  return h;
}
function iH01(iarr, dParent, styles, id, overlap) {
  function iH01Zone(dTable, nmax = 3, padding = 10) {
    let sz = netHandSize(nmax);
    return mZone(dTable, { wmin: sz.w, h: sz.h, padding: padding });
  }
  let h = isdef(Items[id]) ? Items[id] : { arr: iarr, styles: styles, id: id };
  if (nundef(h.zone)) h.zone = iH01Zone(dParent); else clearElement(h.zone);
  let items = i52(iarr);
  h.iHand = iSplay(items, h.zone, {}, 'right', overlap);
  return h;
}
function iHand52(i) {
  let hand = iSplay(i, dTable);
}
function iHandZone(dParent, styles, nmax) {
  if (nundef(styles)) styles = { bg: 'random', rounding: 10 };
  if (isdef(nmax)) {
    console.log('nmax', nmax)
    let sz = netHandSize(nmax);
    styles.w = sz.w;
    styles.h = sz.h;
  }
  return mZone(dParent, styles);
}
function iHandZone_test(dTable, nmax = 10, padding = 10) {
  let sz = netHandSize(nmax);
  return mZone(dTable, { wmin: sz.w, h: sz.h, bg: 'random', padding: padding, rounding: 10 });
}
function iHexboard(cols = 3, rows = 3, a = 48) {
  let sq3 = Math.sqrt(3);
  let wp = a / 4, hp = a / 4, h = sq3 * a / 2;
  let [xoff, dx, yoff, dy] = [h + wp / 2, 2 * h, hp / 2, a / 2];
  let ys = 2 + 3 * rows;
  let xs = cols;
  let x = xoff, y = yoff;
  let pts = [];
  let infos = [];
  let idx = 0;
  let yEven = true;
  for (let i = 0; i < ys; i++) {
    let tcolOffset = yEven ? 1 : 0;
    let isCenterRow = i >= 2 && ((i - 2) % 3) == 0;
    for (let j = 0; j < xs + (1 - tcolOffset); j++) {
      let pt = { x: x, y: y };
      pts.push(pt);
      infos.push({ index: idx, tcol: tcolOffset + 2 * j, trow: i, x: x, y: y, pt: pt, isCenterRow: isCenterRow, isHexCenter: isCenterRow, isCenterCol: j % 2 == 1 });
      x += dx;
      idx += 1;
    }
    yEven = !yEven;
    y += dy; x = i % 2 ? xoff : wp / 2;
  }
  let byrc = {};
  for (const i of infos) {
    lookupSet(byrc, [i.trow, i.tcol], i.index);
  }
  let byxy = {};
  let adjList = [];
  let di = {};
  for (const info of infos) {
    let [r, c] = [info.trow, info.tcol];
    info.nodes = [
      lookup(byrc, [r - 2, c]),
      lookup(byrc, [r - 1, c + 1]),
      lookup(byrc, [r + 1, c + 1]),
      lookup(byrc, [r + 2, c]),
      lookup(byrc, [r + 1, c - 1]),
      lookup(byrc, [r + 1, c - 1]),
    ];
    for (let i = 0; i < 6; i++) {
      let n1 = info.nodes[i];
      if (n1 == null) continue;
      let n2 = info.nodes[(i + 1 % 6)];
      if (n2 == null) continue;
      if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
      lookupSet(di, [n1, n2], true);
      adjList.push([n1, n2]);
    }
    info.neighbors = [
      lookup(byrc, [r - 3, c + 1]),
      lookup(byrc, [r, c + 2]),
      lookup(byrc, [r + 3, c + 1]),
      lookup(byrc, [r + 3, c - 1]),
      lookup(byrc, [r, c - 2]),
      lookup(byrc, [r - 3, c - 1]),
    ];
  }
  let boardItem = { dx: dx, dy: dy, rows: rows, cols: cols, count: infos.length, adjList: adjList, byrc: byrc, pts: pts, items: infos };
  return boardItem;
}
function iHigh(item) { let d = iDiv(item); mStyle(d, { bg: 'darkgray' }); }
function iHighlight(item) { let d = iDov(item); mClass(d, 'overlaySelected'); }
function iHouse(dParent, ns = 1, styles = { w: 500, h: 400 }) {
  let d = mDiv(dParent, { display: 'inline-grid', position: 'relative', box: true });
  ns = isNumber(ns) ? d.style.gridTemplateAreas = getLayoutSample(ns) : ns; //'"z z d" "a a c" "a a c"';// getLayoutSample(3);
  let s = d.style.gridTemplateAreas = ns;
  let letterList = filterDistinctLetters(s);
  let wallWidth = valf(styles.gap, 4);
  let lines = s.split('"').filter(x => !isWhiteSpaceString(x));
  let cols = lines[0].split(' ').length;
  let rows = lines.length;
  let wHouse = Math.round(styles.w / cols) * cols + wallWidth * cols + 1;
  let hHouse = Math.round(styles.h / rows) * rows + wallWidth * rows + 1;
  d.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
  d.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
  let szDoor = valf(styles.szDoor, 40);
  let [wallColor, floorColor] = [valf(styles.fg, 'white'), valf(styles.bg, BLUE)];
  mStyleX(d, { bg: wallColor, w: wHouse, h: hHouse, gap: wallWidth, padding: wallWidth });
  let rooms = [];
  for (const ch of letterList) {
    let r = iRoom(d, ch, { bg: floorColor });
    rooms.push(r);
  }
  let house = { rect: getRect(d), fg: wallColor, bg: floorColor, doors: [], rooms: rooms.map(x => x.id), roomLetters: letterList, szDoor: szDoor, wallWidth: wallWidth };
  house.roomsByLetter = {};
  rooms.map(x => house.roomsByLetter[x.ch] = x.id);
  iAdd(house, { div: d });
  rooms.map(x => x.house = house.id);
  roomAdjacency(house);
  return house;
}
function iInit(dParent, item) {
  if (is_canvas(dParent)) draw_on_canvas(dParent.cx, item);
  else draw_on_div(dParent, item);
}
function iLabel(i) { return isdef(i.live) ? i.live.dLabel : isdef(i.dLabel) ? i.dLabel : null; }
function iLabyrint(dParent, cols, rows, styles = { w: 800, h: 400 }) {
  let d = mDiv(dParent, { display: 'inline-grid', position: 'relative', box: true });
  ns = isNumber(ns) ? d.style.gridTemplateAreas = getLayoutSample(ns) : ns; //'"z z d" "a a c" "a a c"';// getLayoutSample(3);
  let s = d.style.gridTemplateAreas = ns;
  let letterList = filterDistinctLetters(s);
  let wallWidth = valf(styles.gap, 4);
  let lines = s.split('"').filter(x => !isWhiteSpaceString(x));
  let wHouse = Math.round(styles.w / cols) * cols + wallWidth * cols + 1;
  let hHouse = Math.round(styles.h / rows) * rows + wallWidth * rows + 1;
  d.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
  d.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
  let szDoor = valf(styles.szDoor, 40);
  let [wallColor, floorColor] = [valf(styles.fg, 'white'), valf(styles.bg, BLUE)];
  mStyleX(d, { bg: wallColor, w: wHouse, h: hHouse, gap: wallWidth, padding: wallWidth });
  let rooms = [];
  for (const ch of letterList) {
    let r = iRoom(d, ch, { bg: floorColor });
    rooms.push(r);
  }
  let house = { rect: getRect(d), fg: wallColor, bg: floorColor, doors: [], rooms: rooms.map(x => x.id), roomLetters: letterList, szDoor: szDoor, wallWidth: wallWidth };
  house.roomsByLetter = {};
  rooms.map(x => house.roomsByLetter[x.ch] = x.id);
  iAdd(house, { div: d });
  rooms.map(x => x.house = house.id);
  roomAdjacency(house);
  return house;
}
function iLetters(s, dParent, style) {
  let d = mDiv(dParent);
  for (let i = 0; i < s.length; i++) {
    let d1 = mDiv(d);
    d1.innerHTML = s[i];
    mStyleX(d1, style);
  }
  return d;
}
function image_show(e) {
  var image = e.target.src;
  var image_viewer = mBy("image_viewer");
  image_viewer.innerHTML = "<img src='" + image + "' style='width:100%' />";
  image_viewer.className = "image_on";
}
function imageFileTests() {
  initTable(); Items = {};
  Socket = io(SERVERURL);
  let item = mFileInput(dTable);
  mLinebreak(dTable, 25);
  let btn = mButton('upload', () => mSocketUploadImage(item, Socket), dTable);
}
function iMagnify(perle) { mMagnify(null, perle); }
function iMagnifyCancel() { mCancelMagnify(); }
function iMagnifyX(ui, item, pos) {
  let path = item.path;
  if (isdef(MAGNIFIER_IMAGE) && MAGNIFIER_IMAGE.src == path) {
    console.log('schon offen!!!')
    return;
  } else if (isdef(MAGNIFIER_IMAGE)) mCancelMagnify();
  let imgSize = 514, fontSize = 24;
  let [w, h, fz] = [imgSize, imgSize + fontSize + 10, fontSize];
  let dPresent = MAGNIFIER_IMAGE = mDiv(document.body, { bg: HeaderColor, position: 'absolute', left: 0, top: 0, w: w, h: h });
  let d = dPresent;
  let dText = mText(item.text, d, { color: 'white', fz: fz });
  let dImage = mDiv(d, { rounding: '50%', w: w, h: w });
  mCenterCenterFlex(dImage);
  let img1 = mImg(path, dImage, {});
  mCenterCenterFlex(dPresent);
}
function iMakeHand(iarr, dParent, styles, id) {
  let data = DA[id] = {};
  let h = data.deck = new DeckClass();
  h.init(iarr);
  iPresentHand(data, dParent, styles);
  return data;
}
function iMakeHand_test(dParent, iarr, id) {
  let data = DA[id] = {};
  let h = data.deck = new DeckClass();
  h.init(iarr);
  iPresentHand_test(dParent, data);
  return data;
}
function iMeasure(item, sizingOptions) {
  if (nundef(iDiv(item))) return;
  setRect(iDiv(item), valf(sizingOptions, { hgrow: true, wgrow: true }));
}
function iMenuLine(dParent, styles) {
  let d = mRow(dParent, styles);
  console.log('d', d)
  let item = mItem('dMenu', { div: d }, { type: 'menu' });
  return item;
}
function iMenuSidebarDiv(dParent, options) {
  let d0 = mDiv100(dParent, options.outerStyles);
  setRect(d0);
  let dMenu = mDiv(d0, options.menuStyles);
  let b = mButton(options.bCaption, null, dMenu, options.bStyles, 'mybutton', getUID('b'));
  setRect(dMenu, { hfix: true, wgrow: true });
  let st = options.innerStyles;
  st.position = 'relative';
  st.h = d0.rect.h - dMenu.rect.h - valf(st.matop, 0);
  let d = mDiv(d0, options.innerStyles);
  let dSide = mDiv(d, options.sbStyles);
  let dContent = mDiv(d, options.divStyles, getUID());
  let sb = iSidebar(dSide, dContent, b, 120, false);
  let item = mItem(getUID('comp'), { div: d0, button: b, dMenu: dMenu, sidebar: sb, dContent: dContent }, { type: 'component' });
  return item;
}
function iMessage(item, msg) { let dm = diMessage(item); if (isdef(dm)) dm.innerHTML = msg; }
function img_html(filename, fulldim = 'height') {
  return `<img ${fulldim}='100%' src='../rechnung/images/${filename}'>`;
}
function iMoveFromTo(item, d1, d2, callback, offset) {
  let bi = iBounds(item);
  let b1 = iBounds(d1);
  let b2 = iBounds(d2);
  if (nundef(offset)) offset = { x: 0, y: 0 };
  let dist = { x: b2.x - b1.x + offset.x, y: b2.y - b1.y + offset.y };
  item.div.style.zIndex = 100;
  let a = aTranslateBy(item.div, dist.x, dist.y, 500);
  a.onfinish = () => { mAppend(d2, item.div); item.div.style.zIndex = item.z = iZMax(); if (isdef(callback)) callback(); };
}
function iMoveFromToPure(item, d1, d2, callback, offset) {
  let bi = iBounds(item);
  let b1 = iBounds(d1);
  let b2 = iBounds(d2);
  if (nundef(offset)) offset = { x: 0, y: 0 };
  let dist = { x: b2.x - b1.x + offset.x, y: b2.y - b1.y + offset.y };
  item.div.style.zIndex = 100;
  let a = aTranslateBy(item.div, dist.x, dist.y, 500);
  a.onfinish = () => { if (isdef(callback)) callback(); };
}
function in_game() { return isdef(mBy('table')) && Session.in_game == `${Session.cur_user} ${Session.cur_tid}`; }
function in_game_off() { Session.in_game = null; }
function in_game_on() { Session.in_game = `${Session.cur_user} ${Session.cur_tid}`; }
function in_game_open_prompt() { return uiActivated && Session.in_prompt == `${Session.cur_user} ${Session.cur_tid}`; }
function in_game_open_prompt_off() { Session.in_prompt = null; }
function in_game_open_prompt_on() { Session.in_prompt = `${Session.cur_user} ${Session.cur_tid}`; }
function inc_g_index() { set_g_index(G.i + 1); }
function inc_handsize(fen, uname) {
  let pl = fen.players[uname];
  pl.handsize = Number(pl.handsize) + 1;
  return pl.handsize;
}
function inc_level_on_winstreak(winners, game) {
  for (const w of winners) {
    let o = lookup(DB.users, [w, 'games', game]);
    console.assert(isdef(o), 'no DB.users record for game', game);
    o.winstreak = DB.users[w].games[game].winstreak = isdef(o.winstreak) ? o.winstreak + 1 : 1;
    if (o.winstreak >= 1) {
      let currentlevel = get_startlevel(w, game);
      lookupSetOverride(DB.users, [w, 'games', game, 'startlevel'], Math.min(currentlevel + 1, Session.maxlevel));
      delete o.winstreak;
    }
  }
}
function inc_player_score(plname) { ensure_score(plname); return Z.fen.players[plname].score += 1; }
function incInput(inp, n = 1) {
  let val = Number(inp.innerHTML);
  val += n;
  inp.innerHTML = val;
}
function includesAnyOf(s, slist) { for (const l of slist) { if (s.includes(l)) return true; } return false; }
function increase_handicap_if_losestreak(losers, game) {
  console.log('winners', losers);
  for (const w of losers) {
    let o = lookupSet(DB.users, [w, 'games', game], {});
    if (nundef(o.losestreak)) o.losestreak = 1; else o.losestreak += 1;
    if (o.losestreak >= 1) {
      lookupSetOverride(o, ['startlevel'], Math.max(o.startlevel - 1, 0));
      o.losestreak = 0;
      console.log('...startlevel of', w, 'is decreased to', get_startlevel(w, game));
    }
  }
}
function incrementSimulation() {
  if (mouse.down) {
    var dx = mouse.x - circle.x,
      dy = mouse.y - circle.y,
      distance = Math.sqrt(dx * dx + dy * dy),
      unitX = dx / distance,
      unitY = dy / distance,
      force = distance * mousePullStrength;
    circle.vx += unitX * force;
    circle.vy += unitY * force;
  }
  circle.vy += gravity;
  circle.vx *= dampening;
  circle.vy *= dampening;
  circle.x += circle.vx;
  circle.y += circle.vy;
  if (circle.y + radius > canvas.height) {
    circle.y = canvas.height - radius;
    circle.vy = - Math.abs(circle.vy);
  }
  else if (circle.y - radius < 0) {
    circle.y = radius;
    circle.vy = Math.abs(circle.vy);
  }
  if (circle.x + radius > canvas.width) {
    circle.x = canvas.width - radius;
    circle.vx = - Math.abs(circle.vx);
  }
  else if (circle.x - radius < 0) {
    circle.x = radius;
    circle.vx = Math.abs(circle.vx);
  }
}
function indexDiff(a, b, s) {
  let ia = s.indexOf(a);
  let ib = s.indexOf(b);
  console.log('index of', a, 'is', ia)
  console.log('index of', b, 'is', ib)
  return ia - ib;
}
function indexOfAny(s, list, pos) {
  let min = 1000000;
  let match = null;
  for (const w of list) {
    let i = s.indexOf(w, pos);
    if (i >= 0 && i < min) { min = i; match = w; }
  }
  return match ? [min, match] : [-1, null];
}
function indexOfFuncMax(arr, prop, f) {
  let max = null;
  let imax = null;
  for (const [i, v] of arr.entries()) {
    let val = isdef(prop) && isdef(v[prop]) ? v[prop] : v;
    if (isdef(f)) val = f(val);
    if (max == null || val > max) { max = val; imax = i }
  }
  return { i: imax, val: max };
}
function indexOfFuncMin(arr, prop, f) {
  let min = null;
  let imax = null;
  for (const [i, v] of arr.entries()) {
    let val = isdef(prop) && isdef(v[prop]) ? v[prop] : v;
    if (isdef(f)) val = f(val);
    if (min == null || val < min) { min = val; imax = i }
  }
  return { i: imax, val: min };
}
function indexOfMax(arr, prop) {
  let max = null;
  let imax = null;
  for (const [i, v] of arr.entries()) {
    if (prop) {
      if (max == null || v[prop] > max) {
        max = v[prop];
        imax = i;
      } else {
        if (max == null || v > max) {
          max = v;
          imax = i;
        }
      }
    }
  }
  return { i: imax, val: max };
}
function indexOfMin(arr, prop) {
  let min = null;
  let imin = null;
  for (const [i, v] of arr.entries()) {
    if (prop) {
      if (min == null || lookup(v, [prop]) < min) {
        min = v[prop];
        imin = i;
      }
    } else {
      if (min == null || v < min) {
        min = v;
        imin = i;
      }
    }
  }
  return { i: imin, val: min };
}
function inferPlayerColorFromNameOrInit(plid, index) {
  let cname = plid.toLowerCase();
  if (cname in playerColors) return playerColors[cname];
  if (nundef(index)) index = 0;
  let ckeys = getKeys(playerColors);
  return playerColors[ckeys[index] % playerColors.length];
}
function inferType(val) {
  for (const t of ['region', 'power', 'unit', 'faction']) {
    if (isType(t, val)) {
      return t;
    }
  }
  return 'unknown';
}
function info_from_fen(fen) {
  let all_attrs = gSet_attributes();
  let keys = get_keys(all_attrs);
  let info = {};
  for (let i = 0; i < fen.length; i++) {
    let prop = keys[i];
    let val = all_attrs[prop][Number(fen[i])];
    info[prop] = val;
  }
  return info;
}
function infoHasNumber(info) {
  let ws = info.words;
  return firstCond(ws, x => isNumber(x));
}
function infoHasNumberOrTimeString(info) {
  return infoHasNumber(info) || infoHasTimeString(info);
}
function infoHasTimeString(info) {
  let ws = info.words;
  return firstCond(ws, x => isTimeString(x));
}
function infoLayout(n, R) {
}
function infoToItem(x) { let item = { info: x, key: x.key }; item.id = iRegister(item); return item; }
function init() {
  createPeeps()
  resize()
  gsap.ticker.add(render)
  window.addEventListener('resize', resize)
}
function init_internet() { DA.internet = navigator.onLine; }
function init_keyhandlers() {
  onkeyup = onkeyupHandler;
}
function init_table() {
  dTable = mBy('dTable'); mStyle(dTable, { box: true, padding: 10, hmin: 500, w: '100%' });
}
function initActionPanel() {
  show('dLeftSide');
  let dParent = mBy('dLeftSide');
  clearElement(dParent);
  dLeiste = mDiv(dParent);
  mStyle(dLeiste, { wmin: 70, hmin: '100%', display: 'flex', 'flex-flow': 'column wrap' });
}
function initAutoplayToActionButtons() {
  if (S.settings.game == 'catan') setKeys(S.settings, ['dev', 'keywords', 'action'], { buy: 'buy devcard', hex: 'place robber', Corner: 'settlement or city', Edge: 'road' })
  else setKeys(S.settings, ['dev', 'keywords', 'action'], {});
  let d = document.getElementById('a_d_autoplay_buttons');
  let buttons = [...d.children];
  let defaultIds = ['c_b_NextPlayer', 'c_b_NextTurn'];
  let kws = lookup(S.settings, ['dev', 'keywords', 'action']);
  if (!kws) kws = {};
  let kwKeys = getKeys(kws);
  let requiredButtonIds = kwKeys.map(x => 'c_b_RTA_' + x).concat(defaultIds);
  let actualButtons = buttons.filter(x => x.id).map(x => x.id);
  for (const id of arrMinus(actualButtons, requiredButtonIds)) $('#' + id).remove();
  for (const id of arrMinus(requiredButtonIds, actualButtons)) {
    let b = document.createElement('button');
    let key = id.substring(8);
    b.innerHTML = kws[key];
    b.id = id;
    b.onclick = () => onClickRunToAction(b.id, id);
    d.appendChild(b);
  }
}
function initAux() {
  dAux = mBy('dAux');
}
function InitBoardSquares() {
  var light = 0;
  var rankName;
  var fileName;
  var divString;
  var lightString;
  var lastLight = 0;
  for (rankIter = RANKS.RANK_8; rankIter >= RANKS.RANK_1; rankIter--) {
    light = lastLight ^ 1;
    lastLight ^= 1;
    rankName = "rank" + (rankIter + 1);
    for (fileIter = FILES.FILE_A; fileIter <= FILES.FILE_H; fileIter++) {
      fileName = "file" + (fileIter + 1);
      if (light == 0) lightString = "Light";
      else lightString = "Dark";
      divString = "<div class=\"Square clickElement " + rankName + " " + fileName + " " + lightString + "\"/>";
      light ^= 1;
      $("#ChessBoard").append(divString);
    }
  }
}
function initBoardSquares() {
  var light = 0;
  var rowName;
  var colName;
  var divString;
  var lightString;
  var lastLight = 0;
  for (rowIter = ROWS.ROW_8; rowIter >= ROWS.ROW_1; rowIter--) {
    light = lastLight ^ 1;
    lastLight ^= 1;
    rowName = "row" + (rowIter + 1);
    for (colIter = COLUMNS.COL_A; colIter <= COLUMNS.COL_H; colIter++) {
      colName = "col" + (colIter + 1);
      if (light == 0) lightString = "Light";
      else lightString = "Dark";
      divString = "<div class=\"Square clickElement " + rowName + " " + colName + " " + lightString + "\"/>";
      light ^= 1;
      $("#Board").append(divString);
    }
  }
}
function InitBoardVars() {
  var index = 0;
  for (index = 0; index < MAXGAMEMOVES; index++) {
    brd_history.push({
      move: NOMOVE,
      castlePerm: 0,
      enPas: 0,
      fiftyMove: 0,
      posKey: 0
    });
  }
  for (index = 0; index < PVENTRIES; index++) {
    brd_PvTable.push({
      move: NOMOVE,
      posKey: 0
    });
  }
}
function InitColsRowsBrd() {
  var index = 0;
  var col = COLUMNS.COL_A;
  var row = ROWS.ROW_1;
  var sq = SQUARES.A1;
  var sq64 = 0;
  for (index = 0; index < BRD_SQ_NUM; ++index) {
    ColBrd[index] = SQUARES.OFFBOARD;
    RowBrd[index] = SQUARES.OFFBOARD;
  }
  for (row = ROWS.ROW_1; row <= ROWS.ROW_8; ++row) {
    for (col = COLUMNS.COL_A; col <= COLUMNS.COL_H; ++col) {
      sq = fromRCMxToNumArrSq(col, row);
      ColBrd[sq] = col;
      RowBrd[sq] = row;
    }
  }
}
function initCrowd() {
  while (availablePeeps.length) {
    addPeepToCrowd().walk.progress(Math.random())
  }
}
function initDom() {
  ROOT = makeRoot();
  createMSTree(ROOT);
  simpleColors(S.settings.color.theme);
  measureMSTree(ROOT);
  if (!firstDomLoad) {
    initZoom();
    zoom_on_resize('a_d_header');
    zoom_on_wheel_alt();
    firstDomLoad = true;
  }
}
function InitFilesRanksBrd() {
  var index = 0;
  var file = FILES.FILE_A;
  var rank = RANKS.RANK_1;
  var sq = SQUARES.A1;
  var sq64 = 0;
  for (index = 0; index < BRD_SQ_NUM; ++index) {
    FilesBrd[index] = SQUARES.OFFBOARD;
    RanksBrd[index] = SQUARES.OFFBOARD;
  }
  for (rank = RANKS.RANK_1; rank <= RANKS.RANK_8; ++rank) {
    for (file = FILES.FILE_A; file <= FILES.FILE_H; ++file) {
      sq = FR2SQ(file, rank);
      FilesBrd[sq] = file;
      RanksBrd[sq] = rank;
    }
  }
}
function initGameScreen() {
  console.log('IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII!!!!!!!!!!')
  hide('dMainContent'); hide('dHeader'); show('dButtons');
  show('dGameScreen');
  console.log('game should be starting!!!');
  if (isdef(G)) {
    console.log('should just go back to game!');
  } else {
    _start();
  }
}
function InitHashKeys() {
  var index = 0;
  for (index = 0; index < 13 * 120; ++index) {
    PieceKeys[index] = RAND_32();
  }
  SideKey = RAND_32();
  for (index = 0; index < 16; ++index) {
    CastleKeys[index] = RAND_32();
  }
}
function initialize_state() {
  let dpop = mBy('dPopup'); dpop.onclick = ev => evNoBubble(ev);
  onclick = close_popup;
  onkeyup = keyhandler;
  let state = localStorage.getItem('boa');
  if (state) S = JSON.parse(state);
  else S = { location: null, boa_state: null, bw_state: null, master_password: null, score: 0, };
  S.location = 'home';
  S.bw_state = 'loggedin';
  S.boa_state = null;
}
function initLineBottom() {
  dLineBottomOuter = mDiv(table); dLineBottomOuter.id = 'lineBottomOuter';
  dLineBottom = mDiv(dLineBottomOuter); dLineBottom.id = 'lineBottom';
  dLineBottomLeft = mDiv(dLineBottom); dLineBottomLeft.id = 'lineBottomLeft';
  dLineBottomRight = mDiv(dLineBottom); dLineBottomRight.id = 'lineBottomRight';
  dLineBottom = mDiv(dLineBottom); dLineBottom.id = 'lineBottomMiddle';
  mLinebreak(table);
}
function initLineNavi() {
  dNavi = mBy('freezer');
  mStyleX(dNavi, { bg: 'navy', margin: 0, padding: 0, pabottom: 4, paleft: 4 })
  dLineNaviOuter = mDiv(dNavi); dLineNaviOuter.id = 'lineNaviOuter';
  dLineNavi = mDiv(dLineNaviOuter); dLineNavi.id = 'lineNavi';
  dLineNaviLeft = mDiv(dLineNavi); dLineNaviLeft.id = 'lineNaviLeft';
  dLineNaviRight = mDiv(dLineNavi); dLineNaviRight.id = 'lineNaviRight';
  dLineNaviMiddle = mDiv(dLineNavi); dLineNaviMiddle.id = 'lineNaviMiddle';
  mLinebreak(table);
}
function initLineTable() {
  dLineTableOuter = mDiv(table); dLineTableOuter.id = 'lineTableOuter';
  dLineTable = mDiv(dLineTableOuter); dLineTable.id = 'lineTable';
  dLineTableLeft = mDiv(dLineTable); dLineTableLeft.id = 'lineTableLeft';
  dLineTableMiddle = mDiv(dLineTable); dLineTableMiddle.id = 'lineTableMiddle';
  mClass(dLineTableMiddle, 'flexWrap');
  dLineTableRight = mDiv(dLineTable); dLineTableRight.id = 'lineTableRight';
  mLinebreak(table);
}
function initLineTitle() {
  dLineTitleOuter = mDiv(table); dLineTitleOuter.id = 'lineTitleOuter';
  dLineTitle = mDiv(dLineTitleOuter); dLineTitle.id = 'lineTitle';
  if (PROJECTNAME != 'belinda') mStyle(dLineTitle, { matop: 5 });
  dLineTitleLeft = mDiv(dLineTitle); dLineTitleLeft.id = 'lineTitleLeft';
  dLineTitleRight = mDiv(dLineTitle); dLineTitleRight.id = 'lineTitleRight';
  dLineTitleMiddle = mDiv(dLineTitle); dLineTitleMiddle.id = 'lineTitleMiddle';
  mLinebreak(table);
}
function initLineTop() {
  dLineTopOuter = mDiv(table); dLineTopOuter.id = 'lineTopOuter';
  dLineTop = mDiv(dLineTopOuter); dLineTop.id = 'lineTop';
  dLineTopLeft = mDiv(dLineTop); dLineTopLeft.id = 'lineTopLeft';
  dLineTopRight = mDiv(dLineTop); dLineTopRight.id = 'lineTopRight';
  dLineTopMiddle = mDiv(dLineTop); dLineTopMiddle.id = 'lineTopMiddle';
  dScore = mDiv(dLineTopMiddle);
  dScore.id = 'dScore';
  dLevel = mDiv(dLineTopLeft);
  dLevel.id = 'dLevel';
  dGameTitle = mDiv(dLineTopRight);
  dGameTitle.id = 'dGameTitle';
  let d = mDiv(dLineTopRight);
  d.id = 'time';
  mLinebreak(table);
}
function initLive() { Live = {}; }
function initLobby(username) {
  hide('dGameScreen'); hide('dButtons');
  show('dMainContent'); show('dLobby'); show('dHeader'); show('dTempleLobby');
  setTitle('Welcome to the Lobby');
  if (isString(username)) { sendLogin(username); console.log('...', username) }
  else username = U.name;
  sendBtn.onclick = e => {
    e.preventDefault();
    if (!messageInput.value) {
      if (GENERATE_EMPTY_MESSAGES) messageInput.value = 'hallo';
      else return console.log('must supply a message');
    }
    const message = { author: username, date: formatDate(new Date()), content: messageInput.value };
    console.log('sending message', message)
    sendUserMessage(message);
    messageInput.value = '';
  };
}
function initLocalClocks() {
  var date = new Date;
  var seconds = date.getSeconds();
  var minutes = date.getMinutes();
  var hours = date.getHours();
  var hands = [
    {
      hand: 'hours',
      angle: (hours * 30) + (minutes / 2)
    },
    {
      hand: 'minutes',
      angle: (minutes * 6)
    },
    {
      hand: 'seconds',
      angle: (seconds * 6)
    }
  ];
  for (var j = 0; j < hands.length; j++) {
    var elements = document.querySelectorAll('.' + hands[j].hand);
    for (var k = 0; k < elements.length; k++) {
      elements[k].style.webkitTransform = 'rotateZ(' + hands[j].angle + 'deg)';
      elements[k].style.transform = 'rotateZ(' + hands[j].angle + 'deg)';
      if (hands[j].hand === 'minutes') {
        elements[k].parentNode.setAttribute('data-second-angle', hands[j + 1].angle);
      }
    }
  }
}
function InitMvvLva() {
  var Attacker;
  var Victim;
  for (Attacker = PIECES.wP; Attacker <= PIECES.bK; ++Attacker) {
    for (Victim = PIECES.wP; Victim <= PIECES.bK; ++Victim) {
      MvvLvaScores[Victim * 14 + Attacker] = VictimScore[Victim] + 6 - (VictimScore[Attacker] / 100);
    }
  }
}
function initOptions() {
  setDefaultOptions();
  S.options.colors = getColors(3);
  S.options.clickToSelect = true;
  S.options.tooltips = document.getElementById('bTTip').textContent.includes('ON');
  setPlayMode(S_playMode);
  if (isdef(S.user.spec)) {
    for (const k in S.user.spec.OPTIONS) {
      S.options[k] = S.user.spec.OPTIONS[k];
    }
  }
  initAutoplayToActionButtons();
  initTextures();
  setColorPalette(S.options.colors);
}
function initPage() {
  let colors = ['#27344b', '#485b6c', '#383e48', '#f2f7f8'];
  mStyle(dMain, { padding: 0, margin: 0 });
  let dLeft = mDiv(dMain, { hmin: 500, bg: colors[0], flex: 1 }, 'dLeft');
  let dRight = mDiv(dMain, { hmin: 500, flex: 4 }, 'dRight');
  let dHeader = mDiv(dRight, { bg: colors[1], align: 'center', h: 70, fz: 40, family: 'summervibes', position: 'relative' }, 'dHeader', 'My Chat');
  let dContainer = mDiv(dRight, { display: 'flex' });
  let dInnerLeft = mDiv(dContainer, { position: 'relative', hmin: 430, bg: colors[2], flex: 1 }, 'dInnerLeft');
  mCenterCenterFlex(dInnerLeft);
  let dInnerRight = mDiv(dContainer, { transition: `all ${DELAY_PANE}ms ease`, hmin: 430, bg: colors[3], flex: 2, align: 'center' }, 'dInnerRight');
  let dChatWindow = mDiv(dInnerRight, { display: 'none', 'overflow-x': 'hidden', 'overflow-y': 'auto', padding: 10, fg: 'black', align: 'left' }, 'dChatWindow');
  let dGameWindow = mDiv(dInnerRight, { display: 'none', overflow: 'hidden' }, 'dGameWindow');
  let dUserInfo = mDiv(dLeft, { padding: 10, align: 'center' }, 'dUserInfo');
  let dToolbar = mDiv(dLeft, { matop: 40, align: 'center' });
  for (const t of ['Games', 'Tables', 'Chat', 'Contacts', 'Account']) {
    let text = t + ` <img src="../base/assets/images/icons/${t}.png" height="90%" style="float:right"/>`;
    let dLabel = mLabel(text, dToolbar, { padding: 5, cursor: 'pointer', w: '100%', h: 30, display: 'block', 'border-bottom': 'solid thin #ffffff55' });
    dLabel.onclick = () => window['onClickMenu'](t.toLowerCase());
    let d = mDiv(dInnerLeft, { position: 'absolute', w: '100%', h: '100%', display: 'none' }, 'd' + t);
  }
}
function initPageHeader() {
  pageHeaderSetGame();
  pageHeaderSetPlayers();
}
function initPlayers() {
  S.players = {};
  G.players = {};
  let ckeys = Object.keys(playerColors);
  let i = 0;
  for (const id in G.serverData.players) {
    let pl = G.serverData.players[id];
    let colorName = isdef(pl.color) ? pl.color : ckeys[i];
    colorName = colorName.toLowerCase();
    let altName = capitalize(colorName);
    let color = isdef(playerColors[colorName]) ? playerColors[colorName] : colorName;
    let username = isdef(S.gameInfo.userList) ? S.gameInfo.userList[i]
      : isdef(S.plAddedByMe) && S.plAddedByMe[id] ? S.plAddedByMe[id] : 'unknown' + i;
    S.players[id] = { username: username, id: id, color: color, altName: altName, index: i };
    i += 1;
  }
}
function initRSGData() {
  S.user = {};
  G = { table: {}, players: {} };
  UIS = {};
  IdOwner = {};
  id2oids = {};
  oid2ids = {};
  id2uids = {};
  DELETED_IDS = [];
}
function initScore() { resetScore(); }
function initServerPool(settings, state, perlenDict) {
  let pool = {};
  let poolArr = [];
  let maxPoolIndex = 0;
  addKeys(settings, { poolSelection: 'random', numPool: 20 });
  let n = settings.poolSelection != 'player' ? settings.numPool : 0;
  let keys = getRandomPerlenKeys(perlenDict, n);
  for (const k of keys) {
    addToPool(pool, poolArr, perlenDict[k], maxPoolIndex);
    maxPoolIndex += 1;
  }
  state.pool = pool;
  state.poolArr = poolArr;
  return maxPoolIndex;
}
function initSETTINGS() {
  setDefaultRSGSettings();
  setPlaymode(S.settings.playmode, true);
  S.settings.dev = {};
  if (S.settings.userSettings) _mergeOptions();
  _initAutoplayToActionButtons();
  _initCheatButtons();
  _initScenarioButtons();
}
function initSettings(game) {
  Settings = deepmergeOverride(DB.settings, U.settings);
  delete Settings.games;
  let gsSettings = lookup(U, ['games', game, 'settings']);
  if (isdef(gsSettings)) Settings = deepmergeOverride(Settings, gsSettings);
  updateSettings();
}
function initSettingsP0() {
  let iLanguage = mBy('input' + currentLanguage);
  iLanguage.checked = true;
  let iPicsPerLevel = mBy('inputPicsPerLevel');
  iPicsPerLevel.value = PICS_PER_LEVEL;
}
function initSidebar() {
  show('dLeftSide');
  let dParent = mBy('dLeftSide');
  clearElement(dParent);
  dLeiste = mDiv(dParent);
  mStyle(dLeiste, { wmin: 70, hmax: '100vh', display: 'flex', 'flex-flow': 'column wrap' });
}
function initSidebar1() {
  show(dSidebar);
  clearElement(dSidebar);
  mDiv(dSidebar, { 'min-width': 50, 'max-height': '100vh', display: 'flex', 'flex-flow': 'column wrap', 'align-content': 'center' }, 'dLeiste');
}
function initSocket() {
  Socket = io();
  Socket.on('clientId', handleClientIdSendLogin);
  Socket.on('db', handleDB);
  Socket.on('userJoined', handleUserJoined);
  Socket.on('userLeft', handleUserLeft);
  Socket.on('userMessage', handleUserMessage);
  Socket.on('gameState', handleGameState);
  Socket.on('dbUpdate', handleDbUpdate);
  Socket.on('mouse', handleMouse);
  Socket.on('show', handleShow);
  Socket.on('hide', handleHide);
}
function InitSq120To64() {
  var index = 0;
  var file = FILES.FILE_A;
  var rank = RANKS.RANK_1;
  var sq = SQUARES.A1;
  var sq64 = 0;
  for (index = 0; index < BRD_SQ_NUM; ++index) {
    Sq120ToSq64[index] = 65;
  }
  for (index = 0; index < 64; ++index) {
    Sq64ToSq120[index] = 120;
  }
  for (rank = RANKS.RANK_1; rank <= RANKS.RANK_8; ++rank) {
    for (file = FILES.FILE_A; file <= FILES.FILE_H; ++file) {
      sq = FR2SQ(file, rank);
      Sq64ToSq120[sq64] = sq;
      Sq120ToSq64[sq] = sq64;
      sq64++;
    }
  }
}
function initSTRUCTURES() {
  let data = S.user.spec.STRUCTURES;
  if (nundef(data)) return;
  BINDINGS = {};
  let hasStructure = false;
  for (const areaName in data) {
    reqs = data[areaName];
    let mobj = makeArea(areaName, reqs.location);
    let areaId = mobj.id;
    for (const prop in reqs) {
      let val = reqs[prop];
      if (prop == 'location') continue;
      if (prop == 'structure') {
        hasStructure = true;
        let info = reqs.structure;
        let func = info.type;
        let odict = parseDictionaryName(info.object_pool);
        if (!odict) odict = G.table;
        let boardInfo = info.cond;
        let structObject = window[func](odict, areaId, boardInfo);
        timit.showTime('*** board end ***')
      } else if (prop == 'binding') {
        BINDINGS[areaId] = val;
      } else {
        let lst = jsCopy(val);
        let func = 'set' + capitalize(prop);
        let params = lst;
        if (!Array.isArray(params)) params = params.split(',');
        if (mobj[func] !== null) mobj[func](...params);
      }
    }
  }
  return hasStructure;
}
function initSymbolTableForGamesAddons() {
  Daat.GameClasses = {
    gTouchPic: GTouchPic, gNamit: GNamit, gStory: GStory,
    gTouchColors: GTouchColors, gPremem: GPremem, gMem: GMem, gMissingLetter: GMissingLetter,
    gMissingNumber: GMissingNumber, gWritePic: GWritePic, gSayPic: GSayPic, gSteps: GSteps, gElim: GElim,
    gAnagram: GAnagram, gAbacus: GAbacus, gPasscode: GPasscode, gCats: GCats,
  }
}
async function initSyms() {
  console.log('haloooooooooooooooo');
}
function initTable() {
  clearElement(dTableBackground);
  setTableBackground(RED, 'white', true);
  let ltitle = get3ColLineName(dTableBackground, 'title', { hmin: 30 });
  mStyleX(dTitle, { maleft: -50 })
  let ltable = get3ColLineName(dTableBackground, 'table', {});
  let lbottom = get3ColLineName(dTableBackground, 'bottom', { position: 'absolute', bottom: 30 });
}
function initTableOptions(playMode) {
  if (playMode == 'play') {
    S.options.table = {
      showComplexVals: false,
      optIn: null,
      optOut: { visible: -1, obj_type: -1, row: -1, col: -1, rows: -1, cols: -1, neighbors: -1, corners: -1, edges: -1, fields: -1, id: -1, name: -1 },
      showProps: false,
      sysprop: { player: presentPlayer },
      fontSize: M.game == 'catan' ? 12 : 60
    };
  } else {
    S.options.table = {
      showComplexVals: true,
      optin: null,
      optOut: { row: -1, col: -1, neighbors: -1, corners: -1, edges: -1, obj_type: -1, name: -1, id: -1 },
      showProps: true,
      sysprop: M.game == 'catan' ? null : { visible: presentVisible },
      fontSize: 12
    };
  }
}
function initTABLES() {
  let tables = {
    a_d_game: S.settings.gameAreaSize,
  };
  document.getElementById('c_d_statusInHeaderText').innerHTML = ''
  if (isPlain()) {
    let space = 400;
    let pmainSpace = space;
    let pothersSpace = (space - 100) * (S.gameConfig.numPlayers - 1);
    setCSSVariable('--wPlayers', '' + pothersSpace + 'px');
    S.settings.table.defaultArea = 'a_d_objects';
    S.settings.player.defaultArea = 'a_d_player'; //'a_d_options';
    S.settings.player.defaultMainArea = 'a_d_game';
    tables.a_d_game = [pmainSpace, 800];
    document.getElementById('c_d_statusText').innerHTML = 'Me'
  } else {
    document.getElementById('a_d_player_header').innerHTML = '<p>players</p>';
    setCSSVariable('--wPlayers', '400px');
    S.settings.table.defaultArea = 'a_d_objects';
    S.settings.player.defaultArea = 'a_d_player'; //'a_d_options';
    S.settings.player.defaultMainArea = null;
    let d = document.getElementById('a_d_game');
    d.style.overflow = 'visible';
    d.classList.remove('flexWrap');
  }
  for (const areaName of [S.settings.table.defaultArea, S.settings.player.defaultArea, S.settings.player.defaultMainArea]) {
    if (areaName === null) continue;
    let d = document.getElementById(areaName);
    if (d.id != 'a_d_player') { d.style.overflowY = 'auto'; }
    d.style.overflowX = 'hidden';
    d.classList.add('flexWrap');
  }
  for (const areaName in tables) {
    setAreaWidth(areaName, tables[areaName][0]);
    setAreaHeight(areaName, tables[areaName][1]);
  }
}
function initTextures() {
  let textures = lookup(S.options, ['assets', 'textures']);
  if (!textures) return;
  console.log(S.options.assets.textures)
  for (const s of S.options.assets.textures) {
    let key, val;
    if (isList(s)) { key = s[0]; val = s[1]; } else { key = s; val = s; }
  }
}
function initUI() {
  document.title = 'HA!';
  divMain = d3.select('#MAIN');
  divPlayer = d3.select('#PLAYER');
  divOpps = {};
  let dOpps = d3.select('#OPPS');
  for (const plid in playerConfig[GAME].players) {
    let dPlid = dOpps.append('div').attr('id', plid);
    divOpps[plid] = dPlid;
  }
  colors = ['blue', 'red', 'green', 'purple', 'black', 'white'];
  iColor = 0;
}
function initZoom() {
  let bz = localStorage.getItem('bodyZoom');
  if (bz) bz = Math.max(Number(bz), .2);
  else bz = 1.0;
  zoom(bz);
}
function initZoomToFit() { justExpand = true; zoom_on_resize(...arguments); }
function inno_action_achieve(otree, uname) {
  return [];
}
function inno_action_draw(otree, uname) {
  let [age, letter] = inno_get_deck_info_for_player(otree, uname);
  let res = `draw.decks.${letter}.${age}`;
  return [res];
}
function inno_action_meld(otree, uname) {
  return otree[uname].hand.map(x => `${uname}.hand.${x}`);
}
function inno_action_topcard(otree, uname) {
  let top2 = inno_get_top_card_actions(otree, uname);
  return top2;
}
function inno_activate(otree, r, uname, cardname) {
  let fname = `inno_${cardname}_todo`;
  if (nundef(window[fname])) { console.log('activate', cardname, 'NOT IMPLEMENTED!!!!'); return; }
  let todo = window[fname](otree, uname);
  let todo_incl_sharing = inno_add_sharing_players(otree, uname, cardname, todo);
  let idx = otree.todo.indexOf(r);
  console.assert(idx == otree.itask, 'inno_activate: itask does NOT point to r!!!!!');
  otree.todo.splice(idx, 1, ...todo_incl_sharing);
}
function inno_add_sharing_players(otree, uname, cardname, todo) {
  otree.pl_sharing = inno_calc_sharing(otree, uname, cardname);
  let task_list = jsCopy(todo);
  todo = [];
  for (const plname of otree.pl_sharing) {
    let new_task_list = [];
    for (const t of task_list) { let t1 = {}; t1.uname = plname; t1.id = getUID('r'); addKeys(t, t1); new_task_list.push(t1); }
    todo = todo.concat(new_task_list);
  }
  todo = todo.concat(task_list);
  return todo;
}
function inno_agriculture_post(otree, r, uname, action, item) {
  if (action != 'pass') {
    let card = inno_get_cardinfo(stringAfterLast(action, '.'));
    let deck = otree.decks[card.exp[0]][card.age];
    return_elem_to_deck_from(card.key, otree[uname].hand, deck);
    let n = card.age + 1;
    let pl = otree[uname];
    draw_from_deck_to(otree.decks.B[n], pl.scored);
  }
  next_task(otree, r);
  turn_send_move_update(otree, uname);
}
function inno_agriculture_pre(otree, r, uname) {
  r.actions = inno_get_hand_actions(otree, uname);
  r.actions.push('pass');
  activate_actions(r, uname);
}
function inno_agriculture_todo(otree, uname) {
  let r1 = {
    id: getUID('r'),
    uname: uname,
    key: 'inno_agriculture',
    actions: [],
    selected: null,
  };
  let list = [r1];
  return list;
}
function inno_branch(obj, otree, rtree) {
  ui_present_stats(otree);
  let uitree = ui_present_table(rtree, dTable);
  if (nundef(otree.todo)) { otree.todo = inno_todo_init(otree); }
  let req = otree.todo[otree.itask];
  console.log('____________', ITER);
  let my_turn = true;
  window[req.key + '_pre'](otree, req, req.uname);
}
function inno_calc_sharing(otree, uname, ckey) {
  let ci = inno_get_cardinfo(ckey);
  let sym = ci.type;
  let n = otree[uname].totals[sym];
  let pl_sharing = otree.plorder.filter(x => x != uname && otree[x].totals[sym] >= n);
  return pl_sharing;
}
function inno_calc_visible_syms(board, splays = {}) {
  let res = {};
  INNO.symNames.map(x => res[x] = 0);
  for (const color in board) {
    let res_color = inno_calc_visible_syms_pile(board[color], splays[color]);
    for (const k in res) { res[k] += res_color[k]; }
  }
  return res;
}
function inno_calc_visible_syms_pile(keys, dir) {
  let [cards, totals] = [keys.map(x => InnoById[x]), {}];
  INNO.symNames.map(x => totals[x] = 0);
  if (isEmpty(keys)) return totals;
  let top = cards.shift();
  for (const k of top.resources) {
    if (isdef(totals[k])) totals[k] += 1;
  }
  if (nundef(dir) || dir == 0) return totals;
  if (dir == 1) {
  } else if (dir == 2) {
    for (const c of cards) {
      for (const k in totals) {
        if (c.resources[0] == k) totals[k]++;
        if (c.resources[1] == k) totals[k]++;
      }
    }
  }
  return totals;
}
function inno_card(dParent, keyOrName) {
  if (nundef(keyOrName)) keyOrName = chooseRandom(get_keys(InnoById));
  let cardInfo, name, key, id;
  if (isdef(InnoById[keyOrName])) { id = key = keyOrName; cardInfo = InnoById[id]; name = cardInfo.name; }
  else if (isdef(InnoByName[keyOrName])) { name = keyOrName; cardInfo = InnoByName[name]; id = key = cardInfo.id; };
  let sym = INNO.sym[cardInfo.type];
  let info = Syms[sym.key];
  let card = cBlank(dParent, { fg: 'black', bg: INNO.color[cardInfo.color], w: Card.sz, h: Card.sz * .65, margin: 10 });
  let [dCard, sz, szTitle, margin] = [iDiv(card), Card.sz / 5, cardInfo.exp[0] == 'A' ? Card.sz / 12 : Card.sz / 8, 4];
  let [dTitle, dMain] = cTitleArea(card, szTitle);
  let d = mAddContent(dTitle, name, {
    patop: 4, bg: sym.bg, fg: 'white', h: szTitle, fz: szTitle * .7, align: 'center',
    position: 'relative'
  });
  mAddContent(d, cardInfo.age, { hpadding: szTitle / 4, float: 'right' });
  let s = mSym(sym.key, d, { hpadding: szTitle / 4, h: szTitle * .7, fg: sym.fg, float: 'left' });
  let positions = ['tl', 'bl', 'bc', 'br'];
  for (let i = 0; i < 4; i++) {
    let r = cardInfo.resources[i];
    let pos = positions[i];
    if (r in INNO.sym) { innoSym(r, dMain, sz, pos, margin); }
    else if (r == 'None') { innoAgeNumber(cardInfo.age, dMain, sz, pos, margin); }
    else if (isNumber(r)) { innoBonusNumber(r, dMain, sz, pos, margin); }
    else if (r == 'echo') { innoEcho(cardInfo.echo, dMain, sz, pos, margin); }
    else if (r == 'inspire') { innoInspire(cardInfo.inspire, dMain, sz, pos, margin); }
  }
  if (isdef(cardInfo.dogmas)) {
    let box = mBoxFromMargins(dMain, 10, margin, sz + margin, sz + 2 * margin);
    mStyle(box, { align: 'left' });
    let text = '';
    for (const dog of cardInfo.dogmas) {
      let t = startsWith(dog, 'I demand') ? ('I <b>demand</b>' + dog.substring(8)) : startsWith(dog, 'I compell') ? ('I <b>compell</b>' + dog.substring(8)) : dog;
      text += `<span style="color:${sym.bg};font-family:${info.family}">${info.text}</span>` + '&nbsp;' + t + '<br>';
    }
    let t2 = innoText(text);
    mFillText(t2, box);
  } else if (isdef(cardInfo.res_city)) {
    let positions = ['tc', 'tr'];
    for (let i = 0; i < 2; i++) {
      let r = cardInfo.res_city[i];
      let pos = positions[i];
      if (r == 'flag') { innoFlag(cardInfo.type, dMain, sz, pos, margin); }
      else if (r in INNO.sym) { innoSym(r, dMain, sz, pos, margin); }
      else if (r == 'None') { innoAgeNumber(cardInfo.age, dMain, sz, pos, margin); }
      else if (isNumber(r)) { innoBonusNumber(r, dMain, sz, pos, margin); }
      else if (r == 'echo') { innoEcho(cardInfo.echo, dMain, sz, pos, margin); }
      else if (r == 'inspire') { innoInspire(cardInfo.inspire, dMain, sz, pos, margin); }
    }
  }
  card.info = cardInfo;
  return card;
}
function inno_card_fixed_font(dParent, keyOrName) {
  if (nundef(keyOrName)) keyOrName = chooseRandom(get_keys(InnoById));
  let cardInfo, name, key, id;
  if (isdef(InnoById[keyOrName])) { id = key = keyOrName; cardInfo = InnoById[id]; name = cardInfo.name; }
  else if (isdef(InnoByName[keyOrName])) { name = keyOrName; cardInfo = InnoByName[name]; id = key = cardInfo.id; };
  let sym = INNO.sym[cardInfo.type];
  let info = Syms[sym.key];
  let card = cBlank(dParent, { fg: 'black', bg: INNO.color[cardInfo.color], w: Card.sz, h: Card.sz * .65, margin: 10 });
  let [dCard, sz, szTitle, margin] = [iDiv(card), Card.sz / 5, cardInfo.exp[0] == 'A' ? Card.sz / 12 : Card.sz / 8, 4];
  let [dTitle, dMain] = cTitleArea(card, szTitle);
  let d = mAddContent(dTitle, name, {
    patop: 4, bg: sym.bg, fg: 'white', h: szTitle, fz: szTitle * .7, align: 'center',
    position: 'relative'
  });
  mAddContent(d, cardInfo.age, { hpadding: szTitle / 4, float: 'right' });
  let s = mSym(sym.key, d, { hpadding: szTitle / 4, h: szTitle * .7, fg: sym.fg, float: 'left' });
  let positions = ['tl', 'bl', 'bc', 'br'];
  for (let i = 0; i < 4; i++) {
    let r = cardInfo.resources[i];
    let pos = positions[i];
    if (r in INNO.sym) { innoSym(r, dMain, sz, pos, margin); }
    else if (r == 'None') { innoAgeNumber(cardInfo.age, dMain, sz, pos, margin); }
    else if (isNumber(r)) { innoBonusNumber(r, dMain, sz, pos, margin); }
    else if (r == 'echo') { innoEcho(cardInfo.echo, dMain, sz, pos, margin); }
  }
  let box = mBoxFromMargins(dMain, 10, margin, sz + margin, sz + 2 * margin);
  console.log('box', box);
  mStyle(box, { align: 'left', padding: 4 });
  let text = '';
  for (const dog of cardInfo.dogmas) {
    let t = startsWith(dog, 'I demand') ? ('I <b>demand</b>' + dog.substring(8)) : startsWith(dog, 'I compell') ? ('I <b>compell</b>' + dog.substring(8)) : dog;
    text += `<span style="color:${sym.bg};font-family:${info.family}">${info.text}</span>` + '&nbsp;' + t + '<br>';
  }
  let t2 = innoText(text);
  mText(t2, box, { fz: 10 });
  card.info = cardInfo;
  return card;
}
function inno_code_of_laws_post(otree, r, uname, action, item) {
  if (action != 'pass') {
    let card = inno_get_cardinfo(stringAfterLast(action, '.'));
    elem_from_to(card.key, otree[uname].hand, otree[uname].board[card.color]);
    let splay = inno_get_splay(otree, `${uname}.board.${card.color}`);
    if (splay == 0 && otree[uname].board[card.color].length > 1) otree[uname].splays[card.color] = 1;
  }
  next_task(otree, r);
  turn_send_move_update(otree, uname);
}
function inno_code_of_laws_pre(otree, r, uname) {
  r.actions = inno_get_hand_actions(otree, uname);
  r.actions.push('pass');
  activate_actions(r, uname);
}
function inno_code_of_laws_todo(otree, uname) {
  console.log('making todolist for code_of_laws!!!');
  let r1 = {
    id: getUID('r'),
    uname: uname,
    key: 'inno_code_of_laws',
    actions: [],
    selected: null,
  };
  let list = [r1];
  return list;
}
function inno_create_card_assets() {
  Dinno = { A: {}, B: {}, C: {}, E: {}, F: {} };
  InnoById = {};
  InnoByName = {};
  for (const exp in Cinno) {
    for (const name in Cinno[exp]) {
      let c = Cinno[exp][name];
      c.name = name;
      c.exp = exp;
      let id = inno_get_id(c);
      c.id = c.key = id;
      if (isdef(InnoById[id])) { console.log('duplicate id', id, InnoById[id].name, c.name); }
      InnoById[id] = c;
      let key_name = name.toLowerCase().trim();
      if (isdef(InnoByName[key_name])) console.log('duplicate name', name);
      InnoByName[key_name] = c;
      lookupAddToList(Dinno, [exp[0], c.age], c.id);
    }
  }
}
function inno_create_ui_tree(n, dParent, r) {
  let d;
  if (n.path.includes('splays')) {
  } else if (n.path.includes('achievements')) {
    let id = getUID('u');
    d = mDiv(dParent, { bg: 'sienna', fg: 'white', w: '100%' }, id, n.path);
    mFlexWrap(d);
    for (const cont of n.content) {
      let card = InnoById[cont];
      let d1 = mDiv(d, { bg: 'sienna', margin: 4, border: 'blue', wmin: 25 }, null, isdef(card) ? card.age : cont);
    }
    r.add_ui_node(d, id, n.oid);
  } else if (startsWith(n.path, 'deck')) {
    mFlexWrap(dParent);
    let id = getUID('u');
    let styles = isNumber(stringAfterLast(n.path, '.')) ? { bg: 'beige', fg: 'black', margin: 4, border: 'red', wmin: 25 } : { bg: 'beige', fg: 'black' };
    d = mDiv(dParent, styles, id, n.path);
    r.add_ui_node(d, id, n.oid);
  } else if (r.otree.player_names.includes(n.content)) {
    let id = getUID('u');
    let bg = r.otree[n.content].color;
    let styles = { bg: bg, fg: 'contrast', w: '100%' };
    d = mDiv(dParent, styles, id, n.path);
    r.add_ui_node(d, id, n.oid);
  } else if (n.type == 'cardlist' && !n.path.includes('board')) {
    let id = getUID('u');
    d = mDiv(dParent, { bg: '#00000080', gap: 10, padding: 10 }, id, stringAfterLast(n.path, '.'));
    mCenterFlex(d);
    r.add_ui_node(d, id, n.oid);
  } else if (n.type == 'string' && !endsWith(n.path, 'board')) {
    let id = getUID('u');
    d = mDiv(dParent, { bg: 'inherit' }, id, n.content);
    r.add_ui_node(d, id, n.oid);
  } else if (endsWith(n.path, 'board')) {
    let id = getUID('u');
    d = mDiv(dParent, { bg: 'inherit' }, id, n.content);
    mFlexWrap(d);
    r.add_ui_node(d, id, n.oid);
  } else if (n.type == 'cardlist' && n.path.includes('board')) {
    let id = getUID('u');
    d = mDiv(dParent, {}, id);
    let splay = inno_get_splay(r.otree, n.path);
    let [num, wcard, hcard, ov] = [n.content.length, 300, 200, 78];
    mContainerSplay(d, splay, wcard, hcard, num, ov);
    r.add_ui_node(d, id, n.oid);
  } else if (n.type == 'card') {
    let c;
    if (n.path.includes('board')) {
      c = inno_present_card(dParent, n.content);
      let list = lookup(Session.otree, stringBeforeLast(n.path, '.').split('.'));
      let splay = inno_get_splay(r.otree, n.path);
      mItemSplay(c, list, splay);
    } else {
      c = inno_present_card(dParent, n.content);
      let d = iDiv(c);
    }
    r.add_ui_node(iDiv(c), c.id, n.oid);
  }
  if (nundef(d)) return;
  for (const ch of n.children) {
    inno_create_ui_tree(r.nodes[ch], d, r);
  }
}
function inno_draw_action(otree, r, uname, exp, age) {
  draw_from_deck_to(otree.decks[exp][age], otree[uname].hand);
  next_task(otree, r);
}
function inno_get_all_actions(otree, uname) {
  let actions = [];
  let ameld = inno_action_meld(otree, uname);
  let atop = inno_action_topcard(otree, uname);
  let achieve = inno_action_achieve(otree, uname);
  let adraw = inno_action_draw(otree, uname);
  actions = atop.concat(ameld, achieve, adraw);
  return actions;
}
function inno_get_basic_deck_age(otree, min_age) {
  for (let i = min_age; i <= 10; i++) {
    let deck = otree.decks.B[i];
    let len = deck.length;
    if (len > 0) return i;
  }
  return 11;
}
function inno_get_cardinfo(key) { return InnoById[key]; }
function inno_get_deck_age(otree, deck_letter, min_age = 1) {
  let deck_age = inno_get_basic_deck_age(otree, min_age);
  if (deck_letter == 'B') return deck_age;
  let deck = otree.decks[deck_letter][deck_age];
  while (deck_age <= 10 && isEmpty(deck)) { deck_age += 1; deck = otree.decks[deck_letter][deck_age]; }
  return deck_age;
}
function inno_get_deck_info_for_player(otree, uname) {
  let has_echo = inno_has_echo(otree, uname);
  let letter = has_echo || isEmpty(otree[uname].hand) ? 'B' : 'E';
  let min_age = inno_get_player_age(otree, uname);
  let age = inno_get_deck_age(otree, letter, min_age);
  return [age, letter];
}
function inno_get_hand_actions(otree, uname) {
  let actions = [];
  otree[uname].hand.map(x => actions.push(`${uname}.hand.${x}`));
  return actions;
}
function inno_get_id(c) { return normalize_string(c.name); }
function inno_get_object_keys(otree) {
  let keys = {}; for (const k in InnoById) keys[k] = true;
  for (const k of otree.plorder) keys[k] = true;
  for (const k of ['decks', 'board', 'splays', 'hand', 'green', 'purple', 'blue', 'red', 'yellow', 'forecast', 'scored', 'artifact', 'special_achievements', 'achievements']) keys[k] = true;
  let decknames = 'ABCEF';
  for (let i = 0; i < decknames.length; i++) { keys[decknames[i]] = true; }
  for (let age = 1; age <= 10; age++) { keys['' + age] = true; }
  return keys;
}
function inno_get_phase(iphase) { return INNO.phases[iphase].key; }
function inno_get_player_age(otree, uname) {
  let top = inno_get_top_card_info(otree, uname);
  let maxage = arrMinMax(top, x => x.age).max;
  return maxage;
}
function inno_get_splay(otree, path) {
  let [uname, x, color, y] = path.split('.');
  let splay = otree[uname].splays[color];
  return splay;
}
function inno_get_top_card_actions(otree, uname) {
  let keys = inno_get_top_card_keys(otree, uname);
  let res = keys.map(x => `${uname}.board.${inno_get_cardinfo(x).color}.${x}`);
  return res;
}
function inno_get_top_card_info(otree, uname) { return inno_get_top_card_keys(otree, uname).map(x => inno_get_cardinfo(x)); }
function inno_get_top_card_keys(otree, uname) {
  let pl = otree[uname];
  let board = pl.board;
  let top = [];
  for (const k in board) { if (!isEmpty(board[k])) top.push(arrFirst(board[k])); }
  return top;
}
function inno_has_echo(otree, uname) {
  let handcardinfo = otree[uname].hand.map(x => inno_get_cardinfo(x));
  let has_echo = firstCond(handcardinfo, x => x.exp[0] == 'E');
  return has_echo;
}
function inno_has_towers(cardinfo) { return cardinfo.resources.includes('tower'); }
function inno_init_post(otree, r, uname, action, item) {
  let path = r.selected;
  let cardname = stringAfterLast(path, '.');
  let card = inno_get_cardinfo(cardname);
  let pl = otree[uname];
  lookupAddToList(otree, ['progress'], { name: uname, key: cardname });
  elem_from_to(cardname, pl.hand, pl.board[card.color]);
  let i = otree.itask + 1;
  if (i >= get_num_players(otree)) {
    otree.plorder = sortBy(otree.progress, 'key').map(x => x.name);
    otree.history = otree.todo;
    otree.progress = null;
    otree.todo = inno_todo_justone(otree);
  } else {
    otree.itask = i;
  }
  turn_send_move_update(otree, uname);
}
function inno_init_pre(otree, r, uname) {
  r.actions = inno_get_hand_actions(otree, uname);
  activate_actions(r, uname);
}
function inno_is_artifact(cardinfo) { return cardinfo.exp[0] == 'A'; }
function inno_is_basic(cardinfo) { return cardinfo.exp[0] == 'B'; }
function inno_is_echoes(cardinfo) { return cardinfo.exp[0] == 'E'; }
function inno_is_figure(cardinfo) { return cardinfo.exp[0] == 'F'; }
function inno_justone_post(otree, r, uname, action, item) {
  inno_perform_action(otree, r, uname, action, item);
  turn_send_move_update(otree, uname);
}
function inno_justone_pre(otree, r, uname) {
  r.actions = inno_get_all_actions(otree, uname);
  activate_actions(r, uname);
}
function inno_meld(otree, r, uname, cardname) {
  let ci = inno_get_cardinfo(cardname);
  let pl = otree[uname];
  elem_from_to_top(cardname, pl.hand, pl.board[ci.color]);
  next_task(otree, r);
}
function inno_metalworking_post(otree, r, uname, action, item) {
  next_task(otree, r);
  turn_send_move_update(otree, uname);
}
function inno_metalworking_pre(otree, r, uname) {
  let deck_letter = inno_has_echo(otree, uname) ? 'E' : 'B';
  let card = null;
  while (nundef(card) || inno_has_towers(card)) {
    let deck_age = inno_get_deck_age(otree, deck_letter);
    let deck = otree.decks[deck_letter][deck_age];
    let peek = deck[0];
    ckey = deck.shift();
    console.log('age', deck_age, 'deck length', deck.length)
    console.assert(isdef(ckey) && peek == ckey, 'metalworking: not drawing top card!!!!!!!');
    card = inno_get_cardinfo(ckey);
    console.log('draw card', ckey, inno_has_towers(card));
    if (inno_has_towers(card)) otree[uname].scored.push(ckey); else otree[uname].hand.push(ckey);
  }
  console.log('metalworking is *DONE*');
  inno_metalworking_post(otree, r, uname);
}
function inno_metalworking_todo(otree, uname) {
  console.log('making todolist for metalworking!!!');
  let r1 = {
    id: getUID('r'),
    uname: uname,
    key: 'inno_metalworking',
    actions: [],
    selected: null,
  };
  let list = [r1];
  return list;
}
function inno_perform_action(otree, r, uname, action, item) {
  console.log('inno_perform_action', otree, r, uname, action, item);
  let a = action;
  console.assert(r.selected == action, 'r.selected NOT SAME AS action!!!!!!!!!!!!!!!!!!!!!!!!');
  let parts = a.split('.');
  if (parts.length == 3) {
    let [x, obj, cardname] = parts;
    if (obj == 'hand' && x == uname) {
      inno_meld(otree, r, uname, cardname);
    }
    let [deck, exp, age] = parts;
    if (deck == 'decks') {
      console.assert(false, 'SHOULD NOT GET HERE HAPPEN!!!! inno_perform_action draw mit a=draw.decks...!!!!!!!!!!!!!!!');
    }
  } else if (parts.length == 4) {
    let [x, obj, color, cardname] = parts;
    if (obj == 'board' && x == uname) {
      inno_activate(otree, r, uname, cardname);
    }
    let [action, deck, exp, age] = parts;
    if (action == 'draw' && deck == 'decks') {
      inno_draw_action(otree, r, uname, exp, age);
    }
  }
}
function inno_perform_initial_selections(r, otree) {
  let pl_order = [];
  for (const uname of otree.turn) {
    let path = r.selected[uname][0];
    let cardname = stringAfterLast(path, '.');
    let card = inno_get_cardinfo(cardname);
    let pl = otree[uname];
    pl_order.push({ name: uname, key: cardname });
    elem_from_to(cardname, pl.hand, pl.board[card.color]);
  }
  return pl_order;
}
function inno_present_board(dParent, board) {
  let dBoard = mDiv(dParent, {}, null, 'board');
  mFlex(dBoard);
  let boardItemLists = [];
  for (const color in board) {
    let cardlist = board[color];
    let d = mDiv(dBoard);
    let items = inno_present_cards(d, cardlist);
    boardItemLists.push(items);
  }
  return boardItemLists;
}
function inno_present_card(dParent, k) { let card = inno_card(dParent, k); card.key = card.info.key; return card; }
function inno_present_cards(dParent, keys) {
  let items = [];
  for (const k of keys) {
    let card = inno_present_card(dParent, k);
    items.push(card);
  }
  return items;
}
function inno_present_hand(dParent, hand) {
  let dHand = mDiv(dParent, {}, null, 'hand');
  mFlexWrap(dHand); mLinebreak(dHand);
  let handItems = inno_present_cards(dHand, hand);
  return handItems;
}
function inno_regular_pre(otree, r, uname) { inno_justone_pre(otree, r, uname); }
function inno_setup(player_names) {
  inno_shuffle_decks();
  let pre_fen = {};
  let decks = pre_fen.decks = jsCopy(Dinno);
  pre_fen.achievements = [];
  for (const age in decks.B) { last_elem_from_to(decks.B[age], pre_fen.achievements); }
  pre_fen.special_achievements = ['monument', 'empire', 'world', 'wonder', 'universe', 'legend', 'repute', 'fame', 'glory', 'victory', 'supremacy', 'destiny', 'wealth', 'heritage', 'history'];
  let pls = pre_fen.players = {};
  let deck1 = decks.B[1]; let deck2 = decks.E[1];
  for (const plname of player_names) {
    let pl = pls[plname] = {
      hand: [],
      board: { blue: [], red: [], green: [], yellow: [], purple: [] },
      splays: { blue: 0, red: 0, green: 0, yellow: 0, purple: 0 },
      achievements: [],
      scored: [],
      forecast: [],
      artifact: null
    };
    last_elem_from_to(deck1, pl.hand); last_elem_from_to(deck2, pl.hand);
  }
  pre_fen.plorder = jsCopy(player_names);
  let fen = {
    players: pre_fen.players,
    decks: pre_fen.decks,
  };
  addKeys(pre_fen, fen);
  return fen;
}
function inno_show_other_player_info(ev) {
  console.log('enter', ev.target);
  let id = evToId(ev);
  let g = Session;
  let plname = stringAfter(id, '_');
  let pl = firstCond(g.players, x => x.name == plname);
  console.log('player info for', pl);
}
function inno_shuffle_decks() {
  for (const exp in Dinno) {
    for (const age in Dinno[exp]) {
      shuffle(Dinno[exp][age]);
    }
  }
}
function inno_stat_sym(key, n, dParent, sz) {
  let d = mDiv(dParent, { display: 'flex', dir: 'c', fz: sz });
  let s = mSym(INNO.sym[key].key, d, { h: sz, fz: sz, fg: INNO.sym[key].fg });
  d.innerHTML += `<span>${n}</span>`;
  return d;
}
function inno_todo_init(otree) {
  let r = {
    key: 'inno_init',
    actions: [],
    selected: null,
  };
  let list = [];
  for (const uname of otree.plorder) {
    let task = jsCopy(r);
    task.id = getUID('r');
    task.uname = uname;
    list.push(task);
  };
  otree.itask = 0;
  return list;
}
function inno_todo_justone(otree) {
  let r = {
    key: 'inno_justone',
    actions: [],
    selected: null,
  };
  let list = otree.todo = [];
  for (const uname of otree.plorder) {
    let i = get_index_in_plorder(otree, uname);
    if (i >= otree.plorder.length / 2) break;
    let task = jsCopy(r);
    task.id = getUID('r');
    task.uname = uname;
    list.push(task);
  };
  otree.itask = 0;
  return list;
}
function inno_todo_regular(otree, uname) {
  let r = {
    key: 'inno_regular',
    uname: uname,
    actions: [],
    selected: null,
  };
  let r1 = jsCopy(r); r1.id = getUID('r');
  let r2 = jsCopy(r); r2.id = getUID('r');
  let list = [r1, r2];
  otree.itask = 0;
  return list;
}
function inno_undo_random_deal(fen) {
  for (const uname in fen.players) {
    let pl = fen.players[uname];
    last_elem_from_to(pl.hand, fen.decks.E[1]);
    last_elem_from_to(pl.hand, fen.decks.B[1]);
  }
}
function inno_ut0_create_staged() {
  Session.cur_game = 'gPreinno';
  let player_names = ['mimi', 'leo'];
  let fen = inno_setup(player_names);
  console.log('fen', fen)
  let [decks, mimi, leo] = [fen.decks, fen.players.mimi, fen.players.leo];
  let deck1 = decks.B[1]; let deck2 = decks.E[1];
  inno_undo_random_deal(fen);
  elem_from_to('agriculture', deck1, mimi.hand);
  elem_from_to('comb', deck2, mimi.hand);
  elem_from_to('metalworking', deck1, leo.hand);
  elem_from_to('soap', deck2, leo.hand);
  DA.staged_moves = ['mimi.hand.agriculture', 'leo.hand.metalworking', 'mimi.board.yellow.agriculture', 'mimi.hand.comb',
    'leo.board.red.metalworking', 'leo.board.red.metalworking', 'mimi.board.yellow.agriculture', 'pass', 'mimi.board.yellow.agriculture', 'pass'];
  DA.iter = 100;
  return [fen, player_names];
}
function inno_ut1_create_staged() {
  console.log('*** TEST: activate agriculture ***');
  Session.cur_game = 'gPreinno';
  let player_names = ['mimi', 'leo'];
  let fen = inno_setup(player_names);
  let [decks, mimi, leo] = [fen.decks, fen.players.mimi, fen.players.leo];
  let deck1 = decks.B[1]; let deck2 = decks.E[1];
  inno_undo_random_deal(fen);
  elem_from_to('agriculture', deck1, mimi.hand);
  elem_from_to('comb', deck2, mimi.hand);
  elem_from_to('metalworking', deck1, leo.hand);
  elem_from_to('soap', deck2, leo.hand);
  DA.staged_moves = ['mimi.hand.agriculture', 'leo.hand.metalworking', 'mimi.board.yellow.agriculture', 'mimi.hand.comb'];
  DA.iter = 13;
  return [fen, player_names];
}
function inno_ut10_create_staged() {
  Session.cur_game = 'gPreinno';
  let player_names = ['mimi', 'leo'];
  let fen = inno_setup(player_names);
  let [decks, mimi, leo] = [fen.decks, fen.players.mimi, fen.players.leo];
  let deck1 = decks.B[1]; let deck2 = decks.E[1];
  inno_undo_random_deal(fen);
  elem_from_to('agriculture', deck1, mimi.hand);
  elem_from_to('comb', deck2, mimi.hand);
  elem_from_to('metalworking', deck1, leo.hand);
  elem_from_to('soap', deck2, leo.hand);
  DA.staged_moves = ['mimi.hand.agriculture', 'leo.hand.metalworking', 'draw', 'draw', 'draw', 'draw'];
  DA.iter = 100;
  return [fen, player_names];
}
function inno_ut11_create_staged() {
  Session.cur_game = 'gPreinno';
  let player_names = ['mimi', 'leo'];
  let fen = inno_setup(player_names);
  let [decks, mimi, leo] = [fen.decks, fen.players.mimi, fen.players.leo];
  let deck1 = decks.B[1]; let deck2 = decks.E[1];
  inno_undo_random_deal(fen);
  elem_from_to('agriculture', deck1, mimi.hand);
  elem_from_to('comb', deck2, mimi.hand);
  elem_from_to('metalworking', deck1, leo.hand);
  elem_from_to('soap', deck2, leo.hand);
  DA.staged_moves = ['mimi.hand.agriculture', 'leo.hand.metalworking', 'draw', 'draw', 'draw', 'draw', 'meld', 'meld', 'draw', 'draw', 'meld', 'meld'];
  DA.iter = 100;
  return [fen, player_names];
}
function inno_ut12_create_staged() {
  console.log('*** TEST: activate code_of_laws ***');
  Session.cur_game = 'gPreinno';
  let player_names = ['mimi', 'leo'];
  let fen = inno_setup(player_names);
  let [decks, mimi, leo] = [fen.decks, fen.players.mimi, fen.players.leo];
  let deck1 = decks.B[1]; let deck2 = decks.E[1];
  inno_undo_random_deal(fen);
  elem_from_to('code_of_laws', deck1, mimi.hand);
  elem_from_to('puppet', deck2, mimi.hand);
  elem_from_to('sailing', deck1, leo.hand);
  elem_from_to('soap', deck2, leo.hand);
  DA.staged_moves = ['mimi.hand.code_of_laws', 'leo.hand.sailing', 'mimi.board.purple.code_of_laws', 'leo.hand.soap', 'mimi.hand.puppet'];
  DA.iter = 100;
  return [fen, player_names];
}
function inno_ut2_create_staged() {
  Session.cur_game = 'gPreinno';
  let player_names = ['mimi', 'leo'];
  let fen = inno_setup(player_names);
  let [decks, mimi, leo] = [fen.decks, fen.players.mimi, fen.players.leo];
  let deck1 = decks.B[1]; let deck2 = decks.E[1];
  inno_undo_random_deal(fen);
  elem_from_to('agriculture', deck1, mimi.hand);
  elem_from_to('comb', deck2, mimi.hand);
  elem_from_to('metalworking', deck1, leo.hand);
  elem_from_to('soap', deck2, leo.hand);
  DA.staged_moves = ['mimi.hand.agriculture', 'leo.hand.metalworking'];
  DA.iter = 100;
  return [fen, player_names];
}
function inno_ut3_create_staged() {
  Session.cur_game = 'gPreinno';
  let player_names = ['mimi', 'leo', 'felix', 'amanda'];
  let fen = inno_setup(player_names);
  let [decks, mimi, leo, felix, amanda] = [fen.decks, fen.players.mimi, fen.players.leo, fen.players.felix, fen.players.amanda];
  let deck1 = decks.B[1]; let deck2 = decks.E[1];
  inno_undo_random_deal(fen);
  elem_from_to('wheel', deck1, mimi.hand);
  elem_from_to('comb', deck2, mimi.hand);
  elem_from_to('metalworking', deck1, leo.hand);
  elem_from_to('soap', deck2, leo.hand);
  elem_from_to('agriculture', deck1, felix.hand);
  elem_from_to('chopsticks', deck2, felix.hand);
  elem_from_to('pottery', deck1, amanda.hand);
  elem_from_to('dice', deck2, amanda.hand);
  DA.staged_moves = ['mimi.hand.wheel', 'leo.hand.metalworking', 'felix.hand.agriculture', 'amanda.hand.dice'];
  DA.iter = 100;
  return [fen, player_names];
}
function inno_ut4_create_staged() {
  console.log('*** TEST: sharing agriculture ***');
  Session.cur_game = 'gPreinno';
  let player_names = ['mimi', 'leo', 'felix'];
  let fen = inno_setup(player_names);
  let [decks, mimi, leo, felix] = [fen.decks, fen.players.mimi, fen.players.leo, fen.players.felix];
  let deck1 = decks.B[1]; let deck2 = decks.E[1];
  inno_undo_random_deal(fen);
  elem_from_to('pottery', deck1, mimi.hand);
  elem_from_to('comb', deck2, mimi.hand);
  elem_from_to('metalworking', deck1, leo.hand);
  elem_from_to('soap', deck2, leo.hand);
  elem_from_to('agriculture', deck1, felix.hand);
  elem_from_to('chopsticks', deck2, felix.hand);
  DA.staged_moves = ['mimi.hand.pottery', 'leo.hand.soap', 'felix.hand.agriculture'];
  DA.iter = 100;
  return [fen, player_names];
}
function inno_ut5_create_staged() {
  console.log('*** TEST: sharing metalworking ***');
  Session.cur_game = 'gPreinno';
  let player_names = ['mimi', 'leo', 'felix'];
  let fen = inno_setup(player_names);
  let [decks, mimi, leo, felix] = [fen.decks, fen.players.mimi, fen.players.leo, fen.players.felix];
  let deck1 = decks.B[1]; let deck2 = decks.E[1];
  inno_undo_random_deal(fen);
  elem_from_to('wheel', deck1, mimi.hand);
  elem_from_to('comb', deck2, mimi.hand);
  elem_from_to('metalworking', deck1, leo.hand);
  elem_from_to('soap', deck2, leo.hand);
  elem_from_to('agriculture', deck1, felix.hand);
  elem_from_to('chopsticks', deck2, felix.hand);
  DA.staged_moves = ['mimi.hand.wheel', 'leo.hand.metalworking', 'felix.hand.agriculture', 'draw.decks.B.1'];
  DA.iter = 100;
  return [fen, player_names];
}
function inno_ut6_create_staged() {
  console.log('*** TEST: draw ***');
  Session.cur_game = 'gPreinno';
  let player_names = ['mimi', 'leo'];
  let fen = inno_setup(player_names);
  let [decks, mimi, leo] = [fen.decks, fen.players.mimi, fen.players.leo];
  let deck1 = decks.B[1]; let deck2 = decks.E[1];
  inno_undo_random_deal(fen);
  elem_from_to('wheel', deck1, mimi.hand);
  elem_from_to('comb', deck2, mimi.hand);
  elem_from_to('metalworking', deck1, leo.hand);
  elem_from_to('soap', deck2, leo.hand);
  DA.staged_moves = ['mimi.hand.wheel', 'leo.hand.soap'];
  DA.iter = 100;
  return [fen, player_names];
}
function inno_ut7_create_staged() {
  console.log('*** TEST: draw 2 ***');
  Session.cur_game = 'gPreinno';
  let player_names = ['mimi', 'leo'];
  let fen = inno_setup(player_names);
  let [decks, mimi, leo] = [fen.decks, fen.players.mimi, fen.players.leo];
  let deck1 = decks.B[1]; let deck2 = decks.E[1];
  inno_undo_random_deal(fen);
  elem_from_to('wheel', deck1, mimi.hand);
  elem_from_to('comb', deck2, mimi.hand);
  elem_from_to('metalworking', deck1, leo.hand);
  elem_from_to('soap', deck2, leo.hand);
  DA.staged_moves = ['mimi.hand.wheel', 'leo.hand.soap', 'decks.E.1', 'decks.B.1', 'decks.B.1'];
  DA.iter = 100;
  return [fen, player_names];
}
function inno_ut8_create_staged() {
  console.log('*** TEST: splay up ***');
  Session.cur_game = 'gPreinno';
  let player_names = ['mimi', 'leo'];
  let fen = inno_setup(player_names);
  let [decks, mimi, leo] = [fen.decks, fen.players.mimi, fen.players.leo];
  let deck1 = decks.B[1]; let deck2 = decks.E[1];
  inno_undo_random_deal(fen);
  elem_from_to('agriculture', deck1, mimi.hand);
  elem_from_to('comb', deck2, mimi.hand);
  elem_from_to('metalworking', deck1, leo.hand);
  elem_from_to('puppet', deck2, leo.hand);
  elem_from_to('chopsticks', deck2, mimi.board.yellow);
  elem_from_to('soap', deck2, mimi.board.yellow);
  elem_from_to('fermenting', decks.B[2], mimi.board.yellow);
  fen.players.mimi.splays.yellow = 3;
  DA.iter = 100;
  return [fen, player_names];
}
function inno_ut9_create_staged() {
  console.log('*** TEST: splay complex ***');
  Session.cur_game = 'gPreinno';
  let player_names = ['mimi', 'leo'];
  let fen = inno_setup(player_names);
  let [decks, mimi, leo] = [fen.decks, fen.players.mimi, fen.players.leo];
  let deck1 = decks.B[1]; let deck2 = decks.E[1];
  inno_undo_random_deal(fen);
  elem_from_to('agriculture', deck1, mimi.hand);
  elem_from_to('comb', deck2, mimi.hand);
  elem_from_to('metalworking', deck1, leo.hand);
  elem_from_to('puppet', deck2, leo.hand);
  let mydeck1 = decks.B[1].map(x => ({ key: x, deck: decks.B[1] }));
  let mydeck2 = decks.B[2].map(x => ({ key: x, deck: decks.B[2] }));
  let mydeck3 = decks.B[3].map(x => ({ key: x, deck: decks.B[3] }));
  let mydecks = mydeck1.concat(mydeck2).concat(mydeck3);
  for (const x of mydecks) { elem_from_to(x.key, x.deck, mimi.board[inno_get_cardinfo(x.key).color]); }
  fen.players.mimi.splays.blue = 3;
  fen.players.mimi.splays.red = 0;
  fen.players.mimi.splays.green = 1;
  fen.players.mimi.splays.yellow = 2;
  fen.players.mimi.splays.purple = 2;
  DA.iter = 100;
  return [fen, player_names];
}
function innoAgeNumber(n, dParent, sz, pos, margin = 10) {
  let x = Card.sz * .04; sz -= x;
  let hOff = 0;
  let styles = { wmin: sz * 1.1, h: sz, bg: '#131313', align: 'center' };
  let box = mShape('hexFlat', dParent, styles); mPlace(box, pos, margin, margin - hOff / 2);
  s = mDiv(box, { fz: sz * .6, fg: 'white', display: 'inline-block' }, null, n);
  mPlace(s, 'cc');
  return box;
}
function innoBonusNumber(n, dParent, sz, pos, margin = 10) {
  let hOff = margin / 2;
  let styles = { w: sz, h: sz - hOff, bg: 'brown', box: true, align: 'center' };
  let box = mShape('circle', dParent, styles); mPlace(box, pos, margin + hOff / 2, margin);
  let dText = mDiv(box, { fz: sz * .1, fg: 'black', 'line-height': sz * .1, matop: sz * .05 }, null, 'bonus');
  let dNum = mDiv(box, { fz: sz * .7, fg: 'black', 'line-height': sz * .65 }, null, n);
  return box;
}
function innoEcho(text, dParent, sz, pos, margin = 10) {
  if (isList(text)) text = text.join('<br>');
  margin /= 2;
  sz += margin / 4;
  let box = mDiv(dParent, { w: sz, h: sz, bg: 'black', fg: 'white', rounding: 10 });
  mPlace(box, pos, margin);
  box.onclick = (ev) => makeInfobox(ev, box, 3);
  let t2 = innoText(text);
  mFillText(t2, box);
  return box;
}
function innoFlag(cardType, dParent, sz, pos, margin = 10) {
  let box = mDiv(dParent, { w: sz, h: sz, bg: INNO.sym.flag.bg, rounding: 10 }); if (isdef(pos)) mPlace(box, pos, margin);
  s = mSym(INNO.sym.flag.key, box, { sz: sz * .75, fg: INNO.sym[cardType].bg }, 'cc');
  return box;
}
function innoInspire(text, dParent, sz, pos, margin = 10) {
  if (isList(text)) text = text.join('<br>');
  margin /= 2;
  sz += margin / 4;
  let box = mDiv(dParent, { w: sz, h: sz, bg: '#ffffff80', fg: 'black', rounding: 10 });
  mPlace(box, pos, margin);
  box.onclick = (ev) => makeInfobox(ev, box, 3);
  let t2 = innoText(text);
  mFillText(t2, box);
  return box;
}
function innoSym(key, dParent, sz, pos, margin = 10) {
  let box = mDiv(dParent, { w: sz, h: sz, bg: INNO.sym[key].bg, rounding: 10 }); if (isdef(pos)) mPlace(box, pos, margin);
  s = mSym(INNO.sym[key].key, box, { sz: sz * .75, fg: INNO.sym[key].fg }, 'cc');
  return box;
}
function innoSymInline(key, dParent) {
  s = mSymInline(INNO.sym[key].key, dParent, { fg: INNO.sym[key].fg, bg: INNO.sym[key].bg, rounding: 10 });
  return s;
}
function innoText(text) {
  for (const s in INNO.sym) { INNO.sym[s].sym = Syms[INNO.sym[s].key]; }
  let parts = text.split('[');
  let s = parts[0];
  for (let i = 1; i < parts.length; i++) {
    let part = parts[i];
    let kw = stringBefore(part, ']');
    let sp;
    let fz = Card.sz * .04;
    if (Object.keys(INNO.sym).includes(kw)) { let o = INNO.sym[kw]; sp = makeSymbolSpan(o.sym, o.bg, o.fg, fz * .9, '20%'); }
    else if (isNumber(kw)) { sp = makeNumberSpan(kw, '#232323', 'white', fz * .9, '20%'); }
    s += sp + stringAfter(part, ']');
  }
  return s;
}
function innovation_get_card(ckey, index, h = 200) {
  let filename = `${Basepath}assets/games/innovation/img${ckey}.jpg`;
  let clip = 50;
  let html = `<img src='${filename}' height='${h + clip}' style='clip-path:inset(0px 0px ${clip}px 0px)'></img>`;
  let d = mDiv(null, { rounding: 8, bg: 'blue', margin: 10, h: h, w: h * 141 / 200, overflow: 'hidden' }, null, html, 'card');
  mMagnifyOnHoverControl(d)
  let item = { key: ckey, index: index, div: d, html: html, h: h, faceUp: true };
  d.onclick = () => { face_up(item); };
  return item;
}
function innovation_present(fen, d_table) {
  G = {};
  G.deck = ui_generic_deck(d_table, fen.deck);
  let pls = G.players = {};
  for (const uname in fen.players) {
    let pl = pls[uname] = {};
    let fpl = fen.players[uname];
    let user = firstCond(Users, x => x.name == uname);
    copyKeys(user, pl)
    console.log('pl', uname, pl)
    let d = mDiv(d_table, { bg: user.color }, null, uname); mFlexWrap(d)
    pl.div = d;
    let i = 0; let items = pl.hand = fpl.hand.map(x => { i++; return innovation_get_card(x, i) });
    for (const item of items) mAppend(d, iDiv(item));
  }
}
function innovation_setup(players) {
  let fen = {};
  let deck = fen.deck = shuffle(range(0, 435));
  let pls = fen.players = {};
  for (const uname of players) {
    let pl = pls[uname] = {};
    pl.hand = deck_deal(deck, 7);
  }
  let plturn = fen.plturn = rChoose(players);
  let phase = fen.phase = 'create';
  return fen;
}
function input_to_anzeige1(caption, index) {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  const di = { '3': 'three', '4': 'four', '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine', T: 'ten', J: 'jack', Q: 'queen', K: 'king', A: 'ace' };
  let bid = fen.newbid;
  if (index == 0) {
    bid[0] = Number(caption);
    if (bid[0] == 0) {
      bid[0] = '_'; bid[1] = '_';
    } else if (bid[1] == '_') {
      let hand = fen.players[uplayer].hand;
      let c1 = arrLast(hand);
      let r = c1[0];
      if (r == '2') r = bid[3] == 'ace' ? 'K' : 'A';
      if (di[r] == bid[3]) bid[1] = bid[3] == 'three' ? 'four' : 'three'; else bid[1] = di[r];
    }
  } else if (index == 1) {
    bid[1] = di[caption];
    if (bid[0] == '_') bid[0] = 1;
    if (bid[3] == bid[1]) { bid[0] = bid[0] + bid[2]; bid[2] = bid[3] = '_'; }
  } else if (index == 2) {
    bid[2] = Number(caption);
    if (bid[2] == 0) {
      bid[2] = '_'; bid[3] = '_';
    } else if (bid[3] == '_') {
      let hand = fen.players[uplayer].hand;
      let c1 = hand[0];
      let r = c1[0];
      if (r == '2') r = bid[1] == 'ace' ? 'K' : 'A';
      if (di[r] == bid[1]) bid[3] = bid[1] == 'three' ? 'four' : 'three'; else bid[3] = di[r];
    }
  } else {
    bid[3] = di[caption];
    if (bid[2] == '_') bid[2] = 1;
    if (bid[3] == bid[1]) { bid[0] = bid[0] + bid[2]; bid[1] = bid[3]; bid[2] = bid[3] = '_'; }
  }
  for (let i = 0; i < 4; i++)  iDiv(UI.panelItems[i]).innerHTML = bid[i];
}
function insertColNew(board, cClick) { return expandBoard(board, board.rows, board.cols + 1, cClick + 1); }
function insertHere() {
  var thisScript = document.scripts[document.scripts.length - 1];
  var parent = thisScript.parentElement;
  for (let i = 0; i < arguments.length; i++) {
    const el = arguments[i];
    if (typeof el == 'string') {
      thisScript.nextSibling.insertAdjacentHTML('beforebegin', el);
    } else {
      parent.insertBefore(el, thisScript.nextSibling);
    }
  }
}
function insertRowNew(board, cClick) { return expandBoard(board, board.rows + 1, board.cols, cClick + 1); }
function instanceOf(o, className) {
  let otype = o.obj_type;
  switch (className) {
    case '_player':
    case 'player': return ['GamePlayer', 'me', '_me', 'player', '_player', 'opp', 'opponent', '_opponent'].includes(otype); break;
    case 'building': return otype == 'farm' || otype == 'estate' || otype == 'chateau' || otype == 'settlement' || otype == 'city' || otype == 'road'; break;
  }
}
function instantiateFractions(wp) {
  let text = wp.text;
  let parts = text.split('{');
  console.log('parts', parts);
  let tnew = '';
  if (!startsWith(text, '{')) { tnew += parts[0]; parts = parts.slice(1); }
  let denom;
  for (const part of parts) {
    let textPart = stringAfter(part, '}');
    let key = part.substring(0, 2);
    console.log('key', key);
    if (part[0] == 'F') {
      let numer = part[1] == 'a' ? 1 : isdef(denom) ? denom : randomNumber(2, 8);
      if (nundef(denom)) {
        denom = numer <= 2 ? randomNumber(numer + 1, 9) :
          numer < 9 ? coin() ? randomNumber(2, numer - 1) : randomNumber(numer + 1, 9) : randomNumber(2, number - 1);
      }
      tnew += ' ' + getTextForFraction(numer, denom);
      operands.push(numer / denom);
    }
    tnew += ' ' + textPart.trim();
  }
  wp.text = tnew.trim();
}
function instantiateNames(wp) {
  let text = wp.text;
  let parts = text.split('@P');
  let diNames = wp.diNames = {};
  let tnew = '';
  let allNames = jsCopy(arrPlus(GirlNames, BoyNames));
  let gNames = jsCopy(GirlNames);
  let bNames = jsCopy(BoyNames);
  if (!startsWith(text, '@P')) { tnew += parts[0]; parts = parts.slice(1); }
  for (const part of parts) {
    let textPart = stringAfter(part, ' ');
    let hasDot = part[2] == '.';
    let key = part.substring(0, 2);
    if (['G', 'B', 'P'].includes(part[0])) {
      let nlist = part[0] == 'P' ? allNames : part[0] == 'B' ? bNames : gNames;
      if (isdef(diNames[key])) {
        tnew += ' ' + diNames[key];
      } else {
        diNames[key] = chooseRandom(nlist);
        removeInPlace(nlist, diNames[key]);
        removeInPlace(allNames, diNames[key]);
        tnew += ' ' + diNames[key];
      }
    }
    tnew += (hasDot ? '. ' : ' ') + textPart.trim();
  }
  wp.text = tnew.trim();
  if (wp.sol[0] == 'p') {
    let k = wp.sol.trim().substring(3);
    wp.result = { number: 0, text: diNames[k] };
    return true;
  } else { return false; }
}
function instantiateNumbers(wp) {
  let text = wp.text;
  if (wp.sol[0] == 's') { wp.result = { number: 0, text: wp.sol.substring(1) }; return [{}, '']; }
  let diop = wp.diop = {}, res, result = [], eq;
  let solist = wp.sol.split('=>');
  for (const sol of solist) {
    [res, eq] = replaceSol(sol, diop);
    result.push(res);
  }
  result = arrLast(result).res;
  wp.result = { number: isdef(diop.R) ? diop.R : result };
  wp.result.text = '' + wp.result.number;
  for (const k in diop) {
    if (k == 'R') continue;
    text = replaceAll(text, '@' + k, valToString(diop[k]));
  }
  wp.text = text;
  fractionConvert(wp, diop);
  return [diop, eq];
}
function instantiateNumbers_dep(wp) {
  let text = wp.text;
  let diop = {};
  let sol = wp.sol;
  let rhs = stringBefore(sol, '=');
  let type = rhs.includes('*') ? rhs.includes('R') ? 'div' : 'mult' : rhs.includes('R') ? 'minus' : 'plus';
  let i = 0;
  while (i < rhs.length) {
    if (rhs[i] == 'R') { diop.R = getOperand(type); i += 1; }
    else if (rhs[i] == 'N') {
      i += 1;
      let inum = Number(rhs[i]);
      let k = 'N' + inum;
      diop[k] = getOperand(type);
      i += 1;
    } else i += 1;
  }
  i = 0;
  while (i < rhs.length) {
    if (rhs[i] == 'n') {
      i += 1;
      let inum = Number(rhs[i]);
      let k = 'n' + inum;
      let kN = 'N' + inum;
      let x = diop[kN];
      diop[k] = randomNumber(1, x - 1);
      i += 1;
    } else i += 1;
  }
  let eq = rhs;
  for (const k in diop) {
    eq = eq.replace(k, diop[k]);
  }
  let result = eval(eq);
  let lhs = stringAfter(sol, '=');
  diop[lhs] = result;
  wp.result = { number: isdef(diop.R) ? diop.R : result };
  wp.result.text = '' + wp.result.number;
  for (const k in diop) {
    if (k == 'R') continue;
    text = text.replace('@' + k, diop[k]);
  }
  wp.text = text;
  return [diop, eq];
}
function instantiateNumbersIncludingFractions(wp) {
  let sol = wp.sol;
  console.log('________________sol', sol)
  let parts = sol.split('{');
  let di = {};
  let newSol = '';
  for (const p of parts) {
    if (p[0] == 'N') {
      let key = p.substring(0, 2);
      let n;
      console.log('p', p)
      if (p[2] == '(') {
        let nums = stringBetween(p, '(', ')');
        let lst = allNumbers(nums);
        if (lst.length <= 3 && lst[0] <= lst[1]) {
          n = randomNumber(...lst);
        } else {
          n = chooseRandom(lst);
        }
      } else {
        n = randomNumber(2, 9);
      }
      let rest = stringAfter(p, '}');
      newSol += '' + n + rest;
      di[key] = n;
    } else newSol += p;
  }
  console.log('newSol', newSol);
  let res = eval(newSol);
  console.log('res of simplify', res);
  let numResult = res[0] / res[1];
  let textResult = numResult == Math.round(numResult) ? numResult : '' + res[0] + '/' + res[1];
  wp.result = { number: numResult, text: textResult };
  let text = wp.text;
  for (const k in di) {
    if (k == 'R') continue;
    text = replaceAll(text, '{' + k + '}', di[k]);
  }
  console.log('_________ text', text);
  parts = text.split('{');
  let tnew = '';
  for (const p of parts) {
    if (p[0] == 'F') {
      let s = stringBefore(p, '}');
      console.log('s', s)
      let [n, d] = allNumbers(s);
      tnew += getTextForFraction(n, d);
      tnew += '; ' + stringAfter(p, '}');
    } else tnew += p;
  }
  text = tnew;
  wp.text = text;
  mText(wp.text, dTable)
}
function instantiateOidKeyAtParent(oid, key, uidParent, R) {
  console.log('>>>>>instantiate', oid, 'using', key, 'at', uidParent, '\nrParent', R.rNodes[uidParent], '\nuiParent', R.uiNodes[uidParent]);
  let rtreeParent = R.rNodes[uidParent];
  if (nundef(rtreeParent.children)) {
    if (isdef(R.uiNodes[uidParent])) change_parent_type_if_needed(rtreeParent, R);
    rtreeParent.children = [];
  }
  let index = rtreeParent.children.length;
  let newPath = isdef(rtreeParent.sub) ? extendPath(rtreeParent.path, index) : '.';
  let nsp = R.lastSpec[key];
  let n1 = recBuildRTree(nsp, key, '.', rtreeParent, R.lastSpec, R, oid);
  R.rNodes[n1.uid] = n1;
  lookupAddToList(R.rNodesOidKey, [oid, key], n1.uid);
  rtreeParent.children.push(n1.uid);
  if (isdef(R.uiNodes) && isdef(R.uiNodes[uidParent])) {
    let parent = R.uiNodes[uidParent];
    parent.adirty = true;
    recBuildUiFromNode(n1, uidParent, R, parent.defParams, oid);
    parent.children = rtreeParent.children;
  } else {
    console.log('UI not creatable! No suitable parent found! uidParent', uidParent, 'oid', oid, 'key', key, R.uiNodes);
  }
}
function instantiateWP(wp) {
  if (wp.title.includes('Fractions')) instantiateNumbersIncludingFractions(wp); else instantiateNumbers(wp);
  instantiateNames(wp);
  console.log('wp', wp.text, wp.result);
}
function instantOidKey(oid, key, uidParent, R) {
  let rtreeParent = R.rNodes[uidParent];
  if (nundef(rtreeParent.children)) {
    rtreeParent.children = [];
  }
  let n1 = recTree(R.lastSpec[key], rtreeParent, R, oid, key);
  R.rNodes[n1.uid] = n1;
  rtreeParent.children.push(n1.uid);
  if (rtreeParent.children.length == 2 && rtreeParent.type == 'invisible' && lookup(rtreeParent, ['params', 'bg'])) {
    let uiParent = R.uiNodes[rtreeParent.uid];
    if (isdef(uiParent)) {
      rtreeParent.type = uiParent.type = 'panel';
      decodeParams(uiParent, R, {});
      uiParent.adirty = true;
      applyCssStyles(uiParent.ui, uiParent.cssParams);
    }
  }
  return n1;
}
function intDiv(n, q) {
  return Math.floor(n / q);
}
function interaction(fen, plname, func) {
  if (!uiActivated) return;
  uiActivate = false;
  pollStop();
  func(fen, plname);
}
function interrupt() {
  STOPAUS = true;
  uiActivated = aiActivated = false;
  clearTimeouts();
  if (isdef(G.clear)) G.clear();
  TOMan.clear();
  clearMarkers();
}
function intersection(arr1, arr2) {
  let res = [];
  for (const a of arr1) {
    if (arr2.includes(a)) {
      addIf(res, a);
    }
  }
  return res;
}
function intro_create_score_table(fen) {
  let dParent = mBy('dIntro');
  let d = mDiv(dParent, { margin: 'auto', w: 300 });
  html = `<div style='text-align:center;margin-top:100px'>
  <table id='customers'><tr><th>player</th><th>score</th></tr>
  `;
  let plparts = fen.split(',');
  for (const pl of plparts) {
    html += `<tr><td>${stringBefore(pl, ':')}</td><td>${stringAfter(pl, ':')}</td></tr>`
  }
  html += '</table></div>';
  d.innerHTML = html;
}
function intro_show_user_image(uname) {
  let dParent = mBy('dIntro');
  let d = mDiv(dParent, { margin: 'auto', w: 300 });
  let html = `
  <div style='text-align:center;margin-top:100px'>
    <img src='../base/assets/images/${uname}.jpg' class="img_person" height=200 />
  </div>
  `;
  d.innerHTML = html;
}
function ipadd(elem) {
  elem.setAttribute('draggable', true);
  function OnDragOver(ev) {
    elem.setAttribute('DragOver', true);
    ev.stopPropagation();
    ev.preventDefault();
    ev.dataTransfer.dropEffect = 'copy';
  }
  function OnDragLeave(ev) {
    elem.removeAttribute('DragOver');
  }
  function OnDrop(ev) {
    elem.removeAttribute('DragOver');
    ev.preventDefault();
    ev.stopPropagation();
    elem.innerHTML = ev.dataTransfer.getData('text/plain');
  }
  function OnDragStart(ev) {
    console.log('insane!!!');
    ev.stopPropagation();
    ev.dataTransfer.dropEffect = 'move';
    ev.dataTransfer.setData('text/plain', this.innerHTML);
  }
  function OnClickClick(ev) {
    ev.preventDefault();
    ev.stopPropagation();
    let aname = 'data_transport';
    let source = DA[aname];
    if (isdef(source)) {
      elem.innerHTML = source.innerHTML;
      toggleSelectionOfPicture(source);
      DA[aname] = null;
    } else {
      toggleSelectionOfPicture(elem);
      DA[aname] = elem;
    }
  }
  elem.addEventListener('dragstart', OnDragStart);
  elem.addEventListener('dragover', OnDragOver);
  elem.addEventListener('dragleave', OnDragLeave);
  elem.addEventListener('drop', OnDrop);
  elem.onclick = OnClickClick;
  DA.data_transport = null;
}
function ipaddX(elem, role) {
  let isSource = role != 'target';
  let isTarget = role != 'source';
  if (isSource) elem.setAttribute('draggable', true);
  function OnDragOver(ev) {
    elem.setAttribute('DragOver', true);
    ev.stopPropagation();
    ev.preventDefault();
    ev.dataTransfer.dropEffect = 'copy';
  }
  function OnDragLeave(ev) {
    elem.removeAttribute('DragOver');
  }
  function OnDrop(ev) {
    elem.removeAttribute('DragOver');
    ev.preventDefault();
    ev.stopPropagation();
    if (isTarget) elem.innerHTML = ev.dataTransfer.getData('text/plain');
  }
  function OnDragStart(ev) {
    ev.stopPropagation();
    ev.dataTransfer.dropEffect = 'move';
    ev.dataTransfer.setData('text/plain', this.innerHTML);
  }
  function OnClickClick(ev) {
    ev.preventDefault();
    ev.stopPropagation();
    let aname = 'data_transport';
    let source = DA[aname];
    if (nundef(source) && isSource) {
      toggleSelectionOfPicture(elem);
      DA[aname] = elem;
    } else if (isdef(source)) {
      if (isTarget) {
        if (source == elem) {
          console.log('INPUT');
          elem.innerHTML = '_';
        } else {
          elem.innerHTML = source.innerHTML;
        }
        toggleSelectionOfPicture(source);
        DA[aname] = null;
      }
      else if (isSource) {
        toggleSelectionOfPicture(source);
        if (source != elem) { toggleSelectionOfPicture(elem); DA[aname] = elem; }
        else {
          let is_letter = !isTarget;
          if (is_letter) {
            let l = elem.innerHTML;
            let inp_empty;
            for (const inp of Goal.inputs) {
              let di = iDiv(inp);
              let inner = di.innerHTML;
              if (iDiv(inp).innerHTML == '_') { inp_empty = inp; break; }
            }
            if (isdef(inp_empty)) iDiv(inp_empty).innerHTML = l;
          }
          DA[aname] = null;
        }
      }
    }
  }
  if (isSource) elem.addEventListener('dragstart', OnDragStart);
  elem.addEventListener('dragover', OnDragOver);
  elem.addEventListener('dragleave', OnDragLeave);
  elem.addEventListener('drop', OnDrop);
  elem.onclick = OnClickClick;
  DA.data_transport = null;
}
function ipaddX_orig(elem, role) {
  let isSource = role != 'target';
  let isTarget = role != 'source';
  if (isSource) elem.setAttribute('draggable', true);
  function OnDragOver(ev) {
    elem.setAttribute('DragOver', true);
    ev.stopPropagation();
    ev.preventDefault();
    ev.dataTransfer.dropEffect = 'copy';
  }
  function OnDragLeave(ev) {
    elem.removeAttribute('DragOver');
  }
  function OnDrop(ev) {
    elem.removeAttribute('DragOver');
    ev.preventDefault();
    ev.stopPropagation();
    if (isTarget) elem.innerHTML = ev.dataTransfer.getData('text/plain');
  }
  function OnDragStart(ev) {
    ev.stopPropagation();
    ev.dataTransfer.dropEffect = 'move';
    ev.dataTransfer.setData('text/plain', this.innerHTML);
  }
  function OnClickClick(ev) {
    ev.preventDefault();
    ev.stopPropagation();
    let aname = 'data_transport';
    let source = DA[aname];
    if (nundef(source) && isSource) {
      toggleSelectionOfPicture(elem);
      DA[aname] = elem;
    } else if (isdef(source)) {
      if (isTarget) { elem.innerHTML = source.innerHTML; toggleSelectionOfPicture(source); DA[aname] = null; }
      else if (isSource) {
        toggleSelectionOfPicture(source);
        if (source != elem) { toggleSelectionOfPicture(elem); DA[aname] = elem; }
        else { DA[aname] = null; }
      }
    }
  }
  if (isSource) elem.addEventListener('dragstart', OnDragStart);
  elem.addEventListener('dragover', OnDragOver);
  elem.addEventListener('dragleave', OnDragLeave);
  elem.addEventListener('drop', OnDrop);
  elem.onclick = OnClickClick;
  DA.data_transport = null;
}
function ipaddX_v1(elem, role) {
  let isSource = role != 'target';
  let isTarget = role != 'source';
  if (isSource) elem.setAttribute('draggable', true);
  function OnDragOver(ev) {
    elem.setAttribute('DragOver', true);
    ev.stopPropagation();
    ev.preventDefault();
    ev.dataTransfer.dropEffect = 'copy';
  }
  function OnDragLeave(ev) {
    elem.removeAttribute('DragOver');
  }
  function OnDrop(ev) {
    elem.removeAttribute('DragOver');
    ev.preventDefault();
    ev.stopPropagation();
    if (isTarget) elem.innerHTML = ev.dataTransfer.getData('text/plain');
  }
  function OnDragStart(ev) {
    ev.stopPropagation();
    ev.dataTransfer.dropEffect = 'move';
    ev.dataTransfer.setData('text/plain', this.innerHTML);
  }
  function OnClickClick(ev) {
    ev.preventDefault();
    ev.stopPropagation();
    let aname = 'data_transport';
    let source = DA[aname];
    if (nundef(source) && isSource) {
      toggleSelectionOfPicture(elem);
      DA[aname] = elem;
    } else if (isdef(source)) {
      if (isTarget) {
        if (source == elem) {
          console.log('INPUT');
          elem.innerHTML = '_';
        } else {
          elem.innerHTML = source.innerHTML;
        }
        toggleSelectionOfPicture(source);
        DA[aname] = null;
      }
      else if (isSource) {
        toggleSelectionOfPicture(source);
        if (source != elem) { toggleSelectionOfPicture(elem); DA[aname] = elem; }
        else {
          let is_letter = !isTarget;
          if (is_letter) {
            let l = elem.innerHTML;
            let inp_empty;
            for (const inp of Goal.inputs) {
              let di = iDiv(inp);
              let inner = di.innerHTML;
              if (iDiv(inp).innerHTML == '_') { inp_empty = inp; break; }
            }
            if (isdef(inp_empty)) iDiv(inp_empty).innerHTML = l;
          }
          DA[aname] = null;
        }
      }
    }
  }
  if (isSource) elem.addEventListener('dragstart', OnDragStart);
  elem.addEventListener('dragover', OnDragOver);
  elem.addEventListener('dragleave', OnDragLeave);
  elem.addEventListener('drop', OnDrop);
  elem.onclick = OnClickClick;
  DA.data_transport = null;
}
function iPanel(dParent, styles, classes, id, inner) {
  let item = { id: isdef(id) ? id : getUID(), type: 'plain' };
  let dOuter = mDiv(dParent);
  mCenterCenterFlex(dOuter);
  let d = mDiv(dOuter);
  if (isdef(inner)) d.innerHTML = inner;
  if (nundef(styles)) styles = {};
  let picStyles = { fz: valf(styles.fz, valf(styles.h / 2, 25)), display: 'inline-block' };
  mStyle(dOuter, styles);
  mStyle(d, picStyles);
  if (isdef(classes)) mClass(dOuter, classes);
  iAdd(item, { div: dOuter, dPic: d });
  return item;
}
function iParentBounds(i) {
  if (isdef(i.div)) i = i.div;
  let b = getBounds(i);
  let [x, y, w, h] = [Math.round(b.left), Math.round(b.top), Math.round(b.width), Math.round(b.height)];
  return { x: x, y: y, w: w, h: h };
}
function iPic(i) { return isdef(i.live) ? i.live.dPic : isdef(i.dPic) ? i.dPic : null; }
async function iPrepper() {
  symbolDict = Syms = await localOrRoute('syms', '../assets/allSyms.yaml');
  SymKeys = Object.keys(Syms);
  initTable();
}
function iPresentHand(h, dParent, styles, redo = true) {
  if (nundef(h.zone)) h.zone = iHandZone(dParent, styles); else clearElement(h.zone);
  if (nundef(h.iHand)) {
    let items = i52(h.deck.cards());
    h.iHand = iSplay(items, h.zone);
  } else if (redo) {
    clearElement(h.zone);
    let items = i52(h.deck.cards());
    h.iHand = iSplay(items, h.zone);
  }
  return h;
}
function iPresentHand_test(dParent, h, redo = true) {
  if (nundef(h.zone)) h.zone = iHandZone_test(dParent); else clearElement(h.zone);
  if (nundef(h.iHand)) {
    let items = i52(h.deck.cards());
    h.iHand = iSplay(items, h.zone);
  } else if (redo) {
    clearElement(h.zone);
    let items = i52(h.deck.cards());
    h.iHand = iSplay(items, h.zone);
  }
  return h;
}
function iReg(item, liveprops, addprops) {
  iRepair(item);
  if (isdef(liveprops)) for (const k in liveprops) { lookupSetOverride(item, ['live', k], liveprops[k]) }
  if (isdef(addprops)) copyKeys(addprops, item);
  let umain = iDiv(item); if (nundef(umain) && isdef(item.live)) { umain = get_values(item.live)[0]; }
  let id = item.id;
  if (nundef(id) && umain) { id = valnwhite(umain.id, getUID()); item.id = id; }
  else if (nundef(id)) { id = getUID(); item.id = id; }
  if (umain) { umain.id = id; }
  if (nundef(Items[id])) Items[id] = item;
  return item;
}
function iRegister(item, id) { let uid = isdef(id) ? id : getUID(); Items[uid] = item; return uid; }
function iRegisterX(item, keyProp, id) {
  let uid = isdef(id) ? id : getUID(); Items[uid] = item;
  if (isdef(item[keyProp])) ItemsByKey[item[keyProp]] = uid; return uid;
}
function iRemakeHand(data) {
  let zone = data.zone;
  let deck = data.deck;
  let items = i52(deck.cards());
  clearElement(zone);
  data.iHand = iSplay(items, zone);
  return data;
}
function iRemoveFromLive(pid, id) {
  if (pid == id) { console.log('!!!!!!!!!!!!!!!!!!!!', id, 'member of itself!!!'); return; }
  let comp = Items[pid];
  let l = comp.live;
  let tbr = null;
  for (const k in l) {
    let el = l[k];
    if (el.id == id) { tbr = k; break; }
  }
  if (tbr) delete l[tbr];
}
function iRepair(item) {
  let todelete = [];
  delete item.funcs;
  for (const k in item) {
    let val = item[k];
    if (isDOM(val) || k == 'cx') {
      lookupSetOverride(item, ['live', k], val);
      todelete.push(k);
    } else if (typeof val == 'function') {
      lookupSet(item, ['funcs', k], true);
    }
  }
  for (const k of todelete) delete item[k];
  return item;
}
function iResize(i, w, h) { return isList(i) ? i.map(x => iSize(x, w, h)) : iSize(i, w, h); }
function iResize52(i, h) { let w = h * .7; return iResize(i, w, h); }
function iRoom(dParent, ch, styles) {
  let def = { 'grid-area': ch, position: 'relative' };
  copyKeys(def, styles);
  let dCell = mDiv(dParent, styles);
  let rect = getRect(dCell);
  let size = Math.round(rect.w * rect.h / 1000);
  let room = { id: ch, ch: ch, bg: dCell.style.backgroundColor, rect: rect, size: size };
  delete Items[ch];
  iAdd(room, { div: dCell });
  room.doors = [];
  room.furniture = [];
  room.hasDoor = () => !isEmpty(room.doors)
  room.hasPassThrough = () => room.doors.length >= 2;
  return room;
}
function is_a_word(w, lang) { return lookup(Dictionary, [lang, w]) != null; }
function is_admin(name) { return ['mimi'].includes(isdef(name) ? name : Session.cur_user); }
function is_advanced_user() {
  let advancedUsers = ['mimi', 'bob', 'buddy', 'minnow', 'nimble', 'leo'];
  return isdef(U) && ((advancedUsers.includes(DA.secretuser) || advancedUsers.includes(U.name)));
}
function is_ai_player(plname) {
  let [fen, name] = [Z.fen, valf(plname, Z.uplayer)];
  return lookup(fen, ['players', name, 'playmode']) == 'bot';
}
function is_bid_higher_than(bid, oldbid) {
  bid = jsCopy(bid);
  if (bid[0] == '_') bid[0] = 0;
  if (bid[2] == '_') bid[2] = 0;
  if (oldbid[0] == '_') oldbid[0] = 0;
  if (oldbid[2] == '_') oldbid[2] = 0;
  let higher = bid[0] > oldbid[0]
    || bid[0] == oldbid[0] && is_higher_ranked_name(bid[1], oldbid[1])
    || bid[0] == oldbid[0] && bid[1] == oldbid[1] && bid[2] > oldbid[2]
    || bid[0] == oldbid[0] && bid[1] == oldbid[1] && bid[2] == oldbid[2] && is_higher_ranked_name(bid[3], oldbid[3]);
  return higher;
}
function is_bw_loggedin() {
  let bw_state = S.bw_state;
  return bw_state == 'loggedin';
}
function is_canvas(item) { return isdef(item.cx) && isdef(item.cv); }
function is_card(o) { return isdef(o.rank) || isdef(o.o) && isdef(o.o.rank); }
function is_card_key(ckey, rankstr = '*A23456789TJQK', suitstr = 'SHCD') { return rankstr.includes(ckey[0]) && suitstr.includes(ckey[1]); }
function is_collect_mode() { return Z.turn.length > 1; }
function is_correct_group(j, n = 3) { let r = j[0][0]; return j.length >= n && has_at_most_n_jolly(j, Z.options.jokers_per_group) && j.every(x => is_jolly(x) || x[0] == r); }
function is_correct_group_illegal(cards) {
  let keys = cards.map(x => x.key);
  let isgroup = is_group(keys);
  if (isgroup) return false;
  if (is_fixed_goal() && get_round_goal() != '7R') {
    return `the goal for this round is ${get_round_goal()}!`;
  }
  let [fen, uplayer] = [Z.fen, Z.uplayer];
  let pl = fen.players[uplayer];
  if (!is_fixed_goal() && pl.goals['7R'] == true) return `you can only have one sequence of 7!`;
  if (pl.journeys.find(x => is_sequence(x))) return `you can only have one sequence of 7!`;
  if (pl.roundgoal) return `row of 7 NOT allowed except if it is the round goal!`;
  return false;
}
function is_current_player_bot() {
  let [fen, uplayer, turn] = [Z.fen, Z.uplayer, Z.turn];
  let curplayer = Z.turn[0];
  if (fen.players[curplayer].playmode == 'bot') return true; else return false;
}
function is_fixed_goal() { return Z.options.phase_order == 'fixed'; }
function is_game_card(k) { return isdef(Session.cards[k]); }
function is_game_host() { return Session.cur_table.host == Session.cur_user; }
function is_group(j) {
  if (j.length < 3) return false;
  let rank = firstCond(j, x => !is_jolly(x))[0];
  return j.every(x => is_jolly(x) || x[0] == rank);
}
function is_higher_ranked_name(f1, f2) {
  let di2 = { _: 0, three: 3, four: 4, five: 5, six: 6, seven: 7, eight: 8, nine: 9, ten: 10, jack: 11, queen: 12, king: 13, ace: 14 };
  return di2[f1] > di2[f2];
}
function is_human_player(plname) {
  let [fen, name] = [Z.fen, valf(plname, Z.uplayer)];
  return lookup(fen, ['players', name, 'playmode']) == 'human';
}
function is_in_middle_of_church() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  return isdef(fen.players[uplayer].tithes);
}
function is_it_my_turn(r, uname) { return r.uname == uname; }
function is_joker(card) { return is_jolly(card.key); }
function is_jolly(ckey) { return ckey[0] == '*'; }
function is_journey(cards) {
  let jlist = find_sequences(cards, cards.length, 'A23456789TJQK');
  let j = firstCond(jlist, x => x.length == cards.length);
  return j;
}
function is_just_my_turn() {
  return isEmpty(Z.turn.filter(x => x != Z.uplayer));
}
function is_key_down(key) {
  if (nundef(DA.keystate)) {
    DA.keystate = {};
    window.addEventListener('keyup', (e) => DA.keystate[e.key] = false);
    window.addEventListener('keydown', (e) => { DA.keystate[e.key] = true; });
  }
  return DA.keystate.hasOwnProperty(key) && DA.keystate[key] || false;
}
function is_lat_lng(p) { return isdef(p.lat); }
function is_lat_long(p) { return is_lat_lng(p); }
function is_legal_if_7R(cards) {
  let keys = cards.map(x => x.key);
  let isgroup = is_group(keys);
  if (isgroup) return true;
  if (is_fixed_goal() && get_round_goal() != '7R') {
    return false;
  }
  let [fen, uplayer] = [Z.fen, Z.uplayer];
  let pl = fen.players[uplayer];
  if (!is_fixed_goal() && pl.goals['7R'] == true) return false;
  if (pl.journeys.find(x => is_sequence(x))) return false;
  return true;
}
function is_map(o) { return isdef(o.map) || isdef(o._panes); }
function is_multi_stage() { return isdef(Z.fen.trigger); }
function is_multi_trigger(plname) { return lookup(Z, ['fen', 'trigger']) == plname; }
function is_online() { return lookup(DA, ['internet']); }
function is_overlapping_set(cards, max_jollies_allowed = 1, seqlen = 7, group_same_suit_allowed = true) {
  let istart = 0;
  let inextstart = 0;
  let lmin = 3;
  let legal = true;
  if (cards.length < lmin) return false;
  while (legal && istart <= cards.length - lmin) {
    let cl = cards.slice(istart, istart + lmin);
    let set = ferro_is_set(cl, max_jollies_allowed, seqlen, group_same_suit_allowed);
    if (set) { istart++; inextstart = Math.min(istart + lmin, cards.length - 3); }
    else if (!set && inextstart == istart) return false;
    else istart++;
  }
  return cards.map(x => x.key);
}
function is_playerdata_set(plname) {
  return isdef(Z.playerdata) && !isEmpty(Z.playerdata) && !isEmpty(Z.playerdata.find(x => x.name == plname).state);
}
function is_playing(pl, fen) {
  return isList(fen.plorder) && fen.plorder.includes(pl) || isList(fen.roundorder) && fen.roundorder.includes(pl) || Z.game == 'feedback' && isdef(Z.fen.players[pl]);
}
function is_polling_on() { return IS_POLLING_ALLOWED; }
function is_race_game(gname) { return DB.games[gname].game_type == 'race'; }
function is_really_online() { return navigator.onLine; }
function is_round_over(otree) { return otree.round.length >= otree.plorder.length; }
function is_sequence(j) { return !is_group(j); }
function is_Set(x) {
  return '_set' in x;
}
function is_setup_commissions_complete() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  let next = get_next_player(Z, uplayer);
  return next == plorder[0] && fen.comm_setup_num == 1;
}
function is_shield_mode() {
  return Z.role == 'spectator'
    || Z.mode == 'multi' && Z.role == 'inactive' && Z.host != Z.uname
    || Z.mode == 'multi' && Z.role == 'inactive' && Z.pl.playmode != 'bot'
}
function is_solved(board) {
  let expected = [1, 2, 3, 4, 5, 6, 7, 8, 9]
  let valid = true
  for (r = 0; r < 9 && valid == true; r++) {
    if (!compare(expected, get_row(board, r))) {
      valid = false
    }
  }
  for (c = 0; c < 9 && valid == true; c++) {
    if (!compare(expected, get_column(board, c))) {
      valid = false
    }
  }
  for (q = 1; q < 9 && valid == true; q++) {
    if (!compare(expected, get_square(board, q))) {
      valid = false
    }
  }
  return valid
}
function is_stall_selection_complete() { return Z.fen.stallSelected.length == Z.fen.plorder.length; }
function is_stringified(obj) {
  if (isString(obj)) {
    return '"\'{[('.includes(obj[0]);
  }
  return false;
}
function is_Tuple(x) {
  return isDict(x) && ('_tuple' in x);
}
function is_turn_counter_clockwise(a1, a2) {
  let diff = Math.abs(a2 - a1);
  let q1 = get_quadrant(a1);
  let q2 = get_quadrant(a2);
  let cclock = false;
  if (q1 == q2) { cclock = a2 < a1; }
  else {
    if (a2 > a1 && diff > 180) cclock = true;
    if (a2 < a1 && diff < 180) cclock = true;
  }
  return cclock;
}
function is_user_spectating(g) { return isdef(U) && !g.plorder.includes(U.name); }
function is_visible(id) { return !mBy(id).classList.includes('d-block'); }
function isAcceptableAnswerButNewSound(info, reqAnswer, s) {
  let sParts = s.split(' ');
  let aParts = reqAnswer.split(' ');
  if (isTimeString(s)) s = convertTimesAndNumbersToWords(s);
  if (isTimeString(reqAnswer)) reqAnswer = convertTimesAndNumbersToWords(reqAnswer);
  if (sParts.length != aParts.length) return false;
  for (let i = 0; i < sParts.length; i++) {
    if (!soundsSimilar(sParts[i], aParts[i])) return false;
  }
  return true;
}
function isActionElement(x) {
  return typeof x == 'object' && 'type' in x;
}
function isAlphaNum(s) { query = /^[a-zA-Z0-9]+$/; return query.test(s); }
function isAlphaNumeric(str) {
  var code, i, len;
  for (i = 0, len = str.length; i < len; i++) {
    code = str.charCodeAt(i);
    if (!(code > 47 && code < 58) &&
      !(code > 64 && code < 91) &&
      !(code > 96 && code < 123) && str[i] != '_') {
      return false;
    }
  }
  return true;
};
function isANS(unitType) {
  return ['AirForce', 'Submarine', 'Carrier', 'Fleet'].includes(unitType);
}
function isBoard(uid, R) {
  if (!uid) return false;
  let n = R.uiNodes[uid];
  return isdef(n) && isdef(n.bi) && isdef(n.bi.boardDiv);
}
function isBoardElement(oid) { let mobj = getVisual(oid); return mobj && mobj.idParent[2] == 's'; }
function isBoardElementObject(o) { return o.edges || o.corners; }
function isBoardMember(uid, R) {
  let n = R.uiNodes[uid];
  return isdef(n) ? isBoard(n.uidParent, R) : false;
}
function isBoardObject(o) { return o.map && o.fields; }
function isCapitalLetter(s) { return /^[A-Z]$/i.test(s); }
function isCapitalLetterOrDigit(s) { return /^[A-Z0-9ÖÄÜ]$/i.test(s); }
function isCardSet(o) {
  if (nundef(o)) return false;
  if (nundef(o._set)) return false;
  let arr = o._set;
  if (!isList(arr)) return false;
  for (const el of arr) {
    if (nundef(el)) return false;
    if (nundef(el._obj)) return false;
    let card = G.table[el._obj];
    if (nundef(card) || card.generic_type != 'card') return false;
  }
  return true;
}
function isCardType(o) {
  return 'obj_type' in o && endsWith(o.obj_type, 'card');
}
function isCloseTo(n, m, acc = 10) { return Math.abs(n - m) <= acc + 1; }
function isColorName(s) { ensureColorNames(); return (isdef(ColorNames[s.toLowerCase()])); }
function isComplexColor(x) { return isString(x) && x.includes('('); }
function isContainerType(t) { return t == 'panel' || t == 'list' || t == 'hand'; }
function isCornerRoom(house, room) {
  let rr = room.rect;
  let rh = house.rect;
  let w = house.wallWidth;
  let isHorSide = isCloseTo(rr.x, rh.x, w) || isCloseTo(rr.r, rh.r, w);
  let isVertSide = isCloseTo(rr.y, rh.y, w) || isCloseTo(rr.b, rh.b, w);
  return isHorSide && isVertSide;
}
function isDeckObject(o) {
  if (nundef(o)) console.log(getFunctionsNameThatCalledThisFunction(), 'undefined object checked for is deck!!!')
  return isdef(o.deck_count);
}
function isdef(x) { return x !== null && x !== undefined; }
function isDetection() { return (S.settings.boardDetection || S.settings.deckDetection) && !S.settings.userStructures }
function isDict(d) { let res = (d !== null) && (typeof (d) == 'object') && !isList(d); return res; }
function isDictOrList(d) { return typeof (d) == 'object'; }
function isDigit(s) { return /^[0-9]$/i.test(s); }
function isDOM(x) { let c = lookup(x, ['constructor', 'name']); return c ? startsWith(c, 'HTML') || startsWith(c, 'SVG') : false; }
function isDynamic(x) { let t = lookup(x, ['meta', 'type']); return t == 'dynamic'; }
function isEastRoom(house, room) { return isCloseTo(room.rect.r, house.rect.r, house.wallWidth); }
function isEmosetMember(name, info) { return emoSets[name].f(info); }
function isEmpty(arr) {
  return arr === undefined || !arr
    || (isString(arr) && (arr == 'undefined' || arr == ''))
    || (Array.isArray(arr) && arr.length == 0)
    || Object.entries(arr).length === 0;
}
function isEmptyDict(x) { return isDict(x) && isEmpty(Object.keys(x)); }
function isEmptyOrWhiteSpace(s) { return isEmpty(s.trim()); }
function isEnglish(lang) { return startsWith(lang.toLowerCase(), 'e'); }
function isEnglishKeyboardGermanEquivalent(wreq, w) {
  wreq = fromUmlaut(wreq)
  w = fromUmlaut(w);
  return allLettersContained(wreq, w);
}
function isError(d) {
  let kathastrophicError = !(typeof d == 'object');
  let someErrorOccurred = 'error' in d;
  if (kathastrophicError) {
    error('KATHASTROPHIC ERROR!!!!!', d)
    alert('KATHASTROPHIC ERROR!!!!! data type ' + (typeof d));
    return true;
  } else if (someErrorOccurred) {
    switch (d.type) {
      case 'parse': return false;
      case 'ajax': return true;
      default: return true;
    }
  }
  return false;
}
function isEvent(param) { return getTypeOf(param) == 'event'; }
function isFaceUp(oCard) { return oCard.obj_type; }
function isFarbPerle(perle) { return isGermanColorName(perle.key); }
function isField(o) { return o.neighbors; }
function isFractionType(x) { return isDict(x) && isdef(x.n) && isdef(x.d); }
function isFrontAIPlayer(id) {
  if (USE_BACKEND_AI) return false;
  let players = S.gameConfig.players;
  let pl = firstCond(players, x => x.id == id);
  let playerType = pl.playerType;
  return playerType == 'AI';
}
function isGameWithSpeechRecognition() { return ['gSayPic', 'gSayPicAuto'].includes(currentGame); }
function isGermanColorName(s) { return isColorName(s) || isdef(GermanToEnglish[s]) && isColorName(GermanToEnglish[s]); }
function isGermanString(x) { return currentLanguage == 'D' && !isNumber(x) && !isTimeString(x); }
function isGridType(t) { return t == 'grid'; }
function iSidebar(d1, d2, dToggle = null, w = 100, startOpen = true, id) {
  mStyle(d1, { h: '100%', w: startOpen == true ? w : 0, position: 'absolute', z: 1, top: 0, left: 0, 'overflow': 'hidden' });
  mStyle(d2, { h: '100%', maleft: startOpen == true ? w : '0px', box: true }, null, null);
  d1.isOpen = startOpen;
  d1.wNeeded = w;
  let tell = () => console.log('sidebar is', d1.isOpen ? 'OPEN' : 'CLOSED');
  let fToggle = (ev, animate = true) => {
    d1.isOpen = !d1.isOpen;
    let val = d1.isOpen ? d1.wNeeded : 0;
    if (animate) multiStyleAnimation([[d1, { w: val }], [d2, { maleft: val }]], 500, tell);
    else { mStyle(d1, { w: val }); mStyle(d2, { maleft: val }); tell(); }
  }
  let fOpen = (ev, animate = true) => {
    if (d1.isOpen) return;
    fToggle(ev, animate);
  }
  let fClose = (ev, animate = true) => {
    if (!d1.isOpen) return;
    fToggle(ev, animate);
  }
  let fAddContent = (cont, styles) => {
    mAddContent(d1, cont, styles, { keepInLine: true, replace: false });
    let sz = getSizeNeeded(d1);
    d1.wNeeded = sz.w;
    if (d1.isOpen) { mStyle(d1, { w: d1.wNeeded }); mStyle(d2, { maleft: d1.wNeeded }); }
  };
  let fReplaceContent = (cont, styles) => { clearElement(d1); fAddContent(cont, styles); };
  id = isdef(id) ? id : !isEmpty(d1.id) ? d1.id : getUID('sb');
  let item = mItem(id, { div: d1 }, { type: 'sidebar', w: w, toggle: fToggle, open: fOpen, close: fClose, addContent: fAddContent, replaceContent: fReplaceContent }, true);
  if (!isEmpty(d2.id)) item.idContent = d2.id;
  if (isdef(dToggle)) { iAdd(item, { dToggle: dToggle }); dToggle.onclick = fToggle; }
  return item;
}
function iSidebar01(d, d1, d2, dToggle = null, w = 100) {
  mStyleX(d1, { h: '100%', w: 100, position: 'absolute', z: 1, top: 0, left: 0, overflow: 'hidden', transition: '0.5s' });
  mStyleX(d2, { maleft: 100, h: '100%', box: true, transition: '0.5s' }, null, null)
  let fToggle = () => {
    mToggle(d1, 'width', 0, w); mToggle(d2, 'margin-left', 0, w);
  }
  let item = mItem({ div: d1, dParent: d, dSibling: d2 });
  item.fToggle = fToggle;
  item.w = w;
  if (isdef(dToggle)) { item.dToggle = dToggle; dToggle.onclick = fToggle; }
  return item;
}
function iSidebar04(d, d1, d2, dToggle = null, w = 100, startOpen = true) {
  mStyleX(d1, { h: '100%', w: startOpen ? w : 0, position: 'absolute', z: 1, top: 0, left: 0, overflow: 'hidden', transition: '0.5s' });
  mStyleX(d2, { h: '100%', maleft: startOpen ? w : 0, box: true, transition: '0.5s' }, null, null);
  d1.isOpen = startOpen;
  let fToggle = () => {
    d1.isOpen = !d1.isOpen;
    let wOpen = valf(d1.wNeeded, w)
    mToggle(d1, 'width', 0, wOpen);
    mToggle(d2, 'margin-left', 0, wOpen);
  }
  let fOpen = () => {
    if (d1.isOpen) return;
    fToggle();
  }
  let fClose = () => {
    if (!d1.isOpen) return;
    fToggle();
  }
  let fReplaceContent = cont => {
    d1.style.width = 'auto';
    d1.innerHTML = cont;
    let wNeeded = d1.wNeeded = getRect(d1).w;
    d1.wCurrent = d1.style.width = makeUnitString(wNeeded);
    console.log('now wNeeded is', d1.wNeeded);
    if (!d1.isOpen) d1.style.width = 0;
  };
  let fAddContent = cont => {
    d1.style.width = 'auto';
    mAppend(d1, isString(cont) ? mText(cont, d1) : cont);
    let wNeeded = d1.wNeeded = getRect(d1).w;
    d1.wCurrent = d1.style.width = makeUnitString(wNeeded);
    console.log('now wNeeded is', d1.wNeeded);
    if (!d1.isOpen) d1.style.width = 0;
  };
  let item = mItem({ div: d1, dParent: d, dSibling: d2 });
  d1.item = item; d1.id = item.id;
  item.toggle = fToggle;
  item.open = fOpen;
  item.close = fClose;
  item.addContent = fAddContent;
  item.replaceContent = fReplaceContent;
  item.w = w;
  if (isdef(dToggle)) { item.dToggle = dToggle; dToggle.onclick = fToggle; }
  return item;
}
function isItem(i) { return isdef(i.div); }
function iSize(i, w, h) { i.w = w; i.h = h; mSize(i.div, w, h); }
function isJoinMenuOpen() {
  return isVisible(document.getElementById('bLobbyJoinOk'));
}
function isLabelVisible(id) { return isVisible(mBy(id).children[1]); }
function isLastTestOfSeries() {
  let tests = ALLTESTS[iTESTSERIES];
  let numtests = Object.keys(tests).length;
  return iTEST >= numtests;
}
function isLeafType(t) { return t == 'info' || t == 'title' || t == 'card' || t == 'picto'; }
function isLetter(s) { return /^[a-zA-Z]$/i.test(s); }
function isLetterElement(elem) { return isCapitalLetterOrDigit(elem.innerHTML); }
function isList(arr) { return Array.isArray(arr); }
function isListOf(arr, predfunc) { return Array.isArray(arr) && !firstCond(arr, x => !predfunc(x)); }
function isListOf_Obj(x) {
  return isList(x) && !empty(x) && atleastOneElementOfXIsDictWithKey_obj(x);
}
function isListOfActionElements(lst) {
  if (!isList(lst)) return false;
  for (const el of lst) {
    if (isList(el)) return false;
  }
  return true;
}
function isListOfActions(l) {
  return isList(l) && !empty(l) && isActionElement(l[0]);
}
function isListOfListOfActions(x) {
  return isList(x) && x.length > 0 && isList(x[0]) && x[0].length > 0 && isActionElement(x[0][0]);
}
function isListOfLists(lst) {
  return isList(lst) && !isEmpty(lst) && isList(lst[0]);
}
function isListOfLiterals(lst) {
  if (!isList(lst)) return false;
  for (const el of lst) {
    if (!isLiteral(el)) return false;
  }
  return true;
}
function isListOfServerObjects(x) {
  let oids = getElements(x);
  console.log('getElements returns', oids);
  return false;
}
function isLiteral(x) { return isString(x) || isNumber(x); }
function isll(ll) {
  if (!isList(ll)) {
    testHelpers('NOT a list', ll);
    return false;
  }
  for (const l of ll) {
    if (!isList(l)) {
      testHelpers('element', l, 'NOT a list!');
      return false;
    }
    for (const el of l) {
      if (!isString(el) && !isNumeric(el)) return false;
    }
  }
  return true;
}
function isllPlus(ll) {
  if (!isList(ll)) {
    testHelpers('NOT a list', ll);
    return false;
  }
  for (const l of ll) {
    if (!isList(l)) {
      testHelpers('element', l, 'NOT a list!');
      return false;
    }
  }
  return true;
}
function isMap(x) { let t = lookup(x, ['meta', 'type']); return t == 'map'; }
function isMergeableObject(val) {
  var nonNullObject = val && typeof val === 'object'
  return nonNullObject
    && Object.prototype.toString.call(val) !== '[object RegExp]'
    && Object.prototype.toString.call(val) !== '[object Date]'
}
function isMS(param) {
  return getTypeOf(param) == 'MS';
}
function isMyPlayer(id) {
  let uname = getUsernameForPlayer(id);
  return startsWith(uname, USERNAME);
}
function isMyTurn() {
  disableButton('c_b_PollStatus');
}
function isNorthRoom(house, room) { return isCloseTo(room.rect.t, house.rect.t, house.wallWidth); }
function isNumber(x) { return x !== ' ' && x !== true && x !== false && isdef(x) && (x == 0 || !isNaN(+x)); }
function isNumberOrTimeString(w) { return isNumber(w) || isTimeString(w); }
function isNumeric(x) { return !isNaN(+x); }
function isObject(v) {
  return '[object Object]' === Object.prototype.toString.call(v);
};
function isOppPiece(sym, plSym) { return sym && sym != plSym; }
function iSortHand(dParent, h) {
  let d = h.deck;
  d.sort();
  iPresentHand(dParent, h);
}
function iSortHand_test(dParent, h) {
  let d = h.deck;
  d.sort();
  iPresentHand_test(dParent, h);
}
function isOverflown(element) {
  return element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth;
}
function isPlain() { return !S.settings.boardDetection && !S.settings.deckDetection && !S.settings.userStructures }
function iSplay(items, iContainer, containerStyles, splay = 'right', ov = 20, ovUnit = '%', createHand = true, rememberFunc = true) {
  if (!isList(items)) items = [items];
  if (isEmpty(items)) return { w: 0, h: 0 };
  let [w, h] = [items[0].w, items[0].h];
  let isHorizontal = splay == 'right' || splay == 'left';
  for (let i = 0; i < items.length; i++) {
    let item = items[i];
    item.col = isHorizontal ? i : 0;
    item.row = isHorizontal ? 0 : i;
    item.index = item.z = i;
  }
  if (nundef(containerStyles)) containerStyles = {};
  let dContainer = iDiv(iContainer);
  let dParent, iParent;
  if (createHand) {
    dParent = mDiv(dContainer);
    iParent = { div: dParent };
  } else if (isItem(iContainer)) {
    dParent = iContainer.div;
    iParent = iContainer;
  } else dParent = iContainer;
  mStyleX(dParent, containerStyles);
  let gap = isdef(containerStyles.padding) ? containerStyles.padding : 0;
  let overlap = ov;
  if (ovUnit == '%') overlap = ov == 0 ? .5 : (isHorizontal ? w : h) * ov / 100;
  let x = y = gap;
  let sz = splayout(items.map(x => x.div), dParent, w, h, x, y, overlap, splay);
  dParent.style.width = '' + sz.w + 'px';
  dParent.style.height = '' + sz.h + 'px';
  if (isdef(iParent)) { iParent.w = sz.w; iParent.h = sz.h; iParent.items = items; }
  return isdef(iParent) ? iParent : dParent;
}
function iSplay52(i, iContainer, splay = 'right', ov = 20, ovUnit = '%', createiHand = true, rememberFunc = true) {
  let ilist = !isList(i) ? i : [i];
  let items = isNumber(i[0]) ? i52(ilist) : ilist;
  let res = iSplay(items, iContainer, null, 'right', 20, '%', true);
  return res;
}
function isPlayerChecked(i) {
  id = getidNum(i); return document.getElementById(id).checked == true;
}
function isPlaying() { return DA.isSound; }
function IsRepetition() {
  var index = 0;
  for (index = brd_hisPly - brd_fiftyMove; index < brd_hisPly - 1; ++index) {
    if (brd_posKey == brd_history[index].posKey) {
      return BOOL.TRUE;
    }
  }
  return BOOL.FALSE;
}
function isSeason(ph) {
  return ['Spring', 'Summer', 'Fall', 'Winter'].includes(ph);
}
function isSet(x) { return (isDict(x) && (x.set || x._set)); }
function isSimilar(reqAnswer, answer, lang) {
  if (answer == reqAnswer) return true;
  else if (replaceAll(answer, ' ', '') == replaceAll(reqAnswer, ' ', '')) return true;
  else if (differInAtMost(reqAnswer, answer, 1)) return true;
  else if (isSimilarSound(reqAnswer, answer, lang)) return true;
  else return false;
}
function isSimilarSound(reqAnswer, s, lang) {
  let sParts = s.split(' ');
  let aParts = reqAnswer.split(' ');
  if (isNumber(s) || isTimeString(s, lang)) s = convertTimesAndNumbersToWords(s);
  if (isNumber(reqAnswer) || isTimeString(reqAnswer, lang)) reqAnswer = convertTimesAndNumbersToWords(reqAnswer);
  if (sParts.length != aParts.length) return false;
  for (let i = 0; i < sParts.length; i++) {
    if (!soundsSimilar(sParts[i], aParts[i], lang)) return false;
  }
  return true;
}
function isSimple(x) { return isString(x) || isNumeric(x); }
function isSimpleType(type) { return !['list', 'object'].includes(type); }
function isSingleDigit(s) { return /^[0-9]$/i.test(s); }
function isSingleton(x) {
  return (isSet(x) &&
    ('set' in x && x.set.length == 1 || '_set' in x && x._set.length == 1))
    ||
    (isTuple(x) &&
      ('tuple' in x && x.tuple.length == 1 || '_tuple' in x && x._tuple.length == 1));
}
function isSizedNode(n) { return isdef(n.params.size) || isdef(n.params.width) || isdef(n.params.height); }
function isSouthRoom(house, room) { return isCloseTo(room.rect.b, house.rect.b, house.wallWidth); }
function isSpecType(t) { return isdef(R.lastSpec[t]); }
function isStatic(x) { let t = lookup(x, ['meta', 'type']); return t == 'static'; }
function isString(param) { return typeof param == 'string'; }
function isStructuralElement(oid) { if (nundef(G.table) || !(oid in G.table)) return false; return 'map' in G.table[oid]; }
function isSvg(elem) { return startsWith(elem.constructor.name, 'SVG'); }
function isTimeForAddon() {
  if (nundef(ADS)) return false;
  if (isEmpty(U.avAddons)) return false;
  if (isdef(AD) && AD.running && AD.checkEndCondition()) {
    console.log('END!')
    AD.die();
    U.addons[AD.key].open = false;
    AD = null;
  }
  if (isdef(AD)) return AD.isTimeForAddon();
  let open = allCondDict(U.addons, x => x.open == true);
  if (isEmpty(open)) {
    console.log('open is empty! choosing a random addon!')
    let k = chooseRandom(U.avAddons);
    AD = new ADS[k].cl(k, ADS[k], {});
  } else if (open.length == 1) {
    let k = open[0];
    AD = new ADS[k].cl(k, ADS[k], U.addons[k]);
  } else {
    let k = chooseRandom(open);
    AD = new ADS[k].cl(k, ADS[k], U.addons[k]);
  }
  return AD.isTimeForAddon();
}
function isTimeString(w, lang) {
  let res1 = (w.includes(':') && w.length >= 4 && w.length <= 5);
  let res2 = (lang == 'D' && stringAfterLast(w.toLowerCase(), ' ') == 'uhr');
  return res1 || res2;
}
function isTooEarly(optYear, curYear, optStep, curStep) {
  return Number(curYear) < optYear || curStep < optStep;
}
function iStrip(item) { delete item.live; return item; }
function isTuple(x) {
  return Array.isArray(x);
}
function iStyle(i, styles) { mStyleX(iDiv(i), styles); }
function isType(sType, val) {
  switch (sType) {
    case 'region':
      return val in regions;
    case 'power':
      return val in unitsPerPower;
    case 'unit':
      return val in units;
    case 'faction':
      return val in ['Axis', 'West', 'USSR'];
  }
  return false;
}
function isVariableColor(c) { return c == 'random' || c == 'randPastel' || c == 'randDark' || c == 'randLight' || isList(c); }
function iSvg(i) { return isdef(i.live) ? i.live.svg : isdef(i.svg) ? i.svg : i; }
function isVisible(elem) {
  if (isString(elem)) elem = document.getElementById(elem);
  let x = elem.style.flex;
  return (elem.style.display != 'none' || elem.offsetParent !== null) && (nundef(elem.style.flex) || !endsWith(elem.style.flex, '0%'));
}
function isVisible2(elem) {
  if (isString(elem)) elem = document.getElementById(elem);
  return (elem.style.display != 'none' || elem.offsetParent !== null);
}
function isVisibleToPlayer(o, player) {
  let vis = getVisibleSet(o);
  if (vis && vis.includes(player)) return true;
}
function isWestRoom(house, room) { return isCloseTo(room.rect.l, house.rect.l, house.wallWidth); }
function isWhiteSpace(ch) { return /\s/.test(ch) }
function isWhiteSpace1(s) { let white = new RegExp(/^\s$/); return white.test(s.charAt(0)); }
function isWhiteSpace2(ch) {
  const alphanum = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_';
  return !alphanum.includes(ch);
}
function isWhiteSpaceString(s) { return isEmptyOrWhiteSpace(s); }
function isWord(w) { return lookup(Dictionary, [G.language, w]); }
function isWrongPhase(optPhase, curPhase) {
  return optPhase != 'any' && !startsWithCaseIn(curPhase, optPhase);
}
function isWrongPlayer(optPlayer, curPlayer) {
  return optPlayer != 'any' && !startsWithCaseIn(curPlayer, optPlayer);
}
function isYesNo(choices) { return !firstCond(choices, x => !(['yes', 'no'].includes(x.text))); }
function iSym(kItem, dParent, styles, classes) {
  let item;
  if (isString(kItem)) { item = { id: getUID(), key: kItem, info: Syms[kItem] }; }
  else if (nundef(kItem.info)) { item = { id: getUID(), key: kItem.key, info: kItem }; }
  else item = kItem;
  let info = item.info;
  let dOuter = mDiv(dParent);
  mCenterCenterFlex(dOuter);
  let d = mDiv(dOuter);
  d.innerHTML = info.text;
  if (nundef(styles)) styles = {};
  let picStyles = { family: info.family, fz: valf(styles.fz, valf(styles.h / 2, 25)), display: 'inline-block' };
  mStyle(dOuter, styles);
  mStyle(d, picStyles);
  if (isdef(classes)) mClass(dOuter, classes);
  iAdd(item, { div: dOuter, dPic: d });
  return item;
}
function iTableBounds(i) { return iBounds(i, dTable); }
function iTag(tags = ['canvas', 'textarea', 'a'], ignore_empty = true) {
  for (const t of tags) {
    let uis = Array.from(document.getElementsByTagName(t));
    if (ignore_empty) uis = uis.filter(d => !isEmpty(d.innerHTML));
    for (const ui of uis) {
      if (isEmptyOrWhiteSpace(ui.id)) ui.id = getUID();
      iAdd({}, { div: ui });
    }
  }
  setTimeout(show_tagged, 100);
}
async function iTest00() {
  await iPrepper();
  let keys = SymKeys;
  let k = chooseRandom(keys);
  let item = miPic(k, dTable, { w: 100, h: 100, fz: 80, bg: 'blue' });
}
function iTitle(item, msg) { let dm = diTitle(item); if (isdef(dm)) dm.innerHTML = msg; }
function iToggleMultipleSelection(item, items) {
  let ui = iDiv(item);
  item.isSelected = !item.isSelected;
  if (item.isSelected) mClass(ui, 'framedPicture'); else mRemoveClass(ui, 'framedPicture');
  if (isdef(items)) {
    for (const i1 of items) {
      if (i1.isSelected) {
        console.assert(!items.includes(i1), 'UNSELECTED PIC IN PICLIST!!!!!!!!!!!!')
        items.push(i1);
      } else {
        console.assert(items.includes(i1), 'PIC NOT IN PICLIST BUT HAS BEEN SELECTED!!!!!!!!!!!!')
        removeInPlace(items, i1);
      }
    }
  }
}
function iToggleSingleSelection(item, items) {
  let ui = iDiv(item);
  let selItem = null;
  item.isSelected = !item.isSelected;
  if (item.isSelected) { mClass(ui, 'framedPicture'); selItem = item; }
  else { mRemoveClass(ui, 'framedPicture'); selItem = null; }
  if (isdef(items) && selItem) {
    for (const i1 of items) {
      if (i1.isSelected && i1 != item) {
        i1.isSelected = false;
        mRemoveClass(iDiv(i1), 'framedPicture');
        break;
      }
    }
  }
  return selItem;
}
function iToRowCol(idx, rows, cols) { let c = idx % cols; let r = (idx - c) / rows; return [r, c]; }
function iToSuit52_G(suit) {
  return suit === 0 ? 'spades' : suit === 1 ? 'hearts' : suit === 2 ? 'clubs' : suit === 3 ? 'diamonds' : 'joker';
}
function iToValue(l) { if (isdef(l)) l = l % 13; return isdef(l) ? l == 0 ? 13 : l : null; }
function iTrim(item, serialize = true) {
  let todelete = [];
  for (const k in item) {
    let val = item[k];
    if (isDOM(val)) {
      if (!serialize) { if (isEmptyOrWhiteSpace(val.id)) val.id = getUID(); lookupSetOverride(item, ['live', val.id], val); }
      todelete.push(k);
    } else if (typeof val == 'function') {
      console.log('funcname', val.name);
      if (serialize) item[k] = val.name;
      else { lookupSetOverride(item, ['funcs', val.name], val); todelete.push(k); }
    }
  }
  if (serialize) { delete item.live; delete item.funcs };
  for (const k of todelete) delete item[k];
  return item;
}
function iUnhigh(item) { let d = iDiv(item); mStyle(d, { bg: 'transparent' }); }
function iZMax(n) { if (isdef(n)) ZMax = n; ZMax += 1; return ZMax; }
function join_table(user, tid) { to_server({ uname: user, tid: tid }, 'join_table'); }
function joinMultiplayerGame() {
}
function jolly_matches(key, j, rankstr = 'A23456789TJQKA') {
  let jolly_idx = find_index_of_jolly(j);
  if (jolly_idx == -1) return false;
  if (is_group(j)) {
    let r = get_group_rank(j);
    if (key[0] == r) return true;
  } else if (jolly_idx > 0) {
    let rank_before_index = j[jolly_idx - 1][0];
    let suit_needed = j[jolly_idx - 1][1];
    let rank_needed = rankstr[rankstr.indexOf(rank_before_index) + 1];
    if (key[0] == rank_needed && key[1] == suit_needed) return true;
  } else {
    let rank_after_index = j[jolly_idx + 1][0];
    let suit_needed = j[jolly_idx + 1][1];
    let rank_needed = rank_after_index == 'A' ? 'K' : rankstr[rankstr.indexOf(rank_after_index) - 1];
    if (key[0] == rank_needed && key[1] == suit_needed) return true;
  }
  return false;
}
function Joy() {
  this.SENSITIVITY = 50;
  this.diffX = 0;
  this.diffY = 0;
  var touches = [];
  var startX;
  var startY;
  this.onTouchStart = function (event) {
    result = "touch: ";
    touches = event.touches;
    startX = touches[0].screenX;
    startY = touches[0].screenY;
    result += "x: " + startX + ", y: " + startY;
    console.log(result);
  }
  this.onTouchMove = function (event) {
    result = "move: "
    event.preventDefault();
    touches = event.touches;
    this.diffX = touches[0].screenX - startX;
    this.diffY = touches[0].screenY - startY;
    result += "dx: " + this.diffX + ", dy: " + this.diffY;
    console.log(result);
  }
  this.onTouchEnd = function (event) {
    result = "no touch";
    touches = event.touches;
    this.diffX = 0;
    this.diffY = 0;
  }
  touchable = 'createTouch' in document;
  if (touchable) {
    document.addEventListener('touchstart', this.onTouchStart, false);
    document.addEventListener('touchmove', this.onTouchMove, false);
    document.addEventListener('touchend', this.onTouchEnd, false);
  }
  this.getDX = function () {
    return "At least I work...";
    return this.diffX;
  }
  this.getDY = function () {
    return this.diffY;
  }
}
function jsClean(o) {
  if (nundef(o)) return o;
  else if (isDOM(o)) return null;
  else if (isLiteral(o)) return o;
  else if (isList(o)) {
    let onew = o.map(x => jsClean(x));
    return onew.filter(x => x !== null);
  } else if (isDict(o)) {
    for (const k in o) o[k] = jsClean(o[k]);
    let onew = {};
    for (const k in o) if (o[k] !== null) onew[k] = o[k];
    return onew;
  }
}
function jsCopy(o) { return JSON.parse(JSON.stringify(o)); }
function jsCopyMinus(o) {
  let lstOmit = [...arguments].slice(1);
  let oNew = {};
  for (const k in o) {
    if (lstOmit.includes(k)) continue;
    oNew[k] = o[k];
  }
  return oNew;
}
function jsCopySafe(o) { return JSON.parse(JSON.stringify(jsClean(o))); }
function jsonToYaml(o) { let y = jsyaml.dump(o); return y; }
function jsSafeStringify(obj, indent = 2) {
  let cache = [];
  const retVal = JSON.stringify(
    obj,
    (key, value) =>
      typeof value === "object" && value !== null
        ? cache.includes(value)
          ? undefined
          : cache.push(value) && value
        : value,
    indent
  );
  cache = null;
  return retVal;
};
function just_map() {
  var map = L.map('map');
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);
  return map;
}
function just_message(msg, styles = {}) {
  alert(msg);
}
function just_points(map) {
  console.log('geo', Geo)
  let [p1, p2] = [Geo.places.tuerkenschanzpark, Geo.places.vegagasse];
  return [p1, p2];
}
function justClick(ev) { console.log('click', ev.target, 'item', evToItemC(ev)); }
function justIds(o) {
  return Object.keys(o);
}
function keepOnlyElements(func, lst) {
  return lst.filter(func);
}
function keyDownHandler(ev) {
  checkArrowKeys(ev);
}
function keyhandler(ev) {
  if (ev.key == 'Enter') { }
  else if (ev.key == 'Escape') { close_popup(); }
}
function keyUpHandler(ev) {
  checkControlKey(ev);
}
function kriegTest00(game) {
  game.load({ pl1: { hand: ['TH', 'KH'] }, pl2: { hand: ['9C', 'QC'] } }); game.deck.sort(); game.print_state();
  for (let i = 0; i < 2; i++) { game.make_random_move(); game.make_random_move(); game.print_state(); if (game.is_out_of_cards()) { console.log('game over!'); break; } }
}
function kriegTest00UI() {
  setBackgroundColor(null, 'random');
  clearElement(dTable)
  let back = new GKriegBack();
  back.load({ pl1: { name: 'felix', hand: ['TH', 'KH'] }, pl2: { name: 'tom', hand: ['9C', 'QC'] } }); back.deck.sort(); back.print_state();
  let front = new GKriegFront(130, dTable);
  front.presentState(back.get_state(), dTable);
  mLinebreak(dTable, 50);
  mButton('Move!', () => kriegTest00UI_engine(back, front), dTable, { fz: 28, matop: 10, rounding: 10, padding: 16, border: 8 }, ['buttonClass']);
}
function kriegTest00UI_engine(back, front) {
  if (back.is_out_of_cards()) { console.log('!!!!!!!!!!!!!!!!'); front.presentGameover(back.winner(), kriegTest00UI); return; }
  clearTable(dTable);
  back.make_random_moveX();
  back.make_random_moveX();
  back.print_state();
  front.presentState(back.get_state(), dTable);
  if (back.is_out_of_cards()) { console.log('game over!'); front.presentGameover(back.winner(), kriegTest00UI); return; }
  mLinebreak(dTable, 50);
  mButton('Move!', () => kriegTest00UI_engine(back, front), dTable, { fz: 28, matop: 10, rounding: 10, padding: 16, border: 8 }, ['buttonClass']);
}
function kriegTest01(game) {
  game.load({ pl1: { hand: ['TH', 'QH'] }, pl2: { hand: ['9C', 'KC'] } }); game.deck.sort();
  game.print_state();
  for (let i = 0; i < 8; i++) {
    game.make_random_moveX();
    game.print_state();
    if (game.is_out_of_cards()) { console.log('game over!'); break; }
  }
}
function kriegTest02(game) {
  game.load({ pl1: { hand: ['TH'], trick: [['2H']] }, pl2: { hand: ['9C', 'KC'] } }); game.deck.sort();
  game.print_state('start:');
  for (let i = 0; i < 12; i++) {
    game.make_random_move();
    game.print_state('move:');
    game.resolve();
    game.swap_turn();
    if (i % 2 == 0) game.print_state('after resolve:');
    if (game.is_out_of_cards()) { console.log('game over!'); break; }
  }
}
function kriegTest03(game) {
  game.load({ pl1: { hand: ['TH'], trick: [['2H']] }, pl2: { hand: ['9C'], trick: [['KC']] } }); game.deck.sort();
  game.print_state('start:');
  for (let i = 0; i < 10; i++) {
    game.make_random_move();
    game.print_state('move:');
    game.resolve();
    game.swap_turn();
    if (i % 2 == 1) game.print_state('after resolve:');
    if (game.is_out_of_cards()) { console.log('game over!'); break; }
  }
}
function kriegTest04(game) {
  game.load({ pl1: { name: 'felix', hand: ['TH'], trick: [['2H']] }, pl2: { name: 'max', hand: ['9C'], trick: [['2C']] } }); game.deck.sort();
  game.print_state('start:');
  for (let i = 0; i < 2; i++) {
    game.make_random_move();
    game.print_state('move:');
    console.log('turn', game.iturn)
    if (game.iturn == 1) {
      game.resolve();
      game.swap_turn();
      game.print_state('after resolve:');
    } else game.swap_turn();
    if (game.is_out_of_cards()) { console.log('game over! winner', game.winner().name); break; }
  }
}
function kriegTest05(game) {
  game.load();
  game.print_state('start:');
  for (let i = 0; i < 25; i++) {
    game.make_random_move();
    game.print_state('move:');
    console.log('turn', game.iturn)
    if (game.iturn == 1) {
      game.resolve();
      game.swap_turn();
      game.print_state('after resolve:');
    } else game.swap_turn();
    if (game.is_out_of_cards()) { console.log('game over! winner', game.winner().index); break; }
  }
}
function kriegTest06(game) {
  game.load();
  game.print_state('start:');
  let front = new GKriegFront(130, dTable);
  front.presentState(game.get_state(), dTable);
  return;
  for (let i = 0; i < 25; i++) {
    game.make_random_move();
    game.print_state('move:');
    console.log('turn', game.iturn)
    if (game.iturn == 1) {
      game.resolve();
      game.swap_turn();
      game.print_state('after resolve:');
    } else game.swap_turn();
    if (game.is_out_of_cards()) { console.log('game over! winner', game.winner().index); break; }
  }
}
function labelDiv(label, color, w, h) {
  let d = mDiv();
  let dText = mAppendText(d, label);
  dText.classList.add('truncate');
  dText.classList.add('centerCentered');
  mColor(d, color);
  mSize(d, w, h);
  return d;
}
function labelPrepper(val) { return `<b>${val.toUpperCase()}</b>`; }
function labelToggler(ev) {
  let id = evToClosestId(ev);
  let info = symbolDict[id.substring(1)];
  if (isLabelVisible(id)) maHideLabel(id, info); else maShowLabel(id, info);
  mBy('dummy').focus();
}
function landing() { if (isdef(DA.landing)) DA.landing(); }
function last(arr) {
  return arr.length > 0 ? arr[arr.length - 1] : null;
}
function last_elem_from_to(arr1, arr2) { arr2.push(arr1.pop()); }
function last_n_digits(number, n = 2) {
  return number % Math.pow(10, n);
}
function lastCond(arr, func) {
  if (nundef(arr)) return null;
  for (let i = arr.length - 1; i >= 0; i--) { let a = arr[i]; if (func(a)) return a; }
  return null;
}
function lastCondDict(dict, func) {
  let keys = Object.keys(dict);
  for (let i = keys.length - 1; i >= 0; i--) {
    if (func(dict[i])) return dict[i];
  }
  return null;
}
function lastCondDictPlusKey(dict, func) {
  let keys = Object.keys(dict);
  for (let i = keys.length - 1; i >= 0; i--) {
    let key = keys[i];
    if (func(dict[key])) return [key, dict[key]];
  }
  return null;
}
function lastCondX(ad, func, keysSorted) {
  if (nundef(ad)) return null;
  else if (isDict(ad)) {
    if (isdef(keysSorted)) {
      for (let i = keysSorted.length - 1; i >= 0; i--) {
        let k = keysSorted[i];
        let v = ad[k];
        if (func(v)) { if (nundef(v.key)) v.key = k; return v; }
      }
    } else {
      for (const k in ad) {
        let v = ad[k];
        if (func(v)) { if (nundef(v.key)) v.key = k; return v; }
      }
    }
  } else {
    for (let i = ad.length - 1; i >= 0; i--) { if (func(ad[i])) return ad[i]; }
  }
  return null;
}
function lastDescendantOfType(type, parent) {
  if (getTypeOf(parent) == type) return parent;
  let children = arrChildren(parent);
  if (isEmpty(children)) return null;
  for (const ch of children.reverse()) {
    let res = lastDescendantOfType(type, ch);
    if (res) return res;
  }
  return null;
}
function lastIndexOfAny(s, list, pos) {
  let min = -1;
  let match = null;
  for (const w of list) {
    let i = s.lastIndexOf(w, pos);
    if (i >= 0 && i > min) { min = i; match = w; }
  }
  return match ? [min, match] : [-1, null];
}
function lastOfLanguage(key, language) {
  let y = symbolDict[key];
  let w = y[language];
  let last = stringAfterLast(w, '|');
  return last.trim();
}
function lastStreakCorrect(items) {
  let n = G.incrementLevelOnPositiveStreak;
  let iFrom = items.length - 1;
  let iTo = iFrom - n;
  for (let i = iFrom; i > iTo; i--) {
    if (i < 0) return false;
    else if (!items[i].isCorrect) return false;
  }
  return true;
}
function lastStreakFalse(items) {
  let n = G.decrementLevelOnNegativeStreak;
  let iFrom = items.length - 1;
  let iTo = iFrom - n;
  for (let i = iFrom; i > iTo; i--) {
    if (i < 0) return false;
    else if (items[i].isCorrect) return false;
  }
  return true;
}
function lastWord(s) { return stringAfterLast(s, ' '); }
function layoutCardsOverlapping(mkHand, mkCardList) {
  let dHand = mkHand.elem;
  let cardContainer = mkHand.parts.body;
  let bds = getBounds(cardContainer);
  if (bds.height < 10) {
    console.log('>>')
  }
  let gap = 2;
  let hCard = mkHand.hCard;
  if (!PREFERRED_CARD_HEIGHT) PREFERRED_CARD_HEIGHT = hCard;
  let wCard = hCard * .7;
  mkCardList.map(x => mStyle(x.elem, { height: hCard, width: wCard, position: 'absolute' }, 'px'));
  let ovl = wCard / 4;
  let numCards = mkCardList.length;
  let wHand = (numCards - 1) * ovl + wCard + gap;
  cardContainer.style.setProperty('width', wHand + 'px');
  cardContainer.style.setProperty('position', 'relative');
  let x = gap; let y = gap;
  for (const card of mkCardList) {
    card.setPos(x, y);
    x += ovl;
  }
  let iz = 10;
  for (const card of mkCardList) {
    card.loc = mkHand.id;
    card.attach('body');
    card.zIndex = card.elem.style.zIndex = iz;
    iz += 1;
    mkMan.setDone(card.oid);
  }
}
function layoutFlex(elist, dGrid, containerStyles, { rows, cols, isInline = false } = {}) {
  console.log(elist, elist.length)
  let dims = calcRowsCols(elist.length, rows, cols);
  console.log('dims', dims);
  let parentStyle = jsCopy(containerStyles);
  if (containerStyles.orientation == 'v') {
    parentStyle['writing-mode'] = 'vertical-lr';
  }
  parentStyle.display = 'flex';
  parentStyle.flex = '0 0 auto';
  parentStyle['flex-wrap'] = 'wrap';
  mStyleX(dGrid, parentStyle);
  let b = getRect(dGrid);
  return { w: b.w, h: b.h };
}
function layoutGrid(elist, dGrid, containerStyles, { rows, cols, isInline = false } = {}) {
  console.log('layoutGrid in _legacy!')
  let dims = calcRowsCols(elist.length, rows, cols);
  let parentStyle = jsCopy(containerStyles);
  parentStyle.display = isInline ? 'inline-grid' : 'grid';
  parentStyle['grid-template-columns'] = `repeat(${dims.cols}, auto)`;
  parentStyle['box-sizing'] = 'border-box';
  mStyleX(dGrid, parentStyle);
  let b = getRect(dGrid);
  return { w: b.w, h: b.h };
}
function layoutGridInfo(gContainer, fields, corners, edges, fw, fh) {
  for (const [id, f] of Object.entries(fields)) {
    gContainer.appendChild(f.ui);
    gPos(f.ui, fw * f.info.x, fh * f.info.y);
  }
  for (const [id, f] of Object.entries(edges)) {
    agLine(f.ui, f.info.x1 * fw, f.info.y1 * fw, f.info.x2 * fw, f.info.y2 * fw);
    gContainer.appendChild(f.ui);
  }
  for (const [id, f] of Object.entries(corners)) {
    gContainer.appendChild(f.ui);
    gPos(f.ui, fw * f.info.x, fh * f.info.y);
  }
}
function layoutHand(n) {
  if (isdef(n.params.overlap) && n.children.length > 1) {
    let cards = n.children.map(x => x.ui);
    let clast = arrLast(cards);
    let b = getBounds(clast);
    let wIs = b.width;
    let overlap = firstNumber(n.params.overlap);
    let sOverlap = '' + overlap;
    let unit = stringAfter(n.params.overlap, sOverlap);
    let wSoll = 0;
    if (unit == '%') {
      overlap /= 100;
      wSoll = wIs - wIs * overlap;
    } else { wSoll = wIs - overlap; }
    let wTotal = wIs + wSoll * (cards.length - 1);
    n.ui.style.maxWidth = '' + (wTotal + 2) + 'px';
  }
}
function layoutRow(uis, area, w, h, gap) {
  if (isEmpty(uis)) return [0, 0];
  let x = y = gap;
  uis.map(d => {
    mAppend(area, d);
    mPos(d, x, y);
    x += w + gap;
  });
  return [x, y + h + gap];
}
function layRow(olist, area, size = 50, gap = 4) {
  let res = [];
  let w = size, x = gap;
  olist.map(o => {
    let d = showPictoDiv(o.key, area, o.color, x, gap, w);
    res.push(d);
    x += w + gap;
  });
  return res;
}
function leaf_draw(o) {
  let [x, y] = [o.p.x, o.p.y];
  let [w, h] = [o.len * 1.5, o.len];
  cEllipse(x, y, w, h, { bg: o.color }, o.angle);
}
function length_of_each_array(arr) {
  let res = []
  for (const a of arr) {
    res.push(a.length);
  }
  return res.sort((a, b) => b - a);
}
function lerp(a, b, t) { return a + (b - a) * t; }
function lerpoint(i1, i2, frac = .5) {
  let o = { draw: i1.draw, update: i1.update };
  addKeys(i1, o);
  let pos = lerpos(i1, i2, frac);
  o.x = pos.x; o.y = pos.y;
  o.color = colorMix(i1.color, i2.color, frac * 100);
  if (isdef(i1.label)) o.label = `${(o.x / i1.ppp).toFixed(1)},${(o.y / i1.ppp).toFixed(1)}`;
  return o;
}
function lerpos(i1, i2, frac = .5) { return { x: lerp(i1.x, i2.x, frac), y: lerp(i1.y, i2.y, frac) }; }
function lettersToArray(s) { return toLetterList(s); }
function levDist(s, t) {
  var d = [];
  var n = s.length;
  var m = t.length;
  if (n == 0) return m;
  if (m == 0) return n;
  for (var i = n; i >= 0; i--) d[i] = [];
  for (var i = n; i >= 0; i--) d[i][0] = i;
  for (var j = m; j >= 0; j--) d[0][j] = j;
  for (var i = 1; i <= n; i++) {
    var s_i = s.charAt(i - 1);
    for (var j = 1; j <= m; j++) {
      if (i == j && d[i][j] > 4) return n;
      var t_j = t.charAt(j - 1);
      var cost = (s_i == t_j) ? 0 : 1;
      var mi = d[i - 1][j] + 1;
      var b = d[i][j - 1] + 1;
      var c = d[i - 1][j - 1] + cost;
      if (b < mi) mi = b;
      if (c < mi) mi = c;
      d[i][j] = mi;
      if (i > 1 && j > 1 && s_i == t.charAt(j - 2) && s.charAt(i - 2) == t_j) {
        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
      }
    }
  }
  return d[n][m];
}
function levelML() {
  let levelInfo = LevelsML[currentLevel];
  MaxNumTrials = levelInfo.MaxNumTrials;
  MaxWordLength = levelInfo.MaxWordLength;
  MinWordLength = levelInfo.MinWordLength;
  setKeys();
  NumPics = levelInfo.NumPics;
  NumLabels = levelInfo.NumLabels;
  NumMissingLetters = levelInfo.NumMissingLetters;
  MaxPosMissing = levelInfo.MaxPosMissing;
}
function levelSP() {
  let levelInfo = LevelsSP[currentLevel];
  MaxNumTrials = levelInfo.MaxNumTrials;
  MaxWordLength = levelInfo.MaxWordLength;
  MinWordLength = levelInfo.MinWordLength;
  setKeys(currentCategories, false, x => lastOfLanguage(x, currentLanguage), true, true);
  NumPics = levelInfo.NumPics;
  NumLabels = levelInfo.NumLabels;
}
function levelSPA() {
  let levelInfo = LevelsSPA[currentLevel];
  MaxNumTrials = levelInfo.MaxNumTrials;
  MaxWordLength = levelInfo.MaxWordLength;
  MinWordLength = levelInfo.MinWordLength;
  setKeys(currentCategories, true, (k) => lastOfLanguage(k, currentLanguage));
  boundary = currentKeys.length - 1;
  NextPictureIndex = 0;
  NumPics = levelInfo.NumPics;
  NumLabels = levelInfo.NumLabels;
}
function levelStep10() {
  mClass(document.body, 'aniFadeOutIn');
  hide('dLevelComplete');
  setTimeout(levelStep11, 500);
}
function levelStep11() {
  clearTable();
  setTimeout(levelStep12, 500);
}
function levelStep12() {
  addBadge(dLeiste, currentLevel);
  hide('dLevelComplete');
  clearTable();
  setTimeout(playRubberBandSound, 500);
  setBackgroundColor();
  showLevel();
  setTimeout(levelStep13, 2000);
}
function levelStep13() {
  mRemoveClass(document.body, 'aniFadeOutIn');
  proceedIfNotStepByStep();
}
function levelTC() {
  let levelInfo = LevelsTC[currentLevel];
  MaxNumTrials = levelInfo.MaxNumTrials;
  MaxWordLength = levelInfo.MaxWordLength;
  MinWordLength = levelInfo.MinWordLength;
  setKeys(['life'], true);
  NumPics = levelInfo.NumPics;
  NumLabels = levelInfo.NumLabels;
  NumColors = levelInfo.NumColors;
}
function levelTP() {
  let levelInfo = LevelsTP[currentLevel];
  MaxNumTrials = levelInfo.MaxNumTrials;
  MaxWordLength = levelInfo.MaxWordLength;
  MinWordLength = levelInfo.MinWordLength;
  setKeys();
  NumPics = levelInfo.NumPics;
  NumLabels = levelInfo.NumLabels;
}
function levelWP() {
  let levelInfo = LevelsWP[currentLevel];
  MaxNumTrials = levelInfo.MaxNumTrials;
  MaxWordLength = levelInfo.MaxWordLength;
  MinWordLength = levelInfo.MinWordLength;
  setKeys();
  NumPics = levelInfo.NumPics;
  NumLabels = levelInfo.NumLabels;
}
function lGrid(n, R) {
  resizeBoard(n, R);
  for (const uidMember of n.children) {
    let tile = R.uiNodes[uidMember];
    if (nundef(tile.children)) continue;
    wrapLayoutPosition(n, tile, R);
  }
  return { w: n.wTotal, h: n.hTotal };
}
function lHand(n, R) { return handLayout(n, R) }
function lighterColor(r, g, b) {
  let hsv = rgbToHsv(r, g, b);
  testHelpers(hsv);
  let h = hsv.h;
  let s = hsv.s;
  let v = hsv.v * 1.5;
  let hsl = hsvToHsl(h, s, v);
  h = hsl.h;
  s = hsl.s * 100;
  let l = hsl.l * 100;
  testHelpers('hsl:', h, s, l);
  return hslToHslaString(h, s, l);
}
function LineMatch(BookLine, gameline) {
  for (var len = 0; len < gameline.length; ++len) {
    if (len >= BookLine.length) { return BOOL.FALSE; }
    if (gameline[len] != BookLine[len]) { return BOOL.FALSE; }
  }
  return BOOL.TRUE;
}
function lineStyleFunction(feature, resolution) {
  return new Style({
    stroke: new Stroke({
      color: 'green',
      width: 2,
    }),
    text: createTextStyle(feature, resolution, myDom.lines),
  });
}
function lineupDecks(msDecks, deckArea) {
  let x = 0;
  let ysign = 1;
  let yfactor = 0;
  let yheight = 140;
  let y = yfactor * yheight * ysign;
  let areaCenter = { x: deckArea.w / 2, y: deckArea.h / 2 };
  let topLeftOffset = { x: areaCenter.x - 78 / 2, y: areaCenter.y - 110 / 2 };
  for (const mobj of msDecks) {
    mobj.attach();
    mobj.setPos(x + topLeftOffset.x, y + topLeftOffset.y);
    if (ysign > 0) { yfactor += 1; }
    ysign = -ysign;
    y = yfactor * yheight * ysign;
  }
}
function linkElement(s) {
  let el = document.createElement('div');
  el.style.backgroundColor = 'dimgray';
  el.innerHTML = s;
  el.onmouseenter = () => highlightContentIds(el);
  el.onmouseleave = () => unhighlightContentIds(el);
  return el;
}
function linkObjects(id, oid) {
  _addRelatives(id, oid);
  listKey(id2oids, id, oid);
  listKey(oid2ids, oid, id);
  //#region testcode
  //#endregion
}
function list2dict(arr, keyprop = 'id', uniqueKeys = true) {
  let di = {};
  for (const a of arr) {
    if (uniqueKeys) lookupSet(di, [a[keyprop]], a);
    else lookupAddToList(di, [a[keyprop]], a);
  }
  return di;
}
function liste(areaName, oSpec, oid, o) {
  let [num, or, split, bg, fg, id, panels, parent] = getParams(areaName, oSpec, oid);
  parent.style.display = 'inline-grid';
  return parent;
}
function listFromString(s) {
  let words = s.split(',');
  return words.map(x => x.replace('"', '').trim());
}
function listKey(d, key, val, uniqueValues = true) {
  if (nundef(d[key])) { d[key] = []; }
  if (uniqueValues) { addIf(d[key], val); } else { d[key].push(val); }
  return d[key];
}
function listKeys(dict, keys, val, uniqueValues = true) {
  let d = dict;
  keysCopy = jsCopy(keys);
  let lastKey = keysCopy.pop();
  for (const k of keysCopy) {
    if (!(k in d)) {
      d[k] = {};
    }
    d = d[k];
  }
  return listKey(d, lastKey, val, uniqueValues);
}
function listToString(lst) { return isEmpty(lst) ? lst : lst.join(' '); }
async function load_all() {
  let o = await route_path_yaml_dict('../y/page.yaml');
  for (const item of o) { add_edit(item.x, item.y - 41, item.text); }
}
function load_assets(obj) {
  Config = jsyaml.load(obj.config);
  Syms = jsyaml.load(obj.syms);
  SymKeys = Object.keys(Syms);
  ByGroupSubgroup = jsyaml.load(obj.symGSG);
  C52 = jsyaml.load(obj.c52);
  Cinno = jsyaml.load(obj.cinno);
  Info = jsyaml.load(obj.info);
  Sayings = jsyaml.load(obj.sayings);
  create_card_assets_c52();
  KeySets = getKeySets();
  assertion(isdef(Config), 'NO Config!!!!!!!!!!!!!!!!!!!!!!!!');
}
function load_assets_direct(obj) {
  Config = jsyaml.load(obj.config);
  Syms = jsyaml.load(obj.syms);
  SymKeys = Object.keys(Syms);
  ByGroupSubgroup = jsyaml.load(obj.symGSG);
  Info = jsyaml.load(obj.info);
  KeySets = getKeySets();
  console.assert(isdef(Config), 'NO Config!!!!!!!!!!!!!!!!!!!!!!!!');
}
async function load_assets_fetch(basepath, baseminpath) {
  let path = basepath + 'assets/';
  Config = await route_path_yaml_dict(baseminpath + 'config.yaml');
  DB = await route_path_yaml_dict(basepath + 'DB.yaml');
  Syms = await route_path_yaml_dict(path + 'allSyms.yaml');
  SymKeys = Object.keys(Syms);
  ByGroupSubgroup = await route_path_yaml_dict(path + 'symGSG.yaml');
  C52 = await route_path_yaml_dict(path + 'c52.yaml');
  Cinno = await route_path_yaml_dict(path + 'fe/inno.yaml');
  Info = await route_path_yaml_dict(path + 'lists/info.yaml');
  create_card_assets_c52();
  KeySets = getKeySets();
  console.assert(isdef(Config), 'NO Config!!!!!!!!!!!!!!!!!!!!!!!!');
  return { users: dict2list(DB.users, 'name'), games: dict2list(Config.games, 'name'), tables: [] };
}
function load_coassets(obj) {
  Config = jsyaml.load(obj.config);
  Syms = jsyaml.load(obj.syms);
  SymKeys = Object.keys(Syms);
  ByGroupSubgroup = jsyaml.load(obj.symGSG);
  Info = jsyaml.load(obj.info);
  KeySets = getKeySets();
  console.assert(isdef(Config), 'NO Config!!!!!!!!!!!!!!!!!!!!!!!!');
}
async function load_codebase(paths, preserveRegionNames = false) {
  if (nundef(paths)) {
    paths = ['basemin', 'board', 'cards', 'gamehelpers', 'select'];
    paths = paths.map(f => `../basejs/${f}.js`);
  }
  let superdi = { cla: {}, func: {}, const: {}, var: {} };
  for (const f of paths) {
    console.log('...processing file', f);
    let current_file = stringBefore(stringAfterLast(f, '/'), '.');
    let base = await route_path_text(f);
    let res = parseCodefile(base, current_file, preserveRegionNames, {}, superdi);
  }
  return superdi;
}
async function load_config(port = 3000, apps = true, tables = false) {
  Config = await route_path_yaml_dict('../y/config.yaml');
  let server = 'http:/' + '/localhost:' + port;
  if (apps) {
    let files = await route_path_json(server + '/files?dir=appdata');
    console.log('apps', files)
    for (const f of files) {
      let appname = stringBefore(f, '.');
      Config.apps[appname].data = await route_path_yaml_dict(`../y/appdata/${appname}.yaml`);
    }
  }
  if (tables) {
    let files = await route_path_json(server + '/files?dir=tables');
    console.log('tables', files)
    Tables = {};
    for (const f of files) {
      let id = stringBefore(f, '.');
      Tables[id] = await route_path_yaml_dict(`../y/tables/${id}.yaml`);
    }
  }
}
async function load_config_fast(applist = [], tablelist = []) {
  Config = await route_path_yaml_dict('../y/config.yaml');
  for (const appname of applist) {
    Config.apps[appname].data = await route_path_yaml_dict(`../y/appdata/${appname}.yaml`);
    Config.apps[appname].name = appname;
  }
  Tables = {};
  for (const tableid of tablelist) {
    Tables[tableid] = await route_path_yaml_dict(`../y/tables/${tableid}.yaml`);
    Tables[tableid].name = tableid;
  }
}
async function load_config_new() {
  Config = await route_path_yaml_dict('../y/config.yaml');
  let data = await route_path_yaml_dict('../y/appdata.yaml');
  for (const k in data) {
    Config.apps[k].data = data[k];
  }
}
async function load_db() { DB = await route_path_yaml_dict('../y/db.yaml'); Config = DB; }
async function load_syms(path) {
  if (nundef(path)) path = '../base/assets/';
  Syms = await route_path_yaml_dict(path + 'allSyms.yaml');
  SymKeys = Object.keys(Syms);
  ByGroupSubgroup = await route_path_yaml_dict(path + 'symGSG.yaml');
  KeySets = getKeySets();
  Info = await route_path_yaml_dict(path + 'lists/info.yaml');
  C52 = await route_path_yaml_dict(path + 'c52.yaml');
  create_card_assets_c52();
  assertion(Syms, 'Syms undefined!');
}
function load_user(name, display_ui = true) {
  if (nundef(name)) name = 'guest';
  let udata = lookup(DB, ['users', name]);
  if (!udata) udata = add_new_user({ name: name, color: randomColor(), motto: random_motto(), image: false, games: {}, tables: {} });
  Session.cur_user = name;
  if (!is_admin(name)) localStorage.setItem('user', name);
  if (display_ui) show_user(udata);
  if (name == 'mimi') show('dAdminButtons'); else hide('dAdminButtons');
  return udata;
}
function load_yt_in_iframe(dParent) {
  var div = document.createElement('iframe');
  div.id = 'iframe1';
  mStyle(div, { w: 500, h: 300 });
  mAppend(dParent, div);
  div.src = "https://www.youtube.com/embed/3pNpHZ1yv3I"; //YES!
  //iDiv.src = "https://www.youtube.com/embed/3pNpHZ1yv3I?autoplay=1";
}
async function loadAllGames_dep() {
  if (allGames) return;
  allGames = vidCache_dep.load('allGames');
  if (!allGames) {
    allGames = await route_allGames();
    console.log(allGames)
  }
}
async function loadAsset() {
  let response = await fetch('/frontend/static/rsg/assets/gameIconCodes.yml');
  console.log(response);
}
async function loadAssets() {
  vidCache = new LazyCache(!USE_LOCAL_STORAGE);
  testCardsC = await vidCache.load('testCards', async () => await route_rsg_asset('testCards', 'yaml'));
  testCards = vidCache.asDict('testCards');
  iconCharsC = await vidCache.load('iconChars', route_iconChars);
  iconChars = vidCache.asDict('iconChars');
  allGamesC = await vidCache.load('allGames', route_allGames);
  allGames = vidCache.asDict('allGames');
  playerConfig = stubPlayerConfig(allGames);
}
async function loadassets() {
  C52 = await localOrRoute('C52', '../base/assets/c52.yaml');
  symbolDict = Syms = await localOrRoute('syms', '../base/assets/allSyms.yaml');
  SymKeys = Object.keys(Syms);
  ByGroupSubgroup = await localOrRoute('gsg', '../base/assets/symGSG.yaml');
  WordP = await route_path_yaml_dict('../base/assets/math/allWP.yaml');
  DB = await route_path_yaml_dict('../DB.yaml');
  start();
}
async function loadAssetsSIMA(assetsPath) {
  timit.show('assets*')
  c52 = await localOrRoute('c52', assetsPath + 'c52_blackBorder.yaml');
  cinno = await localOrRoute('cinno', assetsPath + 'fe/inno.yaml');
  symbolDict = await localOrRoute('symbolDict', assetsPath + 'symbolDict.yaml');
  symbolKeys = Object.keys(symbolDict);
  symbolList = dict2list(symbolDict);
  ensureSymBySet(); makeHigherOrderGroups();
  svgDict = await localOrRoute('svgDict', assetsPath + 'svgDict.yaml');
  svgKeys = Object.keys(svgDict);
  svgList = dict2list(svgDict);
  Syms = await localOrRoute('syms', assetsPath + 'syms.yaml');
  SymKeys = Object.keys(Syms);
  timit.show('assets done')
}
async function loadAsText(url) {
  let f = await fetch(url);
  let txt = await f.text();
  return txt;
}
function loadAutoState() {
  if ('auto' in HistoryOfStates) Socket.emit('state', HistoryOfStates.auto);
}
async function loadBasicAssets(assetsPath) {
  c52 = await localOrRoute('c52', assetsPath + 'c52_blackBorder.yaml');
  cinno = await localOrRoute('cinno', assetsPath + 'fe/inno.yaml');
  symbolDict = await localOrRoute('symbolDict', assetsPath + 'symbolDict.yaml');
  symbolKeys = Object.keys(symbolDict);
  symbolList = dict2list(symbolDict);
  ensureSymBySet(); makeHigherOrderGroups();
  svgDict = await localOrRoute('svgDict', assetsPath + 'svgDict.yaml');
  svgKeys = Object.keys(svgDict);
  svgList = dict2list(svgDict);
}
async function loadBestKeys() {
  BestKeySets = await loadYamlDict('/assets/speech/keysets.yaml');
  BestKeysD = await loadYamlDict('/assets/speech/bestKeysD.yaml');
  BestKeysE = await loadYamlDict('/assets/speech/bestKeysE.yaml');
  for (const e of BestKeysD) {
    let info = symbolDict[e.k];
    info.bestD = e.r;
    info.bestDConf = e.c;
  }
  for (const e of BestKeysE) {
    let info = symbolDict[e.k];
    info.bestE = e.r;
    info.bestEConf = e.c;
  }
  for (const setname in BestKeySets) {
    for (const k of BestKeySets[setname]) {
      let info = symbolDict[k];
      if (nundef(info.bestE)) info.bestE = lastOfLanguage(k, 'E');
      if (nundef(info.bestD)) info.bestD = lastOfLanguage(k, 'D');
      info[setname] = { E: info.bestE, D: info.bestD };
    }
  }
}
function loadBoardImage(dOneBoard, s, b, scale, useCornerColor = false) {
  let boardFilename = s.boardFilename;
  if (boardFilename == 'none') { return; }
  let path = getBoardImagePath(boardFilename);
  var img = mCreate('img');
  img.onload = ev => {
    let sz = s.naturalImageSize = b.imgSize = { w: img.naturalWidth, h: img.naturalHeight };
    let szi = s.backgroundSize;
    if (szi == 'initial' && scale != 1) szi = getScaledSizeCss(sz, scale);
    b.dOuter.style.backgroundImage = `url(${img.src})`;
    mStyleX(b.dOuter, { 'background-size': szi, 'background-repeat': 'no-repeat', 'background-position': 'center center' });
    let [wb, hb] = [Math.max(sz.w * scale, b.wNeeded), Math.max(sz.h * scale, b.hNeeded)];
    mStyleX(b.dOuter, { wmin: wb, hmin: hb });
    if (useCornerColor) setLinearBackground(b.d0, s.baseColor, 10);
    b.img = img;
  }
  img.src = path;
}
async function loadCode() {
  if (TESTING && !CODE_VERSION) return;
  let url = TESTING && !USE_NON_TESTING_DATA ? TEST_PATH + GAME + '/code' + CODE_VERSION + '.js'
    : '/games/' + GAME + '/_rsg/' + GAME + VERSION + '.js';
  let loader = new ScriptLoader();
  await loader.load(SERVER + url);
  if (TESTING) userCodeC = await vidCache.load('userCode', async () => await route_path_asText_dict(url), true, false);
  else userCodeC = await vidCache.load('userCode', async () => await route_userCode(GAME, GAME + VERSION), !CACHE_CODE, CACHE_CODE);
  userCode = vidCache.asDict('userCode');
  let d = mBy('OLDCODE');
  if (d && SHOW_CODE) { d.innerHTML = '<pre>' + userCode.asText + '</pre>'; }
}
function loadCode_dep(text) {
  if (isdef(text)) text = text.trim();
  if (isEmpty(text)) {
    return;
  }
  var scriptTag = document.createElement("script");
  scriptTag.onload = () => console.log('code loaded.....');
  scriptTag.setAttribute("type", "text/javascript");
  scriptTag.innerHTML = text;
  document.getElementsByTagName("body")[0].appendChild(scriptTag);
}
function loadCode0(text, codeToRunWhenScriptLoaded = null, callback = null) {
  if (isdef(text)) text = text.trim();
  if (isEmpty(text)) {
    console.log('code is empty!!! no script loaded!');
    if (callback) callback();
    return;
  }
  var scriptTag = document.createElement("script");
  scriptTag.setAttribute("type", "text/javascript");
  scriptTag.text = callback ? [text, codeToRunWhenScriptLoaded].join('\n') : text;
  document.getElementsByTagName("body")[0].appendChild(scriptTag);
}
async function loadCodebase(dir) {
  let path_js=isdef(dir)?(dir+'/z_all.js'):'../allcode.js';
  dir = isdef(dir)?dir:'../basejs';
  let text = CODE.text = await route_path_text(path_js);
  let keysSorted = [];
  let lines = text.split('\r\n');
  for (const l of lines) {
    if (['var', 'const', 'cla', 'func'].some(x => l.startsWith(x))) {
      let key = firstWordAfter(l, ' ', true);
      keysSorted.push(key);
    }
  }
  CODE.keysSorted = keysSorted;
  CODE.di = await route_path_yaml_dict(dir+'/z_all.yaml');
  CODE.justcode = await route_path_yaml_dict(dir+'/z_allcode.yaml');
  CODE.codelist=dict2list(CODE.justcode,'key');
  CODE.history = await route_path_yaml_dict(dir+'/z_allhistory.yaml');
  let keys = {};
  for (const k in CODE.di) { for (const k1 in CODE.di[k]) keys[k1] = CODE.di[k][k1]; }
  CODE.all = keys;
  CODE.keylist = Object.keys(keys)
}
async function loadCorrectWords() {
  CorrectKeysByLanguage = { E: [], EB: [], D: [] };
  CorrectByKey = {};
  let speechZira = await loadYamlDict('/assets/speech/speechZira.yaml');
  for (const k in speechZira) {
    let e = lookup(speechZira, [k, 'E', 'zira']);
    if (e && e.correct) {
      let c = Math.round(e.conf * 100);
      lookupSet(CorrectByKey, [k, 'E'], { r: e.req, c: c });
      addIf(CorrectKeysByLanguage.E, k);
    }
  }
  let speechBritish = await loadYamlDict('/assets/speech/speechBritish.yaml');
  for (const k in speechBritish) {
    let e = lookup(speechBritish, [k, 'E', 'ukMale']);
    if (e && e.correct) {
      let c = Math.round(e.conf * 100);
      lookupSet(CorrectByKey, [k, 'EB'], { r: e.req, c: c });
      addIf(CorrectKeysByLanguage.EB, k);
    }
  }
  let speechDeutsch = await loadYamlDict('/assets/speech/speechDeutsch.yaml');
  for (const k in speechDeutsch) {
    let e = lookup(speechDeutsch, [k, 'D', 'deutsch']);
    if (e && e.correct) {
      let c = Math.round(e.conf * 100);
      lookupSet(CorrectByKey, [k, 'D'], { r: e.req, c: c });
      addIf(CorrectKeysByLanguage.D, k);
    }
  }
}
async function loadCorrectWords_dep() {
  CorrectWords = await loadYamlDict('/assets/correctWordsX.yaml');
  CorrectWordsCorrect = { E: {}, D: {} };
  CorrectWordsExact = { E: {}, D: {} };
  CorrectWordsFailed = { E: {}, D: {} };
  if (isdef(CorrectWords) && isdef(CorrectWords.data)) {
    for (const cwentry of CorrectWords.data) {
      let key = cwentry.key;
      for (const lang of ['E', 'D']) {
        let cw = cwentry[lang];
        if (cw.isCorrect) {
          if (cw.answer == cw.req && !(cw.danger == true)) CorrectWordsExact[lang][key] = cw;
          else CorrectWordsCorrect[lang][key] = cw;
        } else CorrectWordsFailed[lang][key] = cw;
      }
    }
  }
}
function loader_off() { let d = mBy('loader_holder'); if (isdef(d)) d.className = 'loader_off'; }
function loader_on() { let d = mBy('loader_holder'); if (isdef(d)) d.className = 'loader_on'; }
function loadExerciser(dParent, row, col) {
  loadPic('exercises', 100, 100, dParent, { row: row, col: col, scale: 1.5 }, 'gif');
}
function loadGame(id) {
  if (nundef(id)) id = localStorage.getItem('game');
  if (nundef(id)) id = Object.keys(DB.games)[0];
  G = lookup(DB, ['games', id]);
  G.color = getColorDictColor(G.color);
  G.id = Gamename = id;
  updateGamenameUi(id, G.color);
}
async function loadGameInfo(useAllGamesStub = true) {
  if (useAllGamesStub) {
    allGames = {
      ttt: {
        name: 'TicTacToe',
        long_name: 'Tic-Tac-Toe',
        short_name: 'ttt',
        num_players: [2],
        player_names: ['Player1', 'Player2'],
      },
      s1: {
        name: 's1',
        long_name: 's1',
        short_name: 's1',
        num_players: [2, 3, 4, 5],
        player_names: ['Player1', 'Player2', 'Player3', 'Player4', 'Player5'],
      },
      starter: {
        name: 'Starter',
        long_name: 'Starter',
        short_name: 'starter',
        num_players: [2],
        player_names: ['Player1', 'Player2'],
      },
      catan: {
        name: 'Catan',
        long_name: 'The Settlers of Catan',
        short_name: 'catan',
        num_players: [3, 4],
        player_names: ['White', 'Red', 'Blue', 'Orange'],
      },
      aristocracy: {
        name: 'Aristocracy',
        long_name: 'Aristocracy',
        short_name: 'aristocracy',
        num_players: [2, 3, 4, 5],
        player_names: ['Player1', 'Player2', 'Player3', 'Player4', 'Player5'],
      }
    };
  } else {
    allGamesC = await vidCache.load('allGames', route_allGames);
    allGames = vidCache.asDict('allGames');
  }
  playerConfig = stubPlayerConfig(allGames);
}
async function loadGerman(justNouns = false) {
  let root = justNouns ? 'Nouns' : 'Dict';
  let ed = await route_path_yaml_dict('../assets/speech/ed' + root + '.yaml');
  let de = await route_path_yaml_dict('../assets/speech/de' + root + '.yaml');
  return [ed, de];
}
function loadHistoryExp() {
  let hist = localStorage.getItem('history');
  if (isdef(hist)) {
    HistoryOfStates = JSON.parse(hist);
    console.log('history loaded successfully...', HistoryOfStates);
  } else {
    console.log('no history found!!!');
  }
}
async function loadIcon_dep(key) {
  if (!iconChars) iconChars = await route_iconChars();
  return iconChars[key];
}
function loadIconChars(callbacks = []) {
  loadYML('/frontend/static/rsg/assets/gameIconCodes.yml', dga => {
    gaChars = dga;
    loadYML('/frontend/static/rsg/assets/faIconCodes.yml', dfa => {
      faChars = dfa;
      iconChars = {};
      faKeys = [];
      for (const k in faChars) {
        iconChars[k] = faChars[k];
      }
      for (const k in gaChars) {
        if (isdef(faChars[k])) faKeys.push(k);
        iconChars[k] = gaChars[k];
      }
      timit.showTime('loaded icons codes')
      if (!isEmpty(callbacks)) callbacks[0](arrFromIndex(callbacks, 1));
    });
  });
}
function loadIcons(callback) {
  let faChars, gaChars;
  loadYML('/_lib/assets/icons/gameIconCodes.yml', dga => {
    gaChars = dga;
    loadYML('/_lib/assets/icons/faIconCodes.yml', dfa => {
      faChars = dfa;
      iconChars = {};
      for (const k in faChars) {
        iconChars[k] = faChars[k];
      }
      for (const k in gaChars) {
        iconChars[k] = gaChars[k];
      }
      timit.showTime('loaded icons codes');
      callback();
    });
  });
}
async function loadInitialServerData(unameStarts) {
  let initialPath = GAME + (USE_MAX_PLAYER_NUM ? '_max' : '');
  _syncUsernameOfSender(unameStarts);
  if (TESTING) {
    let url = SERVERDATA_PATH + '.yaml';
    serverDataC = initialDataC[GAME] = await vidCache.load('_initial_' + initialPath, async () => await route_path_yaml_dict(url), true, false);
  } else {
    serverDataC = initialDataC[GAME] = await vidCache.load('_initial_' + initialPath, async () => await route_initGame(GAME, playerConfig[GAME], Username), !CACHE_INITDATA, CACHE_INITDATA);
  }
  serverData = vidCache.asDict('_initial_' + initialPath);
  return serverData;
}
async function loadInitialServerDatafe(unameStarts) {
  _syncUsernameOfSender(unameStarts);
  let url = SERVERDATA_PATH;
  serverDataC = initialDataC[GAME] = await vidCache.load('serverData', async () => await route_path_yaml_dict(url), true, false);
  serverData = vidCache.asDict('serverData');
  return serverData;
}
function loadJSON(path, callback) {
  //usage: https://stackoverflow.com/questions/48073151/read-local-json-file-into-variable
  var xobj = new XMLHttpRequest();
  xobj.overrideMimeType('application/json');
  xobj.open('GET', path, true);
  xobj.onreadystatechange = function () {
    if (xobj.readyState == 4 && xobj.status == '200') {
      callback(JSON.parse(xobj.responseText));
    }
  };
  xobj.send(null);
}
async function loadJsonDict(url) { return await route_path_json_dict(url); }
function loadObject(name) { return JSON.parse(localStorage.getItem(name)); }
function loadPic(filename, w, h, dParent, { x, y, row, col, scale } = {}, ext = 'jpg', dir = '../assets/images/postures/') {
  let dPic = mDiv(dParent);
  dPic.style.width = '' + w + 'px';
  dPic.style.height = '' + h + 'px';
  if (isdef(row)) row *= w;
  if (isdef(col)) col *= h;
  if (isdef(x)) col = x;
  if (isdef(y)) row = y;
  if (nundef(row)) row = 0;
  if (nundef(col)) col = 0;
  dPic.style.background = `url(${dir}${filename}.${ext}) -${col}px -${row}px`;
  if (isdef(scale)) dPic.style.transform = `scale(${scale})`;
}
function loadRandomExerciser(dParent) {
  mLinebreak(dParent, 75);
  loadExerciser(dParent, randomNumber(0, 5), randomNumber(0, 7));
  mLinebreak(dParent, 25);
}
function loadRandomExerciser2(dParent, i) {
  let w = 280;
  let h = 240;
  let filename = 'exercises2';
  let table = [[30, 30], [30, 260], [30, 480], [30, 730], [20, 940],
  [350, 30], [350, 245], [350, 450], [350, 650], [330, 890],
  [620, 0], [620, 245], [620, 460], [620, 700], [560, 920],
  [880, 0], [900, 245], [890, 460], [860, 700], [870, 920],
  [1150, 0], [1170, 320], [1150, 620], [1120, 900],
  [1350, 30], [1400, 330], [1380, 630], [1350, 890]
  ];
  if (nundef(i)) i = randomNumber(0, table.length - 1);
  i = i % table.length;
  let x = table[i][0];
  let y = table[i][1];
  if (i == 9) { w = 240; h = 280; }
  else if (i == 13) { w = 240; h = 200; }
  else if (i == 14) { w = 260; h = 260; }
  else if (i == 20 || i == 21 || i == 22) { w = 240; h = 260; }
  else if (i == 24) { w = 280; h = 280; }
  else if (i == 25) { w = 200; h = 290; }
  else if (i == 26) { w = 230; h = 260; }
  else if (i == 27) { w = 240; h = 250; }
  console.log('i' + i, x, y)
  loadPic(filename, w, h, dParent, { x: x, y: y }, 'gif');
}
function loadRandomTaeOrPosturePic(dpics) {
  let imgs = ['tae', 'posture'];
  mImage(`../assets/images/postures/${chooseRandom(imgs)}0${randomNumber(1, 8)}.jpg`, dpics, 200, 200);
}
function loadScript(path, callback) {
  var script = document.createElement('script');
  script.onload = function () {
    if (callback) callback(path);
  };
  script.src = path;
  document.head.appendChild(script);
}
async function loadServerDataForTestSeries(series) {
  let path = '/assetsTEST/' + series + '/server.yaml';
  await loadTestServerData(path);
  preProcessData();
  sData = makeDefaultPool(jsCopy(serverData));
  return sData;
}
async function loadSIMA(callback) {
  let url = SERVERURL;
  fetch(url, {
    method: 'GET',
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    },
  }).then(async data => {
    let sData = await data.json();
    DB = sData[0];
    if (CLEAR_LOCAL_STORAGE) localStorage.clear();
    await loadAssetsSIMA('../assets/');
    if (isdef(callback)) callback();
  });
}
async function loadSolutions(series) {
  let solFilename = 'sol';
  let sol = await loadJsonDict('/assetsTEST/' + series + '/' + solFilename + '.json');
  let sol1 = {};
  for (const k in sol) { sol1[firstNumber(k)] = sol[k]; }
  let solutions = sol1;
  return solutions;
}
async function loadSpec(path) {
  if (TESTING) {
    let url = DSPEC_PATH + '.yaml';
    defaultSpecC = await vidCache.load('defaultSpec', async () => await route_path_yaml_dict(url), true, false);
    url = (isdef(path) ? path : SPEC_PATH) + '.yaml';
    if (USE_NON_TESTING_DATA) url = '/games/' + GAME + '/_rsg/' + GAME + VERSION + '.yaml';
    userSpecC = await vidCache.load('userSpec', async () => await route_test_userSpec(url), true, false);
  } else {
    url = DSPEC_PATH + '.yaml';
    defaultSpecC = await vidCache.load('defaultSpec', async () => await route_path_yaml_dict(url), !CACHE_DEFAULTSPEC, CACHE_DEFAULTSPEC);
    userSpecC = await vidCache.load('userSpec', async () => await route_userSpec(GAME, GAME + VERSION), !CACHE_USERSPEC, CACHE_USERSPEC);
  }
  defaultSpec = vidCache.asDict('defaultSpec');
  userSpec = vidCache.asDict('userSpec');
  SPEC = deepmerge(defaultSpec, userSpec);
  DEFS = SPEC.defaults;
  delete SPEC.defaults;
  if (userSpec.layout_alias) { SPEC.areas = userSpec.layout_alias; }
  if (userSpec.areas) { SPEC.areas = userSpec.areas; }
  delete SPEC.layout_alias;
  delete SPEC.asText;
}
async function loadSpecAndCode() {
  let initialPath = GAME + (USE_MAX_PLAYER_NUM ? '_max' : '');
  if (TESTING) {
    let url = TEST_PATH + 'defaultSpec' + DSPEC_VERSION + '.yaml';
    defaultSpecC = await vidCache.load('defaultSpec', async () => await route_path_yaml_dict(url), true, false);
    url = TEST_PATH + GAME + '/uspec' + USPEC_VERSION + '.yaml';
    if (USE_NON_TESTING_DATA) url = '/games/' + GAME + '/_rsg/' + GAME + VERSION + '.yaml';
    userSpecC = await vidCache.load('userSpec', async () => await route_test_userSpec(url), true, false);
    url = TEST_PATH + GAME + '/code' + CODE_VERSION + '.js';
    if (USE_NON_TESTING_DATA) url = '/games/' + GAME + '/_rsg/' + GAME + VERSION + '.js';
    userCodeC = await vidCache.load('userCode', async () => await route_path_asText_dict(url), true, false);
    url = TEST_PATH + GAME + '/data' + SERVERDATA_VERSION + '_' + initialPath + '.yaml';
    serverDataC = initialDataC[GAME] = await vidCache.load('_initial_' + initialPath, async () => await route_path_yaml_dict(url), true, false);
    serverData = vidCache.asDict('_initial_' + initialPath);
  } else {
    url = TEST_PATH + 'defaultSpec' + DSPEC_VERSION + '.yaml';
    defaultSpecC = await vidCache.load('defaultSpec', async () => await route_path_yaml_dict(url), !CACHE_DEFAULTSPEC, CACHE_DEFAULTSPEC);
    userSpecC = await vidCache.load('userSpec', async () => await route_userSpec(GAME, GAME + VERSION), !CACHE_USERSPEC, CACHE_USERSPEC);
    let fname = userSpecC['CODE'];
    userCodeC = await vidCache.load('userCode', async () => await route_userCode(GAME, GAME + VERSION), !CACHE_CODE, CACHE_CODE);
    serverDataC = initialDataC[GAME] = await vidCache.load('_initial_' + initialPath, async () => await route_initGame(GAME, playerConfig[GAME], USERNAME), !CACHE_INITDATA, CACHE_INITDATA);
  }
  defaultSpec = vidCache.asDict('defaultSpec');
  userSpec = vidCache.asDict('userSpec');
  userCode = vidCache.asDict('userCode');
  loadCode0(userCode.asText, 'setUserSpecAndCode();', () => {
    setUserSpecAndCode();
  });
  serverData = vidCache.asDict('_initial_' + initialPath);
}
async function loadSpecfe() {
  let url = DSPEC_PATH + DSPEC_VERSION + '.yaml';
  defaultSpecC = await vidCache.load('defaultSpec', async () => await route_path_yaml_dict(url), true, false);
  url = SPEC_PATH;
  let staticSpecC = await vidCache.load('staticSpec', async () => await route_test_userSpec(url), true, false);
  defaultSpec = vidCache.asDict('defaultSpec');
  staticSpec = vidCache.asDict('staticSpec');
  SPEC = deepmerge(defaultSpec, staticSpec, { arrayMerge: overwriteMerge });
  delete SPEC.asText;
  let d = mBy('SPEC');
  if (d && SHOW_SPEC) { d.innerHTML = '<pre>' + jsonToYaml(SPEC) + '</pre>'; }
}
function loadStyle(href, callback) {
  let style = document.createElement('link');
  style.rel = href == 'favicon' ? 'shortcut icon' : 'stylesheet';
  style.onload = function () {
    if (callback) callback(href);
  };
  style.href = href;
  document.head.appendChild(style);
}
function loadTable(id) {
  if (nundef(id)) id = localStorage.getItem('table');
  if (nundef(id)) id = findTable(true);
  T = lookup(DB, ['tables', id]);
  Tablename = id;
  logTable();
  updateTablenameUi(id, G.color);
}
async function loadTestServerData(url) {
  let initial = 'testServerData';
  serverDataC = initialDataC[GAME] = await vidCache.load(initial, async () => await route_path_yaml_dict(url), true, false);
  serverData = vidCache.asDict(initial);
  return serverData;
}
function loadText(path, callback) {
  $.ajax({
    url: path,
    type: 'GET',
    success: response => {
      if (callback) {
        callback(response);
      }
    },
    error: err => {
      error(err);
    }
  });
  return 'ok';
}
function loadUrlToJSON(url, callback) { }
function loadUser(newUser) {
  cleanupOldGame();
  Username = isdef(newUser) ? newUser : localStorage.getItem('user');
  if (nundef(Username)) Username = DEFAULTUSERNAME;
  let uData = lookupSet(DB, ['users', Username]);
  if (!uData) {
    if (startsWith(newUser, 'test')) { uData = DB.users[Username] = jsCopy(DB.users.test0); uData.id = Username; }
    else { uData = DB.users[Username] = jsCopy(DB.users.guest0); uData.id = Username; }
  }
  U = DB.users[Username];
  let uiName = 'spUser';
  let dUser = mBy(uiName);
  if (nundef(dUser)) { dUser = editableUsernameUi(dLineTopLeft); dUser.id = uiName; }
  let game = !window.navigator.onLine && U.lastGame == 'gSayPic' ? 'gTouchPic' : U.lastGame;
  if (nundef(game)) game = U.avGames[0];
  setGame(game);
}
function loadUserCode(callbacks = []) {
  let fname = S.user.spec ? S.user.spec.CODE : null;
  if (nundef(fname)) {
    S.user.script = 'no code';
    if (!isEmpty(callbacks)) callbacks[0](arrFromIndex(callbacks, 1));
  } else {
    S.path.script = '/games/' + S.settings.game + '/_rsg/' + fname + '.js';
    loadScript(S.path.script, dScript => {
      loadText(S.path.script, code => {
        console.log('script.onload DOES WORK!!!!!!!!!!!!')
        S.user.script = code;
        if (!isEmpty(callbacks)) callbacks[0](arrFromIndex(callbacks, 1));
      });
    });
  }
}
function loadUserSpec(callbacks = []) {
  sendRoute('/get_UI_spec/' + GAME, d1 => {
    try {
      S.user.spec = JSON.parse(d1);
      sendRoute('/spec/' + GAME, d2 => {
        S.user.specText = d2;
        if (!isEmpty(callbacks)) callbacks[0](arrFromIndex(callbacks, 1));
      });
    } catch {
      S.user.spec = null;
      S.user.specText = 'null';
      if (!isEmpty(callbacks)) callbacks[0](arrFromIndex(callbacks, 1));
    }
  });
}
function loadWalker(dParent) { loadExerciser(dParent, 3, 2); }
async function loadYamlDict(url) { return await route_path_yaml_dict(url); }
function loadYML(path, callback) {
  res = undefined;
  $.get(path)
    .done(function (data) {
      var yml = jsyaml.load(data);
      var jsonString = JSON.stringify(data);
      var json = $.parseJSON(jsonString);
      callback(yml);
    });
}
function lobbyView() {
  //document.body.style.transform = null; //'scale('+1+')'; //.5)'; //+(percent/100)+")";
  view = 'lobby';
  hideLogin();
  showLobby();
  hideGame();
  updateLoginHeader();
  removeAllGlobalHandlers();
  addLobbyViewHandlers();
  if (isPlaying) enableResumeButton(); else disableResumeButton();
  enableCreateButton();
  enableJoinButton();
  if (!USE_SOCKETIO) hideEventList();
}
async function localOrRoute(key, url) {
  if (USE_LOCAL_STORAGE) {
    let x = localStorage.getItem(key);
    if (isdef(x)) return JSON.parse(x);
    else {
      let data = await route_path_yaml_dict(url);
      if (key != 'svgDict') localStorage.setItem(key, JSON.stringify(data));
      return data;
    }
  } else return await route_path_yaml_dict(url);
}
function localUpdate() {
  update();
}
function log_array(arr) {
  arr.map(x => console.log(x));
}
function log_object(o = {}, msg = '', props = [], indent = 0) {
  console.log(indent ? '.'.repeat(indent) : '____', msg, indent ? '' : `(caller:${getFunctionsNameThatCalledThisFunction()})`);
  let keys = get_keys(o); keys.sort();
  for (const k of keys) {
    if (isEmpty(props) || props.includes(k)) {
      if (isDict(o[k])) { log_object(o[k], k, get_keys(o[k]).join(' '), indent + 1); console.log(); }
      else if (isListOf(o[k], isLiteral)) console.log(' '.repeat(indent), k + ':', o[k].join(','));
      else console.log(' '.repeat(indent), k + ':', o[k]);
    }
  }
}
function log_objectX(o, props, msg) { console.log('___', getFunctionsNameThatCalledThisFunction(), msg); let keys = get_keys(o); keys.sort(); for (const k of props.split(' ')) { console.log('', k + ':', o[k]); } }
function logAddLine(div) { LOGDIVS.push(div); }
function logClearAll() { LOG = {}; clearElement('logDiv'); LOGDIVS = []; }
function logClientReceive(type, data) {
  MessageCounter++;
  if (VerboseSocket) console.log('#' + MessageCounter, 'receive', type, data)
}
function logClientSend(type, data) {
  MessageCounter++;
  if (VerboseSocket) console.log('#' + MessageCounter, 'send', type, data)
}
function logFormattedData(data, n, msgAfter = '') {
  let s = makeStrings(data, ['game', 'actions', 'waiting_for', 'created']);
}
function logGetDiv(plid) {
  let d = LOG[plid];
  if (!d) {
    let idParent = 'logDiv';
    let id = idParent + '_' + plid;
    d = mDiv(mBy(idParent));
    mStyle(d, { position: 'relative', left: 0, top: 0, width: 100, height: 100 }, '%');
    d.id = id;
    LOG[plid] = d;
  }
  d.style.maxHeight = getBounds('areaTable').height + 'px';
  return d;
}
function logicCheck(pic) {
}
function logicFilter(allPics, exceptProps) {
  let props = { label: { vals: getDistinctVals(allPics, 'label'), friendly: '' } };
  if (G.numColors > 1) props.colorKey = { vals: getDistinctVals(allPics, 'colorKey'), friendly: 'color' };
  if (G.numRepeat > 1) props.iRepeat = { vals: getDistinctVals(allPics, 'iRepeat'), friendly: 'number' };
  if (sameList(Object.keys(props), exceptProps)) return ['no props left', 'no', [], 'unknown'];
  let lstSpoken, lstWritten, piclist = [];
  let prop = chooseRandom(arrWithout(Object.keys(props), exceptProps));
  let val = chooseRandom(props[prop].vals);
  lstSpoken = [];
  if (prop == 'label') {
    lstSpoken.push(val);
    lstWritten = [labelPrepper(val)];
    piclist = allPics.filter(x => x.label == val);
  } else if (prop == 'colorKey') {
    lstSpoken = lstSpoken.concat(['with', props[prop].friendly, ColorDict[val][G.language]]);
    lstWritten = ['with', props[prop].friendly, colorPrepper(val)];
    piclist = allPics.filter(x => x[prop] == val);
  } else if (prop == 'iRepeat') {
    let op = (G.level > 2 && G.numRepeat > 2 && val > 1 && val < G.numRepeat) ? chooseRandom(['leq', 'geq', 'eq']) : 'eq';
    let oop = OPS[op];
    lstSpoken = lstSpoken.concat(['with', props[prop].friendly, oop.sp, val]);
    lstWritten = ['with', props[prop].friendly, oop.wr, val];
    piclist = allPics.filter(x => oop.f(x[prop], val));
  }
  if (nundef(lstWritten)) lstWritten = lstSpoken;
  let s = lstSpoken.join(' ');
  let w = lstWritten.join(' ');
  if (G.language == 'D') {
    s = s.split(' ').map(x => translateToGerman(x)).join(' ');
    w = w.split(' ').map(x => translateToGerman(x)).join(' ');
  }
  return [s, w, piclist, prop];
}
function logicMulti(n) {
  let allPics = Pictures;
  let maxPics = 4;
  let [s1, w1, pics1, prop1] = logicFilter(allPics, []);
  let [s, w, pics, prop] = [s1, w1, pics1, prop1];
  let maxloop = 3; cntloop = 0; let propsUsed = [prop1];
  while (pics.length > maxPics && cntloop < maxloop) {
    cntloop += 1;
    let opp = arrMinus(allPics, pics);
    if (opp.length <= maxPics) {
      let lst = ['eliminate', 'all', 'EXCEPT'];
      if (G.language == 'D') lst = lst.map(x => DD[x]);
      let prefix = lst.join(' ');
      s = prefix + ' ' + s;
      w = prefix + ' ' + w;
      return [s, w, opp];
    }
    [s1, w1, pics1, prop1] = logicFilter(pics, propsUsed);
    if (isEmpty(pics1)) return [s, w, pics];
    else {
      pics = pics1;
      prop = prop1;
      if (prop1 == 'label') {
        s = s1 + ' ' + s;
        w = w1 + ' ' + w;
      } else if (arrLast(propsUsed) == 'label') {
        let conn = G.language == 'E' ? ' with ' : ' mit ';
        s1 = s1.substring(s1.indexOf(' '));
        w1 = w1.substring(w1.indexOf(' '));
        s = s + conn + s1; w = w + conn + w1;
      } else {
        let conn = G.language == 'E' ? ' and ' : ' und ';
        s1 = s1.substring(s1.indexOf(' '));
        w1 = w1.substring(w1.indexOf(' '));
        s = s + conn + s1; w = w + conn + w1;
      }
      propsUsed.push(prop1);
    }
  }
  let lst1 = ['click', 'all'];
  if (G.language == 'D') lst1 = lst1.map(x => DD[x]);
  let prefix = lst1.join(' ');
  s = prefix + ' ' + s;
  w = prefix + ' ' + w;
  return [s, w, pics];
}
function logicReset() {
}
function login(username) {
  sendRoute('/login/' + username, d => {
    if (d != username) {
      alert('ERROR: ' + d);
    } else {
      USERNAME = clientData.name = d;
      document.title = 'RSG: ' + USERNAME;
      loggedIn = true;
      openSocket();
      lobbyView();
    }
  });
}
function loginView() {
  view = 'login'; hideLobby(); showLogin(); hideGame(); clearChat(); clearMessages();
  removeAllGlobalHandlers();
  addLoginViewHandlers();
}
function logout() {
  closeSocket();
  sendRoute('/logout/' + clientData.name, d => {
    clientData.name = null;
    loggedIn = false;
    loginView();
  });
}
function logRenew() { for (const d of LOGDIVS) { makeSimpleString(d); } }
function logTable() { console.log('T: game', T.game, '\nplayers', T.players.map(x => x.id), '\nstate', T.uiState) }
function logUpdateVisibility(plid, players) { for (const pl in players) { if (pl != plid) hideLog(pl); else showLog(pl); } }
function logVals(title, o) {
  let s = title + ':  ';
  for (const k in o) { s += k + ':' + o[k] + ' '; }
  console.log(s);
}
function long_polling_shield_on() {
  DA.long_polling = { type: 'table_status', data: Session.cur_tid, tid: Session.cur_tid, table: Session.cur_table, polling: true, waiting_for_prop: 'status', waiting_for_val: 'started' };
  polling_shield_on('waiting for host to start game...');
  TOMain = setTimeout(() => {
    check_poll_orig();
  }, 5000);
}
function longest_array(arr) {
  let max = 0;
  for (const a of arr) {
    if (a.length > max) max = a.length;
  }
  return max;
}
function lookup(dict, keys) {
  let d = dict;
  let ilast = keys.length - 1;
  let i = 0;
  for (const k of keys) {
    if (k === undefined) break;
    let e = d[k];
    if (e === undefined || e === null) return null;
    d = d[k];
    if (i == ilast) return d;
    i += 1;
  }
  return d;
}
function lookupAddIfToList(dict, keys, val) {
  let lst = lookup(dict, keys);
  if (isList(lst) && lst.includes(val)) return;
  lookupAddToList(dict, keys, val);
}
function lookupAddToList(dict, keys, val) {
  let d = dict;
  let ilast = keys.length - 1;
  let i = 0;
  for (const k of keys) {
    if (i == ilast) {
      if (nundef(k)) {
        console.assert(false, 'lookupAddToList: last key indefined!' + keys.join(' '));
        return null;
      } else if (isList(d[k])) {
        d[k].push(val);
      } else {
        d[k] = [val];
      }
      return d[k];
    }
    if (nundef(k)) continue;
    if (d[k] === undefined) d[k] = {};
    d = d[k];
    i += 1;
  }
  return d;
}
function lookupAsIdList(dict, keys) {
  let d = dict;
  let last = keys[keys.length - 1];
  for (const k of keys) {
    if (k in d) {
      d = d[k];
      if (k == last) return dict2list(d, 'id');
    } else return null;
  }
}
function lookupDef(o, proplist, def) { return lookup(o, proplist) || def; }
function lookupRemoveFromList(dict, keys, val, deleteIfEmpty = false) {
  let d = dict;
  let ilast = keys.length - 1;
  let i = 0;
  for (const k of keys) {
    if (i == ilast) {
      if (nundef(k)) {
        alert('lookupRemoveFromList: last key indefined!' + keys.join(' '));
        return null;
      } else if (isList(d[k])) {
        removeInPlace(d[k], val);
        if (deleteIfEmpty && isEmpty(d[k])) delete d[k];
      } else {
        if (d[k] === undefined) {
          error('lookupRemoveFromList not a list ' + d[k]);
          return null;
        }
      }
      return d[k];
    }
    if (nundef(k)) continue;
    if (d[k] === undefined) {
      error('lookupRemoveFromList key not found ' + k);
      return null;
    }
    d = d[k];
    i += 1;
  }
  return d;
}
function lookupSet(dict, keys, val) {
  let d = dict;
  let ilast = keys.length - 1;
  let i = 0;
  for (const k of keys) {
    if (nundef(k)) continue;
    if (d[k] === undefined) d[k] = (i == ilast ? val : {});
    if (nundef(d[k])) d[k] = (i == ilast ? val : {});
    d = d[k];
    if (i == ilast) return d;
    i += 1;
  }
  return d;
}
function lookupSetOverride(dict, keys, val) {
  let d = dict;
  let ilast = keys.length - 1;
  let i = 0;
  for (const k of keys) {
    if (i == ilast) {
      if (nundef(k)) {
        return null;
      } else {
        d[k] = val;
      }
      return d[k];
    }
    if (nundef(k)) continue;
    if (nundef(d[k])) d[k] = {};
    d = d[k];
    i += 1;
  }
  return d;
}
function loop(n) { return range(1, n); }
function lPicto() { }
function lsys_add() {
  C.items = {};
  let root = C.root; root.gen++;
  let [stack, gen, b, sentence, x, y, angle, len, id] = [[], root.gen, root, root.sentence, root.p2.x, root.p2.y, root.angle, root.len, root.id++];
  for (let i = 0; i < gen; i++) { len *= root.dlen; sentence = generate(sentence); }
  let step = 0;
  for (var i = 0; i < sentence.length; i++) {
    var ch = sentence[i];
    if ('ABCFVWXYZ'.includes(ch)) {
      b = create_branch(b, angle, len, b.color); lookupAddToList(C.items, ['branch'], b); b.id = id++;
    } else if (ch == '+') {
      angle -= root.dangle;
    } else if (ch == '-') {
      angle += root.dangle;
    } else if (ch == '[') {
      stack.push({ x: b.p2.x, y: b.p2.y, angle: angle, b: b });
    } else if (ch == ']') {
      let o = stack.pop();
      angle = o.angle; x = o.x; y = o.y; b = o.b;
    }
  }
  C.changed = true;
  if (root.gen < root.depth) TO.iv1 = setTimeout(lsys_add, 100); else TO.iv1 = setTimeout(() => G_init('lsys'), 5000);
}
function lsys_init(offx = 0, offy = 0, options = {}) {
  let n = NATURE.lsystems.length;
  let i = DA.isystem = (DA.isystem + 1) % n;
  let system = NATURE.lsystems[i];
  let maxdepth = calc_maxdepth(12000, system.rules);
  let root = {
    axiom: system.axiom, //'F',
    sentence: system.axiom,
    rules: system.rules,
    t: 'root',
    p2: { x: CV.width / valf(system.xstart, 2), y: CV.height },
    angle: toRadian(90),
    len: valf(system.len, 100),
    age: 0,
    gen: 0,
    id: 0,
    dangle: toRadian(valf(system.angle, 25)),
    dlen: valf(system.dlen, .5),
    thickness: valf(options.thick, 1),
    dthickness: 1,
    color: rColor(70), //'seagreen',
    depth: Math.min(valf(system.depth, NATURE.depth), maxdepth),
    animated: false,
    jitter: false,
    done: true,
  };
  return root;
}
function ltest_aristo_simple() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix', 'gul', 'amanda', 'lauren'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { commission: 'no' });
}
function ltest0() {
  let centers = cCircle({ x: 300, y: 300 }, 400, 6);
  for (const c of centers) {
    let item = mPic('bee', dMain, { fz: 40, bg: 'skyblue', rounding: '50%', padding: 10 });
    mPos(iDiv(item), c.x, c.y);
  }
}
function ltest0_card() { let c = ari_get_card('QSn'); mAppend(dTable, iDiv(c)); }
function ltest1_card() { let c = cLandscape(dTable, { margin: 12 }); }
function ltest1_hex(chex = { x: 200, y: 200 }) {
  let centers = cCircle(chex, 400, 6);
  for (const c of centers) {
    let item = mPic('bee', dMain, { fz: 40, bg: 'skyblue', rounding: '50%', padding: 10 });
    mPos(iDiv(item), c.x, c.y);
  }
  let item = mPic('bee', dMain, { fz: 40, bg: 'skyblue', rounding: '50%', padding: 10 });
  mPos(iDiv(item), chex.x, chex.y);
}
function ltest10_ferro_sim() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_one_player_0_coins], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.auto_moves = [['random']];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'felix', playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest100_auction() {
  TESTING = true; DA.testing = true; DA.test = { mods: [set_auction_phase], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat', commission: 'no', rumors: 'no' });
}
function ltest101_commission() {
  TESTING = true; DA.testing = true; DA.test = { mods: [set_queen_phase, give_player_multiple_commission_cards], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat', commission: 'yes', rumors: 'no' });
}
function ltest102_luxurycard() {
  let dTable = mBy('dTable'); clearElement(dTable); mStyle(dTable, { hmin: 400 });
  drawcard('AHl', dTable, 300);
  drawcard('AHl', dTable, 200);
  drawcard('AHl', dTable, 100);
}
function ltest103_aristo_journey() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_player_luxury_cards], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat', commission: 'no', rumors: 'no' });
}
function ltest105_aristo_church() {
  TESTING = true; DA.testing = true;
  DA.test = { mods: [give_players_stalls, make_church], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest106_aristo_build() {
  TESTING = true; DA.testing = true; DA.test = { mods: [set_king_phase, give_player_only_4_cards], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest107_aristo_build() {
  TESTING = true; DA.testing = true; DA.test = { mods: [set_king_phase, give_players_schweine_variety], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })));
}
function ltest107_aristo_inspect_schwein() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_players_schwein, set_queen_phase], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest108_animate_coin() {
  TESTING = true; DA.testing = true; DA.test = { mods: [set_king_phase, give_players_schweine_variety], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  DA.landing = () => {
    d = UI.player_stat_items[Z.uplayer].dCoin;
    anim1(d);
  };
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest108_aristo_inspect_schwein() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_players_schweine_variety, set_queen_phase], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest109_ferro() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_player_achieve_5], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = ['mimi', 'felix', 'gul'];
  startgame('ferro', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest109_spotit() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('spotit', playernames.map(x => ({ name: x, playmode: 'human' })), {});
}
function ltest11_ferro_discard() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { console.log('discard:', Z.fen.deck_discard); }
  DA.auto_moves = [['random'], [1], [1], ['random']];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest110_auction() {
  TESTING = true; DA.testing = true; DA.test = { mods: [set_auction_phase], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat', commission: 'no', rumors: 'no' });
}
function ltest110_fritz() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('fritz', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest111_start() {
  show_home_logo();
  if (nundef(U)) { show_users(); return; } show_username();
  if (DA.TEST0) show('dTestButtons');
}
function ltest12_ferro_buy() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { console.log('discard:', Z.fen.deck_discard); }
  DA.auto_moves = [['random']];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest2() {
  let boardInfo = iHexboard(2, 3, 35);
  mFlex(dMain);
  console.log('HALLO');
  let dParent = mPanel(dMain);
  let board = mItem(null, { div: dParent }, boardInfo);
  console.log('board', board, '\nboard panel', iDiv(board));
  console.log('------------------')
  let sym = chooseRandom(getAnimals());
  let items = [];
  for (const info of boardInfo.items) {
    let d = mDiv(dParent, { bg: 'random', w: board.dx / 2, h: board.dy * 2 });
    mPos(d, info.pt.y, info.pt.x);
    let item = mItem(null, { div: d }, info);
    items.push(item);
  }
}
function ltest2_card() {
  let c = cPortrait(dTable, { margin: 12, border: 'solid 4px lime', bg: 'lightgreen' });
  let d = iDiv(c);
  console.log('d', d)
  let ds = mSym('red apple', d, { sz: 30 }, 'tl');
  ds = mSymText(2, d, { sz: 25, rounding: '50%', bg: 'gold', margin: 3 }, 'tr');
  ds = mText('APPLES', d, { family: 'Algerian', w: '100%', fz: 12, align: 'center', position: 'absolute', bottom: 0 });
  ds = mSymText(2, d, { sz: 25, rounding: '50%', bg: 'crimson', margin: 3 }, 'br');
  ds = mSym('green apple', d, { sz: 70 }, 'cc');
}
function ltest2_hextest() {
  let [centers, wCont, hCont] = hexCenters(5, 4, 100, 100);
  console.log('centers', centers);
  let dCont = mDiv(dMain, { position: 'relative', w: wCont, h: hCont });
  for (const pt of centers) {
    let d = drawShape('hex', dCont);
    mCenterAt(d, pt.x, pt.y);
  }
  return dCont;
}
function ltest2_iHexboard() {
  let boardInfo = iHexboard(2, 3, 35);
  mFlex(dMain);
  console.log('HALLO');
  let dParent = mPanel(dMain);
  let board = mItem(null, { div: dParent }, boardInfo);
  console.log('board', board, '\nboard panel', iDiv(board));
  console.log('------------------')
  let sym = chooseRandom(getAnimals());
  let items = [];
  for (const info of boardInfo.items) {
    let d = mDiv(dParent, { bg: 'random', w: board.dx / 2, h: board.dy * 2 });
    mPos(d, info.pt.y, info.pt.x);
    let item = mItem(null, { div: d }, info);
    items.push(item);
  }
}
function ltest20_spotit_adaptive() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { console.log('discard:', Z.fen); }
  DA.auto_moves = [];
  startgame('spotit', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest21_spotit() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { console.log('discard:', Z.fen); }
  DA.auto_moves = [];
  startgame('spotit', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat', adaptive: false });
}
function ltest22_ferro_action1() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest23_aristo_building_downgrade() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_players_buildings], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('aristo', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest24_ferro_jolly() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [give_other_jolly_group], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest25_ferro_jolly() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [give_each_jolly_group], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest26_ferro_endgame() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [each_hand_of_one], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest27_ferro_commands() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [['random']];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest28_ferro_jolly_complex() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [give_other_jolly_group], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest29_ferro_play() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [give_player_hand_group, o => o.round = 2], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [[0, 1, 2], [1]];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest3_card() {
  let di = SHERIFF.cards;
  for (const name in di) {
    let c = sheriff_card(name);
    mAppend(dTable, iDiv(c));
  }
}
function ltest3_catan() {
  let [rows, cols, wCell, hCell, wCorner, hCorner, cover] = [5, 5, 100, 100, 25, 25, true];
  let [centers, wCont, hCont] = cover ? hexCenters(rows, cols, wCell, hCell) : hex1Centers(rows, cols, wCell, hCell);
  let dBoard = mDiv(dMain, { position: 'relative', w: wCont, h: hCont, margin: 25 });
  for (const pt of centers) {
    let d = drawShape('hex', dBoard, { w: wCell - 4, h: hCell - 4 });
    mClass(d, 'field');
    mCenterAt(d, pt.x, pt.y);
  }
  let vertices = getCornerVertices(centers, wCell, hCell);
  for (const pt of vertices) {
    let d = mDiv(dBoard, { rounding: '50%', w: wCorner, h: hCorner });
    mClass(d, 'corner');
    mCenterAt(d, pt.x, pt.y);
  }
  mButton('mod colors', modifyColor, dMain);
  let items = [];
  centers.map(x => items.push({ x: x.x, y: x.y, type: 'field' }));
  vertices.map(x => items.push({ x: x.x, y: x.y, type: 'corner' }));
  let byrc = addRowsCols(items);
  console.log(byrc);
  console.log(items);
}
function ltest30_ferro_jolly_jolly() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [give_each_jolly_group, give_player_jolly], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest31_ferro_rollback() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [small_hands, give_other_jolly_group, o => o.round = 1], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest32_select_error() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [small_hands, give_other_jolly_group, o => o.round = 4], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => ferro_transaction_error(['44', '5', '55', '7R'], ['jolly', 'anlegen'], 'take_turn_single');
  DA.auto_moves = [];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest33_ferro_sequence() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [give_player_sequence, give_other_jolly_group, o => o.round = 1], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [[2, 3, 6, 9, 10, 11, 12]];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest34_ferro_anlegen() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [give_other_jolly_group, o => o.round = 1], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [[0, 14]];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest35_ferro_sequence_anlegen() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [give_other_jolly_sequence, o => o.round = 1], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest36_ferro_two_sequence() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [give_player_jolly_sequence, give_player_sequence, o => o.round = 1], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [[0, 1, 2, 3, 4, 5, 6, 7, 8]];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest37_ferro_4_players() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }, { name: 'felix', playmode: 'human' }, { name: 'gul', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest38_ferro_end_of_round() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [give_player_group, give_player_only_one_card], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'nasi', playmode: 'human' }, { name: 'felix', playmode: 'human' }, { name: 'gul', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest39_ferro_7R() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [give_player_7R], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [[0, 1, 2, 3, 4, 5, 6, 7]];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }, { name: 'felix', playmode: 'human' }, { name: 'gul', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest4_catan_1hex() {
  let [rows, cols, wCell, hCell, wCorner, hCorner, cover] = [1, 1, 400, 400, 100, 50 * Math.sqrt(3), true];
  let [centers, wCont, hCont] = cover ? hexCenters(rows, cols, wCell, hCell) : hex1Centers(rows, cols, wCell, hCell);
  let dBoard = mDiv(dMain, { position: 'relative', w: wCont, h: hCont, margin: 100 });
  for (const pt of centers) {
    let d = drawShape('hex', dBoard, { w: wCell - 4, h: hCell - 4 });
    mClass(d, 'field');
    mCenterAt(d, pt.x, pt.y);
  }
  let vertices = getCornerVertices(centers, wCell, hCell);
  for (const pt of vertices) {
    let d = drawShape('hexF', dBoard, { w: wCorner, h: hCorner });
    mClass(d, 'corner');
    mCenterAt(d, pt.x, pt.y);
  }
  setCssVar('--color1', YELLOW);
  setCSSVariable('--color2', GREEN);
  mButton('mod colors', modifyColor, dMain);
  let items = [];
  centers.map(x => items.push({ x: x.x, y: x.y, type: 'field' }));
  vertices.map(x => items.push({ x: x.x, y: x.y, type: 'corner' }));
  let byrc = addRowsCols(items);
  addIds(items);
  neighborhood(items, byrc);
  console.log('items', items);
  let di = {};
  let edges = [];
  for (const item of items) {
    if (item.type != 'field') continue;
    for (let i = 0; i < 6; i++) {
      let v1 = item.nodes[i];
      let v2 = item.nodes[(i + 1) % 6];
      if (lookup(di, [v1, v2]) || lookup(di, [v2, v1])) continue;
      let e = makeEdge(dBoard, Items[v1], Items[v2], hCorner / 2);
      edges.push(e);
      lookupSet(di, [v1, v2], e);
    }
  }
}
function ltest4_sheriff() {
  let di = SHERIFF.cards;
  for (const name in di) { let c = sheriff_card(name); mAppend(dTable, iDiv(c)); }
}
function ltest40_ferro_7R_anlegen() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [give_player_7R], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [[0, 1, 2, 3, 4, 5, 6, 7]];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }, { name: 'felix', playmode: 'human' }, { name: 'gul', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest41_frenzy_DD() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('fritz', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest42_aristo() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('aristo', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest43_fritz_discard_pile() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [make_deck_discard], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('fritz', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest44_ferro_7R() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [give_player_7R], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }, { name: 'felix', playmode: 'human' }, { name: 'gul', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest45_fritz() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('fritz', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest46_fritz_endgame() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = {
    mods: [o => { let pl = o.fen.players[o.fen.turn[0]].hand = ['4Hn', '2Cn', '3Cn']; }], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0]
  };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('fritz', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest47_aristo() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix', 'gul', 'amanda', 'lauren'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest48_aristo_church() {
  TESTING = true; DA.testing = true; DA.test = {
    mods: [give_players_stalls], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0]
  };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix', 'gul', 'amanda', 'lauren'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest49_aristo_church() {
  TESTING = true; DA.testing = true; DA.test = {
    mods: [give_players_stalls, make_church, set_player_tithes], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0]
  };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest5_catan() {
  let [rows, cols, wCell, hCell, wCorner, hCorner, cover] = [10, 10, 80, 80, 20, 10 * Math.sqrt(3), true];
  let [centers, wCont, hCont] = cover ? hexCenters(rows, cols, wCell, hCell) : hex1Centers(rows, cols, wCell, hCell);
  let dBoard = mDiv(dMain, { position: 'relative', w: wCont, h: hCont, margin: 100 });
  for (const pt of centers) {
    let d = drawShape('hex', dBoard, { w: wCell - 4, h: hCell - 4 });
    mClass(d, 'field');
    mCenterAt(d, pt.x, pt.y);
  }
  let vertices = getCornerVertices(centers, wCell, hCell);
  for (const pt of vertices) {
    let d = drawShape('hexF', dBoard, { w: wCorner, h: hCorner });
    mClass(d, 'corner');
    mCenterAt(d, pt.x, pt.y);
  }
  let items = [];
  centers.map(x => items.push({ x: x.x, y: x.y, type: 'field' }));
  vertices.map(x => items.push({ x: x.x, y: x.y, type: 'corner' }));
  let byrc = addRowsCols(items);
  addIds(items);
  neighborhood(items, byrc);
  console.log('items', items);
  let di = {};
  let edges = [];
  for (const item of items) {
    if (item.type != 'field') continue;
    for (let i = 0; i < 6; i++) {
      let v1 = item.nodes[i];
      let v2 = item.nodes[(i + 1) % 6];
      if (lookup(di, [v1, v2]) || lookup(di, [v2, v1])) continue;
      let e = makeEdge(dBoard, Items[v1], Items[v2], hCorner / 2, 10);
      edges.push(e);
      lookupSet(di, [v1, v2], e);
    }
  }
}
function ltest5_jokerhtml() {
  let html = `
    <div style="position: absolute; top: 0px; left: 0px; width: 200px; height: 300px; background: blue">
      HALLLLLLLLLLLLLLLLLLLLOOOOOOOOOOOOOOOOOOO
      <!-- joker svg orig -->
      <svg
        xmlns="http://www.w3.org/2000/svg"
        xmlns:xlink="http://www.w3.org/1999/xlink"
        class="card"
        face="0J"
        height="100%"
        preserveAspectRatio="none"
        viewBox="-120 -168 240 336"
        width="100%"
      >
        <symbol id="J11" preserveAspectRatio="none" viewBox="0 0 1300 2000">
          <path fill="#FC4" d="M1095,1000A445,445 0 0 1 650,1445 445,445 0 0 1 205,1000 445,445 0 0 1 650,555 445,445 0 0 1 1095,1000Z"></path>
        </symbol>
        <symbol id="J12" preserveAspectRatio="none" viewBox="0 0 1300 2000">
          <path
            fill="red"
            d="M317.05664,1294.416 100,1620l220,-60 40,240 140,-200 160,200 40,-200 180,180 60,-220 260,60 -236.67969,-304.3027A445,445 0 0 1 650,1445 445,445 0 0 1 317.05664,1294.416ZM831.71484,249.10742C687.94378,262.65874 542.4812,256.33752 420,520 369.08062,331.38331 278.61481,370.61289 187.77148,412.01367a75,75 0 0 1 2.52344,19.12695 75,75 0 0 1 -16.78515,47.19532c66.827,55.25537 117.57478,127.8247 155.77539,213.90429A445,445 0 0 1 650,555 445,445 0 0 1 924.33984,650.26562c42.39917,-50.4556 91.60026,-93.34711 167.51176,-106.5332a75,75 0 0 1 -0.6524,-9.14258 75,75 0 0 1 14.6172,-44.3457C1026.3517,437.47479 931.12146,446.83238 840,440 761.98041,388.07638 804.10248,338.17898 853.51758,288.4043a75,75 0 0 1 -21.80274,-39.29688z"
          ></path>
        </symbol>
        <symbol id="J13" preserveAspectRatio="none" viewBox="0 0 1300 2000">
          <path
            fill="#44F"
            d="M879.65521,937.6026a40,40 0 0 1 -40,40 40,40 0 0 1 -40,-40 40,40 0 0 1 40,-40 40,40 0 0 1 40,40zm-379.31039,0a40,40 0 0 1 -40,40 40,40 0 0 1 -40,-40 40,40 0 0 1 40,-40 40,40 0 0 1 40,40z"
          ></path>
        </symbol>
        <symbol id="J14" preserveAspectRatio="none" viewBox="0 0 1300 2000">
          <path
            stroke="#44F"
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="6"
            fill="none"
            d="M317.05664,1294.416 100,1620l220,-60 40,240 140,-200 160,200 40,-200 180,180 60,-220 260,60 -236.67969,-304.3027M1241.1987,534.58948a75,75 0 0 1 -75,75 75,75 0 0 1 -75,-75 75,75 0 0 1 75,-75 75,75 0 0 1 75,75zM980.11493,234.09686a75,75 0 0 1 -75,75 75,75 0 0 1 -75,-75 75,75 0 0 1 75,-75 75,75 0 0 1 75,75zM190.29556,431.1412a75,75 0 0 1 -75,75 75,75 0 0 1 -74.999997,-75 75,75 0 0 1 74.999997,-75 75,75 0 0 1 75,75zM924.3457,650.27148c42.40088,-50.45397 91.5936,-93.35356 167.5059,-106.53906 -0.4037,-3.03138 -0.6215,-6.0846 -0.6524,-9.14258 0.03,-15.96068 5.1503,-31.4957 14.6172,-44.3457C1026.3517,437.47479 931.12146,446.83238 840,440 761.98041,388.07638 804.10248,338.17898 853.51758,288.4043 842.40414,277.84182 834.79487,264.12701 831.71484,249.10742 687.94378,262.65874 542.4812,256.33752 420,520 369.08062,331.38331 278.61481,370.61289 187.77148,412.01367c1.66108,6.24042 2.50924,12.66925 2.52344,19.12695 -0.0209,17.1896 -5.94587,33.85038 -16.7832,47.19336 66.82714,55.25532 117.5686,127.8306 155.76953,213.91016M384.88867,1140c51.89013,98.343 153.91815,159.9189 265.11133,160 111.19809,-0.076 213.23257,-61.6527 265.125,-160M1095,1000A445,445 0 0 1 650,1445 445,445 0 0 1 205,1000 445,445 0 0 1 650,555 445,445 0 0 1 1095,1000Z"
          ></path>
        </symbol>
        <rect width="239" height="335" x="-119.5" y="-167.5" rx="12" ry="12" fill="white" stroke="black"></rect>
        <text x="-110" y="-115" fill="red" stroke="red" style="font:bold 60px sans-serif">*</text>
        <use width="202.8" height="312" x="-101.4" y="-156" xlink:href="#J11"></use>
        <use width="202.8" height="312" x="-101.4" y="-156" xlink:href="#J12"></use>
        <use width="202.8" height="312" x="-101.4" y="-156" xlink:href="#J13"></use>
        <use width="202.8" height="312" x="-101.4" y="-156" xlink:href="#J14"></use>
      </svg>
    </div>
  `;
  document.body.appendChild(mCreateFrom(html));
}
function ltest50_aristo_church() {
  TESTING = true; DA.testing = true; DA.test = {
    mods: [give_players_stalls, make_church], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0]
  };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest51_aristo_church_downgrade() {
  TESTING = true; DA.testing = true; DA.test = {
    mods: [give_players_stalls, prep_for_church_downgrade], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0]
  };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest52_aristo_church_empty() {
  TESTING = true; DA.testing = true; DA.test = {
    mods: [give_players_empty_stalls], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0]
  };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest53_fritz_endround() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = {
    mods: [o => { let pl = o.fen.players[o.fen.turn[0]].hand = ['4Hn']; }], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0]
  };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('fritz', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest54_fritz_outoftime() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = {
    mods: [make_both_run_out_of_time], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0]
  };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('fritz', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest55_fritz_set_with_same_suits() {
  DA.magnify_on_select = true;
  TESTING = true; DA.testing = true; DA.test = {
    mods: [give_player_hand_groups], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0]
  };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('fritz', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest56_algo_overlapping_sets() {
  let cards = ['2Hn', '3Hn', '4Hn', '5Hn', '6Hn', '7Hn', '7Cn', '7Dn', '7Hn'].map(x => fritz_get_card(x));
  let res = is_overlapping_set(cards, 1, 3, false);
  console.log('res:', res);
  res = is_overlapping_set(['2Hn', '3Hn', '4Hn', '3Hn', '2Hn'].map(x => fritz_get_card(x)), 1, 3, false);
  console.log('res:', res);
  res = is_overlapping_set(['2Hn', '3Hn', '4Hn', '3Hn'].map(x => fritz_get_card(x)), 1, 3, false);
  console.log('res:', res);
  res = is_overlapping_set(['2Hn', '3Hn', '3Hn', '3Cn'].map(x => fritz_get_card(x)), 1, 3, false);
  console.log('res:', res);
  res = is_overlapping_set(['2Hn', '3Hn', '4Hn', '5Hn', '5Cn', '5Dn', '5Cn', '5Hn'].map(x => fritz_get_card(x)), 1, 3, false);
  console.log('res:', res);
  res = is_overlapping_set(['2Hn', '3Hn', '4Hn', '5Hn', '5Cn', '5Cn', '5Cn', '5Hn', '6Hn', '7Hn'].map(x => fritz_get_card(x)), 1, 3, false);
  console.log('res:', res);
  res = is_overlapping_set(['2Hn', '*Hn', '2Cn', '3Hn', '4Cn'].map(x => fritz_get_card(x)), 1, 3, false);
  console.log('res:', res);
  res = is_overlapping_set(['2Hn', '*Hn', '2Cn', '3Cn', '4Cn'].map(x => fritz_get_card(x)), 1, 3, false);
  console.log('res:', res);
  res = is_overlapping_set(['4Hn', '3Hn', '2Hn', '2Cn', '2Sn', '3Sn', '4Sn'].map(x => fritz_get_card(x)), 1, 3, false);
  console.log('res:', res);
  res = is_overlapping_set(['4Hn', '3Hn'].map(x => fritz_get_card(x)), 1, 3, false);
  console.log('res:', res);
  res = is_overlapping_set(['4Hn'].map(x => fritz_get_card(x)), 1, 3, false);
  console.log('res:', res);
}
function ltest57_aristo() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest58_aristo_building_rumor_harvest() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_players_buildings_plus, add_rumors_to_buildings, give_player_queen], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('aristo', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest59_arrTakeLast() {
  let x = arrTakeLast([0, 1, 2, 3, 4, 5], 3, 2); console.log('x', x);
  x = arrTakeLast({ blue: 1, red: 2, green: 3 }, 2, 2); console.log('x', x);
  x = arrTakeLast([0, 1, 2, 3, 4, 5], 10, 0); console.log('x', x);
}
function ltest6_bluff_skin() {
  startgame('bluff', [{ name: 'valerie', playmode: 'human' }, { name: 'felix', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest60_aristo_inspect_schwein() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_players_schwein, add_rumors_to_buildings], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('aristo', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest61_aristo_inspect_correct() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_players_buildings, add_rumors_to_buildings], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('aristo', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest62_aristo_inspect_closed_schwein() {
  TESTING = true; DA.testing = true; DA.test = { mods: [x => give_players_schwein(x, false), add_rumors_to_buildings], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('aristo', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest63_aristo_blackmail() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_other_various_buildings, set_queen_phase], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('aristo', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest64_aristo_blackmailed_building() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_other_blackmailed_building], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('aristo', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest65_stamp() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('aristo', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest66_stamp_style() {
  dTable = mBy('dTable'); mClass('dTexture', 'wood'); mCenterFlex(dTable);
  let hand = ['2Hn', '3Hn', '4Hn', '5Hn', '6Hn', '7Hn', '8Hn', '9Hn', 'THn', 'JHn', 'QHn', 'KHn', 'AHn'];
  let ui = ui_type_hand(hand, dTable);
  mStamp(ui.container, 'blackmail');
}
function ltest67_aristo_blackmail_owner() {
  TESTING = true; DA.testing = true; DA.test = { mods: [set_blackmail_owner_stage], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('aristo', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest68_aristo_blackmail_owner_defend() {
  TESTING = true; DA.testing = true; DA.test = { mods: [set_blackmail_owner_stage_defend], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  startgame('aristo', [{ name: U.name, playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest69_ferro_is_group() {
  let j = ['*Hn', '8Dn', '8Hn'];
  let x = is_group(j);
  console.log('is_group', x);
  j = ['8Hn', '*Dn', '8Hn'];
  x = is_group(j);
  console.log('is_group', x);
}
function ltest7_ferro_skin() {
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'felix', playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest70_aristo_church() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_players_stalls, make_church], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix', 'leo', 'gul'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest71_ferro() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix', 'leo', 'gul'];
  startgame('ferro', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest72_ferro() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix', 'gul', 'amanda', 'lauren', 'valerie', 'guest', 'nimble', 'sheeba', 'sarah'];
  startgame('ferro', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest73_ferro_deck_empty() {
  TESTING = true; DA.testing = true; DA.test = { mods: [make_deck_empty], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix', 'gul', 'amanda', 'lauren', 'valerie', 'guest', 'nimble', 'sheeba', 'sarah'];
  startgame('ferro', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest74_ferro_scroll_history() {
  TESTING = true; DA.testing = true; DA.test = { mods: [make_long_history], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = ['mimi', 'felix', 'gul', 'amanda', 'lauren', 'valerie', 'guest', 'nimble', 'sheeba', 'sarah'];
  startgame('ferro', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest75_ferro_multi() {
  TESTING = true; DA.testing = true; DA.test = { mods: [make_long_history], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [['random']];
  let playernames = ['mimi', 'felix', 'gul', 'amanda', 'lauren', 'valerie', 'guest', 'nimble', 'sheeba', 'sarah'];
  startgame('ferro', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'multi' });
}
function ltest76_aristo_multi() {
  TESTING = true; DA.testing = true; DA.test = { mods: [make_long_history], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = ['mimi', 'felix', 'gul'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'multi', rumors: 'no', commission: 'no', journey: 'no' });
}
function ltest77_aristo_church() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_players_stalls, make_church], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix', 'leo', 'gul'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest78_aristo_church() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_players_stalls, make_church], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [['random'], ['random']];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest79_bluff_multi() {
  TESTING = true; DA.testing = true; DA.test = { mods: [make_long_history], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = ['mimi', 'felix'];
  startgame('bluff', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'multi' });
}
function ltest8_ferro_sim() {
  TESTING = true; DA.testing = true; DA.test = { iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.auto_moves = [['last']];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'felix', playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest80_fritz_multi() {
  TESTING = true; DA.testing = true; DA.test = { mods: [make_long_history], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = ['mimi', 'felix'];
  startgame('fritz', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'multi' });
}
function ltest81_spotit_multi() {
  TESTING = true; DA.testing = true; DA.test = { mods: [make_long_history], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = ['mimi', 'felix'];
  startgame('spotit', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'multi' });
}
function ltest82_ferro() {
  TESTING = true; DA.testing = true; DA.test = { mods: [make_long_history], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = ['mimi', 'felix', 'gul'];
  startgame('ferro', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest83_ferro_multi() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = ['mimi', 'felix'];
  startgame('ferro', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'multi' });
}
function ltest83_svg() {
  dTable = mBy('dTexture'); mCenterFlex(dTable); mStyle(dTable, { hmin: 500 }); mClass(dTable, 'wood');
  mStyle(dTable, { gap: 10 });
  let card;
  card = cBlankSvg(dTable);
  console.log('card', card);
  let g = iG(card);
  let x = mgSuit('Pik');
  mgSize(x, 40);
  mgPos(card, x);
}
function ltest84_svg() {
  let dTable = mBy('dTable'); clearElement(dTable); mStyle(dTable, { hmin: 400 })
  let card = cBlank(dTable); let d = iDiv(card); let sz = card.h / 6;
  let i = 0;
  for (let suit of ['H', 'S', 'D', 'C']) {
    let s1 = mSuit(suit, d, { w: sz, h: sz });
    mPos(s1, sz * i, 0); i++;
  }
}
function ltest85_card_short_text() {
  let dTable = mBy('dTable'); clearElement(dTable); mStyle(dTable, { hmin: 400 });
  let ckey = 'KCn';
  let sz = 20;
  let d = mDiv(dTable, {}, null, `hallo das ist ein ${mCardText(ckey)}.`);
  return;
}
function ltest86_ferro() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_player_two_ferro_sets, make_long_history], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = ['mimi', 'felix', 'gul'];
  startgame('ferro', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest87_aristo() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest88_aristo_market() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_players_stalls], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest89_aristo_journey() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix', 'amanda', 'lauren'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat', commission: 'no', rumors: 'no' });
}
function ltest9_ferro_sim() {
  TESTING = true; DA.testing = true; DA.test = { iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.auto_moves = [['random']];
  startgame('ferro', [{ name: U.name, playmode: 'human' }, { name: 'felix', playmode: 'human' }, { name: 'amanda', playmode: 'human' }], { mode: 'hotseat' });
}
function ltest90_bluff() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix', 'amanda', 'lauren'];
  startgame('bluff', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest90_bluff_ueberbiete() {
  TESTING = true; DA.testing = true; DA.test = { mods: [bluff_start_bid], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix', 'amanda', 'lauren'];
  startgame('bluff', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest91_bluff_strategy() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = ['mimi', 'lauren', 'felix'];
  let playmodes = ['human', 'bot', 'bot'];
  let strategy = ['', 'random', 'clairvoyant'];
  let i = 0; let players = playernames.map(x => ({ name: x, strategy: strategy[i], playmode: playmodes[i++] }));
  let options = { mode: 'hotseat' };
  startgame('bluff', players, options);
}
function ltest92_bluff_bots() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = ['mimi', 'lauren', 'felix'];
  let playmodes = ['bot', 'bot', 'bot'];
  let strategy = ['random', 'perfect', 'clairvoyant'];
  let i = 0; let players = playernames.map(x => ({ name: x, strategy: strategy[i], playmode: playmodes[i++] }));
  let options = { mode: 'hotseat' };
  startgame('bluff', players, options);
}
function ltest93_bluff() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix', 'amanda', 'lauren'];
  startgame('bluff', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest94_aristo_journey() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_players_hand_journey], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat', commission: 'no', rumors: 'no' });
}
function ltest95_aristo_rumor_action() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_players_buildings_plus, set_queen_phase, give_player_king], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix', 'amanda', 'lauren'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat' });
}
function ltest96_aristo_visit() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_players_schwein, set_queen_phase, give_player_queen], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix', 'amanda', 'lauren'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat', commission: 'no', rumors: 'no' });
}
function ltest97_find_sequences() {
  let x = follows_in_rank('ACn', '2Cn', 'A23456789TJQK');
  console.log('follows', x);
  x = find_sequences(['ACn', '2Cn', '3Hn', '5Hn', '7Hn', '7Sn', '7Cn', '7Dn'], 2, 'A23456789TJQK');
  console.log('follows', x);
}
function ltest98_weired_blatt_aendern() {
  TESTING = true; DA.testing = true; DA.test = { mods: [give_players_hand_A2], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('aristo', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat', commission: 'no', rumors: 'no' });
}
function ltest99_fritz() {
  TESTING = true; DA.testing = true; DA.test = { mods: [], iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [0] };
  DA.test.end = () => { };
  DA.auto_moves = [];
  let playernames = [U.name, 'felix'];
  startgame('fritz', playernames.map(x => ({ name: x, playmode: 'human' })), { mode: 'hotseat', commission: 'no', rumors: 'no' });
}
function luminance(r, g, b) {
  var a = [r, g, b].map(function (v) {
    v /= 255;
    return v <= 0.03928
      ? v / 12.92
      : Math.pow((v + 0.055) / 1.055, 2.4);
  });
  return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;
}
function luxury_card_deco(card) {
  let d = iDiv(card); mStyle(d, { position: 'relative' });
  let d1 = mDiv(d, { fg: 'dimgray', fz: 11, family: 'tangerine', position: 'absolute', left: 0, top: 0, 'writing-mode': 'vertical-rl', transform: 'scale(-1)', top: '35%' }, null, 'Luxury');
  let html = `<img height=${18} src="../base/assets/icons/deco0.svg" style="transform:scaleX(-1);">`;
  d1 = mDiv(d, { position: 'absolute', bottom: -2, left: 3, opacity: .25 }, null, html);
}
function maButton(caption, handler, dParent, styles) {
  let a = mLink("javascript:void(0)", dParent, {}, null, caption, 'a');
  a.onclick = handler;
  if (isdef(styles)) mStyle(a, styles);
  return a;
}
function mAddBehavior(ui, beh, params) {
  switch (beh) {
    case 'magnifyOnHover': addMagnifyOnHover(ui, ...params); break;
    case 'selectOnClick': addSelectOnClick(ui, ...params); break;
  }
}
function mAddContent(d, content, styles, opt) { return mAddContentAndMeasure(d, content, styles, opt, false, false); }
function mAddContentAndMeasure(d, content, styles, opts = {}, wNeeded = true, hNeeded = true) {
  let keepInLine = valf(opts.keepInLine, false);
  let replace = valf(opts.replace, false);
  let newline = valf(opts.newline, false);
  let d1 = content;
  if (isDOM(content)) mAppend(d, content);
  else if (isDict(content)) {
    d1 = iDiv(content);
    if (isDOM(d1)) {
      mAppend(d, d1);
    } else if (nundef(d1)) {
      d1 = mDiv(d, { bg: 'random' });
      mNode(content, d1);
    } else {
      doms = recFindDOMs(content);
      d1 = mDiv(d, { bg: 'random' });
      for (const dom of doms) { mAppend(d1, dom); }
    }
  } else if (isList(content)) {
    d1 = mDiv(d, { bg: 'random' });
    content = content.join(',');
    d1.innerHTML = content;
  } else if (isString(content) && content[0] === '<') {
    d1 = createElementFromHtml(cont);
    mAppend(d, d1);
  } else {
    d1 = mText(content, d);
  }
  if (replace) clearElement(d);
  if (keepInLine) styles['white-space'] = 'nowrap';
  if (newline) styles.display = 'block';
  if (isdef(styles)) mStyle(d1, styles);
  if (wNeeded && hNeeded) setSizeNeeded(d);
  else if (wNeeded) setWNeeded(d);
  else if (hNeeded) setHNeeded(d);
  return d1;
}
function mAddContentAndMeasureH(d, content, styles, opt) { return mAddContentAndMeasure(d, content, styles, opt, false, true); }
function mAddContentAndMeasureW(d, content, styles, opt) { return mAddContentAndMeasure(d, content, styles, opt, true, false); }
function magnifyFront(id) {
  let card = UIS[id];
  let hand = UIS[card.hand];
  if (hand.scale != 1) {
    card.setScale(1);
  }
  _bringCardToFront(id)
}
function maHideLabel(id, info) {
  let d = mBy(id);
  let dPic = d.children[0];
  let dText = d.children[1];
  dText.style.display = 'none';
  let dPicText = dPic.children[0];
  let family = dPicText.style.fontFamily;
  let i = (family == info.family) ? 0 : EMOFONTLIST.indexOf(family) + 1;
  let wInfo = info.w[i];
  let hInfo = info.h[i];
  let b = getBounds(d);
  let styles = { w: b.width, h: b.height };
  let [ptop, pbottom] = [firstNumber(d.style.paddingTop), firstNumber(d.style.paddingBottom)];
  let p = (isdef(ptop) && isdef(pbottom)) ? Math.min(ptop, pbottom) :
    isdef(ptop) ? ptop : isdef(pbottom) ? pbottom / 2 : 0;
  let [padw, padh] = [p, p];
  let [wtotal, htotal] = [styles.w, styles.h];
  let [wpic, hpic] = [wtotal - 2 * padw, htotal - 2 * padh];
  let fw = wpic / wInfo;
  let fh = hpic / hInfo;
  f = Math.min(fw, fh);
  fzreal = f * info.fz;
  wreal = f * wInfo;
  hreal = f * hInfo;
  padw += isdef(styles.w) ? (wpic - wreal) / 2 : 0;
  padh += isdef(styles.h) ? (hpic - hreal) / 2 : 0;
  if (!(padw >= 0 && padh >= 0)) { console.log(info); }
  let innerStyles = {};
  innerStyles.fz = fzreal;
  innerStyles.weight = 900;
  info.fzOrig = dPicText.style.fontSize;
  info.textColorOrig = dPicText.style.color;
  dPicText.style.fontSize = fzreal + 'px';
  info.wOrig = dPic.style.width;
  info.hOrig = dPic.style.height;
  innerStyles.w = wreal;
  innerStyles.h = hreal + 2 * padh;
  mStyleX(dPic, innerStyles);
  let outerStyles = {};
  info.paddingOrig = d.style.padding;
  info.paddingTopOrig = d.style.paddingTop;
  info.paddingBottomOrig = d.style.paddingBottom;
  outerStyles.padding = '' + 2 * padh + 'px ' + padw + 'px' + '0' + 'px ' + padw + 'px';
  mStyleX(d, outerStyles);
}
function main_menu_off() { close_sidebar(); open_mini_user_info(); }
function main_menu_on() { open_sidebar(); close_mini_user_info(); }
function mainVisualExists(oid) {
  return firstCond(oid2ids[oid], x => x[0] == 'm');
}
function make_both_run_out_of_time(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  for (const plname in fen.players) {
    let pl = fen.players[plname];
    pl.time_left = 100;
  }
}
function make_card_selectable(item) { let d = iDiv(item.o); mClass(d, 'selectable'); if (Z.game != 'aristo') { spread_hand(item.path, .3); } mClass(d.parentNode, 'selectable_parent'); }
function make_card_selected(item) {
  let color = isdef(Z.func.get_selection_color) ? Z.func.get_selection_color(item) : 'red';
  set_card_border(item, 13, color);
  if (DA.magnify_on_select) mClass(iDiv(item.o), 'mag');
}
function make_card_unselectable(item) { let d = iDiv(item.o); d.onclick = null; mClassRemove(d, 'selectable'); mClassRemove(d.parentNode, 'selectable_parent'); spread_hand(item.path); }
function make_card_unselected(item) { set_card_border(item); if (DA.magnify_on_select) mClassRemove(iDiv(item.o), 'mag'); }
function make_church(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  fen.stage = 1004;
  fen.market = ['JHn', 'QSn'];
}
function make_container_selectable(item) { let d = iDiv(item); mClass(d, 'selectable'); mClass(d, 'selectable_parent'); }
function make_container_selected(item) { let d = iDiv(item); mClass(d, 'selected_parent'); }
function make_container_unselectable(item) { let d = iDiv(item); d.onclick = null; mClassRemove(d, 'selectable'); mClassRemove(d, 'selectable_parent'); }
function make_container_unselected(item) { let d = iDiv(item); mClassRemove(d, 'selected_parent'); }
function make_csv_for_rankings() {
  let csv = 'players,';
  let games = get_values(DB.games);
  let gamenames = games.map(x => x.friendly).join(',');
  csv += gamenames;
  for (const name in DB.users) {
    let [dbuser, values, usergames] = [DB.users[name], [], []];
    for (const gname in dbuser.games) {
      let rec = dbuser.games[gname];
      if (isdef(rec.total) && rec.total > 0) usergames.push(gname);
    }
    if (isEmpty(usergames)) continue;
    for (const gname in DB.games) {
      let info = lookupSet(DB.users, [name, 'games', gname], {});
      if (nundef(info.total)) values.push('0/0'); else values.push(`${info.wins}/${info.total}`);
    }
    if (!isEmpty(values)) csv += `\n${name},` + values.join(',');
  }
  return csv;
}
function make_deck_discard(o) {
  let fen = o.fen;
  let uplayer = o.uplayer;
  fen.deck_discard = ['2Sn', '3Sn', '4Sn', '5Sn', '6Sn', '7Sn', '8Sn', '9Sn', 'TSn'];
  fen.journeys = [['2Dn', '3Dn', '4Dn'], ['5Sn', '6Sn', '7Sn']];
}
function make_deck_empty(o) {
  let fen = o.fen;
  fen.deck_discard = fen.deck;
  output_arr_short(fen.deck);
  fen.deck = [];
}
function make_deck_selectable(item) { }
function make_deck_selected(item) { }
function make_deck_unselectable(item) { }
function make_deck_unselected(item) { }
function make_favicon(key) {
  let url = valf(Emicons[key], Emicons.maus);
  var link = document.querySelector("link[rel*='icon']") || document.createElement('link');
  link.type = 'image/png';
  link.rel = 'shortcut icon';
  link.href = url; //'https://ssl.gstatic.com/docs/doclist/images/infinite_arrow_favicon_5.ico';
  document.getElementsByTagName('head')[0].appendChild(link);
}
function make_goal_set(deck, prob_different) {
  let [fen1, fen2, fen3] = [deck[0], '', ''];
  let n = fen1.length;
  let different = randomNumber(0, n - 1);
  for (let i = 0; i < n; i++) {
    let l1 = fen1[i];
    let same = i == different ? false : coin(prob_different);
    let inc = coin() ? 1 : -1;
    let [l2, l3] = same ? [l1, l1] : ['' + (3 + Number(l1) + inc * 1) % 3, '' + (3 + Number(l1) + inc * 2) % 3];
    fen2 += l2; fen3 += l3;
  }
  return [fen1, fen2, fen3];
}
function make_hand_selectable(item) { }
function make_hand_selected(item) { }
function make_hand_unselectable(item) { }
function make_hand_unselected(item) { }
function make_long_history(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  fen.history = [];
  for (let i = 0; i < 100; i++) {
    let lines = [`${rChoose(get_keys(fen.players))} discards ${rCard()}`];
    let title = 'discard';
    fen.history.push({ title: title, lines: lines });
  }
}
function make_market_selectable(item) { }
function make_market_selected(item) { }
function make_market_unselectable(item) { }
function make_market_unselected(item) { }
function make_payments_challenge_eval(inp) {
  let val = inp.value;
  let solution = { amount: DA.bill.nums.balance, index: DA.bill.acc.index };
  let answer = { amount: Number(val.substring(1).trim()), index: Number(inp.id.substring(3)) };
  let correct = solution.amount.toFixed(2) == answer.amount.toFixed(2) && solution.index == answer.index;
  show_eval_message(correct, null, correct ? onclick_home : null);
}
function make_players(playernames) {
  let o = Session.cur_players = {};
  for (const plname of playernames) {
    o[plname] = { name: plname, color: getColorDictColor(DB.users[plname].color), imgPath: `../base/assets/images/${plname}.jpg`, score: 0 };
  }
  Session.cur_me = o[Session.cur_user];
  Session.cur_others = get_values(o).filter(x => x.name != Session.cur_user);
}
function make_set_deck(n_or_attr_list) {
  let all_attrs = gSet_attributes();
  let keys = get_keys(all_attrs);
  let n = isNumber(n_or_attr_list) ? n_or_attr_list : n_or_attr_list.length;
  let attrs = isNumber(n_or_attr_list) ? arrTake(keys, n) : n_or_attr_list;
  let list = ['0', '1', '2'];
  let i = 1;
  while (i < n) {
    let [l1, l2, l3] = [jsCopy(list), jsCopy(list), jsCopy(list)];
    l1 = l1.map(x => '0' + x); l2 = l2.map(x => '1' + x); l3 = l3.map(x => '2' + x);
    list = l1.concat(l2).concat(l3);
    i++;
  }
  return list;
}
function make_string_selectable(item) { let d = mBy(item.id); mClass(d, 'selectable_button'); }
function make_string_selected(item) { let d = mBy(item.id); item.bg = mGetStyle(d, 'bg'); item.fg = mGetStyle(d, 'fg'); mStyle(d, { bg: 'yellow', fg: 'black' }); }
function make_string_unselectable(item) { let d = mBy(item.id); d.onclick = null; mClassRemove(d, 'selectable_button'); }
function make_string_unselected(item) { let d = mBy(item.id); mStyle(d, { bg: item.bg, fg: item.fg }); }
function makeArea(areaName, idParent) {
  let mobj = new MOBJ();
  let id = 'm_A_' + areaName;
  mobj.id = id;
  let domel = document.createElement('div');
  domel.style.position = 'absolute';
  mobj.elem = domel;
  mobj.elem.id = id;
  mobj.parts.elem = mobj.elem;
  mobj.domType = getTypeOf(mobj.elem);
  mobj.cat = DOMCATS[mobj.domType];
  mobj.idParent = idParent;
  let parent = UIS[idParent];
  parent.children.push(id);
  mobj.attach();
  UIS[id] = mobj;
  linkObjects(id, areaName);
  listKey(IdOwner, id[2], id);
  return mobj;
}
function makeAreaNameDomel(areaName) { return `<div style='width:100%'>${areaName}</div>`; }
function makeAreas(dParent, layout) {
  let dGrid = mDiv(dParent, { gap: 10, bg: 'white', w: '90%', padding: 10, display: 'inline-grid', rounding: 10 }, 'dGrid');
  if (nundef(layout)) layout = ['T', 'H A'];
  let x = createGridLayout(dGrid, layout);
  let areaStyles = { bg: 'green', rounding: 6 };
  let contentStyles = { lowerRounding: 6 };
  let messageStyles = { fg: 'yellow' };
  let titleStyles = { bg: 'dimgray', family: 'AlgerianRegular', upperRounding: 6 };
  let areas = {
    T: { title: 'table', id: 'dTrick', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles, titleOnTop: true },
    H: { title: 'YOU', id: 'dHuman', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles, titleOnTop: false },
    A: { title: 'opponent', id: 'dAI', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles, titleOnTop: false },
  };
  let items = [];
  for (const k in areas) {
    let item = areas[k];
    item.areaStyles['grid-area'] = k;
    let dCell = mTitledMessageDiv(item.title, dGrid, item.id, item.areaStyles, item.contentStyles, item.titleStyles, item.messageStyles, item.titleOnTop)
    iRegister(item, item.id);
    if (item.titleOnTop) iAdd(item, { div: dCell, dTitle: dCell.children[0], dMessage: dCell.children[1], dContent: dCell.children[2] });
    else iAdd(item, { div: dCell, dTitle: dCell.children[2], dMessage: dCell.children[0], dContent: dCell.children[1] });
    mCenterCenterFlex(diContent(item));
    mStyleX(diContent(item), { gap: 10 });
    items.push(item);
  }
  return items;
}
function makeAreasKrieg(dParent) {
  let dGrid = mDiv(dParent, { gap: 10, bg: 'white', w: '90%', padding: 10, display: 'inline-grid', rounding: 10 }, 'dGrid');
  let layout = ['T', 'H A'];
  let x = createGridLayout(dGrid, layout);
  let areaStyles = { bg: 'green', rounding: 6 };
  let contentStyles = { lowerRounding: 6 };
  let messageStyles = { fg: 'yellow' };
  let titleStyles = { bg: 'dimgray', family: 'AlgerianRegular', upperRounding: 6 };
  let areas = {
    T: { title: 'table', id: 'dTrick', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles, titleOnTop: true },
    H: { title: 'YOU', id: 'dHuman', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles, titleOnTop: false },
    A: { title: 'opponent', id: 'dAI', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles, titleOnTop: false },
  };
  let items = [];
  for (const k in areas) {
    let item = areas[k];
    item.areaStyles['grid-area'] = k;
    let dCell = mTitledMessageDiv(item.title, dGrid, item.id, item.areaStyles, item.contentStyles, item.titleStyles, item.messageStyles, item.titleOnTop)
    iRegister(item, item.id);
    if (item.titleOnTop) iAdd(item, { div: dCell, dTitle: dCell.children[0], dMessage: dCell.children[1], dContent: dCell.children[2] });
    else iAdd(item, { div: dCell, dTitle: dCell.children[2], dMessage: dCell.children[0], dContent: dCell.children[1] });
    mCenterCenterFlex(diContent(item));
    mStyleX(diContent(item), { gap: 10 });
    items.push(item);
  }
  return items;
}
function makeAux(s, oid, areaName, directParent) {
  let id = 'x_l_' + getUID() + '@' + oid;
  if (isdef(UIS[id])) { error('CANNOT create ' + id + ' TWICE!!!!!!!!!'); return; }
  let mobj = new MOBJ();
  mobj.id = id;
  let domel = document.createElement('div');
  domel.classList.add('hallo');
  domel.innerHTML = s;
  mobj.elem = domel;
  mobj.parts.elem = mobj.elem;
  mobj.domType = getTypeOf(domel);
  mobj.cat = DOMCATS[mobj.domType];
  let idParent = areaName;
  mobj.idParent = idParent;
  let parent = UIS[idParent];
  parent.children.push(id);
  mobj.isa.aux = true;
  linkObjects(id, oid);
  listKey(IdOwner, id[2], id);
  UIS[id] = mobj;
  if (isdef(directParent)) { mobj.isAttached = true; directParent.appendChild(mobj.elem) } else mobj.attach();
  return mobj;
}
function makeBestMove(color) {
  if (color === 'b') {
    var move = getBestMove(G.game, color, globalSum)[0];
    return move;
  } else {
    var move = getBestMove(G.game, color, -globalSum)[0];
  }
  globalSum = evaluateBoard(move, globalSum, 'b');
  G.game.move(move);
  G.board.position(G.game.fen());
}
function makeBoard(idBoard, o, areaName) {
  let id = 'm_s_' + idBoard;
  if (isdef(UIS[id])) { error('CANNOT create ' + id + ' TWICE!!!!!!!!!'); return; }
  let mobj = new MOBJ();
  mobj.id = id;
  let domel = addSvgg(UIS[areaName].elem, id, { originInCenter: true });
  mobj.elem = domel;
  mobj.parts.elem = mobj.elem;
  mobj.domType = getTypeOf(domel);
  mobj.cat = DOMCATS[mobj.domType];
  let idParent = areaName;
  mobj.idParent = areaName;
  let parent = UIS[idParent];
  parent.children.push(id);
  mobj.o = o;
  mobj.isa.board = true;
  linkObjects(id, idBoard);
  listKey(IdOwner, id[2], id);
  UIS[id] = mobj;
  mobj.isAttached = true;
  return mobj;
}
function makeBoardElement(oid, o, idBoard, elType) {
  let id = 'm_t_' + oid;
  if (isdef(UIS[id])) {
    error('CANNOT create ' + id + ' TWICE!!!!!!!!!');
    return;
  }
  let mobj = new MOBJ();
  mobj.id = id;
  let domel = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  mobj.elem = domel;
  mobj.elem.id = id;
  mobj.parts.elem = mobj.elem;
  mobj.domType = getTypeOf(domel);
  mobj.cat = DOMCATS[mobj.domType];
  let idParent = idBoard;
  mobj.idParent = idParent;
  let parent = UIS[idParent];
  parent.children.push(id);
  mobj.o = o;
  mobj.isa[elType] = true;
  linkObjects(id, oid);
  listKey(IdOwner, id[2], id);
  UIS[id] = mobj;
  return mobj;
}
function makeCadreTable(powers) {
  let cadreTypes = ['Infantry', 'Fortress', 'Tank', 'AirForce', 'Fleet', 'Carrier', 'Submarine'];
  let table = makeTable('AvailableCadres', cadreTypes, powers);
  addTableTo(table);
}
function makeCanvas(d) {
  let canvas = mCreate('canvas');
  mAppend(d, canvas);
  canvas.id = 'sheet';
  return canvas;
}
function makeCard(oid, o, areaName) {
  let idArea = getIdArea(areaName);
  let id = 'm_t_' + oid;
  if (isdef(UIS[id])) {
    error('CANNOT create ' + id + ' TWICE!!!!!!!!!');
    return;
  }
  let mobj = new MOBJ();
  mobj.id = id;
  let cardName = isdef(o.name) ? o.name : 'King';
  let domel;
  if (GAME == 'catan') domel = _makeCardDivCatan(oid, o);
  else if (GAME == 'aristocracy') domel = _makeCardDivAristocracy(oid, o);
  else domel = _makeCardDivDefault(oid, o);
  domel.id = id;
  mobj.elem = domel;
  mobj.parts.elem = mobj.elem;
  mobj.domType = getTypeOf(domel);
  mobj.cat = DOMCATS[mobj.domType];
  let parent = UIS[idArea];
  let idParent = parent.id;
  mobj.idParent = idParent;
  parent.children.push(id);
  mobj.o = o;
  mobj.isa.card = true;
  linkObjects(id, oid);
  listKey(IdOwner, id[2], id);
  UIS[id] = mobj;
  return mobj;
}
function makeCard_dep(oid, o, areaName) {
  let idArea = getIdArea(areaName);
  let id = 'm_t_' + oid;
  if (isdef(UIS[id])) {
    error('CANNOT create ' + id + ' TWICE!!!!!!!!!');
    return;
  }
  let mk = new MK();
  mk.id = id;
  let cardName = isdef(o.name) ? o.name : 'King';
  let domel;
  if (GAME == 'catan') domel = _makeCardDivCatan(oid, o);
  else if (GAME == 'aristocracy') domel = _makeCardDivAristocracy(oid, o);
  else domel = _makeCardDivDefault(oid, o);
  domel.id = id;
  mk.elem = domel;
  mk.parts.elem = mk.elem;
  mk.domType = getTypeOf(domel);
  mk.cat = DOMCATS[mk.domType];
  let parent = UIS[idArea];
  let idParent = parent.id;
  mk.loc = idParent;
  parent.children.push(id);
  mk.o = o;
  mk.isa.card = true;
  linkObjects(id, oid);
  listKey(IdOwner, id[2], id);
  UIS[id] = mk;
  return mk;
}
function makeCard123(oid, o) {
  let mk = new MK();
  let id = getIdForOid(oid);
  mk.id = id;
  let domel = makeCardDomel(o);
  evAddCounter += 1;
  domel.style.position = 'absolute';
  mk.elem = domel;
  mk.elem.id = id;
  mk.parts.elem = mk.elem;
  mk.domType = getTypeOf(mk.elem);
  mk.cat = DOMCATS[mk.domType];
  mk.o = o;
  mk.oid = oid;
  mk.isa.card = true;
  UIS[id] = mk;
  linkObjects(id, oid);
  listKey(IdOwner, id[2], id);
  return mk;
}
function makeCardDomel(oCard) {
  if (lookup(SPEC, ['typeMappings', 'card'])) {
    for (const k in SPEC.typeMappings.card) {
      oCard[k] = oCard[SPEC.typeMappings.card[k]];
    }
  }
  let el = cardFace(oCard);
  return el;
}
function makeCategories() {
  let keys = Categories = {
    animal: getGSGElements(g => g == 'Animals & Nature', s => startsWith(s, 'animal')),
    clothing: getGSGElements(g => g == 'Objects', s => s == 'clothing'),
    emotion: getGSGElements(g => g == 'Smileys & Emotion', s => startsWith(s, 'face') && !['face-costume', 'face-hat'].includes(s)),
    food: getGSGElements(g => g == 'Food & Drink', s => startsWith(s, 'food')),
    'game/toy': (['sparkler', 'firecracker', 'artist palette', 'balloon', 'confetti ball'].concat(ByGroupSubgroup['Activities']['game'])).sort(),
    gesture: getGSGElements(g => g == 'People & Body', s => startsWith(s, 'hand')),
    job: ByGroupSubgroup['People & Body']['job'],
    mammal: ByGroupSubgroup['Animals & Nature']['animal-mammal'],
    music: getGSGElements(g => g == 'Objects', s => startsWith(s, 'musi')),
    object: getGSGElements(g => g == 'Objects', s => true),
    place: getGSGElements(g => g == 'Travel & Places', s => startsWith(s, 'place')),
    plant: getGSGElements(g => g == 'Animals & Nature' || g == 'Food & Drink', s => startsWith(s, 'plant') || s == 'food-vegetable' || s == 'food-fruit'),
    sport: ByGroupSubgroup['Activities']['sport'],
    tool: getGSGElements(g => g == 'Objects', s => s == 'tool'),
    transport: getGSGElements(g => g == 'Travel & Places', s => startsWith(s, 'transport')),
  };
  let incompatible = DA.incompatibleCats = {
    animal: ['mammal'],
    clothing: ['object'],
    emotion: ['gesture'],
    food: ['plant', 'animal'],
    'game/toy': ['object', 'music'],
    gesture: ['emotion'],
    job: ['sport'],
    mammal: ['animal'],
    music: ['object', 'game/toy'],
    object: ['music', 'clothing', 'game/toy', 'tool'],
    place: [],
    plant: ['food'],
    sport: ['job'],
    tool: ['object'],
    transport: [],
  }
}
function makeCells(d, rows, cols, gap = '2px') {
  d.style.setProperty('--grid-rows', rows);
  d.style.setProperty('--grid-cols', cols);
  d.style.setProperty('--grid-gap', gap);
  let cells = [];
  for (rows = 0; rows < rows; rows++) {
    cells[rows] = [];
    for (cols = 0; cols < cols; cols++) {
      let cell = document.createElement("div");
      cell.innerText = (rows + ',' + cols);
      d.appendChild(cell).className = "grid-item";
      cells[rows].push(cell);
    }
  }
  return cells;
}
function makeCollectionArea(key, parentAreaId) {
  let parentArea = UIS[parentAreaId];
  let handAreaName = key;
  if (isdef(parentArea)) {
    let mobj = makeArea(handAreaName, parentAreaId);
    mobj.setBg(randomColor());
    mobj.title(stringAfter(key, '.'));
    let bTitle = getBounds(mobj.parts.title);
    mobj.parts['title'].fontSize = '12px';
    mobj.elem.style.minWidth = bTitle.width + 'px'; //'90px';
    mobj.elem.style.minHeight = '146px';
    mobj.body('hand');
    let div = mobj.parts['hand'];
    div.style.position = 'relative';
    div.style.left = '10px';
    div.style.top = '10px';
    div.style.width = 'auto';
    div.style.height = 'auto';
    mobj.collectionKey = key;
    mobj.adjustSize = true;
    let divCollection = mobj.elem;
    divCollection.style.position = null;
    return mobj;
  }
}
function makeColumns(dParent, divList, wFit, hFit, yStart) {
  let h = maxFit(divList, 'offsetHeight', 0, hFit);
  let wmax = maxFit(divList, 'offsetWidth', 0, wFit);
  let w = sumProp(divList, 'offsetWidth');
  if (w > wFit) {
    h = Math.min(h + 20, hFit);
    dParent.style.overflow = 'auto';
  }
  let hPlus = hFit - h;
  let margin = '5';
  let wIdeal = (wFit / divList.length) - (divList.length + 1) * margin;
  if (wIdeal >= wmax) wmax = wIdeal;
  let wPlus = wFit - (wmax * divList.length);
  let dy = hPlus / 3;
  let dx = wPlus / (divList.length + 1);
  let x = dx;
  let y = dy + yStart;
  for (const div of divList) {
    div.style = `height:${h}px;width:${wmax}px;background-color:dimgrey;position:absolute;left:${x}px;top:${y}px`;
    x += dx + wmax;
  }
}
function makeCorners(pool, board, serverBoard) {
  let serverFieldIds = _setToList(serverBoard.fields).map(x => x._obj);
  board.structInfo.corners = _setToList(serverBoard.corners).map(x => x._obj);
  let dhelp = {};
  for (const fid of serverFieldIds) {
    let sfield = pool[fid];
    let ffield = getVisual(fid);
    if (nundef(sfield.corners)) continue;
    let iPoly = 0;
    let cornerIds = sfield.corners.map(x => x._obj);
    for (const cid of cornerIds) {
      if (!cid) {
        iPoly += 1;
        continue;
      } else if (isdef(dhelp[cid])) {
        iPoly += 1;
        continue;
      } else {
        let corner = makeBoardElement(cid, pool[cid], board.id, 'corner');
        let poly = ffield.memInfo.poly[iPoly];
        corner.memInfo = { shape: 'circle', memType: 'corner', x: poly.x, y: poly.y, w: 1, h: 1 };
        dhelp[cid] = corner;
        iPoly += 1;
      }
    }
  }
}
function makeDeck({ kind, N, nJokers, fPrep, fDraw, bDraw, x, y, w, h } = {}) {
  if (nundef(kind)) kind = 'deck52';
  let params = {
    kind: kind,
    fPrepFace: isdef(fPrep) ? fPrep : window[kind + 'Prep'],
    fUpdateFace: isdef(fDraw) ? fDraw : window[kind + 'Update'],
    fPrepBack: isdef(bDraw) ? bDraw : window[kind + 'Back'],
    fUpdateBack: isdef(bDraw) ? bDraw : window[kind + 'Back'],
    size: { w: 78, h: 110 },
    orientation: 'portrait',
    repeat: 1,
    numJokers: isdef(nJokers) ? nJokers : 0,
  };
  let defStyle = { deck52: { n: 52 }, catan: { n: 20 }, free: {}, deckEmpty: { n: 0 } };
  N = isdef(N) ? N : defStyle[params.kind].n;
  params.N = N;
  params.NTotal = N + (isdef(nJokers) ? nJokers : 0);
  return DeckB.fDeck(params);
}
function makeDeckArea(areaName, numDecks) {
  let parentOfDeckArea = UIS[areaName];
  let deckHeight = 140;
  let deckHeightNeeded = numDecks * deckHeight;
  if (deckHeightNeeded > parentOfDeckArea.h) setAreaHeight(areaName, deckHeightNeeded);
  else deckHeightNeeded = parentOfDeckArea.h;
  let deckAreaName = 'deckArea';
  let mobj = makeArea(deckAreaName, areaName);
  mobj.setBg('seagreen');
  mobj.setBounds(0, 0, 200, deckHeightNeeded, 'px');
  return mobj;
}
function makeDeckMS(oid, o, deck1, areaName, x, y) {
  let id = 'm_t_' + oid;
  if (isdef(UIS[id])) { error('CANNOT create ' + id + ' TWICE!!!!!!!!!'); return; }
  let mobj = new MOBJ();
  mobj.id = id;
  mobj.o = o;
  mobj.deck = deck1;
  mobj.oid = oid;
  mobj.elem = document.createElement('div');
  mobj.elem.id = id;
  mobj.parts.elem = mobj.elem;
  mobj.domType = getTypeOf(mobj.elem);
  mobj.cat = DOMCATS[mobj.domType];
  mobj.idParent = areaName;
  UIS[areaName].children.push(id);
  mobj.isa.deck = true;
  listKey(IdOwner, id[2], id);
  linkObjects(id, oid);
  UIS[id] = mobj;
  return mobj;
}
function makeDeckSuccess(oid, o, areaName) {
  let id = 'm_t_' + oid;
  if (isdef(UIS[id])) { error('CANNOT create ' + id + ' TWICE!!!!!!!!!'); return; }
  let mobj = new MOBJ();
  mobj.id = id;
  mobj.oid = oid;
  mobj.o = o;
  mobj.isa.deck = true;
  mobj.elem = document.createElement('div');
  mobj.elem.id = id;
  mobj.parts.elem = mobj.elem;
  mobj.domType = getTypeOf(mobj.elem);
  mobj.cat = DOMCATS[mobj.domType];
  mobj.idParent = areaName;
  UIS[areaName].children.push(id);
  listKey(IdOwner, id[2], id);
  linkObjects(id, oid);
  UIS[id] = mobj;
  mobj.elem.classList.add('deckBase');
  let num = o.deck_count == 0 ? 0 : o.deck_count / 2 + 1;
  let topmost = makeStapel(mobj.elem, num);
  mobj.topmost = topmost;
  if (topmost != mobj.elem) mobj.parts['topmost'] = topmost;
  return mobj;
}
function makeDefaultAction(boat, areaName) {
  let mobj = new MOBJ();
  let id = 'd_a_' + boat.iTuple;
  if (isdef(UIS[id])) { error('CANNOT create ' + id + ' TWICE!!!!!!!!!'); return null; }
  mobj.id = id;
  let domel = document.createElement('div');
  domel.textContent = boat.text;
  domel.style.cursor = 'pointer';
  mobj.elem = domel;
  mobj.parts.elem = mobj.elem;
  mobj.domType = getTypeOf(domel);
  mobj.cat = DOMCATS[mobj.domType];
  let idParent = areaName;
  mobj.idParent = idParent;
  let parent = UIS[idParent];
  parent.children.push(id);
  mobj.o = boat;
  mobj.isa.boat = true;
  for (const tupleEl of boat.tuple) {
    if (tupleEl.type == 'obj' && isdef(tupleEl.ID)) {
      let oid = tupleEl.ID;
      boat.oids.push(oid);
      linkObjects(id, oid);
    }
  }
  listKey(IdOwner, id[2], id);
  UIS[id] = mobj;
  mobj.attach();
  return mobj;
}
function makeDefaultObject(oid, o, areaName) { return _makeDefault(makeIdDefaultObject(oid), oid, o, areaName, oid + ': ' + o.obj_type); }
function makeDefaultPlayer(oid, o, areaName) { return _makeDefault(makeIdDefaultPlayer(oid), oid, o, areaName, 'player: ' + oid + '(' + getPlayerColorString(oid) + ', ' + getUser(oid) + ')'); }
function makeDefaultPool(fromData) {
  if (nundef(fromData) || isEmpty(fromData.table) && isEmpty(fromData.players)) return {};
  if (nundef(fromData.table)) fromData.table = {};
  let data = jsCopy(fromData.table);
  for (const k in fromData.players) {
    data[k] = jsCopy(fromData.players[k]);
  }
  return data;
}
async function makeDictionaries() {
  let ddd = await route_path_text('../assets/speech/ddAlles.txt');
  console.log(ddd)
  let lines = ddd.split('\n');
  console.log(lines);
  let newLines = [];
  let deDict = {};
  let deNouns = {};
  let edDict = {};
  let edNouns = {};
  for (let i = 0; i < lines.length; i++) {
    let l = lines[i];
    if (startsWith(l, 'German')) console.log(l);
    else if (startsWith(l, 'A ')) console.log(l);
    else {
      newLines.push(l);
      let d = stringBefore(l, ' :');
      let gen = null;
      if (d.includes('{')) {
        let parts = d.split('{');
        d = parts[0].trim();
        gen = stringBefore(parts[1], '}').trim();
        lookupSet(deDict, [d, 'gen'], gen);
        lookupSet(deNouns, [d, 'gen'], gen);
      }
      let elist = stringAfter(l, ': ').split(',').map(x => x.trim());
      for (const e of elist) {
        lookupAddIfToList(deDict, [d, 'e'], e);
        lookupAddIfToList(edDict, [e, 'd'], d);
        if (isdef(gen)) {
          lookupAddIfToList(edNouns, [e, 'd'], d);
          lookupAddIfToList(deNouns, [d, 'e'], e);
        }
      }
    }
  }
  console.log(deDict);
  console.log(edDict);
  downloadTextFile(newLines.join('\n'), 'ddText', ext = 'txt')
  downloadAsYaml(deDict, 'deDict');
  downloadAsYaml(edDict, 'edDict');
  downloadAsYaml(deNouns, 'deNouns');
  downloadAsYaml(edNouns, 'edNouns');
}
function makeDomArea(domel) {
  if (nundef(domel.id)) return;
  let mobj = new MOBJ();
  let id = domel.id;
  mobj.id = id;
  mobj.elem = domel;
  mobj.parts.elem = mobj.elem;
  mobj.domType = getTypeOf(domel);
  mobj.cat = DOMCATS[mobj.domType];
  let idParent = domel.parentNode.id;
  mobj.idParent = idParent;
  let parent = UIS[idParent];
  parent.children.push(id);
  mobj.isAttached = true;
  UIS[id] = mobj;
  listKey(IdOwner, id[2], id);
  return mobj;
}
function makeDragDrop(objElems, dropzoneElems) {
  let dropzones = document.querySelectorAll('.dropzone');
  let droppable = new Draggable.Droppable(
    dropzones,
    {
      draggable: '.draggable',
      dropzone: '.dropzone',
      mirror: { constrainDimensions: true }
    }
  );
  return;
  let droppableOrigin;
  droppable.on('drag:start', (ev) => {
    console.log('drag', droppableOrigin, ev)
  });
  droppable.on('droppable:dropped', (ev) => {
    console.log('drop!', droppableOrigin, ev);
  });
  return droppable;
}
function makeDraggable(elem, dropPos) {
  elem.draggable = true;
  elem.ondragstart = drag;
  if (isdef(dropPos)) elem.dropPosition = dropPos;
}
function makeDraggableInner(elem) {
  elem.setAttribute('draggable', true);
  elem.ondragstart = ev => {
    if (!canAct()) return;
    let id = evToClosestId(ev);
    let source = mBy(id);
    if (isLetterElement(source)) {
      ev.dataTransfer.setData("Text", source.innerHTML);
    }
  }
  mClass(elem, 'draggable');
}
function makeDraggableX(elem, dropPos) {
  elem.draggable = true;
  elem.ondragstart = dragX;
  if (isdef(dropPos)) elem.dropPosition = dropPos;
}
function makeDraggableX2(elem, dropPos) {
  elem.draggable = true;
  elem.ondragstart = dragX2;
  if (isdef(dropPos)) elem.dropPosition = dropPos;
}
function makeDrawingArea(id, idArea, addToUIS = false) {
  if (addToUIS && isdef(UIS[id])) { error('CANNOT create ' + id + ' TWICE!!!!!!!!!'); return; }
  let mobj = new MOBJ();
  mobj.id = id;
  let idParent = idArea;
  mobj.idParent = idArea;
  let parent = UIS[idParent];
  if (parent) parent.children.push(id);
  let parentElem = parent ? parent.elem : document.getElementById(idArea);
  let domel = addSvgg(parentElem, id, { originInCenter: true });
  mobj.w = parent.w;
  mobj.h = parent.h;
  mobj.isAttached = true;
  mobj.elem = domel;
  mobj.parts.elem = mobj.elem;
  mobj.domType = getTypeOf(domel);
  mobj.cat = DOMCATS[mobj.domType];
  mobj.isa.drawingArea = true;
  if (addToUIS) {
    listKey(IdOwner, id[2], id);
    UIS[id] = mobj;
  }
  return mobj;
}
function makeDrawingElement(id, idDrawingArea, addToUIS = false) {
  if (isdef(UIS[id])) {
    error('CANNOT create ' + id + ' TWICE!!!!!!!!!');
    return;
  }
  let mobj = new MOBJ();
  mobj.id = id;
  let domel = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  mobj.elem = domel;
  mobj.parts.elem = mobj.elem;
  mobj.domType = getTypeOf(domel);
  mobj.cat = DOMCATS[mobj.domType];
  let idParent = idDrawingArea;
  mobj.idParent = idParent;
  let parent = UIS[idParent];
  if (parent) parent.children.push(id);
  if (addToUIS) {
    listKey(IdOwner, id[2], id);
    UIS[id] = mobj;
  }
  return mobj;
}
function makeDroppable(target) {
  target.ondragover = allowDrop;
  target.ondrop = drop;
}
function makeDroppableX(target) {
  target.ondragover = allowDrop;
  target.ondrop = dropX;
}
function makeDroppableX2(target) {
  target.ondragover = allowDrop;
  target.ondrop = dropX2;
}
function makeEdge(dParent, v1, v2, dFromEdge, ew = 20) {
  let switched = false;
  if (v1.x == v2.x) {
    if (v1.y > v2.y) { let h = v2; v2 = v1; v1 = h; switched = true; }
    let w = ew / 2;
    let sp = `polygon(${v1.x - w + ew}px ${v1.y + dFromEdge + ew}px, ${v1.x + w + ew}px ${v1.y + dFromEdge + ew}px, ${v2.x + w + ew}px ${v2.y - dFromEdge + ew}px, ${v2.x - w + ew}px ${v2.y - dFromEdge + ew}px)`;
    let de = mDiv(dParent, { position: 'absolute', left: -ew, top: -ew, w: '120%', h: '120%' });
    mClass(de, 'edge');
    mStyle(de, { 'clip-path': sp });
    return mItem(null, { div: de }, { type: 'edge' }, true);
  }
  if (v1.x > v2.x) { let h = v2; v2 = v1; v1 = h; switched = true; }
  let dx = v2.x - v1.x;
  let dy = v2.y - v1.y;
  let m = dy / dx;
  let [x1, y1, x2, y2] = [v1.x, v1.y, v2.x, v2.y];
  let alpha = Math.atan(m);
  let xa = x1 + dFromEdge * Math.cos(alpha);
  let ya = y1 + dFromEdge * Math.sin(alpha);
  let xe = x2 - dFromEdge * Math.cos(alpha);
  let ye = y2 - dFromEdge * Math.sin(alpha);
  let m2 = -1 / m;
  let beta = Math.atan(m2);
  let w = ew / 2;
  let x1t = xa + w * Math.cos(beta);
  let y1t = ya + w * Math.sin(beta);
  let x1b = xa - w * Math.cos(beta);
  let y1b = ya - w * Math.sin(beta);
  let x2t = xe + w * Math.cos(beta);
  let y2t = ye + w * Math.sin(beta);
  let x2b = xe - w * Math.cos(beta);
  let y2b = ye - w * Math.sin(beta);
  let de = mDiv(dParent, { position: 'absolute', left: 0, top: 0, w: '120%', h: '120%' });
  mStyle(de, { 'clip-path': `polygon(${x1t}px ${y1t}px, ${x2t}px ${y2t}px, ${x2b}px ${y2b}px, ${x1b}px ${y1b}px)` });
  mClass(de, 'edge');
  return mItem(null, { div: de }, { type: 'edge' }, true);
}
function makeEdge1(dParent, v1, v2) {
  let poly = get2Points(v1, v2);
  let minx = 100000, miny = 100000, maxx = -100000, maxy = -100000;
  for (const k in poly) {
    let pt = poly[k];
    minx = Math.min(pt.x, minx);
    miny = Math.min(pt.y, miny);
    maxx = Math.max(pt.x, maxx);
    maxy = Math.max(pt.y, maxy);
  }
  let bb = { x: minx, y: miny, w: maxx - minx, h: maxy - miny };
  let de = mDiv(dParent, { position: 'absolute', left: minx, top: miny, w: bb.w, h: bb.h, bg: 'red' });
  let [x1, y1, x2, y2] = [v1.x, v1.y, v2.x, v2.y];
  let stroke = 10;
  let sp = '';
  if (x1 == x2) {
    if (y1 < y2) sp = 'polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)';
    else sp = 'polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)';
  } else if (y1 == y2) {
    sp = 'polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)';
  } else if (x1 < x2 && y1 < y2) {
    sp = `polygon(0% 0%, 0% 20%, 100% 100%, 100% 80%)`;
  } else if (x1 < x2 && y1 > y2) {
    sp = `polygon(0% 100%, 0% 80%, 100% 0%, 100% 20%)`;
  } else if (x1 > x2 && y1 < y2) {
    sp = `polygon(0% 100%, 0% 80%, 100% 0%, 100% 20%)`;
  } else {
    sp = `polygon(0% 0%, 0% 20%, 100% 100%, 100% 80%)`;
  }
  mStyle(de, { 'clip-path': sp });
  let e = mItem(null, { div: de }, { type: 'edge', nodes: [v1.id, v2.id] });
  return e;
}
function makeEdges(pool, board, serverBoard) {
  let serverFieldIds = _setToList(serverBoard.fields).map(x => x._obj);
  board.structInfo.edges = _setToList(serverBoard.edges).map(x => x._obj);
  dhelp = {};
  for (const fid of serverFieldIds) {
    let sfield = pool[fid];
    if (nundef(sfield.edges)) continue;
    let edgeIds = sfield.edges.map(x => x._obj);
    for (const eid of edgeIds) {
      if (!eid) {
        continue;
      } else if (isdef(dhelp[eid])) {
        continue;
      } else {
        let edge = makeBoardElement(eid, pool[eid], board.id, 'edge');
        let el = G.table[eid];
        let n1 = getVisual(el.corners[0]._obj);
        let n2 = getVisual(el.corners[1]._obj);
        edge.memInfo = {
          shape: 'line',
          memType: 'edge',
          x1: n1.memInfo.x,
          y1: n1.memInfo.y,
          x2: n2.memInfo.x,
          y2: n2.memInfo.y,
          x: (n1.x + n2.x) / 2,
          y: (n1.y + n2.y) / 2,
          thickness: 1,
          w: 1,
          h: 1,
        };
        dhelp[eid] = edge;
      }
    }
  }
}
function makeEdgeW(dParent, v1, v2, dFromEdge, ew = 20) {
  mCircle(dParent, v1.x, v1.y, 5, 'red');
  let switched = false;
  if (v1.x == v2.x) {
    if (v1.y > v2.y) { let h = v2; v2 = v1; v1 = h; switched = true; }
    let w = ew / 2;
    let sp = `polygon(${v1.x - w + ew}px ${v1.y + dFromEdge + ew}px, ${v1.x + w + ew}px ${v1.y + dFromEdge + ew}px, ${v2.x + w + ew}px ${v2.y - dFromEdge + ew}px, ${v2.x - w + ew}px ${v2.y - dFromEdge + ew}px)`;
    console.log('sp', sp)
    let de = mDiv(dParent, { position: 'absolute', left: -ew, top: -ew, w: '120%', h: '120%', bg: 'random' });
    mStyle(de, { 'clip-path': sp });
    return de;
  }
  if (v1.x > v2.x) { let h = v2; v2 = v1; v1 = h; switched = true; }
  let dx = v2.x - v1.x;
  let dy = v2.y - v1.y;
  let m = dy / dx;
  let [x1, y1, x2, y2] = [v1.x, v1.y, v2.x, v2.y];
  let alpha = Math.atan(m);
  let xa = x1 + dFromEdge * Math.cos(alpha);
  let ya = y1 + dFromEdge * Math.sin(alpha);
  mCircle(dParent, xa, ya, 10, 'orange');
  let xe = x2 - dFromEdge * Math.cos(alpha);
  let ye = y2 - dFromEdge * Math.sin(alpha);
  mCircle(dParent, xe, ye, 10, 'orange');
  let m2 = -1 / m;
  let beta = Math.atan(m2);
  let w = ew / 2;
  let x1t = xa + w * Math.cos(beta);
  let y1t = ya + w * Math.sin(beta);
  mCircle(dParent, x1t, y1t, 5, 'green');
  let x1b = xa - w * Math.cos(beta);
  let y1b = ya - w * Math.sin(beta);
  mCircle(dParent, x1b, y1b, 5, 'green');
  let x2t = xe + w * Math.cos(beta);
  let y2t = ye + w * Math.sin(beta);
  mCircle(dParent, x2t, y2t, 5, 'violet');
  let x2b = xe - w * Math.cos(beta);
  let y2b = ye - w * Math.sin(beta);
  mCircle(dParent, x2b, y2b, 5, 'violet');
  let de = mDiv(dParent, { position: 'absolute', left: 0, top: 0, w: '120%', h: '120%', bg: 'random' });
  mStyle(de, { 'clip-path': `polygon(${x1t}px ${y1t}px, ${x2t}px ${y2t}px, ${x2b}px ${y2b}px, ${x1b}px ${y1b}px)` });
  return de;
}
function makeElemDraggableTo(elem, target, key) {
  if (isdef(key)) {
    if (nundef(target.ddKeys)) target.ddKeys = [];
    if (nundef(elem.ddKeys)) elem.ddKeys = [];
    addIf(target.ddKeys, key);
    addIf(elem.ddKeys, key);
  }
  if (nundef(elem.id)) elem.id = getUID();
  elem.draggable = true;
  elem.ondragstart = isdef(key) ? dragKey : drag;
  target.ondragover = isdef(key) ? allowDropKey : allowDrop;
  target.ondrop = isdef(key) ? dropKey : drop;
}
function makeElemY(type, idParent, gName, level, { row = undefined, col = undefined, w = 0, h = 0, x = 0, y = 0, x1 = 0, y1 = 0, x2 = 0, y2 = 0, gap = 0, ipal = 0, bg = 0, fg = 0, shape = 'rect', border = 0, thickness = 0 }) {
  let uid = getUID();
  let elem = { id: uid, type: type, parent: idParent, gName: gName, level: level };
  if (row !== undefined) {
    elem.row = row;
  }
  if (col !== undefined) {
    elem.col = col;
  }
  register(elem, uid, type, x, y);
  if (level > 1) {
    elem.w = w - gap;
    elem.h = h - gap;
    elem.x = x;
    elem.y = y;
  }
  if (level > 2) {
    elem.ms = new MS(uid, gName);
  }
  if (level > 3) {
    let ms = elem.ms;
    if (ipal) {
      ms.setbg(getpal(ipal));
    }
    if (bg) ms.setbg(bg);
    if (fg) ms.setfg(fg);
    switch (shape) {
      case 'circle':
        ms.ellipse({ w: elem.w, h: elem.h });
        break;
      case 'hex':
        ms.hex({ w: elem.w, h: elem.h });
        break;
      case 'line':
        let fill = ipal ? getpal(ipal) : fg ? fg : border;
        ms.line({ x1: x1, y1: y1, x2: x2, y2: y2, fill: fill, thickness: thickness });
        break;
      default:
        ms.rect({ w: elem.w, h: elem.h });
        break;
    }
  }
  if (level > 4) {
    let ms = elem.ms;
    switch (shape) {
      case 'circle':
        ms.ellipse({ className: 'overlay', w: elem.w, h: elem.h });
        break;
      case 'hex':
        ms.hex({ className: 'overlay', w: elem.w, h: elem.h });
        break;
      case 'line':
        let fill = ipal ? getpal(ipal) : fg ? fg : border;
        ms.line({ className: 'overlay', x1: x1, y1: y1, x2: x2, y2: y2, thickness: thickness });
        break;
      default:
        ms.rect({ className: 'overlay', w: elem.w, h: elem.h });
        break;
    }
  }
  if (elem.ms && type != 'edge') {
    elem.ms.setPos(x, y);
  }
  return elem;
}
function makeEmoSetIndex() {
  if (isdef(symBySet)) return;
  symBySet = {}; symKeysBySet = {}; symListBySet = {};
  for (const k in emoSets) {
    let set = emoSets[k];
    let name = set.name;
    let f = set.f;
    symBySet[name] = [];
    for (const k1 in symbolDict) {
      let info = symbolDict[k1];
      if (info.type == 'icon') continue;
      let o = info;
      if (nundef(o.group) || nundef(o.subgroups)) continue;
      let passt = f(o);
      if (!passt) continue;
      if (passt) {
        lookupSet(symBySet, [name, k1], info);
        lookupAddToList(symKeysBySet, [name], k1);
        lookupAddToList(symListBySet, [name], info);
      }
    }
  }
  makeGroupSub();
}
function makeExpSequence() {
  G.operand = randomNumber(G.minNum, G.maxNum);
  G.op = chooseRandom(G.ops);
  G.step = G.op == 'minus' ? randomNumber(0, G.operand) : randomNumber(G.minFactor, G.maxFactor);
  G.oop = OPS[G.op];
  G.result = G.oop.f(G.operand, G.step);
  G.seq = [G.operand, G.oop.wr, G.step, '=', G.result];
  return G.seq;
}
function makeFields(pool, board, serverBoard, shape) {
  let serverFieldIds = _setToList(serverBoard.fields).map(x => x._obj);
  board.structInfo.fields = serverFieldIds;
  for (const fid of serverFieldIds) {
    let sField = pool[fid];
    let r = sField.row;
    let c = sField.col;
    let field = makeBoardElement(fid, sField, board.id, 'field');
    field.memInfo = shape == 'hex' ? getHexFieldInfo(board.structInfo, r, c) : getQuadFieldInfo(board.structInfo, r, c);
  }
  board.structInfo.vertices = correctPolys(board.structInfo.fields.map(x => getVisual(x).memInfo.poly), 1);
}
function makeGreyTransparent(ctx, color = 'white', sz = 200) {
  var image = ctx.getImageData(0, 0, sz, sz);
  var imageData = image.data, length = imageData.length;
  let im = imageData;
  const x = 245;
  for (var i = 0; i < length; i += 4) {
    if (im[i] > x && im[i + 1] > x && im[i + 2] > x) {
      im[i + 3] = 0;
    }
  }
  image.data = imageData;
  ctx.putImageData(image, 0, 0);
}
function makeGrid9(d, centerW = '3fr', centerH = '3fr', gap = '2px') {
  d.style.setProperty('--grid_center_w', makeUnitString(centerW, 'fr'));
  d.style.setProperty('--grid_center_h', makeUnitString(centerH, 'fr'));
  d.style.setProperty('--grid-gap', gap);
  d.classList.add('grid9');
  let cells = [];
  for (rows1 = 0; rows1 < 3; rows1++) {
    cells[rows1] = [];
    for (cols1 = 0; cols1 < 3; cols1++) {
      let cell = document.createElement("div");
      cell.innerText = (rows1 + ',' + cols1);
      d.appendChild(cell).className = "grid-item";
      cells[rows1].push(cell);
    }
  }
  return cells;
}
function makeGroupSub() {
  symKeysByGroupSub = {};
  for (const k of symKeysBySet['all']) {
    let info = symbolDict[k];
    if (isEmpty(info.E) || isEmpty(info.D)) lookupAddIfToList(symKeysByGroupSub, ['NA', info.group + '-' + info.subgroups], k);
    else lookupAddIfToList(symKeysByGroupSub, [info.group, info.subgroups], k);
  }
}
function makeHand(key, idParent, color, padding = 4, margin = 4) {
  let mk = makeArea(key, idParent);
  if (SPEC.showCardHandBackground) mk.setBg(isdef(color) ? color : randomColor());
  let dParent = mById(idParent);
  let bParent = getBounds(dParent);
  let areaTitleHeight = SPEC.showAreaNames ? getTextSize('happy', dParent).h : 0;
  let clearBoth = bParent.height > bParent.width;
  let zusatz = 2 * (padding + margin) + areaTitleHeight;
  let hCard = PREFERRED_CARD_HEIGHT ? PREFERRED_CARD_HEIGHT
    : bParent.height ? bParent.height - zusatz
      : 100;
  if (hCard < MIN_CARD_HEIGHT) hCard = MIN_CARD_HEIGHT;
  if (hCard > MAX_CARD_HEIGHT) hCard = MAX_CARD_HEIGHT;
  hParent = hCard + zusatz;
  let hTotal = hParent - 2 * (padding + margin) - areaTitleHeight;
  h = hTotal - 2 * padding;
  if (h > MAX_CARD_HEIGHT) {
    h = MAX_CARD_HEIGHT;
    hTotal = h + 2 * padding;
  }
  let bTitle = { height: 0 };
  if (SPEC.showCardHandName) {
    mk.title(stringAfter(key, '.'));
    bTitle = getBounds(mk.parts.title);
    mk.parts.title.style.setProperty('width', bTitle.width + 'px');
  }
  let hBody = h - bTitle.height;
  mk.body();
  let dBody = mk.parts.body;
  dBody.style.setProperty('height', hBody + 'px');
  let d = mk.elem;
  d.style.setProperty('padding', padding + 'px');
  d.style.setProperty('border-radius', padding + 'px');
  d.style.setProperty('margin', margin + 'px');
  d.style.setProperty('position', 'relative');
  d.style.setProperty('float', 'left');
  if (clearBoth) d.style.setProperty('clear', 'both');
  mk.hCard = hCard;
  mk.collectionKey = key;
  mk.adjustSize = true;
  return mk;
}
function makeHigherOrderGroups() {
  for (const honame in higherOrderEmoSetNames) {
    for (const name of (higherOrderEmoSetNames[honame])) {
      for (const k in symBySet[name]) {
        let info = symbolDict[k];
        lookupSet(symBySet, [honame, k], info);
        lookupAddToList(symKeysBySet, [honame], k);
        lookupAddToList(symListBySet, [honame], info);
      }
    }
  }
  let s = '';
  for (const k in symKeysBySet) {
    s += k + ':' + symKeysBySet[k].length + ', ';
  }
  ensureSymByType();
}
function makeHugeBoardInBoard(num, rowsPerBoard) {
  let r = makeTreeNNEach(num, num);
  let params = { contentwalign: 'center', contenthalign: 'center', orientation: 'w', rows: rowsPerBoard, cols: num / rowsPerBoard };
  let uidRoot = r.tree.uid;
  let root = r.rNodes[uidRoot];
  root.params = params;
  for (const ch of root.children) {
    let n = r.rNodes[ch];
    n.params = params;
  }
  return r;
}
function makeHugeBoardInBoardOld(num, rowsPerBoard) {
  let r = makeTreeNNEach(num, num);
  return r;
  let params = { contentwalign: 'center', contenthalign: 'center', orientation: 'w', rows: rowsPerBoard, cols: num / rowsPerBoard };
  let uidRoot = r.tree.uid;
  let root = r.rNodes[uidRoot];
  root.params = params;
  for (const ch of root.children) {
    let n = r.rNodes[ch];
    n.params = params;
  }
  return r;
}
function makeIdDefaultObject(oid) { return 'd_t_' + oid; }
function makeIdDefaultPlayer(oid) { return 'd_p_' + oid; }
function makeIdInfobox(oid) { return 'i_i_' + oid; }
function makeInfobox(ev, elem, scale) {
  let t = ev.target; while (isdef(t) && t != elem) t = t.parentNode; if (nundef(t)) { console.log('WRONG click', ev.target); return; }
  let di = DA.infobox; if (isdef(di)) {
    let inner = di.innerHTML;
    di.remove();
    DA.infobox = null;
    if (inner == elem.innerHTML) return;
  }
  let r = getRectInt(elem, dTable);
  let d = DA.infobox = mDiv(dTable, {
    bg: 'black', rounding: 10, fz: 24, position: 'absolute',
    w: r.w, h: r.h, left: r.l, top: r.t, transform: `scale(${scale})`
  }, 'dInfoBox', elem.innerHTML);
  d.innerHTML += '<div style="font-size:6px">click to close</div><br>';
  d.onclick = () => { d.remove(); DA.infobox = null; }
}
function makeInnoNumberDiv(n, fz) {
  return `<span style='background:white;color:black;padding:2px 10px;border-radius:50%'>${n}</span>`;
}
function makeInnoSymbolDiv(info, bg, fz = 20) {
  return `<div style='text-align:center;display:inline;background-color:${bg};width:40px;padding:2px ${fz / 2}px;
  font-size:${fz}px;font-family:${info.family}'>${info.text}</div>`;
}
function makeItemDiv(item, options) {
  if (isdef(options.outerStyles) && isdef(options.ifs)) copyKeys(item, options.outerStyles, {}, Object.keys(options.ifs));
  let dOuter = mCreate('div', options.outerStyles, item.id);
  if (isdef(item.textShadowColor)) {
    let sShade = '0 0 0 ' + item.textShadowColor;
    if (options.showPic) {
      options.picStyles['text-shadow'] = sShade;
      options.picStyles.fg = colorFrom('black', options.contrast); //'#00000080' '#00000030' 
    } else {
      options.labelStyles['text-shadow'] = sShade;
      options.labelStyles.fg = colorFrom('black', options.contrast); //'#00000080' '#00000030' 
    }
  }
  let dLabel;
  if (options.showLabels && options.labelTop == true) { dLabel = mText(item.label, dOuter, options.labelStyles); }
  let dPic;
  if (options.showPic) {
    dPic = mDiv(dOuter, { family: item.info.family });
    dPic.innerHTML = item.info.text;
    if (isdef(options.picStyles)) mStyleX(dPic, options.picStyles);
  }
  if (options.showLabels && options.labelBottom == true) { dLabel = mText(item.label, dOuter, options.labelStyles); }
  if (isdef(options.handler)) dOuter.onclick = options.handler;
  iAdd(item, { options: options, div: dOuter, dLabel: dLabel, dPic: dPic });
  if (isdef(item.textShadowColor)) { applyColorkey(item, options); }
  return dOuter;
}
function makeItemDivs(items, options) { for (let i = 0; i < items.length; i++) { makeItemDiv(items[i], options) } }
function makeItemHintable(item) {
  let d = iDiv(item);
  let dov = mDiv100(d);
  let rect = getRect(d);
  mStyleX(dov, { position: 'absolute', w: rect.w, h: rect.h })
  iAdd(item, { overlay: dov });
  dov.style.userSelect = 'none';
}
function makeKeyValueTable(data) {
  let cols = 2;
  let rows = data.length;
  let res = `<table>`;
  for (const k in data) {
    res += `<tr><th>${k}</th><td>${data[k]}</td></tr>`;
  }
  res += `</table>`;
  let res1 = (elem = new DOMParser().parseFromString(res, 'text/html').body.firstChild);
  return res1;
}
function makeLineSegment(mobj, o, msLoc, sz, color) {
  let [x1, y1, x2, y2] = msLoc.getEndPointsOfLineSegmentOfLength(sz);
  mobj.line({ cap: 'round', thickness: msLoc.thickness, x1: x1, y1: y1, x2: x2, y2: y2 }).setBg(color).attach();
  mobj.line({ className: 'overlay', cap: 'round', thickness: msLoc.thickness, x1: x1, y1: y1, x2: x2, y2: y2 });
}
function makeLogArea(plid) {
  let mobj = new MOBJ();
  let idParent = 'a_d_log';
  let id = idParent + '_' + plid;
  mobj.id = id;
  let el = document.createElement('div');
  el.style.position = 'absolute';
  el.style.left = '0px';
  el.style.top = '0px';
  el.style.width = '100%';
  el.style.height = '100%';
  el.style.overflowY = 'auto';
  mobj.elem = el;
  mobj.elem.id = id;
  mobj.parts.elem = mobj.elem;
  mobj.domType = getTypeOf(mobj.elem);
  mobj.cat = DOMCATS[mobj.domType];
  mobj.idParent = idParent;
  let parent = UIS[idParent];
  parent.children.push(id);
  mobj.attach();
  UIS[id] = mobj;
  listKey(IdOwner, id[2], id);
  return mobj;
}
function makeMainBoardElementVisual(oid, o) {
  let id = 'm_t_' + oid;
  if (isdef(UIS[id])) { error('CANNOT create ' + id + ' TWICE!!!!!!!!!'); return; }
  let mobj = new MOBJ();
  mobj.id = id;
  let domel = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  mobj.elem = domel;
  mobj.parts.elem = mobj.elem;
  mobj.domType = getTypeOf(domel);
  mobj.cat = DOMCATS[mobj.domType];
  let locElem = getVisual(o.loc._obj);
  let parent = UIS[locElem.idParent];
  let idParent = parent.id;
  mobj.idParent = idParent;
  parent.children.push(id);
  mobj.o = o;
  mobj.isa.movable = 'loc';
  linkObjects(id, oid);
  listKey(IdOwner, id[2], id);
  UIS[id] = mobj;
  let color = S.settings.useColorHintForObjects ? getColorHint(o) : randomColor();
  if (nundef(color)) color = 'black';
  let boardElemType = getBoardElementStandardType(locElem);
  let sizeInfo = S.settings.pieceSizeRelativeToLoc[boardElemType];
  let baseValue = locElem[sizeInfo[0]];
  let percent = Number(sizeInfo[1]);
  let sz = (baseValue * percent) / 100;
  if (boardElemType != 'edge') {
    makePictoPiece(mobj, o, sz, color)
    mobj.setPos(locElem.x, locElem.y);
  } else {
    makeLineSegment(mobj, o, locElem, sz, color);
  }
  mobj.attach();
  return mobj;
}
function makeMainPlayer(oid, o, areaName) {
  let id = 'm_p_' + oid;
  if (isdef(UIS[id])) { error('CANNOT create ' + id + ' TWICE!!!!!!!!!'); return; }
  let mobj = new MOBJ();
  mobj.id = id;
  let title = 'player: ' + oid + '(' + getPlayerColorString(oid) + ', ' + getUser(oid) + ')';
  let domel = document.createElement('div');
  domel.style.cursor = 'default';
  mobj.elem = domel;
  mobj.parts.elem = mobj.elem;
  mobj.domType = getTypeOf(domel);
  mobj.cat = DOMCATS[mobj.domType];
  let idParent = areaName;
  mobj.idParent = idParent;
  let parent = UIS[idParent];
  parent.children.push(id);
  let sTitle = title;
  let color = G.playersAugmented[oid].color;
  mobj.title(sTitle, 'title', color);
  mobj.o = o;
  mobj.isa.player = true;
  linkObjects(id, oid);
  listKey(IdOwner, id[2], id);
  UIS[id] = mobj;
  mobj.attach();
  return mobj;
}
function makeMainVisual(oid, o) {
  if (!('loc' in o) || !isBoardElement(o.loc._obj)) return null;
  let id = 'm_t_' + oid;
  if (isdef(UIS[id])) { console.log('CANNOT create ' + id + ' TWICE!!!!!!!!!'); return; }
  let ms = new RSG();
  ms.id = id;
  let domel = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  ms.elem = domel;
  ms.parts.elem = ms.elem;
  ms.domType = getTypeOf(domel);
  ms.cat = DOMCATS[ms.domType];
  let locElem = getVisual(o.loc._obj);
  let parent = UIS[locElem.idParent];
  let idParent = parent.id;
  ms.idParent = idParent;
  parent.children.push(id);
  ms.o = o;
  ms.isa.movable = 'loc';
  linkObjects(id, oid);
  listKey(IdOwner, id[2], id);
  UIS[id] = ms;
  let color = getColorHint(o);
  let [w, h] = locElem.isa.corner ? [locElem.w / 2, locElem.h / 2]
    : locElem.isa.field ? [locElem.w / 4, locElem.h / 4] : [locElem.thickness + 2, locElem.thickness + 2];
  let [x, y] = [locElem.x, locElem.y];
  ms.ellipse({ w: w, h: h, fill: color }); ms.setPos(x, y); ms.attach();
  return ms;
}
function MakeMove(move) {
  var from = FROMSQ(move);
  var to = TOSQ(move);
  var side = brd_side;
  brd_history[brd_hisPly].posKey = brd_posKey;
  if ((move & MFLAGEP) != 0) {
    if (side == COLOURS.WHITE) {
      ClearPiece(to - 10);
    } else {
      ClearPiece(to + 10);
    }
  } else if ((move & MFLAGCA) != 0) {
    switch (to) {
      case SQUARES.C1:
        MovePiece(SQUARES.A1, SQUARES.D1);
        break;
      case SQUARES.C8:
        MovePiece(SQUARES.A8, SQUARES.D8);
        break;
      case SQUARES.G1:
        MovePiece(SQUARES.H1, SQUARES.F1);
        break;
      case SQUARES.G8:
        MovePiece(SQUARES.H8, SQUARES.F8);
        break;
      default: break;
    }
  }
  if (brd_enPas != SQUARES.NO_SQ) HASH_EP();
  HASH_CA();
  brd_history[brd_hisPly].move = move;
  brd_history[brd_hisPly].fiftyMove = brd_fiftyMove;
  brd_history[brd_hisPly].enPas = brd_enPas;
  brd_history[brd_hisPly].castlePerm = brd_castlePerm;
  brd_castlePerm &= CastlePerm[from];
  brd_castlePerm &= CastlePerm[to];
  brd_enPas = SQUARES.NO_SQ;
  HASH_CA();
  var captured = CAPTURED(move);
  brd_fiftyMove++;
  if (captured != PIECES.EMPTY) {
    ClearPiece(to);
    brd_fiftyMove = 0;
  }
  brd_hisPly++;
  brd_ply++;
  if (PiecePawn[brd_pieces[from]] == BOOL.TRUE) {
    brd_fiftyMove = 0;
    if ((move & MFLAGPS) != 0) {
      if (side == COLOURS.WHITE) {
        brd_enPas = from + 10;
      } else {
        brd_enPas = from - 10;
      }
      HASH_EP();
    }
  }
  MovePiece(from, to);
  var prPce = PROMOTED(move);
  if (prPce != PIECES.EMPTY) {
    ClearPiece(to);
    AddPiece(to, prPce);
  }
  brd_side ^= 1;
  HASH_SIDE();
  if (SqAttacked(brd_pList[PCEINDEX(Kings[side], 0)], brd_side)) {
    TakeMove();
    return BOOL.FALSE;
  }
  return BOOL.TRUE;
}
function makemove(t) {
  let myMoves = t.moves[Session.cur_user];
  Session.cur_step = myMoves.length + 1;
  myMoves.push(randomNumber(1000, 2000));
  Session.cur_move = arrLast(myMoves);
  DA.next = get_play_dep(Session.cur_step, Session.cur_move);
  save_tables();
}
function makeNewLayout(g1) {
  let nodes = g1.getNodes();
  let x = 10; let y = 10;
  for (n of nodes) {
    n.position({ x: x, y: y });
    x += 50; y += 50; if (y > 250) { y = 10; } if (x > 550) { x = 10; }
  }
}
async function makeNewSyms() {
  let etext = await route_path_text('../assets/speech/di/_wE.txt');
  let ew = etext.split('\n');
  console.log('eng', ew);
  let dtext = await route_path_text('../assets/speech/di/_wD.txt');
  let ftext = await route_path_text('../assets/speech/di/_wF.txt');
  let stext = await route_path_text('../assets/speech/di/_wS.txt');
  let ctext = await route_path_text('../assets/speech/di/_wC.txt');
  let dw = dtext.split('\n');
  let fw = ftext.split('\n');
  let sw = stext.split('\n');
  let cw = ctext.split('\n');
  let edict = {};
  for (let i = 0; i < ew.length; i++) {
    edict[ew[i]] = { E: ew[i], D: dw[i], F: fw[i], S: sw[i], C: cw[i] };
  }
  let symNew = {};
  for (const k in symbolDict) {
    let info = symbolDict[k];
    let inew = {};
    for (const k1 of ['key', 'hexcode', 'hex', 'family', 'text', 'type', 'isDuplicate']) {
      if (isdef(info[k1])) inew[k1] = info[k1];
    }
    inew.w = info.w;
    inew.h = info.h;
    let wk = inew.E = isdef(info.bestE) ? info.bestE : k;
    let e = edict[wk];
    if (isdef(e)) {
      inew.D = e.D;
      inew.F = e.F;
      inew.S = e.S;
      inew.C = e.C;
    }
    if (nundef(inew.D) && isdef(info.bestD)) inew.D = info.bestD;
    symNew[k] = inew;
    console.log('key', k, inew)
  }
  return symNew;
}
function makeNumberSpan(n, bg, fg, fz, rounding = '50%') {
  return `<span style='font-size:${fz}px;background:${bg};color:${fg};padding:0px 5px;border-radius:${rounding}'>${n}</span>`;
}
function makePage() {
  var dMain = document.getElementById('dMain');
  mStyle(dMain, { bg: 'indigo' });
  let [dHeaderLeft, dTitle, dHeaderRight] = std3title(dMain, 'Aristocracy', { family: 'AlgerianRegular' });
  let [dLeft, dMiddle, dRight] = std3fold(dMain);
  let dFooter = mDiv(dMain, { bg: '#00000050' }, 'dFooter', 'footer');
  let bMenuLeft = stdMenuButton(dHeaderLeft);
  stdSidebarController(bMenuLeft, 'dLeft');
  let bMenuRight = stdMenuButton(dHeaderRight);
  stdSidebarController(bMenuRight, 'dRight');
  return dMiddle;
}
function makePerleDiv(item, outerStyles, imgStyles, labelStyles, labelPos = null, magnify = true, handler = null, useNewImage = false) {
  let defOuterStyles = {
    display: 'inline-flex', 'flex-direction': 'column',
    'justify-content': 'center', 'align-items': 'center', 'vertical-align': 'top',
    padding: 0, box: true
  };
  addKeys(defOuterStyles, outerStyles);
  let dOuter = mCreate('div', outerStyles);
  if (labelPos && nundef(item.label)) { item.label = item.text.toLowerCase(); }
  let dLabel;
  let [w, h, fz] = [labelStyles.wmax, labelStyles.hmax, labelStyles.fz];
  let sz = simpleFit(item.label, w, h, fz);
  labelStyles = sz;
  dLabel = mTextFit(item.label, { wmax: w, hmax: h }, null, labelStyles);
  if (labelPos[0] == 't') dLabel = mText(item.label, dOuter, labelStyles);
  let x;
  imgStyles.rounding = '50%';
  if (useNewImage) {
    imgStyles.rounding = '50%';
    x = mAppend(dOuter, NEWLY_CREATED_IMAGE);
    mStyleX(x, imgStyles);
  } else {
    x = mImg(item.path, dOuter, imgStyles);
  }
  if (magnify) {
    x.onmouseenter = ev => { if (ev.ctrlKey) mMagnify(x, item); }
    x.onmouseleave = ev => mCancelMagnify(x, item.path);
  }
  if (labelPos[0] == 'b') dLabel = mText(item.label, dOuter, labelStyles);
  if (isdef(handler)) dOuter.onclick = ev => handler(ev, item);
  item.type = 'perle'; dOuter.id = iRegister(item);
  iAdd(item, { div: dOuter, dLabel: dLabel, dImg: x });
  return dOuter;
}
function makePictoCard(oid, o) {
  let symbolKeyPropName = 'name';
  let key = _getSymbolKey(o[symbolKeyPropName]);
  let symbol = symbols[key];
  let color = symbolColors[key];
  let d = document.createElement('div');
  $(d).on("mouseenter", function () { magnifyFront(this.id); });
  $(d).on("mouseleave", function () { minifyBack(this.id); });
  d.innerHTML = 'hallo';
  d.style.position = 'absolute';
  let dx = 0;
  d.style.left = '' + dx + 'px';
  d.style.top = '0px';
  let ch = iconChars[symbol];
  let text = String.fromCharCode('0x' + ch);
  let family = (ch[0] == 'f' || ch[0] == 'F') ? 'pictoFa' : 'pictoGame';
  d.innerHTML = `
    <div class="cardCatan">
      <p style='font-size:22px;'>${o.name}</p>
      <div class="cardCenter">
        <div class="circular" style='background:${color}'><span style='color:white;font-size:70px;font-weight:900;font-family:${family}'>${text}</span></div>
      </div>
      <hr>
      <p style='font-size:20px;'>${o.desc}</p>
      <div style='color:${color};position:absolute;left:8px;top:8px;width:35px;height:35px'>
        <span style='font-family:${family}'>${text}</span>
      </div>
    </div>
  `;
  return d;
}
function makePictoCardDomel(oCard) {
  if (lookup(SPEC, ['typeMappings', 'card'])) {
    for (const k in SPEC.typeMappings.card) {
      oCard[k] = oCard[SPEC.typeMappings.card[k]];
    }
  }
  let el = cardFace(oCard);
  return el;
}
function makePictoPiece(mobj, o, sz, color) {
  let [w, h] = [sz, sz];
  let sym = o.obj_type;
  if (sym in S.settings.symbols) { sym = S.settings.symbols[sym]; }
  if (!(sym in iconChars)) {
    symNew = Object.keys(iconChars)[randomNumber(5, 120)];
    S.settings.symbols[sym] = symNew;
    sym = symNew;
  }
  mobj.ellipse({ w: w, h: h, fill: color, alpha: .3 });
  let pictoColor = color == 'black' ? randomColor() : color;
  mobj.pictoImage(sym, pictoColor, sz * 2 / 3);
}
function makePlayermodeReadOnly(mode) {
  let el = getPlayermodeRadio(mode);
  el = document.getElementById('c_b_mm_' + mode);
  $(el).attr({ 'disabled': true, });
  document.getElementById('span_' + mode).style.color = 'silver';
}
function makePlayerReadOnly(i) {
  let el = getPlayerRadio(i);
  $(el).attr({ 'disabled': true, });
}
function makePlayerTypeReadOnlyX(i) {
  let prefixPl = 'c_b_mm_pl';
  let pltId = prefixPl + 't' + i;
  document.getElementById(pltId).readOnly = true;
}
function makePlayerTypesReadOnly() {
  for (let i = 1; i <= 8; i += 1) {
    makePlayerTypeReadOnly(i);
  }
}
function makePool(cond, source, R) {
  if (nundef(cond)) return [];
  else if (cond == 'all') return source;
  let pool = [];
  for (const oid of source) {
    let o = R.getO(oid);
    if (!evalConds(o, cond)) continue;
    pool.push(oid);
  }
  return pool;
}
function makeRandomElement() {
  let domel = document.createElement('div');
  mStyle(domel, { width: 100, height: 100, 'background-color': 'red', position: 'fixed', left: 0, top: 0 });
  return domel;
}
function makeRandomTree() {
  let r = { rNodes: {}, uiNodes: {}, defs: DEFS };
  let n = r.tree = addManual00Node(null, r);
  recPopulateTree(n, r, 3);
  return r;
}
function makeRect(x, y, w, h) { let r = { x: x, y: y, w: w, h: h }; extendRect(r); return r; }
function makeRefLinkDiv(val, refs, prop, prefix) {
  let cl = prefix + '_r_' + getUID(); let ref = { oids: [val[prop]], id: cl }; refs.push(ref);
  let sval = `<div id=${cl} class='up10 hallo'>${val[prop].toString()}</div>`;
  return sval;
}
function makeRefLinkDiv4_obj(val, refs) { return makeRefLinkDiv(val, refs, '_obj', 't'); }
function makeRefLinkDiv4_player(val, refs) { return makeRefLinkDiv(val, refs, '_player', 'p'); }
function makeRefLinkDiv4ListOf_obj(val, refs, className = 'up10 hallo') {
  return makeRefLinkDivList(val, refs, '_obj', 't', className);
}
function makeRefLinkDiv4ListOf_player(val, refs, className = 'up10 hallo') {
  return makeRefLinkDivList(val, refs, '_player', 'p', className);
}
function makeRefLinkDiv4MatrixOf_obj(val, refs) {
  let rows = val._ndarray;
  let sval = `<div>`;
  let rowClass = 'up2 hallo';
  for (const row of rows) {
    sval += makeRefLinkDiv4ListOf_obj(row, refs, rowClass) + '<br>';
    rowClass = 'hallo';
  }
  sval += '</div>';
  return sval;
}
function makeRefLinkDivList(val, refs, prop, prefix, className = 'up10 hallo') {
  let cl = prefix + '_r_' + getUID(); let ref = { oids: val.filter(x => isdef(x)).map(x => x[prop]), id: cl }; refs.push(ref);
  let sval = `<div id=${cl} class='${className}'>${val.map(x => !x ? '_' : x[prop]).toString()}</div>`;
  return sval;
}
function makeRefs(idParent, refs) {
  for (const ref of refs) {
    let id = ref.id;
    let oids = ref.oids;
    if (isdef(UIS[id])) { error('CANNOT create ' + id + ' TWICE!!!!!!!!!'); return; }
    let mobj = new MOBJ();
    mobj.id = id;
    let domel = document.getElementById(id);
    mobj.elem = domel;
    mobj.parts.elem = mobj.elem;
    mobj.domType = getTypeOf(domel);
    mobj.cat = DOMCATS[mobj.domType];
    mobj.idParent = idParent;
    let parent = UIS[idParent];
    parent.children.push(id);
    mobj.isAttached = true;
    mobj.isa.ref = true;
    mobj.o = ref.oids;
    for (const oid of ref.oids) linkObjects(id, oid);
    listKey(IdOwner, id[2], id);
    UIS[id] = mobj;
  }
}
function makeRoot() {
  let mobj = new MOBJ();
  let id = 'R_d_root';
  mobj.id = id;
  mobj.elem = document.getElementById(id);
  mobj.domType = getTypeOf(mobj.elem);
  mobj.IdParent = null;
  mobj.isAttached = true;
  UIS[id] = mobj;
  return mobj;
}
function makeRows(d, rows, cols, gap = '2px') {
  d.style.setProperty('--grid-rows', rows);
  d.style.setProperty('--grid-cols', cols);
  d.style.setProperty('--grid-gap', gap);
  for (cols = 0; cols < (rows * cols); cols++) {
    let cell = document.createElement("div");
    cell.innerText = (cols + 1);
    d.appendChild(cell).className = "grid-item";
  };
};
function makeSidebar00(d, d1, d2) {
  mStyleX(d1, { h: '100%', w: 100, position: 'absolute', z: 1, top: 0, left: 0, overflow: 'hidden', transition: '0.5s' });
  mStyleX(d2, { maleft: 100, h: '100%', box: true, transition: '0.5s' }, null, null)
  d2.onclick = () => {
    mToggle(d1, 'width', 0, 100); mToggle(d2, 'margin-left', 0, 100);
  }
}
function makeSimpleString(d) {
  show(d);
  let html = '';
  for (const node of d.childNodes) { if (isdef(node.innerHTML)) html += node.innerHTML; else html += node.nodeValue; }
  d.innerHTML = html;
}
function makeSimplestTree() {
  let r = { rNodes: {}, uiNodes: {}, defs: DEFS };
  let n = r.tree = addManual00Node(null, r);
  addManual00Node(n, r);
  return r;
}
function makeSimpleTree(numChildren = 2) {
  let r = { rNodes: {}, uiNodes: {}, defs: DEFS };
  let n = r.tree = addManual00Node(null, r);
  for (let i = 0; i < numChildren; i++) addManual00Node(n, r);
  return r;
}
function makeStapel(elem, n) {
  let parent = elem;
  for (let i = 1; i <= n; i++) {
    let dummy = document.createElement('div');
    elem.appendChild(dummy);
    dummy.classList.add('cardBack');
    elem = dummy;
  }
  return elem;
}
function makeString(obj, prop, maxlen = 50, isStart = true) {
  let s = prop + ':';
  if (prop in obj) {
    let s1 = JSON.stringify(obj[prop]);
    if (maxlen > 0) {
      s += isStart ? s1.substring(0, maxlen) : s1.substring(s.length - maxlen);
    } else {
      s += s1;
    }
  } else {
    s += ' not present';
  }
  return s;
}
function makeStrings(obj, props, maxlen = 50, isStart = true) {
  strs = props.map(x => makeString(obj, x)).join('\n');
  return strs;
}
function makeSurePlayerColorsAreContrasting(human, ai) {
  ai.color = RED;
}
function makeSvg(w, h) {
  const svg1 = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg1.setAttribute('width', w);
  svg1.setAttribute('height', h);
  return svg1;
}
function makeSymbolSpan(info, bg, fg, fz, rounding = '50%') {
  let patop = Math.min(2, fz * .2);
  let pad = '5% 10%'; pad = '3px 5px'; pad = `${patop}px ${patop * 2}px`;
  if (info.key == 'queen-crown') pad = `${patop}px ${patop}px ${1}px ${patop}px`;
  else if (info.key == 'leaf') pad = `${1}px ${patop}px ${patop}px ${patop}px`;
  else if (info.key == 'white-tower') pad = `${patop}px ${patop * 2}px ${patop - 1}px ${patop * 2}px`;
  return `<div style='box-sizing:border-box;padding:${pad};min-height:${fz + 3}px;display:inline-block;font-family:${info.family};font-size:${fz}px;background:${bg};color:${fg};border-radius:${rounding}'>${info.text}</div>`;
}
function makeTable(tableName, rowHeaders, colHeaders) {
  let cols = colHeaders.length + 1;
  let rows = rowHeaders.length + 1;
  let sh = `<table id='${tableName}'><tr><th></th>`;
  for (const ch of colHeaders) {
    sh += `<th id='${ch}Header'>${ch}</th>`;
  }
  sh += `</tr>`;
  for (const rh of rowHeaders) {
    sh += `<tr id='${rh}${tableName}'><th>${rh}</th>`;
    for (const ch of colHeaders) {
      sh += `<td id='${rh}${ch}'>0</td>`;
    }
    sh += `</tr>`;
  }
  sh += `</table>`;
  let res = (elem = new DOMParser().parseFromString(sh, 'text/html').body.firstChild);
  return res;
}
function makeTableTreeX(fStruct, { presentationStrategy, fContent, fType, autoType, positioning = 'none', params } = {}) {
  R = fStruct();
  if (isdef(params)) { for (const uid in params) { R.rNodes[uid].params = params[uid]; } }
  if (isdef(autoType)) {
    for (const uid in R.rNodes) {
      let v = R.rNodes[uid];
      let val = autoType;
      if (!val) delete v.type; else v.type = val;
    }
  }
  if (isdef(fType)) {
    for (const uid in R.rNodes) {
      let v = R.rNodes[uid];
      let val = fType(v, R);
      if (!val) delete v.type; else v.type = val;
    }
  }
  if (isdef(fContent)) {
    for (const uid in R.rNodes) {
      let v = R.rNodes[uid];
      let val = fContent(v, R);
      if (!val) delete v.content; else v.content = val;
    }
  }
  let d = mBy('table');
  d.style.position = 'relative';
  R.baseArea = 'table';
  recUiTestX(R.tree, R);
  let root = R.uiNodes[R.tree.uid];
  if (positioning == 'random') {
    recPosRandomUiTreeX(R.tree.uid, R, { wmax: 6, hmax: 4, xmax: 50, ymax: 25, granularity: 10 });
    delete root.params.size;
    delete root.params.pos;
  } else if (positioning == 'regular') {
    recPosRegularUiTree(R.tree.uid, R);
    delete root.params.size;
    delete root.params.pos;
  } else {
  }
  R.presentationStrategy = isdef(presentationStrategy) ? presentationStrategy : R.defs.defaultPresentationStrategy;
  return R;
}
function makeTestButton(caption, func, container) {
  let b = document.createElement('button')
  b.textContent = capitalize(caption);
  container.appendChild(b)
  b.addEventListener('click', func);
  return b;
}
function makeTree33() {
  let r = { rNodes: {}, uiNodes: {}, defs: DEFS };
  let n = r.tree = addManual00Node(null, r);
  let n1;
  for (let i = 0; i < 3; i++) {
    n1 = addManual00Node(n, r);
  }
  for (let i = 0; i < 3; i++) {
    addManual00Node(n1, r);
  }
  return r;
}
function makeTree332x2() {
  let r = { rNodes: {}, uiNodes: {}, defs: DEFS };
  let n = r.tree = addManual00Node(null, r);
  let n1;
  for (let i = 0; i < 3; i++) {
    n1 = addManual00Node(n, r);
  }
  let n2, n3;
  for (let i = 0; i < 3; i++) {
    let nChild = addManual00Node(n1, r);
    if (i == 0) n2 = nChild;
    else if (i == 2) n3 = nChild;
  }
  for (let i = 0; i < 2; i++) { addManual00Node(n2, r); }
  for (let i = 0; i < 2; i++) { addManual00Node(n3, r); }
  return r;
}
function makeTreeNN(num1, num2) {
  let r = { rNodes: {}, uiNodes: {}, defs: DEFS };
  let n = r.tree = addManual00Node(null, r);
  let n1;
  for (let i = 0; i < num1; i++) {
    n1 = addManual00Node(n, r);
  }
  for (let i = 0; i < num2; i++) {
    addManual00Node(n1, r);
  }
  return r;
}
function makeTreeNNEach(num1, num2) {
  let r = { rNodes: {}, uiNodes: {}, defs: DEFS };
  let n = r.tree = addManual00Node(null, r);
  for (let i = 0; i < num1; i++) {
    let n1 = addManual00Node(n, r);
    for (let j = 0; j < num2; j++) {
      addManual00Node(n1, r);
    }
  }
  return r;
}
function makeUnitString(nOrString, unit = 'px', defaultVal = '100%') {
  if (nundef(nOrString)) return defaultVal;
  if (isNumber(nOrString)) nOrString = '' + nOrString + unit;
  return nOrString;
}
function makeUserAvatar(username) {
  let a = { username: username };
  let d = mDiv(document.body, { rounding: '50%', align: 'center', position: 'fixed', w: 30, h: 30, fz: 25, bg: 'random', fg: 'contrast' }, 'd' + username);
  d.innerHTML = username[0];
  d.style.zIndex = 20;
  Avatars[username] = d;
  return d;
}
function MakeUserMove() {
  if (UserMove.from != SQUARES.NO_SQ && UserMove.to != SQUARES.NO_SQ) {
    console.log("User Move:" + PrSq(UserMove.from) + PrSq(UserMove.to));
    var parsed = ParseMove(UserMove.from, UserMove.to);
    DeselectSq(UserMove.from);
    DeselectSq(UserMove.to);
    console.log("Parsed:" + parsed);
    if (parsed != NOMOVE) {
      MakeMove(parsed);
      MoveGUIPiece(parsed);
      CheckAndSet();
      PreSearch();
    } else {
      ShowChessMessage('illegal move!', 1000);
    }
    UserMove.from = SQUARES.NO_SQ;
    UserMove.to = SQUARES.NO_SQ;
  }
}
function makeVisual(mobj, x, y, w, h, color, shape, { x1, y1, x2, y2 } = {}) {
  if (shape == 'circle') {
    mobj.ellipse({ w: w, h: h }).ellipse({ className: 'overlay', w: w, h: h });
    mobj.setPos(x, y);
  } else if (shape == 'hex') {
    mobj.hex({ w: w, h: h }).hex({ className: 'overlay', w: w, h: h });
    mobj.setPos(x, y);
  } else if (shape == 'quad' || shape == 'rect') {
    mobj.rect({ w: w, h: h }).rect({ className: 'overlay', w: w, h: h });
    mobj.setPos(x, y);
  } else if (shape == 'triangle') {
    mobj.triangle({ w: w, h: h }).triangle({ className: 'overlay', w: w, h: h });
    mobj.setPos(x, y);
  } else if (shape == 'line') {
    let thickness = w;
    let fill = color;
    mobj.line({ className: 'ground', x1: x1, y1: y1, x2: x2, y2: y2, fill: fill, thickness: thickness })
      .line({ className: 'overlay', x1: x1, y1: y1, x2: x2, y2: y2, thickness: thickness, });
  } else {
    mobj[shape]({ className: 'ground', w: w, h: h });
    mobj[shape]({ className: 'overlay', w: w, h: h });
    mobj.setPos(x, y);
  }
  mobj.setBg(color, shape != 'line');
  mobj.orig.bg = color;
  mobj.originalBg = color;
  mobj.orig.shape = shape;
  mobj.originalSize = { w: w, h: h };
  mobj.orig.w = w;
  mobj.orig.h = h;
  return mobj;
}
function makeVisualsForHexboard(boardInfo) {
  let infos = boardInfo.items;
  let sym = chooseRandom(getAnimals());
  let items = [];
  for (const info of infos) {
    let item = drawText(info.trow + ',' + info.tcol, info.pt);
    if (info.isHexCenter) mStyle(iDiv(item), { bg: 'pink' })
    items.push(item);
  }
}
async function makeWordProblemsDict() {
  let wp = await route_path_text('../assets/math/hallo.txt');
  wp = wp.split('*');
  wp.splice(0, 1);
  let wpDict = {}; let wpList = [];
  for (const line of wp) {
    let index = firstNumber(line);
    let rest = stringAfter(line, '.');
    let title = stringBefore(rest, ':').trim();
    let sol = firstNumber(stringAfter(rest, '@'));
    let text = stringBetween(rest, ':', '@').trim();
    let nums = allNumbers(text);
    let inum = 0;
    let ersetzer = { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, g: 7, h: 8, i: 9 };
    let kers = Object.keys(ersetzer);
    if (nums) {
      for (const n of nums) {
        let s = n.toString();
        let i = s.indexOf(text);
        let len = s.length;
        text = text.replace(s, '{N' + kers[inum] + '}');
        inum += 1;
      }
    }
    for (let j = 0; j < inum; j++) {
      let s = '{N' + kers[j];
      let by = '{N' + ersetzer[kers[j]];
      text = replaceAllSpecialChars(text, s, by);
    }
    let iname = 1;
    for (const name of PersonNames) {
      if (text.includes(name)) {
        text = replaceAll(text, name, '{P' + iname + '}');
        iname += 1;
      }
    }
    let p = { index: index, title: title, sol: sol, text: text };
    wpList.push(p);
    if (startsWith(title, 'Adding')) {
      lookupAddIfToList(wpDict, ['plus'], p);
      delete p.sol;
    }
  }
  downloadAsYaml(wpList, 'wp');
  console.log('dict', wpDict);
  downloadAsYaml(wpDict, 'wp');
  return wpDict;
}
function maLayout(pics, dParent) {
  mClass(dParent, 'flexWrap');
  let numPics = pics.length;
  let rows = Math.sqrt(numPics);
  rows = Math.floor(rows);
  let cols = Math.ceil(numPics / rows);
  let [pictureSize, picsPerLine] = calcDimsAndSize(cols, rows);
  clearElement(dParent);
  let i = 0;
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      maResizePic(pics[i], dParent, pictureSize)
      i += 1;
      if (i >= pics.length) return;
    }
    mLinebreak(dParent);
  }
}
function mAnimate(elem, prop, valist, callback, msDuration = 1000, easing = 'cubic-bezier(1,-0.03,.86,.68)', delay = 0, forwards = 'none') {
  let kflist = [];
  for (const perc in valist) {
    let o = {};
    let val = valist[perc];
    o[prop] = isString(val) || prop == 'opacity' ? val : '' + val + 'px';
    kflist.push(o);
  }
  let opts = { duration: msDuration, fill: forwards, easing: easing, delay: delay };
  let a = toElem(elem).animate(kflist, opts);
  if (isdef(callback)) { a.onfinish = callback; }
  return a;
}
function mAnimateList(elem, ogoal, callback, msDuration = 1000, easing = 'cubic-bezier(1,-0.03,.86,.68)', delay = 0) {
  for (const k in ogoal) {
    ogoal[k] = isString(ogoal[k]) || k == 'opacity' ? ogoal[k] : '' + ogoal[k] + 'px';
  }
  let kflist = [ogoal];
  let opts = { duration: msDuration, fill: 'forwards', easing: easing, delay: delay };
  let a = toElem(elem).animate(kflist, opts);
  if (isdef(callback)) { a.onfinish = callback; }
  return a;
}
function mAnimateTo(elem, prop, val, callback, msDuration = 1000, easing = 'cubic-bezier(1,-0.03,.86,.68)', delay = 0) {
  let o = {};
  o[prop] = isString(val) || prop == 'opacity' ? val : '' + val + 'px';
  let kflist = [o];
  let opts = { duration: msDuration, fill: 'forwards', easing: easing, delay: delay };
  let a = toElem(elem).animate(kflist, opts);
  if (isdef(callback)) { a.onfinish = callback; }
  return a;
}
function map_add_layer(key = 'osm') {
  let layer;
  if (key == 'osm') {
    layer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>', subdomains: ['a', 'b', 'c'] });
  } else if (key == 'watercolor') {
    let url = 'https://stamen-tiles-{s}.a.ssl.fastly.net/watercolor/{z}/{x}/{y}.jpg';
  } else if (startsWith(key, 'mb')) {
    let url = 'https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw';
    let id = key.includes('sat') ? 'mapbox/satellite-v9' : 'mapbox/streets-v11';
    layer = L.tileLayer(url, { id: id, tileSize: 512, zoomOffset: -1, attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>' });
  } else if (key.includes('top')) {
    layer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
      maxZoom: 22,
      attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
    });
  }
  layer.addTo(M.map);
  return layer;
}
function map_init(dParent, city, zoom) {
  let o = M.cities[city];
  let center = [o.lat, o.lon];
  var map = L.map(dParent, { center: center, minZoom: 2, zoom: zoom });
  return map;
}
function map_moveby(pin, fx, fy) {
  let pos = pin.getLatLng();
  let lat = fx(pos.lat);
  let lng = fy(pos.lng);
  pin.setLatLng([lat, lng]);
}
function map_moveto(pin, center) { pin.setLatLng(center); }
function map_range(x, min1, max1, min2, max2) { return convert_to_range(x, min1, max1, min2, max2); }
function maPic(infokey, dParent, styles, isText = true, isOmoji = false) {
  let info = isString(infokey) ? picInfo(infokey) : infokey;
  if (!isText && info.type == 'emo') {
    let dir = isOmoji ? 'openmoji' : 'twemoji';
    let hex = info.hexcode;
    if (isOmoji && hex.indexOf('-') == 2) hex = '00' + hex;
    let ui = mImg('/assets/svg/' + dir + '/' + hex + '.svg', dParent);
    if (isdef(styles)) mStyleX(ui, styles);
    return ui;
  }
  let outerStyles = isdef(styles) ? jsCopy(styles) : {};
  outerStyles.display = 'inline-block';
  let family = info.type == 'emo' && isString(isOmoji) ? isOmoji : isOmoji == true ? 'emoOpen' : info.family;
  let i = (family == info.family) ? 0 : EMOFONTLIST.indexOf(family) + 1;
  if (i < 0) {
    i = 1; console.log('iiiiiii', i, family, info.family);
  }
  let wInfo = info.w[i];
  let hInfo = info.h[i];
  let innerStyles = { family: family };
  let [padw, padh] = isdef(styles.padding) ? [styles.padding, styles.padding] : [0, 0];
  let dOuter = isdef(dParent) ? mDiv(dParent) : mDiv();
  let d = mDiv(dOuter);
  d.innerHTML = info.text;
  let wdes, hdes, fzdes, wreal, hreal, fzreal, f;
  if (isdef(styles.w) && isdef(styles.h) && isdef(styles.fz)) {
    [wdes, hdes, fzdes] = [styles.w, styles.h, styles.fz];
    let fw = wdes / wInfo;
    let fh = hdes / hInfo;
    let ffz = fzdes / info.fz;
    f = Math.min(fw, fh, ffz);
  } else if (isdef(styles.w) && isdef(styles.h)) {
    [wdes, hdes] = [styles.w, styles.h];
    let fw = wdes / wInfo;
    let fh = hdes / hInfo;
    f = Math.min(fw, fh);
  } else if (isdef(styles.w) && isdef(styles.fz)) {
    [wdes, fzdes] = [styles.w, styles.fz];
    let fw = wdes / wInfo;
    let ffz = fzdes / info.fz;
    f = Math.min(fw, ffz);
  } else if (isdef(styles.h) && isdef(styles.fz)) {
    [hdes, fzdes] = [styles.h, styles.fz];
    let fh = hdes / hInfo;
    let ffz = fzdes / info.fz;
    f = Math.min(fh, ffz);
  } else if (isdef(styles.h)) {
    hdes = styles.h;
    f = hdes / hInfo;
  } else if (isdef(styles.w)) {
    wdes = styles.w;
    f = wdes / wInfo;
  } else {
    mStyleX(d, innerStyles);
    mStyleX(dOuter, outerStyles);
    return dOuter;
  }
  fzreal = f * info.fz;
  wreal = Math.round(f * wInfo);
  hreal = Math.round(f * hInfo);
  wdes = Math.round(wdes);
  hdes = Math.round(hdes);
  padw += isdef(styles.w) ? (wdes - wreal) / 2 : 0;
  padh += isdef(styles.h) ? (hdes - hreal) / 2 : 0;
  if (!(padw >= 0 && padh >= 0)) {
    console.log(info)
    console.log('\nstyles.w', styles.w, '\nstyles.h', styles.h, '\nstyles.fz', styles.fz, '\nstyles.padding', styles.padding, '\nwInfo', wInfo, '\nhInfo', hInfo, '\nfzreal', fzreal, '\nwreal', wreal, '\nhreal', hreal, '\npadw', padw, '\npadh', padh);
  }
  innerStyles.fz = fzreal;
  innerStyles.weight = 900;
  innerStyles.w = wreal;
  innerStyles.h = hreal;
  mStyleX(d, innerStyles);
  outerStyles.padding = '' + padh + 'px ' + padw + 'px';
  outerStyles.w = wreal;
  outerStyles.h = hreal;
  mStyleX(dOuter, outerStyles);
  return dOuter;
}
function maPic4(info, dParent, styles) {
  mStyleX(dParent, { display: 'flex', 'flex-flow': 'row wrap' });
  maPic(info, table, styles, true);
  maPic(info, table, styles, true, 'segoe ui emoji');
  maPic(info, table, styles, false);
  maPic(info, table, styles, false, true);
  mLinebreak(table);
}
function maPicButton(key, handler, dParent, styles, classes = 'picButton', isText, isOmoji) {
  let x = maPic(key, dParent, styles, isText, isOmoji);
  if (isdef(handler)) x.onclick = handler;
  mClass(x, classes);
  return x;
}
function maPicFrame(info, dParent, containerStyles, picStyles, isText = true, isOmoji = false) {
  let d = mDiv(dParent);
  maPic(info, d, picStyles, isText, isOmoji);
  mStyleX(d, containerStyles);
  return d;
}
function maPicLabel(info, dParent, containerStyles, picStyles, textStyles, isText = true, isOmoji = false) {
  let d = mDiv(dParent);
  let dPic = maPic(info, d, picStyles, isText, isOmoji);
  let dText = mText(info.annotation, d, textStyles, ['might-overflow']);
  mStyleX(d, containerStyles);
  return d;
}
function maPicLabel_dep(info, dParent, styles, isText = true, isOmoji = false) {
  let d = mDiv(dParent, { bg: 'random', fg: 'contrast', padding: 4, margin: 2 });
  maPic(info, d, styles, isText, isOmoji);
  mText(info.annotation, d);
  d.style.textAlign = 'center';
  return d;
}
function maPicLabelButton(info, label, handler, dParent, styles, classes = 'picButton', isText, isOmoji) {
  let sz = isdef(styles) && isdef(styles.w) ? styles.w : 200;
  let [g, p, t] = getHarmoniousStyles1(styles.w, styles.h, 10, 'arial', 'random', 'random', true);
  g.display = 'inline-block';
  for (const k in styles) {
    g[k] = styles[k];
    if (k == 'rounding') p.rounding = styles.rounding;
  }
  console.log('g', g, '\np', p, '\nt', t)
  let x = maPicLabelX(info, label, dParent, g, p, t, isText, isOmoji);
  if (isdef(handler)) x.onclick = handler;
  mClass(x, classes);
  return x;
}
function maPicLabelButtonFitText(info, label, { w, h, bgPic, textShadowColor, contrast, sPic = {} }, handler, dParent, styles, classes = 'picButton', isText, isOmoji, focusElement) {
  let picLabelStyles = getHarmoniousStylesPlusPlus(styles, sPic, {}, w, h, 65, 0, 'arial', bgPic, 'transparent', null, null, true);
  let x = maPicLabelFitX(info, label.toUpperCase(), { wmax: w, textShadowColor: textShadowColor, contrast: contrast }, dParent, picLabelStyles[0], picLabelStyles[1], picLabelStyles[2], isText, isOmoji);
  x.id = 'd' + info.key;
  if (isdef(handler)) x.onclick = handler;
  x.style.cursor = 'pointer';
  x.lastChild.style.cursor = 'pointer';
  x.style.userSelect = 'none';
  mClass(x, classes);
  return x;
}
function maPicLabelButtonX(info, label, handler, dParent, styles, classes = 'picButton', isText, isOmoji) {
  let handler1 = (ev) => {
    let id = evToClosestId(ev);
    let info = symbolDict[id.substring(1)];
    if (isLabelVisible(id)) maHideLabel(id, info); else maShowLabel(id, info);
    mBy('dummy').focus();
  }
  let picLabelStyles = getHarmoniousStylesPlus(styles, {}, {}, 200, 200, 0, 'arial', 'random', 'transparent', true);
  let x = maPicLabelX(info, label.toUpperCase(), dParent, picLabelStyles[0], picLabelStyles[1], picLabelStyles[2], true, false);
  x.id = 'd' + label;
  x.onclick = handler;
  x.style.cursor = 'pointer';
  x.lastChild.style.cursor = 'pointer';
  x.style.userSelect = 'none';
  return x;
}
function maPicLabelButtonXX(info, label, handler, dParent, styles, classes = 'picButton', isText, isOmoji) {
  let handler1 = (ev) => {
    let id = evToClosestId(ev);
    let info = infoDictionary[id.substring(1)];
    if (isLabelVisible(id)) maHideLabel(id, info); else maShowLabel(id, info);
    mBy('dummy').focus();
  }
  let picLabelStyles = getHarmoniousStylesPlusPlus(styles, {}, {}, 200, 200, 65, 0, 'arial', 'random', 'transparent', null, null, true);
  let x = maPicLabelFit(info, label.toUpperCase(), dParent, picLabelStyles[0], picLabelStyles[1], picLabelStyles[2], true, false);
  x.id = 'd' + label;
  x.onclick = handler;
  x.style.cursor = 'pointer';
  x.lastChild.style.cursor = 'pointer';
  x.style.userSelect = 'none';
  return x;
}
function maPicLabelFit(info, label, dParent, containerStyles, picStyles, textStyles, isText = true, isOmoji = false) {
  let d = mDiv(dParent);
  let dPic = maPic(info, d, picStyles, isText, isOmoji);
  let maxchars = 15; let maxlines = 1;
  console.log(containerStyles, picStyles, textStyles);
  let hAvail = containerStyles.h -
    (containerStyles.patop + picStyles.h + containerStyles.pabottom);
  let wAvail = containerStyles.w;
  let fz = textStyles.fz;
  console.log('_ avail:', wAvail, hAvail)
  let styles1 = textStyles;
  let size = getSizeWithStylesX(label, styles1, wAvail);
  console.log('__', size);
  let dText = mTextFit(label, maxchars, maxlines, d, textStyles, ['truncate']);
  mStyleX(d, containerStyles);
  return d;
}
function maPicLabelFitX(info, label, { wmax, hmax, textShadowColor, contrast = .35 }, dParent, containerStyles, picStyles, textStyles, isText = true, isOmoji = false) {
  let d = mDiv(dParent);
  if (isdef(textShadowColor)) {
    let sShade = '0 0 0 ' + textShadowColor;
    picStyles['text-shadow'] = sShade;
    picStyles.fg = colorFrom('black', contrast); //'#00000080' '#00000030' 
  }
  let dPic = maPic(info, d, picStyles, isText, isOmoji);
  let maxchars = 15; let maxlines = 1;
  let wAvail, hAvail;
  hAvail = containerStyles.h - (containerStyles.patop + picStyles.h);
  wAvail = containerStyles.w;
  if (isdef(hmax)) {
    hAvail = containerStyles.h - (containerStyles.patop + picStyles.h);
    if (hmax != 'auto') {
      hAvail = Math.min(hAvail, hmax);
    }
  }
  if (isdef(wmax)) {
    wAvail = containerStyles.w;
    if (wmax != 'auto') {
      wAvail = Math.min(wAvail, wmax);
    }
  }
  let fz = textStyles.fz;
  let styles1 = textStyles;
  let size = getSizeWithStylesX(label, styles1, isdef(wmax) ? wAvail : undefined, isdef(hmax) ? hAvail : undefined);
  let size1 = getSizeWithStylesX(label, styles1);
  let f1 = wAvail / size1.w;
  let isTextOverflow = f1 < 1;
  if (f1 < 1) {
    textStyles.fz *= f1;
    textStyles.fz = Math.floor(textStyles.fz);
  }
  let [wBound, hBound] = [isdef(wmax) ? size.w : undefined, isdef(hmax) ? size.h : undefined];
  let isOverflow = isdef(wBound) && size.w > wAvail || isdef(hBound) && size.h > hAvail;
  let dText = mTextFit(label, { wmax: wBound, hmax: hBound }, d, textStyles, isTextOverflow ? ['truncate'] : null);
  mStyleX(d, containerStyles);
  dText.style.margin = 'auto';
  return d;
}
function maPicLabelShowHideHandler(ev) {
  let id = evToClosestId(ev);
  let info = symbolDict[id.substring(1)];
  if (isLabelVisible(id)) maHideLabel(id, info); else maShowLabel(id, info);
  if (isdef(mBy('dummy'))) mBy('dummy').focus();
}
function maPicLabelX(info, label, dParent, containerStyles, picStyles, textStyles, isText = true, isOmoji = false) {
  let d = mDiv(dParent);
  let dPic = maPic(info, d, picStyles, isText, isOmoji);
  let dText = mText(label, d, textStyles, ['might-overflow']);
  mStyleX(d, containerStyles);
  return d;
}
function maPicOver(d, dParent, fz, color, picStyle) {
  let b = getBounds(dParent);
  d.style.top = picStyle == 'segoeBlack' ? (b.y + 60 - fz / 2 + 'px') : (b.y + 100 - fz / 2 + 'px');
  d.style.left = picStyle == 'segoeBlack' ? (b.x + 120 - fz / 2 + 'px') : (b.x + 100 - fz / 2 + 'px');
  d.style.color = color;
  d.style.fontSize = fz + 'px';
  d.style.display = 'block';
  let { isText, isOmoji } = getParamsForMaPicStyle(picStyle);
  d.style.fontFamily = isString(isOmoji) ? isOmoji : isOmoji ? 'emoOpen' : 'emoNoto';
  return d;
}
function maPicSimple(key) {
  let info = picInfo(key);
  let d = mText(info.text);
  d.style.setProperty('font-family', info.family);
  return d;
}
function maPicSimpleEmoHexText(hex, parent, fontSize) {
  if (isString(parent)) parent = mBy(parent);
  let d = mDiv(parent);
  let s1 = '&#' + hex + ';'; //'\u{1F436}';
  d.innerHTML = s1;
  d.style.fontSize = fontSize + 'pt';
  return d;
}
function mapOMap(omap, pool) {
  let olist = [];
  let ids = omap ? getElements(omap) : [];
  if (!isEmpty(ids)) {
    for (const id of ids) {
      let o = pool[id];
      o.id = id;
      olist.push(o);
    }
  } else {
    for (const k in omap) {
      let item = { key: k, value: omap[k] };
      olist.push(item);
    }
  }
  return olist;
}
function mAppear(d, ms = 800, callback = null) { return mAnimateTo(d, 'opacity', 1, callback, ms); }
function mAppend(d, child) { toElem(d).appendChild(child); return child; }
function mAppendS(d, child) { d = mEnsure(d); if (d) d.appendChild(child); return child; }
function mAppendText(d, text) { let dText = mCreate('div'); dText.innerHTML = text; d.appendChild(dText); return dText; }
function mAppendTextS(d, text) { let dText = mCreate('div'); dText.innerHTML = text; mAppendS(d, dText); return dText; }
function mappingsClear() {
  mappingTypes = {};
  mappingsInitialized = {};
}
function mAppPos(d, child) { d.style.position = 'relative'; return mAppend(d, child); }
function mAppPosS(d, child) { d = ensure(d); d.style.position = 'relative'; return mAppend(d, child); }
function mapSafe(func, listFunc, oid) {
  let uis = listFunc(oid);
  if (!isdef(uis)) return;
  if (!isList(uis)) uis = [uis];
  uis.map(x => x[func]());
}
function mapValues(o, p, pdef, spec) {
  let oNew = {};
  for (const k in p) {
    if (nundef(p[k])) continue;
    if (nundef(p[k]._map)) { oNew[k] = p[k]; continue; }
    let p1 = p[k];
    let m = p1._map;
    let mapName = m.map;
    let _map = spec[mapName];
    let propPath = m.key;
    let _key = decodePropertyPath(o, propPath);
    let val = _map[_key];
    let valKey = isdef(m.value) ? m.value : k;
    if (isdef(val) && isdef(val[valKey])) { oNew[k] = val[valKey]; }
    else if (isdef(m.default)) { oNew[k] = m.default; }
    else if (isdef(pdef[k])) { oNew[k] = pdef[k]; }
  }
  return oNew;
}
function mapzeug_sample_code() {
  //#region sample code marker, circle and on drag handler
  M.markers.nasi = get_marker(map, center, { user: 'nasi', draggable: true });
  M.shapes = {};
  M.shapes.nasi = get_circle(center, { sz: 1000, bg: GREEN }).addTo(map);
  M.markers.nasi.on('drag', function (e) {
    var d = map.distance(e.latlng, M.shapes.nasi.getLatLng());
    var isInside = d < M.shapes.nasi.getRadius();
    console.log('inside?', isInside ? 'YES' : 'NO');
    M.shapes.nasi.setStyle({ fillColor: isInside ? 'green' : '#f03' });
  });
  //#endregion
}
function maResizePic(p, dParent, pictureSize) {
  let d = p.div;
  mAppend(dParent, d);
  let oldSize = p.sz;
  if (oldSize >= 200) return;
  let x = pictureSize / oldSize;
  if (Math.abs(x - 1) <= .1) return;
  let dpic = d.children[0];
  let bpic = getBounds(dpic);
  let wPicOld = bpic.width;
  let wPicNew = bpic.width * x;
  let hPicOld = bpic.height;
  let hPicNew = bpic.height * x;
  console.log('pic will be resized from', wPicOld, hPicOld, 'to', wPicNew, hPicNew)
  console.log('info.hOrig', p.info.hOrig)
  console.log('info', p.info)
  mSize(d, pictureSize, pictureSize);
  let dsym = dpic.children[0];
  let fzPicOld = firstNumber(dsym.style.fontSize);
  let fzPicNew = fzPicOld * x;
  let hNew = fzPicNew * p.info.h[0] / 100;
  console.log('new h should be', hNew, 'but is', hPicNew)
  mStyleX(dpic, { w: wPicNew, h: hNew });
  mStyleX(dsym, { fz: fzPicNew });
  let dtext = d.children[1];
  let fzTextOld = firstNumber(dtext.style.fontSize);
  let fzTextNew = Math.round(fzTextOld * x);
  mStyleX(dtext, { fz: fzTextNew, w: 'auto', h: 'auto' });
  d.style.padding = '0px';
  p.sz = pictureSize;
  let htext = p.isLabelVisible ? getBounds(dtext).height : 0;
  let hpic = getBounds(dpic).height;
  d.style.paddingTop = '' + ((pictureSize - (htext + hpic)) / 2) + 'px';
  for (let i = 2; i < d.children.length; i++) {
    let dOrdinal = d.children[i];
    let fzOld = firstNumber(dOrdinal.style.fontSize);
    let fzNew = fzOld * x;
    let leftOld = firstNumber(dOrdinal.style.left);
    let leftNew = Math.floor(leftOld * x);
    let topOld = firstNumber(dOrdinal.style.top);
    let topNew = Math.floor(topOld * x);
    mStyleX(dOrdinal, { fz: fzNew, left: leftNew, top: topNew });
  }
}
function markerFail() { return createMarker(MarkerId.FAIL); }
function markerSuccess() { return createMarker(MarkerId.SUCCESS); }
function markerSuccessNew(ui, sz) {
  let d = createMarker(MarkerId.SUCCESS);
  if (nundef(ui)) return d;
  if (nundef(sz)) sz = getRect(ui).h;
  let top = (cy - sz * 2 / 3);
  let left = (cx - sz / 3);
  sz *= 4 / 5;
  mpOver(d, ui, sz, 'limegreen', 'segoeBlack');
  return d;
}
function maShowLabel(id, info) {
  let d = mBy(id);
  let dPic = d.children[0];
  let dText = d.children[1];
  let dPicText = dPic.children[0];
  dPicText.style.fontSize = info.fzOrig;
  dPicText.style.color = info.textColorOrig;
  dPic.style.width = info.wOrig;
  dPic.style.height = info.hOrig;
  d.style.paddingTop = info.paddingTopOrig;
  d.style.paddingBottom = info.paddingBottomOrig;
  dText.style.display = 'block';
  dText.style.width = 'auto'
}
function maShowPictures(keys, labels, dParent, onClickPictureHandler,
  { showRepeat, container, lang, border, picSize, bgs, colorKeys, contrast, repeat = 1,
    sameBackground, shufflePositions = true } = {}, { sCont, sPic, sText } = {}) {
  let pics = [];
  //#region prelim
  let numPics = keys.length * repeat;
  let items = [];
  for (let i = 0; i < keys.length; i++) {
    let k = keys[i];
    let info = isdef(lang) ? getRandomSetItem(lang, k) : symbolDict[k];
    let bg = isList(bgs) ? bgs[i] : isdef(colorKeys) ? 'white' : sameBackground ? computeColor('random') : 'random';
    let label = isList(labels) ? labels[i] : isdef(lang) ? info.best : k;
    items.push({ key: k, info: info, label: label, bg: bg, iRepeat: 1 });
  }
  let items1 = jsCopy(items);
  for (let i = 0; i < repeat - 1; i++) {
    items = items.concat(items1);
  }
  let isText = true;
  let isOmoji = false;
  if (isdef(lang)) {
    let textStyle = getParamsForMaPicStyle('twitterText');
    isText = textStyle.isText;
    isOmoji = textStyle.isOmoji;
  }
  numPics = items.length;
  if (shufflePositions) { shuffle(items); }
  //#endregion prelim
  let lines = isdef(colorKeys) ? colorKeys.length : 1;
  let [pictureSize, picsPerLine] = calcDimsAndSize(numPics, lines, container);
  let stylesForLabelButton = { rounding: 10, margin: pictureSize / 8 };
  if (isdef(border)) stylesForLabelButton.border = border;
  if (isdef(picSize)) pictureSize = picSize;
  let labelRepeat = {};
  for (let line = 0; line < lines; line++) {
    let textShadowColor, colorKey;
    if (isdef(colorKeys)) { colorKey = colorKeys[line]; textShadowColor = ColorDict[colorKey].c; labelRepeat = {}; }
    for (let i = 0; i < numPics; i++) {
      let item = items[i];
      let info = item.info;
      let label = item.label;
      let iRepeat = labelRepeat[label];
      if (nundef(iRepeat)) iRepeat = 1; else iRepeat += 1;
      labelRepeat[label] = iRepeat;
      let bg = item.bg;
      let ipic = (line * picsPerLine + i);
      if (ipic % picsPerLine == 0 && ipic > 0) { mLinebreak(dParent); }
      let id = 'pic' + ipic;
      let d1 = maPicLabelButtonFitText(info, label,
        { w: pictureSize, h: pictureSize, bgPic: bg, textShadowColor: textShadowColor, contrast: contrast, sPic: sPic },
        onClickPictureHandler, dParent, stylesForLabelButton, 'frameOnHover', isText, isOmoji);
      d1.id = id;
      if (showRepeat) addRepeatInfo(d1, iRepeat, pictureSize);
      let fzPic = firstNumber(d1.children[0].children[0].style.fontSize);
      pics.push({
        textShadowColor: textShadowColor, color: ColorDict[colorKey], colorKey: colorKey, key: info.key, info: info,
        bg: bg, div: d1, id: id, sz: pictureSize, fzPic: fzPic,
        index: ipic, row: line, col: i, iRepeat: iRepeat, label: label, isLabelVisible: true, isSelected: false
      });
    }
  }
  return pics;
}
function matchAllUnits_dep(arr, pl, tile, type) {
  let units = arr.filter(x => x.obj_type == 'unit' && getUnitOwner(x.nationality) == pl && x.tile == tile && x.type == type);
  if (units.length > 1) {
    msg = 'matchSingleUnit: MULTIPLE UNITS MATCH EXACTLY!!!';
    alert(msg);
  } else if (units.length == 1) {
    return units[0];
  }
  return null;
}
function matches_on_either_end(card, j) {
  let key = card.key;
  let jfirst = arrFirst(j.o.list);
  let jlast = arrLast(j.o.list);
  rankstr = 'A23456789TJQK';
  let [s, s1, s2] = [key[1], jfirst[1], jlast[1]];
  let anfang = s == s1 && follows_in_rank(key, jfirst, rankstr);
  let ende = s == s2 && follows_in_rank(jlast, key, rankstr);
  return anfang || ende;
}
function matchesAnyWordOrSound(info, s) {
  if (!isEnglish(currentLanguage)) return false;
  for (const w of info.words) {
    if (isTimeString(w)) return soundsSimilar(w, s);
  }
  return false;
}
function matchingNumberOrTime(info, answer) {
  if (infoHasNumberOrTimeString(info) && isNumberOrTimeString(answer)) {
    if (isNumber(answer) && infoHasNumber(info)) {
      let best1 = firstCond(info.words, x => isNumber(x));
      return best1 == answer;
    } else if (isTimeString(answer) && infoHasTimeString(info)) {
      let ts = firstCond(info.words, x => isTimeString(x));
      let x1 = convertGermanUhrzeitToNumbers(answer);
      let x2 = convertTimeStringToNumbers(ts);
      removeInPlace(x1, 0);
      removeInPlace(x2, 0);
      return sameList(x1, x2);
    } else if (infoHasTimeString(info)) {
      let best1 = firstCond(info.words, x => isTimeString(x));
      let x1 = convertTimesAndNumbersToWords(best1);
      let x2 = convertTimesAndNumbersToWords(answer);
      return x1 == x2;
    }
  }
}
function matchSingleUnit_dep(idDict, pl, tile, type) {
  let arr = dict2list(idDict, 'id');
  let units = arr.filter(x => x.obj_type == 'unit' && getUnitOwner(x.nationality) == pl && x.tile == tile && x.type == type);
  if (units.length > 1) {
    msg = 'matchSingleUnit: MULTIPLE UNITS MATCH EXACTLY!!!';
    alert(msg);
  } else if (units.length == 1) {
    return units[0];
  }
  return null;
}
function matchUnits(darr, option, pl = null, tile = null, type = null, cv = null) {
  let arr = null;
  if (typeof darr === 'object' && darr.constructor == Object) {
    arr = dict2list(darr, 'id');
  } else arr = darr;
  let result = [];
  for (const o of arr) {
    if (o.obj_type != 'unit') continue;
    if (pl && getUnitOwner(o.nationality) != pl) continue;
    if (tile && o.tile != tile) continue;
    if (type && (o.type != 'Convoy' && o.type != type || o.type == 'Convoy' && o.carrying != type)) {
      continue;
    }
    if (cv && o.cv != cv) continue;
    if (option == 'first') {
      return o;
    }
    result.push(o);
  }
  if (result.length == 0) return option == 'all' ? [] : null;
  return option == 'all' ? result : option == 'last' ? result[result.length - 1] : (result[0], result[result.length - 1]);
}
function MaterialDraw() {
  if (0 == brd_pceNum[PIECES.wR] && 0 == brd_pceNum[PIECES.bR] && 0 == brd_pceNum[PIECES.wQ] && 0 == brd_pceNum[PIECES.bQ]) {
    if (0 == brd_pceNum[PIECES.bB] && 0 == brd_pceNum[PIECES.wB]) {
      if (brd_pceNum[PIECES.wN] < 3 && brd_pceNum[PIECES.bN] < 3) { return BOOL.TRUE; }
    } else if (0 == brd_pceNum[PIECES.wN] && 0 == brd_pceNum[PIECES.bN]) {
      if (Math.abs(brd_pceNum[PIECES.wB] - brd_pceNum[PIECES.bB]) < 2) { return BOOL.TRUE; }
    } else if ((brd_pceNum[PIECES.wN] < 3 && 0 == brd_pceNum[PIECES.wB]) || (brd_pceNum[PIECES.wB] == 1 && 0 == brd_pceNum[PIECES.wN])) {
      if ((brd_pceNum[PIECES.bN] < 3 && 0 == brd_pceNum[PIECES.bB]) || (brd_pceNum[PIECES.bB] == 1 && 0 == brd_pceNum[PIECES.bN])) { return BOOL.TRUE; }
    }
  } else if (0 == brd_pceNum[PIECES.wQ] && 0 == brd_pceNum[PIECES.bQ]) {
    if (brd_pceNum[PIECES.wR] == 1 && brd_pceNum[PIECES.bR] == 1) {
      if ((brd_pceNum[PIECES.wN] + brd_pceNum[PIECES.wB]) < 2 && (brd_pceNum[PIECES.bN] + brd_pceNum[PIECES.bB]) < 2) { return BOOL.TRUE; }
    } else if (brd_pceNum[PIECES.wR] == 1 && 0 == brd_pceNum[PIECES.bR]) {
      if ((brd_pceNum[PIECES.wN] + brd_pceNum[PIECES.wB] == 0) && (((brd_pceNum[PIECES.bN] + brd_pceNum[PIECES.bB]) == 1) || ((brd_pceNum[PIECES.bN] + brd_pceNum[PIECES.bB]) == 2))) { return BOOL.TRUE; }
    } else if (brd_pceNum[PIECES.bR] == 1 && 0 == brd_pceNum[PIECES.wR]) {
      if ((brd_pceNum[PIECES.bN] + brd_pceNum[PIECES.bB] == 0) && (((brd_pceNum[PIECES.wN] + brd_pceNum[PIECES.wB]) == 1) || ((brd_pceNum[PIECES.wN] + brd_pceNum[PIECES.wB]) == 2))) { return BOOL.TRUE; }
    }
  }
  return BOOL.FALSE;
}
function mAttrs(elem, attrs) { for (const k in attrs) { elem.setAttribute(k, attrs[k]); } }
function mAutocomplete(dParent) {
  let form = mCreateFrom(`
    <form class='form' autocomplete="off" action="javascript:void(0);">
      <div class="autocomplete" style="width: 200px">
        <input id="myInput" type="text" name="myCity" placeholder="City" onclick="select()" />
      </div>
      <input style="margin-left:-15px" type="submit" value="Go!" />
    </form>
  `  );
  form.onsubmit = () => {
    let c = mBy('myInput').value.toLowerCase();
    let o = Geo.cities[c];
    if (nundef(o)) { c = toUmlaut(c); o = Geo.cities[c]; }
    console.log('c', c);
    let center = o.center;
    M.map.flyTo(center, M.map.getZoom(), { animate: false })
  }
  let d = mAppend(dParent, form);
  autocomplete('myInput', get_values(Geo.cities).map(x => x.name));
}
function maxFit(olist, prop, min, max) {
  let res = 0;
  for (const d of olist) {
    res = Math.max(res, d[prop]);
  }
  if (res < min) res = min; else if (res > max) res = max;
  return res;
}
function mBackground(bg, fg) { mStyle(document.body, { bg: bg, fg: fg }); }
function mBare(n, R, uidParent) {
  let ui;
  let dParent = mBy(n.idUiParent);
  ui = mDiv(dParent);
  if (isdef(n.content)) { mNode(n.content, ui) }
  return ui;
}
function mBg(d, color) { d.style.backgroundColor = color; }
function mBox(w, h, color, dParent = null) { let d = mDiv(dParent); return mStyle(d, { 'background-color': color, position: 'absolute', display: 'inline', width: w, height: h }); }
function mBoxFromMargins(dParent, t, r, b, l, styles, id, inner, classes) {
  let d = mDiv(dParent, { position: 'absolute', top: t, right: r, bottom: b, left: l }, id, inner, classes);
  let pos = dParent.style.position;
  if (pos != 'absolute') dParent.style.position = 'relative';
  if (isdef(styles)) mStyle(d, styles);
  return d;
}
function mButton(caption, handler, dParent, styles, classes, id) {
  let x = mCreate('button');
  x.innerHTML = caption;
  if (isdef(handler)) x.onclick = handler;
  if (isdef(dParent)) toElem(dParent).appendChild(x);
  if (isdef(styles)) mStyle(x, styles);
  if (isdef(classes)) mClass(x, classes);
  if (isdef(id)) x.id = id;
  return x;
}
function mButtonX(dParent, handler, pos = 'tr', sz = 25, color = 'white') {
  let d2 = mDiv(dParent, { fg: color, w: sz, h: sz, cursor: 'pointer' }, null, `<i class="fa fa-times" style="font-size:${sz}px;"></i>`, 'btnX');
  mPlace(d2, pos, 2);
  d2.onclick = handler;
  return d2;
}
function mBy(id) { return document.getElementById(id); }
function mById(id) { return document.getElementById(id); }
function mCancelMagnify(img, path) {
  if (isdef(MAGNIFIER_IMAGE)) { MAGNIFIER_IMAGE.remove(); MAGNIFIER_IMAGE = null; }
}
function mCanvas(dParent, styles = {}, bstyles = {}, play = null, pause = null, origin = 'tl') {
  let cv = mCreate('canvas');
  mAppend(toElem(dParent), cv);
  addKeys({ w: 500, h: 500, bg: '#222', rounding: 10 }, styles);
  mStyle(cv, styles);
  let [w, h] = [cv.width, cv.height] = [styles.w, styles.h];
  let cx = cv.getContext('2d');
  let [x, y] = posToPoint(origin, w, h);
  cx.translate(x, y);
  if (!play) return { cv: cv, cx: cx, origin: { x: x, y: y }, x: 0, y: 0, w: w, h: h };
  mLinebreak(dParent)
  addKeys({ fz: 28, fg: 'skyblue', display: 'flex', ajcenter: true, w: styles.w }, bstyles)
  let controls = mPlayPause(dParent, bstyles, play, pause);
  return { cv: cv, cx: cx, origin: { x: x, y: y }, x: 0, y: 0, w: w, h: h, controls: controls.ui, play: controls.play, pause: controls.pause, stop: controls.play, stop: controls.pause };
}
function mCanvas100(dParent) { let d = mDiv(dParent); mStyleX(d, { position: 'absolute', w: '100%', h: '100%' }); return d; }
function mCard(dParent, styles, classtr = '', id = null) {
  let classes = toWords("card300 wb " + classtr);
  return mDiv(dParent, styles, id, null, classes);
}
function mCard52(n, R, uidParent) {
  let dParent = mBy(n.idUiParent);
  console.log('...MCARD52')
  let ui;
  let w, h;
  if (n.params.size) { w = n.params.size.w; h = n.params.size.h; }
  else[w, h] = [70, 110];
  if (nundef(n.content)) ui = cardFace({}, w, h);
  else {
    if (isDict(n.content)) {
      let o = n.content;
      let rank = isdef(o.rank) ? o.rank : null;
      let key = isdef(o.key) ? o.key : null;
      let suit = isdef(o.suit) ? o.suit : null;
      let cardKey = isdef(o.cardKey) ? o.cardKey : null;
      ui = cardFace({ rank: rank, suit: suit, key: key, cardKey: cardKey }, w, h);
    } else if (isString(n.content)) {
      let s = n.content;
      let len = s.length;
      if (len == 1) ui = cardFace({ rank: s }, w, h);
      else if (len == 2) {
        ui = cardFace({ cardKey: s }, w, h);
      } else ui = cardFace({ key: s }, w, h);
    }
  }
  mAppend(dParent, ui);
  n.potentialOverlap = true;
  return ui;
}
function mCard52_Wrapper(n, R, uidParent) {
  let dParent = mBy(n.idUiParent);
  let uiWrapper = mDiv(dParent);
  addClass(uiWrapper, 'cardWrapper');
  let ui;
  let w, h;
  if (n.params.size) { w = n.params.size.w; h = n.params.size.h; }
  else[w, h] = [70, 110];
  if (nundef(n.content)) ui = cardFace({}, w, h);
  else {
    if (isDict(n.content)) {
      let o = n.content;
      let rank = isdef(o.rank) ? o.rank : null;
      let key = isdef(o.key) ? o.key : null;
      let suit = isdef(o.suit) ? o.suit : null;
      let cardKey = isdef(o.cardKey) ? o.cardKey : null;
      ui = cardFace({ rank: rank, suit: suit, key: key, cardKey: cardKey }, w, h);
    } else if (isString(n.content)) {
      let s = n.content;
      let len = s.length;
      if (len == 1) ui = cardFace({ rank: s }, w, h);
      else if (len == 2) {
        ui = cardFace({ cardKey: s }, w, h);
      } else ui = cardFace({ key: s }, w, h);
    }
  }
  mAppend(uiWrapper, ui);
  return ui;
}
function mCardButton(caption, handler, dParent, styles, classtr = '', id = null) {
  let classes = toWords("card300 wb fett no_outline btn" + classtr);
  return mButton(caption, handler, dParent, styles, classes, id);
}
function mCardText(ckey, sz, color) { return is_jolly(ckey) ? '<span style="font-family:Algerian">jolly</span>' : `${ckey[0]}${mSuit(ckey, sz, color)}`; }
function mCellContent(dCell, styles, html) {
  clearElement(dCell);
  let d = mDiv(dCell, { w: '100%', h: '100%' });
  mCenterCenterFlex(d);
  let d1 = mDiv(d, styles, null, html);
  mCenterCenterFlex(d1);
  return d1;
}
function mCenter(d, gap) { mCenterFlex(d, true, false, true, gap); }
function mCenterAbs(d, offsetX = 0, offsetY = 0) {
  let dParent = d.parentNode;
  if (nundef(dParent)) return;
  let b = getBounds(dParent);
  let b1 = getBounds(d);
  let h = b.height;
  let h1 = b1.height;
  let hdiff = h - h1;
  d.style.top = (offsetY + hdiff / 2) + 'px';
  let w = b.width;
  let w1 = b1.width;
  let wdiff = w - w1;
  d.style.left = (offsetX + wdiff / 2) + 'px';
  d.style.position = 'absolute';
  if (isEmpty(dParent.style.position)) dParent.style.position = 'relative';
}
function mCenterAbs_v0(d) {
  let dParent = d.parentNode;
  if (nundef(dParent)) return;
  let b = getBounds(dParent);
  let b1 = getBounds(d);
  let h = b.height;
  let h1 = b1.height;
  let hdiff = h - h1;
  d.style.top = (hdiff / 2) + 'px';
  let w = b.width;
  let w1 = b1.width;
  console.log('zone w:', w, 'item w:', w1);
  let wdiff = w - w1;
  d.style.left = (wdiff / 2) + 'px';
  d.style.position = 'absolute';
  console.log('parent position', dParent.style.position)
  if (isEmpty(dParent.style.position)) dParent.style.position = 'relative';
  console.log('d', d)
}
function mCenterAt(d, x, y) {
  let rect = getRect(d);
  mPos(d, x - rect.w / 2, y - rect.h / 2);
}
function mCenterCenter(d, gap) { mCenterCenterFlex(d, gap); }
function mCenterCenterFlex(d, gap) { mCenterFlex(d, true, true, true, gap); }
function mCenteredNode(content) {
  let d = mNode(content);
  return d;
}
function mCenterFlex(d, hCenter = true, vCenter = false, wrap = true, gap = null) {
  let styles = { display: 'flex' };
  if (hCenter) styles['justify-content'] = 'center';
  styles['align-content'] = vCenter ? 'center' : 'flex-start';
  if (wrap) styles['flex-wrap'] = 'wrap';
  if (gap) styles.gap = gap;
  mStyle(d, styles);
}
function mCenterFlexNowrap(d) { mCenterFlex(d, true, true, false); }
function mCenterH(d) {
  let dParent = d.parentNode;
  let b = getBounds(dParent);
  let h = b.width;
  let b1 = getBounds(d);
  let h1 = b1.width;
  let diff = h - h1;
  d.style.marginleft = (diff / 2) + 'px';
}
function mCenterText(d) { d.style.textAlign = 'center'; }
function mCenterV(d) {
  let dParent = d.parentNode;
  let b = getBounds(dParent);
  let h = b.height;
  let b1 = getBounds(d);
  let h1 = b1.height;
  let diff = h - h1;
  d.style.marginTop = (diff / 2) + 'px';
}
function mCheckbox(label, val, dParent, handler, styles) {
  styles.align = 'left';
  let d = mDiv(dParent, styles);
  let hpad = valf(styles.hpadding, 4);
  let dLabel = mDiv(d, { w: '40%', align: 'right', hpadding: hpad, display: 'inline-block' }, null, label);
  let d2 = mDiv(d, { display: 'inline', w: '50%', hpadding: hpad });
  let inp = createElementFromHTML(
    `<input type="checkbox" class="checkbox" ` + (val === true ? 'checked=true' : '') + ` >`);
  mAppend(d2, inp);
  inp.onchange = (ev) => { handler(inp.checked, ev); };
  return inp;
}
function mCheckbox_dep(label, val, dParent, styles = {}, id) {
  let d = mDiv(dParent, { display: 'inline-block', align: 'left' });
  let inp = createElementFromHTML(
    `<input type="checkbox" class="checkbox" ${(val === true ? 'checked=true' : '')} >`
  );
  if (isdef(id)) inp.id = id;
  let labelui = createElementFromHTML(`<label>${label}</label>`);
  mAppend(d, labelui);
  mAppend(labelui, inp);
  mStyleX(inp, styles);
  mClass(inp, 'input');
  return inp;
}
function mCheckit(elem, sz = 50) {
  if (nundef(sz)) sz = getRect(elem).h;
  let d = markerSuccess();
  mpOver(d, elem, sz * (4 / 5), 'limegreen', 'segoeBlack');
  mMoveBy(d, 0, -4);
  return d;
}
function mCircle(dParent, x, y, rad, color) {
  let d = mDiv(dParent, { w: 2 * rad, h: 2 * rad, bg: color, rounding: '50%' });
  mCenterAt(d, x, y);
  return d;
}
function mClass(d) {
  d = toElem(d);
  if (arguments.length == 2) {
    let arg = arguments[1];
    if (isString(arg) && arg.indexOf(' ') > 0) { arg = [toWords(arg)]; }
    else if (isString(arg)) arg = [arg];
    if (isList(arg)) {
      for (let i = 0; i < arg.length; i++) {
        d.classList.add(arg[i]);
      }
    }
  } else for (let i = 1; i < arguments.length; i++) d.classList.add(arguments[i]);
}
function mClass0(d) { d = toElem(d); d.className = ''; }
function mClasses(d, lst) { for (let i = 1; i < lst.length; i++) d.classList.add(lst[i]); }
function mClassOnly(d, s) { d.className = s; }
function mClassRemove(d) { d = toElem(d); for (let i = 1; i < arguments.length; i++) d.classList.remove(arguments[i]); }
function mClassReplace(d, weg, her) { mClassRemove(d, weg); mClass(d, her); }
function mClassToggle(d, classes) {
  let wlist = toWords(classes);
  d = toElem(d);
  for (const c of wlist) if (d.classList.contains(c)) mClassRemove(d, c); else mClass(d, c);
}
function mClear(d) { clearElement(toElem(d)); }
function mColFlex(dParent, chflex = [1, 5, 1], bgs) {
  let styles = { opacity: 1, display: 'flex', aitems: 'stretch', 'flex-flow': 'nowrap' };
  mStyle(dParent, styles);
  let res = [];
  for (let i = 0; i < chflex.length; i++) {
    let bg = isdef(bgs) ? bgs[i] : null;
    let d1 = mDiv(dParent, { flex: chflex[i], bg: bg });
    res.push(d1);
  }
  return res;
}
function mColor(d, bg, fg) { return mStyle(d, { 'background-color': bg, 'color': fg }); }
function mColorLetters(s, brightness) {
  return toLetters(s).map(x => `<div style='display:inline-block;transform:rotate(${rChoose([10, 5, -10, -5])}deg);color:${rColor(brightness)}'>${x == ' ' ? '&nbsp;' : x}</div>`).join('');
}
function mColorPicker0(dParent, palette, onColor) {
  let dPalette = mDiv(dParent, { margin: 4 }); mFlex(dPalette);
  let items = [];
  for (const c of palette) {
    dColor = mDiv(dPalette, { display: 'inline-block', w: 50, h: 50, bg: c, rounding: 4, margin: 4 });
    let item = { color: c, isSelected: false };
    iAdd(item, { div: dColor });
    items.push(item);
  }
  let picker = { div: dPalette, selected: null, items: items };
  for (const item of items) {
    iDiv(item).onclick = (ev) => {
      console.log('click!!!', ev.target);
      picker.selectedItem = iToggleSingleSelection(item, items);
      onColor(item.color);
    }
  }
  return picker;
}
function mColorPicker1(dParent, palette, onColor) {
  let dPalette = mDiv(dParent, { margin: 4 }); mFlex(dPalette);
  let items = [];
  for (const c of palette) {
    dColor = mDiv(dPalette, { display: 'inline-block', w: 50, h: 50, bg: c, rounding: 4, margin: 4 });
    let item = { color: c, isSelected: false };
    iAdd(item, { div: dColor });
    items.push(item);
  }
  let picker = { div: dPalette, selected: null, items: items };
  for (const item of items) {
    iDiv(item).onclick = (ev) => {
      console.log('click!!!', ev.target);
      picker.selectedItem = iToggleSingleSelection(item, items);
      onColor(item.color);
    }
  }
  let elem = mCreate('input'); mAppend(dPalette, elem);
  let alphaPicker = new JSColor(elem, {});
  let alphaItem = { isSelected: false };
  alphaPicker.onChange = () => { alphaItem.color = elem.value; onColor(elem.value); }
  alphaItem.picker = alphaPicker;
  iAdd(alphaItem, { div: elem });
  items.push(alphaItem);
  return picker;
}
function mColorPicker2(dParent, palette, onColor, initialColor) {
  let elem = mDiv(dParent, { w: 50, h: 50, display: 'inline-block' });
  let picker = new JSColor(elem, {
    alpha: 'ff',
    closeButton: true,
    value: initialColor,
    palette: palette,
  });
  picker.onInput = () => { let c = picker.toHEXAString(); onColor(c); console.log('picked', c); }
  return picker;
}
function mColorPicker3(elem, palette, onColor, initialColor) {
  let picker = new JSColor(elem, {
    alpha: 'ff',
    closeButton: true,
    value: initialColor,
    palette: palette,
  });
  picker.onInput = () => { let c = picker.toHEXAString(); onColor(c); console.log('picked', c); }
  return picker;
}
function mColorPickerBehavior(value, targetImage, elem, handler) {
  let hues = arrTake(colorHueWheel(value), 10);
  let colorPalette = hues.map(x => colorFrom(colorHSLBuild(x)));
  let palette = isdef(targetImage) ? colorPaletteFromImage(targetImage) : colorPalette;
  mStyle(elem, { bg: value });
  let inp = new JSColor(elem, { alpha: 'ff', closeButton: true, value: value, palette: palette, });
  inp.onInput = () => { let c = inp.toHEXAString(); handler(c); }
  return inp;
}
function mColorPickerControl(label, value, targetImage, dParent, handler, styles = { hpadding: 25 }) {
  let d = mDiv(dParent, styles);
  let hpad = valf(styles.hpadding, 6);
  let dLabel = mDiv(d, { 'vertical-align': 'top', w: '35%', align: 'right', hpadding: hpad, display: 'inline-block' }, null, label);
  let hues = arrTake(colorHueWheel(value), 10);
  let colorPalette = hues.map(x => colorFrom(colorHSLBuild(x)));
  let palette = isdef(targetImage) ? colorPaletteFromImage(targetImage) : colorPalette;
  let elem = mDiv(d, { w: '55%', hpadding: hpad, h: 24, rounding: hpad, display: 'inline-block' });
  let inp = new JSColor(elem, {
    alpha: 'ff',
    closeButton: true,
    value: value,
    palette: palette,
  });
  inp.onInput = () => { let c = inp.toHEXAString(); handler(c); }
  return inp;
}
function mColorX(d, bg, fg) {
  [bg, fg] = getExtendedColors(bg, fg);
  return mColor(d, bg, fg);
}
function mCols(dParent, arr, itemStyles = { bg: 'random' }, rowStyles, colStyles, akku) {
  let d0 = mDiv100(dParent, { display: 'flex', 'justify-content': 'space-between' });
  if (isdef(colStyles)) mStyle(d0, colStyles);
  for (let i = 0; i < arr.length; i++) {
    let content = arr[i];
    if (isList(content)) {
      d1 = mDiv(d0);
      mRows(d1, content, itemStyles, rowStyles, colStyles, akku);
    } else {
      d1 = mContent(content, d0, itemStyles);
      akku.push(d1);
    }
  }
}
function mColsX(dParent, arr, itemStyles = { bg: 'random' }, rowStyles, colStyles, akku) {
  let d0 = mDiv100(dParent, { display: 'flex', 'justify-content': 'space-between' });
  if (isdef(colStyles)) mStyle(d0, colStyles);
  for (let i = 0; i < arr.length; i++) {
    let content = arr[i];
    if (isList(content)) {
      d1 = mDiv(d0);
      mRowsX(d1, content, itemStyles, rowStyles, colStyles, akku);
    } else {
      d1 = mContentX(content, d0, itemStyles);
      akku.push(d1);
    }
  }
}
function mConfine(n, modul, min, max) {
  rem = n % modul; n = n - rem;
  while (n < min) n += modul;
  while (n > max) n -= modul;
  return n;
}
function mContainer(d, styles = {}) {
  let defOuterStyles = {
    display: 'inline-flex', 'flex-direction': 'column',
    'justify-content': 'center', 'align-items': 'center', 'vertical-align': 'top',
    padding: 0, box: true
  };
  addKeys(d, defOuterStyles);
  mStyleX(d, styles);
}
function mContainerSplay(d, splay, w, h, num, ov) {
  if (nundef(splay)) splay = 2;
  if (!isNumber(splay)) splay = get_splay_number(splay);
  if (isString(ov) && ov[ov.length - 1] == '%') ov = splay == 0 ? 1 : splay == 3 ? Number(ov) * h / 100 : Number(ov) * w / 100;
  if (splay == 3) {
    d.style.display = 'grid';
    d.style.gridTemplateRows = `repeat(${num},${ov}px)`;
    console.log('HAAAAAAAAAAAALLLLLLLLLLLLLLLLLLLLLLLLLLOOOOOOOOOOOOOOOOOOOOOOOOO')
    d.style.minHeight = `${h + (num - 1) * (ov * 1.1)}px`;
  } else if (splay == 2 || splay == 1) {
    d.style.display = 'grid';
    d.style.gridTemplateColumns = `repeat(${num},${ov}px)`;
    let wnew = w + (num - 1) * (ov * 1.1);
    d.style.minWidth = `${w + (num - 1) * (ov * 1.1)}px`;
  } else if (splay == 0) {
    d.style.display = 'grid'; ov = .5
    d.style.gridTemplateColumns = `repeat(${num},${ov}px)`;
    d.style.minWidth = `${w + (num - 1) * (ov * 1.1)}px`;
  } else if (splay == 5) {
    d.style.display = 'grid';
    d.style.gridTemplateColumns = `${ov}px repeat(${num - 1},${ov / 2}px)`;
    d.style.minWidth = `${w + (num) * (ov / 2 * 1.1)}px`;
  } else if (splay == 4) {
    d.style.position = 'relative';
    if (nundef(ov)) ov = .5;
    d.style.minWidth = `${w + (num - 1) * (ov * 1.1)}px`;
    d.style.minHeight = `${h + (num - 1) * (ov * 1.1)}px`;
  }
}
function mContainerSplay_WORKS(d, splay, w, h, num, ov) {
  if (!isNumber(splay)) splay = get_splay_number(splay);
  if (isString(ov) && ov[ov.length - 1] == '%') ov = splay == 0 ? 1 : splay == 3 ? Number(ov) * h / 100 : Number(ov) * w / 100;
  if (splay == 3) {
    d.style.display = 'grid';
    d.style.gridTemplateRows = `repeat(${num},${ov}px)`;
    d.style.height = `${h + (num - 1) * (ov * 1.1)}px`;
  } else if (splay == 2 || splay == 1) {
    d.style.display = 'grid';
    d.style.gridTemplateColumns = `repeat(${num},${ov}px)`;
    d.style.width = `${w + (num - 1) * (ov * 1.1)}px`;
  } else if (splay == 0) {
    d.style.display = 'grid'; ov = .5
    d.style.gridTemplateColumns = `repeat(${num},${ov}px)`;
    d.style.width = `${w + (num - 1) * (ov * 1.1)}px`;
  } else if (splay == 4) {
    d.style.position = 'relative';
    if (nundef(ov)) ov = .5;
    d.style.width = `${w + (num - 1) * (ov * 1.1)}px`;
    d.style.height = `${h + (num - 1) * (ov * 1.1)}px`;
  }
}
function mContent(content, dParent, styles) {
  let d1 = isdef(Syms[content]) ? mSymInDivShrink(content, dParent, styles) : mDiv(dParent, styles, null, content);
  return d1;
}
function mContentX(content, dParent, styles = { sz: Card.sz / 5, fg: 'random' }) {
  let [key, scale] = isDict(content) ? [content.key, content.scale] : [content, 1];
  if (scale != 1) { styles.transform = `scale(${scale},${Math.abs(scale)})`; }
  let dResult = mDiv(dParent);
  let ds = isdef(Syms[key]) ? mSym(key, dResult, styles) : mDiv(dResult, styles, null, key);
  return dResult;
}
function mCreate(tag, styles, id) { let d = document.createElement(tag); if (isdef(id)) d.id = id; if (isdef(styles)) mStyle(d, styles); return d; }
function mcreate_map(opts) {
  let center = M.center = valf(opts.center, Geo.places.tuerkenschanzpark);
  let zoom = M.zoom = valf(opts.zoom, 19);
  let [minzoom, maxzoom] = [M.minzoom, M.maxzoom] = [2, 19];
  let map = mget_map(center, zoom);
  mset_bounds(minzoom, maxzoom);
  mset_layers(opts.base, opts.overlay);
  return map;
}
function mCreateFrom(htmlString) {
  var div = document.createElement('div');
  div.innerHTML = htmlString.trim();
  return div.firstChild;
}
function mDataTable(reclist, dParent, rowstylefunc, headers, id, showheaders = true) {
  if (nundef(headers)) headers = get_keys(reclist[0]);
  let t = mTable(dParent, headers, showheaders);
  if (isdef(id)) t.id = `t${id}`;
  let rowitems = [];
  let i = 0;
  for (const u of reclist) {
    let rid = isdef(id) ? `r${id}_${i}` : null;
    r = mTableRow(t, u, headers, rid);
    if (isdef(rowstylefunc)) mStyle(r.div, rowstylefunc(u));
    rowitems.push({ div: r.div, colitems: r.colitems, o: u, id: rid, index: i });
    i++;
  }
  return { div: t, rowitems: rowitems };
}
function mDefault(n, R, area) {
  let ui;
  let dParent = mBy(n.idUiParent);
  ui = mDiv(dParent);
  if (isdef(n.content)) {
    let d;
    if (n.type != 'manual00') d = mNode(n.content, ui, n.title, isSizedNode(n));
    else d = mNode(n.content, ui, n.title);
    if (isdef(n.params['text-align'])) d.style.textAlign = n.params['text-align'];
  }
  if (n.type != 'manual00') addClassInfo(ui, n);
  return ui;
}
function mDestroy(elem) { if (isString(elem)) elem = mById(elem); purge(elem); }
function mDictionary(o, { dParent, title, flattenLists = true, className = 'node', omitEmpty = false } = {}) {
  let oCopy = jsCopy(o);
  let d = mCreate('div');
  if (isdef(className)) mClass(d, className);
  mYaml(d, oCopy);
  let pre = d.getElementsByTagName('pre')[0];
  pre.style.fontFamily = 'inherit';
  if (isdef(title)) mInsert(d, mText(title));
  if (isdef(dParent)) mAppend(dParent, d);
  return d;
}
function mDictionary_dep(o, { dParent, title, flattenLists = true, className = 'node', omitEmpty = false } = {}) {
  let oCopy = jsCopy(o);
  if (flattenLists) { recFlattenLists(oCopy); }
  let d = mCreate('div');
  if (isdef(className)) mClass(d, className);
  mYaml(d, oCopy);
  let pre = d.getElementsByTagName('pre')[0];
  pre.style.fontFamily = 'inherit';
  if (isdef(title)) mInsert(d, mText(title));
  if (isdef(dParent)) mAppend(dParent, d);
  return d;
}
function mDisable(elem) { elem = toElem(elem); mStyle(elem, { cursor: 'default', opacity: 0 }); }
function mDiv(dParent, styles, id, inner, classes, sizing) {
  dParent = toElem(dParent);
  let d = mCreate('div');
  if (dParent) mAppend(dParent, d);
  if (isdef(styles)) mStyle(d, styles);
  if (isdef(classes)) mClass(d, classes);
  if (isdef(id)) d.id = id;
  if (isdef(inner)) d.innerHTML = inner;
  if (isdef(sizing)) { setRect(d, sizing); }
  return d;
}
function mDiv100(dParent, styles, id, sizing = false) { let d = mDiv(dParent, styles, id); mSize(d, 100, 100, '%', sizing); return d; }
function mDivCenteredAt(pt, dParent, styles = {}, id, inner, classes) {
  [w, h] = detect_size_from_styles(styles);
  addKeys({ position: 'relative' }, dParent);
  copyKeys({ position: 'absolute', x: w / 2, y: h / 2 }, styles);
  return mDiv(dParent, styles, id, inner, classes);
}
function mDivG(area, w, h, color) {
  let d = mDiv(mBy('table'));
  if (isdef(w)) mSize(d, w, h);
  if (isdef(color)) mColor(d, color);
  let g = aSvgg(d);
  return g;
}
function mDivItem(dParent, styles, id, content) {
  if (nundef(id)) id = getUID();
  let d = mDiv(dParent, styles, id, content);
  return mItem(id, { div: d });
}
function mDivLine(dParent, styles = {}, id = null, innerlist = ['', '', ''], classes = null) {
  addKeys({ w: '100%', box: true, padding: 4 }, styles);
  let d = mDiv(dParent, styles, id, `<div>${innerlist[0]}</div><div>${innerlist[1]}</div><div>${innerlist[2]}</div>`, classes);
  mStyle(d, { display: 'flex', 'justify-content': 'space-between', 'align-items': 'center' });
  return d;
}
function mDivLR(dParent, styles, id, innerlist, classes) {
  let d = mDiv(dParent, styles, id, `<div>${innerlist[0]}</div><div>${innerlist[1]}</div>`, classes);
  mStyle(d, { display: 'flex', 'justify-content': 'space-between', 'align-items': 'center' });
  return d;
}
function mDivPosAbs(x = 0, y = 0, dParent = null) { let d = mCreate('div'); if (dParent) mAppend(dParent, d); mPos(d, x, y); return d; }
function mDivPosRel(x = 0, y = 0, dParent = null) { let d = mCreate('div'); if (dParent) mAppend(dParent, d); mPosRel(d, x, y); return d; }
function mDivRestOfPage(dParent, dAbove, styles, id, inner, classes, sizing) {
  let d = mDiv(dParent, styles, id, inner, classes, sizing);
  let fSize = () => {
    let top = getRect(dAbove).h;
    console.log('top', top, '?');
    let h = window.innerHeight - (isNumber(top) ? top : 31);
    mSize(d, '100%', h);
    setRect(d);
    console.log('d', d);
  };
  new ResizeObserver(() => {
    let r = getRect(dAbove);
    console.log('haaaaaaaaaaaaaaaaaaaaaaaaaaaaaaar', r);
    fSize();
  }).observe(dAbove);
  window.onresize = fSize;
  return d;
}
function mDivSvg(area, w, h, color) {
  let d = mDiv(mBy('table'));
  if (isdef(w)) mSize(d, w, h);
  if (isdef(color)) mColor(d, color);
  let g = aSvgg(d);
  return g;
}
function mdo(o, p, d) {
  p = { x: p.x, y: p.y + d };
  if (o) o.setPos(p.x, p.y);
  return p;
}
function mDom(dParent, styles = {}, opts = {}) {
  let tag = valf(opts.tag, 'div');
  let d = document.createElement(tag);
  mAppend(dParent, d);
  if (tag == 'textarea') styles.wrap = 'hard';
  const aliases = {
    classes: 'className',
    inner: 'innerHTML',
    html: 'innerHTML',
  };
  for (const opt in opts) { d[valf(aliases[opt], opt)] = opts[opt] };
  mStyle(d, styles);
  return d;
}
function mDom100(dParent, styles, opts) {
  if (nundef(styles.w) && nundef(styles.wrest)) addKeys({ w100: true }, styles);
  if (nundef(styles.h) && nundef(styles.hrest)) addKeys({ h100: true }, styles);
  return mDom(dParent, styles, opts);
}
function mDomRest(dParent, styles, opts) {
  if (nundef(styles.w) && nundef(styles.w100)) addKeys({ wrest: true }, styles);
  if (nundef(styles.h) && nundef(styles.h100)) addKeys({ hrest: true }, styles);
  return mDom(dParent, styles, opts);
}
function mDover(dParent, styles = {}, sizing = true) {
  let d = mDiv(dParent, styles);
  mIfNotRelative(dParent);
  mStyle(d, { position: 'absolute', left: 0, top: 0, w: '100%', h: '100%' });
  setRect(d, sizing);
  return d;
}
function mDraggable(item) {
  let d = iDiv(item);
  d.draggable = true;
  d.ondragstart = drag;
}
function mDropImage(e, img) {
  var dt = e.dataTransfer;
  console.log('dropped', dt)
  var files = dt.files;
  if (files.length) {
    let imgFile = files[0];
    var reader = new FileReader();
    reader.onload = function (e) {
      img.src = e.target.result;
      imgFile.data = e.target.result;
    }
    reader.readAsDataURL(imgFile);
  } else {
    console.log('dropped on', e.target, 'img', img);
    clearElement(img);
    var html = dt.getData('text/html');
    console.log('__________dataTransfer', html);
    let match = html && /\bsrc="?([^"\s]+)"?\s*/.exec(html);
    let url = match && match[1];
    if (url) {
      console.log('JA!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
      img.onerror = function () {
        alert("Error in uploading");
      }
      img.crossOrigin = "";
      img.src = url;
    }
  }
}
function mDroppable(item, handler, dragoverhandler) {
  let d = iDiv(item);
  d.ondragover = isdef(dragoverhandler) ? dragoverhandler : default_allowDrop;
  d.ondrop = handler;
}
function measure_fieldset(fs) {
  let legend = fs.firstChild;
  let r = getRect(legend);
  let labels = fs.getElementsByTagName('label');
  let wmax = 0;
  for (const l of labels) {
    let r1 = getRect(l);
    wmax = Math.max(wmax, r1.w);
  }
  let wt = r.w;
  let wo = wmax + 24;
  let diff = wt - wo;
  if (diff >= 10) {
    for (const l of labels) { let d = l.parentNode; mStyle(d, { maleft: diff / 2 }); }
  }
  let wneeded = Math.max(wt, wo) + 10;
  mStyle(fs, { wmin: wneeded });
  for (const l of labels) { let d = l.parentNode; mStyle(l, { display: 'inline-block', wmin: 50 }); mStyle(d, { wmin: wneeded - 40 }); }
}
function measureDefaultPlayerElement(plms) {
  let elem = plms.elem;
  let w = $(elem).width();
  if (nundef(S.vars.wDefaultPlayer)) S.vars.wDefaultPlayer = w;
  else if (w > S.vars.wDefaultPlayer) S.vars.wDefaultPlayer = w;
}
function measureDomel(mobj) {
  let el = mobj.elem;
  let info = window.getComputedStyle(el, null);
  mobj.x = getAsInt(mobj, info, 'left');
  mobj.y = getAsInt(mobj, info, 'top');
  mobj.w = getAsInt(mobj, info, 'width');
  mobj.h = getAsInt(mobj, info, 'height');
  mobj.bg = info.backgroundColor;
  mobj.fg = info.color;
  return [mobj.x, mobj.y, mobj.w, mobj.h];
}
function measureElem(ms) {
  let el = ms.elem;
  ms.w = el.offsetWidth; ms.h = el.offsetHeight; ms.x = el.offsetLeft; ms.y = el.offsetTop;
  return [ms.x, ms.y, ms.w, ms.h];
}
function measureMSTree(root) {
  let divs = root.elem.getElementsByTagName('div');
  let divNames = [...divs].map(x => x.id);
  divNames = divNames.filter(x => !isEmpty(x));
  divNames.map(x => { measureDomel(UIS[x]) });
  let tabDivs = document.getElementById('a_d_testing').getElementsByClassName('divInTab');
  let correctTabName = 'a_d_objects';
  let correctMS = UIS[correctTabName];
  for (const div of [...tabDivs]) {
    let id = div.id;
    if (id == correctTabName) continue;
    let mobj = UIS[id];
    mobj.x = correctMS.x; mobj.y = correctMS.y; mobj.w = correctMS.w; mobj.h = correctMS.h;
  }
}
function measureText(text, styles = {}, cx = null) {
  if (!cx) {
    var canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement('canvas'));
    cx = canvas.getContext('2d');
  }
  cx.font = isdef(styles.font) ? styles.font : `${styles.fz}px ${styles.family}`;
  var metrics = cx.measureText(text);
  return { w: metrics.width, h: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent };
}
function measureText1(text, fz, family, weight = 900) {
  console.log(text, fz, family)
  let sFont = '' + weight + ' ' + fz + 'px ' + family;
  sFont = sFont.trim();
  var canvas = document.createElement('canvas');
  var context = canvas.getContext('2d');
  context.font = sFont;
  var metrics = context.measureText(text);
  let actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
  return { w: metrics.width, h: actualHeight };
}
function measureTextX(text, fz, family, weight = 900) {
  let sFont = '' + weight + ' ' + fz + 'px ' + family;
  sFont = sFont.trim();
  var canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement('canvas'));
  var context = canvas.getContext('2d');
  context.font = sFont;
  var metrics = context.measureText(text);
  let actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
  console.log(metrics.width, actualHeight, fz)
  return { w: metrics.width, h: actualHeight, fz: fz };
}
function measureWord(w, fz) { let styles = { fz: fz, family: 'arial' }; return getSizeWithStyles(w, styles); }
function mEdit(label, value, dParent, handler, styles, classes, id) {
  let d = mDiv(dParent, styles);
  let hpad = valf(styles.hpadding, 4);
  let dLabel = mDiv(d, { w: '50%', align: 'right', hpadding: hpad, display: 'inline-block' }, null, label);
  let inp = mCreateFrom(`<div contenteditable="true" spellcheck="false">${value}</div>  `)
  mAppend(d, inp);
  mStyle(inp, { display: 'inline-block', w: '50%', align: 'left', hpadding: hpad });
  inp.addEventListener('keydown', unfocusOnEnter);
  inp.addEventListener('focusout', ev => { handler(inp.innerHTML, ev); });
  inp.onclick = ev => selectText(ev.target);
  if (isdef(classes)) mClass(inp, classes);
  if (isdef(id)) inp.id = id;
  return inp;
}
function mEditableInput(dParent, label, val, styles, classes, id) {
  let labelElem = mCreateFrom(`<span>${label}</span>  `)
  let elem = mCreateFrom(`<span contenteditable="true" spellcheck="false">${val}</span>  `)
  elem.addEventListener('keydown', (ev) => {
    if (ev.key === 'Enter') {
      ev.preventDefault();
      mBy('dummy').focus();
    }
  });
  let dui = mDiv(dParent, { margin: 2 });
  mAppend(dui, labelElem);
  mAppend(dui, elem);
  if (isdef(styles)) {
    if (isdef(styles.wInput)) mStyle(elem, { wmin: styles.wInput });
    mStyle(elem, styles);
  }
  if (isdef(classes)) mStyle(elem, classes);
  if (isdef(id)) elem.id = id;
  return elem;
}
function mEditableOnEdited(id, dParent, label, initialVal, onEdited, onOpening, styles, classes) {
  let inp = mEditableInput(dParent, label, initialVal, styles, classes);
  inp.id = id;
  if (isdef(onOpening)) { inp.addEventListener('focus', ev => onOpening(ev)); }
  inp.addEventListener('focusout', ev => {
    window.getSelection().removeAllRanges();
    if (isdef(onEdited)) onEdited(inp.innerHTML, ev);
  });
  return inp;
}
function mEditNumber(label, value, dParent, handler, styles, classes, id, triggerOnChange = false) {
  let d = mDiv(dParent, styles);
  let hpad = valf(styles.hpadding, 4);
  let dLabel = mDiv(d, { w: '50%', align: 'right', hpadding: hpad, display: 'inline-block' }, null, label);
  if (nundef(handler)) handler = x => console.log(x);
  let inp = mCreateFrom(`<div contenteditable="true" spellcheck="false">${value}</div>  `)
  mAppend(d, inp);
  mStyle(inp, { display: 'inline-block', w: '40%', align: 'left', hpadding: hpad });
  inp.addEventListener('keydown', unfocusOnEnter);
  inp.addEventListener('focusout', ev => { handler(inp.innerHTML, ev); });
  inp.onclick = ev => selectText(ev.target);
  if (isdef(classes)) mClass(inp, classes);
  if (isdef(id)) inp.id = id;
  return inp;
}
function mEditRange(label, value, min, max, step, dParent, handler, styles, classes, id, triggerOnChange = true) {
  let d = mDiv(dParent, styles);
  let hpad = valf(styles.hpadding, 4);
  let dLabel = mDiv(d, { w: '30%', align: 'right', hpadding: hpad, display: 'inline-block' }, null, label);
  let inpText = mCreateFrom(`<input type='number'  step=${step} min="${min}" max="${max}" value="${value}" ></input>`);
  let inp = mCreateFrom(`<input type="range" step=${step} min="${min}" max="${max}" value="${value}" ></input>`);
  mAppend(d, inpText);
  mAppend(d, inp);
  mStyle(inpText, { display: 'inline', w: '20%', align: 'left', hpadding: hpad });
  mStyle(inp, { display: 'inline', w: '40%', hpadding: hpad });
  inpText.onchange = (ev) => { inp.value = inpText.value; handler(inpText.value, ev); };
  inpText.onclick = ev => selectText(ev.target);
  inp.onchange = (ev) => { inpText.value = inp.value; handler(inpText.value, ev); };
  if (isdef(classes)) mClass(inp, classes);
  if (isdef(id)) inp.id = id;
  return inpText;
}
function mEditX(label, val, dParent, styles, classes, handler, id, opt = {}) {
  let defOptions = {
    alignLabel: 'right',
    fgLabel: 'silver',
    wminLabel: 120,
    alignInput: 'left',
    fgInput: 'white',
    wminInput: 50,
    wminRight: 120,
    align: 'center',
  }
  addKeys(defOptions, opt);
  let wminTotal = wminLabel + wminRight;
  if (nundef(styles)) styles = {};
  if (nundef(styles.wmin)) styles.wmin = 0;
  styles.wmin = Math.max(styles.wmin, wminTotal);
  styles.align = opt.align;
  let dOuter = mDiv(dParent, styles, id, null, classes);
  let dLabel = mDiv(dOuter, { fg: opt.fgLabel, wmin: opt.wminLabel, align: opt.alignLabel }, null, label);
  let dInput = mDiv(dOuter, { contenteditable: true, spellcheck: false, fg: opt.fgInput, wmin: opt.wminInput, align: opt.alignInput }, null, val);
  dInput.onfocusout = ev => handler(dInput.innerHTML, ev);
  dInput.onkeydown = (ev) => {
    if (ev.key === 'Enter') {
      ev.preventDefault();
      mBy('dummy').focus();
    }
  }
  return dInput;
}
function mEnable(elem) { elem = toElem(elem); mStyle(elem, { cursor: 'pointer', opacity: 1 }); }
function mEnsure(d) { return isString(d) ? mById(d) : d; }
function menu_disable(key, elem) {
  let d = menu_find_elem(key, elem);
  if (d) {
    mClassRemove(d, 'enabled');
    mClass(d, 'disabled');
    d.setAttribute('enabled', false);
  }
}
function menu_enable(key, elem) {
  let d = menu_find_elem(key, elem);
  if (d) {
    mClassRemove(d, 'disabled');
    mClass(d, 'enabled');
    d.setAttribute('enabled', true);
  }
}
function menu_enabled(key, elem) {
  let d = menu_find_elem(key, elem);
  return d ? mHasClass(d, 'enabled') : false;
}
function menu_find_elem(key, elem) {
  elem = isdef(elem) ? elem : isdef(mBy('label_' + key)) ? mBy('label_' + key) : isdef(mBy(key)) ? mBy(key) : isdef(Items[key]) ? iDiv(Items[key]) : null;
  if (nundef(elem)) { console.log('no menu with key', key); return null; }
  return elem;
}
function merge1(sp1, sp2, { dataMerge } = {}) {
  let options = {
    sub: (a, b, opt) => b.concat(a),
    data: (a, b, opt) => isLiteral(a) && isLiteral(b) ?
      nundef(dataMerge) || dataMerge == 'concat' ? a + ' ' + b
        : dataMerge == 'reverse' ? b + ' ' + a
          : b
      : dm1(a, b, opt),
  };
  return dm1(sp1, sp2, options);
}
function mergeAllRefsToIdIntoNode(n, R) {
  let loc = n._id;
  let refDictBySpecNodeName = R.refs[loc];
  let nNew = jsCopy(n);
  for (const spNodeName in refDictBySpecNodeName) {
    let reflist = refDictBySpecNodeName[spNodeName];
    for (const ref of reflist) {
      nNew = deepmergeOverride(nNew, ref);
    }
  }
  return nNew;
}
function mergeArr(a, b, opt) {
  var res = a.slice()
  b.forEach(function (e, i) {
    if (typeof res[i] === 'undefined') {
      res[i] = cloneIfNecessary(e, opt)
    } else if (isDictOrList(e)) {
      res[i] = dm1(a[i], e, opt);
    } else if (a.indexOf(e) === -1) {
      res.push(cloneIfNecessary(e, opt));
    }
  })
  return res
}
function mergeChildrenWithRefs(n, R) {
  for (const k in n) {
    let ch = n[k];
    if (nundef(ch._id)) continue;
    let loc = ch._id;
    let refs = R.refs[loc];
    if (nundef(refs)) continue;
    let spKey = Object.keys(refs)[0];
    let nSpec = R.lastSpec[spKey];
    let oNew = deepmerge(n[k], nSpec);
    n[k] = oNew;
  }
}
function mergeCombine(base, drueber) { return _deepMerge(base, drueber); }
function mergeCombineArrays(base, drueber) {
  return deepmerge(base, drueber);
}
function mergeCreatedAndUpdated(data) {
  if (!('created' in data)) data.created = {};
  data.created = extend(true, data.created, data.updated);
  let mergeFailed = false;
  let d = {};
  if ('created' in data && 'updated' in data) {
    for (const id in data.updated) {
      if (!(id in data.created)) {
        d.summary = 'missing id in data.created ' + id;
      } else {
        for (const key in data.updated[id]) {
          if (!(key in data.created[id]) || data.created[id][key] != data.updated[id][key]) {
            if (key == 'visible') {
              let set1 = getVisibleSet(data.created[id]);
              let set2 = getVisibleSet(data.updated[id]);
              if (sameList(set1, set2)) continue;
              if (empty(set1) && empty(set2)) continue;
            }
          }
        }
      }
      if (mergeFailed) {
        console.log('MERGE FAILED!!!', id, d.summary.toString(), data);
      }
    }
  }
}
function mergedSpecNode(n1, n2) {
  if (nundef(n1.cond) && nundef(n2.cond)) {
    return merge1(n1, n2);
  } else {
    return deepmerge(n1, n2);
  }
}
function mergeDynSetNodes(o) {
  let merged = {};
  let interpool = null;
  for (const nodeId in o.RSG) {
    let node = jsCopy(dynSpec[nodeId]);
    let pool = node.pool;
    if (pool) {
      if (!interpool) interpool = pool;
      else interpool = intersection(interpool, pool);
    }
    merged = deepmerge(merged, node);
  }
  merged.pool = interpool;
  return merged;
}
function mergeIncludingPrototype(oid, o) {
  let merged = mergeDynSetNodes(o);
  merged.oid = oid;
  let t = merged.type;
  let info;
  if (t && PROTO[t]) {
    info = deepmerge(merged, jsCopy(PROTO[t]));
  } else info = merged;
  return info;
}
function mergeObj(a, b, opt) {
  var res = {}
  if (nundef(a)) return b;
  else if (nundef(b)) return a;
  else if (isLiteral(a)) return b;
  else if (isLiteral(b)) return a;
  else if (isDictOrList(a)) {
    Object.keys(a).forEach(function (key) {
      res[key] = cloneIfNecessary(a[key], opt);
    })
  };
  Object.keys(b).forEach(function (key) {
    let func = opt[key];
    if (!res[key]) {
      res[key] = isLiteral(b[key]) ? b[key] : jsCopy(b[key]);
    } else if (func) {
      res[key] = func(a[key], b[key], opt);
    } else if (isLiteral(a[key])) {
      res[key] = cloneIfNecessary(b[key], opt);
    } else {
      res[key] = dm1(a[key], b[key], opt);
    }
  })
  return res;
}
function mergeObject(target, source, optionsArgument) {
  var destination = {}
  if (isMergeableObject(target)) {
    Object.keys(target).forEach(function (key) {
      destination[key] = cloneIfNecessary(target[key], optionsArgument)
    })
  }
  Object.keys(source).forEach(function (key) {
    if (!isMergeableObject(source[key]) || !target[key]) {
      destination[key] = cloneIfNecessary(source[key], optionsArgument)
    } else {
      destination[key] = deepmerge(target[key], source[key], optionsArgument)
    }
  })
  return destination;
}
function mergeOverride(base, drueber) { return _deepMerge(base, drueber, { arrayMerge: _overwriteMerge }); }
function mergeOverrideArrays(base, drueber) {
  return deepmerge(base, drueber, { arrayMerge: overwriteMerge });
}
function message_controls() {
  return `
  </div>
  <div style='display:flex;gap:10px;padding:10px;box-sizing:border-box;width:100%;height:60px;'>
    <label for='message_file'><img src='../base/assets/images/icons/clip.png' style='opacity:0.8;width:30px;cursor:pointer;' ></label>
    <input type='file' id='message_file' name='file' style='display:none' onchange='send_image(this.files)' />
    <input id='message_text' onkeyup='enter_pressed(event)' style='flex:6;border:solid thin #ccc;border-bottom:none;font-size:14px;padding:4px;outline:none;' type='text' placeHolder='type your message'/>
    <input style='flex:1;cursor:pointer;outline:none;' type='button' value='send' onclick='send_message(event)'/>
  </div>
  <span onclick='delete_thread(event)' style='color:white;cursor:pointer;'>Delete this thread </span>
  </div>`;
}
function message_left(msg, sender) {
  image = sender.imagePath;
  $a = `
  <div id='message_left'>
  <div></div>
    <img  id='prof_img' src='${image}' class='img_person sz50' style='float: left;margin:2px;'>
    <b>${sender.username}</b><br>
    ${msg.message}<br><br>`;
  if (msg.files != "") {
    $a += `<img src='${msg.files}' style='margin:30px;cursor:pointer;' onclick='image_show(event)' /> <br>`;
  }
  $a += `<span style='font-size:11px;color:white;'>${msg.date}<span>
  <img id='trash' src='../base/assets/images/icons/trash.png' onclick='delete_message(event)' msgid='${msg.id}' />
  </div>`;
  return $a;
}
function message_right(msg, sender) {
  image = sender.imagePath;
  $a = `
  <div id='message_right'>
  <div>`;
  if (msg.seen) {
    $a += "<img src='../base/assets/images/tick.png' style=''/>";
  } else if (msg.received) {
    $a += "<img src='../base/assets/images/tick_grey.png' style=''/>";
  }
  $a += `</div>
    <img id='prof_img' src='${image}' style='float:right;margin:2px;' class='img_person sz50'>
    <b>${sender.username}</b><br>
    ${msg.message}<br><br>`;
  if (msg.files != "") {
    $a += `<img src='${msg.files}' style='margin:30px;cursor:pointer;' onclick='image_show(event)' /> <br>`;
  }
  $a += `<span style='font-size:11px;color:#888;'>${msg.date}<span>
    <img id='trash' src='../base/assets/images/icons/trash.png' onclick='delete_message(event)' msgid='${msg.id}' />
  </div>`;
  return $a;
}
function mFade(d, ms = 800, callback = null) { return mAnimateTo(d, 'opacity', 0, callback, ms); }
function mFadeClear(d, ms = 800, callback = null) { return mAnimateTo(d, 'opacity', 0, () => { mClear(d); if (callback) callback(); }, ms); }
function mFadeClearShow(d, ms = 800, callback = null) { return mAnimate(d, 'opacity', [1, 0], () => { mClear(d); if (callback) callback(); }, ms); }
function mFadeRemove(d, ms = 800, callback = null) { return mAnimateTo(d, 'opacity', 0, () => { mRemove(d); if (callback) callback(); }, ms); }
function mFall(d, ms = 800, dist = 50) { toElem(d).animate([{ opacity: 0, transform: `translateY(-${dist}px)` }, { opacity: 1, transform: 'translateY(0px)' },], { fill: 'both', duration: ms, easing: 'ease' }); }
function mFg(d, color) { d.style.color = color; }
function mFileInput(dParent, dPreviewParent) {
  let dInput = mDiv(dParent, { padding: 4, h: 100, bg: '#fff', align: 'center', cursor: 'pointer', fg: 'gray' });
  let dMessage = mDiv(dInput, {}, null, 'click to browse');
  let dPreview = mDiv(dInput);
  var fakeInput = document.createElement("input");
  fakeInput.type = "file";
  fakeInput.accept = "image/*";
  fakeInput.multiple = false;
  dInput.onclick = () => { fakeInput.click(); };
  let item = { fileObject: null, filename: null, imgData: null, img: null, loaded: false };
  iAdd(item, { div: dInput, dPreview: dPreview });
  var img = mCreate("img"); mAppend(dPreview, img);
  mStyleX(img, { wmax: 100, hmax: 70, mabottom: 4 })
  fakeInput.onchange = function () {
    const reader = new FileReader();
    reader.onload = function () {
      img.src = this.result;
      const base64 = this.result.replace(/.*base64,/, '');
      Socket.emit('image2', base64);
    };
    reader.readAsDataURL(this.files[0]);
  };
  return item;
}
function mFilePreview(item, dParent, allowMultipleChildren = true) {
  let imgFile = item.fileObject;
  if (!allowMultipleChildren) clearElement(dParent);
  var img = mCreate("img"); mAppend(dParent, img);
  mStyleX(img, { wmax: 100, hmax: 70, mabottom: 4 })
  var reader = new FileReader();
  reader.onload = function (e) {
    img.src = e.target.result;
    let bytes = item.bytes = new Uint8Array(e.target.result);
    Socket.emit('image1', bytes);
    item.filenameWithExt = imgFile.name;
    item.filename = stringBefore(imgFile.name, '.');
    item.ext = stringAfter(imgFile.name, '.');
    item.img = img;
    item.previewParent = dParent;
    item.loaded = true;
    console.log('item', item);
  }
  reader.readAsArrayBuffer(imgFile);
}
function mFillText(text, box, padding = 10, perleft = 10, pertop = 20) {
  let r = mMeasure(box);
  let [fz, w, h] = fitFont(text, 14, r.w - padding, r.h - padding);
  let dText = mDiv(box, {
    w: w, h: h, fz: fz,
    position: 'absolute', transform: `translate(-${perleft}%,-${pertop}%)`, top: `${pertop}%`, left: `${perleft}%`
  }, null, text);
  return dText;
}
function mFleeting(inner, d, ms = 3000, styles = {}, classes = null) {
  d = toElem(d);
  addKeys({ transition: 'all .5s ease', padding: 10, box: true, fg: 'red' }, styles)
  if (isdef(styles)) mStyle(d, styles);
  if (isdef(classes)) mClass(d, classes);
  d.innerHTML = inner;
  TO.fleeting = setTimeout(() => mClear(d), ms);
}
function mFlex(d, or = 'h') {
  d = toElem(d);
  d.style.display = 'flex';
  d.style.flexFlow = (or == 'v' ? 'column' : 'row') + ' ' + (or == 'w' ? 'wrap' : 'nowrap');
}
function mFlex1(d) { d.style.display = 'flex'; d.style.flexWrap = 'wrap'; d.style.flex = 1; }
function mFlexCenterContent(d) { mStyle(d, { 'justify-content': 'center', 'align-items': 'center' }); }
function mFlexChild(d, grow = 1, shrink = 0, base = 'auto') {
  d.style.flex = '' + grow + ' ' + shrink + ' ' + base;
}
function mFlexChildSplit(d, split) {
  if (split != 1) { split *= 10; if (split % 2 == 0) split /= 2; }
  d.style.flex = '' + split + ' 0 auto';
}
function mFlexColumn(d, or = 'h') {
  d = toElem(d);
  d.style.display = 'flex';
  d.style.flexFlow = (or == 'v' ? 'column' : 'row') + ' ' + (or == 'w' ? 'wrap' : 'nowrap');
  d.style.alignItems = 'stretch';
  d.style.alignContent = 'stretch';
  d.style.justiifyItems = 'stretch';
  d.style.justifyContent = 'stretch';
}
function mFlexColumnWrap(d) { mStyle(d, { display: 'flex', 'flex-flow': 'column wrap' }); }
function mFlexEvenly(d) {
  let styles = { display: 'flex' };
  styles['justify-content'] = 'space-evenly';
  mStyle(d, styles);
}
function mFlexLinebreak(d) { if (isString(d)) d = mBy(d); let lb = mDiv(d); mClass(lb, 'linebreak'); return lb; }
function mFlexLR(d) { mStyle(d, { display: 'flex', 'justify-content': 'space-between', 'align-items': 'center' }); }
function mFlexSpacebetween(d) { mFlexLR(d); }
function mFlexWrap(d) { mFlex(d, 'w'); }
function mFlexWrapGrow(d) { d.style.display = 'flex'; d.style.flexWrap = 'wrap'; d.style.flex = 1; }
function mFlip(card, ms, callback) {
  let a = mAnimate(iDiv(card), 'transform', [`scale(1,1)`, `scale(0,1)`],
    () => {
      if (card.faceUp) face_down(card); else face_up(card);
      mAnimate(iDiv(card), 'transform', [`scale(0,1)`, `scale(1,1)`], callback, ms / 2, 'ease-in', 0, 'both');
    },
    ms / 2, 'ease-out', 0, 'both');
}
function mFont(d, fz) { d.style.setProperty('font-size', makeUnitString(fz, 'px')); }
function mForm(dParent) {
  return mAppend(dParent, mCreate('form'));
}
function mFromPoint(x, y) {
  var element, elements = [];
  var old_visibility = [];
  while (true) {
    element = document.elementFromPoint(x, y);
    if (!element || element === document.documentElement) {
      break;
    }
    elements.push(element);
    old_visibility.push(element.style.visibility);
    element.style.visibility = 'hidden';
  }
  for (var k = 0; k < elements.length; k++) {
    elements[k].style.visibility = old_visibility[k];
  }
  elements.reverse();
  return elements;
}
function mGap(d, gap) { d.style.setProperty('margin', gap + 'px'); }
function mget_map(center = Geo.places.tuerkenschanzpark, zoom = 17) {
  M.center = center;
  M.zoom = zoom;
  let map = M.map = L.map('map').setView(center, zoom);
  return map;
}
function mGetStyle(elem, prop) {
  let val;
  elem = toElem(elem);
  if (prop == 'bg') { val = getStyleProp(elem, 'background-color'); if (isEmpty(val)) return getStyleProp(elem, 'background'); }
  else if (isdef(STYLE_PARAMS[prop])) { val = getStyleProp(elem, STYLE_PARAMS[prop]); }
  else {
    switch (prop) {
      case 'vmargin': val = stringBefore(elem.style.margin, ' '); break;
      case 'hmargin': val = stringAfter(elem.style.margin, ' '); break;
      case 'vpadding': val = stringBefore(elem.style.padding, ' '); break;
      case 'hpadding': val = stringAfter(elem.style.padding, ' '); break;
      case 'box': val = elem.style.boxSizing; break;
      case 'dir': val = elem.style.flexDirection; break;
    }
  }
  if (nundef(val)) val = getStyleProp(elem, prop);
  if (val.endsWith('px')) return firstNumber(val); else return val;
}
function mGetStyleX(elem, prop) {
  let val;
  if (isdef(STYLE_PARAMS[prop])) { val = elem.style[STYLE_PARAMS[prop]]; }
  else {
    switch (prop) {
      case 'vmargin': val = stringBefore(elem.style.margin, ' '); break;
      case 'hmargin': val = stringAfter(elem.style.margin, ' '); break;
      case 'vpadding': val = stringBefore(elem.style.padding, ' '); break;
      case 'hpadding': val = stringAfter(elem.style.padding, ' '); break;
      case 'box': val = elem.style.boxSizing; break;
      case 'dir': val = elem.style.flexDirection; break;
    }
  }
  if (nundef(val)) val = elem.style[prop];
  if (val.endsWith('px')) return firstNumber(val); else return val;
}
function mgPos(card, el, x = 0, y = 0, unit = '%', anchor = 'center') {
  mAppend(iG(card), el);
  let box = el.getBBox();
  console.log('rect', box);
  el.setAttribute('x', x);
  el.setAttribute('y', y);
}
function mGrid(rows, cols, dParent, styles = {}) {
  let d = mDiv(dParent, styles);
  d.style.gridTemplateColumns = 'repeat(' + cols + ',1fr)';
  d.style.gridTemplateRows = 'repeat(' + rows + ',1fr)';
  d.style.display = 'inline-grid';
  d.style.padding = valf(styles.padding, styles.gap) + 'px';
  return d;
}
function mGridFrom(d, m, cols, rows, cellstyles = {}) {
  let gta = '';
  let words = [];
  for (const line of m) {
    gta = gta + `'${line}' `;
    let warr = toWords(line);
    for (const w of warr) if (!words.includes(w)) words.push(w);
  }
  let dParent = mDom100(d, { display: 'grid', 'grid-template-areas': gta });
  dParent.style.gridTemplateColumns = cols;
  dParent.style.gridTemplateRows = rows;
  for (const w of words) {
    let st = copyKeys({ 'grid-area': w, bg: rColor(50) }, cellstyles);
    let cell = window[w] = mDom(dParent, st, { id: w });
  }
  return dParent;
}
function mgShape(key) {
}
function mgSize(el, h, w) {
  el.setAttribute('height', h);
  if (isdef(w)) el.setAttribute('width', w);
}
function mgSuit(key) {
  let el = gCreate('use');
  el.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#' + key);
  return el;
}
function mgSuit1(card, key, h, x, y) {
  el = document.createElementNS('http://www.w3.org/2000/svg', 'use');
  el.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', `#${key}`);
  el.setAttribute('height', h);
  el.setAttribute('width', h);
  el.setAttribute('x', x);
  el.setAttribute('y', y);
  mAppend(iG(card), el);
  return el;
}
function mgSvg(dParent, attrs) { return mgTag('svg', dParent, attrs); }
function mgSym(key) {
  let el = gCreate('text');
  let info = Syms[key];
  mStyle(el, { family: info.family });
  el.innerHTML = info.text;
  return el;
}
function mgTag(tag, dParent, attrs, styles = {}, innerHTML) {
  let elem = gCreate(tag);
  mStyle(elem, styles);
  mAttrs(elem, attrs);
  if (isdef(innerHTML)) elem.innerHTML = innerHTML;
  if (isdef(dParent)) mAppend(dParent, elem);
  return elem;
}
function mgText(text, dParent, attrs, styles) { return mgTag('text', dParent, attrs, styles, text); }
function mHand(n, R, uidParent) {
  let dParent = mBy(n.idUiParent);
  let ui = mDiv(dParent);
  addClass(ui, 'handStyle');
  return ui;
}
function mHasClass(el, className) {
  if (el.classList) return el.classList.contains(className);
  else return !!el.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)'));
}
function mHeading(msg, dParent, level, id) {
  let p = mCreate('h' + level);
  if (!isEmpty(msg)) p.innerHTML = msg;
  if (isdef(id)) p.id = id;
  mAppend(dParent, p);
  return p;
}
function mHex00(dParent, styles, id) {
  let ui = gShape('hex', 100, 100, 'blue', 4);
  let gParent = findAncestorElemWithParentOfType(dParent, 'svg');
  gParent.appendChild(ui);
  return ui;
}
function mHex01(dParent, styles = {}, sz = 100) {
  let szNet = (isdef(styles.padding)) ? sz - 2 * styles.padding : sz;
  let h = sz; w = h * 0.866;
  let d = mDiv(dParent, { w: w, h: h });
  let g = asvg(d);
  let hh = szNet + sz; wh = hh * 0.866;
  let colors = ['yellow', 'orange', 'red', 'green', 'violet']
  let hex1 = agShape(g, 'hex', wh, hh, chooseRandom(colors));
  if (isdef(styles)) mStyleX(d, styles)
  return d;
}
function mHex02(dParent, w) {
  let gap = 4;
  let whex = w - gap;
  let wcont = w;
  let hbrut = w / .866;
  let hhex = hbrut - gap;
  let hcont = hbrut * .75;
  let d = mDiv(dParent, { w: wcont, h: hcont, display: 'inline-block' });
  let g = asvg(d);
  let hex1 = agShape(g, 'hex', whex, hhex, randomColor());
  return d;
  function asvg(dParent, sz, originInCenter = true) {
    if (!dParent.style.position) dParent.style.position = 'relative';
    let svg1 = gSvg();
    svg1.setAttribute('width', '100%');
    svg1.setAttribute('height', '150%');
    let style = 'margin:0;padding:0;position:absolute;top:0px;left:0px;background:transparent';
    svg1.setAttribute('style', style);
    dParent.appendChild(svg1);
    let g1 = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    svg1.appendChild(g1);
    if (originInCenter) { g1.style.transform = "translate(50%, 50%)"; }
    return g1;
  }
}
function mHex03(dParent, w, bg) {
  let gap = 4;
  let whex = w - gap;
  let wcont = w;
  let hbrut = w / .866;
  let hhex = hbrut - gap;
  let hcont = hbrut * .75;
  let d = mDiv(dParent, { w: wcont, h: hcont, display: 'inline-block' });
  let g = asvg(d);
  let hex1 = agShape(g, 'hex', whex, hhex, bg);
  return d;
  function asvg(dParent, sz, originInCenter = true) {
    if (!dParent.style.position) dParent.style.position = 'relative';
    let svg1 = gSvg();
    svg1.setAttribute('width', '100%');
    svg1.setAttribute('height', '150%');
    let style = 'margin:0;padding:0;position:absolute;top:0px;left:0px;background:transparent';
    svg1.setAttribute('style', style);
    dParent.appendChild(svg1);
    let g1 = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    svg1.appendChild(g1);
    if (originInCenter) { g1.style.transform = "translate(50%, 50%)"; }
    return g1;
  }
}
function mHex04(dParent, w, bg) {
  let gap = 4;
  let whex = w - gap;
  let wcont = w;
  let hbrut = w / .866;
  let hhex = hbrut - gap;
  let hcont = hbrut * .75;
  let d = mDiv(dParent, { w: wcont, h: hcont, display: 'inline-block' });
  let g = asvg(d);
  let hex1 = agShape(g, 'hex', whex, hhex, bg);
  return d;
  function asvg(dParent, sz, originInCenter = true) {
    if (!dParent.style.position) dParent.style.position = 'relative';
    let svg1 = gSvg();
    svg1.setAttribute('width', '100%');
    svg1.setAttribute('height', '150%');
    let style = 'margin:0;padding:0;position:absolute;top:0px;left:0px;background:transparent';
    svg1.setAttribute('style', style);
    dParent.appendChild(svg1);
    let g1 = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    svg1.appendChild(g1);
    if (originInCenter) { g1.style.transform = "translate(50%, 50%)"; }
    return g1;
  }
}
function mHex05(dParent, w, bg) {
  let gap = 4;
  let whex = w - gap;
  let wcont = w;
  let hbrut = w / .866;
  let hhex = hbrut - gap;
  let hcont = hbrut * .75;
  let d = mDiv(dParent, { w: wcont, h: hcont, display: 'inline-block' });
  let d1 = mDiv100(d, { position: 'absolute', top: -15, 'z-index': -1 });
  let g = asvg(d1);
  let hex1 = agShape(g, 'hex', whex, hhex, bg);
  let dField = mDiv100(d, { padding: '0%', 'z-index': 100 });
  let dInnerField = mDiv(dField, { w: '99%', h: '113%', bg: 'blue', rounding: '50%' });
  return d;
  function asvg(dParent, sz, originInCenter = true) {
    if (!dParent.style.position) dParent.style.position = 'relative';
    let svg1 = gSvg();
    svg1.setAttribute('width', '100%');
    svg1.setAttribute('height', '150%');
    let style = 'margin:0;padding:0;position:absolute;top:0px;left:0px;background:transparent';
    svg1.setAttribute('style', style);
    dParent.appendChild(svg1);
    let g1 = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    svg1.appendChild(g1);
    if (originInCenter) { g1.style.transform = "translate(50%, 50%)"; }
    return g1;
  }
}
function mHexWeissNicht(dParent, styles = {}, sz = 100) {
  let szNet = (isdef(styles.padding)) ? sz - 2 * styles.padding : sz;
  let h = sz; w = h * 0.866;
  let d = mDiv(dParent, { w: 2 * w, h: h * 1.5 });
  let g = asvg(d);
  let hh = szNet + sz; wh = hh * 0.866;
  let colors = ['yellow', 'orange', 'red', 'green', 'violet']
  let hex1 = agShape(g, 'hex', wh, hh, chooseRandom(colors));
  if (isdef(styles)) mStyleX(d, styles)
  return d;
}
function mHide(d, ms = 0) { if (ms > 0) mFade(d, ms); else mStyle(d, { opacity: 0 }); }
function mHigh(ui) { mClass(ui, 'high'); }
function miAddLabel(item, styles) {
  let d = iDiv(item);
  if (getTypeOf(d.firstChild) == 'Text') {
    let handler = d.onmousedown;
    d.onmousedown = null;
    let dPic = d;
    let dParent = d.parentNode;
    let outerStyles = jsCopy(styles);
    addKeys({
      display: 'inline-flex', 'flex-direction': 'column',
      'justify-content': 'center', 'align-items': 'center', 'vertical-align': 'top',
    }, outerStyles);
    d = mDiv(dParent, outerStyles);
    mAppend(d, dPic);
    d.onmousedown = handler;
    let dLabel = mText(item.label, d, { fz: valf(styles.fz, 20) });
    iAdd(item, { div: d, dPic: dPic, dLabel: dLabel, options: outerStyles });
  } else if (nundef(iLabel(item))) {
    let dLabel = mText(item.label, d, { fz: valf(styles.fz, 20) });
    iAdd(item, { dLabel: dLabel });
  }
  return d;
}
function MicrophoneHide() {
  if (nundef(MicrophoneUi)) return;
  if (RecogOutput) console.log('* mic end')
  MicrophoneUi.style.opacity = .31;
}
function MicrophoneShow() {
  if (nundef(MicrophoneUi)) return;
  if (RecogOutput) console.log('* mic start')
  MicrophoneUi.style.opacity = 1;
}
function MicrophoneStart() {
  if (RecogOutput) console.log('* mic start')
  MicrophoneUi.style.opacity = 1;
}
function MicrophoneStop() {
  if (RecogOutput) console.log('* mic end')
  MicrophoneUi.style.opacity = .31;
}
function mIfNotRelative(d) { if (isEmpty(d.style.position)) d.style.position = 'relative'; }
function mImage() { return mImg(...arguments); }
function mImg(path, dParent, styles, classes, callback) {
  let d = mCreate('img');
  if (isdef(callback)) d.onload = callback;
  d.src = path;
  if (isdef(dParent)) mAppend(dParent, d);
  if (isdef(styles)) mStyle(d, styles);
  if (isdef(classes)) mClass(d, classes);
  if (isdef(styles.w)) d.setAttribute('width', styles.w + 'px');
  if (isdef(styles.h)) d.setAttribute('height', styles.h + 'px');
  return d;
}
function mInfo(n, R, uidParent) {
  let ui;
  let dParent = mBy(n.idUiParent);
  if (getTypeOf(dParent) == 'g') {
    return gInfo(n, R, uidParent);
  } else if (isdef(n.content)) {
    ui = mNode(n.content, dParent);
    mClass(ui, 'node');
  } else {
    ui = mDiv(dParent);
    ui.style.display = 'hidden';
  }
  return ui;
}
function minifyBack(id) {
  let card = UIS[id];
  let hand = UIS[card.hand];
  if (hand.scale != 1) {
    card.setScale(hand.scale);
  }
  _sendCardToBack(id)
}
function minimax(game, depth, alpha, beta, isMaximizingPlayer, sum, color) {
  if (G.id != 'gChess' || !aiActivated) return;
  positionCount++;
  var children = game.ugly_moves({ verbose: true });
  children.sort(function (a, b) { return 0.5 - Math.random() });
  var currMove;
  if (depth === 0 || children.length === 0) {
    return [null, sum]
  }
  var maxValue = Number.NEGATIVE_INFINITY;
  var minValue = Number.POSITIVE_INFINITY;
  var bestMove;
  for (var i = 0; i < children.length; i++) {
    currMove = children[i];
    var currPrettyMove = game.ugly_move(currMove);
    var newSum = evaluateBoard(currPrettyMove, sum, color);
    var [childBestMove, childValue] = minimax(game, depth - 1, alpha, beta, !isMaximizingPlayer, newSum, color);
    game.undo();
    if (isMaximizingPlayer) {
      if (childValue > maxValue) {
        maxValue = childValue;
        bestMove = currPrettyMove;
      }
      if (childValue > alpha) {
        alpha = childValue;
      }
    }
    else {
      if (childValue < minValue) {
        minValue = childValue;
        bestMove = currPrettyMove;
      }
      if (childValue < beta) {
        beta = childValue;
      }
    }
    if (alpha >= beta) {
      break;
    }
  }
  if (isMaximizingPlayer) {
    return [bestMove, maxValue]
  }
  else {
    return [bestMove, minValue];
  }
}
function minimaxCopy(node, depth, alpha, beta, maxDepth, maxim) {
  CCC += 1;
  if (depth >= maxDepth) return F_HEURISTIC(node, MAXIMIZER, MINIMIZER);
  let ec = F_END(node, depth); if (ec.reached) return ec.val;
  depth += 1;
  var move, result;
  var availableMoves = F_MOVES(node);
  let player = maxim ? MAXIMIZER : MINIMIZER;
  let nodeSafe = jsCopy(node);
  for (var i = 0; i < availableMoves.length; i++) {
    move = availableMoves[i];
    let node1 = jsCopy(node);
    console.assert(sameList(nodeSafe, node), 'HA!');
    F_APPLYMOVE(node1, move, player);
    result = minimaxCopy(node1, depth, alpha, beta, maxDepth, !maxim);
    if (maxim) {
      if (result > alpha) {
        alpha = result;
        if (depth == 1) SelectedMove = move;
      } else if (alpha >= beta) { return alpha; }
    } else {
      if (result < beta) {
        beta = result;
        if (depth == 1) SelectedMove = move;
      } else if (beta <= alpha) { return beta; }
    }
  }
  return maxim ? alpha : beta;
}
function minimizeObjects() { let ids = getDefaultObjectIds(); ids.map(x => UIS[x].minimize()); }
function mInner(html, dParent, styles) { dParent.innerHTML = html; if (isdef(styles)) mStyle(dParent, styles); }
function mInput(dParent, styles, id, placeholder, classtr = 'input', tabindex = null, value = '') {
  let html = `<input type="text" id=${id} class="${classtr}" placeholder="${valf(placeholder, '')}" tabindex="${tabindex}" value="${value}">`;
  let d = mAppend(dParent, mCreateFrom(html));
  if (isdef(styles)) mStyle(d, styles);
  return d;
}
function mInputGroup(dParent, styles) {
  let baseStyles = { display: 'inline-block', align: 'right', bg: '#00000080', rounding: 10, padding: 20, margin: 12 };
  if (isdef(styles)) styles = deepmergeOverride(baseStyles, styles); else styles = baseStyles;
  return mDiv(dParent, styles);
}
function mInputLineWithButtons(dParent, opts, val = '') {
  let html = `
    <form id="fSearch" action="javascript:void(0);" class='form' autocomplete='off'>
      <label>Keywords:</label>
      <input id="iKeywords" type="text" name="keywords" style="flex-grow:1" value="${val}" />
    </form>
    `;
  let elem = mCreateFrom(html);
  mAppend(dParent, elem);
  let handler;
  for (const cap in opts) {
    handler = opts[cap];
    mButton(cap, opts[cap], elem, {}, 'hop1');
  }
  elem.onsubmit = (ev) => { ev.preventDefault(); };
  return elem;
}
function mInputX(dParent, styles, { textPadding, label, value, submitOnEnter, autoComplete, autoFocus, autoSelect, handler, createContainer } = {}) {
  let d;
  if (createContainer) {
    d = mDiv(dParent, { align: 'center' });
    mAppend(dParent, d);
  } else if (isdef(label)) {
    d = createElementFromHTML(`<label>${isdef(label) ? label : ''}</label>`);
    mAppend(dParent, d);
  } else d = dParent;
  let inp = createElementFromHTML(`<input type="text" class="input" value="${isdef(value) ? value : ''}" />`);
  mAppend(d, inp);
  if (isdef(autoComplete)) inp.autoComplete = autoComplete ? 'on' : 'off';
  if (isdef(submitOnEnter))
    inp.onkeydown = (ev) => {
      if (ev.key === 'Enter') {
        ev.preventDefault();
        mBy('dummy').focus();
        if (isdef(handler)) handler(inp.value);
      }
    };
  if (isdef(styles)) { mStyleX(d, styles); }
  let inpStyles = isdef(styles) ? jsCopy(styles) : {};
  delete inpStyles.padding;
  if (isdef(textPadding)) inpStyles.padding = textPadding;
  if (isdef(inpStyles.w)) inpStyles.w = '100%';
  mStyleX(inp, inpStyles);
  if (isdef(autoFocus)) inp.focus();
  if (autoSelect == true) inp.select();
  return inp;
}
function mInsert(dParent, el, index = 0) { dParent.insertBefore(el, dParent.childNodes[index]); return el; }
function mInsertAfter(dParent, el, index = 0) {
  if (dParent.childNodes.length == index) mAppend(dParent, el);
  else mInsert(dParent, el, index + 1);
}
function mInsertAt(dParent, el, index = 0) { mInsert(dParent, el, index); }
function mInsertFirst(dParent, el) { mInsert(dParent, el, 0); }
function mInstruction(msg, dParent, hasExclamation = true) {
  let p = mCreate('h2');
  p.innerHTML = msg + (hasExclamation ? '!' : '');
  mAppend(dParent, p);
  return p;
}
function mInvisible(n, R, uidParent) {
  let dParent = mBy(n.idUiParent);
  let d = mDiv(dParent);
  if (n.content) {
    mText(n.content, d);
  }
  return d;
}
function miPic(item, dParent, styles, classes) {
  let info = isString(item) ? Syms[item] : isdef(item.info) ? item.info : item;
  let d = mDiv(dParent);
  d.innerHTML = info.text;
  if (nundef(styles)) styles = {};
  let family = info.family;
  addKeys({ family: family, fz: 50, display: 'inline-block' }, styles);
  mStyle(d, styles);
  if (isdef(classes)) mClass(d, classes);
  mCenterCenterFlex(d);
  return d;
}
function MIRROR120(sq) {
  var file = MirrorFiles[FilesBrd[sq]];
  var rank = MirrorRanks[RanksBrd[sq]];
  return FR2SQ(file, rank);
}
function MIRROR64(sq) { return Mirror64[sq]; }
function mist() {
  var map = L.map('map', {
    minZoom: 0,
    maxZoom: 20
  });
  var cartodbAttribution = '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/attribution">CARTO</a>';
  //maps: http://bl.ocks.org/Xatpy/raw/854297419bd7eb3421d0/
  // var layer = L.tileLayer('https://cartocdn_{s}.global.ssl.fastly.net/base-antique/{z}/{x}/{y}.png', { attribution: cartodbAttribution }).addTo(map);
  // var layer = L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', { attribution: cartodbAttribution }).addTo(map);
  var layer = L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', { attribution: cartodbAttribution }).addTo(map);
  //var layer = L.tileLayer('http://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}.png', { attribution: cartodbAttribution }).addTo(map);
  //var layer = L.tileLayer('http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', { attribution: cartodbAttribution }).addTo(map);
  //var layer = L.tileLayer('https://cartocdn_{s}.global.ssl.fastly.net/base-eco/{z}/{x}/{y}.png', { attribution: cartodbAttribution }).addTo(map);
  //var layer = L.tileLayer('https://cartocdn_{s}.global.ssl.fastly.net/base-midnight/{z}/{x}/{y}.png', { attribution: cartodbAttribution }).addTo(map);
  map.setView([0, 0], 0);
  return;
  setView(center, zoom);
  flyTo(center, zoom);
  zoomIn() / zoomIn(delta);
  zoomOut() / zoomOut(delta);
  setZoomAround(fixedPoint, zoom);
  fitBounds(bounds);
}
function mItem(id, diDOM, di = {}, addSizing = false) {
  let item = di;
  id = isdef(id) ? id : isdef(diDOM) && isdef(diDOM.div) && !isEmpty(diDOM.div.id) ? diDOM.div.id : getUID();
  item.id = iRegister(item, id);
  if (isdef(diDOM) && isdef(diDOM.div)) { diDOM.div.id = id; iAdd(item, diDOM); }
  if (addSizing) {
    if (nundef(item.sizing)) item.sizing = 'sizeToContent';
    if (nundef(item.positioning)) { item.positioning = 'absolute'; }
    if (nundef(item.posType)) { item.posType = 'center'; }
    if (isdef(diDOM) && item.sizing == 'sizeToContent') iMeasure(item, item.sizingOptions);
  }
  return item;
}
function mItemSplay(item, list, splay, ov = .5) {
  if (!isNumber(splay)) splay = get_splay_number(splay);
  let d = iDiv(item);
  let idx = list.indexOf(item.key);
  if (splay == 4) {
    let offset = (list.length - idx) * ov;
    mStyle(d, { position: 'absolute', left: offset, top: offset });
    d.style.zIndex = list.length - idx;
  } else {
    d.style.zIndex = splay != 2 ? list.length - idx : 0;
  }
}
function mixinChannel(n, rParent, R) {
  let chanav = buildChanav(n, rParent);
  chanavList = isList(chanav) ? chanav : isString(chanav) ? [chanav] : [];
  let chanimpl = n.channels;
  chanimpl = isDict(chanimpl) ? Object.keys(chanimpl) : isList(chanimpl) ? chanimpl : isString(chanimpl) ? [chanimpl] : [];
  let activeChannelKey = null; let activeChannel = null;
  for (const ch of chanimpl) {
    let k = Object.keys(ch)[0];
    let val = ch[k];
    if (chanavList.includes(k)) { activeChannelKey = k; activeChannel = val; }
  }
  if (activeChannel) {
    n = deepmerge(n, activeChannel);
  }
  return [n, chanav];
}
function mLabel(label) { return mText(label); }
function mle(o, p, d) {
  p = { x: p.x - d, y: p.y };
  if (o) o.setPos(p.x, p.y);
  return p;
}
function mLeft(dParent, d, margin = 0) {
  mStyle(dParent, { display: 'flex', 'justify-content': 'space-between', 'align-items': 'center' });
  mInsertFirst(dParent, d);
  mStyle(d, { margin: margin, 'align-self': 'flex-start' });
  return d;
}
function mLine(dParent, styles) { return mDiv(dParent, styles, null, '<hr>'); }
function mLine3(dParent, index, ids, styles) {
  let html = `<div class="lineOuter">
    <div>
      <div id="${ids[0]}" class="lineLeft"> </div>
      <div id="${ids[1]}" class="lineMiddle"> </div>
      <div id="${ids[2]}" class="lineRight"> </div>
    </div>
  </div>
  `;
  let x = createElementFromHTML(html);
  mInsert(dParent, x, index);
  return [mBy(ids[0]), mBy(ids[1]), mBy(ids[2])];
}
function mLinebreak(dParent, gap) {
  dParent = toElem(dParent);
  let d;
  let display = getComputedStyle(dParent).display;
  if (display == 'flex') {
    d = mDiv(dParent, { fz: 2, 'flex-basis': '100%', h: 0, w: '100%' }, null, ' &nbsp; ');
  } else {
    d = mDiv(dParent, {}, null, '<br>');
  }
  if (isdef(gap)) { d.style.minHeight = gap + 'px'; d.innerHTML = ' &nbsp; '; d.style.opacity = .2; }
  return d;
}
function mLinebreakFlex(dParent, gap) {
  dParent = toElem(dParent);
  let d = mDiv(dParent, { fz: 2, 'flex-basis': '100%', h: 0, w: '100%' }, null, ' &nbsp; ');
  if (isdef(gap)) { d.style.minHeight = gap + 'px'; d.innerHTML = ' &nbsp; '; d.style.opacity = .2; }
  return d;
}
function mLinebreakNew(d, gap) { mGap(d, gap); }
function mLink(href, dParent, styles, id, inner, classes, sizing) {
  let d = mCreate('a');
  if (dParent) mAppend(dParent, d);
  d.href = valf(href, '#');
  if (isdef(styles)) mStyle(d, styles);
  if (isdef(classes)) mClass(d, classes);
  if (isdef(id)) d.id = id;
  if (isdef(inner)) d.innerHTML = inner;
  if (isdef(sizing)) { setRect(d, sizing); }
  return d;
}
function mList(n, R, uidParent) {
  let dParent = mBy(n.idUiParent);
  let ui = mDiv(dParent);
  return ui;
}
function mMagnify(img, item) {
  let path = item.path;
  if (isdef(MAGNIFIER_IMAGE) && MAGNIFIER_IMAGE.src == path) {
    console.log('schon offen!!!')
    return;
  } else if (isdef(MAGNIFIER_IMAGE)) mCancelMagnify();
  let imgSize = 514, fontSize = 24;
  let [w, h, fz] = [imgSize, imgSize + fontSize + 10, fontSize];
  let dPresent = MAGNIFIER_IMAGE = mDiv(document.body, { bg: HeaderColor, position: 'absolute', left: 0, top: 0, w: w, h: h });
  let d = dPresent;
  d.style.zIndex = 100000;
  let dText = mText(item.text, d, { color: 'white', fz: fz });
  let dImage = mDiv(d, { rounding: '50%', w: w, h: w });
  mCenterCenterFlex(dImage);
  let img1 = mImg(path, dImage, {});
  mCenterCenterFlex(dPresent);
}
function mMagnifyOnHoverControl(elem) {
  elem.onmouseenter = ev => { if (ev.ctrlKey) mClass(elem, 'magnify_on_hover'); }
  elem.onmouseleave = ev => mClassRemove(elem, 'magnify_on_hover');
}
function mMagnifyOnHoverControlPopup(elem) {
  elem.onmouseenter = ev => {
    if (ev.ctrlKey) {
      let r = getRect(elem, document.body);
      let popup = mDiv(document.body, { rounding: 4, position: 'absolute', top: r.y, left: r.x }, 'popup');
      let clone = elem.cloneNode(true);
      popup.appendChild(clone);
      mClass(popup, 'doublesize')
      popup.onmouseleave = () => popup.remove();
    }
  }
}
function mMagnifyOnHoverControlRemove(elem) {
  elem.onmouseenter = elem.onmouseleave = null;
  mClassRemove(elem, 'magnify_on_hover');
}
function mManual00(n, R, area) {
  let ui = mDefault(n, R, area);
  if (isdef(n.idUiParent)) {
    let dParent = mBy(n.idUiParent);
    if (dParent && nundef(dParent.style.position)) dParent.style.position = 'relative';
  }
  return ui;
}
function mMarginAuto(d) { d.style.setProperty('margin', 'auto'); }
function mMeasure(d) { let r = getRect(d); mStyle(d, { w: r.w, h: r.h }); return r; }
function mMenuButton(dParent, caption, styles) {
  caption = valf(caption, UnicodeSymbols.menu);
  styles = valf(styles, { fz: 30, margin: 4 });
  let b = mButton(caption, null, dParent, styles, 'mybutton', getUID('b'));
  return b;
}
function mMenuLine(dParent, styles) {
  let menuStyles = isdef(styles) ? styles : { bg: wblack, alpha: .65 };
  let dMenu = mDiv(dParent, menuStyles);
  return dMenu;
}
function mMicrophone(dParent, color) {
  let d = mDiv(dParent);
  d.innerHTML = '🎤';
  let c = bestContrastingColor(color, ['yellow', 'orange', 'red']);
  let bg = c;
  let style = { bg: bg, rounding: '50%', fz: 50, padding: 5, transition: 'opacity .35s ease-in-out' };
  mStyle(d, style);
  mLinebreak(dParent);
  return d;
}
function mMinBounds(d) {
  let b = getBounds(d);
  mStyle(d, { 'min-width': b.width, 'min-height': b.height }, 'px');
}
function mMinSize(d, w, h, unit = 'px') { mStyle(d, { 'min-width': w, 'min-height': h }, unit); }
function mMoveBy(elem, dx, dy) { let rect = getRect(elem); mPos(elem, rect.x + dx, rect.y + dy); }
function mMultiline(s, tabvalue, dParent, styles, classes) {
  let spc = '&nbsp;';
  let lines = s.split('\n');
  let html = '';
  for (let i = 0; i < lines.length; i += 1) {
    let line = lines[i];
    let n = countIndent(line, tabvalue);
    let x = spc.repeat(n) + line;
    html += x + '<br>';
  }
  let d1 = mText(html, dParent);
  if (isdef(styles)) mStyle(d1, styles);
  if (isdef(classes)) mClass(d1, ...classes);
  return d1;
}
function mNode(o, dParent, title) {
  recConvertLists(o);
  console.log('mNode o', o);
  let d = mCreate('div');
  mYaml(d, o);
  let pre = d.getElementsByTagName('pre')[0];
  pre.style.fontFamily = 'inherit';
  if (isdef(title)) mInsert(d, mText(title));
  if (isdef(dParent)) mAppend(dParent, d);
  if (isDict(o)) d.style.textAlign = 'left';
  return d;
}
function mNodeChangeContent(ui, content) {
  let domel = ui.getElementsByTagName('pre')[0];
  domel.innerHTML = jsonToYaml(content);
}
function mNodeFilter(o, { sort, dParent, title, lstFlatten, lstOmit, lstShow, className = 'node', omitEmpty = false } = {}) {
  let oCopy = isList(lstShow) ? filterByKey(o, lstShow) : jsCopySafe(o);
  if (isList(lstFlatten)) recConvertToSimpleList(oCopy, lstFlatten);
  if (nundef(lstOmit)) lstOmit = [];
  if (omitEmpty || !isEmpty(lstOmit)) oCopy = recDeleteKeys(oCopy, omitEmpty, lstOmit);
  let d = mCreate('div');
  if (isdef(className)) mClass(d, className);
  switch (sort) {
    case 'keys': oCopy = sortKeys(oCopy); break;
    case 'all': oCopy = JSON.sort(oCopy); break;
  }
  mYaml(d, oCopy);
  let pre = d.getElementsByTagName('pre')[0];
  pre.style.fontFamily = 'inherit';
  if (isdef(title)) mInsert(d, mText(title));
  if (isdef(dParent)) mAppend(dParent, d);
  return d;
}
function mNull(d, attr) { d.removeAttribute(attr); }
function modal_off() { let d = mBy('dModal'); d.innerHTML = ''; d.style.display = 'none'; }
function modal_on() { let d = mBy('dModal'); return d; }
function modify_def_players(list) {
  console.log('list', list);
  return;
  let uname = Session.cur_user;
  Session.def_players = list;
  newlist = get_def_players_for_user(uname);
  populate_players(newlist);
}
function modify_item_for_adaptive(item, items, n) {
  item.numSyms = n;
  [item.rows, item.cols, item.colarr] = calc_syms(item.numSyms);
  let other_items = items.filter(x => x != item);
  let shared_syms = find_shared_keys(item.keys, other_items.map(x => x.keys));
  let other_symbols = item.keys.filter(x => !shared_syms.includes(x));
  item.keys = shared_syms;
  let num_missing = item.numSyms - item.keys.length;
  item.keys = item.keys.concat(rChoose(other_symbols, num_missing));
  shuffle(item.keys);
  item.scales = item.keys.map(x => rChoose([1, .75, 1.2, .9, .8]));
}
function modify_table() {
  let uname = Session.cur_user;
  let table = Session.cur_table;
  if (nundef(table)) { alert('no table available!'); return; }
  let game = Session.cur_game = table.game;
  let tid = Session.cur_tid = table.id;
  let t = {};
  t.id = Session.cur_tid;
  t.players = valf(lookup(Session, ['game_options', 'players']), table.players);
  t.options = valf(lookup(Session, ['game_options', 'game']), table.options);
  t.pl_options = get_player_options(t.players, game);
  console.log('settings to table:\nnew players', t.players, '\nnew options', t.options);
  t.player_init = {};
  return t;
}
function modifyColor() {
  const colors = [YELLOW, 'skyblue', "green", "purple", "yellow"];
  document.body.style.setProperty('--corner-color', colors[Math.floor(Math.random() * colors.length)]);
  document.body.style.setProperty('--color1', colors[Math.floor(Math.random() * colors.length)]);
  document.body.style.setProperty('--color2', colors[Math.floor(Math.random() * colors.length)]);
}
function modifyColorkey(item) {
  let colorkey = chooseRandom(Object.keys(ColorDict));
  let textShadowColor = ColorDict[colorkey].c;
  item.textShadowColor = textShadowColor;
  item.color = ColorDict[colorkey];
  item.colorKey = colorkey;
  applyColorkey(item);
}
function modifyServerData() {
  let pl = serverData.players[GAMEPLID];
  let o = GAME == 'catan' ? pl.devcards : pl.hand;
  if (!o) {
    for (const plid in serverData.players) {
      serverData.players[plid].hand = { _set: [] };
    }
    o = pl.hand;
  }
  let cards = getElements(o);
  if (cards.length > 5) resetPlayerCards(); else addCardsToPlayers();
  let opt = serverData.options;
  if (opt) {
    let keys = Object.keys(opt);
    let firstKey = keys[0];
    let actions = opt[firstKey].actions._set[0]._tuple[0]._set;
    if (actions.length > 50) removedActions = actions.splice(0, 8);
    else if (actions.length > 33) removedActions = removedActions.concat(actions.splice(0, 30));
    else removedActions.map(x => actions.push(x));
  }
}
function modifyServerDataRandom(username) {
  _syncUsernameOfSender(username);
  prevServerData = jsCopy(serverData);
  let ranks = ['2', '3', '4', 'Q', 'J', 'T', 'A', '9'];
  let dModify = serverData.table ? serverData.table : serverData;
  let keys = Object.keys(dModify);
  let nChange = randomNumber(1, keys.length);
  shuffle(keys);
  console.log('>>>change', nChange, 'items!')
  for (let i = 0; i < nChange; i++) {
    let id = keys[i];
    let val = dModify[id];
    if (isLiteral(val)) dModify[id] = { id: id, value: val };
    dModify[id].rank = chooseRandom(ranks);
  }
}
function modLabel(item, newLabel, styles) {
  let dLabel = iLabel(item);
  dLabel.innerHTML = newLabel;
  mStyleX(dLabel, styles);
  item.label = newLabel;
  return dLabel;
}
function more() {
  let sz = measureText(text, styles, cx);
  console.log('sz', sz)
  let [v, h] = [pos[0], pos[1]];
  let offy = v == 't' ? -sz.h : 'c' ? -sz.h / 2 : 0;
  let offx = h == 'l' ? -sz.w : 'c' ? -sz.w / 2 : 0;
  let [x, y] = [styles.x + offx, styles.y + offy];
  console.log('pos', pos, styles.x, styles.y, x, y)
  cx.fillText(text, x, y);
  return;
  if (pos[1] == 'c') cx.textAlign = 'center';
  cx.font = `16px Arial`;
  cx.fillStyle = color;
  cx.fillText(`${label}`, x, y + (pos[0] == 'b' ? 20 : -10));
}
function MOVE(from, to, captured, promoted, flag) { return (from | (to << 7) | (captured << 14) | (promoted << 20) | flag); }
function move_down(canvas, item) { item.y += 1; canvas.clamp(item); return true; }
function move_probs(canvas, item) {
  let pinc = get_with_prob(item.probs);
  item.x += pinc.x; item.y += pinc.y;
  canvas.clamp(item);
  return true;
}
function move_random(canvas, item) { item.x += rFloat(-1, 1); item.y += rFloat(-1, 1); canvas.clamp(item); return true; }
function move_todo_to_history(otree) {
  otree.history = otree.history.concat(otree.todo);
}
function Move2FromTo(move) {
  var ff = FilesBrd[FROMSQ(move)];
  var rf = RanksBrd[FROMSQ(move)];
  var ft = FilesBrd[TOSQ(move)];
  var rt = RanksBrd[TOSQ(move)];
  return { from: { sq: FROMSQ(move), file: ff, rank: rf }, to: { sq: TOSQ(move), file: ft, rank: rt } };
}
function moveAvatar(username, x, y) { mStyleX(getAvatar(username), { left: x, top: y }); }
function moveCardsFromTo(cards, from, to) {
}
function MoveExists(move) {
  GenerateMoves();
  var index;
  var moveFound = NOMOVE;
  for (index = brd_moveListStart[brd_ply]; index < brd_moveListStart[brd_ply + 1]; ++index) {
    moveFound = brd_moveList[index];
    if (MakeMove(moveFound) == BOOL.FALSE) {
      continue;
    }
    TakeMove();
    if (move == moveFound) {
      return BOOL.TRUE;
    }
  }
  return BOOL.FALSE;
}
function moveFromTo_v0(item, d1, d2) {
  let bi = iTableBounds(item);
  let b1 = iTableBounds(d1);
  let b2 = iTableBounds(d2);
  console.log('item', bi);
  console.log('d1', b1);
  console.log('d2', b2);
  mStyleX(dTable, { bg: 'yellow' });
  let dist = { x: b2.x - b1.x, y: b2.y - b1.y };
  item.div.style.zIndex = 100;
  let a = aTranslateBy(item.div, dist.x, dist.y, 500);
  a.onfinish = () => { mAppend(d2, item.div); item.div.style.zIndex = item.z = iZMax(); };
  return;
  setTimeout(() => {
    console.log(item.div);
    let d = item.div;
    mRemove(d);
  }, 1500);
  setTimeout(() => {
    let item = iAppend52(28, d2);
    mCenterAbs(item.div);
  }, 1500);
}
function MoveGUIPiece(move) {
  var from = FROMSQ(move);
  var to = TOSQ(move);
  var flippedFrom = from;
  var flippedTo = to;
  var epWhite = -10;
  var epBlack = 10;
  if (GameController.BoardFlipped == BOOL.TRUE) {
    flippedFrom = MIRROR120(from);
    flippedTo = MIRROR120(to);
    epWhite = 10;
    epBlack = -10;
  }
  if (move & MFLAGEP) {
    var epRemove;
    if (brd_side == COLOURS.BLACK) {
      epRemove = flippedTo + epWhite;
    } else {
      epRemove = flippedTo + epBlack;
    }
    console.log("en pas removing from " + PrSq(epRemove));
    RemoveGUIPiece(epRemove);
  } else if (CAPTURED(move)) {
    RemoveGUIPiece(flippedTo);
  }
  var rank = RanksBrd[flippedTo];
  var file = FilesBrd[flippedTo];
  var rankName = "rank" + (rank + 1);
  var fileName = "file" + (file + 1);
  $(".Piece").each(function (index) {
    if ((RanksBrd[flippedFrom] == 7 - Math.round($(this).position().top / 60)) && (FilesBrd[flippedFrom] == Math.round($(this).position().left / 60))) {
      $(this).removeClass();
      $(this).addClass("Piece clickElement " + rankName + " " + fileName);
    }
  });
  if (move & MFLAGCA) {
    if (GameController.BoardFlipped == BOOL.TRUE) {
      switch (to) {
        case SQUARES.G1: RemoveGUIPiece(MIRROR120(SQUARES.H1)); AddGUIPiece(MIRROR120(SQUARES.F1), PIECES.wR); break;
        case SQUARES.C1: RemoveGUIPiece(MIRROR120(SQUARES.A1)); AddGUIPiece(MIRROR120(SQUARES.D1), PIECES.wR); break;
        case SQUARES.G8: RemoveGUIPiece(MIRROR120(SQUARES.H8)); AddGUIPiece(MIRROR120(SQUARES.F8), PIECES.bR); break;
        case SQUARES.C8: RemoveGUIPiece(MIRROR120(SQUARES.A8)); AddGUIPiece(MIRROR120(SQUARES.D8), PIECES.bR); break;
      }
    } else {
      switch (to) {
        case SQUARES.G1: RemoveGUIPiece(SQUARES.H1); AddGUIPiece(SQUARES.F1, PIECES.wR); break;
        case SQUARES.C1: RemoveGUIPiece(SQUARES.A1); AddGUIPiece(SQUARES.D1, PIECES.wR); break;
        case SQUARES.G8: RemoveGUIPiece(SQUARES.H8); AddGUIPiece(SQUARES.F8, PIECES.bR); break;
        case SQUARES.C8: RemoveGUIPiece(SQUARES.A8); AddGUIPiece(SQUARES.D8, PIECES.bR); break;
      }
    }
  }
  var prom = PROMOTED(move);
  console.log("PromPce:" + prom);
  if (prom != PIECES.EMPTY) {
    console.log("prom removing from " + PrSq(flippedTo));
    RemoveGUIPiece(flippedTo);
    AddGUIPiece(flippedTo, prom);
  }
  printGameLine();
}
function moveMinuteHands(containers) {
  for (var i = 0; i < containers.length; i++) {
    containers[i].style.webkitTransform = 'rotateZ(6deg)';
    containers[i].style.transform = 'rotateZ(6deg)';
  }
  setInterval(function () {
    for (var i = 0; i < containers.length; i++) {
      if (containers[i].angle === undefined) {
        containers[i].angle = 12;
      } else {
        containers[i].angle += 6;
      }
      containers[i].style.webkitTransform = 'rotateZ(' + containers[i].angle + 'deg)';
      containers[i].style.transform = 'rotateZ(' + containers[i].angle + 'deg)';
    }
  }, 60000);
}
function MovePiece(from, to) {
  var index = 0;
  var pce = brd_pieces[from];
  var col = PieceCol[pce];
  HASH_PCE(pce, from);
  brd_pieces[from] = PIECES.EMPTY;
  HASH_PCE(pce, to);
  brd_pieces[to] = pce;
  for (index = 0; index < brd_pceNum[pce]; ++index) {
    if (brd_pList[PCEINDEX(pce, index)] == from) {
      brd_pList[PCEINDEX(pce, index)] = to;
      break;
    }
  }
}
function moveSecondHands() {
  var containers = document.querySelectorAll('.seconds-container');
  setInterval(function () {
    for (var i = 0; i < containers.length; i++) {
      if (containers[i].angle === undefined) {
        containers[i].angle = 6;
      } else {
        containers[i].angle += 6;
      }
      containers[i].style.webkitTransform = 'rotateZ(' + containers[i].angle + 'deg)';
      containers[i].style.transform = 'rotateZ(' + containers[i].angle + 'deg)';
    }
  }, 1000);
}
function moveTo(card, dx, dy) { card.animateTo({ delay: 1000, duration: 500, ease: 'quartOut', x: dx, y: dy }) }
function mp_over(d, dParent, fz, color, picStyle) {
  let b = getRect(dParent);
  let cx = b.w / 2 + b.x;
  let cy = b.h / 2 + b.y;
  d.style.top = picStyle == 'segoeBlack' ? ((cy - fz * 2 / 3) + 'px') : ((cy - fz / 2) + 'px');
  d.style.left = picStyle == 'segoeBlack' ? ((cx - fz / 3) + 'px') : ((cx - fz * 1.2 / 2) + 'px');
  d.style.color = color;
  d.style.fontSize = fz + 'px';
  d.style.display = 'block';
  return d;
}
function mPane(dParent, pos, styles, id) {
  console.log(pos, pos[0])
  let d = mDiv(dParent, styles, id);
  if (nundef(pos)) pos = 't'; else pos = pos[0].toLowerCase();
  let posStyle = { display: 'flex' };
  switch (pos) {
    case 't': addKeys({ w: '100%' }, posStyle); break;
    case 'l': addKeys({ h: '100%', 'flex-direction': 'column' }, posStyle); break;
    case 'b': addKeys({ w: '100%', position: 'absolute', bottom: 0 }, posStyle); break;
    case 'r': addKeys({ h: '100%', 'flex-direction': 'column', position: 'absolute', right: 0 }, posStyle); break;
  }
  mStyleX(d, posStyle);
  return d;
}
function mPanel(dParent) {
  let d = mDiv(dParent, { position: 'relative' });
  mCenterCenterFlex(d);
  return d;
}
function mPara(text, dParent, styles, classes) {
  let d = mCreate('p');
  mAppend(dParent, d);
  if (!isEmpty(text)) d.innerHTML = text;
  if (isdef(styles)) mStyleX(d, styles);
  if (isdef(classes)) mClass(d, classes);
  return d;
}
function mParent(elem) { return elem.parentNode; }
function mPath(p) {
  if (!(p.path.includes('.'))) p.path += '.png';
  return PERLENPATH_FRONT + 'perlen/' + p.path;
}
function mpBadge(info, label, { w, h, bg, fgPic, fgText }, handler, dParent, styles, classes = 'picButton', isText, isOmoji) {
  if (nundef(handler)) handler = (ev) => { let id = evToClosestId(ev); let info = symbolDict[id.substring(1)]; if (isLabelVisible(id)) maHideLabel(id, info); else maShowLabel(id, info); mBy('dummy').focus(); }
  let picLabelStyles = getBadgeStyles(styles, {}, {}, w, h, 60, 2, 4, 'arial', bg, 'transparent', fgPic, fgText, true);
  let x = maPicLabelFitX(info, label.toUpperCase(), { wmax: w }, dParent, picLabelStyles[0], picLabelStyles[1], picLabelStyles[2], true, false);
  x.id = 'd' + info.key;
  x.lastChild.style.cursor = 'default';
  x.style.userSelect = 'none';
  return x;
}
function mpButton(info, label, { w, h, bg, fgPic, fgText }, handler, dParent, styles, classes = 'picButton', isText, isOmoji) {
  if (nundef(handler)) handler = labelToggler;
  let picLabelStyles = getHarmoniousStylesPlusPlus(styles, {}, {}, w, h, 65, 0, 'arial', bg, 'transparent', fgPic, fgText, true);
  let x = maPicLabelFitX(info, label.toUpperCase(), { wmax: w }, dParent, picLabelStyles[0], picLabelStyles[1], picLabelStyles[2], true, false);
  x.id = 'd' + info.key;
  x.onclick = handler;
  x.style.cursor = 'pointer';
  x.lastChild.style.cursor = 'pointer';
  x.style.userSelect = 'none';
  mClass(x, classes);
  return x;
}
function mpGridLabeled(dParent, list, picLabelStyles) {
  let dGrid = mDiv(dParent);
  let elems = [];
  let isText = true;
  let isOmoji = false;
  for (const k of list) {
    let info = symbolDict[k];
    let el = maPicLabel(info, dGrid, picLabelStyles[0], picLabelStyles[1], picLabelStyles[2], isText, isOmoji)
    elems.push(el);
  }
  let gridStyles = { 'place-content': 'center', gap: 4, margin: 4, padding: 4, rounding: 5 };
  let size = layoutGrid(elems, dGrid, gridStyles, { rows: 10, isInline: true });
}
function mPic(kItem, dParent, styles, classes) {
  let item;
  if (isString(kItem)) { item = { id: getUID(), key: kItem, info: Syms[kItem] }; }
  else if (nundef(kItem.info)) { item = { id: getUID(), key: kItem.key, info: kItem }; }
  else item = kItem;
  let info = item.info;
  let dOuter = mDiv(dParent);
  mCenterCenterFlex(dOuter);
  let d = mDiv(dOuter);
  d.innerHTML = info.text;
  if (nundef(styles)) styles = {};
  let picStyles = { family: info.family, fz: valf(styles.fz, valf(styles.h / 2, 25)), display: 'inline-block' };
  mStyle(dOuter, styles);
  mStyle(d, picStyles);
  if (isdef(classes)) mClass(dOuter, classes);
  iAdd(item, { div: dOuter, dPic: d });
  return item;
}
function mPicButton(key, handler, dParent, styles, classes) {
  let x = createPicto({
    key: key, w: 20, h: 20, unit: 'px', fg: 'yellow', bg: 'violet',
    padding: 2, margin: 0, cat: 'd', parent: dParent, rounding: 4
  });
  if (isdef(handler)) x.onclick = handler;
  if (isdef(styles)) {
    mStyle(x, styles);
  }
  if (isdef(classes)) { mClass(x, ...classes); }
  else mClass(x, 'picButton');
  return x;
}
function mPicButtonSimple(key, handler, dParent, styles, classes) {
  let x = createPictoSimple({ key: key, cat: 'd', parent: dParent });
  if (isdef(handler)) x.onclick = handler;
  if (isdef(styles)) { mStyle(x, styles); }
  if (isdef(classes)) { mClass(x, ...classes); }
  return x;
}
function mPicSimple(info, dParent, { w, h, unit = 'px', fg, bg, padding, border, rounding, shape }) {
  if (nundef(w)) w = 25;
  if (nundef(h)) h = w;
  let d = document.createElement('div');
  if (dParent) dParent.appendChild(d);
  d.style.textAlign = 'center';
  d.style.fontFamily = info.family;
  d.style.fontWeight = 900;
  d.style.fontSize = h + unit;
  [bg, fg] = getExtendedColors(bg, fg);
  if (isdef(bg)) d.style.backgroundColor = bg;
  if (isdef(fg)) d.style.color = fg;
  d.innerHTML = info.text;
  if (isdef(padding)) d.style.padding = padding + unit;
  d.style.display = 'inline-block';
  d.style.minHeight = h + padding + unit;
  d.style.minWidth = w + 2 * padding + unit;
  if (isdef(border)) d.style.border = border;
  if (isdef(rounding)) d.style.borderRadius = rounding + unit;
  else if (isdef(shape) && shape == 'ellipse') {
    let b = getBounds(d);
    let vertRadius = b.height / 2;
    let horRadius = b.width / 2;
    let r = Math.min(vertRadius, horRadius);
    console.log(b, r)
    d.style.borderRadius = `${r}${unit}`;
  }
  d.key = info.key;
  return d;
}
function mPicto(n, R, uidParent) {
  let dParent = mBy(n.idUiParent);
  let ui;
  let w = (isdef(n.params.size.w) ? n.params.size.w : 50);
  let h = (isdef(n.params.size.h) ? n.params.size.h : 50);
  let fz = (isdef(n.params.fontSize) ? n.params.fontSize : 20);
  let bg = isdef(n.params.bg) ? n.params.bg : randomColor();
  let fg = isdef(n.params.fg) ? n.params.fg : colorIdealText(bg);
  let key = n.content;
  ui = pictoDiv(key, bg, w, h)
  mAppend(dParent, ui);
  return ui;
}
function mPictoWrapper(n, R, uidParent) {
  let dParent = mBy(n.idUiParent);
  let uiWrapper = mDiv(dParent);
  addClass(uiWrapper, 'cardWrapper');
  let key = n.content;
  let ui = maPicSimple(key);
  mAppend(uiWrapper, ui);
  addClass(ui, 'pictoStyle');
  return ui;
}
function mPlace(elem, pos, offx, offy) {
  elem = toElem(elem);
  pos = pos.toLowerCase();
  let dParent = elem.parentNode; if (dParent.style.position != 'absolute') dParent.style.position = 'relative';
  let vert = valf(offx, 0);
  let hor = isdef(offy) ? offy : vert;
  if (pos[0] == 'c' || pos[1] == 'c') {
    let rParent = getRect(dParent);
    let [wParent, hParent] = [rParent.w, rParent.h];
    let rElem = getRect(elem);
    let [wElem, hElem] = [rElem.w, rElem.h];
    switch (pos) {
      case 'cc': mStyle(elem, { position: 'absolute', left: hor + (wParent - wElem) / 2, top: vert + (hParent - hElem) / 2 }); break;
      case 'tc': mStyle(elem, { position: 'absolute', left: hor + (wParent - wElem) / 2, top: vert }); break;
      case 'bc': mStyle(elem, { position: 'absolute', left: hor + (wParent - wElem) / 2, bottom: vert }); break;
      case 'cl': mStyle(elem, { position: 'absolute', left: hor, top: vert + (hParent - hElem) / 2 }); break;
      case 'cr': mStyle(elem, { position: 'absolute', right: hor, top: vert + (hParent - hElem) / 2 }); break;
    }
    return;
  }
  let di = { t: 'top', b: 'bottom', r: 'right', l: 'left' };
  elem.style.position = 'absolute';
  elem.style[di[pos[0]]] = hor + 'px'; elem.style[di[pos[1]]] = vert + 'px';
}
function mPlaceText(text, where, dParent, styles, innerStyles, classes) {
  let box;
  if (where.length == 4) {
    let [t, r, b, l] = where;
    box = mBoxFromMargins(dParent, t, r, b, l);
  } else if (where.length == 3) {
    let [wb, hb, place] = where;
    box = mDiv(dParent, { w: wb, h: hb });
    mPlace(box, place);
  }
  let r = mMeasure(box);
  let [fz, w, h] = fitFont(text, 20, r.w, r.h);
  console.log('res', fz, w, h);
  let dText = mDiv(box, {
    w: w, h: h, fz: fz,
    position: 'absolute', transform: 'translate(-50%,-50%)', top: '50%', left: '50%'
  }, null, text);
  if (isdef(styles)) mStyle(box, styles);
  if (isdef(innerStyles)) mStyle(dText, innerStyles);
  if (isdef(classes)) mStyle(box, classes);
  return box;
}
function mPlayPause(dParent, styles = {}, handle_play = null, handle_pause = null) {
  if (!handle_play) handle_play = audio_onclick_pp;
  if (!handle_pause) handle_pause = handle_play;
  let html = `
    <div id="dButtons">
      <a id="bPlay" href="#">
        <i class="fa fa-play fa-2x"></i>
      </a>
      <a id="bPause" href="#" style="display: none">
        <i class="fa fa-pause fa-2x"></i>
      </a>
    </div>
  `;
  let pp = mCreateFrom(html);
  mAppend(dParent, pp);
  addKeys({ fz: 28, fg: 'lightgreen', display: 'flex', ajcenter: true, w: getRect(dParent).w }, styles);
  mStyle(pp, styles);
  mBy('bPlay').onclick = () => { hide0('bPlay'); show0('bPause'); handle_play(); }
  mBy('bPause').onclick = () => { hide0('bPause'); show0('bPlay'); handle_pause(); }
  let [fg, fz] = [styles.fg, styles.fz];
  mStyle(mBy('bPlay'), { fg: fg, fz: fz })
  mStyle(mBy('bPause'), { fg: fg, fz: fz })
  return { ui: pp, play: () => fireClick(mBy('bPlay')), pause: () => fireClick(mBy('bPause')) };
}
function mpLineup(dParent, keys, bgs, fg, textColor, texts) {
  let g2Pics = [];
  let stylesForLabelButton = { rounding: 10, margin: 4 };
  const picStyles = ['twitterText', 'twitterImage', 'openMojiText', 'openMojiImage', 'segoe', 'openMojiBlackText', 'segoeBlack'];
  let isText = true; let isOmoji = false;
  for (let i = 0; i < keys.length; i++) {
    let k = replaceAll(keys[i], ' ', '-');
    let info = symbolDict[k];
    let label = "level " + i;
    let h = window.innerHeight; let hBadge = Math.floor((h) / 14);
    let d1 = mpBadge(info, label, { w: hBadge, h: hBadge, bg: bgs[i], fgPic: fg, fgText: textColor }, null, dParent, stylesForLabelButton, 'frameOnHover', isText, isOmoji);
    g2Pics.push({ key: info.key, info: info, div: d1, id: d1.id, index: i });
  }
  return g2Pics;
}
function mPopup(content, dParent, styles, id) {
  if (isdef(mBy(id))) mRemove(id);
  mIfNotRelative(dParent);
  if (nundef(styles)) styles = { top: 0, left: 0 };
  styles.position = 'absolute';
  let d1 = mDiv(dParent, styles, valf(id, getUID()), content);
  return d1;
}
function mPos(d, x, y, unit = 'px') { mStyle(d, { left: x, top: y, position: 'absolute' }, unit); }
function mPosAbs(d) { d.style.position = 'absolute'; }
function mPosBL(d, x, y, unit = 'px') { y = valf(y, x); mStyle(d, { left: x, bottom: y, position: 'absolute' }, unit); }
function mPosBottom(d, x, y, unit = 'px') { mStyle(d, { left: x, bottom: y, position: 'absolute' }, unit); }
function mPosBottomRight(d, x, y, unit = 'px') { mStyle(d, { right: x, bottom: y, position: 'absolute' }, unit); }
function mPosBR(d, x, y, unit = 'px') { y = valf(y, x); mStyle(d, { right: x, bottom: y, position: 'absolute' }, unit); }
function mPosRel(d, x, y, unit) { d.style.position = 'relative'; if (isdef(x)) mStyle(d, { left: x, top: y }, unit); }
function mPosRight(d, x, y, unit = 'px') { mStyle(d, { right: x, top: y, position: 'absolute' }, unit); }
function mPosTL(d, x, y, unit = 'px') { y = valf(y, x); mStyle(d, { left: x, top: y, position: 'absolute' }, unit); }
function mPosTR(d, x, y, unit = 'px') { y = valf(y, x); mStyle(d, { right: x, top: y, position: 'absolute' }, unit); }
function mpOver(d, dParent, fz, color, picStyle) {
  let b = getRect(dParent);
  let cx = b.w / 2 + b.x;
  let cy = b.h / 2 + b.y;
  d.style.top = picStyle == 'segoeBlack' ? ((cy - fz * 2 / 3) + 'px') : ((cy - fz / 2) + 'px');
  d.style.left = picStyle == 'segoeBlack' ? ((cx - fz / 3) + 'px') : ((cx - fz * 1.2 / 2) + 'px');
  d.style.color = color;
  d.style.fontSize = fz + 'px';
  d.style.display = 'block';
  let { isText, isOmoji } = getParamsForMaPicStyle(picStyle);
  d.style.fontFamily = isString(isOmoji) ? isOmoji : isOmoji ? 'emoOpen' : 'emoNoto';
  return d;
}
function mpOverImage(d, dParent, sz) {
  let b = getRect(dParent);
  let cx = b.w / 2 + b.x;
  let cy = b.h / 2 + b.y;
  sz = Math.max(sz, 50);
  d.style.top = (cy - sz / 2) + 'px';
  d.style.left = (cx - sz / 4) + 'px';
  d.style.color = 'green';
  d.style.fontSize = sz + 'px';
  d.style.display = 'block';
  return d;
}
function mpSimpleButton(key, dParent, handler) {
  let info = symbolDict[key];
  let label = stringAfterLast(info.E, '|');
  let st = { w: 200, h: 200, bg: 'random', fgPic: 'random', fgText: 'contrast' };
  let stylesForLabelButton = { rounding: 10, margin: 24 };
  let { isText, isOmoji } = getParamsForMaPicStyle('twitterText');
  let d1 = maPicLabelButtonFitText(info, label, st, handler, dParent, stylesForLabelButton, 'frameOnHover', isText, isOmoji);
  return d1;
}
function mPulse(d, ms, callback = null) { mClass(d, 'onPulse'); TO[getUID()] = setTimeout(() => { mClassRemove(d, 'onPulse'); if (callback) callback(); }, ms); }
function mPulse1(d, callback) { mPulse(d, 1000, callback); }
function mPulse2(d, callback) { mPulse(d, 2000, callback); }
function mPulse3(d, callback) { mPulse(d, 3000, callback); }
function mPuppet(key, dParent, styles = {}, dist = 250) {
  if (nundef(dParent)) dParent = document.body; else dParent = toElem(dParent);
  addKeys({ position: 'fixed', fz: 40, left: 40, top: 40 }, styles);
  dPuppet = miPic(key, dParent, styles);
  aRollby(dPuppet, dist);
}
function mRadio(label, val, name, dParent, styles = {}, handler, group_id, is_on) {
  let cursor = styles.cursor; delete styles.cursor;
  let d = mDiv(dParent, styles, group_id + '_' + val);
  let id = isdef(group_id) ? `i_${group_id}_${val}` : getUID();
  let type = isdef(group_id) ? 'radio' : 'checkbox';
  let checked = isdef(is_on) ? is_on : false;
  let inp = mCreateFrom(`<input class='radio' id='${id}' type="${type}" name="${name}" value="${val}">`);
  if (checked) inp.checked = true;
  let text = mCreateFrom(`<label for='${inp.id}'>${label}</label>`);
  if (isdef(cursor)) { inp.style.cursor = text.style.cursor = cursor; }
  mAppend(d, inp);
  mAppend(d, text);
  if (isdef(handler)) {
    inp.onclick = ev => {
      ev.cancelBubble = true;
      if (handler == 'toggle') {
      } else if (isdef(handler)) {
        handler(val);
      }
    };
  }
  return d;
}
function mRadio1(label, val, dParent, styles = {}, handler, group_id) {
  let cursor = styles.cursor; delete styles.cursor;
  let d = mDiv(dParent, styles, group_id + '_' + val);
  let inp = mCreateFrom(`<input class='radio' id='i_${group_id}_${val}' type="radio" name="${group_id}" value="${val}" >`);
  let text = mCreateFrom(`<label for='${inp.id}'>${label}</label>`);
  if (isdef(cursor)) { inp.style.cursor = text.style.cursor = cursor; }
  mAppend(d, inp);
  mAppend(d, text);
  if (isdef(handler)) d.onclick = () => handler(val);
  return d;
}
function mRadioGroup(dParent, styles, id, legend, legendstyles) {
  let f = mCreate('fieldset');
  f.id = id;
  if (isdef(styles)) mStyle(f, styles);
  if (isdef(legend)) {
    let l = mCreate('legend');
    l.innerHTML = legend;
    mAppend(f, l);
    if (isdef(legendstyles)) { mStyle(l, legendstyles); }
  }
  mAppend(dParent, f);
  return f;
}
function mRadioToggle(label, val, dParent, styles = {}, is_on = true) {
  let cursor = styles.cursor; delete styles.cursor;
  let d = mDiv(dParent, styles);
  let id = getUID();
  let inp = mCreateFrom(`<input class='radio' id='${id}' type="checkbox" checked="${is_on}" value="${val}" >`);
  let text = mCreateFrom(`<label for='${id}'>${label}</label>`);
  if (isdef(cursor)) { inp.style.cursor = text.style.cursor = cursor; }
  mAppend(d, inp);
  mAppend(d, text);
  return d;
}
function mRemove(elem) {
  elem = toElem(elem);
  var a = elem.attributes, i, l, n;
  if (a) {
    for (i = a.length - 1; i >= 0; i -= 1) {
      n = a[i].name;
      if (typeof elem[n] === 'function') {
        elem[n] = null;
      }
    }
  }
  a = elem.childNodes;
  if (a) {
    l = a.length;
    for (i = a.length - 1; i >= 0; i -= 1) {
      mRemove(elem.childNodes[i]);
    }
  }
  elem.remove();
}
function mRemoveChildrenFromIndex(dParent, i) { while (dParent.children[i]) { mRemove(dParent.children[i]); } }
function mRemoveClass(d) { for (let i = 1; i < arguments.length; i++) d.classList.remove(arguments[i]); }
function mRemoveClasses(d, lst) { for (let i = 1; i < lst.length; i++) d.classList.remove(lst[i]); }
function mRemoveGracefully(elem) {
  mClass(elem, 'aniFastDisappear');
  setTimeout(() => mRemove(elem), 500);
}
function mRemoveStyle(d, styles) { for (const k of styles) d.style[k] = null; }
function mReveal(d) { d.style.opacity = 1; }
function mri(o, p, d) {
  p = { x: p.x + d, y: p.y };
  if (o) o.setPos(p.x, p.y);
  return p;
}
function mRight(dParent, d, margin = 0) {
  mStyle(dParent, { display: 'flex', 'justify-content': 'space-between', 'align-items': 'center' });
  mAppend(dParent, d);
  mStyle(d, { margin: margin, 'align-self': 'flex-end' });
  return d;
}
function mRise(d, ms = 800) {
  toElem(d).animate([{ opacity: 0, transform: 'translateY(50px)' }, { opacity: 1, transform: 'translateY(0px)' },], { fill: 'both', duration: ms, easing: 'ease' });
}
function mRot(d, angle) { d.style.transform = 'rotate(' + angle + 'deg)'; }
function mRow(dParent, styles) {
  return mDiv(dParent, styles)
}
function mRows(dParent, arr, itemStyles = { bg: 'random' }, rowStyles, colStyles, akku) {
  let d0 = mDiv100(dParent, { display: 'flex', dir: 'column', 'justify-content': 'space-between' });
  if (isdef(rowStyles)) mStyle(d0, rowStyles);
  for (let i = 0; i < arr.length; i++) {
    let content = arr[i];
    if (isList(content)) {
      let d1 = mDiv(d0);
      mCols(d1, content, itemStyles, rowStyles, colStyles, akku);
    } else {
      d1 = mContent(content, d0, itemStyles);
      akku.push(d1);
    }
  }
}
function mRowsX(dParent, arr, itemStyles = { bg: 'random' }, rowStyles, colStyles, akku) {
  let d0 = mDiv100(dParent, { display: 'flex', dir: 'column', 'justify-content': 'space-between' });
  if (isdef(rowStyles)) mStyle(d0, rowStyles);
  for (let i = 0; i < arr.length; i++) {
    let content = arr[i];
    if (isList(content)) {
      let d1 = mDiv(d0);
      mColsX(d1, content, itemStyles, rowStyles, colStyles, akku);
    } else {
      d1 = mContentX(content, d0, itemStyles);
      akku.push(d1);
    }
  }
}
function mScale(d, scale) { mStyle(d, { 'transform-origin': 'top', transform: `scale(${scale})` }); }
function mScreen(dParent, styles) { let d = mDover(dParent); if (isdef(styles)) mStyleX(d, styles); return d; }
function mSearch(handler, dParent, styles, classes) {
  let html = `
    <form id="fSearch" action="javascript:void(0);" class='form'>
      <label>Keywords:</label>
      <input id="iKeywords" type="text" name="keywords" style="flex-grow:1" />
      <button type="submit" class='hop1' >Search</button>
    </form>
  `;
  let elem = mCreateFrom(html);
  mAppend(dParent, elem);
  elem.onsubmit = handler;
  return elem;
}
function mSection(styles = {}, id, inner, tag, classes) {
  let d = mBy(id);
  addKeys({ position: 'relative' }, styles);
  mStyle(d, styles);
  if (isdef(tag) && isdef(inner)) inner = `<${tag}>${inner}</${tag}>`;
  if (isdef(inner)) d.innerHTML = inner;
  if (isdef(classes)) mClass(d, classes);
  return d;
}
function msElapsedSince(msStart) { return Date.now() - msStart; }
function mSelect(dParent, optionList, friendlyList, initval, onselect, label, styles, classes) {
  let d = mDiv(dParent);
  val = valf(initval, optionList[0]);
  let inp = mCreate('select');
  inp.onchange = onselect;
  for (let i = 0; i < optionList.length; i++) {
    let opt = optionList[i];
    let friendly = friendlyList[opt];
    let el = mCreate('option');
    el.setAttribute('value', opt);
    el.innerHTML = friendly;
    mAppend(inp, el);
    if (opt == val) el.selected = true;
  }
  mAppend(d, inp);
  if (isdef(styles)) mStyle(inp, styles);
  if (isdef(classes)) mClass(inp, classes);
  return d;
}
function mSelectTableRow(r, color = 'pink') {
  let t = r.parentNode;
  for (const ch of t.children) mStyle(ch, { background: 'transparent' });
  mStyle(r, { background: color });
}
function mset_bounds(minzoom = 2, maxzoom = 20) {
  let map = M.map;
  map.options.minZoom = minzoom;
  map.options.maxZoom = maxzoom;
  var southWest = L.latLng(-89.98155760646617, -180),
    northEast = L.latLng(89.99346179538875, 180);
  var bounds = L.latLngBounds(southWest, northEast);
  map.setMaxBounds(bounds);
  map.on('drag', function () {
    map.panInsideBounds(bounds, { animate: false });
  });
}
function mset_layers(base, overlay) {
  let map = M.map;
  [base, overlay] = [toWords(base), toWords(overlay)];
  let baseLayers = {}, overlays = {};
  M.layers = {};
  for (const k of base) {
    let l = _get_layer(k, { opacity: 1 });
    l.overlay = false;
    l.key = k;
    M.layers[k] = baseLayers[k] = l;
  }
  for (const k of overlay) {
    let l = get_layer(k, { opacity: .5 });
    l.overlay = true;
    l.key = k;
    M.layers['ov_' + k] = overlays[k] = l;
  }
  M.layer_control = L.control.layers(baseLayers, overlays).addTo(map);
  baseLayers[base[0]].addTo(map);
  overlays[overlay[0]].addTo(map);
}
function mShape(shape, dParent, styles, pos, classes) {
  styles = valf(styles, { bg: 'random' });
  styles.display = 'inline-block';
  let x;
  if (isdef(PolyClips[shape])) {
    let d = mDiv(dParent, styles, null, null, classes);
    styles['clip-path'] = PolyClips[shape];
    mStyle(d, styles);
    x = d;
  } else {
    styles.rounding = shape == 'circle' || shape == 'ellipse' ? '50%' : styles.rounding;
    x = mDiv(dParent, styles, null, null, classes);
  }
  if (isdef(pos)) { mPlace(x, pos); }
  return x;
}
function mShapeR(shape = 'hex', dParent = null, styles = {}, pos, classes) {
  let x;
  let bg = isdef(styles.bg) ? computeColorX(styles.bg) : 'conic-gradient(green,pink,green)';
  let sz = isdef(styles.sz) ? styles.sz : isdef(styles.w) ? styles.w : isdef(styles.h) ? styles.h : null;
  if (isdef(PolyClips[shape])) {
    sz = valf(sz, 80);
    let html = `<div style=
    "--b:${bg};
    --clip:${PolyClips[shape]};
    --patop:100%;
    --w:${sz}px;
    "></div>`;
    x = createElementFromHtml(html);
  } else {
    x = mShape(shape, dParent, styles, pos, classes);
    return x;
  }
  if (sz) {
    bvar = sz > 120 ? 8 : sz > 80 ? 5 : sz > 50 ? 3 : 1;
    mClass(x, "weired" + bvar);
    mStyle(x, { w: sz });
  }
  if (isdef(dParent)) mAppend(dParent, x);
  if (isdef(classes)) mClass(x, classes);
  if (isdef(pos)) { mPlace(x, pos); }
  return x;
}
function mShield(dParent, styles = { bg: '#00000020' }, id = null, classnames = null, hideonclick = false) {
  dParent = toElem(dParent);
  let d = mDiv(dParent, styles, id, classnames);
  lookupAddIfToList(DA, ['shields'], d);
  mIfNotRelative(dParent);
  mStyle(d, { position: 'absolute', left: 0, top: 0, w: '100%', h: '100%' });
  if (hideonclick) d.onclick = ev => { evNoBubble(ev); d.remove(); };
  else d.onclick = ev => { evNoBubble(ev); };
  mClass(d, 'topmost');
  return d;
}
function mShieldsOff() { if (nundef(DA.shields)) return; for (const d of DA.shields) d.remove(); }
function mShow(d, ms = 0) { if (ms > 0) mAppear(d, ms); else mStyle(d, { opacity: 1 }); }
function mShrink(d, x = .75, y = .75, ms = 800, callback = null) {
  let anim = toElem(d).animate([{ transform: `scale(${1},${1})` }, { transform: `scale(${x},${y})` },], { fill: 'both', duration: ms, easing: 'ease' });
  anim.onfinish = callback;
}
function mShrinkTranslate(child, scale, newParent, ms = 800, callback) {
  let [dx, dy] = get_screen_distance(child, newParent);
  mAnimate(child, 'transform', [`translateX(${dx}px) translateY(${dy}px) scale(${scale})`], callback, ms, 'ease');
}
function mShrinkUp(d, x = .75, y = 0, ms = 800, callback = null) {
  let anim = toElem(d).animate([{ transform: `scale(${1},${1})`, opacity: 1 }, { transform: `scale(${x},${y})`, opacity: 0 },], { fill: 'none', duration: ms, easing: 'ease' });
  anim.onfinish = mClear(d);
}
function mSidebar(title, dParent, styles, id, inner) {
  let elem = createElementFromHtml(`
  <div id="${id}" class="w3sidebar">
    <h1>${title}</h1>
    <a href="javascript:void(0)" class="closebtn">×</a>
  </div>  
  `);
  function openNav() {
    elem.style.width = "250px";
    dParent.style.marginLeft = "250px";
  }
  function closeNav() {
    elem.style.width = "0";
    dParent.style.marginLeft = "0";
  }
  elem.children[1].onclick = closeNav;
  mClass(dParent, 'w3sidebarParent');
  let dContent = mDiv(elem);
  mInsert(dParent.parentNode, elem);
  return { div: elem, dContent: dContent, fOpen: openNav, fClose: closeNav };
}
function mSimplest(n, R, uidParent) {
  let ui;
  let dParent = mBy(n.idUiParent);
  if (isdef(n.content)) {
    ui = mDiv(dParent);
    ui.innerHTML = n.content;
  } else {
    ui = mDiv(dParent);
  }
  let b = getBounds(ui, true);
  console.log('________createUi: ', n.uid, '\n', ui, '\nbounds', b.width, b.height);
  if (ui.id == '_1') ui.style.maxWidth = '140px';
  return ui;
}
function mSimplestInvisible(n, R, uidParent) {
  let dParent = mBy(n.idUiParent);
  let d = mDiv(dParent);
  if (n.content) {
    mText(n.content, d);
  }
  return d;
}
function MSInit() {
  ROOT = { id: 'root', elem: domId('root'), type: 'div', cat: 'd', children: [] };
  createMSTree(ROOT);
  simpleColors(S.options.colors[0]);//'midnightBlue');
  measureMSTree(ROOT);
}
function mSize(d, w, h, unit = 'px', sizing) { if (nundef(h)) h = w; mStyle(d, { width: w, height: h }, unit); if (isdef(sizing)) setRect(d, sizing); }
function mSizePic(d, w, h = 0, unit = 'px') { return mStyle(d, { 'font-size': h / 2, 'font-weight': 900, 'padding-top': h / 4, 'text-align': 'center', 'box-sizing': 'border-box', width: w, height: h ? h : w }, unit); }
function msNow() { return Date.now(); }
function mSocketUploadImage(item, socket) {
  if (!item.loaded) {
    console.log('file not ready!click again!'); return;
  }
  socket.emit('testImageUpload', { filename: item.filename, image: item.base64 });
}
function mSpan(dParent, styles, innerHTML) {
  let d = mCreate('span');
  if (isdef(styles)) mStyle(d, styles);
  if (isdef(innerHTML)) d.innerHTML = innerHTML;
  if (isdef(dParent)) mAppend(dParent, d);
  return d;
}
function mStamp(d1, text, color, sz) {
  mStyle(d1, { position: 'relative' });
  let r = getRect(d1);
  let [w, h] = [r.w, r.h];
  color = valf(color, 'black');
  sz = valf(sz, r.h / 7);
  let [padding, border, rounding, angle] = [sz / 10, sz / 6, sz / 8, rChoose([-16, -14, -10, 10, 14])];
  let d2 = mDiv(d1, {
    fg: color,
    position: 'absolute', top: 25, left: 5,
    transform: `rotate(${angle}deg)`,
    fz: sz,
    hpadding: 2,
    vpadding: 0,
    rounding: rounding,
    border: `${border}px solid ${colorTrans(color, .8)}`,
    '-webkit-mask-size': `${w}px ${h}px`,
    '-webkit-mask-position': `50% 50%`,
    '-webkit-mask-image': 'url("../base/assets/images/textures/grunge.png")',
    weight: 400,
    display: 'inline-block',
    'text-transform': 'uppercase',
    family: 'blackops',
    'mix-blend-mode': 'multiply',
  }, null, text);
}
function msToTime(ms) {
  let secs = Math.floor(ms / 1000);
  let mins = Math.floor(secs / 60);
  secs = secs - mins * 60;
  let hours = Math.floor(mins / 60);
  mins = mins - hours * 60;
  return { h: hours, m: mins, s: secs };
}
function mStyle(elem, styles, unit = 'px') {
  elem = toElem(elem);
  if (isdef(styles.whrest)) { delete styles.whrest; styles.w = styles.h = 'rest'; } else if (isdef(styles.wh100)) { styles.w = styles.h = '100%'; delete styles.wh100; }
  if (isdef(styles.w100)) styles.w = '100%'; else if (isdef(styles.wrest)) styles.w = 'rest';
  if (isdef(styles.h100)) styles.h = '100%'; else if (isdef(styles.hrest)) styles.h = 'rest';
  let dParent = elem.parentNode;
  let pad = parseInt(valf(dParent.style.padding, '0'));
  let rp = getRect(dParent);
  let r = getRect(elem, dParent);
  if (styles.w == 'rest') {
    let left = r.l;
    let w = rp.w;
    let wrest = w - left - pad;
    styles.w = wrest;
  }
  if (styles.h == 'rest') {
    let r1 = getRect(dParent.lastChild, dParent);
    let hrest = rp.h - (r1.y) - pad;
    styles.h = hrest;
  }
  let bg, fg;
  if (isdef(styles.bg) || isdef(styles.fg)) {
    [bg, fg] = colorsFromBFA(styles.bg, styles.fg, styles.alpha);
  }
  if (isdef(styles.vpadding) || isdef(styles.hpadding)) {
    styles.padding = valf(styles.vpadding, 0) + unit + ' ' + valf(styles.hpadding, 0) + unit;
  }
  if (isdef(styles.vmargin) || isdef(styles.hmargin)) {
    styles.margin = valf(styles.vmargin, 0) + unit + ' ' + valf(styles.hmargin, 0) + unit;
  }
  if (isdef(styles.upperRounding) || isdef(styles.lowerRounding)) {
    let rtop = '' + valf(styles.upperRounding, 0) + unit;
    let rbot = '' + valf(styles.lowerRounding, 0) + unit;
    styles['border-radius'] = rtop + ' ' + rtop + ' ' + rbot + ' ' + rbot;
  }
  if (isdef(styles.box)) styles['box-sizing'] = 'border-box';
  if (isdef(styles.round)) styles['border-radius'] = '50%';
  for (const k in styles) {
    let val = styles[k];
    let key = k;
    if (isdef(STYLE_PARAMS[k])) key = STYLE_PARAMS[k];
    else if (k == 'font' && !isString(val)) {
      let fz = f.size; if (isNumber(fz)) fz = '' + fz + 'px';
      let ff = f.family;
      let fv = f.variant;
      let fw = isdef(f.bold) ? 'bold' : isdef(f.light) ? 'light' : f.weight;
      let fs = isdef(f.italic) ? 'italic' : f.style;
      if (nundef(fz) || nundef(ff)) return null;
      let s = fz + ' ' + ff;
      if (isdef(fw)) s = fw + ' ' + s;
      if (isdef(fv)) s = fv + ' ' + s;
      if (isdef(fs)) s = fs + ' ' + s;
      elem.style.setProperty(k, s);
      continue;
    } else if (k == 'classname') {
      mClass(elem, styles[k]);
    } else if (k == 'border') {
      if (isNumber(val)) val = `solid ${val}px ${isdef(styles.fg) ? styles.fg : '#ffffff80'}`;
      if (val.indexOf(' ') < 0) val = 'solid 1px ' + val;
    } else if (k == 'ajcenter') {
      elem.style.setProperty('justify-content', 'center');
      elem.style.setProperty('align-items', 'center');
    } else if (k == 'layout') {
      if (val[0] == 'f') {
        val = val.slice(1);
        elem.style.setProperty('display', 'flex');
        elem.style.setProperty('flex-wrap', 'wrap');
        let hor, vert;
        if (val.length == 1) hor = vert = 'center';
        else {
          let di = { c: 'center', s: 'start', e: 'end' };
          hor = di[val[1]];
          vert = di[val[2]];
        }
        let justStyle = val[0] == 'v' ? vert : hor;
        let alignStyle = val[0] == 'v' ? hor : vert;
        elem.style.setProperty('justify-content', justStyle);
        elem.style.setProperty('align-items', alignStyle);
        switch (val[0]) {
          case 'v': elem.style.setProperty('flex-direction', 'column'); break;
          case 'h': elem.style.setProperty('flex-direction', 'row'); break;
        }
      } else if (val[0] == 'g') {
        val = val.slice(1);
        elem.style.setProperty('display', 'grid');
        let n = allNumbers(val);
        let cols = n[0];
        let w = n.length > 1 ? '' + n[1] + 'px' : 'auto';
        elem.style.setProperty('grid-template-columns', `repeat(${cols}, ${w})`);
        elem.style.setProperty('place-content', 'center');
      }
    } else if (k == 'layflex') {
      elem.style.setProperty('display', 'flex');
      elem.style.setProperty('flex', '0 1 auto');
      elem.style.setProperty('flex-wrap', 'wrap');
      if (val == 'v') { elem.style.setProperty('writing-mode', 'vertical-lr'); }
    } else if (k == 'laygrid') {
      elem.style.setProperty('display', 'grid');
      let n = allNumbers(val);
      let cols = n[0];
      let w = n.length > 1 ? '' + n[1] + 'px' : 'auto';
      elem.style.setProperty('grid-template-columns', `repeat(${cols}, ${w})`);
      elem.style.setProperty('place-content', 'center');
    }
    if (key == 'font-weight') { elem.style.setProperty(key, val); continue; }
    else if (key == 'background-color') elem.style.background = bg;
    else if (key == 'color') elem.style.color = fg;
    else if (key == 'opacity') elem.style.opacity = val;
    else if (key == 'wrap') { if (val == 'hard') elem.setAttribute('wrap', 'hard'); else elem.style.flexWrap = 'wrap'; }
    else if (startsWith(k, 'dir')) {
      isCol = val[0] == 'c';
      elem.style.setProperty('flex-direction', 'column');
    } else if (key == 'flex') {
      if (isNumber(val)) val = '' + val + ' 1 0%';
      elem.style.setProperty(key, makeUnitString(val, unit));
    } else {
      elem.style.setProperty(key, makeUnitString(val, unit));
    }
  }
}
function mStyleGet(elem, prop) { return mGetStyle(elem, prop); }
function mStyleOrClass(elem, st) { if (isString(st)) mClass(elem, st); else mStyle(elem, st); }
function mStyleRemove(elem, prop) {
  if (isdef(STYLE_PARAMS[prop])) prop = STYLE_PARAMS[prop];
  elem.style.removeProperty(prop);
}
function mStyleS(elem, styles, unit = 'px') { elem = mEnsure(elem); for (const k in styles) { elem.style.setProperty(k, makeUnitString(styles[k], unit)); } return elem; }
function mStyleToCy(di, group) { return translateStylesToCy(di, group); }
function mStyleTranslate(prop, val, convertNumbers = true) {
  const paramDict = {
    align: 'text-align',
    bg: 'background-color',
    fg: 'color',
    hgap: 'column-gap',
    vgap: 'row-gap',
    matop: 'margin-top',
    maleft: 'margin-left',
    mabottom: 'margin-bottom',
    maright: 'margin-right',
    patop: 'padding-top',
    paleft: 'padding-left',
    pabottom: 'padding-bottom',
    paright: 'padding-right',
    rounding: 'border-radius',
    w: 'width',
    h: 'height',
    wmin: 'min-width',
    hmin: 'min-height',
    wmax: 'max-width',
    hmax: 'max-height',
    fontSize: 'font-size',
    fz: 'font-size',
    family: 'font-family',
    weight: 'font-weight',
    z: 'z-index'
  };
  let valDict = {
    random: randomColor(),
  };
  let propName = isdef(paramDict[prop]) ? paramDict[prop] : prop;
  let newVal = isdef(valDict[val]) ? valdict[val] : val;
  if (convertNumbers && isNumber(newVal)) newVal = '' + newVal + 'px';
  return [propName, newVal];
}
function mStyleUndo(ui, styles = {}) {
  for (const k in styles) {
    let key = valf(STYLE_PARAMS[k], k);
    ui.style[key] = null;
  }
}
function mStyleX(elem, styles, unit = 'px') {
  const paramDict = {
    bg: 'background-color',
    fg: 'color',
    align: 'text-align',
    matop: 'margin-top',
    maleft: 'margin-left',
    mabottom: 'margin-bottom',
    maright: 'margin-right',
    patop: 'padding-top',
    paleft: 'padding-left',
    pabottom: 'padding-bottom',
    paright: 'padding-right',
    rounding: 'border-radius',
    w: 'width',
    h: 'height',
    fontSize: 'font-size',
    fz: 'font-size',
    family: 'font-family',
    weight: 'font-weight',
  };
  let bg, fg;
  if (isdef(styles.bg) || isdef(styles.fg)) {
    [bg, fg] = getExtendedColors(styles.bg, styles.fg);
  }
  if (isdef(styles.vmargin) && isdef(styles.hmargin)) {
    styles.margin = vmargin + unit + ' ' + hmargin + unit;
  }
  if (isdef(styles.vpadding) && isdef(styles.hpadding)) {
    styles.padding = vpadding + unit + ' ' + hpadding + unit;
  }
  for (const k in styles) {
    let val = styles[k];
    let key = k;
    if (isdef(paramDict[k])) key = paramDict[k];
    else if (k == 'font' && !isString(val)) {
      let fz = f.size; if (isNumber(fz)) fz = '' + fz + 'px';
      let ff = f.family;
      let fv = f.variant;
      let fw = isdef(f.bold) ? 'bold' : isdef(f.light) ? 'light' : f.weight;
      let fs = isdef(f.italic) ? 'italic' : f.style;
      if (nundef(fz) || nundef(ff)) return null;
      let s = fz + ' ' + ff;
      if (isdef(fw)) s = fw + ' ' + s;
      if (isdef(fv)) s = fv + ' ' + s;
      if (isdef(fs)) s = fs + ' ' + s;
      elem.style.setProperty(k, s);
      continue;
    } else if (k == 'border') {
      if (val.indexOf(' ') < 0) val = 'solid 1px ' + val;
    }
    if (key == 'font-weight') { elem.style.setProperty(key, val); continue; }
    else if (key == 'background-color') elem.style.background = bg;
    else if (key == 'color') elem.style.color = fg;
    else {
      elem.style.setProperty(key, makeUnitString(val, unit));
    }
  }
}
function mSuit(ckey, sz = 20, color = null) {
  let suit = ckey.length == 1 ? ckey : ckey[1];
  let di = { S: '&spades;', H: '&hearts;', D: '&diams;', C: '&clubs;' };
  color = valf(color, suit == 'H' || suit == 'D' ? 'red' : 'black');
  let html = `<span style='color:${color};font-size:${sz}px'>${di[suit]}</span>`;
  return html;
}
function mSuitPos(svg, pos) {
  pos = pos.toLowerCase();
  if (pos[0] == 'c' || pos[1] == 'c') {
    let dCard = svg.parentNode;
    let r = getRect(dCard);
    let [wCard, hCard] = [r.w, r.h];
    let [wSym, hSym] = [svg.getAttribute('width'), svg.getAttribute('height')];
    switch (pos) {
      case 'cc': mStyle(svg, { position: 'absolute', left: (wCard - wSym) / 2, top: (hCard - hSym) / 2 }); break;
      case 'tc': mStyle(svg, { position: 'absolute', left: (wCard - wSym) / 2, top: 0 }); break;
      case 'bc': mStyle(svg, { position: 'absolute', left: (wCard - wSym) / 2, bottom: 0 }); break;
      case 'cl': mStyle(svg, { position: 'absolute', left: 0, top: (hCard - hSym) / 2 }); break;
      case 'cr': mStyle(svg, { position: 'absolute', right: 0, top: (hCard - hSym) / 2 }); break;
    }
    return;
  }
  let di = { t: 'top', b: 'bottom', r: 'right', l: 'left' };
  svg.style.position = 'absolute';
  svg.style[di[pos[0]]] = svg.style[di[pos[1]]] = 0;
}
function mSuitSize(suit, sz) { suit.setAttribute('sz', sz); suit.firstChild.setAttribute('height', sz); gSizeToContent(suit); }
function mSwap(obj1, obj2) {
  var parent2 = obj2.parentNode;
  var next2 = obj2.nextSibling;
  if (next2 === obj1) {
    parent2.insertBefore(obj1, obj2);
  } else {
    obj1.parentNode.insertBefore(obj2, obj1);
    if (next2) {
      parent2.insertBefore(obj1, next2);
    } else {
      parent2.appendChild(obj1);
    }
  }
}
function mSym(key, dParent, styles = {}, pos, classes) {
  let info = Syms[key];
  styles.display = 'inline-block';
  let family = info.family;
  styles.family = family;
  let sizes;
  if (isdef(styles.sz)) { sizes = mSymSizeToBox(info, styles.sz, styles.sz); }
  else if (isdef(styles.w) && isdef(styles.h)) { sizes = mSymSizeToBox(info, styles.w, styles.h); }
  else if (isdef(styles.fz)) { sizes = mSymSizeToFz(info, styles.fz); }
  else if (isdef(styles.h)) { sizes = mSymSizeToH(info, styles.h); }
  else if (isdef(styles.w)) { sizes = mSymSizeToW(info, styles.w); }
  else { sizes = mSymSizeToFz(info, 25); }
  styles.fz = sizes.fz;
  styles.w = sizes.w;
  styles.h = sizes.h;
  styles.align = 'center';
  if (isdef(styles.bg) && info.family != 'emoNoto') { styles.fg = styles.bg; delete styles.bg; }
  let x = mDiv(dParent, styles, null, info.text);
  if (isdef(classes)) mClass(x, classes);
  if (isdef(pos)) { mPlace(x, pos); }
  return x;
}
function mSymbol(key, dParent, sz, styles = {}) {
  console.log('key', key)
  let info = symbolDict[key];
  fzStandard = info.fz;
  hStandard = info.h[0];
  wStandard = info.w[0];
  let fzMax = fzStandard * sz / Math.max(hStandard, wStandard);
  fzMax *= .9;
  let fz = isdef(styles.fz) && styles.fz < fzMax ? styles.fz : fzMax;
  let wi = wStandard * fz / 100;
  let hi = hStandard * fz / 100;
  let vpadding = 2 + Math.ceil((sz - hi) / 2); console.log('***vpadding', vpadding)
  let hpadding = Math.ceil((sz - wi) / 2);
  let margin = '' + vpadding + 'px ' + hpadding + 'px'; //''+vpadding+'px '+hpadding+' ';
  let newStyles = deepmergeOverride({ fz: fz, align: 'center', w: sz, h: sz, bg: 'white' }, styles);
  newStyles.fz = fz;
  let d = mDiv(dParent, newStyles);
  console.log(key, info)
  let txt = mText(info.text, d, { family: info.family });
  console.log('-----------', margin, hpadding, vpadding);
  mStyle(txt, { margin: margin, 'box-sizing': 'border-box' });
  return d;
}
function mSymFramed(info, bg, sz) {
  let [w, h, fz] = [sz, sz, sz * .7];
  return mCreateFrom(`<div style='
  text-align:center;display:inline;background-color:${bg};
  font-size:${fz}px;overflow:hidden;
  font-family:${info.family}'>${info.text}</div>`);
}
function mSymInDiv(sym, dParent, styles = { sz: Card.sz / 5, fg: 'random' }) {
  dResult = mDiv(dParent);
  ds = mSym(sym, dResult, styles);
  return dResult;
}
function mSymInDivShrink(sym, dParent, styles = { sz: Card.sz / 5, fg: 'random' }) {
  dResult = mDiv(dParent);
  let ds = mSym(sym, dResult, styles);
  let scale = chooseRandom([.5, .75, 1, 1.25]);
  let [scaleX, scaleY] = [coin() ? scale : -scale, scale];
  if (coin()) ds.style.transform = `scale(${scaleX},${scaleY})`;
  return dResult;
}
function mSymInline(key, dParent, styles) {
  let info = Syms[key];
  styles.family = info.family;
  let el = mSpan(dParent, styles, null, info.text);
  return text;
}
function mSymSizeToBox(info, w, h) {
  let fw = w / info.w;
  let fh = h / info.h;
  let f = Math.min(fw, fh);
  return { fz: 100 * f, w: info.w * f, h: info.h * f };
}
function mSymSizeToFz(info, fz) { let f = fz / 100; return { fz: fz, w: info.w * f, h: info.h * f }; }
function mSymSizeToH(info, h) { let f = h / info.h; return { fz: 100 * f, w: info.w * f, h: h }; }
function mSymSizeToW(info, w) { let f = w / info.w; return { fz: 100 * f, w: w, h: info.h * f }; }
function mSymText(s, dParent, styles = {}, pos, classes) {
  styles.display = 'inline-block';
  styles.w = valfi(styles.w, styles.sz, styles.h, '25%');
  styles.h = valfi(styles.h, styles.sz, styles.w, styles.fz, '25%');
  styles.fz = valfi(styles.fz, styles.sz * 4 / 5, styles.h * 4 / 5, styles.w * 2, '20%');
  styles.align = 'center';
  let x = mDiv(dParent, styles, null, s); mCenterCenterFlex(x);
  if (isdef(classes)) mClass(x, classes);
  if (isdef(pos)) { mPlace(x, pos); }
  return x;
}
function mSzPic(d, sz, unit = 'px') { return mSizePic(d, sz, sz, unit); }
function mTable(dParent, headers, showheaders, styles = { mabottom: 0 }, className = 'table') {
  let d = mDiv(dParent);
  let t = mCreate('table');
  mAppend(d, t);
  if (isdef(className)) mClass(t, className);
  if (isdef(styles)) mStyle(t, styles);
  if (showheaders) {
    let code = `<tr>`;
    for (const h of headers) {
      code += `<th>${h}</th>`
    }
    code += `</tr>`;
    t.innerHTML = code;
  }
  return t;
}
function mTableCol(r, val) {
  let col = mCreate('td');
  mAppend(r, col);
  if (isdef(val)) col.innerHTML = val;
  return col;
}
function mTableCommandify(rowitems, di) {
  for (const item of rowitems) {
    for (const index in di) {
      let colitem = item.colitems[index];
      colitem.div.innerHTML = di[index](item, colitem.val);
    }
  }
}
function mTableCommandifyList(rowitem, val, func) {
  let names = isString(val) ? val.replaceAll(' ', ',').split(',') : val;
  let html = '';
  for (const name of names) {
    html += func(rowitem, name);
  }
  return html;
}
function mTableCommands(rowitems, di) {
  let t = rowitems[0].div.parentNode;
  mTableHeader(t, 'commands');
  for (const item of rowitems) {
    let drow = item.div;
    let dcol = mTableCol(drow);
    let colitem = { div: dcol, key: 'commands', val: null };
    item.colitems.push(colitem);
    let html = '';
    for (const k in di) {
      html += di[k](item);
    }
    dcol.innerHTML = html;
  }
}
function mTableHeader(t, val) {
  let col = mCreate('th');
  mAppend(t.firstChild, col);
  col.innerHTML = val;
  return col;
}
function mTableRow(t, o, headers, id) {
  let elem = mCreate('tr');
  if (isdef(id)) elem.id = id;
  mAppend(t, elem);
  let colitems = [];
  for (const k of headers) {
    let val = isdef(o[k]) ? isDict(o[k]) ? JSON.stringify(o[k]) : isList(o[k]) ? o[k].join(', ') : o[k] : '';
    let col = mTableCol(elem, val);
    colitems.push({ div: col, key: k, val: val });
  }
  return { div: elem, colitems: colitems };
}
function mTableTransition(d, ms = 800) {
  toElem(d).animate([{ opacity: .25 }, { opacity: 1 },], { fill: 'both', duration: ms, easing: 'ease' });
}
function mTag(tag, inner = null, dParent = null, styles = {}, id = null, classes = null) {
  let el = mCreate(tag);
  if (inner) el.innerHTML = inner; //'Descriptive Text goes here';
  if (dParent) mAppend(dParent, el);
  if (styles) mStyle(el, styles);
  if (id) el.id = id;
  if (classes) mClass(el, classes);
  return el;
}
function mTaPlain(dParent, styles = {}, opts = {}) {
  opts.tag = 'textarea';
  let ta = mDom(dParent, styles, opts);
  mClass(ta, 'plain');
  return ta;
}
function mText(text, dParent, styles, classes) {
  if (!isString(text)) text = text.toString();
  let d = mDiv(dParent);
  if (!isEmpty(text)) { d.innerHTML = text; }
  if (isdef(styles)) mStyle(d, styles);
  if (isdef(classes)) mClass(d, classes);
  return d;
}
function mTextArea(rows, cols, dParent, styles = {}, id) {
  let html = `<textarea id="${id}" rows="${rows}" cols="${cols}" wrap="hard"></textarea>`;
  let t = mCreateFrom(html);
  mAppend(dParent, t);
  mStyle(t, styles);
  return t;
}
function mTextarea(rows, cols, dParent, styles = {}, id) {
  let html = `<textarea id="${id}"`;
  if (isdef(rows)) html += ` rows="${rows}"`;
  if (isdef(cols)) html += ` cols="${cols}"`;
  html += ` wrap="hard"></textarea>`;
  let t = mCreateFrom(html);
  mAppend(dParent, t);
  mStyle(t, styles);
  return t;
}
function mTextDiv(text, dParent = null) { let d = mCreate('div'); d.innerHTML = text; return d; }
function mTextFit(text, { wmax, hmax }, dParent, styles, classes) {
  let d = mDiv(dParent);
  if (!isEmpty(text)) d.innerHTML = text;
  if (nundef(styles) && (isdef(wmax)) || isdef(hmax)) {
    styles = {};
  }
  if (isdef(wmax)) styles.width = wmax;
  if (isdef(hmax)) styles.height = hmax;
  if (isdef(styles)) mStyleX(d, styles);
  if (isdef(classes)) mClass(d, classes);
  return d;
}
function mTextWidth(txt, fz = 16) {
  let len = txt.length;
  let wprox = (len + 1.5) * fz / 2;
  return wprox;
}
function mTitle(n, R, uidParent) {
  let dParent = mBy(n.idUiParent);
  let ui = mText(n.content, dParent);
  return ui;
}
function mTitledDiv(title, dParent, outerStyles = {}, innerStyles = {}, id) {
  let d = mDiv(dParent, outerStyles);
  let dTitle = mDiv(d);
  dTitle.innerHTML = title;
  innerStyles.w = '100%';
  innerStyles.h = outerStyles.h - getRect(dTitle).h;
  let dContent = mDiv(d, innerStyles, id);
  return dContent;
}
function mTitledMessageDiv(title, dParent, id, outerStyles = {}, contentStyles = {}, titleStyles = {}, messageStyles = {}, titleOnTop = true) {
  let d = mDiv(dParent, outerStyles, id);
  let dTitle = mDiv(d, titleStyles, id + '.title'); dTitle.innerHTML = title;
  let dMessage = mDiv(d, messageStyles, id + '.message'); dMessage.innerHTML = 'hallo!';
  contentStyles.w = '100%';
  let hTitle = getRect(dTitle).h, hMessage = getRect(dMessage).h, hArea = getRect(d).h;
  let hContent = hArea - hTitle - hMessage - 4;
  mStyle(dMessage, { h: hMessage + 2 });
  mStyle(dTitle, { h: hTitle + 2 });
  contentStyles.hmin = hContent;
  let dContent = mDiv(d, contentStyles, id + '.content');
  if (!titleOnTop) { mAppend(d, dTitle); }
  return d;
}
function mToggle(label, dParent, styles = {}, handler, is_on, styleyes, styleno, classes = null) {
  let cursor = styles.cursor; delete styles.cursor;
  let name = replaceWhite(label);
  let checked = isdef(is_on) ? is_on : false;
  let b = mButton(label, null, dParent, styles, classes);
  mClass(b, 'noactive');
  b.setAttribute('checked', checked);
  b.onclick = ev => {
    ev.cancelBubble = true;
    let b = ev.target;
    assertion(b == ev.target, 'NOOOOOOOOOOOOOOOOOOOOOOO')
    let oldval = b.getAttribute('checked') == 'false' ? false : true;
    let newval = oldval ? false : true;
    if (newval === true) {
      mStyle(b, styleyes);
    } else {
      mStyle(b, styleno);
    }
    b.setAttribute('checked', newval);
    handler(name, newval);
  };
  return b;
}
function mToggle_orig_BROKEN(label, val, dParent, styles = {}, handler = null, is_on = true) {
  let cursor = styles.cursor; delete styles.cursor;
  let d = mDiv(dParent, styles);
  let id = getUID();
  let inp = createElementFromHTML(`<input class='radio' id='${id}' type="checkbox" checked="${is_on}" value="${val}" >`);
  let text = createElementFromHTML(`<label for='${id}'>${label}</label>`);
  if (isdef(cursor)) { inp.style.cursor = text.style.cursor = cursor; }
  mAppend(d, inp);
  mAppend(d, text);
  if (isdef(handler)) inp.onclick = ev => { ev.cancelBubble = true; handler(val); }
  return d;
}
function mTogglebar(di, handler, styleyes, styleno, dParent, styles, bstyles, id, classes, bclasses) {
  let d = mDiv(dParent, styles, id, classes);
  for (const k in di) {
    mToggle(k, d, bstyles, handler, di[k], styleyes, styleno, bclasses);
  }
}
function mToggleStyle(d, prop, val1, val2) {
  let val = d.style[prop];
  if (val === null && val1 == 0) val = val1;
  else if (isNumber(val1)) val = firstNumber(val);
  if (val == val1) d.style[prop] = makeUnitString(val2); else d.style[prop] = makeUnitString(val1);
}
function mToolbar(buttons, handler, dParent, styles = {}, bstyles = {}, id = null, classes = null, bclasses = null) {
  let d = mDiv(dParent, styles, id, classes);
  for (const arg of buttons) {
    let funcname = replaceWhite(arg);
    mButton(arg, () => handler(arg), d, bstyles, bclasses, `b${funcname}`);
  }
  return d;
}
function mTranslate(child, newParent, ms = 800, callback = null) {
  let [dx, dy] = get_screen_distance(child, newParent);
  onend = () => { mAppend(newParent, child); if (callback) callback(); };
  mAnimate(child, 'transform', [`translateX(${dx}px) translateY(${dy}px)`], onend, ms, 'ease');
}
function mTranslate1(child, newParent, ms = 800, callback = null) {
  child = toElem(child);
  newParent = toElem(newParent);
  const parentOriginal = child.parentNode;
  let children = arrChildren(parentOriginal);
  let iChild = children.indexOf(child);
  let sibling = iChild == children.length - 1 ? null : children[iChild + 1];
  const x0 = child.getBoundingClientRect().left;
  const y0 = child.getBoundingClientRect().top;
  newParent.appendChild(child);
  const x1 = child.getBoundingClientRect().left;
  const y1 = child.getBoundingClientRect().top;
  if (sibling) parentOriginal.insertBefore(child, sibling); else parentOriginal.appendChild(child);
  child.style.setProperty('--dx', (x1 - x0) + 'px');
  child.style.setProperty('--dy', (y1 - y0) + 'px');
  child.style.setProperty('--ms', `${ms}ms`);
  child.addEventListener('animationend', function () {
    newParent.appendChild(child);
    child.classList.remove('move');
    if (callback) callback();
  });
  child.classList.add('move');
}
function mTranslateBy(elem, x, y, ms = 800, callback = null) {
  mAnimate(elem, 'transform', [`translateX(${x}px) translateY(${y}px)`], callback, ms, 'ease');
}
function mTranslateByFade(elem, x, y, ms = 800, callback = null) {
  mAnimate(elem, 'transform', [`translateX(${x}px) translateY(${y}px)`], callback, ms, 'ease');
  let a = toElem(elem).animate([{ opacity: .25 }, { opacity: 1 },], { fill: 'both', duration: ms, easing: 'ease' });
}
function MUELL() {
  let [mean, stdev] = [0, 1];
  let f = x => gaussian_amp(x, mean, stdev);
  let y = f(0);
  console.log('y', y);
  let amp = .9 * (-canvas.miny) / (40 * y);
  f = x => gaussian_amp(x, mean, stdev, amp);
  canvas.draw_axes();
  canvas.plot(f, 'orange', 1);
  let x = 40 * search_end_point(f, 0, canvas.maxx, .1, .01);
  console.log('point x', x, canvas.minx, canvas.maxx);
  y = -40 * f(x / 40)
  console.log('point y', x, 0, canvas.maxy);
  console.log('scale', canvas.scale)
  let xreal = x / 40;
  let yreal = f(xreal) / (40);
  x = 0;
  for (let i = canvas.minx; i < canvas.maxx; i += canvas.scale) {
    let x1 = Math.round(convert_to_range(x, -4, 4, 50, 150));
    let x2 = Math.round(convert_to_range(-x, -4, 4, 50, 150));
    canvas.pp(x * 40, 0, 3, `${x1}`);
    canvas.pp(-x * 40, 0, 3, `${x2}`); x += 2;
  }
}
function muiCard(key, dParent, styles, classes) {
}
function multiCartesi() {
  let arr = Array.from(arguments);
  if (arr.length > 2) {
    return cartesi(arr[0], stripSet(multiCartesi(...arr.slice(1))));
  } else if (arr.length == 2) return cartesi(arr[0], arr[1]);
  else if (arr.length == 1) return arr[0];
  else return [];
}
function multiSplit(s, seplist) {
  let res = [s];
  for (const sep of seplist) {
    let resNew = [];
    for (const s1 of res) {
      let parts = s1.split(sep);
      resNew = resNew.concat(parts);
    }
    res = resNew;
  }
  return res.filter(x => !isEmpty(x));
}
function multiStyleAnimation(elist, ms, callback) {
  let els = elist.map(x => x[0]);
  let styles = elist.map(x => x[1]);
  els.map(x => x.style.transition = '' + ms + 'ms');
  for (let i = 0; i < els.length; i++) { mStyleX(els[i], styles[i]); }
  DA.TO = setTimeout(() => {
    els.map(x => x.style.transition = 'unset');
    if (isdef(callback)) callback();
  }, ms);
}
function mUnhigh(ui) { mClassRemove(ui, 'high'); }
function munhigh(d) { d = isString(d) ? mBy(d) : d; mStyle(d, { border: 'none' }); }
function mup(o, p, d) {
  p = { x: p.x, y: p.y - d };
  if (o) o.setPos(p.x, p.y);
  return p;
}
function mutate_colors(type, colors) {
  let items = C.items[type];
  let changed = false;
  let lastcolor = arrLast(colors);
  for (const item of items) {
    if (item.color == lastcolor) continue;
    changed = true;
    if (coin()) continue;
    let i = colors.indexOf(item.color) + 1;
    item.color = colors[i];
    if (type == 'branch') item.thickness -= 1.5;
  }
  return changed;
}
function mXit(elem, sz = 50) {
  if (nundef(sz)) sz = getRect(elem).h;
  let d = markerFail();
  mpOver(d, elem, sz / 2, 'red', 'openMojiTextBlack');
  mMoveBy(d, 0, -4);
  return d;
}
function my_poly_center(f) {
  let pts = points_from_feature(f);
  let c2 = get_polygon_centroid(pts);
  if (isNaN(c2.x) || isNaN(c2.y)) return null;
  center = [c2.y, c2.x];
  return center;
}
function mYaml(d, js) {
  d.innerHTML = '<pre>' + jsonToYaml(js) + '</pre>';
  return d;
}
function myFunction() {
  console.log('onresize!!!');
}
function myMinimax(node, depth, alpha, beta, maxDepth, maxim) {
  CCC += 1;
  if (depth >= maxDepth) return 1;
  let ec = F_END(node, depth); if (ec.reached) return ec.val;
  depth += 1;
  var move, result;
  var availableMoves = F_MOVES(node);
  let player = maxim ? MAXIMIZER : MINIMIZER;
  for (var i = 0; i < availableMoves.length; i++) {
    move = availableMoves[i];
    F_APPLYMOVE(node, move, player);
    result = myMinimax(node, depth, alpha, beta, maxDepth, !maxim);
    F_UNDOMOVE(node, move, player);
    if (maxim) {
      if (result > alpha) {
        alpha = result;
        if (depth == 1) SelectedMove = move;
      } else if (alpha >= beta) { return alpha; }
    } else {
      if (result < beta) {
        beta = result;
        if (depth == 1) SelectedMove = move;
      } else if (beta <= alpha) { return beta; }
    }
  }
  return maxim ? alpha : beta;
}
function myOnclickCodeInSidebar(ev) {
  let key = isString(ev) ? ev : ev.target.innerHTML;
  let text = CODE.justcode[key];
  AU.ta.value = text;
  let download = false;
  if (download) downloadAsText(text, 'hallo', 'js');
  return text;
}
function myPresent(dArea, items, options) {
  let showLabels = options.showLabels;
  let w = options.w * valf(options.fw, .9);
  let h = options.h * valf(options.fh, .7);
  let wi, hi, rows, cols;
  if (isdef(options.rows) || isdef(options.cols)) {
    [wi, hi, rows, cols] = calcSizeAbWo(items.length, options.rows, options.cols, w, h, options.wimax, options.himax);
  } else[wi, hi, rows, cols] = calcRowsColsSizeAbWo(items.length, w, h, showLabels, options.wimax, options.himax);
  let gap = wi * .1; if (cols > 1) wi -= gap; if (rows > 1) hi -= gap;
  let fzPic = options.fzPic = getStandardFzPic(wi, hi, showLabels);
  let fz = getStandardFz(wi, hi, options.showPic, options.showLabels, options.wLongest);
  options.szPic = { w: wi, h: hi };
  if (nundef(options.ifs)) options.ifs = {};
  let outerStyles = {
    w: showLabels ? wi : 'auto', h: hi, rounding: 6,
    bg: valf(options.ifs.bg, 'random'), fg: 'contrast', display: 'inline-flex', 'flex-direction': 'column',
    'justify-content': 'center', 'align-items': 'center', 'vertical-align': 'top',
  };
  let picStyles = { fz: fzPic };
  let labelStyles = { fz: fz };
  for (const item of items) {
    for (const k in options.ifs) if (isdef(item[k])) outerStyles[k] = item[k];
    if (isdef(item.textShadowColor)) {
      let sShade = '0 0 0 ' + item.textShadowColor;
      if (options.showPic) {
        picStyles['text-shadow'] = sShade;
        picStyles.fg = colorFrom('black', options.contrast); //'#00000080' '#00000030' 
      } else {
        labelStyles['text-shadow'] = sShade;
        labelStyles.fg = colorFrom('black', options.contrast); //'#00000080' '#00000030' 
      }
    }
    let dOuter = mCreate('div', outerStyles, item.id);
    dOuter.onclick = options.handler;
    picStyles.family = item.info.family;
    let dLabel, dPic;
    if (options.showPic) { dPic = mDiv(dOuter, picStyles); dPic.innerHTML = item.info.text; }
    if (showLabels) dLabel = mText(item.label, dOuter, labelStyles);
    if (options.showRepeat) addRepeatInfo(dOuter, item.iRepeat, wi);
    iAdd(item, { options: options, div: dOuter, dLabel: dLabel, dPic: dPic });
  }
  mStyleX(dArea, { display: 'inline-grid', gap: gap, 'grid-template-columns': `repeat(${cols},${wi}px)` });
  items.map(x => mAppend(dArea, iDiv(x)));
  return getRect(dArea);
}
function mySearch(kws) {
  console.log(`'${kws}'`); return;
  let arr = CODE.codelist; 
  let patt = isList(kws) ? kws.join('|') : replaceAll(kws, ' ', '|');
  let regex = new RegExp(`\\b${patt}\\b`);
  console.log('patt',patt)
  let res = arr.filter(x => regex.test(x.value)); 
  let keys = res.map(x => x.key);
  console.log('keys', keys);
  show_sidebar(keys, myOnclickCodeInSidebar);
  return;
  let di = CODE.justcode;
  let dilist = dict2list(di, 'key');
  let records = dilist.filter(x => words.some(w => x.key.match(new RegExp(`\\${w}\\b`, 'i'))));
  console.log('records', records)
  show_sidebar(records.map(x => x.key), myOnclickCodeInSidebar);
  return records;
}
function myShowLabels(onClickPictureHandler, ifs = {}, options = {}, keys, labels) {
  options.wimax = 200; options.himax = 50;
  options.w = window.innerWidth - 180; options.h = 50; options.fz = 22;
  options.showPic = false; options.showLabels = true;
  return showPictures(dTable, onClickPictureHandler, ifs, options, keys, labels);
}
function myShowPics(handler, ifs = {}, options = {}, keys, labels) {
  options.showPic = true;
  options.wimax = options.himax = 200;
  options.w = window.innerWidth - 180; options.h = window.innerHeight - 220;
  Pictures = showPictures(dTable, handler, ifs, options, keys, labels);
}
function mZone(dParent, styles, pos) {
  let d = mDiv(dParent);
  if (isdef(styles)) mStyleX(d, styles);
  if (isdef(pos)) {
    mIfNotRelative(dParent);
    mPos(d, pos.x, pos.y);
  }
  return d;
}
function name2id(name) { return 'd_' + name.split(' ').join('_'); }
function ncdf(x, mean = 100, std = 15) {
  var x = (x - mean) / std
  var t = 1 / (1 + .2315419 * Math.abs(x))
  var d = .3989423 * Math.exp(-x * x / 2)
  var prob = d * t * (.3193815 + t * (-.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))))
  if (x > 0) prob = 1 - prob
  return prob
}
function neighborhood(items, byrc) {
  let adjList = [];
  let di = {};
  for (const info of items) {
    if (info.type != 'field') continue;
    let [r, c] = [info.row, info.col];
    info.nodeItems = [
      lookup(byrc, [r - 2, c]),
      lookup(byrc, [r - 1, c + 1]),
      lookup(byrc, [r + 1, c + 1]),
      lookup(byrc, [r + 2, c]),
      lookup(byrc, [r + 1, c - 1]),
      lookup(byrc, [r - 1, c - 1]),
    ];
    info.nodes = info.nodeItems.map(x => isdef(x) ? x.id : null);
    delete info.nodeItems;
    for (let i = 0; i < 6; i++) {
      let n1 = info.nodes[i];
      if (n1 == null) continue;
      let n2 = info.nodes[(i + 1 % 6)];
      if (n2 == null) continue;
      if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
      lookupSet(di, [n1, n2], true);
      adjList.push([n1, n2]);
    }
    info.neiItems = [
      lookup(byrc, [r - 3, c + 1]),
      lookup(byrc, [r, c + 2]),
      lookup(byrc, [r + 3, c + 1]),
      lookup(byrc, [r + 3, c - 1]),
      lookup(byrc, [r, c - 2]),
      lookup(byrc, [r - 3, c - 1]),
    ];
    info.nei = info.neiItems.map(x => isdef(x) ? x.id : null);
    delete info.neiItems;
  }
}
function neighborhood1(items, byrc) {
  let adjList = [];
  let di = {};
  for (const info of items) {
    let [r, c] = [info.row, info.col];
    info.nodes = [
      lookup(byrc, [r - 2, c]),
      lookup(byrc, [r - 1, c + 1]),
      lookup(byrc, [r + 1, c + 1]),
      lookup(byrc, [r + 2, c]),
      lookup(byrc, [r + 1, c - 1]),
      lookup(byrc, [r + 1, c - 1]),
    ];
    for (let i = 0; i < 6; i++) {
      let n1 = info.nodes[i];
      if (n1 == null) continue;
      let n2 = info.nodes[(i + 1 % 6)];
      if (n2 == null) continue;
      if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
      lookupSet(di, [n1, n2], true);
      adjList.push([n1, n2]);
    }
    info.neighbors = [
      lookup(byrc, [r - 3, c + 1]),
      lookup(byrc, [r, c + 2]),
      lookup(byrc, [r + 3, c + 1]),
      lookup(byrc, [r + 3, c - 1]),
      lookup(byrc, [r, c - 2]),
      lookup(byrc, [r - 3, c - 1]),
    ];
  }
}
function neighborhood2(items, byrc) {
  let adjList = [];
  let di = {};
  for (const info of items) {
    let [r, c] = [info.row, info.col];
    info.nodeItems = [
      lookup(byrc, [r - 2, c]),
      lookup(byrc, [r - 1, c + 1]),
      lookup(byrc, [r + 1, c + 1]),
      lookup(byrc, [r + 2, c]),
      lookup(byrc, [r + 1, c - 1]),
      lookup(byrc, [r + 1, c - 1]),
    ];
    info.nodes = info.nodeItems.map(x => x ? x.id : null);
    delete info.nodeItems;
    for (let i = 0; i < 6; i++) {
      let n1 = info.nodes[i];
      if (n1 == null) continue;
      let n2 = info.nodes[(i + 1 % 6)];
      if (n2 == null) continue;
      if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
      lookupSet(di, [n1, n2], true);
      adjList.push([n1, n2]);
    }
    info.neighbors = [
      lookup(byrc, [r - 3, c + 1]),
      lookup(byrc, [r, c + 2]),
      lookup(byrc, [r + 3, c + 1]),
      lookup(byrc, [r + 3, c - 1]),
      lookup(byrc, [r, c - 2]),
      lookup(byrc, [r - 3, c - 1]),
    ];
  }
}
function nerd_custom_function() {
  var core = nerdamer.getCore();
  var _ = core.PARSER;
  core.Math2.custom = function (a, b) {
    return (2 * a + b) / a;
  };
  _.functions.custom = [, 2];
  var x = nerdamer('custom(2, 6)').evaluate();
  console.log(x.toString());
  var y = nerdamer('custom(a, b)').evaluate();
  console.log(y.toString());
}
function netHandSize(nmax, hCard, wCard, ovPercent = 20, splay = 'right') {
  let isHorizontal = splay == 'right' || splay == 'left';
  if (nundef(hCard)) hCard = 110;
  if (nundef(wCard)) wCard = Math.round(hCard * .7);
  return isHorizontal ? { w: wCard + (nmax - 1) * wCard * ovPercent / 100, h: hCard } : { w: wCard, h: hCard + (nmax - 1) * hCard * ovPercent / 100 };
}
function new_cards_animation(n = 2) {
  let [stage, A, fen, plorder, uplayer, deck] = [Z.stage, Z.A, Z.fen, Z.plorder, Z.uplayer, Z.deck];
  let pl = fen.players[uplayer];
  if (stage == 'card_selection' && !isEmpty(pl.newcards)) {
    let anim_elems = [];
    for (const key of pl.newcards) {
      let ui = lastCond(UI.players[uplayer].hand.items, x => x.key == key);
      if (nundef(ui)) { pl.newcards = []; return; }
      ui = iDiv(ui);
      anim_elems.push(ui);
    }
    delete pl.newcards;
    anim_elems.map(x => mPulse(x, n * 1000));
  }
}
function new_deal(fen) {
  let deck = fen.deck = create_fen_deck('n', fen.num_decks);
  shuffle(deck);
  for (const plname in fen.players) {
    let pl = fen.players[plname];
    let handsize = pl.handsize;
    pl.hand = deck_deal(deck, handsize);
  }
}
function newColors() {
  color_areas(25);
  renderVisualStructures(2);
}
function NewGame(fen) {
  if (nundef(fen)) fen = START_FEN;
  ParseFen(fen);
  PrintBoard();
  SetInitialBoardPieces();
  GameController.PlayerSide = brd_side;
  CheckAndSet();
  GameController.GameSaved = BOOL.FALSE;
  if (SideChar[brd_side] == 'b') {
    GameController.PlayerSide = brd_side ^ 1;
    PreSearch();
  }
}
function NewGameAjax() {
}
function newGameAjax() {
  console.log('new Game Ajax');
  $.ajax({
    url: "insertNewGame.php",
    cache: false
  }).done(function (html) {
    console.log('result:' + html);
  });
}
function newItemSelection(item, items, onSelectSelected = null) {
  console.log('===>', item, items)
  let selectedItem = firstCond(items, x => x.isSelected);
  if (selectedItem && selectedItem != item) toggleItemSelection(selectedItem);
  else if (onSelectSelected && selectedItem) { onSelectSelected(item); }
  toggleItemSelection(item);
}
function newtree() {
  tree = []; leaves = []; numlayers = 0;
}
function next_task(otree, r) {
  let i = otree.itask += 1;
  let n_todo = otree.todo.length;
  if (i >= n_todo) {
    move_todo_to_history(otree);
    start_new_todo_list(otree, r);
  }
}
async function nextTestOfSeries(downloadRequested = true) {
  if (isLastTestOfSeries()) { console.log('...press reset!'); return; }
  await onClickClearTable();
  let tests = ALLTESTS[iTESTSERIES];
  let solutions = ALLTESTSOLUTIONS[iTESTSERIES];
  let context = tests[iTEST];
  mBy('message').innerHTML = '(test) ' + iTESTSERIES + ' / ' + iTEST;
  await rParse('test', context);
  let uiNodeSizes = {};
  recCollectSizeInfo(R.uiNodes[R.tree.uid], R, uiNodeSizes);
  if (isdef(solutions) && isdef(solutions[iTEST])) {
    let changes = propDiffSimple(uiNodeSizes, solutions[iTEST]);
    if (changes.hasChanged) {
      console.log('FAIL!!! ', iTESTSERIES + '.' + iTEST, 'changes: ', changes);
    } else {
      console.log('verifying test case', iTESTSERIES + '.' + iTEST, 'correct!');
    }
  } else {
  }
  let testDict = ALLTESTSOLUTIONS[iTESTSERIES];
  if (nundef(ALLTESTSOLUTIONS[iTESTSERIES])) { testDict = ALLTESTSOLUTIONS[iTESTSERIES] = {}; }
  testDict[iTEST] = uiNodeSizes;
  iTEST += 1;
  if (isLastTestOfSeries() && !IS_START && downloadRequested) {
    if (isdef(testDict)) downloadFile(testDict, 'testDict');
    console.log('...press reset!');
  } else if (IS_START) {
    IS_START = false;
  }
}
function niceColor(rgb) {
  let hsl = rgb2hsl(rgb);
  hsl[0] = (hsl[0] + 0.5) % 1;
  hsl[1] = (hsl[1] + 0.5) % 1;
  hsl[2] = (hsl[2] + 0.5) % 1;
  return 'hsl(' + hsl[0] * 360 + ',' + hsl[1] * 100 + '%,' + hsl[2] * 100 + '%)';
}
function noc0_randomwalkers() {
  let [c1, c2] = [G.items[0], G.items[1]];
  c1.add({ update: move_random, w: 2, h: 2 });
  c2.add({ label: 'tom', draw: draw_label, update: move_random });
  c2.add(new CItemWalker('tim'));
}
function noc1_randomwalkers() {
  let [c1, c2] = [G.items[0], G.items[1]];
  let probs = [{ val: { x: -1, y: 0 }, p: 1 }, { val: { x: 1, y: 0 }, p: 2 }, { val: { x: 0, y: -1 }, p: 3 }, { val: { x: 0, y: 1 }, p: 3 }];
  c1.add({ probs: probs, update: move_probs, w: 2, h: 2 });
  c2.add({ label: 'tom', draw: draw_label, update: move_random });
}
function noc2_explicit_distribution() {
  let [c1, c2] = [G.items[0], G.items[1]];
  const sampler = new WeightedSampler([{ x: 1 }, { x: -1 }, { y: 1 }, { y: -1 }], [1, 2, 1, 2]);
  let randomArray = Array.apply(null, Array(100000)).map(() => sampler.get());
  let randomArray2 = Array.apply(null, Array(100000)).map(() => sampler.get());
  console.log(randomArray);
}
function noc3_gaussian() {
  let canvas = arrLast(G.items);
  let [mean, stdev] = [0, 1]
  let f = x => gaussian1(x, mean, stdev);
  let y = f(0);
  console.log('y', y);
  let amp = .9 * (-canvas.miny) / (40 * y);
  f = x => gaussian1(x, mean, stdev, amp);
  canvas.draw_axes();
  canvas.plot(f, 'orange', 1);
  let x = 40 * search_end_point(f, 0, canvas.maxx, .1, .01);
  console.log('point x', x, canvas.minx, canvas.maxx);
  y = -40 * f(x / 40)
  console.log('point y', x, 0, canvas.maxy);
  console.log('scale', canvas.scale)
  let xreal = x / 40;
  let yreal = f(xreal) / (40);
  x = 0;
  for (let i = canvas.minx; i < canvas.maxx; i += canvas.scale) {
    let x1 = Math.round(convert_to_range(x, -4, 4, 50, 150));
    let x2 = Math.round(convert_to_range(-x, -4, 4, 50, 150));
    canvas.pp(x * 40, 0, `${x1}`);
    canvas.pp(-x * 40, 0, `${x2}`); x += 2;
  }
}
function noc4_gaussian() {
  let canvas = arrLast(G.items);
  draw_gaussian(canvas, 100, 15, 'lime', 1, 'silver', 'IQ');
  return;
  canvas.draw_axes();
  canvas.scale = 40; console.log('canvas', canvas)
  let f = gaussian_amp(canvas, 1)
  canvas.plot(f, 'orange', 1);
  draw_ticks_gaussian(canvas, f, 100, 15, 'silver');
}
function noc5_draw_text() {
  let canvas = arrLast(G.items);
  let d = mInsert(dTable, mCreate('div'));
  mText('hallo', d, { fz: 40, family: 'algerian' });
  draw_text(canvas, 'hallo', { family: 'algerian', fg: 'white', pos: 'tr' });
}
function noc6_simple_gaussian() {
  let canvas = arrFirst(G.items);
  simple_gaussian(canvas);
}
function normalcdf(x, mean, stdev) {
  x = (x - mean) / stdev;
  var a1 = 1 / (1 + .2316419 * Math.abs(x));
  var a2 = .3989423 * Math.exp(-x * x / 2);
  var p = a2 * a1 * (.3193815 + a1 * (-.3565638 + a1 * (1.781478 + a1 * (-1.821256 + a1 * 1.330274))));
  if (x > 0) {
    p = 1 - p
  }
  return p;
}
function normalDistribution(mu, sigma) {
  this.mu = eval(mu);
  this.sigma = eval(sigma);
  this.mean = mean;
  this.variance = variance;
  this.sd = sd;
  this.pdf = pdf;
  this.cdf = cdf;
  this.percentile = percentile;
  this.printMoments = printMoments;
  this.printPdf = printPdf;
  function mean() {
    return jStat.normal.mean(this.mu, this.sigma);
  }
  function variance() {
    return jStat.normal.variance(this.mu, this.sigma);
  }
  function sd() {
    return Math.sqrt(this.variance());
  }
  function pdf(x) {
    if (!isNaN(eval(x))) {
      return jStat.normal.pdf(x, this.mu, this.sigma);
    }
    return '';
  }
  function cdf(x) {
    if (!isNaN(eval(x))) {
      return jStat.normal.cdf(x, this.mu, this.sigma);
    }
    return '';
  }
  function percentile(p) {
    if (!isNaN(eval(p))) {
      return jStat.normal.inv(p, this.mu, this.sigma);
    }
    return '';
  }
  function printMoments() {
    var txt = "";
    txt += '$ \\mu = E(X) = ' + roundNumber(this.mean(), 3) + '\\hspace{0.5cm}$';
    txt += '$ \\sigma = SD(X) = ' + roundNumber(this.sd(), 3) + '\\hspace{0.5cm}$';
    txt += '$ \\sigma^2 = Var(X) = ' + roundNumber(this.variance(), 3) + '$';
    document.getElementById("moments").innerHTML = txt;
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, "moments"]);
  }
  function printPdf(x, direction) {
    var data = new google.visualization.DataTable();
    data.addColumn('number', 'x');
    data.addColumn('number', 'f(x)');
    data.addColumn('number', 'f(x)');
    data.addColumn('number', 'f(x)');
    x = eval(x);
    var lo = this.mean() - 4 * this.sd();
    var hi = this.mean() + 4 * this.sd();
    data.addRows(401);
    var i, grd;
    for (i = 0; i < 401; i++) {
      grd = lo + (hi - lo) * i / 400;
      data.setCell(i, 0, grd);
      data.setCell(i, 1, this.pdf(grd));
      if (!isNaN(x)) {
        if (grd < x) {
          if (direction == 'less')
            data.setCell(i, 2, this.pdf(grd));
        }
        else {
          if (direction == 'greater')
            data.setCell(i, 2, this.pdf(grd));
        }
        if (direction == 'twotail') {
          if (grd < -Math.abs(x)) data.setCell(i, 2, this.pdf(grd));
          if (grd > Math.abs(x)) data.setCell(i, 2, this.pdf(grd));
        }
        if (direction == 'twotailinside') {
          if (grd > -Math.abs(x) && grd < Math.abs(x)) data.setCell(i, 2, this.pdf(grd));
        }
        var xdelta = (hi - lo) / 140;
        if (direction == 'less' || direction == 'greater') {
          if (grd > x - xdelta && grd < x + xdelta) {
            data.setCell(i, 3, this.pdf(grd));
          }
        }
        if (direction == 'twotail') {
          if (grd > -Math.abs(x) - xdelta && grd < -Math.abs(x) + xdelta)
            data.setCell(i, 3, this.pdf(grd));
          if (grd > Math.abs(x) - xdelta && grd < Math.abs(x) + xdelta)
            data.setCell(i, 3, this.pdf(grd));
        }
        if (direction == 'twotailinside') {
          if (grd > -Math.abs(x) - xdelta && grd < -Math.abs(x) + xdelta)
            data.setCell(i, 3, this.pdf(grd));
          if (grd > Math.abs(x) - xdelta && grd < Math.abs(x) + xdelta)
            data.setCell(i, 3, this.pdf(grd));
        }
      }
    }
    var options = {
      backgroundColor: 'transparent',
      areaOpacity: 0,
      hAxis: {
        title: 'x', titleTextStyle: { color: '#000000' },
        min: lo,
        max: hi,
        gridlines: { color: 'transparent', count: 7 },
        baseline: lo
      },
      vAxis: {
        title: 'f(x)', titleTextStyle: { color: '#000000' },
        gridlines: { count: 5, color: 'transparent' },
        viewWindow: { min: 0 },
        viewWindowMode: 'explicit'
      },
      legend: { position: 'none' },
      series: {
        0: { color: 'black', areaOpacity: 0, lineWidth: 1.2 },
        1: { color: '#e7b0b0', areaOpacity: 1, lineWidth: 0 },
        2: { color: '#83aaf1', areaOpacity: 1, lineWidth: 0 },
        3: { color: '#E8E8E8', areaOpacity: 1, lineWidth: 0 }
      },
      tooltip: { trigger: 'none' }
    };
    var chart = new google.visualization.AreaChart(document.getElementById('pdfPlot'));
    chart.draw(data, options);
  }
}
function normalize(text, language) {
  text = text.toLowerCase();
  if (language == 'D') {
    text = convertUmlaute(text);
  }
  return text;
}
function normalize_bid(bid) {
  let need_to_sort = bid[0] == '_' && bid[2] != '_'
    || bid[2] != '_' && bid[2] > bid[0]
    || bid[2] == bid[0] && is_higher_ranked_name(bid[3], bid[1]);
  if (need_to_sort) {
    let [h0, h1] = [bid[0], bid[1]];
    [bid[0], bid[1]] = [bid[2], bid[3]];
    [bid[2], bid[3]] = [h0, h1];
  }
  return bid;
}
function normalize_string(s, sep = '_') {
  s = s.toLowerCase().trim();
  let res = '';
  for (let i = 0; i < s.length; i++) { if (isAlphaNum(s[i])) res += s[i]; else if (s[i] == ' ') res += sep; }
  return res;
}
function normalizeDict(t) {
  let tNew = {};
  let keys = Object.keys(t);
  let minKey = Math.min(...keys.map(x => firstNumber(x)));
  for (const k in t) {
    tNew['_' + (firstNumber(k) - minKey)] = jsCopy(t[k]);
  }
  return { num: minKey, result: sortKeys(tNew) };
}
function normalizeNode(o, num) {
  if (isdef(o.uid)) normalizeSimpleUidProp(o, 'uid', num);
  if (isdef(o.children)) { o.children = o.children.map(x => normalizeVal(x, num)); }
  if (isdef(o.uidParent)) normalizeSimpleUidProp(o, 'uidParent', num);
  if (isdef(o._NODE)) normalizeSpecKeyProp(o, '_NODE', num);
  if (isdef(o.here)) normalizeSpecKeyProp(o, 'here', num);
}
function normalizeRTree(R) { return normalizeTree(R.rNodes, R); }
function normalizeSimpleUidProp(o, prop, num) {
  o[prop] = normalizeVal(o[prop], num);
}
function normalizeSpec(sp) {
  let spNew = {};
  for (const k in sp) {
    spNew[k] = recNormalize(sp[k], sp);
  }
  return spNew;
}
function normalizeSpecKeyProp(o, prop, num) {
  let node1 = o[prop];
  if (isString(node1) && node1.includes('_')) {
    o[prop] = correctNumbersInString(node1, num);
  } else if (isList(node1)) {
    let newlist = [];
    for (const el of node1) {
      if (el.includes('_')) {
        newlist.push(correctNumbersInString(el, num));
      }
    }
    console.log('SOLLTE NIEEEEEEEEEEEEEEEEEEE VORKOMMEN!!!!!!');
    o[prop] = newlist;
  }
}
function normalizeToList(n, prop) {
  let val = n[prop];
  if (isdef(val) && !isList(val)) n[prop] = [val];
}
function normalizeTree(t, r) {
  let tNew = jsCopy(t);
  let first = r.tree.uid;
  let num = firstNumber(first);
  safeRecurse(tNew, normalizeNode, num, false);
  let newRTree = {};
  for (const k in tNew) {
    let kNew = normalizeVal(k, num);
    newRTree[kNew] = tNew[k];
  }
  tNew = newRTree;
  return sortKeys(tNew);
}
function normalizeVal(val, num) {
  let nval = firstNumber(val);
  nval -= num;
  return '_' + nval;
}
function notImplemented(msg = '!') {
  let fname = getFunctionsNameThatCalledThisFunction();
  console.log('NOT IMPLEMENTED:', fname, msg);
}
function notMyTurn() {
  enableButton('c_b_PollStatus');
}
function nRandomNumbers(n, from, to, step) {
  let arr = range(from, to, step);
  return choose(arr, n);
}
function Number(div, board, n) {
  var self = this;
  this.div = div;
  this.board = board;
  this.n = n;
}
function numberSequenceCorrectionAnimation(stringFunc) {
  let wrong = getWrongWords();
  if (nundef(TOList)) TOList = {};
  let msg = stringFunc();
  showFleetingMessage(msg, 0, { fz: 32 });
  Selected.feedbackUI = wrong.map(x => iDiv(x));
  failPictureGoal();
  let t1 = setTimeout(removeMarkers, 1000);
  let t2 = setTimeout(() => wrong.map(x => { correctWordInput(x); animate(iDiv(x), 'komisch', 1300); }), 1000);
  t4 = setTimeout(() => { if (G.spokenFeedback) sayRandomVoice(msg); }, 500);
  TOList.numseq = [t1, t2, t4];
  return 2800;
}
function nundef(x) { return x === null || x === undefined; }
function o_tableDiv_bounds(divParent, o) {
  let html = treee(o);
  let dNew = document.createElement('div');
  dNew.style.float = 'left';
  dNew.innerHTML = html;
  let table = dNew.firstChild;
  divParent.appendChild(dNew);
  return [dNew, table, dNew.offsetWidth, dNew.offsetHeight];
}
function o2yaml(o) { return '<pre>' + jsonToYaml(o) + '</pre>'; }
function o2yamlHtml(el, o) {
  el.innerHTML = '<pre>' + jsonToYaml(o) + '</pre>';
}
function object2string(o, props = [], except_props = []) {
  let s = '';
  if (nundef(o)) return s;
  if (isString(o)) return o;
  let keys = Object.keys(o).sort();
  for (const k of keys) {
    if (!isEmpty(props) && props.includes(k) || !except_props.includes(k)) {
      let val = isList(o[k]) ? o[k].join(',') : isDict(o[k]) ? object2string(o[k].props, except_props) : o[k];
      let key_part = isEmpty(s) ? '' : `, ${k}:`;
      s += val;
    }
  }
  return s;
}
function odict2olist(d, keyName = 'id') {
  let res = [];
  for (const key in d) {
    let o = jsCopy(d[key]);
    o[keyName] = key;
    res.push(o);
  }
  return res;
}
function old_ensure_buttons_visible_ferro() {
  if (isdef(mBy('dbPlayer'))) return;
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  if (fen.players[uplayer].hand.length <= 1) return;
  let d = iDiv(UI.players[uplayer]);
  mStyle(d, { position: 'relative' })
  let dbPlayer = mDiv(d, { position: 'absolute', bottom: 2, left: 100, height: 25 }, 'dbPlayer');
  let styles = { rounding: 6, bg: 'silver', fg: 'black', border: 0, maleft: 10 };
  let bByRank = mButton('by rank', onclick_by_rank_ferro, dbPlayer, styles, 'enabled');
  let bBySuit = mButton('by suit', onclick_by_suit_ferro, dbPlayer, styles, 'enabled');
  if (Z.game == 'ferro') {
    let b = mButton('clear selection', onclick_clear_selection_ferro, dbPlayer, styles, 'enabled', 'bClearSelection');
    if (isEmpty(A.selected)) hide(b);
  }
}
function old_mButtonX(dParent, pos = 'tr', handler = null, defaultBehavior = 'hide', sz = 40) {
  dParent = toElem(dParent);
  let styles = { cursor: 'pointer', w: sz, h: sz };
  let d2 = mDiv(dParent, styles, null, `<svg width='100%' height='100%' ><use xlink:href="#Times" /></svg>`);
  mClass(d2, 'svgbtnX');
  d2.onclick = isdef(handler) ? handler : defaultBehavior == 'hide' ? () => hide(dParent) : () => dParent.remove();
  mPlace(d2, pos, 10);
  return d2;
}
function old_show_settings(dParent) {
  let [options, fen, uplayer] = [Z.options, Z.fen, Z.uplayer];
  clearElement(dParent);
  mFlex(dParent);
  let playermode = get_playmode(uplayer);
  let game_mode = Z.mode;
  let dplaymode = mDiv(dParent, { fg: 'blue' }, null, playermode);
  let dgamemode = mDiv(dParent, { fg: 'red' }, null, Z.mode);
  let d = miPic('gear', dParent, { fz: 20, padding: 6, h: 40, box: true, matop: 2, rounding: '50%', cursor: 'pointer' });
  options.playermode = playermode;
  d.onmouseenter = () => show_options_popup(options);
  d.onmouseleave = hide_options_popup;
}
function old_stage_moves() {
  for (const a of arguments) {
    let [uname, x, cardname] = a.split('.');
    DA.chain.push(() => {
      let g = Session;
      let state = { selected: {} };
      state.selected[uname] = [a];
      let o = { uname: uname, tid: g.table.id, state: state, player_status: 'joined' };
      to_server(o, 'turn_send_move');
    })
  }
}
function on_poll_bot_send_move(obj) {
  console.log('game is over for AI', DA.poll.data.uname);
  clearTimeout(BotTicker);
  delete DA.poll;
}
function on_poll_table_seen(obj) {
  delete DA.poll;
  update_session(obj);
  if (is_game_host()) {
    let txt = jsyaml.dump(DB);
    DA.next = get_games;
    let fen = get_score_fen_from_cur_players();
    to_server({ tid: Session.cur_tid, fen: fen, uname: Session.cur_user, db: txt }, 'save_and_delete');
  } else {
    show_user_intro_screen(true);
  }
}
function on_poll_table_show(obj) {
  delete DA.poll;
  status_message_off();
  present_table(obj);
}
function on_poll_table_started(obj) {
  let t = obj.tables[0];
  update_db_user_from_pl_options(t.pl_options, t.game);
  Session.cur_tid = t.id;
  Session.cur_game = t.game;
  delete DA.poll;
  status_message_off();
  hide('divTest');
  close_sidebar();
  mBy('user_info_mini').style.display = 'flex';
  Session.scoring_complete = false;
  get_play();
}
function on_ticker_status(obj) {
  console.log('status:', TCount);
  if (in_game_open_prompt()) {
    update_session(obj);
    update_game_status(Session.cur_players);
    TOTicker = setTimeout(send_timer_ticker, 3000);
  }
}
function onAvailableGames(d) {
  prelude(getFunctionCallerName(), d);
  if (isError(d)) { restartHost(onHostStarted); return; }
  d = d.response;
}
function onAvailablePlayers(d) {
  prelude(getFunctionCallerName(), d);
  if (isError(d)) { restartHost(onHostStarted); return; }
  d = d.response;
  S.availablePlayers = d;
  console.log('availablePlayers', S.availablePlayers);
  S.playersTaken = {};
  let i = 0;
  for (const plid of S.gameInfo.player_names) {
    console.log(plid)
    if (S.availablePlayers.includes(plid)) {
      console.log('it includes', plid);
      break;
    }
    if (isdef(S.plAddedByMe) && plid in S.plAddedByMe) {
      i += 1;
      continue;
    }
    console.log('still here!!!')
    S.playersTaken[plid] = { username: '?', index: i, id: plid };
    pageHeaderAddPlayer('?', plid, inferPlayerColorFromNameOrInit(plid, i));
    i += 1;
  }
  console.log(S.playersTaken);
  if (!empty(S.availablePlayers)) addUserAsFirstAvailablePlayer();
  else restartHost(onHostStarted);
}
function onBeginRequest(d) {
  prelude(getFunctionCallerName(), d);
  if (isError(d)) { enterWaitingLoop(); return; }
  d = d.response;
  if (S.settings.useSpec) loadUserSpec([loadUserCode, sendInit]); else sendInit();
}
function onChatReceived(d) { if (!USE_SOCKETIO) return; addChat(d); }
function onChatSubmitted(e) { if (!USE_SOCKETIO) return; e.preventDefault(); socketEmitChat(); }
function onclick_account() { if (!menu_enabled('account')) return; stop_game(); get_account(); }
function onclick_ack() {
  if (nundef(Z) || nundef(Z.func.clear_ack)) return;
  Z.func.clear_ack();
}
function onclick_add_question() { show_question_editor(); }
function onclick_animate() { interval_id = setInterval(onclick_layer, 500); }
function onClick_belinda() { window.location = '../belinda/index.php'; }
function onclick_bigredloginbutton() { boalogin_start(); }
function onclick_bill() {
  let dParent = mBy('dBoaMain');
  if (dParent.children.length > 1) dParent.lastChild.remove();
  let acclist = get_fake_boa_data_list().filter(x => isdef(x['Last Payment']));
  let boacc = rChoose(acclist);
  let item = generate_statement(dParent, boacc, boacc.brand);
  DA.bill = item;
  lookupAddIfToList(DA, ['challengedata'], item);
}
function onclick_boa_cancel() { onclick_location('home'); }
function onclick_boa_sendcode() {
  let list1 = get_checked_radios(mBy('dPhoneContact'));
  let list2 = get_checked_radios(mBy('dTextOrPhone'))
  console.log(list1, list2);
  let success_phone = list1.length == 1 && list1[0] == 'text_3';
  let success_textOrPhone = list2.length == 1 && list2[0] == 'text_1';
  let TESTSKIP = false;
  console.log('TESTSKIP', TESTSKIP);
  if (!TESTSKIP) {
    if (!success_phone) { alert("Please select the phone number ending in '0297'!"); return; }
    if (!success_textOrPhone) { alert("Please select the option 'Text message'!"); return; }
  }
  boahavecode_start();
}
function onclick_boa_submit_code() {
  let list1 = get_input_value('inpAuthocode');
  let success_code = list1 == S.boa_authorization_code;
  if (!success_code) {
    show_eval_message(false);
    return;
  }
  boamain_start();
}
function onClick_books() { closeLeftPane(); }
function onclick_bw_symbol(app, key) {
  if (nundef(key)) key = S.current_label;
  let s = lookup(DIBOA, ['bw_info', app, key]);
  if (s && isdef(S.current_input)) {
    S.current_input.value = s;
  } else {
    console.log('no bw_info for', app, key);
  }
}
function onclick_by_rank() {
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  let items = ui_get_hand_items(uplayer).map(x => x.o);
  let h = UI.players[uplayer].hand;
  pl.handsorting = 'rank';
  Clientdata.handsorting = pl.handsorting;
  localStorage.setItem('handsorting', Clientdata.handsorting);
  let cardcont = h.cardcontainer;
  let ch = arrChildren(cardcont);
  ch.map(x => x.remove());
  let sorted = sortCardItemsByRank(items, Z.func.rankstr); //window[Z.game.toUpperCase()].rankstr); //'23456789TJQKA*');
  h.sortedBy = 'rank';
  for (const item of sorted) {
    mAppend(cardcont, iDiv(item));
  }
}
function onclick_by_rank_ferro() {
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  let items = ui_get_hand_items(uplayer).map(x => x.o);
  let h = UI.players[uplayer].hand;
  pl.handsorting = { n: items.length, by: 'rank' };
  let cardcont = h.cardcontainer;
  let ch = arrChildren(cardcont);
  ch.map(x => x.remove());
  let sorted = sortCardItemsByRank(items, '23456789TJQKA*');
  h.sortedBy = 'rank';
  for (const item of sorted) {
    mAppend(cardcont, iDiv(item));
  }
}
function onclick_by_suit() {
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  let items = ui_get_hand_items(uplayer).map(x => x.o);
  let h = UI.players[uplayer].hand;
  Clientdata.handsorting = pl.handsorting = 'suit';
  localStorage.setItem('handsorting', Clientdata.handsorting);
  let cardcont = h.cardcontainer;
  let ch = arrChildren(cardcont);
  ch.map(x => x.remove());
  let sorted = sortCardItemsByRank(items, Z.func.rankstr); //'23456789TJQKA*');
  sorted = sortCardItemsBySuit(sorted);
  h.sortedBy = 'suit';
  for (const item of sorted) {
    mAppend(cardcont, iDiv(item));
  }
}
function onclick_by_suit_ferro() {
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  let items = ui_get_hand_items(uplayer).map(x => x.o);
  let h = UI.players[uplayer].hand;
  pl.handsorting = { n: items.length, by: 'suit' };
  let cardcont = h.cardcontainer;
  let ch = arrChildren(cardcont);
  ch.map(x => x.remove());
  let sorted = sortCardItemsByRank(items, '23456789TJQKA*');
  sorted = sortCardItemsBySuit(sorted);
  h.sortedBy = 'suit';
  for (const item of sorted) {
    mAppend(cardcont, iDiv(item));
  }
}
function onclick_cancelmenu() { hide('dMenu'); }
function onClick_cardgames() { closeLeftPane(); }
function onclick_chat() { if (!menu_enabled('chat')) return; game_interrupt(); get_chat(); }
function onclick_cities() {
  let layer = M.layers.city;
  let capitals = rChoose(M.capitals, 50);
  console.log('capitals', capitals);
  for (const c of M.capitals) {
    console.log('presenting', c)
    map_add_object(M.cities[c], { layer: layer });
  }
}
function onclick_clear_selection_ferro() { clear_selection(); }
function onclick_close_project_editor(ev) {
  console.log('click!!!')
  show_home();
}
function onclick_close_question_editor() {
  console.log('click!!!')
  show_home();
}
function onclick_color(prop) {
  return color => { let styles = {}; styles[prop] = color; mStyle(mBy('dAdmin'), styles); };
}
function onclick_compose() { show_project_editor(); }
function onclick_contacts() { if (!menu_enabled('contacts')) return; game_interrupt(); get_contacts(); }
function onclick_create_game_button() {
  console.assert(is_admin(), 'non admin is creating game!!!!!!!!!!!');
  collect_game_options();
  get_create_table();
}
function onclick_delete_table() { stop_game(); stop_polling(); delete_current_table(); }
function onclick_edit_players() {
  let ta = mBy('ta_edit_players');
  show(ta);
  let button = mBy('b_edit_players');
  button.innerHTML = 'submit';
  button.onclick = onclick_modify_def_players;
  ta.onkeyup = ev => {
    if (ev.key === "Enter") {
      ev.preventDefault();
      ev.cancelBubble = true;
      onclick_modify_def_players(ev);
    }
  };
  ta.focus();
}
async function onclick_file() {
  let res = await route_path_yaml_dict('http://localhost:3000/file?name=test');
  console.log('res', res, typeof (res));
}
function onclick_fork() { add_element(addfork); }
function onclick_game_in_games_menu(ev) {
  Session.cur_game = ev_to_gname(ev);
  set_cur_tid_for_game();
  if (nundef(Session.cur_tid) && is_admin()) { present_game_options(Session.cur_game); }
  else if (isdef(Session.cur_tid)) get_play();
}
function onclick_game_in_gametable(tablename) {
  if (DA.simple) { show_table_simple(tablename); return; }
  stopgame();
  let table = firstCond(Serverdata.tables, x => x.friendly == tablename);
  ensure_polling();
  phpPost({ friendly: tablename }, 'table');
}
function onclick_game_menu_item(ev) {
  let gamename = ev_to_gname(ev);
  stop_game();
  show_game_options_menu(gamename);
}
function onclick_gameover_new() {
  if (is_admin()) {
    let txt = jsyaml.dump(DB);
    DA.chain = [get_games];
    let end_scoring = get_scores_from_cur_players();
    to_server({ tid: Session.cur_tid, end_scoring: end_scoring, uname: Session.cur_user, db: txt }, 'save_and_delete');
  } else {
    present_non_admin_user(Session.cur_user);
  }
}
function onclick_gameover_screen() {
  let game = Session.cur_game;
  let winners = Session.winners;
  if (!Session.scoring_complete) {
    console.log('scoring...')
    decrease_handicap_if_winstreak(winners, game);
    increase_handicap_if_losestreak();
    Session.scoring_complete = true;
  }
  if (is_admin()) {
    let txt = jsyaml.dump(DB);
    DA.next = get_games;
    let fen = get_score_fen_from_cur_players();
    to_server({ tid: Session.cur_tid, fen: fen, uname: Session.cur_user, db: txt }, 'save_and_delete');
  } else {
    get_got_user_in_intro_screen();
    let t = Session.cur_table;
    let fen = t.status == 'past' ? t.fen : get_score_fen_from_cur_players();
    intro_create_score_table(fen, t.friendly);
  }
}
function onclick_games() { if (!menu_enabled('games')) return; stop_game(); get_games(); }
function onclick_header(ev) { if (!is_admin() && ev.path[0].id != 'header') return; open_sidebar(); close_mini_user_info(); }
function onclick_home() { window.location = SERVER; }
function onclick_inno_ut0() { onclick_ut(inno_ut0_create_staged); }
function onclick_inno_ut1() { onclick_ut(inno_ut1_create_staged); }
function onclick_inno_ut2() { onclick_ut(inno_ut2_create_staged); }
function onclick_internet() { toogle_internet_status(); }
function onclick_jittering() {
  jittering = !jittering;
  if (!jittering) {
    tree.map(x => x.repair());
    leaves.map(x => x.current = x.orig.copy());
  }
  show_jittering();
}
function onclick_join_as_player() {
  let [uname, fen, options, uplayer] = [Z.uname, Z.fen, Z.options, Z.uplayer];
  console.log('uname', uname, 'uplayer', uplayer);
  phpPost({ friendly: Z.friendly, uname: uname }, 'join');
}
function onclick_lamp() {
  DA.simple = !DA.simple;
  if (DA.simple) show_simple_ui(); else show_advanced_ui();
  if (isVisible('dTables')) onclick_tables();
}
function onclick_last_test() {
  stop_game();
  stop_polling();
  DA.test.iter = 0;
  DA.test.suiteRunning = false;
  onclick_ut_n('ari', DA.test.number);
}
function onclick_layer() { addlayer(); }
function onclick_leaf() { add_element(addleaf); }
function onclick_left_panel(ev) { if (ev.path[0].id != 'left_panel') return; close_sidebar(); open_mini_user_info(); }
function onclick_list() { show_code_list(DB.code); }
function onclick_location(k) {
  show_correct_location(k);
  if (k == 'boa') {
    console.log('boa_state', S.boa_state);
    if (S.boa_state == 'authorized') { boamain_start(); }
    else if (S.boa_state == 'authorization_pending') boahavecode_start();
    else { S.boa_state = 'start'; boa_start(); }
  } else if (k == 'skype') {
    skype_start();
  } else if (k == 'home') {
    let b = mBy('tbbill'); if (isdef(b)) b.remove();
    scrollToTop();
    S.boa_state = null;
    let dband = mBy('dBandMessage');
    if (isdef(dband)) mStyle(dband, { display: 'none', h: 0, hmin: 0 });
    DA.challenge = DA.name = null;
  }
}
function onclick_log_otree() { log_object(Session.otree, 'otree'); }
function onclick_log_R() { log_object(Session.R, 'R'); }
function onclick_log_R_nodes() { if (isdef(Session.R)) log_object(Session.R.nodes, 'R.nodes'); }
function onclick_log_R_oid2uids() { if (isdef(Session.R)) log_object(Session.R.oid2uids, 'R.oid2uids'); }
function onclick_log_R_path2oid() { if (isdef(Session.R)) log_object(Session.R.path2oid, 'R.path2oid'); }
function onclick_log_R_uid2oids() { if (isdef(Session.R)) log_object(Session.R.uid2oids, 'R.uid2oids'); }
function onclick_log_R_uiNodes() { if (isdef(Session.R)) log_object(Session.R.uiNodes, 'R.uiNodes'); }
function onclick_log_session() { log_object(Session, 'Session'); }
function onclick_login() { if (!menu_enabled('login')) return; stop_game(); get_login(); }
function onclick_login_new() { if (!menu_enabled('login')) return; game_interrupt(); get_login_new(); }
function onclick_logout() {
  mFadeClearShow('dAdminRight', 300);
  mClear('dAdminMiddle');
  stop_game();
  clear_screen();
  U = null;
  show_users();
}
function onclick_menu_item(name) { G_init(name); onclick_playpause(); }
function onclick_modify_def_players(ev) {
  let ta = mBy('ta_edit_players');
  let text = ta.value;
  let words = splitAtAnyOf(text, ', \n');
  let names = [];
  let levels = {};
  for (const w of words) {
    if (w.indexOf('(') < 0) { names.push(w); continue; }
    let name = stringBefore(w, '(');
    let level = firstNumber(w);
    levels[name] = level;
    names.push(name);
  }
  console.log('levels', levels, 'names', names);
  if (!isEmpty(get_keys(levels))) {
    for (const n in levels) {
      lookupSetOverride(DB.users, [n, 'games', Session.cur_game, 'startlevel'], levels[n]);
    }
    db_save();
  }
  let non_existent = names.filter(x => nundef(DB.users[x]));
  if (!isEmpty(non_existent)) {
    status_message('the following players will be discarded because they dont exist: ' + non_existent.join(', '));
    names = arrMinus(names, non_existent);
    if (names.length < 2) {
      let plname = chooseRandom(get_keys(DB.users), x => x != Session.cur_user);
      names.push(plname);
    }
  }
  let final_players = get_def_players_for_user(Session.cur_user, names);
  populate_players(final_players);
}
async function onclick_modify_save() {
}
function onclick_new() { show_code_editor(); }
function onclick_pause_continue() {
  let b = mBy('bPauseContinue');
  clearTimeout(TO.ai);
  onclick_stoppolling();
  show_status('game is paused', true);
  mStyle(b, { fg: 'grey' });
}
function onclick_play() {
  if (!menu_enabled('play')) return;
  stop_game();
  let tid = Session.cur_tid;
  if (isdef(tid)) get_play();
  else if (is_admin()) get_games();
  else present_non_admin_user();
}
function onclick_player_in_gametable(uname, tablename, rid) {
  stopgame();
  U = firstCond(Serverdata.users, x => x.name == uname);
  send_or_sim({ friendly: tablename, uname: U.name, }, 'table');
}
function onclick_plus(id, inc) {
  console.log('id', id);
  ensure_clientstate();
  Clientdata.state[id]++;
  console.log('sending Clientdata.state', Clientdata.state);
  let o = { friendly: 'feedback', uname: Clientdata.uid, state: jsCopy(Clientdata.state) };
  phpPost(o, 'update_player');
}
function onclick_plus_minus(color) { socket.emit('plus', color); }
async function onclick_poll() {
  if (Pollmode == 'manual') poll(true);
  else {
    console.log('STOP autopoll first!!!')
  }
}
function onclick_popup(k) {
  let o = DIBOA[k];
  if (nundef(o)) { console.log('missing popup item: ' + k); return; }
  if (k == 'bw') {
    if (!is_bw_loggedin()) {
      assertion(S.bw_state == 'loggedout' || S.bw_state == 'expired', "bw_state is corrupted!!!!", S.bw_state);
      if (S.bw_state == 'loggedout') { bw_login_popup(); } else { bw_set_new_password_popup(); }
    } else {
      bw_widget_popup();
    }
  } else { console.log('onclick_popup', k); }
}
function onclick_preinno_create() { Session.cur_game = 'gPreinno'; get_create_table({ level_setting: 'min' }, ['mimi', 'leo']); }
function onclick_random() {
  if (uiActivated && !DA.ai_is_moving) ai_move(300);
  else if (!uiActivated) console.log('NOP: ui not activated...');
  else if (DA.ai_is_moving) console.log('NOP: ai is (or was already) moving...');
  else console.log('NOP: unknown...');
}
function onclick_reload() {
  if (isdef(Z)) {
    if (Z.game == 'fritz' && nundef(Z.fen.winners)) {
      console.log(Z);
      Z.fen.players[Z.uplayer].time_left = stop_timer();
      take_turn_fen();
    } else {
      FORCE_REDRAW = true; send_or_sim({ friendly: Z.friendly, uname: Z.uplayer, auto: false }, 'table');
    }
  } else if (U) { onclick_tables(); }
  else { show_users(); }
}
function onclick_reload_after_switching() { DA.pollCounter = 0; DA.reloadColor = rColor(); onclick_reload(); }
function onclick_reload_state() {
  let g = Session;
  let tid = g.cur_tid;
  if (nundef(tid) && is_admin()) get_games();
  else if (nundef(tid)) get_intro();
  else if (is_admin()) { stop_game(); get_play(); }
  else {
    stop_game();
    Session.cur_tid = null;
    to_server({ uname: g.cur_user }, 'newest_table');
  }
}
function onclick_remove_host() {
  let [role, host, game, fen, uplayer, turn, stage] = [Z.role, Z.host, Z.game, Z.fen, Z.uplayer, Z.turn, Z.stage];
}
function onclick_reset_all() { stop_game(); phpPost({ app: 'simple' }, 'delete_tables'); }
function onclick_reset_db() { reset_db_values(); db_save(); }
function onclick_reset_past() { stopgame(); phpPost({ app: 'simple' }, 'delete_past'); }
function onclick_reset_progressbars() {
  DA.winit = 10;
  let oldfen = isdef(Z.fen) ? jsCopy(Z.fen) : { green: 0, red: 0 };
  let fen = { green: DA.winit, red: DA.winit };
  for (const k in DA.bars) {
    set_new_goal(k, DA.winit);
  }
  phpPost({ friendly: 'feedback', fen: fen }, 'reset');
}
function onclick_reset_tables() { stop_game(); stop_polling(); DA.chain = [get_games]; to_server({}, 'reset_tables'); }
function onclick_reset_user() { reset_game_values_for_user(Session.cur_user); db_save(); }
function onclick_restart() {
  let [game, fen, plorder, host] = [Z.game, Z.fen, Z.plorder, Z.host];
  Z.scoring = {};
  if (nundef(fen.original_players)) fen.original_players = fen.players;
  let playernames = [host].concat(get_keys(fen.original_players).filter(x => x != host));
  let playmodes = playernames.map(x => fen.original_players[x].playmode);
  let strategies = playernames.map(x => fen.original_players[x].strategy);
  let default_options = {}; for (const k in Config.games[game].options) default_options[k] = arrLast(Config.games[game].options[k].split(','));
  addKeys(default_options, Z.options);
  fen = Z.fen = Z.func.setup(playernames, Z.options);
  [Z.plorder, Z.stage, Z.turn, Z.round, Z.step, Z.phase] = [fen.plorder, fen.stage, fen.turn, 1, 1, fen.phase];
  if (DA.TESTSTART1) Z.turn = fen.turn = Z.host;
  let i = 0; playernames.map(x => { let pl = fen.players[x]; pl.name = x; pl.strategy = strategies[i]; pl.playmode = playmodes[i++]; });
  take_turn_fen_clear();
}
function onclick_restart_long() {
  let game = Z.game;
  let playernames = [Z.host].concat(Z.plorder.filter(x => x != Z.host));
  let playermodes = playernames.map(x => Z.fen.players[x].playmode);
  let i = 0; let players = playernames.map(x => ({ name: x, playmode: playermodes[i++] }));
  let options = Z.options;
  stopgame();
  startgame(game, players, options);
}
function onclick_restart_move() { clear_transaction(); onclick_reload(); }
function onclick_resume_game_button() {
  console.assert(is_admin(), 'non admin is creating game!!!!!!!!!!!');
  collect_game_options();
  get_modify_table();
}
function onclick_role(role) {
  mFade(mBy('dRoles'), 1000, null, 'linear');
  show_my_role(role);
}
function onclick_run_tests() {
  stop_game();
  stop_polling();
  shield_on();
  DA.test.iter = 0;
  DA.test.suiteRunning = true;
  if (nundef(DA.test.list)) {
    console.log('taking default DA.test.list');
    DA.test.list = [100, 101];
  }
  test_engine_run_next(DA.test.list);
}
async function onclick_save() {
  DB = await route_path_yaml_dict('http://localhost:3000/save');
  console.log('DB', DB);
}
function onclick_set_test() { Session.cur_game = 'gSet'; get_create_table({ level_setting: 'min', winning_score: 1 }, ['mimi', 'leo']); }
function onclick_settings() { if (Session.cur_menu != 'play') { alert('click on a game icon!'); return; } present_game_options(Session.cur_tid); }
function onclick_settings_test() {
  console.log('settings', settings);
  socket.emit('settings', { settings: settings });
}
function onclick_sim_inno_after_init_mimi_turn() {
  delete_current_table();
  Session.cur_game = 'gPreinno';
  test_sim_inno_after_init_mimi_turn();
  get_create_table({ level_setting: 'min' }, ['mimi', 'leo']);
}
function onclick_sim_inno_init_complete() {
  delete_current_table();
  Session.cur_game = 'gPreinno';
  test_sim_inno_init_complete();
  get_create_table({ level_setting: 'min' }, ['mimi', 'leo']);
}
function onclick_skip() {
  let [game, fen, uplayer, turn, stage] = [Z.game, Z.fen, Z.uplayer, Z.turn, Z.stage];
  if (game == 'spotit') return;
  else if (game == 'bluff' && stage == 1 || game == 'ferro' && stage == 'auto_ack') { onclick_ack(); }
  else if (game == 'aristo') {
    Z.uplayer = Z.turn[0];
    Z.A = { level: 0, di: {}, ll: [], items: [], selected: [], tree: null, breadcrumbs: [], sib: [], command: null };
    copyKeys(jsCopy(Z.fen), Z);
    copyKeys(UI, Z);
    activate_ui(Z);
    Z.func.activate_ui();
    ai_move();
  } else {
    let plskip = Z.turn[0];
    Z.turn = [get_next_player(Z, plskip)];
    Z.uplayer = plskip;
    take_turn_fen();
  }
}
function onclick_spotit1() { Session.cur_game = 'gSpotit'; get_create_table({ level_setting: 'min', winning_score: 1 }, ['mimi', 'leo']); }
function onclick_start_spotit() {
  let [game, fen, uplayer, turn, stage] = [Z.game, Z.fen, Z.uplayer, Z.turn, Z.stage];
  Z.stage = 'move';
  Z.turn = jsCopy(Z.plorder);
  take_turn_fen();
}
function onclick_startgame() {
  console.log('starting the game!');
}
function onclick_startpolling() {
  pollStop();
  Pollmode = 'auto';
  poll();
}
function onclick_status() { query_status(); }
function onclick_status_message(ev) {
  evNoBubble(ev); hide('dMessage');
  if (isdef(DA.after_status_message)) {
    let func = DA.after_status_message;
    DA.after_status_message = null;
    func();
  }
}
function onclick_step() {
  DA.test.step = true;
  DA.test.running = true;
  if (!isEmpty(DA.chain)) { dachainext(1000); return; }
  let testnumber = valf(mBy('intestnumber').value, 110);
  if (!isNumber(testnumber)) testnumber = 110;
  console.log('test for step is', testnumber);
  DA.test.number = testnumber;
  onclick_last_test();
}
function onclick_stop_polling() { stop_polling(); }
function onclick_stoppolling() {
  pollStop();
  Pollmode = 'manual';
}
function onclick_submit_boa_login() {
  let userid = get_boa_userid_input().value;
  let pwd = get_boa_pwd_input().value;
  let TESTSUCCESS = false;
  if (TESTSUCCESS || userid == DIBOA.bw_info.boa.userid && pwd == DIBOA.bw_info.boa.pwd) {
    boaverify_start();
  } else {
    console.log('FAIL!!!!!!! onclick_submit_boa_login', userid, pwd);
  }
}
function onclick_table(tablename) {
  send_or_sim({ friendly: tablename, uname: U.name }, 'table');
}
function onclick_tables() { phpPost({ app: 'simple' }, 'tables'); }
async function onclick_test() {
  let res = await route_path_text('http://localhost:3000/test');
  console.log('res', res)
}
function onclick_test_create_anagram_AI() { Session.cur_game = 'gAnagram'; get_create_table({ winning_score: 2 }, ['mimi', 'bob', 'guest', 'leo']); }
function onclick_test_create_maze_AI() { Session.cur_game = 'gMaze'; get_create_table({ winning_score: 2 }, ['mimi', 'bob', 'guest']); }
function onclick_test_create_spotit_AI() { Session.cur_game = 'gSpotit'; get_create_table({ winning_score: 2 }, ['mimi', 'bob']); }
function onclick_test_create1() { get_create_table(); }
function onclick_test_create2_anagram() { Session.cur_game = 'gAnagram'; get_create_table({ level_setting: 'min', winning_score: 1 }); }
function onclick_test_create2_maze() { Session.cur_game = 'gMaze'; get_create_table({ level_setting: 'min', winning_score: 1 }); }
function onclick_tide_all() {
  let [game, fen, uplayer, turn, stage] = [Z.game, Z.fen, Z.uplayer, Z.turn, Z.stage];
  for (const plname in fen.players) {
    let pl = fen.players[plname];
    if (isdef(pl.tides)) { continue; }
    pl.tides = { val: rNumber(8, 10) };
  }
  proceed_to_newcards_selection();
}
function onclick_tithe_all() {
  let [game, fen, uplayer, turn, stage] = [Z.game, Z.fen, Z.uplayer, Z.turn, Z.stage];
  for (const plname in fen.players) {
    let pl = fen.players[plname];
    if (isdef(pl.tithes)) { continue; }
    pl.tithes = { val: rNumber(8, 10) };
  }
  proceed_to_newcards_selection();
}
function onclick_toggle_games() {
  if (isVisible('dGames')) { toggle_games_off(); }
  else { show_games(); toggle_games_on(); }
}
function onclick_toggle_polling() { toggle_polling_status(); }
function onclick_toggle_sidebar(ev) {
  evNoBubble(ev);
  toggle_sidebar(); toggle_mini_user_info();
}
function onclick_toggle_tables() {
  if (isVisible('dTables')) { toggle_tables_off(); }
  else { phpPost({ app: 'simple' }, 'tables'); toggle_tables_on(); }
}
function onclick_toggle_users() {
  if (isVisible('dUsers')) { toggle_users_off(); }
  else { phpPost({ app: 'simple' }, 'users'); toggle_users_on(); }
}
function onclick_toobar(name) {
  console.log('clicked', name);
  switch (name) {
    case 'clear': mClear(dTable); DA.edits = []; break;
    case 'magic': break;
    case 'lineup':
      mCenterFlex(dTable);
      DA.edits.map(x => mStyle(x, { position: null, display: 'inline' }));
      break;
    case 'orig': DA.edits.map(x => x.style.position = 'absolute'); break;
  }
}
function onclick_user(uname) {
  U = firstCond(Serverdata.users, x => x.name == uname);
  localStorage.setItem('uname', U.name);
  DA.secretuser = U.name;
  let elem = firstCond(arrChildren('dUsers'), x => x.getAttribute('username') == uname);
  let img = elem.children[0];
  mShrinkTranslate(img, .75, 'dAdminRight', 400, show_username);
  mFadeClear('dUsers', 300);
}
function onclick_user_in_intro(ev) {
  let uname = try_find_username(ev);
  if (uname) { present_non_admin_user(uname); }
}
function onclick_user_login(e) {
  e.preventDefault(); e.cancelBubble = true;
  var username = e.target.getAttribute("username");
  if (e.target.id == "") {
    username = e.target.parentNode.getAttribute("username");
  }
  load_user(username);
  get_tables();
}
function onclick_user_login_new(e) {
  e.preventDefault(); e.cancelBubble = true;
  var username = e.target.getAttribute("username");
  if (e.target.id == "") {
    username = e.target.parentNode.getAttribute("username");
  }
  load_user(username);
  get_user_tables();
}
function onclick_userid() {
  let userid = mBy("enterID-input");
  let pwd = mBy('tlpvt-passcode-input');
  console.log('userid', userid.value, 'pwd', pwd.value);
}
function onclick_ut(func) {
  let [fen, player_names] = func();
  get_create_staged(fen, { level_setting: 'min' }, player_names);
}
function onclick_ut_n(g, n) {
  DA.test.running = true;
  let [fen, player_names] = window[`${g}_ut${n}_create_staged`]();
  get_create_staged(fen, { level_setting: 'min' }, player_names);
}
function onclick_view_buildings() {
  let [game, fen, uplayer, turn, stage] = [Z.game, Z.fen, Z.uplayer, Z.turn, Z.stage];
  let buildings = UI.players[uplayer].buildinglist;
  for (const b of buildings) b.items.map(x => face_up(x));
  TO.buildings = setTimeout(hide_buildings, 5000);
}
function onclick_view_ranking() { if (nundef(Session.cur_table)) { console.log('need table!'); return; } out1(); csv = make_csv_for_rankings(); }
function onClick1(ev, mobj, part) {
  console.log(mobj)
  if (mobj.scaleValue == 2) { mobj.setScale(1); delete mobj.scaleValue; }
  else { mobj.setScale(2); mobj.scaleValue = 2; }
}
function onClickActivate() {
  console.log('on click', T)
  ACTIVATE_UI = true;
  testActivate(T);
}
function onClickActivateLayout() { closeAux(); Socket.emit('settings', { settings: G.settings }); }
function onClickAdd() { testAddObject(T); }
function onClickAdd5Random() {
  closeAux();
  Socket.emit('poolChange', { n: 5 });
}
function onClickAddActions() {
  if (M.boats) {
    return;
  }
  timit.showTime('start ' + getFunctionCallerName());
  presentActions();
  activateActions();
  timit.showTime('...end ' + getFunctionCallerName());
}
function onClickAddBoard() { addBoard(T); }
function onClickAddDefaultObjects() {
  timit.showTime('start ' + getFunctionCallerName());
  for (const oid in G.table) {
    let mobj = makeDefaultObject(oid, G.table[oid], S.settings.table.defaultArea);
    presentDefault(oid, G.table[oid]);
  }
  timit.showTime('...end ' + getFunctionCallerName());
}
function onClickAddDefaultPlayers() {
  timit.showTime('start ' + getFunctionCallerName());
  for (const oid in G.players) {
    let mobj = makeDefaultPlayer(oid, G.playersAugmented[oid], S.settings.player.defaultArea);
    presentDefault(oid, G.playersAugmented[oid], false);
  }
  timit.showTime('...end ' + getFunctionCallerName());
}
function onClickAddInteraction() { for (const id in UIS) { addTestInteraction(UIS[id]); } }
function onClickAddLocObject() {
  let o = {
    oid: 'loc2ta',
    obj_type: 'robberta',
    name: 'hallo2',
    loc: 'loc3ta'
  };
  let o2 = {
    oid: 'loc1ta',
    obj_type: 'robberta',
    name: 'hallo1',
    loc: 'loc2ta'
  };
  if (isdef(R.getO('loc2ta'))) o = o2;
  R.addObject(o.oid, o); R.addRForObject(o.oid);
  let success = einhaengen(o.oid, o, R);
  recMeasureOverride(R.tree.uid, R)
  updateOutput(R);
}
function onClickAddRobber() { addRobber(T); }
function onClickAddToPool(ev) {
  let button = ev.target;
  if (ActiveButton == button) {
    if (isdef(DA.selectedPerlen) && !isEmpty(DA.selectedPerlen)) {
      let keys = DA.selectedPerlen.map(x => x.key);
      Socket.emit('poolChange', { keys: keys });
      delete DA.selectedPerlen;
    }
    closeAux();
    return;
  }
  openAux('pick perlen', button);
  let d = mDiv(dAuxContent);
  let items = [];
  for (const k in G.perlenDict) {
    let p = jsCopy(G.perlenDict[k]);
    p.path = mPath(p);
    console.log('path', p.path)
    let ui = createPerle(p, d, 64, 1.3, .4);
    mStyleX(ui, { opacity: 1 });
    iAdd(p, { div: ui });
    items.push(p);
  }
  DA.selectedPerlen = [];
  items.map(x => iDiv(x).onclick = ev => { toggleItemSelection(x, DA.selectedPerlen) });
}
function onClickAllTests() {
  setRSG_SOURCE('test');
  isTraceOn = false;
  runAllTests();
}
function onClickAllTestSeries() {
  iTESTSERIES = 0;
  isTraceOn = false;
  onClickResetTest();
  runAllTestSeries();
}
function onClickAreaSizes() {
  if (nundef(bodyZoom)) bodyZoom = 1.0;
  let zoomlevel = calcScreenSizeNeeded();
  let toplevelDiv = document.body.getRootNode();
  let body = document.body;
  let d = document.getElementById('a_d_header'); //'R_d_root');
  console.log('d', getBounds(d), d)
  console.log('width', d.style.offsetWidth);
  console.log('client', window.clientInformation)
  console.log(toplevelDiv, body)
  console.log(getBounds(body))
  console.log('d rect', d.getBoundingClientRect());
  console.log(toplevelDiv.scrollWidth)
  zoom(zoomlevel / 100);
}
function onClickAvailablePlayer(i) {
  let players = S.gameConfig.players;
  let plChosen = firstCond(players, x => x.index == i);
  joinCandidate = plChosen;
}
function onClickBadgeX(ev) {
  interrupt();
  let item = evToItem(ev);
  setBadgeLevel(item.index);
  userUpdate(['games', G.id, 'startLevel'], item.index);
  auxOpen = false;
  TOMain = setTimeout(G.controller.startGame.bind(G.controller), 100);
}
function onClickBoardInChooseBoard(boardFilename) {
  if (boardFilename == G.settings.boardFilename) return;
  G.settings.boardFilename = boardFilename;
  Socket.emit('settings', { settings: G.settings });
}
function onClickCalibrate() {
  if (isCal) {
    if (auxOpen) { closeAux(); }
    exitCalibrationMode();
  } else {
    if (auxOpen) { closeAux(); enterCalibrationMode('all'); }
    else { enterCalibrationMode(1); }
  }
}
function onClickCatan() {
  GAME = S.settings.game = 'catan';
  PLAYMODE = S.settings.playmode = 'hotseat';
  S.gameConfig = gcs[GAME];
  _startNewGame('starter');
}
function onClickCheat(code) { sendRoute('/cheat/' + code, null); }
function onClickChoice(ev) {
  let id = evToClosestId(ev);
  let b = mBy(id);
  let index = Number(stringAfter(id, '_'));
  Goal.choice = Goal.choices[index];
  Goal.buttonClicked = b;
  G.controller.evaluate.bind(G.controller)();
}
function onClickChooseBoard() {
  openAux('click board to select');
  let boards = G.settings.boardFilenames;
  for (const b of boards) {
    let img = mImg(PERLENPATH_FRONT + 'bretter/' + b, dAuxContent, { cursor: 'pointer', h: 200, margin: 8, 'vertical-align': 'baseline' });
    img.onclick = () => { closeAux(); onClickBoardInChooseBoard(b); }
  }
  let img = mDiv(dAuxContent, { cursor: 'pointer', display: 'inline-block', border: 'black', w: 300, h: 200, margin: 8, box: true });
  img.onclick = () => { closeAux(); onClickBoardInChooseBoard('none'); }
}
function onClickChoosePerlen(ev) {
  let button = ev.target;
  if (ActiveButton == button) {
    if (isdef(DA.selectedPerlen) && !isEmpty(DA.selectedPerlen)) {
      let keys = DA.selectedPerlen.map(x => x.key);
      Socket.emit('poolChange', { keys: keys });
      delete DA.selectedPerlen;
    }
    closeAux();
    return;
  }
  openAux('pick perlen', button);
  let d = mDiv(dAuxContent);
  let items = [];
  for (const k in G.perlenDict) {
    let p = jsCopy(G.perlenDict[k]);
    p.path = mPath(p);
    console.log('path', p.path)
    let ui = createPerle(p, d, 64, 1.3, .4);
    mStyle(ui, { opacity: 1 });
    iAdd(p, { div: ui });
    items.push(p);
  }
  DA.selectedPerlen = [];
  items.map(x => iDiv(x).onclick = ev => { toggleItemSelection(x, DA.selectedPerlen) });
}
function onClickClearAllPerlen() {
  closeAux();
  G.clearBoardUI();
  G.clearPoolUI();
  Socket.emit('clearPool');
}
function onClickClearBoard() {
  closeAux();
  let [plist, fields] = G.clearBoardUI();
  console.log('sending remove all perlen command', plist, fields);
  console.log('===> remove list', plist, fields);
  let data = { iPerlen: plist.map(x => x.index), iFroms: fields.map(x => x.index), username: Username };
  logClientSend('removePerlen', data);
  Socket.emit('removePerlen', data);
}
function onClickClearPerlenpool() {
  closeAux();
  G.clearPoolUI();
  Socket.emit('clearPoolarr');
}
async function onClickClearTable() {
  clearElement('table'); clearUpdateOutput(); T = {};
  mBy('table').style.minWidth = 0; mBy('table').style.minHeight = 0;
  resetUIDs();
}
function onclickCodeInSidebar(ev) {
  let key = isString(ev) ? ev : ev.target.innerHTML;
  let text = CODE.justcode[key];
  let ta = AU.ta; let dParent = null;
  if (nundef(ta)) {
    dParent = valf(dFiddle, dTable, document.body);
    let talist = dTable.getElementsByTagName('textarea');
    if (isEmpty(talist)) ta = mTextarea(null, null, dParent, { w: '100%' });
    else ta = talist[0];
  } else dParent = ta.parentNode;
  ta.value = text;
  let hideal = ta.scrollHeight;
  console.log('ta.scrollheight', hideal)
  let hsidebar = window.innerHeight - 68;
  mStyle(dParent, { hmax: hsidebar });
  let lines = text.split('\n');
  let min = lines.length + 1;
  mStyle(ta, { h: hideal, hmin: 50, hmax: hsidebar - 44 });
  ta.scrollTop = 0;
  let download = false;
  if (download) downloadAsText(text, 'hallo', 'js');
  return text;
}
function onClickCollapse() { collapseAll(); }
function onClickComputer() { }
function onClickConnect(port) { initSocket(port); }
function onClickContact(ev) {
  el = evToClass(ev, 'contact');
  DA.currentContact = el.getAttribute('username');
  onClickMenu('chat');
}
function onClickCreateGame() {
  console.log('playMode:', S.settings.playMode, 'PLAYMODE', PLAYMODE, 'S.playModeChanged', S.playModeChanged)
  S.settings.username = USERNAME;
  S.settings.playMode = PLAYMODE;
  S.settings.game = GAME;
  console.log('playMode:', S.settings.playMode, 'PLAYMODE', PLAYMODE, 'S.playModeChanged', S.playModeChanged)
  switch (S.settings.playMode) {
    case 'multiplayer': restartHost(onHostStarted); break;
    case 'hotseat': _startHotseat(); break;
    case 'solo':
    default: break;
  }
}
function onClickCreateGameCancel() {
  currentPlaymode = PLAYMODE;
  currentGamename = GAME;
  closeGameConfig();
}
function onClickCreateGameLobby() {
  openGameConfig();
}
function onClickCreateGameOk() {
  isPlaying = false;
  disableResumeButton();
  GAME = S.settings.game = currentGamename;
  PLAYMODE = S.settings.playmode = currentPlaymode;
  currentSeed = document.getElementById('c_b_mm_seed').value;
  SEED = S.settings.seed = Number(currentSeed);
  joinedPlayers = [];
  let gi = allGames[GAME];
  S.gameInfo = gi;
  let gc = {};
  gc.numPlayers = currentNumPlayers;
  gc.players = [];
  let countNeedToJoin = 0;
  let countMes = 0;
  let iBots = 0;
  for (let i = 0; i < currentNumPlayers; i++) {
    let pl = {};
    pl.index = i + 1;
    pl.id = gi.player_names[i];
    let selType = valueOfElement(getidType(i + 1));
    pl.playerType = startsWith(selType, 'AI') ? 'AI' : selType;
    pl.agentType = pl.playerType == 'AI' ? stringAfter(selType, ' ') : null;
    pl.username = selType == 'me' ? USERNAME + (countMes > 0 ? countMes : '')
      : selType == 'human' ? '' : 'bot' + iBots;
    if (selType == 'me') countMes += 1;
    else if (selType == 'human') countNeedToJoin += 1;
    else iBots += 1;
    gc.players.push(pl);
  }
  S.gameConfig = gc;
  closeGameConfig();
  if (countNeedToJoin > 0) {
    setMessage('new game set up! waiting for ' + countNeedToJoin + ' players to join!');
    socketEmitMessage(JSON.stringify({ type: 'gc', data: gc }));
  } else {
    _startNewGame('starter');
  }
}
function onClickDeactivate() { ACTIVATE_UI = false; testDeactivate(T); }
function onClickDetection() {
  S.settings.userBehaviors = false;
  S.settings.userStructures = false;
  S.settings.userSettings = false;
  S.settings.boardDetection = S_boardDetection = true;
  S.settings.deckDetection = S_deckDetection = true;
  S.settings.openTab = 'ObjectsTab';
  redrawScreen();
}
function onClickDownloadHistory() {
  let keys = Object.keys(HistoryOfStates);
  console.log('history keys', keys);
  for (const k in HistoryOfStates) {
    let pack = HistoryOfStates[k];
    console.log('state', k, 'freeForm', pack.settings.freeForm, 'board', pack.settings.boardFilename)
  }
  downloadAsYaml(HistoryOfStates, `history_` + Date.now());
}
function onClickExpand() { uncollapseAll(); }
function onClickFilter() {
  console.log('clicked filter!')
}
function onClickFilterAndInfobox(ev, mobj, part) { onClickFilterTuples(ev, mobj, part); onClickPlusControlInfobox(ev, mobj, part); }
function onClickFilterOrInfobox(ev, mobj, part) { if (!ev.ctrlKey) onClickFilterTuples(ev, mobj, part); else openInfobox(ev, mobj, part); }
function onClickFilterTuples(ev, mobj, part) {
  let id = mobj.id;
  if (boatFilters.includes(id)) {
    _removeFilterHighlight(mobj);
    removeInPlace(boatFilters, id);
    let relids = getList(id2uids[id]);
    let boats = relids.filter(x => x[2] == 'a');
    if (isEmpty(boats)) { return; }
    for (const bid of boats) { if (!fi.includes(bid)) { _showBoat(bid); } }
  } else {
    let relids = getList(id2uids[id]);
    let boats = relids.filter(x => x[2] == 'a');
    if (isEmpty(boats)) { return }
    if (boats.length == 1) {
      onClickSelectTuple(null, UIS[boats[0]]);
    } else {
      boatFilters.push(id);
      _addFilterHighlight(mobj);
      for (const bid of IdOwner.a) { if (!boats.includes(bid)) { _hideBoat(bid) } }
    }
  }
}
function onClickFloppy() {
  savedb();
}
function onClickFreezer() { console.log('YEP! onClickFreezer!!!!!!!'); hide('freezer'); startUnit(); }
function onClickFreezer2(ev) {
  clearTable(); mRemoveClass(mBy('freezer2'), 'aniSlowlyAppear'); hide('freezer2'); auxOpen = false;
  startUnit();
}
function onClickGamename(inputElem) {
  updateGamename(inputElem.value.toString());
  updatePlayersForGame();
}
function onClickGamesMenu(text) {
  console.log('clicked on menu: ', text);
  console.log('open menu is ', getVisibleChild('dGames'));
  let id = 'd' + capitalize(text);
  if (id == getVisibleChild('dGames')) { console.log('NOPE!'); return; }
  transitionTo(id);
  window['onClick_' + text]();
}
function onClickGear() {
  openAux();
  hide('dGear');
  hide('dCalibrate');
  Settings.createSettingsUi(dAux);
}
function onClickGetUIS(mobj, part) {
  let id = mobj.id;
}
function onClickGo(ev) {
  if (isVisible('dTemple')) {
    closeAux();
    if (G.controllerType == 'solitaire') GC.startGame(); else GC.activateUi();
  } else {
    let item = isdef(ev) ? evToItemC(ev) : null;
    let gKey = nundef(ev) ? SelectedMenuKey : isString(ev) ? ev : item.id;
    if (gKey != SelectedMenuKey) {
      if (isdef(SelectedMenuKey)) toggleItemSelection(Items[SelectedMenuKey]);
      SelectedMenuKey = gKey;
      let item = Items[SelectedMenuKey];
      toggleItemSelection(item);
    } else {
      closeAux();
      setGame(gKey);
      GC.startGame();
    }
  }
}
function onClickInvalidate() { testEngine.invalidate(); }
function onClickIVPicture(ev) {
  ev.cancelBubble = true;
  let pic = findItemFromEvent(Pictures, ev);
  toggleSelectionOfPicture(pic);
}
function onClickJoinGame() {
  if (S.gameInProgress) {
    alert('CANNOT JOIN! game has already started!!! click create game to start a new game or restart to restart current game');
    return;
  }
  console.log('playMode:', S.settings.playMode, 'PLAYMODE', PLAYMODE, 'S.playModeChanged', S.playModeChanged)
  S.settings.username = USERNAME;
  S.settings.playMode = PLAYMODE;
  S.settings.game = GAME;
  console.log('playMode:', S.settings.playMode, 'PLAYMODE', PLAYMODE, 'S.playModeChanged', S.playModeChanged)
  switch (S.settings.playMode) {
    case 'multiplayer': _startMultiplayer(); break;
    case 'hotseat': _startHotseat(); break;
    case 'solo':
    default: break;
  }
}
function onClickJoinGameCancel() {
  closeJoinConfig();
}
function onClickJoinGameLobby() {
  openJoinConfig();
}
function onClickJoinGameOk() {
  isPlaying = false;
  disableResumeButton();
  if (!joinCandidate) {
    setMessage('you did NOT join the game!')
  } else {
    let countMes = 0;
    for (pl of S.gameConfig.players) {
      if (!isEmpty(pl.username) && startsWith(pl.username, USERNAME)) countMes += 1;
    }
    let uname = USERNAME + (countMes > 0 ? countMes : '');
    joinCandidate.username = uname;
    socketEmitMessage(uname + ' joined as ' + joinCandidate.id);
  }
  closeJoinConfig();
  if (checkGameConfigComplete()) {
    disableJoinButton();
  }
}
function onClickListOfObj(b) {
  console.log('clicked', b.textContent);
}
function onClickLoadStateAndSettings() {
  let prefix = prompt('enter name: ');
  if (prefix in HistoryOfStates) {
    let pack = HistoryOfStates[prefix];
    console.log('loaded state', prefix, 'freeForm', pack.settings.freeForm, 'board', pack.settings.boardFilename)
    Socket.emit('state', pack);
  }
}
function onClickLoadStateAndSettings_dep() {
  let prefix = prompt('enter name: ');
  if (!isEmpty(prefix)) recoverStateAndSettings(prefix);
}
function onClickLobby() {
  lobbyView();
  if (!isReallyMultiplayer) openGameConfig();
}
function onClickLogout() { logout(); }
function onClickMeasure() {
  recMeasureOverride(R.tree.uid, R);
  updateOutput(R);
}
function onClickMenu(text) {
  let subMenu = capitalize(text);
  let id = 'd' + subMenu;
  console.log('menu id clicked:', id);
  if (id == getVisibleChild('dInnerLeft')) { console.log('NOPE!'); return; }
  let delay1 = hideCurrent();
  setTimeout(() => {
    let delay2 = text == 'chat' || text == 'tables' ? closeLeftPane() : openLeftPane();
    setTimeout(() => { showCurrent(id); window['onClickMenu' + subMenu](); }, delay2 + 100);
  }, delay1 + 100);
}
function onClickMenuAccount() { show_account(); }
async function onClickMenuChat() {
  chatStartOrActivate();
}
function onClickMenuContacts() { get_data('contacts'); }
function onClickMenuGames() { show_games(); }
function onClickMenuItem(ev) { onClickGo(ev); }
function onClickMenuTables() { }
function onClickModifyLayout(ev) {
  let button = ev.target;
  if (ActiveButton == button) { onClickActivateLayout(); return; }
  openAux('board settings', button);
  let wWidget = 380;
  let [s, b] = [G.settings, G.clientBoard];
  let styles = { w: wWidget, align: 'center', margin: 6 };
  let inpRows = mEditRange('rows: ', s.rows, 1, 20, 1, dAuxContent, (a) => { setApply('rows', a) }, styles);
  let inpCols = mEditRange('cols: ', s.cols, 1, 20, 1, dAuxContent, (a) => { setApply('cols', a) }, styles);
  let inpXOffset = mEditRange('x-offset: ', s.boardMarginLeft, -100, 100, 1, dAuxContent, (a) => { setApply('boardMarginLeft', a) }, styles);
  let inpYOffset = mEditRange('y-offset: ', s.boardMarginTop, -100, 100, 1, dAuxContent, (a) => { setApply('boardMarginTop', a) }, styles);
  let inpRot = mEditRange('rotation: ', s.boardRotation, 0, 90, 1, dAuxContent, (a) => { setApply('boardRotation', a) }, styles);
  mLinebreak(dAuxContent);
  let inpWidth = mEditRange('center dx: ', s.dxCenter, 10, 200, 1, dAuxContent, (a) => { setApply('dxCenter', a) }, styles);
  let inpHeight = mEditRange('center dy: ', s.dyCenter, 10, 200, 1, dAuxContent, (a) => { setApply('dyCenter', a) }, styles);
  let inpFieldSize = mEditRange('field size: ', s.szField, 10, 200, 1, dAuxContent, (a) => { setApply('szField', a) }, styles);
  mLinebreak(dAuxContent);
  let inpSzPerle = mEditRange('perle %: ', s.szPerle, 50, 125, 1, dAuxContent, (a) => { setApply('szPerle', a) }, styles);
  let inpszPoolPerle = mEditRange('pool perle: ', s.szPoolPerle, 40, 140, 1, dAuxContent, (a) => { setApply('szPoolPerle', a) }, styles);
  let inpDimming = mEditRange('dimming %: ', s.dimming, 0, 100, 1, dAuxContent, (a) => { setApply('dimming', a) }, styles);
  mLinebreak(dAuxContent);
  let inpFieldColor = mColorPickerControl('field color: ', s.fieldColor, b.img, dAuxContent, (a) => { setApply('fieldColor', a) }, styles);
  console.log('basecolor', s.baseColor);
  let inpBaseColor = mColorPickerControl('background: ', s.baseColor, b.img, dAuxContent, (a) => { setApply('baseColor', a) }, styles);
  let inpFullCover = mCheckbox('complete rows: ', s.boardLayout == 'hex1' ? false : true, dAuxContent,
    (a) => {
      setApply('boardLayout', a ? 'hex' : 'hex1');
    }, styles);
  let inpfreeForm = mCheckbox('free drop: ', s.freeForm ? true : false, dAuxContent, (a) => { setApply('freeForm', a == 1 ? true : false) }, styles);
}
function onClickMusic() {
  toggleSound('mozart');
  if (isPlaying()) { hide0('bPlay'); show0('bPause'); } else { hide0('bPause'); show0('bPlay'); }
}
function onClickNewColors() {
  iTHEME = (iTHEME + 1) % THEMES.length;
  let color = THEMES[iTHEME];
  document.body.style.backgroundColor = color;
  let fg = colorIdealText(color)
  document.body.style.color = fg;
}
function onClickNextButton() { startRound(); }
function onClickNextExample() { }
function onClickNextGame() { setNextGame(); GC.startGame(); }
function onClickNextPlayerReady() {
  if (WAITINGFORPLAYER !== null) {
    let user = getUsernameForPlayer(WAITINGFORPLAYER);
    WAITINGFORPLAYER = null;
    sendStatus(user, [d => { hide('freezer'); gameStep(d) }]);
  }
}
async function onClickNextTest() {
  setRSG_SOURCE('main');
  await testEngine.loadNextTestCase();
  await rParse(RSG_SOURCE, { defs: testEngine.defs, spec: testEngine.spec, sdata: testEngine.sdata });
}
function onClickNextTestOfSeries() {
  setRSG_SOURCE('test');
  nextTestOfSeries(false);
}
function onClickPaletteButton() {
  alert('FUNCTION DISABLED!')
  return;
  IsCanvasActive = !IsCanvasActive;
  let canvas = mBy('sheet')
  if (IsCanvasActive) {
    canvas.style.userSelect = 'auto';
    console.log(G.clientBoard)
    let r = getRect(G.clientBoard.dOuter); r.left = r.x; r.top = r.y;
    console.log('rectBoard', r);
    mStyleX(canvas, r);
    halloIchZeichneJetzt();
  } else {
    canvas.style.userSelect = 'none';
    canvas.onmousedown = null;
    canvas.onmousemove = null;
    canvas.onmouseup = null;
  }
}
function onClickPass() {
}
function onClickPerlenPool(ev) {
  let button = ev.target;
  if (ActiveButton == button) { doPerlenPoolChanges(); return; }
  openAux('perlen pool', button);
  let wWidget = 380;
  let styles = { w: wWidget, align: 'center', margin: 6 };
  let defOptions = { nAdd: 5, nRemove: 5, clearBoard: false, justRandom: true };
  if (nundef(G.perlenOptions)) G.perlenOptions = {};
  let s = G.perlenOptions;
  copyKeys(defOptions, s);
  let dp = mBy('dAuxContent');
  let inpAddRandom = mEditRange('add: ', s.nAdd, 1, 20, 1, dp, (a) => { s.nAdd = a; }, styles);
  let inpRemove = mEditRange('remove: ', s.nRemove, 1, 20, 1, dp, (a) => { s.nRemove = a; }, styles);
  let inpClearBoard = mCheckbox('clear board: ', s.clearBoard, dp, (a) => { s.clearBoard = a; }, styles);
  let inpClearPool = mCheckbox('clear pool: ', s.clearPool, dp, (a) => { s.clearPool = a; }, styles);
  let inpOnlyRandom = mCheckbox('just random: ', s.justRandom, dp, (a) => { s.justRandom = a; }, styles);
}
function onClickPlain() {
  S.settings.userBehaviors = false;
  S.settings.userStructures = false;
  S.settings.userSettings = false;
  S.settings.boardDetection = S_boardDetection = false;
  S.settings.deckDetection = S_deckDetection = false;
  S.settings.openTab = 'ObjectsTab';
  redrawScreen();
}
function onClickPlay() {
  S.settings.username = USERNAME;
  S.settings.playMode = PLAYMODE;
  S.settings.game = GAME;
  console.log(S.settings.username, S.settings.playMode, S.settings.game);
  switch (S.settings.playMode) {
    case 'multiplayer': whichGame(onWhichGame);
      break;
    case 'hotseat': _startHotseat();
      break;
    case 'solo':
    default:
      break;
  }
}
function onClickPlayerPresence(n) {
  isOptional = (n > numPlayersMin) && (n <= numPlayersMax);
  if (!isOptional) return;
  let el = getPlayerRadio(n);
  let isActive = isPlayerChecked(n);
  if (isActive) checkPlayer(n); else uncheckPlayer(n);
  if (isActive) for (let i = numPlayersMin + 1; i < n; i++) { if (!isPlayerChecked(i)) checkPlayer(i); }
  else for (let i = n + 1; i <= numPlayersMax; i++) { if (isPlayerChecked(i)) uncheckPlayer(i); }
  let cnt = 0;
  for (let i = 1; i <= numPlayersMax; i++) { if (isPlayerChecked(i)) cnt += 1; }
  currentNumPlayers = cnt;
}
function onClickPlaymode(mode) {
  updatePlaymode(mode);
  updatePlayersForMode();
}
function onClickPlusControlInfobox(ev, mobj, part) { if (ev.ctrlKey) { openInfobox(ev, mobj, part); } }
function onClickPollStatus() {
  sendStatus(USERNAME, [gameStep]);
}
function onClickPrefabGallery() {
  openAux('choose board + layout');
  let standards = DB.standardSettings;
  let boardExamples = {};
  for (const stdName in standards) {
    let std = standards[stdName];
    let d = mDiv(dAuxContent, { margin: 10, cursor: 'pointer' });
    addKeys(G.settings, std);
    let b = applyStandard(d, std, 200, 100);
    boardExamples[stdName] = {
      key: stdName,
      board: b,
      settings: std,
      dParent: d,
    }
    d.onclick = () => {
      DA.lastPrefabName = stdName;
      copyKeys(std, G.settings);
      Socket.emit('settings', { settings: G.settings });
      closeAux();
    }
  }
}
async function onClickPrevTest() {
  setRSG_SOURCE('main');
  await testEngine.loadPrevTestCase();
  await rParse(RSG_SOURCE, { defs: testEngine.defs, spec: testEngine.spec, sdata: testEngine.sdata });
}
function onClickPrevTestOfSeries() {
  setRSG_SOURCE('test');
  iTEST -= 2; if (iTEST < 0) iTEST = 0;
  nextTestOfSeries();
}
function onClickPushScenario(cheatCode, actionCode) {
  scenarioQ.push(() => sendRoute('/cheat/' + cheatCode, () => onClickRunToAction(actionCode)));
  scenarioQ.push(() => onClickSelectTuple(null, strategicBoat([actionCode])));
  if (!scenarioRunning) { scenarioRunning = true; onClickStep(); }
}
function onClickRecovery() { recoverStateAndSettings(); }
function onClickRecpoint() { saveStateAndSettings(); }
async function onClickReloadAll() {
  vidCache.invalidate('testCards', 'allGames', 'userSpec', 'serverData', 'userCode');
  _startSession();
}
async function onClickReloadSpec() {
  await loadSpecAndCode();
  presentSpecAndCode();
  redrawScreen();
}
function onClickRemoteConnection() {
  if (isdef(DA.remoteSocket)) DA.remoteSocket.disconnect();
  let socket = DA.remoteSocket = io('https://simplesimpleserver.herokuapp.com');
  socket.on('fromServer', x => console.log('msg from remote:', x.msg));
  socket.on('ping', x => console.log('got pinged from remote!'));
  socket.emit('ping');
}
function onClickRemove() { testRemoveObject(T); }
function onClickRemove5Random() {
  closeAux();
  Socket.emit('removeRandom', { n: 5 });
}
function onClickRemoveActions() {
  timit.showTime('start ' + getFunctionCallerName());
  deleteActions();
  timit.showTime('...end ' + getFunctionCallerName());
}
function onClickRemoveBoard() { removeBoard(T); }
function onClickRemoveDefaultObjects() {
  timit.showTime('start ' + getFunctionCallerName());
  deleteDefaultObjects();
  timit.showTime('...end ' + getFunctionCallerName());
}
function onClickRemoveDefaultPlayers() {
  timit.showTime('start ' + getFunctionCallerName());
  deleteDefaultPlayers();
  timit.showTime('...end ' + getFunctionCallerName());
}
function onClickRemoveInteraction() {
  timit.showTime('start ' + getFunctionCallerName());
  for (const id in UIS) UIS[id].removeEvents();
  timit.showTime('...end ' + getFunctionCallerName());
}
function onClickRemoveRobber() { removeRobber(T); }
async function onClickRepeatTest() {
  setRSG_SOURCE('main');
  await testEngine.repeatTestCase();
  await rParse(RSG_SOURCE, { defs: testEngine.defs, spec: testEngine.spec, sdata: testEngine.sdata });
}
function onClickRepeatTestOfSeries() {
  setRSG_SOURCE('test');
  iTEST -= 1; if (iTEST < 0) iTEST = 0;
  nextTestOfSeries(false);
}
function onClickResetAll() {
  Socket.emit('reset');
}
async function onClickResetLocal() {
  _startSession(true);
}
function onClickResetTest() {
  setRSG_SOURCE('test');
  iTEST = 0;
}
function onClickResizeBoard() {
  let nuiBoard = R.uiNodes['_2'];
  nuiBoard.adirty = true;
  lookupSetOverride(nuiBoard, ['resizeInfo', 'fields'], 180);
  recMeasureOverride(R.tree.uid, R);
}
function onClickRestart() {
  unfreezeUI();
  _startRestartSame();
}
function onClickResumeGameLobby() {
  closeGameConfig();
  gameView();
}
function onClickRetrieveColor() {
  let color = localStorage.getItem('background');
  console.log('retrieved baseColor', color);
  G.settings.baseColor = color;
  Socket.emit('settings', { settings: G.settings });
}
function onClickRetrieveLastState() {
  let lastState = G.lastStateman.getLastStateSaved();
  let s = lastState.settings;
  console.log('retrieve baseColor', s.baseColor);
  Socket.emit('initLastState', { lastState: lastState });
  return;
  let elem = createElementFromHTML(`
    <form action="/lastState" method="post" enctype="multipart/form-data">
    <input type="file" name="lastState" placeholder="Select file" />
    <br />
    <button>Upload</button>
    </form>
  `);
  show(dAux);
  clearElement(dAuxContent);
  mAppend(dAuxContent, elem);
}
function onClickRetrieveSettings() {
  let settings = localStorage.getItem('settings');
  if (isdef(settings)) {
    settings = JSON.parse(settings);
    console.log('retrieved settings (baseColor)', settings.baseColor);
    G.settings = settings;
    Socket.emit('settings', { settings: G.settings });
  } else {
    console.log('no settings in localStorage!');
  }
}
function onClickRetrieveSettings_dep() {
  let settings = localStorage.getItem('settings');
  if (isdef(settings)) {
    settings = JSON.parse(settings);
    console.log('retrieved settings (baseColor)', settings.baseColor);
    G.settings = settings;
    Socket.emit('settings', { settings: G.settings });
  } else {
    console.log('no settings in localStorage!');
  }
}
function onClickRetrieveState() {
  let state = localStorage.getItem('state');
  let randomIndices = localStorage.getItem('randomIndices');
  if (isdef(state) && isdef(randomIndices)) {
    state = JSON.parse(state);
    randomIndices = JSON.parse(randomIndices);
    console.log('retrieved state (boardArr)', state.boardArr.filter(x => x !== null));
    Socket.emit('state', { state: state, randomIndices: randomIndices });
  } else {
    console.log('no state/randomIndices in localStorage!');
  }
}
async function onClickRun() {
  setRSG_SOURCE('main');
  let indexFrom = firstNumber(mBy('iTestCaseFrom').value);
  localStorage.setItem('iTestCaseFrom', indexFrom);
  let indexTo = firstNumber(mBy('iTestCaseTo').value);
  localStorage.setItem('iTestCaseTo', indexTo);
  verifySequence(indexFrom, indexTo, false);
}
async function onClickRunAll() {
  setRSG_SOURCE('main');
  STOP = false;
  isTraceOn = false;
  let sel = mBy('selSeries');
  let listSeries = [];
  for (const ch of sel.children) {
    if (ch.value != 'none') listSeries.push(DIR_TESTS + '/' + ch.value);
  }
  let imax = await testEngine.loadSeries(listSeries[0]);
  show('btnStop');
  await runNextSeries(listSeries, listSeries[0], 0, imax);
}
function onClickRunButton(b) { b.innerHTML = 'Stop'; mStyleX(bRunStop, { bg: 'red' }); StepByStepMode = false; startRound(); }
function onClickRunStopButton(b) { if (StepByStepMode) { onClickRunButton(b); } else { onClickStopButton(b); } }
function onClickRunToAction(keyword) {
  S_autoplayFunction = (_G) => {
    for (const mobj of getBoats()) {
      for (const ti of mobj.o.tuple) {
        if (ti.val.toString().includes(keyword)) {
          setAutoplayFunctionForMode();
          return false;
        }
      }
    }
    return true;
  }
  onClickStep(G);
}
function onClickRunToEnd() {
  S_autoplayFunction = () => true;
  onClickStep(G);
}
function onClickRunToNextPhase() {
  let phase = G.phase;
  S_autoplayFunction = (_G) => _G.phase == phase;
  onClickStep(G);
}
function onClickRunToNextPlayer() {
  let pl = G.player;
  S_autoplayFunction = (_G) => _G.player == pl;
  onClickStep(G);
}
function onClickRunToNextTurn() {
  let pl = G.player;
  S_autoplayFunction = (_G) => {
    if (_G.player != pl) {
      S_autoplayFunction = (_G1, _) => _G1.player != pl;
    };
    return true;
  };
  onClickStep(G);
}
function onClickRunToPlayerChange(player) {
  STOP = false;
  showStop();
  execOptions.skipCond = () => H.player == player;
  decider.onClickStep(H);
}
function onClickSave() { testEngine.saveSolution(T); }
function onClickSaveAsPrefab() {
  let prefabName = prompt('enter name: ', DA.lastPrefabName);
  Socket.emit('prefab', { name: prefabName, settings: G.settings });
  closeAux();
}
function onClickSaveColor() {
  localStorage.setItem('background', G.settings.baseColor);
  console.log('saved baseColor', G.settings.baseColor);
}
function onClickSaveLastState() {
  let lastStateSaved = G.lastStateman.save(G, true);
  let s = lastStateSaved.settings;
  console.log('save baseColor', s.baseColor);
}
function onClickSaveSettings() {
  localStorage.setItem('settings', JSON.stringify(G.settings));
  console.log('saved settings (baseColor)', G.settings.baseColor);
}
function onClickSaveState() {
  let st = G.state;
  let state = { boardArr: st.boardArr, poolArr: st.poolArr, pool: {} };
  for (const k in st.pool) {
    let oNew = state.pool[k] = {};
    copyKeys(st.pool[k], oNew, {}, ['index', 'key']);
  }
  localStorage.setItem('state', JSON.stringify(state));
  localStorage.setItem('randomIndices', JSON.stringify(G.randomIndices));
  console.log('saved state (boardArr)', state.boardArr.filter(x => x !== null));
  console.log('saved state (pool)', Object.keys(state.pool));
}
function onClickSaveStateAndSettings() {
  let prefix = prompt('enter name: ');
  addStateToHistory(prefix);
}
function onClickSaveStateAndSettings_dep() {
  let prefix = prompt('enter name: ');
  if (!isEmpty(prefix)) saveStateAndSettings(prefix);
}
function onClickSaveToHistory() {
  console.log('save to history!');
  let l = G.lastStateman.lastState;
  downloadAsYaml(l, 'lastState');
}
function onClickScenario() {
  scenarioQ = [];
  for (let i = 0; i < 1; i++) {
    scenarioQ.push(cheatDevcard);
    scenarioQ.push(selectBuyDeckcard);
  }
  if (!scenarioRunning) { scenarioRunning = true; onClickRunToNextPhase(); }
  console.log('...scenario', scenario)
}
function onClickSelectTuple(ev, mobj, part) {
  if (choiceCompleted) return;
  choiceCompleted = true;
  iTuple = mobj.o.iTuple;
  freezeUI();
  stopAllHighlighting();
  sendAction(mobj.o, [gameStep]);
}
function onClickShield(ev) {
  ev.stopPropagation();
  console.log('wait...?');
  hideShield();
}
function onClickShowSavedColor() {
  let color = localStorage.getItem('background');
  console.log('saved background is', color);
}
function onClickShowSavedSettings() {
  let settings = localStorage.getItem('settings');
  if (isdef(settings)) {
    settings = JSON.parse(settings);
    console.log('saved settings (baseColor)', settings.baseColor);
  } else {
    console.log('no settings in localStorage!');
  }
}
function onClickShowSavedState() {
  let state = localStorage.getItem('state');
  let randomIndices = localStorage.getItem('randomIndices');
  if (isdef(state) && isdef(randomIndices)) {
    state = JSON.parse(state);
    randomIndices = JSON.parse(randomIndices);
    console.log('retrieved state (boardArr)', state.boardArr.filter(x => x !== null));
  } else {
    console.log('no state/randomIndices in localStorage!');
  }
}
function onClickSmallerBoard() {
  let nuiBoard = R.uiNodes['_2'];
  nuiBoard.adirty = true;
  lookupSetOverride(nuiBoard, ['resizeInfo', 'fields'], 32);
  recMeasureOverride(R.tree.uid, R);
}
function onClickSpec() {
  S.settings.userBehaviors = false;
  S.settings.userStructures = true;
  S.settings.userSettings = true;
  S.settings.boardDetection = S_boardDetection = true;
  S.settings.deckDetection = S_deckDetection = true;
  S.settings.openTab = 'SpecTab';
  redrawScreen();
}
function onClickSpecAndCode() {
  S.settings.userBehaviors = true;
  S.settings.userStructures = true;
  S.settings.userSettings = true;
  S.settings.boardDetection = S_boardDetection = true;
  S.settings.deckDetection = S_deckDetection = true;
  S.settings.openTab = 'CodeTab';
  redrawScreen();
}
function onClickStartButton() { startGame(); }
function onClickStartGame() {
  _sendRoute('/begin/1', d6 => {
    timit.showTime('sending status');
    _sendRoute('/status/' + USERNAME, d7 => {
      let data = JSON.parse(d7);
      processData(data);
      specAndDOM([gameStep]);
    });
  });
}
function onClickStep() {
  if (!this.choiceCompleted) {
    let mobj = getNextStartBoat();
    if (nundef(mobj)) mobj = getBoatWith(['demand', 'offer'], false);
    if (nundef(mobj)) mobj = getBoatWith(['buy'], true);
    if (nundef(mobj)) mobj = getBoatWith(['pass'], true);
    if (nundef(mobj)) mobj = getBoatWith(['demand', 'offer'], false);
    if (nundef(mobj)) mobj = getRandomBoat();
    onClickSelectTuple(null, mobj);
  }
}
function onClickSteps() {
  STOP = false;
  showStop();
  let n = document.getElementById('inSteps').value;
  stepCounter = Number(n) + 1;
  console.log('steps:', stepCounter - 1);
  execOptions.skipCond = () => {
    if (stepCounter > 1) stepCounter -= 1;
    return stepCounter > 1;
  };
  decider.onClickStep(H);
}
function onClickStop() {
  setAutoplayFunctionForMode(PLAYMODE);
  unfreezeUI();
}
function onClickStopButton(b) { b.innerHTML = 'Run'; mStyleX(bRunStop, { bg: 'green' }); StepByStepMode = true; }
function onClickSubmitImageChange() { sendHtml('imgPreview', Username); DA.imageChanged = false; }
function onClickSubmitUsernameChange(newUsername) { window.location = "index.php?user=" + newUsername; }
function onClickTemple() {
  openAux();
  hide('dTemple');
  createMenuUi(dAux);
}
function onClickTempleLobby() {
  START_IN_MENU = true;
  initGameScreen();
}
function onclickTest(x) {
  console.log('TEST!', x)
}
function onClickToggle(b, key) {
  let content = b.textContent;
  let isOn = (content[0] == '-');
  if (isOn) {
    window['S_' + key] = false;
    b.textContent = '+' + content.substring(1);
  } else {
    window['S_' + key] = true;
    b.textContent = '-' + content.substring(1);
  }
}
function onClickToggleButton(button, handlerList) {
  let current = button.textContent;
  let idx = -1;
  let i = 0;
  for (const item of handlerList) {
    if (item[0] == current) {
      idx = i; break;
    }
    i += 1;
  }
  if (idx >= 0) {
    let idxNew = (idx + 1) % handlerList.length;
    button.textContent = handlerList[idxNew][0];
    handlerList[idxNew][1]();
  }
}
function onClickToggleInteractivity(desc) {
  let d = mBy('div' + desc);
  if (isVisible(d)) { hideMenu(desc); } else { showMenu(desc); }
}
function onClickToolbarButton() {
  if (isVisible('sidebar')) {
    hide('sidebar');
    mStyleX(dTable, { w: 'calc( 100% - 120 )' });
  } else {
    show('sidebar');
    mStyleX(dTable, { w: '100%' });
  }
}
function onClickTop() {
  mBy('sidebar').scrollTo(0, 0);
  mBy('pageContent').scrollTo(0, 0);
}
function onClickTTT() {
  GAME = S.settings.game = 'ttt';
  PLAYMODE = S.settings.playmode = 'hotseat';
  S.gameConfig = gcs[GAME];
  _startNewGame('starter');
}
function onClickUpdateOutput(elem) {
  switch (elem.id) {
    case 'contSpec': if (LEAVE_SPEC_OPEN) SHOW_SPEC = true; else SHOW_SPEC = !SHOW_SPEC; break;
    case 'contMixinSpec': SHOW_MIXINSPEC = !SHOW_MIXINSPEC; break;
    case 'contLastSpec': SHOW_LASTSPEC = !SHOW_LASTSPEC; break;
    case 'contUiTree': SHOW_UITREE = !SHOW_UITREE; break;
    case 'contRTree': SHOW_RTREE = !SHOW_RTREE; break;
    case 'contOidNodes': SHOW_OIDNODES = !SHOW_OIDNODES; break;
    case 'contDicts': SHOW_DICTIONARIES = !SHOW_DICTIONARIES; break;
    case 'contRefsIds': SHOW_IDS_REFS = !SHOW_IDS_REFS; break;
  }
  updateOutput(R);
}
function onClickUploadBoard(ev) {
  openAux('upload board image');
  let form1 = new FileUploadForm(dAuxContent, 'Upload Board Image', 'bretter',
    filename => {
      if (!filename) console.log('cancel!');
      else console.log('file ' + filename + ' uploaded successfully!');
      closeAux();
    });
}
function onClickUploadPerlen() {
  openAux('upload perlen images');
  let form1 = new FileUploadForm(dAuxContent, 'Upload Perlen Images', 'perlen',
    filename => {
      if (!filename) console.log('cancel!')
      else console.log('file ' + filename + ' uploaded successfully!');
      closeAux();
    });
}
function onClickUseSettings() {
  S.settings.userBehaviors = false;
  S.settings.userStructures = false;
  S.settings.userSettings = true;
  S.settings.boardDetection = S_boardDetection = true;
  S.settings.deckDetection = S_deckDetection = true;
  S.settings.openTab = 'SettingsTab';
  redrawScreen();
}
function onClickVerify() { testEngine.verify(T); }
async function onClickVerifySoFar() { isTraceOn = false; verifySequence(0, testEngine.index, true); }
function onClickWordInput(ev) {
  return;
  if (!canAct()) return;
  ev.cancelBubble = true;
  let id = evToClosestId(ev);
  let iWord = Number(stringAfter(id, '_'));
  let g = Goal.words[iWord];
  if (nundef(g.hasBlanks) || !g.hasBlanks) return;
  deactivateFocusGroup();
  activateFocusGroup(g.iWord);
}
function onDraggingCloneAround(ev) {
  console.log('YES!')
  if (DragElem === null) return;
  console.log('ev', ev);
  let mx = ev.clientX;
  let my = ev.clientY;
  let dx = mx - DragElem.drag_info.offsetX;
  let dy = my - DragElem.drag_info.offsetY;
  mStyle(DragElem, { left: dx, top: dy });
}
function onDragLetter(ev) { console.log('YES!', ev.clientX, ev.clientY); }
function onDragStartOnLetter1(ev) {
  if (!canAct()) return;
  ev.preventDefault();
  let id = evToClosestId(ev);
  let source = mBy(id);
  if (isLetterElement(source)) {
    var clone = DragElem = source.cloneNode(true);
    clone.id = DragElem.id + '_' + clone;
    DragSource = source;
    mAppend(document.body, clone);
    mClass(clone, 'letter')
    mClass(clone, 'dragelem');
    mStyle(clone, { left: ev.clientX - ev.offsetX, top: ev.clientY - ev.offsetY });
    clone.drag_info = { offsetX: ev.offsetX, offsetY: ev.offsetY };
    clone.setAttribute('draggable', true);
    clone.ondrag = onDraggingCloneAround;
    document.body.ondragend = onReleaseLetter;
  }
}
function onDropLetter(ev) {
  let els = allElementsFromPoint(ev.clientX, ev.clientY);
  let inputs = DropZones;
  for (const inp of inputs) {
    if (els.includes(inp)) {
      inp.innerHTML = DragElem.innerHTML;
      if (startsWith(DragElem.id, 'input')) DragSource.innerHTML = '_';
      let w = buildWordFromLetters(inp.parentNode);
      if (!w.includes('_')) GC.evaluate(w, Goal.label.toUpperCase());
    }
  }
  DragElem.remove();
  DragElem = DragSource = null;
  document.body.ondrag = document.body.ondragend = null;
}
function one_value_cell_constraint(board) {
  updated = false
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      if (board[r][c] == 0) {
        updated = complete_cell(board, r, c) || updated
      }
    }
  }
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      if (Array.isArray(board[r][c])) {
        let possibilities = board[r][c]
        updated = appears_once_only(board, possibilities, get_row(board, r), r, c) ||
          appears_once_only(board, possibilities, get_column(board, c), r, c) ||
          appears_once_only(board, possibilities, get_square(board, square_coordinates[r][c]), r, c) || updated
      }
    }
  }
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      if (Array.isArray(board[r][c])) {
        board[r][c] = 0
      }
    }
  }
  return updated
}
function oneCircleCenters(rows, cols, wCell, hCell) {
  let [w, h] = [cols * wCell, rows * hCell];
  let cx = w / 2;
  let cy = h / 2;
  let centers = [{ x: cx, y: cy }];
  let n = 8;
  let radx = cx - wCell / 2;
  let rady = cy - hCell / 2;
  let peri = Math.min(radx, rady) * 2 * Math.PI;
  n = Math.floor(peri / Math.min(wCell, hCell));
  while (n > 4 && n % 4 != 0 && n % 6 != 0) n -= 1;
  centers = getEllipsePoints(radx, rady, n)
  centers = centers.map(pt => ({ x: pt.X + cx, y: pt.Y + cy }));
  return [centers, wCell * cols, hCell * rows];
}
function onEnterPerle(perle) {
  if (IsControlKeyDown) {
    iMagnify(perle);
  }
}
function oneWordKeys(keys) { return keys.filter(x => !x.includes(' ')); }
function onExistingPlayers(d) {
  prelude(getFunctionCallerName(), d);
  if (isError(d)) { restartHost(onHostStarted); return; }
  d = d.response;
  availablePlayers(onAvailablePlayers);
}
function onExitPerle() { if (IsControlKeyDown) iMagnifyCancel(); }
function onGameChosen(d) {
  prelude(getFunctionCallerName(), d);
  if (isError(d)) { restartHost(onHostStarted); return; }
  d = d.response;
  whichGame(onGameInfo);
}
function onGameInfo(d) {
  prelude(getFunctionCallerName(), d);
  if (isError(d)) { restartHost(onHostStarted); return; }
  d = d.response;
  S.gameInfo = d;
  let currentGame = S.gameInfo.name.toLowerCase();
  availablePlayers(onAvailablePlayers);
}
function onHostStarted(d) {
  pageHeaderClearPlayers();
  prelude(getFunctionCallerName(), d);
  if (isError(d)) throw 'CANNOT RESTART HOST!!!!!!!!!';
  d = d.response;
  S.plAddedByMe = {};
  selectGame(onGameChosen);
}
function onkeydownHandler(ev) {
  if (nundef(DA.keydown)) DA.keydown = {}; for (const k in DA.keydown) { DA.keydown[k](ev); }
}
function onkeyupHandler(ev) {
  if (nundef(DA.keyup)) DA.keyup = {};
  for (const k in DA.keyup) {
    DA.keyup[k](ev);
  }
}
function onKeyWordInput(ev) {
  let charEntered = ev.key.toString();
  if (!isAlphaNum(charEntered)) return;
  let ch = charEntered.toUpperCase();
  Selected = { lastLetterEntered: ch };
  let cands = Goal.blankChars;
  if (Goal.iFocus) {
    let word = Goal.words[Goal.iFocus];
    if (word.hasBlanks) cands = word.charInputs.filter(x => x.isBlank);
    else deactivateFocusGroup();
  }
  console.assert(!isEmpty(cands));
  let isLastOfGroup = (Goal.iFocus != null) && cands.length == 1;
  let isVeryLast = Goal.blankChars.length == 1;
  let target = firstCond(cands, x => x.letter == ch);
  let isMatch = target != null;
  if (!isMatch) target = cands[0];
  fillCharInput(target, ch);
  return { target: target, isMatch: isMatch, isLastOfGroup: isLastOfGroup, isVeryLast: isVeryLast, ch: ch };
}
function onLoginSubmitted(e) {
  e.preventDefault();
  let name = getInputValue('login');
  if (isEmpty(name)) name = chooseRandom(names);
  login(name);
}
function onMessageReceived(d) { if (!USE_SOCKETIO) return; processMessage(d); }
function onMouseDownOnLetter(ev) {
  if (!canAct()) return;
  ev.preventDefault();
  let id = evToClosestId(ev);
  let source = mBy(id);
  if (isLetterElement(source)) {
    var clone = DragElem = source.cloneNode(true);
    clone.id = DragElem.id + '_' + clone;
    DragSource = source;
    mAppend(document.body, clone);
    mClass(clone, 'letter')
    mClass(clone, 'dragelem');
    mStyleX(clone, { left: ev.clientX - ev.offsetX, top: ev.clientY - ev.offsetY });
    clone.drag = { offsetX: ev.offsetX, offsetY: ev.offsetY };
    document.body.onmousemove = onMovingCloneAround;
    document.body.onmouseup = onReleaseLetter;
  }
}
function onMovingCloneAround(ev) {
  if (DragElem === null) return;
  let mx = ev.clientX;
  let my = ev.clientY;
  let dx = mx - DragElem.drag.offsetX;
  let dy = my - DragElem.drag.offsetY;
  mStyle(DragElem, { left: dx, top: dy });
}
function onpagedeactivated(handler) {
  document.addEventListener('visibilitychange',
    () => {
      console.log('visibilityState', document.visibilityState);
      if (document.visibilityState !== 'visible') handler();
    });
}
function onPlayerAdded(d) {
  prelude(getFunctionCallerName(), d);
  if (isError(d)) { restartHost(onHostStarted); return; }
  d = d.response;
  let nap = S.availablePlayers.length - 1;
  let nMax = S.gameInfo.player_names.length;
  let nMin = arrMin(S.gameInfo.num_players);
  let nRegistered = nMax - nap;
  let mustBegin = (nap == 0);
  let canBegin = nRegistered >= nMin;
  if (canBegin) tryBegin(onBeginRequest);
  else enterWaitingLoop();
}
function onPlayerChange() {
  if (!G.playerChanged) return;
  let pid = G.player;
  let o = G.playersAugmented[pid];
  let ms = getVisual(pid);
  let msDef = getDefVisual(pid);
  let msHeader = getPageHeaderDivForPlayer(pid);
  msHeader.classList.add('gamePlayer')
  if (G.previousPlayer) {
    let msHeaderPrevious = getPageHeaderDivForPlayer(G.previousPlayer);
    msHeaderPrevious.classList.remove('gamePlayer');
  }
  if (ms) {
  }
  if (msDef) {
    let msParentId = msDef.parentId;
    let msParent = UIS[msParentId];
    var target = msDef.elem;
    target.parentNode.scrollTop = target.offsetTop;
  }
}
function onReleaseClone(ev) {
  let els = allElementsFromPoint(ev.clientX, ev.clientY);
  let source = DDInfo.source;
  let dSource = iDiv(source);
  let dropHandler = DDInfo.dropHandler;
  for (const target of DDInfo.targets) {
    let dTarget = iDiv(target);
    if (els.includes(dTarget)) {
      if (isdef(dropHandler)) {
        let cDrop = { x: ev.clientX, y: ev.clientY };
        let rTarget = getRect(dTarget);
        let cTarget = { x: rTarget.x + rTarget.w / 2, y: rTarget.y + rTarget.h / 2 };
        let [dx, dy] = [cDrop.x - cTarget.x, cDrop.y - cTarget.y];
        let [ddx, ddy] = [DragElem.drag.offsetX, DragElem.drag.offsetY];
        dropHandler(source, target, DragElem.isCopy, DragElem.clearTarget, dx, dy, ev, DragElem);
      }
      break;
    }
  }
  DragElem.remove();
  DragElem = null;
  document.body.onmousemove = document.body.onmouseup = null;
}
function onReleaseLetter(ev) {
  let els = allElementsFromPoint(ev.clientX, ev.clientY);
  let inputs = DropZones;
  for (const inp of inputs) {
    if (els.includes(inp)) {
      inp.innerHTML = DragElem.innerHTML;
      if (startsWith(DragElem.id, 'input')) DragSource.innerHTML = '_';
      let w = buildWordFromLetters(inp.parentNode);
      if (!w.includes('_')) GC.evaluate(w, Goal.label.toUpperCase());
    }
  }
  DragElem.remove();
  DragElem = DragSource = null;
  document.body.onmousemove = document.body.onmouseup = null;
}
function onselect_action(ev, r, action, uname) { let item = get_selected_ui_item(ev); select_action(r, action, uname, item); }
async function onTestSeriesChanged() {
  let series = mBy('selSeries').value;
  if (series == 'none') return;
  series = DIR_TESTS + '/' + series;
  console.log('series', series)
  await testEngine.loadSeries(series);
  onClickClearTable();
  onClickRepeatTest();
}
function onWhichGame(d) {
  prelude(getFunctionCallerName(), d);
  if (isError(d)) { restartHost(onHostStarted); return; }
  d = d.response;
  S.gameInfo = d;
  let currentGame = S.gameInfo.name.toLowerCase();
  if (currentGame == GAME) existingPlayers(onExistingPlayers);
  else restartHost(onHostStarted);
}
function open_game(uname, game, fen) {
  U = {};
  copyKeys(DB.users[uname], U);
  U.session = {};
  G = new (classByName(capitalize(game) + 'Multi'))(game, DB.games[game]);
  Settings = new SettingsClass(G, dAux);
  if (nundef(U.games[game])) {
    if (G.controllerType == 'solitaire') { U.games[game] = { nTotal: 0, nCorrect: 0, nCorrect1: 0, startlevel: 0 }; }
    else U.games[game] = {};
  }
  if (isdef(G.maxlevel)) G.level = Math.min(getUserStartLevel(game), G.maxlevel);
  if (G.id != 'gAristo') Settings.updateGameValues(U, G);
  showGameTitle();
  return G;
}
function open_game_options(gamename) { present_game_options(gamename); }
function open_game_ui() {
  clear_table_all();
  let hmin = firstNumber(getCssVar('--inner_left_panel_height'));
  mBy("inner_left_panel").innerHTML = `<div style='min-height:${hmin}px'>
  <div id="md" style="display: flex;min-height:${hmin}px">
    <div id="dLeftSide" style="align-self: stretch;min-height:${hmin}px"></div>
    <div id="dRightSide" style='min-height:${hmin}px'>
      <div id="table" class="flexWrap"></div>
    </div>
  </div></div>`;
  initTable();
  badges_off();
}
function open_invisible_input(ev) {
  if (ev.target.id != 'dTable') return;
  let [x, y] = [ev.offsetX, ev.offsetY];
  y = toModulo(y - 10, 20, 0, mStyleGet(dTable, 'h') - 47);
  x = toModulo(x, 50);
  add_edit(x, y);
}
function open_mini_user_info() {
  setTimeout(() => {
    mBy('user_info_mini').style.display = 'flex';
  }, 500);
}
function open_player_editor(ev) {
  console.log('ev', ev)
  let id = evToId(ev);
  console.log('open player editor for player ', id);
  let uname = id.substring(4);
  let game = Session.cur_game;
  console.log('player is', uname);
  let res = prompt(`enter [level lang] for player ${uname}: `);
  console.log('user entered', res);
  if (nundef(res) || isEmpty(res)) return;
  let parts = splitAtAnyOf(res, ' ,');
  let level = 'none', lang = 'none';
  if (parts.length >= 1) { level = set_startlevel(uname, game, Number(parts[0])); }
  if (parts.length >= 2) { lang = set_preferred_lang(uname, parts[1]); }
  console.log('selected language', lang, 'and level', level);
  console.log('should save DB', DB.users[uname]);
  if (isdef(DB.users[uname])) db_save();
  populate_players(Session.game_options.players);
}
function open_prompt() {
  console.assert(!uiActivated, 'open_prompt with uiActivated ON !!!!!!!!!!!!!!!!!!!!!!!!!!');
  let game = Session.cur_game;
  let uname = Session.cur_user;
  let g = Session;
  let next = lookup(DB.games, [game]); if (next) copyKeys(next, g);
  next = lookup(DB.users, [uname, 'games', game]); if (next) copyKeys(next, g);
  let level = g.level = valf(g.startlevel, g.def_startlevel);
  lookupSet(DB.users, [uname, 'games', game, 'startlevel'], level);
  next = lookup(DB.games, [game, 'levels']);
  if (next) copyKeys(next[level], g);
  g.maxlevel = valf(get_keys(next).length, 0) - 1;
  g.color = getColorDictColor(g.color);
  for (const k in g.options) {
    g[k] = get_game_option(g, k); //'winning_score'); 
    console.log('g.' + k, g[k]);
  }
  delete g.levels;
  clearTable(); set_background_color(g.color);
  QContextCounter += 1;
  show_game_name(g.friendly);
  show_title(g.table.friendly);
  show_level(g.level, g.maxlevel);
  if (Session.is_badges) setBadgeLevel(g.level);
  g.startTime = get_timestamp();
  mLinebreak(dTable, 15);
  let items = g.items = spotit_deal(g.num_cards, g.rows, g.cols, g.vocab, g.lang, g.min_scale, g.max_scale);
  Selected = null;
  uiActivated = true;
}
function open_sidebar() {
  DA.left_panel = 'open';
  mBy('left_panel').style.flex = 1;
}
function open_table_dep(tid) {
  let t = DB.tables[tid];
  Session.cur_tid = tid;
  makemove();
}
function openAux(title, button) {
  resetActiveButton();
  show(dAux);
  clearElement(dAuxContent);
  dAuxTitle.innerHTML = title;
  if (isdef(button)) setActiveButton(button);
}
function openCity(evt, cityName) {
  var i, tabcontent, tablinks;
  tabcontent = document.getElementsByClassName('tabcontent');
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = 'none';
  }
  tablinks = document.getElementsByClassName('tablinks');
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(' active', '');
  }
  document.getElementById(cityName).style.display = 'block';
  evt.currentTarget.className += ' active';
}
function openGameConfig() {
  ensureAllGames([proceedToConfig]);
}
function openInfobox(ev, mobj, part) {
  let oid = getOidForMainId(mobj.id);
  if (!oid) return;
  let id = makeIdInfobox(oid);
  let ibox = UIS[id];
  if (ibox) {
    let elem = ibox.elem;
    if (isVisible(elem)) {
      hide(elem);
    } else {
      show(elem);
    }
  } else {
    let msInfobox = makeInfobox(mobj.id, oid, G.table[oid]);
    let area = UIS['a_d_game'];
    let pos = calcMainVisualPosCenterInGameArea(mobj)
    msInfobox.setPos(pos.x, pos.y);
  }
}
function openInfoboxesForBoatOids(boat) {
  let oids = boat.o.oids;
  let mainIds = oids.map(x => getMainId(x));
  for (const id of mainIds) {
    let ms = UIS[id];
    openInfobox(null, ms);
  }
}
function openJoinConfig() {
  hideEventList();
  showJoinConfig();
  setMessage('Join the game!');
  hide('bJoinGame');
  hide('bCreateGame');
  show('bLobbyJoinOk');
  show('bLobbyJoinCancel');
  show('bResumeGame');
  populateJoinList();
  joinCandidate = null;
}
function openLeftPane() {
  if (paneOpen) return 0;
  let right = mBy('dInnerRight');
  mStyle(right, { flex: 0 });
  paneOpen = true;
  return DELAY_PANE;
}
function openLogin() {
  show(dLogin); hide(dLobby); hide(dGameScreen);
  loginBtn.onclick = e => {
    e.preventDefault();
    if (!usernameInput.value) { return console.log('Must supply a username'); }
    let username = usernameInput.value;
    username = username.toLowerCase();
    localStorage.setItem('username', username);
    establishUsername(username);
  };
  document.body.style.opacity = 1;
}
function openSettings() { show(dSettings); pauseUI(); }
function openSocket() {
  if (!USE_SOCKETIO) return;
  if (socket != null) { socket.open(); return; }
  socket = io.connect(SERVER_URL);
  socket.on('connect', () => { socket.emit('message', 'User ' + clientData.name + ' has connected!'); });
  socket.on('message', onMessageReceived);
  socket.on('chat', onChatReceived);
}
function openTab(button) {
  var i, tabcontent, tablinks;
  let selected = button.textContent + 'Tab';
  tabcontent = document.getElementsByClassName('tabcontent');
  for (i = 0; i < tabcontent.length; i++) { tabcontent[i].style.display = 'none'; }
  tablinks = document.getElementsByClassName('tablinks');
  for (i = 0; i < tablinks.length; i++) { tablinks[i].className = tablinks[i].className.replace(' active', ''); }
  document.getElementById(selected).style.display = 'block';
  button.className += ' active';
}
function openTabTesting(cityName) {
  var i, tabcontent, tablinks;
  tabcontent = document.getElementsByClassName('tabcontent');
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = 'none';
  }
  tablinks = document.getElementsByClassName('tablinks');
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(' active', '');
  }
  document.getElementById('a_d_' + cityName).style.display = 'block';
  document.getElementById('c_b_' + cityName).className += ' active';
}
function openToolbar() {
  let d = mBy('dLeiste');
  show(d);
  mStyleX(d, { w: 100 });
  Toolbar = new ToolbarClass(d);
}
function optionsFor(me) {
  Options = {};
  Options.play = { f: () => { playsCard(me, me.hand.topCard(), me.hand, T.trick, true); evaluate(); } };
  setTimeout(Options.play.f, 2000);
}
function orderFromTo(lst, fromOrder, toOrder) {
  let res = [];
  for (let i = 0; i < lst.length; i++) {
    res.push(lst[fromOrder.indexOf(toOrder[i])]);
  }
  testHelpers(res);
  return res;
}
function ordinal_suffix_of(i) {
  var j = i % 10,
    k = i % 100;
  if (j == 1 && k != 11) {
    return i + "st";
  }
  if (j == 2 && k != 12) {
    return i + "nd";
  }
  if (j == 3 && k != 13) {
    return i + "rd";
  }
  return i + "th";
}
function oscillate_between(x, min, max, step) {
  x += step;
  if (x <= min || x >= max) step = -step;
  return [x, step];
}
function oscillator(item) {
  let [astep, a, bstep, b, basefunc] = [item.astep, item.a, item.bstep, item.b, item.basefunc];
  [a, astep] = oscillate_between(a, 0, 5, astep);
  [b, bstep] = oscillate_between(b, 0, 5, bstep);
  [item.astep, item.a, item.bstep, item.b] = [astep, a, bstep, b];
  item.func = x => b * basefunc(a * x);
  return true;
}
function otree2cur_players(otree) {
  Session.cur_players = {};
  for (const uname of otree.plorder) {
    Session.cur_players[uname] = otree[uname];
  }
  return Session.cur_players;
}
function ouparams() {
  for (const uid in R.uiNodes) {
    let n = R.uiNodes[uid];
    console.log(n.uid + ':', n.params);
  }
}
function oupos() {
  for (const uid in R.uiNodes) {
    let n = R.uiNodes[uid];
    console.log(n.uid + ':position', n.params.position, 'size', n.size, 'pos', n.pos);
  }
}
function out1() {
  let game = Session.cur_game;
  let msg = 'stats:score wins total\n';
  for (const x in Session.cur_players) {
    let pl = Session.cur_players[x];
    let info = DB.users[x].games[game];
    msg += `${x}: ${pl.score} ${info.wins} ${info.total}\n`;
  }
  console.log(msg);
}
function output_arr_short(arr) {
  console.log('output_arr_short', getFunctionsNameThatCalledThisFunction());
  console.log('deck top 3', jsCopy(arrTake(arr, 3))); console.log('deck bottom 3', jsCopy(arrTakeLast(arr, 3)));
}
function output_error(msg) { dError.innerHTML = msg; }
function output_loose_and_journeys(fen) {
  for (const j of fen.journeys) { console.log('journey', j.join(', ')); }
  for (const plname in fen.players) { console.log('loosecards', plname, fen.players[plname].loosecards.join(', ')); }
}
function output_scores() {
  let fen = Z.fen;
  for (const plname in fen.players) {
    let pl = fen.players[plname];
  }
}
function outputCombatData(title, data, H) {
  let c = data.temp.combat;
  let sCombat = c == undefined ? 'undef' : c.stage + ', battles: ' + Object.keys(c.battles).toString();
  let sBattle = c == undefined || c.battle == undefined ? 'undef' : c.battle.stage + ', loc: ' + c.battle.tilename;
}
function outputContent(content) {
  if (content.type == 'list') {
    console.log('list of', content.elType, content.content);
  } else {
    console.log('content', content);
  }
}
function outputPlayerUnits(pl, H) {
  let dObjects = dict2list(H.objects, 'id');
  dObjects = dObjects.filter(x => x.obj_type == 'unit');
  let unitsPlayer = dObjects.filter(x => getUnitOwner(x.nationality) == pl);
  sortBy(unitsPlayer, 'tile');
  console.log(pl);
  for (const u of unitsPlayer) {
    console.log(u.type, u.type == 'Fleet' || u.type == 'Tank' ? '\t\t' : '\t', u.cv, '\t', u.tile, u.id);
  }
}
function outputUpdatedScenario(decider, player = false) {
  sc = decider.scenario;
  reqs = '';
  if (decider.decisionMode == 'scenario') {
    for (const pl of ['Axis', 'West', 'USSR']) {
      if (pl in decider.scenario.items) {
        if (player && player != pl) continue;
        reqs += pl + '\n';
        for (const x of decider.scenario.items[pl]) {
          reqs += '  goal=(' + x.goalTile + ',' + x.goalCv + ') ' + x.type + ' ' + x.id;
          if (x.unit) reqs += ' ' + x.unit.tile + ' ' + x.unit.cv;
          reqs += '\n';
        }
      }
      if (pl in decider.scenario.diplItemsTodo) {
        reqs += pl + '\n';
        for (const nat in decider.scenario.diplItemsTodo[pl]) {
          let ist = lookup(decider.scenario.diplItems, [pl, nat]);
          ist = ist ? ist : 0;
          reqs += '  ' + nat + ': ' + decider.scenario.diplItemsTodo[pl][nat] + ' (is ' + ist + ')';
          reqs += '\n';
        }
      }
    }
    if (!empty(decider.scenario.satellites)) {
      reqs += '\nsatellites:\n';
      for (const n in decider.scenario.satellites) {
        reqs += '  ' + n + ': ' + decider.scenario.satellites[n] + '\n';
      }
    }
    reqs += 'done: ' + decider.scenario.done;
    unitTestScenario(reqs);
  }
}
function outype() {
  for (const uid in R.uiNodes) {
    let n = R.uiNodes[uid];
    console.log(n.uid + ':', n.type);
  }
}
function pack_table(o) {
  for (const k of ['players', 'fen', 'state', 'player_status', 'options', 'scoring', 'notes', 'turn']) {
    let val = o[k];
    if (isdef(val)) o[k] = JSON.stringify(val);
  }
  return JSON.stringify({ table: o, playerdata: JSON.stringify(o.playerdata) });
}
function packageState() {
  let st = G.state;
  let state = { boardArr: st.boardArr, poolArr: st.poolArr, pool: {} };
  for (const k in st.pool) {
    let oNew = state.pool[k] = {};
    copyKeys(st.pool[k], oNew, {}, ['index', 'key']);
  }
  let pack = { settings: jsCopy(G.settings), state: state, randomIndices: jsCopy(G.randomIndices) };
  return pack;
}
function padSep(sep, n, args) {
  s = '';
  for (var i = 2; i < arguments.length; i++) {
    s += arguments[i].toString().padStart(n, '0') + sep;
  }
  return s.substring(0, s.length - 1);
}
function pageHeaderAddPlayer(username, playerId, color, asMe = false) {
  let divPlayerNames = document.getElementById('a_d_divPlayerNames');
  divPlayerNames.insertAdjacentHTML('beforeend', pageHeaderGetPlayerHtml(username, playerId, color, asMe));
}
function pageHeaderClearAll() {
  pageHeaderClearPlayers();
  pageHeaderClearGame();
}
function pageHeaderClearGame() {
  UIS['a_d_divGamename'].clear();
}
function pageHeaderClearPlayers() {
  UIS['a_d_divPlayerNames'].clear({ innerHTML: '<div style="float:left">Players:&nbsp;</div>' });
}
function pageHeaderGetPlayerHtml(username, playerId, color, asMe) {
  let spl = `<div id='c_c_${username}' class='playerHeader'><div>${username}</div><div style='color:${color}'>${playerId}</div></div>`
  return spl;
}
function pageHeaderInit() { pageHeaderSetGame(); pageHeaderSetPlayers(); }
function pageHeaderSetGame() {
  let divGamename = document.getElementById('a_d_divGamename');
  divGamename.innerHTML = `<div style='float:right;margin:14px'><b>${allGames[GAME].name}</b><br>(${PLAYMODE})</div>`;
}
function pageHeaderSetPlayers() {
  let divPlayerNames = document.getElementById('a_d_divPlayerNames');
  let s = '<div style="float:left">Players:&nbsp;</div>';
  for (const pid in G.playersAugmented) {
    let pl = G.playersAugmented[pid];
    spl = pageHeaderGetPlayerHtml(pl.username, pid, pl.color, pl.isMe);
    s += spl;
  }
  divPlayerNames.innerHTML = s;
}
function pageHeaderUpdatePlayer(plid) {
  let mk;
  for (const pl in playerConfig[GAME].players) {
    mk = getPageHeaderDivForPlayer(pl);
    mk.classList.remove('gamePlayer');
  }
  mk = getPageHeaderDivForPlayer(plid);
  mk.classList.add('gamePlayer');
}
function pageLayout33() {
  var dMain = document.getElementById('dMain');
  let dHeader = mDiv(dMain, { bg: 'random' }, 'dHeader', 'header');
  let dOuter = mDiv(dMain, { bg: 'random', flex: '1 0 auto', display: 'flex', 'flex-flow': 'row wrap' });
  let dLeft = mDiv(dOuter, { bg: 'random', flex: '0 0 200px' }, 'dLeft', 'left');
  let dMiddle = mDiv(dOuter, { bg: 'random', flex: '1 0 auto' }, 'dMiddle', 'middle');
  let dRight = mDiv(dOuter, { bg: 'random', flex: '0 0 200px' }, 'dRight', 'right');
  let dFooter = mDiv(dMain, { bg: 'random' }, 'dFooter', 'footer');
  return {
    dHeader: dHeader,
    dLeft: dLeft,
    dRight: dRight,
    dMiddle: dMiddle,
    dFooter, dFooter
  }
}
function paint(dParent, r, color = 'random') {
  let d = mDiv(dParent, { position: 'absolute', left: r.x, top: r.y, w: r.w, h: r.h, bg: color });
  return d;
}
function paint_game(state) {
  let [wgreen, wred] = [state.green.pos, state.red.pos];
  dgreen.style.width = wgreen + '%';
  dred.style.width = wred + '%';
}
function paletteFromColor(c, a = 1) {
  if (Array.isArray(c)) return paletteFromRGBArray(c);
  let hsl = standardizeToHsl(c);
  let pal = gen_palette(hsl.h, 1, hsl.s * 100, a);
  return pal;
}
function paletteFromRGBArray(arr) {
  let hsl = rgbToHsl(arr[0], arr[1], arr[2]);
  let hue1 = hsl[0] * 360;
  sat = Math.round(hsl[1] * 100);
  let hsv = rgbToHsv(arr[0], arr[1], arr[2]);
  let hue2 = hsv.h;
  let hue = hue1;
  let result = gen_palette(hue, 1, sat);
  return result;
}
function panel(areaName, oSpec, oid, o) {
  let [num, or, split, bg, fg, id, panels, parent] = getParams(areaName, oSpec, oid);
  if (num > 0) {
    parent.style.display = 'grid';
    clearElement(parent);
    for (let i = 0; i < num; i++) {
      let d = mDiv100(parent);
      d.id = getUID();
      if (panels.length > i) {
        if (oid) dynamicArea(d.id, panels[i], oid, o); else staticArea(d.id, panels[i]);
      }
    }
    if (or == 'rows') {
      console.log('====', split * 100);
      parent.style.gridTemplateColumns = `${split * 100}% 1fr`;
    }
  }
  return parent;
}
function Panel() {
  var self = this;
  this.div = document.getElementById("dTable");
  this.receptors = new Array();
  this.numbers = new Array();
  this.drags = new Array();
  this.dragX = 0;
  this.dragY = 0;
  this.start = function () {
    self.createNumbers(5);
  }
  this.createReceptors = function (num) {
    var w = 100;
    var h = 30;
    for (i = 0; i < num; i++) {
      self.createReceptor("r" + String(i), 64 * i, 120, w, h);
    }
  }
  this.createReceptor = function (id, l, t, w, h) {
    var div = createDroppable(id, "receptorclass", l, t, w, h);
    var receptor = new Receptor(div, self);
    self.receptors.push(receptor);
    self.div.appendChild(div);
    return (receptor);
  }
  this.createNumbers = function (num) {
    var w = 100;
    var offset = 10;
    for (i = 0; i < num; i++) {
      var randomnumber = Math.floor(Math.random() * 11)
      self.createNumber("n" + String(i), randomnumber, (w + offset) * i, 0, w);
    }
  }
  this.createNumber = function (id, n, l, t, w) {
    var div = createDraggable(id, "numberclass", l, t, w, String(n));
    var number = new Number(div, self, n);
    self.numbers.push(number);
    self.div.appendChild(div);
    return (number);
  }
}
function panelLayout(n, R) {
  let params = n.params;
  let num = n.children.length;
  let or = params.orientation ? params.orientation : DEF_ORIENTATION;
  mFlex(n.ui, or);
  let split = params.split ? params.split : DEF_SPLIT;
  if (split == 'min') {
    let b = getBounds(n.ui, true);
    return { w: b.width, h: b.height };
  }
  let reverseSplit = false;
  if (split == 'equal') split = (1 / num);
  else if (isNumber(split)) reverseSplit = true;
  for (let i = 0; i < num; i++) {
    let d = R.uiNodes[n.children[i]].ui;
    mFlexChildSplit(d, split);
    if (reverseSplit) { split = 1 - split; }
  }
  let b = getBounds(n.ui, true);
  return { w: b.width, h: b.height };
}
function param_present_contacts(obj, dParent, onclick_func_name) {
  let others = sync_users(obj.users);
  Session.others = others.map(x => x.name);
  let msgs = valf(obj.msgs, {});
  let mydata = `
  <style>
    @keyframes appear{
      0%{opacity:0;transform: translateY(50px)}
      100%{opacity:1;transform: translateY(0px)}
     }
     .contact{
       cursor:pointer;
       transition: all .5s cubic-bezier(0.68, -2, 0.265, 1.55);
     }
     .contact:hover{
       transform: scale(1.1);
     }
  </style>
  <div style="text-align: center; animation: appear 1s ease both">
  `;
  let mydata_list = '';
  for (const r of others) {
    row = r;
    let image = get_image_path(row);
    let mydata_element = `
        <div class='contact' style='position:relative;text-align:center;margin-bottom:18px;' username='${row.name}' 
          onclick='${onclick_func_name}(event)'>
          <img src='${image}' draggable='true' ondragstart='drag(event)' class='img_person sz100' style='margin:0;'/>
          <br>${row.name}`;
    if (isdef(msgs[row.username])) {
      mydata_element += `<div style='width:20px;height:20px;border-radius:50%;background-color:orange;color:white;position:absolute;left:0px;top:0px;'>` + msgs[row.username] + "</div>";
    }
    mydata_element += "</div>";
    mydata_list += mydata_element;
  }
  mydata += mydata_list;
  dParent.innerHTML = mydata;
}
function paramsToCss(params) {
  let res = { css: {}, std: {}, typ: {} };
  for (const k in params) {
    if (k == 'font') {
      let f = getFontString(params.font);
      if (f) res.css.font = f;
    }
    let rsgParam = PARAMRSG_T[k];
    if (isdef(rsgParam)) if (rsgParam) res.typ[k] = params[k]; else res.std[k] = params[k];
    else {
      let name = PARAMCSS[k];
      if (isdef(name)) {
        res.css[name] = params[k];
      } else {
        res.css[k] = params[k];
      }
    }
  }
  return res;
}
function parentHasChannelForThisOid(n, oid) {
  let channels = n.channels;
  if (nundef(channels)) return true;
}
function parentHasThisChildAlready(uidParent, oid) {
  let n = R.rNodes[uidParent];
  if (nundef(n.children)) return false;
  let hasThisChild = false;
  for (const chuid of n.children) {
    if (R.rNodes[chuid].oid == oid) { hasThisChild = true; break; }
  }
  return hasThisChild;
}
function parse_fen(fen) {
  let parts = fen.split(':');
  let opt = parts[0];
  let glob = parts.length > 1 ? parts[1] : null;
  let pls = [];
  for (let i = 2; i < parts.length; i++) {
    pls.push(parts[i]);
  }
  return { opt: opt, glob: glob, pls: pls };
}
function parse_table(t) {
  set_start_data_from_fen(t.fen, S.game);
  if (isString(t.options)) t.options = JSON.parse(t.options);
  S.players = t.players.map(x => ({ name: x, color: getColorDictColor(DB.users[x].color), imgPath: `../base/assets/images/${x}.jpg`, score: 0 }));
  S.players_by_name = arr_to_dict_by(S.players, 'name');
  S.game = t.game;
  S.tid = t.id;
  S.table = t;
}
function parse_table_and_players(obj) {
  console.log('parse_table', obj.table);
  parse_table(obj.table);
  for (const pl of S.players) copyKeys(obj.players, pl);
}
function parseCodefile(content, fname, preserveRegionNames = true, info = {}, superdi = {}) {
  let defaultRegions = { cla: 'classes', func: 'funcs' };
  let lines = content.split('\r\n');
  let parsing = false, code, type, key, regionName, regionOrig;
  let firstletters = [], firstWords = [], iline = 0;
  for (const line of lines) {
    let l = line; iline += 1;
    if (!l.includes("'//") && !l.includes("//'") && !l.includes("http")) {
      l = replaceAllFast(line, '://', '://');
      l = replaceAllFast(l, '//#', '@@#');
      l = stringBefore(l, '//');
      l = replaceAllFast(l, '@@#', '//#');
      l = replaceAllFast(l, '://', '://');
    }
    if (isEmptyOrWhiteSpace(l.trim())) continue;
    if (parsing) {
      let l1 = replaceAllSpecialChars(l, '\t', '  ');
      let ch = l1[0];
      if (' }]'.includes(ch)) code += l1 + '\r\n';
      if (ch != ' ') {
        parsing = false;
        if (nundef(regionName)) { regionName = regionOrig = valf(defaultRegions[type], type); }
        let regKey = preserveRegionNames ? regionOrig : `${regionName} (${fname})`;
        let sig;
        if (type == 'cla') {
          sig = `class ${key}{}`;
        } else if (type == 'func') {
          let firstline = stringBefore(code, '\r\n');
          if (firstline.includes(') {')) sig = stringBefore(firstline, ') {') + ')';
          else if (firstline.includes('){')) sig = stringBefore(firstline, '){') + ')';
          else sig = `function ${key}()`;
          sig += '{}';
        } else { sig = `${type} ${key}`; }
        let o = { name: key, code: code, sig: sig, region: regKey, filename: fname, type: type };
        addKeys(info, o);
        type = checkKey(superdi, key, type);
        if (type) lookupSetOverride(superdi, [type, key], o);
        addOnelineVars(superdi, o);
        addIf(firstletters, l[0]);
      }
    } else {
      let w = l[0] != '/' ? firstWord(l) : l.substring(0, 3);
      addIf(firstWords, w);
      //if (!['onload', 'async', 'function', 'class', 'var', 'const', '//#'].includes(w)) { console.log('line', iline, w, l[0]); }
    }
    if (parsing) continue;
    if (startsWith(l, '//#region')) {
      regionOrig = stringAfter(l, 'region').trim();
      regionName = firstWordAfter(l, 'region', true);
    } else if (startsWith(l, 'var')) {
      key = firstWordAfter(l, 'var', true);
      parsing = true;
      code = l + '\r\n';
      type = 'var';
    } else if (startsWith(l, 'const')) {
      key = firstWordAfter(l, 'const', true);
      parsing = true;
      code = l + '\r\n';
      type = 'const';
    } else if (startsWith(l, 'class')) {
      key = firstWordAfter(l, 'class', true);
      parsing = true;
      code = l + '\r\n';
      type = 'cla';
    } else if (startsWith(l, 'async') || startsWith(l, 'function')) {
      key = stringBefore(stringAfter(l, 'function').trim(), '(');
      parsing = true;
      code = l + '\r\n';
      type = 'func';
    }
  }
  return superdi;
}
function parseCodefile1(content, fname, preserveRegionNames = true, info = {}, superdi = {}) {
  let lines = content.split('\r\n');
  let parsing = false;
  let code, type, key, star, sig;
  let multicomment = false;
  let iline = 0;
  for (const line of lines) {
    iline++;
    let l = removeCommentsFromLine(line); if (isEmptyOrWhiteSpace(l.trim())) continue;
    if (l.trim().startsWith('/*')) multicomment = true;
    if (multicomment) {
      if (l.trim().endsWith('*/')) multicomment = false;
      continue;
    }
    if (parsing) {
      let l1 = replaceAllSpecialChars(l, '\t', '  ');
      let ch = l1[0];
      if (' }]'.includes(ch)) code += l1 + '\r\n';
      if (ch != ' ') {
        parsing = false;
        let o = { name: key, code: code, sig: sig, region: type, filename: fname, type: type };
        addKeys(info, o);
        if (o.type == 'var' && o.fname == 'chess.js' && o.name.startsWith('brd_')) { lookupSet(superdi, ['chessvar', o.name], true); }
        if (type == 'var') addOnelineVars(superdi, o);
        lookupSetOverride(superdi, [type, key], o);
      }
    }
    if (startsWith(l, 'async') || startsWith(l, 'function')) {
      key = stringBefore(stringAfter(l, 'function').trim(), '(');
      if (key.startsWith('*')) { star = true; key = stringAfter(key, '*').trim(); } else star = false;
      parsing = true;
      code = l + '\r\n';
      type = 'func';
      sig = getFunctionSignature(l, key);
    } else if (startsWith(l, 'class')) {
      key = firstWordAfter(l, 'class', true);
      parsing = true;
      code = l + '\r\n';
      type = 'cla';
      sig = `class ${key}{}`;
    } else if (startsWith(l, 'const')) {
      key = firstWordAfter(l, 'const', true);
      parsing = true;
      code = l + '\r\n';
      type = 'const';
      sig = `const ${key};`;
    } else if (startsWith(l, 'var')) {
      key = firstWordAfter(l, 'var', true);
      parsing = true;
      code = l + '\r\n';
      type = 'var';
      sig = `var ${key};`;
    }
  }
  return superdi;
}
function parseComplexStyleProperty(str) {
  var regex = /(\w+)\((.+?)\)/g,
    transform = {},
    match;
  while (match = regex.exec(str))
    transform[match[1]] = match[2];
  return transform;
}
function parseDictionaryName(s) {
  if (nundef(s)) return null;
  let o_keys = s.split('.');
  if (isEmpty(o_keys)) return null;
  odict = window[o_keys[0]];
  if (!odict || typeof odict != 'object') return null;
  if (o_keys.length > 1) odict = lookup(odict, o_keys.slice(1));
  return odict;
}
function parseDynamicSpec() {
  let sp = jsCopy(SPEC.dynamicSpec);
  geht(sp);
  dynSpec = sp;
  let pool = POOLS.augData;
  for (const oid in pool) {
    let o = pool[oid];
    let info = INFO[oid];
    if (nundef(info) || nundef(info.loc)) {
      continue;
    }
    let loc = info.loc;
    let areaName = getDynId(info.loc, oid);
    if (!AREAS[areaName]) {
      let uiNode = AREAS[loc];
      let group = info.pool;
      prepParentForChildren(loc, group.length);
      for (const oid of group) {
        addPanel(loc, oid);
      }
    }
  }
  for (const oid in pool) {
    let o = pool[oid];
    let info = INFO[oid];
    if (nundef(info) || nundef(info.loc)) continue;
    let loc = info.loc;
    let areaName = getDynId(info.loc, oid);
    console.log(areaName)
    dynamicArea(areaName, info, oid, o);
    let propName = info.type == 'panel' ? 'panels'
      : info.type == 'list' ? 'elm' : 'data';
    let oEinhaengen = AREAS[areaName];
    if (nundef(oEinhaengen[propName])) oEinhaengen[propName] = [];
    oEinhaengen[propName].push(info);
    console.log(oid, info);
    for (const k in info) {
      let parts = k.split('.');
      let s = parts[0];
      let n = parts.length;
      if (n == 1 && k != 'elm' && k != 'data') continue;
      let leaf = parsePath(parts, info[k], info);
    }
    console.log(info)
    continue;
  }
  return;
  for (const k in sp) {
    let node = sp[k];
    let loc = node.loc;
    if (loc && AREAS[loc]) {
      if (k == 'all_opps') {
        console.log('habe area fuer', k);
      }
      let nParent = AREAS[loc];
      let nChild = node;
      if (nChild.panels) {
        let hybrid = {};
        let num = nChild.pool.length;
        let params = nParent.params;
        params.num = num;
        nParent.panels = nChild.panels;
        hybrid.params = params;
        let panels = nChild.panels;
        if (k == 'opp_info') {
        }
        for (const oid of nChild.pool) {
          let o = pool[oid];
          let otherKeys = o.RSG;
          if (k == 'opp_info') {
          }
          for (const k2 of otherKeys) {
            panel
          }
        }
      }
    }
  }
}
function parseDynamicSpec1() {
  let sp = jsCopy(SPEC.dynamicSpec);
  POOLS.augData = makeDefaultPool(sData);
  annotate(sp);
  dynSpec = sp;
  let pool = POOLS.augData;
  for (const k in sp) {
    let node = sp[k];
    if (node.loc) {
      let group = node.pool;
      if (isEmpty(group)) continue;
      let loc = node.loc;
      let uiNode = AREAS[loc];
      prepParentForChildren(loc, group.length);
      for (const oid of group) {
        addPanel(loc, oid);
      }
    }
  }
  for (const oid in pool) {
    let o = pool[oid];
    if (nundef(o.RSG)) continue;
    let merged = mergeDynSetNodes(o);
    if (oid == 'Player2') {
    }
    if (!merged.type || !PROTO[merged.type]) continue;
    let info = jsCopy(PROTO[merged.type]);
    if (oid == 'Player2') {
    }
    let areaName = getDynId(merged.loc, oid);
    dynamicArea(areaName, info, oid, o);
    let propName = info.type == 'panel' ? 'panels'
      : info.type == 'list' ? 'elm' : 'data';
    let oEinhaengen = AREAS[areaName];
    if (nundef(oEinhaengen[propName])) oEinhaengen[propName] = [];
    oEinhaengen[propName].push(info);
  }
}
function ParseFen(fen) {
  var rank = RANKS.RANK_8;
  var file = FILES.FILE_A;
  var piece = 0;
  var count = 0;
  var i = 0;
  var sq64 = 0;
  var sq120 = 0;
  var fenCnt = 0;
  ResetBoard();
  while ((rank >= RANKS.RANK_1) && fenCnt < fen.length) {
    count = 1;
    switch (fen[fenCnt]) {
      case 'p': piece = PIECES.bP; break;
      case 'r': piece = PIECES.bR; break;
      case 'n': piece = PIECES.bN; break;
      case 'b': piece = PIECES.bB; break;
      case 'k': piece = PIECES.bK; break;
      case 'q': piece = PIECES.bQ; break;
      case 'P': piece = PIECES.wP; break;
      case 'R': piece = PIECES.wR; break;
      case 'N': piece = PIECES.wN; break;
      case 'B': piece = PIECES.wB; break;
      case 'K': piece = PIECES.wK; break;
      case 'Q': piece = PIECES.wQ; break;
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
        piece = PIECES.EMPTY;
        count = fen[fenCnt].charCodeAt() - '0'.charCodeAt();
        break;
      case '/':
      case ' ':
        rank--;
        file = FILES.FILE_A;
        fenCnt++;
        continue;
      default:
        printf("FEN error \n");
        return;
    }
    for (i = 0; i < count; i++) {
      sq64 = rank * 8 + file;
      sq120 = SQ120(sq64);
      if (piece != PIECES.EMPTY) {
        brd_pieces[sq120] = piece;
      }
      file++;
    }
    fenCnt++;
  }
  brd_side = (fen[fenCnt] == 'w') ? COLOURS.WHITE : COLOURS.BLACK;
  fenCnt += 2;
  for (i = 0; i < 4; i++) {
    if (fen[fenCnt] == ' ') {
      break;
    }
    switch (fen[fenCnt]) {
      case 'K': brd_castlePerm |= CASTLEBIT.WKCA; break;
      case 'Q': brd_castlePerm |= CASTLEBIT.WQCA; break;
      case 'k': brd_castlePerm |= CASTLEBIT.BKCA; break;
      case 'q': brd_castlePerm |= CASTLEBIT.BQCA; break;
      default: break;
    }
    fenCnt++;
  }
  fenCnt++;
  if (fen[fenCnt] != '-') {
    file = fen[fenCnt].charCodeAt() - 'a'.charCodeAt();
    rank = fen[fenCnt + 1].charCodeAt() - '1'.charCodeAt();
    console.log("fen[fenCnt]:" + fen[fenCnt] + " File:" + file + " Rank:" + rank);
    brd_enPas = FR2SQ(file, rank);
  }
  brd_posKey = GeneratePosKey();
  UpdateListsMaterial();
}
function parseHand(keys, deck) {
  let h1 = keys.map(x => Card52._fromKey(x));
  if (isdef(deck)) h1.map(x => deck.remove(x));
  return h1;
}
function ParseMove(from, to) {
  GenerateMoves();
  var Move = NOMOVE;
  var PromPce = PIECES.EMPTY;
  var found = BOOL.FALSE;
  for (index = brd_moveListStart[brd_ply]; index < brd_moveListStart[brd_ply + 1]; ++index) {
    Move = brd_moveList[index];
    if (FROMSQ(Move) == from && TOSQ(Move) == to) {
      PromPce = PROMOTED(Move);
      if (PromPce != PIECES.EMPTY) {
        if ((PromPce == PIECES.wQ && brd_side == COLOURS.WHITE) || (PromPce == PIECES.bQ && brd_side == COLOURS.BLACK)) {
          found = BOOL.TRUE;
          break;
        }
        continue;
      }
      found = BOOL.TRUE;
      break;
    }
  }
  if (found != BOOL.FALSE) {
    if (MakeMove(Move) == BOOL.FALSE) {
      return NOMOVE;
    }
    TakeMove();
    return Move;
  }
  return NOMOVE;
}
function parsePath(legs, prop, info) {
  let oInfo = info;
  if (isString(prop)) prop = prop.slice(1);
  if (!isEmpty(legs[0])) {
    let len = legs.length - 1;
    let lastLeg = legs[len];
    let restLegs = legs.slice(0, len);
    for (const leg of restLegs) {
      if (oInfo[leg]) oInfo = oInfo[leg];
      else {
        console.log('cannot parse', leg, oInfo);
      }
    }
    if (!info.settings) info.settings = {};
    let k = legs.join('_');
    info.settings[k] = [oInfo];
    info.settings[k].push(lastLeg);
    if (isString(prop)) info.settings[k].push(getObject(info.oid)[prop]);
  }
}
function parsePropertyPath(odict, s) {
  if (isEmpty(s)) return odict;
  let o_keys = s.split('.');
  return lookup(odict, o_keys);
}
function parseRect(elem) {
  let r = elem.getAttribute('rect');
  console.log('elem.rect', r);
  if (nundef(r)) return getRect(elem);
  r = r.split(' ');
  let rect = { w: Number(r[0]), h: Number(r[1]), t: Number(r[2]), l: Number(r[3]), b: Number(r[4]), r: Number(r[5]) };
  return rect;
}
function parseStaticSpec() {
  for (const k in SPEC.staticSpec) {
    if (k == 'root') continue;
    let oSpec = jsCopy(SPEC.staticSpec[k]);
    if (oSpec.loc) {
      let loc = oSpec.loc;
      if (!oSpec.id) oSpec.id = k;
      staticArea(loc, oSpec);
      let oEinhaengen = AREAS[loc];
      if (nundef(oEinhaengen.panels)) oEinhaengen.panels = [];
      oEinhaengen.panels.push(oSpec);
    } else {
      PROTO[k] = oSpec;
    }
  }
}
function path2fen(fen, path) { let o = lookup(fen, path.split('.')); return o; }
function path2UI(path) {
  let res = lookup(UI, path.split('.'));
  return res;
}
function pauseloop() { clearInterval(DA.interval); }
function pauseSound() {
  _qSound = [];
  if (_loaded && isdef(_sndPlayer)) {
    clearTimeout(TOSound);
    _sndPlayer.onended = null;
    _sndPlayer.onpause = whenSoundPaused;
    _sndPlayer.pause();
  }
}
function pauseUI() { uiPausedStack.push(uiPaused); uiPaused |= uiHaltedMask; }
function PawnsInit() {
  var index = 0;
  for (index = 0; index < 10; ++index) {
    PawnRanksWhite[index] = RANKS.RANK_8;
    PawnRanksBlack[index] = RANKS.RANK_1;
  }
  pce = PIECES.wP;
  for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
    sq = brd_pList[PCEINDEX(pce, pceNum)];
    if (RanksBrd[sq] < PawnRanksWhite[FilesBrd[sq] + 1]) {
      PawnRanksWhite[FilesBrd[sq] + 1] = RanksBrd[sq];
    }
  }
  pce = PIECES.bP;
  for (pceNum = 0; pceNum < brd_pceNum[pce]; ++pceNum) {
    sq = brd_pList[PCEINDEX(pce, pceNum)];
    if (RanksBrd[sq] > PawnRanksBlack[FilesBrd[sq] + 1]) {
      PawnRanksBlack[FilesBrd[sq] + 1] = RanksBrd[sq];
    }
  }
}
function payment_complete() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  A.payment = A.items[A.selected[0]];
  let nextstage = Z.stage = ARI.stage[A.command];
  ari_pre_action();
}
function PCEINDEX(pce, pceNum) { return (pce * 10 + pceNum); }
function percentOf(elem, percentW, percentH) {
  if (nundef(percentH)) percentH = percentW;
  if (nundef(percentW)) percentW = percentH = 100;
  let r = getRect(elem);
  return { w: r.w * percentW / 100, h: r.h * percentH / 100 };
}
function percentVh(percent) { return percent * document.documentElement.clientHeight / 100; }
function percentVhIncludingScrollbar(percent) {
  var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
  return (percent * h) / 100;
}
function percentVMax(percent) { return Math.max(percentVh(percent), percentVw(percent)); }
function percentVMaxIncludingScrollbar(percent) {
  return Math.max(percentVhIncludingScrollbar(percent), percentVwIncludingScrollbar(percent));
}
function percentVMin(percent) { return Math.min(percentVh(percent), percentVw(percent)); }
function percentVMinIncludingScrollbar(percent) {
  return Math.min(percentVhIncludingScrollbar(percent), percentVwIncludingScrollbar(percent));
}
function percentVw(percent) { return percent * document.documentElement.clientWidth / 100; }
function percentVwIncludingScrollbar(percent) {
  var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
  return (percent * w) / 100;
}
function perform_search() {
  let words = toWords(mBy('iKeywords').value);
  console.log('keywords are', words);
  let res = [], i = 0;
  for (const c of DB.code) {
    for (const w of words) {
      let w1 = w.toLowerCase();
      let kw = c.kw.toLowerCase();
      let code = c.c.toLowerCase();
      if (kw.includes(w1) || code.includes(w1)) {
        res.push(c);
        c.index = i;
        break;
      }
    }
    i++;
  }
  console.log('filtered:', res);
  show_code_list(res);
}
function Perft(depth) {
  MakeNullMove();
  if (brd_posKey != GeneratePosKey()) {
    console.log(printGameLine());
    PrintBoard();
    srch_stop = BOOL.TRUE;
    console.log('Hash Error After Make');
  }
  TakeNullMove();
  if (brd_posKey != GeneratePosKey()) {
    console.log(printGameLine());
    PrintBoard();
    srch_stop = BOOL.TRUE;
    console.log('Hash Error After Take');
  }
  if (depth == 0) {
    perft_leafNodes++;
    return;
  }
  GenerateMoves();
  var index;
  var move;
  for (index = brd_moveListStart[brd_ply]; index < brd_moveListStart[brd_ply + 1]; ++index) {
    move = brd_moveList[index];
    if (MakeMove(move) == BOOL.FALSE) {
      continue;
    }
    Perft(depth - 1);
    TakeMove();
  }
  return;
}
function PerftTest(depth) {
  PrintBoard();
  console.log("Starting Test To Depth:" + depth);
  perft_leafNodes = 0;
  GenerateMoves();
  var index;
  var move;
  var moveNum = 0;
  for (index = brd_moveListStart[brd_ply]; index < brd_moveListStart[brd_ply + 1]; ++index) {
    move = brd_moveList[index];
    if (MakeMove(move) == BOOL.FALSE) {
      continue;
    }
    moveNum++;
    var cumnodes = perft_leafNodes;
    Perft(depth - 1);
    TakeMove();
    var oldnodes = perft_leafNodes - cumnodes;
    console.log("move:" + moveNum + " " + PrMove(move) + " " + oldnodes);
  }
  console.log("Test Complete : " + perft_leafNodes + " leaf nodes visited");
  $("#FenOutput").text("Test Complete : " + perft_leafNodes + " leaf nodes visited");
  return;
}
function PHLayout() {
  if (isdef(UI.DRR)) UI.DRR.remove();
  mAppend(UI.dRechts, UI.dHistory);
  Clientdata.historyLayout = 'ph';
}
function phpPost(data, cmd) {
  if (DA.TEST1 === true && cmd == 'table') { cmd = 'table1'; }
  pollStop();
  var o = {};
  o.data = valf(data, {});
  o.cmd = cmd;
  o = JSON.stringify(o);
  if (DA.SIMSIM && (DA.exclusive || ['table', 'startgame', 'gameover', 'tables'].includes(cmd))) {
    sendSIMSIM(o, DA.exclusive);
    FORCE_REDRAW = true;
    if (DA.exclusive) return;
  } else if (DA.simulate) {
    sendSIMSIM(o, true, true);
    FORCE_REDRAW = true;
    return;
  }
  clear_transaction();
  var xml = new XMLHttpRequest();
  loader_on();
  xml.onload = function () {
    if (xml.readyState == 4 || xml.status == 200) {
      loader_off();
      handle_result(xml.responseText, cmd);
    } else { console.log('WTF?????') }
  }
  xml.open("POST", "api.php", true);
  xml.send(o);
}
function phpPostSimulate(o, cmd) {
  FORCE_REDRAW = true;
  if (nundef(o.options) && isdef(Z)) {
    o.turn = Z.turn;
    o.expected = Z.expected;
    o.options = Z.options;
  }
  switch (cmd) {
    case "gameover":
    case "move":
    case "table":
    case "startgame":
      let t = pack_table(o);
      let t1 = JSON.parse(t);
      handle_result(t, cmd); break;
    default: break;
  }
}
function picDiv(size) { return o => pictoDiv(o.key, o.color, size, size); }
function picInfo(key) {
  if (isdef(symbolDict[key])) return symbolDict[key];
  else {
    ensureSymByHex();
    let info = symByHex[key];
    if (isdef(info)) { return info; }
    else {
      let infolist = picSearch({ keywords: key });
      if (infolist.length == 0) return null;
      else return chooseRandom(infolist);
    }
  }
}
function PickNextMove(moveNum) {
  var index = 0;
  var bestScore = 0;
  var bestNum = moveNum;
  for (index = moveNum; index < brd_moveListStart[brd_ply + 1]; ++index) {
    if (brd_moveScores[index] > bestScore) {
      bestScore = brd_moveScores[index];
      bestNum = index;
    }
  }
  temp = brd_moveList[moveNum];
  brd_moveList[moveNum] = brd_moveList[bestNum];
  brd_moveList[bestNum] = temp;
  temp = brd_moveScores[moveNum];
  brd_moveScores[moveNum] = brd_moveScores[bestNum];
  brd_moveScores[bestNum] = temp;
}
function pickSuitableItems(n, options) {
  let items = genItems(n, options);
  let words = items.map(x => x.label);
  let minlen = arrMinMax(words, x => x.length).min;
  let used = [];
  for (const item of items) {
    let res = minlen > 6 ? getRandomVowel(item.label, used) : minlen > 3 ? getRandomConsonant(item.label, used) : getRandomLetter(item.label, used);
    if (isEmpty(res)) return null;
    let i = item.iLetter = res.i;
    let letter = item.letter = item.label[i];
    used.push(letter);
  }
  return items;
}
function pickSuitableItems_dep(n, options) {
  let items = genItems(n, options);
  let words = items.map(x => x.label);
  let used = [];
  for (const item of items) {
    let res = getRandomConsonant(item.label, used);
    if (isEmpty(res)) return null;
    let i = item.iLetter = res.i;
    let letter = item.letter = item.label[i];
    used.push(letter);
  }
  return items;
}
function picLabelDiv(size) { return o => pictoLabelDiv(o.key, o.label, o.color, size); }
function picRandom(type, keywords, n = 1) {
  let infolist = picSearch({ type: type, keywords: keywords });
  return n == 1 ? chooseRandom(infolist) : choose(infolist, n);
}
function picSearch({ keywords, type, func, set, group, subgroup, props, isAnd, justCompleteWords }) {
  if (isdef(set)) ensureSymBySet();
  if (isdef(type) && type != 'all') ensureSymByType();
  let [dict, list] = isdef(set) ? [symBySet[set], symListBySet[set]]
    : nundef(type) || type == 'all' ? [symbolDict, symbolList] : [symByType[type], symListByType[type]];
  if (set == 'role' && firstCond(dict2list(dict), x => x.id == 'rotate')) console.log('===>', symBySet[set], dict, dict2list(dict));
  if (nundef(keywords)) return isdef(func) ? func(dict) : list;
  if (!isList(keywords)) keywords = [keywords];
  if (isString(props)) props = [props];
  let infolist = [];
  if (isList(props)) {
    if (isAnd) {
      if (justCompleteWords) {
        infolist = allWordsContainedInPropsAsWord(dict, keywords, props);
      } else {
        infolist = allWordsContainedInProps(dict, keywords, props);
      }
    } else {
      if (justCompleteWords) {
        infolist = anyWordContainedInPropsAsWord(dict, keywords, props);
      } else {
        infolist = anyWordContainedInProps(dict, keywords, props);
      }
    }
  } else if (nundef(props) && nundef(func)) {
    if (isAnd) {
      if (justCompleteWords) {
        infolist = allWordsContainedInKeysAsWord(dict, keywords);
      } else {
        infolist = allWordsContainedInKeys(dict, keywords);
      }
    } else {
      if (justCompleteWords) {
        infolist = anyWordContainedInKeysAsWord(dict, keywords);
      } else {
        infolist = anyWordContainedInKeys(dict, keywords);
      }
    }
  } else if (isdef(func)) {
    infolist = func(dict, keywords);
  }
  return infolist;
}
function picSet(setname) {
  ensureSymBySet();
  return chooseRandom(symListBySet[setname]);
}
function picto(key, x, y, w, h, fg, bg) {
  let ch = iconChars[key];
  let family = (ch[0] == 'f' || ch[0] == 'F') ? 'pictoFa' : 'pictoGame';
  let text = String.fromCharCode('0x' + ch);
  let d = document.createElement('div');
  d.style.textAlign = 'center';
  d.style.fontFamily = family;
  d.style.fontWeight = 900;
  d.style.fontSize = h;
  d.style.backgroundColor = bg;
  d.style.color = fg;
  d.innerHTML = text;
  return d;
}
function pictoDiv(key, color, w, h) {
  let d = maPicSimple(key);
  mColor(d, color);
  mSizePic(d, w, h);
  return d;
}
function pictoLabelDiv(key, label, color = 'blue', sz = 50, gap = 2, fz) {
  let dOuter = mCreate('div');
  let wOuter = sz;
  let wInner = sz - 2 * gap;
  mStyle(dOuter, {
    width: wOuter,
    padding: 0,
    display: 'inline',
    position: 'absolute',
    'text-align': 'center',
    'background-color': randomColor(),
  });
  let dPic = pictoDiv(key, color, wInner, wInner);
  mAppend(dOuter, dPic)
  mStyle(dPic, { margin: gap, 'margin-bottom': 1 })
  let dText = mAppendText(dOuter, label);
  dText.classList.add('truncate');
  mStyle(dText, { 'margin-bottom': gap, width: wOuter });
  return dOuter;
}
function PieceIsOnSq(sq, top, left) {
  if ((RanksBrd[sq] == 7 - Math.round(top / 60)) &&
    FilesBrd[sq] == Math.round(left / 60)) {
    return BOOL.TRUE;
  }
  return BOOL.FALSE;
}
function pKeyVal(dParent, k, val) { let d = pPanel(dParent); d.innerHTML = k + ':'; pVal(d, val); return d; }
function placeDeck(deck, cont, x, y) {
  deck.unmount();
  deck.mount(cont);
  deck.translate(x, y);
}
function placement() {
  let plac = SPEC.placement;
}
function placeSymbol(sym, szSym, margin, posStyles) {
  let d = iDiv(sym);
  posStyles.position = 'absolute';
  posStyles.margin = margin;
  posStyles.h = szSym;
  posStyles.w = szSym;
  mStyle(d, posStyles);
}
function player_stat_count(key, n, dParent, styles = {}) {
  let sz = valf(styles.sz, 16);
  addKeys({ display: 'flex', margin: 4, dir: 'column', hmax: 2 * sz, 'align-content': 'start', fz: sz, align: 'center' }, styles);
  let d = mDiv(dParent, styles);
  if (isdef(Syms[key])) mSym(key, d, { h: sz, 'line-height': sz, w: '100%' });
  else mText(key, d, { h: sz, fz: sz, w: '100%' });
  d.innerHTML += `<span style="font-weight:bold">${n}</span>`;
  return d;
}
function playsCard(pl, card, dHand, dTarget, faceUp) {
  pl.cardPlayed = card;
  removeCard(card, dHand);
  addCard(card, dTarget);
  if (faceUp == true) Card52.turnFaceUp(card);
  mRemoveStyle(card.div, ['cursor', 'position']);
}
function playSound(key, wait = true) {
  if (!wait) _qSound = [];
  _enqSound(key);
  if (_idleSound) { _idleSound = false; _deqSound(); }
}
function playsound() { playSound(...arguments); }
function playt() {
  var tag = document.createElement('script');
  tag.src = "https://www.youtube.com/iframe_api";
  var firstScriptTag = document.getElementsByTagName('script')[0];
  firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
  var player;
  function onYouTubeIframeAPIReady() {
    player = new YT.Player('player', {
      height: '390',
      width: '640',
      videoId: 'Kopr6Q3oGHw',
      playerVars: {
        'playsinline': 1,
      },
      events: {
        'onReady': onPlayerReady,
        'onStateChange': onPlayerStateChange
      }
    });
  }
  function onPlayerReady(event) {
    console.log('player is ready - please click anywhere on page')
    onclick = () => event.target.playVideo();
  }
  var done = false;
  function onPlayerStateChange(event) {
    if (event.data == YT.PlayerState.PLAYING && !done) {
      setTimeout(volume_up, 2000);
      done = true;
    }
  }
}
function plot_cdf(canvas, mean, stdev, xfrom, xto, styles = {}) { }
function plot_derivative(canvas, f, xfrom, xto, styles = {}) { }
function plot_function(canvas, f, xfrom, xto, styles = {}) { }
function plot_integral(canvas, f, xfrom, xto, styles = {}) { }
function plot_line(canvas, item) {
  let cx = canvas.cx;
  cx.font = `${valf(item.fz, 16)}px Arial`;
  cx.fillStyle = item.color;
  if (isdef(item.label)) cx.fillText(`  ${item.label}`, 0, 0);
  cLine(item.x1, item.y1, item.x2, item.y2, { bg: item.color }, 0, cx);
}
function plot_on_canvas(d, items) {
  let r = getRect(dTable);
  let c = mCanvas(d, { w: r.w, h: r.h, rounding: 0, bg: 'white' }); let [cv, cx] = [c.cv, c.cx];
  for (const item of items) {
    let d1 = item.div = cRect(item.x, item.y, item.w, item.h, { bg: item.bg }, cx);
  }
}
function plot_on_div(d, items) {
  mStyle(d, { position: 'relative' });
  for (const item of items) {
    let d1 = item.div = mDiv(d, { x: item.x, y: item.y, w: item.w, h: item.h, bg: item.bg, rounding: '50%', position: 'absolute' });
  }
}
function plot_pdf(canvas, mean, stdev, xfrom, xto, styles = {}) { }
function plot_point(canvas, x, y, styles = {}) { }
function plural(n) { return n == 0 || n > 1 ? 's' : ''; }
function points_from_feature(f) {
  let coords = f.geometry.coordinates;
  let pts = [];
  for (const c of coords[0]) {
    let p = { x: c[0], y: c[1] };
    pts.push(p);
  }
  return pts;
}
function points_to_waypoints(pts = []) { return pts.map(x => L.latLng(x[0], x[1])); }
function points2string(listOfPoints) {
  return listOfPoints.map(p => '' + p.x + ',' + p.Y).join(' '); //'0,0 100,0 50,80',
}
function pointStyleFunction(feature, resolution) {
  return new Style({
    image: new CircleStyle({
      radius: 10,
      fill: new Fill({ color: 'rgba(255, 0, 0, 0.1)' }),
      stroke: new Stroke({ color: 'red', width: 1 }),
    }),
    text: createTextStyle(feature, resolution, myDom.points),
  });
}
function poll() {
  if (IS_POLLING_ALLOWED) {
    if (isdef(DA.poll.func)) DA.poll.data = DA.poll.func(DA.poll.data);
    console.log('...poll')
    to_server(DA.poll.data, DA.poll.type);
  } else console.log('polling OFF!');
}
function poll_for_table_seen_or_deleted() {
  start_polling({ uname: Session.cur_user, tid: Session.cur_tid }, 'poll_table_seen', on_poll_table_seen, 3000);
}
function poll_for_table_show() {
  start_polling({ uname: Session.cur_user, tid: Session.cur_tid }, 'poll_table_show', on_poll_table_show, 3000);
}
function poll_for_table_started() {
  start_polling(Session.cur_user, 'poll_table_started', on_poll_table_started, 3000);
}
function polling_shield_off() { mBy('dPollingShield').style.display = 'none'; }
function polling_shield_on(msg) {
  let d = mBy('dPollingShield');
  d.style.display = 'block';
  d.innerHTML = msg;
}
function pollStart() {
}
function pollStop() { clearTimeout(TO.poll); Clientdata.AUTORESET = true; }
function polygonStyleFunction(feature, resolution) {
  return new Style({
    stroke: new Stroke({
      color: 'blue',
      width: 1,
    }),
    fill: new Fill({
      color: 'rgba(0, 0, 255, 0.1)',
    }),
    text: createTextStyle(feature, resolution, myDom.polygons),
  });
}
function polyPointsFrom(w, h, x, y, pointArr) {
  x -= w / 2;
  y -= h / 2;
  let pts = pointArr.map(p => [p.X * w + x, p.Y * h + y]);
  let newpts = [];
  for (const p of pts) {
    newp = { X: p[0], Y: Math.round(p[1]) };
    newpts.push(newp);
  }
  pts = newpts;
  let sPoints = pts.map(p => '' + p.X + ',' + p.Y).join(' '); //'0,0 100,0 50,80',
  return sPoints;
}
function pop_hist() { let top = G.hist.pop(); G.selist = top.selist; }
function pop_top(o) {
  if (isEmpty(o.list)) return null;
  let t = o.get_topcard();
  o.list.shift();
  o.renew(o.list, o.cardcontainer, o.items, o.get_card_func);
  return t;
}
function populate_game_settings(dParent, tid) {
  if (nundef(tid)) Session.game_options.game = {};
  let poss = DB.games[Session.cur_game].options;
  if (nundef(poss)) return;
  for (const p in poss) {
    let key = p;
    let val = poss[p];
    if (isString(val)) {
      let list = val.split(',');
      let fs = mRadioGroup(dParent, {}, `d_${key}`, key);
      let checkfirst = nundef(tid);
      for (const v of list) {
        let d = mRadio(v, isNumber(v) ? Number(v) : v, fs, { cursor: 'pointer' }, null, key);
        if (checkfirst || lookup(Session.game_options.game, [key]) == v) {
          let inp = d.firstChild;
          inp.setAttribute('checked', true);
          checkfirst = false;
        }
      }
      measure_fieldset(fs);
    }
  }
}
function populate_players(list) {
  let d = mBy('d_players');
  if (nundef(d)) return;
  mRemoveChildrenFromIndex(d, 1);
  Session.game_options.players = [];
  for (const name of list) {
    Session.game_options.players.push(name);
    let d1 = mDiv(d, {}, 'dpl_' + name);
    let b = mButton('edit', ev => open_player_editor(ev), d1);
    let label = `${name} (${get_startlevel(name, Session.cur_game)} ${get_preferred_lang(name)})`;
    if (name == Session.cur_user) { let el = mToggle(label, name, d1, { display: 'inline' }); el.firstChild.setAttribute('disabled', true); }
    else { mToggle(label, name, d1, { cursor: 'pointer', display: 'inline' }); }
  }
  measure_fieldset(d);
  let styles = { fz: 14, wmin: '90%', matop: 8 };
  mButton('clear all', clear_all_players, d_players, styles, null, 'b_clear_players');
  mButton('add players', add_players, d_players, styles, null, 'b_add_players');
  mButton('hand select', hand_select, d_players, styles, null, 'b_select_players');
  mButton('reduce', reduce_to_current_players, d_players, styles, null, 'b_reduce_players');
  mButton('show all', show_all_players, d_players, styles, null, 'b_show_all_players');
}
function populate_players_v0(list) {
  let d = mBy('d_players');
  if (nundef(d)) return;
  mRemoveChildrenFromIndex(d, 1);
  Session.game_options.players = [];
  for (const name of list) {
    Session.game_options.players.push(name);
    if (name == Session.cur_user) { let el = mToggle(name, name, d); el.firstChild.setAttribute('disabled', true); }
    else { mToggle(name, name, d, { cursor: 'pointer' }); }
  }
  d_players.innerHTML += '<br>';
  mTextArea(3, 20, d_players, { fz: 16, display: 'none', resize: 'none', border: 'none', outline: 'none' }, 'ta_edit_players');
  d_players.innerHTML += '<br>';
  measure_fieldset(d);
  mButton('edit', onclick_edit_players, d_players, { fz: 14, wmin: '90%' }, null, 'b_edit_players');
}
function populate_playmode(d, modes) {
  let group = mRadioGroup(d, {}, 'd_mode', 'play mode');
  modes = modes.split(',');
  for (const m of modes) {
    let name = m == 'pp' ? 'pass&play' : m == 'multi' ? 'multiplayer' : m;
    let d = mRadio(name, m, group, { cursor: 'default' }, null, 'mode');
    let inp = d.firstChild;
    inp.setAttribute('disabled', true);
    if (m != 'multi') mClass(d, 'disabled');
  }
  measure_fieldset(group);
  let mode = Session.game_options.mode = modes.includes(Session.def_playmode) ? Session.def_playmode : modes[0];
  let el = mBy(`i_mode_${mode}`).checked = true;
}
function populateGamenames() {
  let elem = document.getElementById('fChooseGame');
  clearInit(elem, { innerHTML: '<legend>choose game</legend>' });
  for (const name in allGames) {
    let radio = document.createElement('input');
    radio.type = 'radio';
    radio.name = 'game';
    radio.classList.add('radio');
    radio.id = 'c_b_mm_' + name;
    radio.value = name;
    radio.addEventListener('click', () => onClickGamename(radio));
    elem.appendChild(radio);
    elem.appendChild(document.createTextNode(allGames[name].name.toLowerCase()));
    elem.appendChild(document.createElement('br'))
  }
  let checkedGameInput = document.getElementById('c_b_mm_' + GAME.toLowerCase());
  checkedGameInput.checked = true;
}
function populateJoinList() {
  let players = S.gameConfig.players;
  console.log('populateJoinList', S.gameConfig)
  for (let i = 1; i <= S.gameConfig.numPlayers; i++) {
    let pl = players[i - 1];
    let idRadio = getidAvailable(i);
    let idSpan = getidSpanJoin(i);
    if (isEmpty(pl.username)) {
      show(idRadio);
      show(idSpan);
      uncheckAvailable(i);
      document.getElementById(idSpan).innerHTML = pl.id;
    } else {
      hide(idRadio);
      hide(idSpan);
    }
  }
  for (let i = S.gameConfig.numPlayers + 1; i <= MAX_PLAYERS_AVAILABLE; i++) {
    let idRadio = getidAvailable(i);
    let idSpan = getidSpanJoin(i);
    hide(idRadio);
    hide(idSpan);
  }
}
function populateSelect(i, listValues, selValue) {
  let id = getidType(i);
  let el = document.getElementById(id);
  clearElement(el);
  for (opt of listValues) {
    var newOption = document.createElement("option");
    newOption.text = opt.toString();
    el.appendChild(newOption);
  }
  $(el).val(selValue);
}
function pos2id(id, row, col) {
  return id + '_' + row + '_' + col;
}
function posBC(d) {
  let dParent = d.parentNode;
  let dNew = mDiv(dParent, { w: '100%', h: 50, position: 'absolute', bottom: 0, left: 0, bg: 'null', align: 'center' });
  mAppend(dNew, d);
}
function posBL(d) { mStyle(d, { left: 0, bottom: 0, position: 'absolute' }); }
function posBLR(d) { mStyle(d, { left: 0, bottom: 0, position: 'absolute' }); mRot(d, 180); }
function posBR(d) { mStyle(d, { right: 0, bottom: 0, position: 'absolute' }); }
function posBRR(d) { mStyle(d, { right: 0, bottom: 0, position: 'absolute' }); mRot(d, 180); }
function posCenterInCenter(d) { d.classList.add('centerCentered'); }
function posCIC(d) { d = mEnsure(d); d.classList.add('centerCentered'); }
function posCICB(d) { d = mEnsure(d); d.classList.add('centerCenteredBottomHalf'); }
function posCICT(d) { d = mEnsure(d); d.classList.add('centerCenteredTopHalf'); }
function positionGElement(ui, uidParent, topG) {
  let uiParent = mBy(uidParent);
  if (isdef(uiParent) && topG != uiParent) {
    console.log('positionGElement', ui.id, uiParent.id, topG.id);
    console.log(ui, uiParent, topG)
    let bds = getBounds(uiParent, true);
    let trans = getTransformInfo(uiParent);
    console.log('positionGElement,trans', trans)
    let [x, y] = [trans.translateX, trans.translateY];
    let x1 = -22;
    let y1 = 0;
    let x2 = 0; let y2 = 0;
    let trans1 = uiParent.style.transform;
    let tt = trans1.split('translate');
    if (tt.length <= 1) {
      console.log('there is NO translate transform!!! uiParent', uiParent);
    } else {
      let traNumbersX = trans1.split('(');
      x2 = firstNumber(traNumbersX[1]);
      let traNumbersY = trans1.split(',');
      y2 = firstNumber(traNumbersY[1]);
    }
    gPos(ui, x2, y2);
    let nParent = R.uiNodes[uidParent]
    let par1 = R.uiNodes[nParent.uidParent];
    let par2 = R.uiNodes[par1.uidParent];
  }
  return ui;
}
function posOverlap(d1, dParent, dx, dy, propName) {
  let chType = d1[propName];
  let numChildrenOfTarget = [...dParent.children].filter(x => x.type == chType).length - 1;
  posXY(d1, dParent, numChildrenOfTarget * dx, numChildrenOfTarget * dy, unit = 'px', position = 'absolute');
}
function post_accept_blackmail() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  let blackmailer = fen.blackmail.blackmailer;
  let blackmailed = fen.blackmail.blackmailed;
  let building_path = fen.blackmail.building_path;
  let fenbuilding = path2fen(fen, building_path);
  let building_owner = stringAfter(building_path, '.'); building_owner = stringBefore(building_owner, '.');
  assertion(building_owner == blackmailed && blackmailed == uplayer, 'blackmailed and uplayer and building owner must be same');
  elem_from_to(item.key, fen.players[blackmailed].stall, fen.players[blackmailer].hand);
  ari_history_list([`${blackmailed} accepts: gives ${item.key} to ${blackmailer}`], 'blackmail');
  delete fenbuilding.isblackmailed;
  [Z.stage, Z.turn] = [35, [blackmailer]];
  take_turn_fen();
}
function post_auction() {
  console.assert(Z.stage == 13, 'WRONG STAGE IN POST AUCTION ' + Z.stage);
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let item = A.selected.map(x => A.items[x])[0];
  lookupSet(fen, ['buy', uplayer], { key: item.key, index: A.selected[0] });
  ari_history_list([`${uplayer} selects ${item.key}`], 'auction');
  for (const plname of fen.maxplayers) {
    if (!lookup(fen, ['buy', plname])) {
      Z.turn = [plname];
      take_turn_fen();
      return;
    }
  }
  let buylist = dict2list(fen.buy, 'playername');
  let discardlist = [];
  for (const plname of fen.maxplayers) {
    let choice = fen.buy[plname];
    let n = arrCount(buylist, x => x.index == choice.index);
    let is_unique = n == 1;
    if (is_unique) {
      fen.players[plname].coins -= fen.second_most;
      let x = UI.player_stat_items[plname].dCoin; mPulse1(x);
      elem_from_to(choice.key, fen.market, fen.players[plname].hand);
      ari_history_list([`${plname} buys ${choice.key} for ${fen.second_most}`], 'auction');
      let card = find_card(choice.index, UI.market);
      animate_card_transfer(card, arrLast(UI.players[plname].hand.items));
    } else {
      addIf(discardlist, choice.key);
      delete fen.buy[plname];
    }
  }
  for (const key of discardlist) {
    elem_from_to(key, fen.market, fen.deck_discard);
    ari_reorg_discard(fen);
    ari_history_list([`${key} is discarded`], 'auction');
  }
  delete fen.second_most;
  delete fen.maxplayers;
  delete fen.buy;
  delete fen.auction;
  Z.stage = 4;
  Z.turn = [fen.plorder[0]];
  setTimeout(take_turn_fen, 1000);
}
function post_ball() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let keys = A.selected.map(x => A.items[x]).map(x => x.key);
  keys.map(x => lookupAddIfToList(fen, ['ball', uplayer], x));
  keys.map(x => removeInPlace(fen.players[uplayer].hand, x));
  let iturn = fen.plorder.indexOf(uplayer) + 1;
  if (iturn >= fen.plorder.length) {
    if (isdef(fen.ball)) {
      let all = [];
      for (const c of fen.market) all.push(c);
      for (const uplayer in fen.ball) for (const c of fen.ball[uplayer]) all.push(c);
      shuffle(all);
      fen.market = [];
      for (let i = 0; i < 2; i++) top_elem_from_to(all, fen.market);
      for (const uplayer in fen.ball) for (let i = 0; i < fen.ball[uplayer].length; i++) top_elem_from_to(all, fen.players[uplayer].hand);
      delete fen.ball;
    }
    iturn = 0;
    Z.stage = 4;
    console.assert(fen.phase == 'queen', 'wie bitte noch nicht in queen phase?!!!!!!!!!!!');
  }
  Z.turn = [fen.plorder[iturn]];
  ari_history_list([`${uplayer} added ${keys.length} card${plural(keys.length)} to ball!`], 'ball');
  take_turn_fen();
}
function post_blackmail() {
  let [fen, uplayer] = [Z.fen, Z.uplayer];
  ari_history_list([`blackmail complete!`], 'blackmail');
  delete fen.blackmail;
  ari_next_action();
}
function post_build() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  if (A.selected.length < 4 || A.selected.length > 6) {
    select_error('select 4, 5, or 6 cards to build!');
    return;
  }
  let building_items = A.selected.map(x => A.items[x]);
  let building_type = building_items.length == 4 ? 'farm' : building_items.length == '5' ? 'estate' : 'chateau';
  fen.players[uplayer].buildings[building_type].push({ list: building_items.map(x => x.key), h: null, schweine: [], lead: building_items[0].key });
  for (const item of building_items) {
    let source = lookup(fen, item.path.split('.'));
    removeInPlace(source, item.key);
  }
  ari_history_list([`${uplayer} builds a ${building_type}`], 'build');
  let is_coin_pay = process_payment();
  let ms = 1800;
  if (is_coin_pay) animcoin(Z.uplayer, 1000);
  remove_ui_items(building_items);
  let pl = fen.players[uplayer];
  let nfarms = pl.buildings.farm.length;
  let nestates = pl.buildings.estate.length;
  let nchateaus = pl.buildings.chateau.length;
  let index = building_type == 'farm' ? nfarms - 1 : building_type == 'estate' ? nfarms + nestates - 1 : nfarms + nestates + nchateaus - 1;
  console.log('index of new building is', index);
  let ifinal = UI.players[uplayer].indexOfFirstBuilding + index;
  console.log('ifinal', ifinal);
  let dpl = iDiv(UI.players[uplayer]);
  let akku = [];
  while (dpl.children.length > ifinal) { akku.push(dpl.lastChild); dpl.removeChild(dpl.lastChild); }
  let fenbuilding = arrLast(fen.players[uplayer].buildings[building_type]);
  let newbuilding = ui_type_building(fenbuilding, dpl, { maleft: 8 }, `players.${uplayer}.buildings.${building_type}.${index}`, building_type, ari_get_card, true, false);
  animbuilding(newbuilding, ms, ari_next_action);
  akku.map(x => mAppend(dpl, x));
}
function post_buy() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let item = A.items[A.selected[0]];
  elem_from_to(item.key, fen.open_discard, fen.players[uplayer].hand);
  ari_history_list([`${uplayer} buys ${item.key}`], 'buy')
  ari_reorg_discard();
  console.log('hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh')
  process_payment();
  setTimeout(ari_next_action, 1000);
}
function post_buy_rumor() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  let non_selected = A.items.filter(x => x.index != A.selected[0]);
  let rumor = item.key;
  for (const item of non_selected) { fen.deck_rumors.push(item.key); }
  fen.players[uplayer].rumors.push(rumor);
  fen.players[uplayer].coins -= 1;
  ari_history_list([`${uplayer} bought a rumor`], 'rumor');
  ari_next_action();
}
function post_church() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let pl = fen.players[uplayer];
  let items = A.selected.map(x => A.items[x]);
  let card = items.find(x => x.path && x.path.includes('church')); if (isdef(card)) card = card.key;
  let cand = items.length > 1 ? items.find(x => !x.path) : fen.candidates[0];
  if (isdef(cand) && isDict(cand)) cand = cand.key;
  if (nundef(card) || nundef(cand)) {
    select_error(`You must select a card ${items.length > 1 ? 'and a candidate' : ''}!`);
    return;
  }
  elem_from_to(card, fen.church, fen.players[cand].hand);
  ari_history_list([`${uplayer} gives ${cand} card ${card}`], 'new cards');
  removeInPlace(fen.toBeSelected, cand);
  if (fen.church.length == 1) {
    let cand = fen.toBeSelected[0];
    let card = fen.church[0];
    elem_from_to(card, fen.church, fen.players[cand].hand);
    ari_history_list([`${cand} receives last card: ${card}`], 'new cards');
    Z.stage = 14;
    let plorder = fen.plorder = jsCopy(fen.heraldorder);
    Z.turn = [plorder[0]];
    take_turn_fen();
  } else {
    Z.turn = [get_next_in_list(uplayer, fen.selorder)];
    take_turn_fen();
  }
}
function post_comm_setup_stage() {
  let [fen, A, uplayer, plorder, pl] = [Z.fen, Z.A, Z.uplayer, Z.plorder, Z.pl];
  let achtungHack = false;
  let new_playerdata = [];
  for (const data of Z.playerdata) {
    let o = data;
    if (is_stringified(data)) {
      console.log('achtungHack: data is stringified');
      o = JSON.parse(data);
      achtungHack = true;
    } else if (is_stringified(data.state)) {
      console.log('achtungHack: data.state is stringified');
      o.state = JSON.parse(data.state);
      achtungHack = true;
    }
    new_playerdata.push(o);
    let state = o.state;
    let giver = state.giver;
    let receiver = state.receiver;
    let keys = state.keys;
    keys.map(x => elem_from_to(x, fen.players[giver].commissions, fen.players[receiver].commissions));
  }
  if (achtungHack) { Z.playerdata = new_playerdata; }
  fen.comm_setup_num -= 1;
  if (fen.comm_setup_num <= 0) {
    delete fen.comm_setup_di;
    delete fen.comm_setup_num;
    delete fen.keeppolling;
    ari_history_list([`commission trading ends`], 'commissions');
    if (exp_rumors && plorder.length > 2) {
      [Z.stage, Z.turn] = [24, Z.options.mode == 'hotseat' ? [fen.plorder[0]] : fen.plorder];
      ari_history_list([`gossiping starts`], 'rumors');
    } else { [Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, fen.phase); }
  } else {
    [Z.stage, Z.turn] = [23, Z.options.mode == 'hotseat' ? [fen.plorder[0]] : fen.plorder];
  }
  take_turn_fen_clear();
}
function post_commission() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let comm_selected = A.items[A.selected[0]];
  let stall_item = A.commission_stall_item;
  console.log('stall_item:', stall_item);
  let rank = A.commission.key[0];
  if (nundef(fen.commissioned)) fen.commissioned = [];
  let x = firstCond(fen.commissioned, x => x.rank == rank);
  if (x) { removeInPlace(fen.commissioned, x); }
  else { x = { key: A.commission.key, rank: rank, count: 0 }; }
  x.count += 1;
  let pl = fen.players[uplayer];
  let top = isEmpty(fen.commissioned) ? null : arrLast(fen.commissioned);
  let rankstr = 'A23456789TJQK';
  let points = !top || get_rank_index(rank, rankstr) >= get_rank_index(top.rank, rankstr) ? 1 : 0;
  points += Number(x.count);
  pl.coins += points;
  fen.commissioned.push(x);
  let key = stall_item.key;
  removeInPlace(pl.stall, key);
  if (comm_selected.path == 'open_commissions') {
    removeInPlace(fen.open_commissions, comm_selected.key);
    top_elem_from_to(fen.deck_commission, fen.open_commissions);
  } else {
    removeInPlace(fen.deck_commission, comm_selected.key);
  }
  arrReplace(pl.commissions, [A.commission.key], [comm_selected.key]);
  ari_history_list([`${uplayer} commissions card ${A.commission.key}`, `${uplayer} gets ${points} coin${if_plural(points)} for commissioning ${A.commission.key}`], 'commission');
  ari_next_action();
}
function post_complementing_market_after_church() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  let pl = fen.players[uplayer];
  let selectedKeys = A.selected.map(i => A.items[i].key);
  for (const ckey of selectedKeys) {
    elem_from_to(ckey, fen.players[uplayer].hand, fen.players[uplayer].stall);
  }
  if (selectedKeys.length > 0) ari_history_list([`${uplayer} complements stall`], 'complement stall');
  let next = get_next_player(Z, uplayer);
  if (next == plorder[0]) {
    ari_clear_church();
    ari_start_action_stage();
  } else {
    Z.turn = [next];
    take_turn_fen();
  }
}
function post_defend_blackmail() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let blackmailer = fen.blackmail.blackmailer;
  let blackmailed = fen.blackmail.blackmailed;
  let building_path = fen.blackmail.building_path;
  let fenbuilding = path2fen(fen, building_path);
  let building_owner = stringAfter(building_path, '.'); building_owner = stringBefore(building_owner, '.');
  assertion(building_owner == blackmailed && blackmailed == uplayer, 'blackmailed and uplayer and building owner must be same');
  let rumors = fen.players[building_owner].rumors;
  let lead = fenbuilding.lead;
  let brumors = fenbuilding.rumors;
  let match = firstCond(rumors, x => x[0] == lead[0]);
  removeInPlace(rumors, match);
  brumors.pop();
  ari_history_list([`${blackmailed} defends: pays matching rumor to deflect blackmail, 1 rumor is removed from building`], 'blackmail');
  delete fenbuilding.isblackmailed;
  [Z.stage, Z.turn] = [35, [blackmailer]];
  take_turn_fen();
}
function post_downgrade() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let pl = fen.players[uplayer];
  A.downgrade_cards = A.selected.map(x => A.items[x]);
  let obuilding = lookup(fen, A.building.path.split('.'));
  let n = obuilding.list.length;
  let nremove = A.downgrade_cards.length;
  let nfinal = n - nremove;
  let type = A.building.o.type;
  let list = pl.buildings[type];
  removeInPlace(list, obuilding);
  let cards = A.downgrade_cards.map(x => x.key);
  if (nfinal < 4) {
    pl.hand = pl.hand.concat(obuilding.list);
  } else if (nfinal == 4) {
    pl.buildings.farm.push(obuilding);
    pl.hand = pl.hand.concat(cards);
  } else if (nfinal == 5) {
    pl.buildings.estate.push(obuilding);
    pl.hand = pl.hand.concat(cards);
  } else if (nfinal == 6) {
    pl.buildings.chateau.push(obuilding);
    pl.hand = pl.hand.concat(cards);
  }
  A.downgrade_cards.map(x => removeInPlace(obuilding.list, x.key));
  if (isdef(pl.tithes)) {
    for (const c of cards) removeInPlace(pl.hand, c);
  }
  ari_history_list([`${uplayer} downgrades to ${ari_get_building_type(obuilding)}`], 'downgrade');
  if (isdef(pl.tithes)) { proceed_to_newcards_selection(); } else ari_next_action(fen, uplayer);
}
function post_endgame() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  if (A.selected[0] == 0) {
    console.log('GAMEOVER!!!!!!!!!!!!!!!!!!!');
    for (const plname of fen.plorder) {
      let pl = fen.players[plname];
      pl.vps = ari_calc_real_vps(fen, plname);
      pl.max_journey_length = ari_get_max_journey_length(fen, plname);
      pl.score = pl.vps * 10000 + pl.max_journey_length * 100 + pl.coins;
      console.log('score', plname, pl.score);
    }
    let playerlist = dict2list(fen.players, 'name');
    let sorted = sortByDescending(playerlist, 'score');
    console.log('scores', sorted.map(x => `${x.name}:${x.score}`));
    let max_score = sorted[0].score;
    let all_winners = sorted.filter(x => x.score == max_score);
    fen.winners = all_winners.map(x => x.name);
    console.log('winners:', fen.winners)
    take_turn_fen();
  } else {
    let iturn = fen.pl_gameover.indexOf(uplayer) + 1;
    if (iturn >= fen.pl_gameover.length) {
      delete fen.pl_gameover;
      Z.turn = [fen.plorder[0]];
      Z.phase = 'queen';
      [Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, Z.phase);
      take_turn_fen();
    } else {
      Z.turn = [fen.pl_gameover[iturn]];
      take_turn_fen();
    }
  }
}
function post_exchange() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  if (A.selected.length != 2) {
    select_error('please, select exactly 2 cards!');
    return;
  }
  let i0 = A.items[A.selected[0]];
  let i1 = A.items[A.selected[1]];
  let [p0, p1] = [i0.path, i1.path];
  if (p0.includes('build') == p1.includes('build')) {
    select_error('select exactly one building card and one of your hand or stall cards!');
    return;
  }
  let ibuilding = p0.includes('build') ? i0 : i1;
  let ihandstall = ibuilding == i0 ? i1 : i0;
  let fenbuilding = lookup(fen, ibuilding.path.split('.'));
  let ib_index = ibuilding.o.index;
  if (fenbuilding.schweine.includes(ib_index)) {
    fenbuilding.schweine.splice(fenbuilding.schweine.indexOf(ib_index), 1);
  }
  let pl = fen.players[uplayer];
  let list2 = ihandstall.path.includes('hand') ? pl.hand : pl.stall;
  let i2 = list2.indexOf(ihandstall.o.key)
  exchange_by_index(fenbuilding.list, ib_index, list2, i2);
  ari_history_list([`${uplayer} exchanges card in ${ari_get_building_type(fenbuilding)}`], 'exchange');
  animate_card_exchange(ibuilding, ihandstall, ari_next_action);
}
function post_harvest() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  let obuilding = lookup(fen, item.path.split('.'));
  fen.players[uplayer].hand.push(obuilding.h);
  obuilding.h = null;
  ari_history_list([`${uplayer} harvests`], 'harvest');
  ari_next_action();
}
function post_inspect() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let schwein = A.items[A.selected[0]].o;
  turn_new_schwein_up(schwein, A.fenbuilding, A.uibuilding);
}
function post_json(url, o, callback) {
  fetch(url, {
    method: 'POST',
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(o)
  }).then(response => response.json()).then(response => callback(response));
}
function post_luxury_or_journey_cards() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  let luxury_selected = A.selected[0] == 0;
  console.log('carditems', A.carditems);
  let n = A.carditems.length;
  if (luxury_selected) {
    let cardstoreplace = A.carditems.map(x => x.key);
    arrReplace(fen.players[uplayer].hand, cardstoreplace, deck_deal(fen.deck_luxury, n));
  } else {
    let len = A.jlegal.length;
    let handcards = firstCond(A.carditems, x => A.jlegal[0] == x.key) ? arrFromIndex(A.jlegal, len - n) : A.jlegal.slice(0, n);
    console.log('handcards', handcards);
    arrExtend(fen.players[uplayer].hand, handcards);
    A.jlegal = arrMinus(A.jlegal, handcards);
    let cardstoremove = A.carditems.map(x => x.key);
    arrRemove(fen.players[uplayer].hand, cardstoremove);
  }
  let path = A.journeyitem.path;
  let parts = path.split('.');
  let owner = parts[1];
  console.log('path', path, 'parts', parts, 'owner', owner)
  fen.players[owner].journeys.splice(Number(parts[3]), 1, A.jlegal);
  [Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, Z.phase);
  ari_history_list([`${uplayer} added to existing journey and takes ${luxury_selected ? 'luxury cards' : 'journey cards'}`], 'journey');
  take_turn_fen();
}
function post_new_journey() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  fen.players[uplayer].journeys.push(A.jlegal);
  arrReplace(fen.players[uplayer].hand, A.jlegal, deck_deal(fen.deck_luxury, A.jlegal.length));
  ari_history_list([`${uplayer} added journey`], 'journey');
  [Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, Z.phase);
  take_turn_fen();
}
function post_pass() {
  let [fen, uplayer] = [Z.fen, Z.uplayer];
  let n = fen.total_pl_actions - fen.num_actions;
  ari_history_list([`${uplayer} passes after ${n} action${plural(n)}`], 'pass');
  fen.num_actions = 0;
  ari_next_action();
}
function post_pickup() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  elem_from_to(item.key, fen.players[uplayer].stall, fen.players[uplayer].hand);
  ari_history_list([`${uplayer} picks up ${item.key}`], 'pickup');
  ari_next_action();
}
function post_reject_blackmail() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  let blackmailer = fen.blackmail.blackmailer;
  let blackmailed = fen.blackmail.blackmailed;
  let building_path = fen.blackmail.building_path;
  let fenbuilding = path2fen(fen, building_path);
  let building_owner = stringAfter(building_path, '.'); building_owner = stringBefore(building_owner, '.');
  assertion(building_owner == blackmailed && blackmailed == uplayer, 'blackmailed and uplayer and building owner must be same');
  ari_history_list([`${blackmailed} rejects!`], 'blackmail');
  let rumors = fenbuilding.rumors;
  let has_lead_rumor = firstCond(rumors, x => x[0] == fenbuilding.lead[0]);
  if (has_lead_rumor) {
    let stall = fen.players[blackmailed].stall;
    fen.players[blackmailer].hand = fen.players[blackmailer].hand.concat(stall);
    fen.players[blackmailed].stall = [];
    ari_history_list([`RUMOR CORRECT!!! ${blackmailed} looses entire stall to ${blackmailer}`], 'blackmail');
  } else {
    ari_history_list([`${blackmailed} was lucky!!! rumors incorrect`], 'blackmail');
  }
  delete fenbuilding.rumors;
  delete fenbuilding.isblackmailed;
  [Z.stage, Z.turn] = [35, [blackmailer]];
  take_turn_fen();
}
function post_rumor_both() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  let non_selected = A.items.filter(x => x.index != A.selected[0])[0];
  let rumor = item.key;
  let rumor_other = non_selected.key;
  fen.players[uplayer].rumors.push(rumor);
  fen.players[A.owner].rumors.push(rumor_other);
  ari_history_list([`${uplayer} got a rumor, ${A.owner} got one too`], 'rumor');
  ari_next_action();
}
function post_rumor_setup() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  for (const plname of plorder) { fen.players[plname].rumors = []; }
  for (const plname of plorder) {
    let data = firstCond(Z.playerdata, x => x.name == plname);
    let di = data.state.di;
    for (const k in di) {
      arrPlus(fen.players[k].rumors, di[k]);
    }
  }
  ari_history_list([`gossiping ends`], 'rumors');
  [Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, fen.phase);
  take_turn_fen_clear();
}
function post_sell() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  if (A.selected.length != 2) {
    select_error('select exactly 2 cards to sell!');
    return;
  }
  for (const i of A.selected) {
    let c = A.items[i].key;
    elem_from_to(c, fen.players[uplayer].stall, fen.deck_discard);
  }
  ari_reorg_discard();
  fen.players[uplayer].coins += 1;
  let [i1, i2] = A.selected.map(x => A.items[x].key)
  ari_history_list([`${uplayer} sells ${i1} and ${i2}`], 'sell');
  ari_next_action(fen, uplayer);
}
function post_stall_selected() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let selectedKeys = A.selected.map(i => A.items[i].key);
  for (const ckey of selectedKeys) {
    elem_from_to(ckey, fen.players[uplayer].hand, fen.players[uplayer].stall);
  }
  ensure_stallSelected(fen);
  fen.stallSelected.push(uplayer);
  ari_history_list([`${uplayer} puts up a stall for ${selectedKeys.length} action${plural(selectedKeys.length)}`], 'market');
  if (is_stall_selection_complete()) {
    delete fen.stallSelected;
    fen.actionsCompleted = [];
    if (check_if_church()) ari_start_church_stage(); else ari_start_action_stage();
  } else {
    Z.turn = [get_next_player(Z, uplayer)];
    take_turn_fen();
  }
}
function post_tax() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let items = A.selected.map(x => A.items[x]);
  let n = fen.pl_tax[uplayer];
  if (items.length != n) {
    select_error(`please select exactly ${n} cards`);
    return;
  }
  for (const item of items) {
    elem_from_to_top(item.key, fen.players[uplayer].hand, fen.deck_discard);
  }
  ari_reorg_discard();
  ari_history_list([`${uplayer} pays tax: ${fen.pl_tax[uplayer]}`], 'tax');
  fen.pl_tax[uplayer] = 0;
  let iturn = fen.plorder.indexOf(uplayer);
  let plnext = ari_get_tax_payer(fen, fen.pl_tax, iturn + 1);
  if (plnext == null) {
    [Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, 'king');
    delete fen.pl_tax;
  } else {
    Z.turn = [plnext];
  }
  take_turn_fen(fen, uplayer);
}
function post_tide() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  let items = A.selected.map(x => A.items[x]);
  if (items.length == 0) { select_error('No cards selected!'); return; }
  let st = items.map(x => ({ key: x.key, path: x.path }));
  let val = arrSum(st.map(x => ari_get_card(x.key).val));
  lookupSet(fen, ['players', uplayer, 'tides'], { keys: st, val: val });
  remove_tides_from_play(fen, uplayer);
  let pldone = plorder.filter(x => isdef(fen.players[x].tides));
  let minplayers = arrMin(pldone, x => fen.players[x].tides.val);
  let minplayer = isList(minplayers) ? minplayers[0] : minplayers;
  let minval = fen.tidemin = fen.players[minplayer].tides.val;
  let next = get_next_in_list(uplayer, fen.church_order);
  if (next == fen.church_order[0]) {
    assertion(sameList(pldone, plorder), 'NOT all players have tides!!!!!!!', pldone);
    if (minplayers.length > 1) { proceed_to_newcards_selection(); return; }
    else {
      pldone = pldone.filter(x => x != minplayer);
      let sorted = sortBy(pldone, x => fen.players[x].tides.val);
      let second_min = sorted[0];
      fen.tide_minimum = fen.players[second_min].tides.val - minval;
      //#region check if minplayer has enough
      let pl = fen.players[minplayer];
      let hst = pl.hand.concat(pl.stall);
      let vals = hst.map(x => ari_get_card(x).val);
      let sum = isEmpty(vals) ? 0 : arrSum(vals);
      let min = fen.tide_minimum;
      if (sum < min) {
        pl.hand = [];
        pl.stall = [];
        let buildings = arrFlatten(get_values(pl.buildings));
        console.log('buildings', buildings);
        if (isEmpty(buildings)) {
          ari_history_list([`${minplayer} does not have a building to downgrade!`], 'downgrade');
          proceed_to_newcards_selection();
          return;
        }
        ari_history_list([`${minplayer} must downgrade a building to tide ${min}!`], 'downgrade');
        Z.stage = 22;
      } else {
        ari_history_list([`${minplayer} must tide more cards to reach ${min}!`], 'tide');
        Z.stage = 21;
      }
      //#endregion
      Z.turn = [minplayer];
    }
  } else {
    Z.turn = [next];
  }
  turn_send_move_update();
}
function post_tide_minimum() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  let pl = fen.players[uplayer];
  let items = A.selected.map(x => A.items[x]);
  let st = items.map(x => ({ key: x.key, path: x.path }));
  pl.tides.keys = pl.tides.keys.concat(st);
  let newval = arrSum(st.map(x => ari_get_card(x.key).val));
  pl.tides.val += newval;
  console.log('tide_minimum', fen.tide_minimum);
  console.log('val', pl.tides.val);
  if (newval < fen.tide_minimum) {
    select_error(`you need to tide at least ${fen.tide_minimum} to reach minimum`);
    return;
  }
  remove_tides_from_play(fen, uplayer, st);
  proceed_to_newcards_selection();
}
function post_tithe() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  let items = A.selected.map(x => A.items[x]);
  if (items.length == 0) { select_error('No cards selected!'); return; }
  let st = items.map(x => ({ key: x.key, path: x.path }));
  let val = arrSum(st.map(x => ari_get_card(x.key).val));
  lookupSet(fen, ['players', uplayer, 'tithes'], { keys: st, val: val });
  remove_tithes_from_play(fen, uplayer);
  let pldone = plorder.filter(x => isdef(fen.players[x].tithes));
  let minplayers = arrMin(pldone, x => fen.players[x].tithes.val);
  let minplayer = isList(minplayers) ? minplayers[0] : minplayers;
  let minval = fen.tithemin = fen.players[minplayer].tithes.val;
  let next = get_next_in_list(uplayer, fen.church_order);
  if (next == fen.church_order[0]) {
    assertion(sameList(pldone, plorder), 'NOT all players have tithes!!!!!!!', pldone);
    if (minplayers.length > 1) { proceed_to_newcards_selection(); return; }
    else {
      pldone = pldone.filter(x => x != minplayer);
      let sorted = sortBy(pldone, x => fen.players[x].tithes.val);
      let second_min = sorted[0];
      fen.tithe_minimum = fen.players[second_min].tithes.val - minval;
      //#region check if minplayer has enough
      let pl = fen.players[minplayer];
      let hst = pl.hand.concat(pl.stall);
      let vals = hst.map(x => ari_get_card(x).val);
      let sum = isEmpty(vals) ? 0 : arrSum(vals);
      let min = fen.tithe_minimum;
      if (sum < min) {
        pl.hand = [];
        pl.stall = [];
        let buildings = arrFlatten(get_values(pl.buildings));
        console.log('buildings', buildings);
        if (isEmpty(buildings)) {
          ari_history_list([`${minplayer} does not have a building to downgrade!`], 'downgrade');
          proceed_to_newcards_selection();
          return;
        }
        ari_history_list([`${minplayer} must downgrade a building to tithe ${min}!`], 'downgrade');
        Z.stage = 22;
      } else {
        ari_history_list([`${minplayer} must tithe more cards to reach ${min}!`], 'tithe');
        Z.stage = 21;
      }
      //#endregion
      Z.turn = [minplayer];
    }
  } else {
    Z.turn = [next];
  }
  take_turn_fen();
}
function post_tithe_minimum() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  let pl = fen.players[uplayer];
  let items = A.selected.map(x => A.items[x]);
  let st = items.map(x => ({ key: x.key, path: x.path }));
  pl.tithes.keys = pl.tithes.keys.concat(st);
  let newval = arrSum(st.map(x => ari_get_card(x.key).val));
  pl.tithes.val += newval;
  console.log('tithe_minimum', fen.tithe_minimum);
  console.log('val', pl.tithes.val);
  if (newval < fen.tithe_minimum) {
    select_error(`you need to tithe at least ${fen.tithe_minimum} to reach minimum`);
    return;
  }
  remove_tithes_from_play(fen, uplayer, st);
  proceed_to_newcards_selection();
}
function post_trade() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  if (A.selected.length != 2) {
    select_error('please, select exactly 2 cards!');
    return;
  }
  let i0 = A.items[A.selected[0]];
  let i1 = A.items[A.selected[1]];
  let num_own_stall = [i0, i1].filter(x => x.path.includes(uplayer)).length;
  if (i0.path == i1.path) {
    select_error('you cannot trade cards from the same group');
    return;
  } else if (num_own_stall != 1) {
    select_error('you have to pick one card of your stall and one other card');
    return;
  } else {
    let list0 = lookup(fen, i0.path.split('.'));
    let list1 = lookup(fen, i1.path.split('.'));
    exchange_by_index(list0, i0.o.index, list1, i1.o.index);
    ari_history_list(get_trade_history(uplayer, i0, i1), 'trade');
    animate_card_exchange(i0, i1, ari_next_action);
  }
}
function post_upgrade() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  A.building = A.items[A.selected[0]];
  let gb = A.building;
  let b = lookup(fen, gb.path.split('.'));
  let n = A.upgrade_cards.length;
  let type0 = gb.o.type;
  let len = gb.o.list.length + n;
  let type1 = len == 5 ? 'estate' : 'chateau';
  let target = lookup(fen, gb.path.split('.'));
  for (const o of A.upgrade_cards) {
    let source = lookup(fen, o.path.split('.'));
    elem_from_to(o.key, source, target.list);
  }
  let bres = target;
  bres.h = null;
  removeInPlace(fen.players[uplayer].buildings[type0], bres);
  fen.players[uplayer].buildings[type1].push(bres);
  ari_history_list([`${uplayer} upgrades a ${type0}`], 'upgrade');
  console.log('hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh')
  process_payment();
  setTimeout(ari_next_action, 1000);
}
function post_visit() {
  let [fen, A, uplayer, building, obuilding, owner] = [Z.fen, Z.A, Z.uplayer, Z.A.building, Z.A.obuilding, Z.A.buildingowner];
  let buildingtype = Z.A.building.o.type;
  let res = A.selected[0] == 0;
  if (!res) {
    if (fen.players[owner].coins > 0) {
      fen.players[owner].coins -= 1;
      fen.players[uplayer].coins += 1;
    }
  } else {
    let list = obuilding.list;
    let correct_key = list[0];
    let rank = correct_key[0];
    while (list.length > 0) {
      let ckey = list[0];
      if (ckey[0] != rank) {
        elem_from_to_top(ckey, list, fen.deck_discard);
      } else {
        elem_from_to(ckey, list, fen.players[owner].hand);
      }
    }
    if (isdef(obuilding.h)) {
      fen.deck_discard.unshift(obuilding.h);
    }
    ari_reorg_discard(fen);
    let blist = lookup(fen, stringBeforeLast(building.path, '.').split('.'));
    removeInPlace(blist, obuilding);
  }
  ari_history_list([`${uplayer} visited ${buildingtype} of ${owner} resulting in ${res ? 'destruction' : 'payoff'}`,], 'visit');
  ari_next_action(fen, uplayer);
}
function posTC(d) { mStyleX(d, { right: '50%', top: 0, position: 'absolute' }); }
async function postCors(url, data, type, handle_result) {
  data.data_type = type;
  var formData = new FormData();
  for (const k in data) {
    formData.append(k, data[k]);
  }
  let h = new Headers();
  h.append('Accept', 'application/text');
  var resp = await fetch(url, {
    method: 'POST',
    mode: 'cors',
    headers: h,
    body: formData,
  });
  let result = await resp.text();
  try {
    let jsonResult = JSON.parse(result);
    if (isdef(handle_result)) handle_result(jsonResult);
  } catch {
    if (isdef(handle_result)) handle_result({ message: result });
  }
}
async function postData(url = '', data = {}) {
  // postData('https://example.com/answer', { answer: 42 })
  const response = await fetch(url, {
    method: 'POST',
    mode: 'cors',
    cache: 'no-cache',
    credentials: 'omit',
    headers: {
      'Content-Type': 'application/json'
    },
    redirect: 'follow',
    referrerPolicy: 'no-referrer',
    body: JSON.stringify(data)
  });
  return await response.text(); //'hallo';// response.json(); // parses JSON response into native JavaScript objects
}
function posTL(d) { mPos(d, 0, 0) }
function posTopLeftInCenter(d) { d.classList.add('centered'); }
function posToPoint(pos = 'cc', w, h, offx = 0, offy = 0) {
  let di = { t: 0, b: h, l: 0, r: w };
  let py = pos[0] == 'c' ? h / 2 : di[pos[0]];
  let px = pos[1] == 'c' ? w / 2 : di[pos[1]];
  return [px + offx, py + offy];
}
function posTR(d) { mStyle(d, { right: 0, top: 0, position: 'absolute' }); }
function posXY(d1, dParent, x, y, unit = 'px', position = 'absolute') {
  if (nundef(position)) position = 'absolute';
  if (dParent && !dParent.style.position) dParent.style.setProperty('position', 'relative');
  d1.style.setProperty('position', position);
  if (isdef(x)) d1.style.setProperty('left', makeUnitString(x, unit));
  if (isdef(y)) d1.style.setProperty('top', makeUnitString(y, unit));
}
function pPanel(dParent) { return mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 }); }
function pr(x) {
}
function prelim() {
  console.assert(isdef(DB));
  Speech = new SpeechAPI('E');
  KeySets = getKeySetsX();
  TO = new TimeoutManager();
  initTable();
  initSidebar();
  initAux();
  _start();
}
async function prelims() {
  if (serverData.waiting_for) { await sendStatus(getUsernameForPlid(serverData.waiting_for[0])); }
  if (serverData.end) { d3.select('button').text('RESTART').on('click', restartGame); }
  timit.showTime('* vor package: *')
  preProcessData();
  isTraceOn = SHOW_TRACE;
  G = {};
  PROTO = {};
  POOLS = { augData: makeDefaultPool(jsCopy(serverData)) };
  sData = POOLS.augData;
}
function prelude(s, d) {
}
function prep_for_church_downgrade(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  fen.stage = 1004;
  fen.market = ['JHn', 'QSn'];
  let ob = {}; ob[uplayer] = { estate: 1 }; stage_correct_buildings(fen, ob);
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    pl.hand = ['JHn', 'QSn']; pl.stall = ['JHn', 'QSn'];
    if (plname == uplayer) {
      pl.hand = ['2Hn', '2Sn']; pl.stall = ['AHn', 'ASn'];
    }
  }
}
function prep_move() {
  let [fen, uplayer, pl] = [Z.fen, Z.uplayer, Z.pl];
  for (const k of ['round', 'phase', 'stage', 'step', 'turn']) { fen[k] = Z[k]; }
  deactivate_ui();
  clear_timeouts();
}
function prepParentForChildren(loc, numChildren) {
  let parent = mBy(loc);
  clearElement(loc);
  parent.style.display = 'inline-grid';
  let uiNode = AREAS[loc];
  if (!uiNode.type) uiNode.type = 'panel';
  if (!uiNode.params) uiNode.params = { split: 'equal' };
  uiNode.params.num = numChildren;
  if (!uiNode.panels) uiNode.panels = [];
}
function preProcessData(data) {
  if (nundef(data)) data = serverData;
  for (const plid in data.players) {
    let pl = data.players[plid];
    if (isdef(pl.obj_type)) continue;
    pl.obj_type = plid == plidSentStatus ? 'GamePlayer' : 'opponent';
  }
  if (data.options) {
    tupleGroups = getTupleGroups();
    let iGroup = 0;
    let iTuple = 0;
    boats = [];
    for (const tg of tupleGroups) {
      for (const t of tg.tuples) {
        let boatInfo = { obj_type: 'boat', oids: [], desc: tg.desc, tuple: t, iGroup: iGroup, iTuple: iTuple, text: t.map(x => x.val), weg: false };
        boats[iTuple] = boatInfo;
        iTuple += 1;
      }
      iGroup += 1;
    }
  } else {
    tupleGroups = null;
    boats = [];
  }
}
function PreSearch() {
  if (GameController.GameOver != BOOL.TRUE) {
    srch_thinking = BOOL.TRUE;
    StartThinking();
    setTimeout(function () { StartSearch(); }, 200);
  }
}
function preselectFirstVisualsForBoats() {
  let oidlist = [];
  for (const id of getBoatIds()) {
    let oids = id2oids[id];
    if (isdef(oids)) oids.map(x => addIf(oidlist, x))
  }
  let vislist = oidlist.map(x => getMainId(x)).filter(x => x !== null);
  vislist = vislist.concat(oidlist.map(x => getDefId(x)));
  vislist.map(id => UIS[id].highFrame());
}
function present() {
  if (Settings.perspective == 'me') presentFor(me);
  else presentAll();
}
function present_a_game() {
  let [fen, uplayer, pl] = [Z.fen, Z.uplayer, Z.pl];
  UI.hand = ui_type_hand(pl.hand, dTable, { margin: 20 });
}
function present_account(userdata) {
  DA.imageChanged = DA.colorChanged = false;
  return `
  <div id="dAccount" style="max-width=500px; margin-top:10px; display:flex; animation: appear1 1s ease;justify-content:center; align-content:center">
    <div id="error">some text</div>
    <div style='text-align:center'>
      <form id="myform" autocomplete="off" style='text-align:center;background:${userdata.color}'>
        <span id='img_dd_instruction' style="font-size:11px;">drag and drop an image to change</span><br>
        <img id="imgPreview" onload='addColorPicker("${userdata.color}");' src='${get_image_path(userdata)}' ondragover="handle_drag_and_drop(event)" ondrop="handle_drag_and_drop(event)" ondragleave="handle_drag_and_drop(event)"
          style="height:200px;margin:10px;" />
        <input id='iUsername' type="text" name="motto" placeholder='motto' value="${userdata.motto}" autofocus
          onkeydown="if (event.keyCode === 13){event.preventDefault();collect_data(event);}" />
        <br />
        <input id='save_settings_button' type="button" value="Submit" onclick="collect_data(event)" ><br>
      </form>
  </div></div>
  `;
}
function present_auto(dParent, state) {
  for (const k in state) {
    let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 }, null, k);
    let val = state[k];
    if (isSimple(val)) {
      d.innerHTML += ': ' + val;
    } else if (isList(val)) {
      mCenterCenterFlex(d);
      val.map(x => mDiv(d, { bg: 'random', rounding: 10, margin: 10, padding: 10 }, null, x));
    } else {
      mCenterCenterFlex(d);
      present_auto(d, val);
    }
  }
}
function present_contacts(obj) {
  let others = sync_users(obj.myusers);
  Session.others = others.map(x => x.name);
  var inner_left_panel = mBy("inner_left_panel");
  inner_left_panel.innerHTML = createContactsContent(others, obj.msgs);
}
function present_game_options(tid) {
  if (isdef(tid)) {
    let table = Session.cur_table;
    Session.cur_game = table.game;
    if (nundef(Session.game_options)) Session.game_options = table_options_to_game_options(table);
  } else {
    Session.game_options = {};
  }
  let gname = Session.cur_game;
  let g = DB.games[gname];
  let d = mBy('inner_left_panel');
  d.innerHTML = get_lobby(tid);
  let d1 = mBy('d_game_options');
  group = mRadioGroup(d1, { wmin: 190 }, 'd_players', 'players');
  populate_game_settings(d1, tid);
  populate_playmode(d1, g.av_modes);
  populate_players(isdef(tid) ? get_keys(Session.cur_players) : get_def_players_for_user(Session.cur_user));
}
function present_games() {
  let html = `<div id='game_menu' style="text-align: center; animation: appear 1s ease both">`;
  for (const g of dict2list(DB.games)) { html += ui_game_menu_item(g, Session.tables_by_game[g.id]); }
  mBy('inner_left_panel').innerHTML = html;
  mCenterCenterFlex(mBy('game_menu'));
}
function present_games_dep(obj) {
  bygame = set_tables_by_game(obj);
  Session.cur_tid = !isEmpty(obj.tables) ? obj.tables[0].id : null;
  mBy('inner_left_panel').innerHTML = createGamesContent(dict2list(DB.games), bygame);
  mCenterCenterFlex(mBy('game_menu'));
}
function present_intro() {
  let dParent = mBy('divTest'); show(dParent); clearElement(dParent);
  mStyle(dParent, { position: 'absolute', top: 0, bg: 'green', wmin: '100vw', hmin: '100vw' });
  param_present_contacts(Session, dParent, 'onclick_user_in_intro');
}
function present_login(obj) { param_present_contacts(obj, mBy('inner_left_panel'), 'onclick_user_login'); }
function present_login_new(obj) {
  let others = sync_users(obj.myusers);
  Session.others = others.map(x => x.name);
  var inner_left_panel = mBy("inner_left_panel");
  inner_left_panel.innerHTML = createLoginNewContent(others, obj.msgs);
}
function present_non_admin_user(username) {
  load_user(username);
  get_dictionary();
  poll_for_table_started();
}
function present_non_admin_waiting_screen() {
  let dParent = mBy('divTest'); show(dParent); clearElement(dParent);
  mStyle(dParent, { position: 'absolute', top: 0, bg: 'green', wmin: '100vw', hmin: '100vw' });
  let dlogout = mDiv(dParent, { position: 'absolute', right: 10, top: 4, cursor: 'pointer' }, 'ddd_logout', `logout`);
  dlogout.onclick = onclick_logout;
  show_user_image(Session.cur_user, dParent);
  status_message_new(`hi, ${capitalize(Session.cur_user)}, a game is starting soon...`, dParent, { classname: 'slow_gradient_blink' });
  mLinebreak(dParent, 100);
  show_rankings(dParent);
}
function present_resume_game_options() {
  let gname = Session.cur_game;
  let g = DB.games[gname];
  Session.game_options = {};
  let d = mBy('inner_left_panel');
  let game = DB.games[Session.cur_game];
  let html = `
  <div id="lobby_holder" class="layout_lobby">
    <div id="lobby_header"><div class='logo'>⛱</div>Settings for ${game.friendly}</div>
    <div id="lobby_main">
        <div id='d_game_options' class='vCenterChildren'>
        </div>
        <div class="button_wrapper">
          <button id='bJoinGame' class='button' style='display:none'>join game</button>
          <button id='bCreateGame' class='button' onclick='onclick_create_game_button()' style='display:none'>create game</button>
          <button id='bResumeGame' class='button' onclick='onclick_resume_game_button()'>resume game</button>
          <button id='bLobbyOk' class='button' onclick='onClickCreateGameOk()' style='display:none'>Ok</button>
          <button id='bLobbyCancel' class='button' onclick='onClickCreateGameCancel()' style='display:none'>Cancel</button>
          <button id='bLobbyJoinOk' class='button' onclick='onClickJoinGameOk()' style='display:none'>Ok</button>
          <button id='bLobbyJoinCancel' class='button' onclick='onClickJoinGameCancel()' style='display:none'>Cancel</button>
        </div>
      </div>
    </div>
  `;
  d.innerHTML = html;
  let d1 = mBy('d_game_options');
  group = mRadioGroup(d1, { wmin: 190 }, 'd_players', 'players');
  populate_game_settings(d1);
  populate_playmode(d1, g.av_modes);
  populate_players(get_def_players_for_user(Session.cur_user));
}
function present_simple(dParent, item) {
  if (isDict(item)) {
    mCenterCenterFlex(dParent);
    for (const k in item) {
      let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 }, null, k + ': ');
      val = item[k];
      present_simple(d, val);
    }
  } else if (isList(item)) {
    mCenterCenterFlex(dParent);
    item.map(x => present_simple(dParent, x));
  } else {
    dParent.innerHTML += item;
  }
}
function present_simple0(dParent, item) {
  if (isDict(item)) {
    let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 });
    mCenterCenterFlex(d);
    for (const k in item) {
      d.innerHTML += k;
      present_simple0(d, item[k]);
    }
  } else if (isList(item)) {
    let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 });
    mCenterCenterFlex(d);
    item.map(x => present_simple0(d, x));
  } else {
    let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 });
    d.innerHTML = item;
  }
}
function present_state_player(dParent, state, player) {
  if (!lookup(state, ['players', player])) { console.log('no state for player', player); return; }
  let dplayer = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 }, null, 'your items:');
  present_auto(dplayer, state.players[player]);
  let drest = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 }, null, 'table');
  present_auto(drest, state);
}
function present_structured(dParent, item) {
  let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 });
  if (isDict(item)) {
    mCenterCenterFlex(d);
    for (const k in item) {
      val = item[k];
      let d1 = mDiv(d, { bg: 'random', rounding: 10, margin: 10, padding: 10 }, null, k);
      present_structured(d1, val);
    }
  } else if (isList(item)) {
    mCenterCenterFlex(d);
    item.map(x => present_structured(d, x));
  } else {
    d.innerHTML = item;
  }
}
function present_structured1(dParent, item) {
  if (isDict(item)) {
    mCenterCenterFlex(dParent);
    for (const k in item) {
      val = item[k];
      let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 }, null, k);
      present_structured1(d, val);
    }
    return dParent;
  } else if (isList(item)) {
    let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 });
    mCenterCenterFlex(d);
    item.map(x => present_structured1(d, x));
    return d;
  } else {
    let d = mDiv(dParent, { bg: 'random', rounding: 10, margin: 10, padding: 10 });
    d.innerHTML = item;
    return d;
  }
}
function present_table(obj) {
  Session.cur_menu = 'play';
  console.assert(isdef(obj.table), 'present_table without obj.table!!!!!!!!!!!!!!');
  update_session(obj);
  let table_status = Session.cur_table.status;
  let my_status = Session.cur_me.player_status;
  let have_another_move = my_status == 'joined';
  if (table_status == 'deleted') { in_game_off(); in_game_open_prompt_off(); status_message_off(); get_games(); return; }
  if (!in_game()) { open_game_ui(); in_game_on(); }
  let d = mBy('table'); d.animate([{ opacity: 0, transform: 'translateY(50px)' }, { opacity: 1, transform: 'translateY(0px)' },], { fill: 'both', duration: 1000, easing: 'ease' });
  if (!have_another_move) { reload_last_game_state(); }
  else if (!in_game_open_prompt()) { open_prompt(); in_game_open_prompt_on(); }
  else { uiActivated = true; }
  update_game_status(Session.cur_players);
  if (table_status == 'over') {
    stop_game();
    let winners = Session.winners = race_check_endcondition();
    if (!isEmpty(winners)) {
      stop_game();
      DA.after_status_message = onclick_gameover_screen;
      show_gameover(winners);
    }
  }
}
function present_table_from_csv(csv_text, dParent) {
  prepare_table();
  dParent.innerHTML = get_table_html();
  import_the_text(csv_text);
}
function present_wait_for_table_to_start() {
  status_message(`hi, ${capitalize(Session.cur_user)}, a game is starting soon...`, { top: 330, classname: 'slow_gradient_blink' });
  poll_for_table_started();
}
function present_wait_for_table_to_start_after_reload() {
  status_message(`table has been canceled by host, new game starting soon...`, { top: 330, classname: 'slow_gradient_blink' });
  poll_for_table_started();
}
function present0(dParent, item) {
  for (const k in item) {
    val = item[k];
    let d = mDiv(dParent, { display: 'inline-block', bg: 'random', rounding: 10, margin: 10, padding: 10 });
    if (isDict(val)) {
      present0(d, val);
    } else if (isList(val)) {
      val.map(x => presentSimpleVal(d, x));
    } else {
      presentSimpleVal(d, val);
    }
  }
}
function present00(items, options) {
  [options.rows, options.cols, options.szPic.w, options.szPic.h] = [10, 10, 50, 50];
  console.log('present00: rows', options.rows, 'cols', options.cols);
  let fzOrig = options.fzOrig = options.fzText;
  _setRowsColsSize(options);
  makeItemDivs(items, options);
  if (options.fixTextFont == true) {
    _setTextFont(items, options, (options.fzOrig + options.fzText) / 2);
  }
  let dGrid = mDiv(options.dArea, { hmax: options.area.h, fz: 2, padding: options.gap }, getUID());
  options.idGrid = dGrid.id;
  for (const item of items) { mAppend(dGrid, iDiv(item)); }
  _makeGridGrid(items, options, dGrid);
  let wa = options.area.w, ha = options.area.h;
  let wi = (wa / options.cols) - 1.25 * options.gap;
  let hi = ha / options.rows - 1.25 * options.gap;
  wi = Math.min(200, wi); wi = Math.round(wi);
  hi = Math.min(200, hi); hi = Math.round(hi);
  let fzMax, fpMax;
  if (options.showLabels) {
    fzMax = Math.floor(idealFontDims(options.wLongest, wi - 2 * options.padding, hi, 24).fz);
    fpMax = options.showPic ? Math.min(hi / 2, wi * 2 / 3, hi - fzMax) : 0;
  } else { fzMax = 1; fpMax = options.showPic ? Math.min(hi * 2 / 3, wi * 2 / 3) : 0; }
  options.fzPic = options.picStyles.fz = fpMax;
  options.fzText = options.labelStyles.fz = fzMax;
  options.szPic = { w: wi, h: hi };
  for (const item of items) {
    let ui = item.live;
    mStyleX(ui.div, { wmin: wi, hmin: hi, padding: 0 });
    if (isdef(ui.dPic)) mStyleX(ui.dPic, { fz: fpMax });
    if (isdef(ui.dLabel)) mStyleX(ui.dLabel, { fz: fzMax });
  }
  if (options.fzText < options.fzOrig && options.fixTextFont == true) _setTextFont(items, options, (options.fzOrig + options.fzText) / 2)
  mStyleX(dGrid, { display: 'inline-grid', wmax: options.area.w, hmax: options.area.h });
  if (isOverflown(dGrid)) {
    let factor = .9;
    w = options.szPic.w * factor;
    h = options.szPic.h * factor;
    fz = options.fzText * factor;
    fzPic = options.fzPic * factor;
    options.fzPic = options.picStyles.fz = fzPic;
    options.fzText = options.labelStyles.fz = fz;
    options.szPic = { w: w, h: h };
    options.padding *= factor;
    options.gap *= factor;
    mStyleX(dGrid, { gap: options.gap / 2 });
    for (const item of items) {
      let ui = item.live;
      if (options.showLabels) mStyleX(ui.dLabel, { fz: fz });
      mStyleX(ui.div, { padding: options.padding, w: w, h: h });
      mStyleX(ui.dPic, { fz: fzPic });
    }
  }
  return [items, options];
}
function presentActions() {
  deleteActions();
  let areaName = 'a_d_divSelect';
  UIS[areaName].elem.scrollTop = 0;
  let iGroup = 0;
  let iTuple = 0;
  for (const tg of G.tupleGroups) {
    for (const t of tg.tuples) {
      let boatInfo = { obj_type: 'boat', oids: [], desc: tg.desc, tuple: t, iGroup: iGroup, iTuple: iTuple, text: t.map(x => x.val), weg: false };
      let mobj = makeDefaultAction(boatInfo, areaName);
      iTuple += 1;
    }
    iGroup += 1;
  }
}
function presentAddNode(n, title, area, lf, ls, lo) {
  if (nundef(lo)) lo = [];
  addIf(lo, 'act');
  addIf(lo, 'ui');
  let d = isString(area) ? mBy(area) : area;
  mNodeFilter(n, { dParent: d, title: title, lstFlatten: lf, lstShow: ls, lstOmit: lo });
}
function presentAll() {
  clearZones();
  for (const pl of T.players) {
    let zone = Zones[pl.id];
    pl.hand.showDeck(zone.dData, 'right', 0, false);
  }
  showTrick();
}
function presentAllProps(oid, pool, ms) {
  let o_new = pool[oid];
  let akku = [];
  for (const prop in o_new) {
    let nval = o_new[prop];
    let sval = simpleRep(nval);
    akku.push(prop + ':' + sval);
  }
  ms.multitext({ txt: akku, fz: 12, fill: 'black' });
}
function presentChoices() {
  G.tupleGroups = getTupleGroups();
  decider.genMove(
    G,
    idx => {
      freezeUI();
      sendAction(idx, [gameStep]);
    },
  );
  timit.end_of_cycle('');
}
function presentDefault(oid, o, isTableObject = true) {
  let mobj = getDefVisual(oid);
  if (!mobj) return;
  if (isPlain() && !isTableObject && G.player == oid) { mobj.hide(); return null; }
  if (isPlain() && !isTableObject) mobj.show();
  let optin = isTableObject ? S.settings.table.optin : S.settings.player.optin;
  let optout = isTableObject ? S.settings.table.optout : S.settings.player.optout;
  keys = optout ? arrMinus(getKeys(o), optout) : optin ? optin : getKeys(o);
  let x = mobj.tableX(o, keys);
  if (!isPlain() && !isTableObject) {
    growIfDefaultMainAreaWidth(mobj);
  }
  return x;
}
function presentDictTree(nDict, uidStart, area, treeProperty, R, lf, ls, lo, styles) {
  if (nundef(nDict)) {
    console.log('presentDictTree: cannot present nDict!!!');
    return;
  }
  d = mBy(area);
  let depth = 10;
  let dLevel = [];
  for (let i = 0; i < depth; i++) {
    let d1 = dLevel[i] = mDiv(d);
    mColor(d1, colorTrans('black', i * .1));
    if (isdef(styles)) mStyleX(d1, styles);
  }
  if (isEmpty(nDict)) return;
  maxLevel = 1 + recPresent(nDict[uidStart], 0, dLevel, nDict, treeProperty,
    { lstFlatten: lf, lstShow: ls, lstOmit: lo });
}
function presentEnd() {
  if (nundef(G.end)) return false;
  let winner = G.serverData.end.winner;
  let msg = winner == null ? 'Both players win!' : 'Winner is ' + G.playersAugmented[winner].name;
  setStatus('GAME OVER! ' + msg);
  if (winner) {
    setCSSVariable('--bgWinner', G.playersAugmented[winner].color);
    areaBlink('a_d_status');
  }
  S_autoplay = false;
  unfreezeUI();
  let d = document.getElementById('a_d_divSelect');
  clearElement(d);
  d.scrollTop = 0;
  return true;
}
function presentFor(me) {
  clearElement(dTable);
  let others = arrWithout(T.players, [me]);
  for (const pl of others) {
    pl.hand.showDeck(dTable, 'right', 0, false);
  }
  mLinebreak(dTable);
  T.trick.showDeck(dTable, 'right', 20, true);
  mLinebreak(dTable);
  me.hand.showDeck(dTable, 'right', 0, false);
  showFleetingMessage('click to play a card!');
}
function presentGenerations_dep(indices, area, R, genKey = 'G') {
  d = mBy(area);
  let level = 0;
  let depth = 10;
  let dLevel = [];
  for (let i = 0; i < depth; i++) {
    let d1 = dLevel[i] = mDiv(d);
    mSize(d1, '100%', 'auto');
    mFlexWrap(d1)
    mColor(d1, colorTrans('black', i * .1));
  }
  let di = 0;
  for (const i of indices) {
    let div = dLevel[di]; di++;
    presentNodes(R.gens[genKey][i], div);
  }
}
function presentInChatList(result, dParent) {
  let d2 = mDiv(dParent, { display: 'flex', gap: 10, margin: 10, padding: 10, bg: 'white', fg: 'dimgray' });
  d2.setAttribute('username', result.username);
  let path = getProfileImagePath(result);
  let img = mImg(path, d2, { h: 50 });
  let d3 = mDiv(d2);
  let name = mText(result.username, d3);
  return d2;
}
function presentInContactMenu(result, d1) {
  let d2 = mDiv(d1, { position: 'relative' }, null, null, 'contact');
  d2.setAttribute('username', result.username);
  let dir = '../base/assets/images/';
  let path = dir + (result.hasImage ? result.username : 'unknown_user') + '.jpg';
  let img = mImg(path, d2, {});
  let name = mText(result.username, d2);
  return d2;
}
function presentItems(items, dParent, rows) {
  //#region phase3: prep container for items
  //#endregion
  //#region phase4: add items to container!
  let dGrid = mDiv(dParent);
  items.map(x => mAppend(dGrid, x.div));
  let gridStyles = { 'place-content': 'center', gap: 4, margin: 4, padding: 4 };
  let gridSize = layoutGrid(items, dGrid, gridStyles, { rows: rows, isInline: true });
  //#endregion
  return { dGrid: dGrid, sz: gridSize };
}
function presentLocationChange(oid, ms) {
  if (G.table[oid].obj_type == 'robber') {
    let o = G.table[oid];
    let changedProps = G.tableUpdated[oid];
    if (changedProps.summary.includes('loc')) {
      let oidLoc = o.loc._obj;
      let visLoc = getVisual(oidLoc);
      ms.setPos(visLoc.x, visLoc.y);
    }
  }
}
function presentLog() {
  let pl = G.player;
  let logId = 'a_d_log' + '_' + pl;
  if (!UIS[logId]) makeLogArea(pl);
  let d = document.getElementById(logId);
  let BASEMARGIN = 16;
  for (const k of G.logUpdated) {
    let logEntry = G.log[pl][k];
    let lineArr = logEntry.line;
    let lineDiv = document.createElement('div');
    lineDiv.style.marginLeft = '' + (BASEMARGIN * (logEntry.level)) + 'px';
    for (const item of lineArr) {
      if (isSimple(item)) {
        let s = trim(item.toString());
        if (!isEmpty(s)) {
          lineDiv.appendChild(document.createTextNode(item));
        }
      } else if (isDict(item)) {
        if (item.type == 'obj') {
          let oid = item.ID;
          let mobj = makeAux(item.val, oid, 'a_d_log', lineDiv);
        } else if (item.type == 'player') {
          let oid = item.val;
          let mobj = makeAux(item.val, oid, 'a_d_log', lineDiv);
        } else {
        }
      }
    }
    d.appendChild(lineDiv);
    d.scrollTop = d.scrollHeight;
  }
}
function presentMain(oid, mobj, pool, isTableObject = true) {
  if (mobj.isa.card) {
    let collKey = mobj.collectionKey;
    if (isdef(collKey)) {
    }
  }
  let o = pool[oid];
  let validKeys = computePresentedKeys(o, isTableObject);
  let color = S.settings.useColorHintForProperties ? getColorHint(o) : mobj.fg;
  let akku = [];
  for (const k of validKeys) {
    let val = o[k];
    if (isSimple(val)) akku.push(val.toString());
  }
  if (!isEmpty(akku)) { mobj.multitext({ txt: akku, fill: color }); } else mobj.clearText();
}
function presentMainMenu() {
  console.log('playMode:', S.settings.playMode, 'PLAYMODE', PLAYMODE, 'S.playModeChanged', S.playModeChanged)
  S.gameInProgress = false;
  initDom();
  openTabTesting('Redmond');
}
function presentMainPlayer(oid, mobj, pool, isTableObject) {
  let o = pool[oid];
  if (!mobj) return;
  if (oid != G.player) { mobj.hide(); return; } else mobj.show();
  let optin = S.settings.player.optin;
  let optout = S.settings.player.optout;
  keys = optout ? arrMinus(getKeys(o), optout) : optin ? optin : getKeys(o);
  let x = mobj.tableX(o, keys);
  growIfDefaultMainAreaWidth(mobj);
  return x;
}
function presentMappings(oid, o) {
  let otype = o.obj_type;
  if (mappingTypes[otype]) {
    if (mappingsInitialized[otype + '.' + oid]) return;
    let mm = mappings.filter(x => x[otype]);
    let onlyOnce = false;
    for (const mapping of mm) {
      executeMapping(mapping, otype, oid, o);
    }
    if (onlyOnce) mappingsInitialized[otype + '.' + oid] = true;
  }
}
function presentNicely(oid, pool, ms) {
  let o_new = pool[oid];
  let akku = [];
  for (const prop in o_new) {
    let nval = o_new[prop];
    let sval = simpleRep(nval);
    akku.push(prop + ':' + sval);
  }
  ms.multitext({ txt: akku, fz: 12, fill: 'black' });
}
function presentNode(o, title, area, lstFlatten, lstShow, lstOmit = [], lstOmitTopLevel = []) {
  if (!isEmpty(lstOmitTopLevel)) {
    let oNew = {};
    for (const k in o) {
      if (lstOmitTopLevel.includes(k)) continue;
      oNew[k] = o[k];
    }
    o = oNew;
  }
  addIf(lstOmit, 'act');
  addIf(lstOmit, 'ui');
  addIf(lstOmit, 'live');
  let d = isString(area) ? mBy(area) : area;
  mNodeFilter(o, { dParent: d, title: title, lstFlatten: lstFlatten, lstShow: lstShow, lstOmit: lstOmit });
}
function presentNodes(sp, area, lf, ls, lo) {
  for (const k in sp) {
    presentAddNode(sp[k], k, area, lf, ls, lo);
  }
}
function presentOidNodes(R, area, lf, ls, lo) {
  for (const oid in R._sd) {
    let rsg = R.getR(oid);
    if (!isEmpty(rsg)) {
      let x = { rsg: rsg };
      presentAddNode(x, oid, area, ['rsg'], ls, lo);
    }
  }
}
function presentPlayer(id, ms, o_new, o_old, options) {
  let res = {};
  if (isdef(G.player)) res.color = G.players[G.player].color;
  return res;
}
function presentPlayers() {
  _playersCreateNew();
  _playersUpdate();
}
function presentPlayersSimple() {
}
function presentRoot_dep(n, area, lf, ls, lo) {
  d = mBy(area);
  let depth = 10;
  let dLevel = [];
  for (let i = 0; i < depth; i++) {
    let d1 = dLevel[i] = mDiv(d);
    mColor(d1, colorTrans('black', i * .1));
  }
  addIf(lo, 'act');
  addIf(lo, 'ui');
  maxLevel = 1 + recPresentFilter(n, 0, dLevel, { lstFlatten: lf, lstShow: ls, lstOmit: lo });
}
function presentRootPresetLists_dep(n, area) {
  let lstFlatten = ['type', 'pool', 'source', 'data', 'content'];
  let lstShow = ['type', 'oid', 'data', 'content', 'pool'];
  let lstOmit = ['act', 'bi', 'sub', '_id', '_ref', 'children', 'source', 'specKey', 'params', 'cssParams', 'typParams', 'stdParams', 'uid', 'ui'];
  d = mBy(area);
  let level = 0;
  let depth = 10;
  let dLevel = [];
  for (let i = 0; i < depth; i++) {
    let d1 = dLevel[i] = mDiv(d);
    mColor(d1, colorTrans('black', i * .1));
  }
  maxLevel = 1 + recPresentFilter(n, 0, dLevel, { lstFlatten: lstFlatten, lstShow: lstShow, lstOmit: lstOmit });
  removeInPlace(lstOmit, 'children');
}
function presentServerData(sdata, area) {
  let d = mBy(area);
  clearElement(d);
  for (const [k, v] of Object.entries(sdata)) {
    mNode(v, { title: k, dParent: d, omitEmpty: true });
  }
}
function presentSimpleVal(d, item) {
  let d1 = mDiv(d, { display: 'inline-block', bg: 'random', rounding: 10, margin: 10, padding: 10 });
  d1.innerHTML = item;
}
function presentSpecAndCode(callbacks = []) {
  let d = document.getElementById('a_d_spec_content');
  if (S.user.spec && S.settings.userSettings) {
    d.innerHTML = S.user.specText;
  } else { d.innerHTML = ''; }
  d = document.getElementById('a_d_code_content');
  if (S.user.script && S.settings.userBehaviors) {
    d.innerHTML = S.user.script;
  } else { d.innerHTML = ''; }
  $('pre').html(function () {
    return this.innerHTML.replace(/\t/g, '&nbsp;&nbsp;');
  });
  if (!isEmpty(callbacks)) callbacks[0](arrFromIndex(callbacks, 1));
}
function presentState1(state, areas) {
  let trick1 = arrFlatten(state.pl1.trick)
  let trick2 = arrFlatten(state.pl2.trick);
  let pl1Hand = state.pl1.hand;
  let pl2Hand = state.pl2.hand;
  let arrs = [[trick1, trick2], [pl1Hand], [pl2Hand]];
  let hands = [];
  for (let i = 0; i < 3; i++) {
    let area = areas[i];
    let d = diContent(area);
    iMessage(area, '');
    for (let j = 0; j < arrs[i].length; j++) {
      let arr = arrs[i][j];
      let id = 'a' + i + '_h' + j;
      let what = iH00(arr, d, {}, id);
      hands.push(what);
    }
  }
  for (let i = 0; i < 2; i++) {
    let cards = hands[i].iHand.items;
    if (isEmpty(hands[i].arr)) continue;
    console.log('cards', cards, 'hands[i]', hands[i])
    for (let j = 0; j < cards.length - 1; j++) {
      Card52.turnFaceDown(cards[j]);
    }
  }
}
function presentStatus() {
  if (isdef(G.serverData.status)) {
    let lineArr = G.serverData.status.line;
    let areaName = isPlain() ? 'c_d_statusInHeaderText' : 'c_d_statusText';
    let d = document.getElementById(areaName);
    let mobj = UIS[areaName];
    mobj.clear(); clearElement(d);
    let pl = G.player;
    let msStatus = makeAux(G.playersAugmented[pl].username + ' (' + pl + ')', pl, areaName);
    let color = getPlayerColor(pl);
    msStatus.setBg(color);
    msStatus.setFg(colorIdealText(color));
    d.appendChild(document.createTextNode(': '));
    for (const item of lineArr) {
      if (isSimple(item)) {
        let s = trim(item.toString());
        if (!isEmpty(s)) {
          d.appendChild(document.createTextNode(item));
        }
      } else if (isDict(item)) {
        if (item.type == 'obj') {
          let oid = item.ID;
          let mobj = makeAux(item.val, oid, areaName);
        } else if (item.type == 'player') {
          let oid = item.val;
          let mobj = makeAux(item.val, oid, areaName);
        }
      }
    }
  }
}
function presentTable() {
  _tableRemove();
  _tableCreateNew();
  _tableUpdate();
}
function presentTableSimple() {
  _tableRemoveSimple();
  _tableCreateNewSimple();
  _tableUpdateSimple();
}
async function presentTree(uiRoot, R) {
  if (R.presentationStrategy == 'rec') {
    recPresentNode(uiRoot, R, uiRoot.params);
  } else if (R.presentationStrategy == 'new') {
    recMeasureOverride(R.tree.uid, R);
  } else if (R.presentationStrategy == 'orig') {
    if (uiRoot.params.sizing == 'sizeToContent') {
      recMeasureAbs(R.tree.uid, R);
      recArrangeContent(R.tree.uid, R);
    } else if (uiRoot.params.sizing == 'fixed') {
      let [minx, maxx, miny, maxy] = recMeasureArrangeFixedSizeAndPos(R.tree.uid, R);
      uiRoot.size = { w: maxx, h: maxy };
      uiRoot.ui.style.minWidth = (uiRoot.size.w + 4) + 'px';
      uiRoot.ui.style.minHeight = (uiRoot.size.h + 4) + 'px';
    } else {
      recMeasureOverride(R.tree.uid, R);
    }
  } else if (nundef(R.presentationStrategy)) {
    if (uiRoot.params.sizing == 'sizeToContent') {
      recMeasureAbs(R.tree.uid, R);
      recArrangeContent(R.tree.uid, R);
    } else if (uiRoot.params.sizing == 'fixed') {
      let [minx, maxx, miny, maxy] = recMeasureArrangeFixedSizeAndPos(R.tree.uid, R);
      uiRoot.size = { w: maxx, h: maxy };
      uiRoot.ui.style.minWidth = (uiRoot.size.w + 4) + 'px';
      uiRoot.ui.style.minHeight = (uiRoot.size.h + 4) + 'px';
    } else {
      recMeasureOverride(R.tree.uid, R);
    }
  } else {
    trace('UNKNOWN presentationStrategy!!!!!!', R.presentationStrategy)
  }
}
function presentTree_dep(n, treeProperty, area, R, lf, ls, lo) {
  d = mBy(area);
  let depth = 10;
  let dLevel = [];
  for (let i = 0; i < depth; i++) {
    let d1 = dLevel[i] = mDiv(d);
    mColor(d1, colorTrans('black', i * .1));
  }
  let nDict = R.rNodes;
  maxLevel = 1 + recPresent(n, 0, dLevel, nDict, treeProperty, { lstFlatten: lf, lstShow: ls, lstOmit: lo });
}
function presentVisible(id, ms, o_new, o_old, options) {
  let visPlayers = getVisibleList(o_new);
  let visColors = visPlayers.map(x => G.players[x].color);
  dots(ms, visColors.length, { UL: false, UR: true, colors: visColors });
}
function presentWaitingFor() {
  if (G.serverData.error) {
    alert(G.serverData.error.type + ' ' + G.serverData.error.msg);
    return;
  }
  let pl = G.serverData.waiting_for[0];
  if (nundef(G.previousWaitingFor) || G.previousWaitingFor != pl) {
    G.previousWaitingFor = pl;
    _updatePageHeader(pl);
  }
  if (S.settings.playmode != 'passplay' && (isMyPlayer(pl) || isFrontAIPlayer(pl) && isMyPlayer(G.player))) {
    let user = G.playersAugmented[pl].username;
    sendStatus(user, [gameStep]);
  } else if (S.settings.playmode == 'passplay') {
    _showPassToNextPlayer(pl);
  } else {
    socketEmitMessage({ type: 'poll', data: pl });
  }
}
function presentWordProblem() {
}
function previewBrowsedFile(dParent, imgFile) {
  var imgView = document.createElement("div");
  imgView.className = "image-view";
  mAppend(dParent, imgView);
  var img = document.createElement("img");
  imgView.appendChild(img);
  var reader = new FileReader();
  reader.onload = function (e) {
    img.src = e.target.result;
    imgFile.data = e.target.result;
  }
  reader.readAsDataURL(imgFile);
}
function previewImageFromFile(imgFile, img) {
  var reader = new FileReader();
  reader.onload = function (e) {
    img.src = e.target.result;
    imgFile.data = e.target.result;
  }
  reader.readAsDataURL(imgFile);
}
function previewImageFromUrl(url, img) {
  img.onerror = function () {
    alert("Error in uploading");
  }
  img.crossOrigin = "";
  img.src = url;
}
function prex(x) {
  prll(expand(x));
}
function PRHLayout() {
  let drr = UI.DRR = mDiv(dTable);
  mAppend(drr, UI.dHistory);
  Clientdata.historyLayout = 'prh';
}
function print_board(gameArr) {
  console.log()
  for (i = 0; i < 9; i++) {
    let row = get_row(gameArr, i)
    if (i % 3 == 0) {
      console.log("|=======|=======|=======|")
    }
    console.log("|",
      print_cell(row[0]), print_cell(row[1]), print_cell(row[2]), "|",
      print_cell(row[3]), print_cell(row[4]), print_cell(row[5]), "|",
      print_cell(row[6]), print_cell(row[7]), print_cell(row[8]), "|")
  }
  console.log("|=======|=======|=======|")
}
function print_cell(value) {
  if (Array.isArray(value)) {
    return "."
  } else if (value == 0) {
    return "."
  } else {
    return value
  }
}
function printBoard(arr, rows, cols, reduced = true) {
  let arrR = boardArrOmitFirstRowCol(arr, rows, cols);
  let s = toBoardString(arrR, rows, cols);
  console.log('board', s);
}
function PrintBoard() {
  return;
  var sq, file, rank, piece;
  console.log("\nGame Board:\n");
  for (rank = RANKS.RANK_8; rank >= RANKS.RANK_1; rank--) {
    var line = ((rank + 1) + "  ");
    for (file = FILES.FILE_A; file <= FILES.FILE_H; file++) {
      sq = FR2SQ(file, rank);
      piece = brd_pieces[sq];
      line += (" " + PceChar[piece] + " ");
    }
    console.log(line);
  }
  console.log("");
  var line = "   ";
  for (file = FILES.FILE_A; file <= FILES.FILE_H; file++) {
    line += (' ' + String.fromCharCode('a'.charCodeAt() + file) + ' ');
  }
  console.log(line);
  console.log("side:" + SideChar[brd_side]);
  console.log("enPas:" + brd_enPas);
  line = "";
  if (brd_castlePerm & CASTLEBIT.WKCA) line += 'K';
  if (brd_castlePerm & CASTLEBIT.WQCA) line += 'Q';
  if (brd_castlePerm & CASTLEBIT.BKCA) line += 'k';
  if (brd_castlePerm & CASTLEBIT.BQCA) line += 'q';
  console.log("castle:" + line);
  console.log("key:" + brd_posKey.toString(16));
}
function printGameLine() {
  var moveNum = 0;
  var gameLine = "";
  for (moveNum = 0; moveNum < brd_hisPly; ++moveNum) {
    gameLine += PrMove(brd_history[moveNum].move) + " ";
  }
  return $.trim(gameLine);
}
function printMatrix(arr2d, title = 'result') {
  let rows = arr2d.length;
  let cols = arr2d[0].length;
  let arr = arrFlatten(arr2d);
  let s = toBoardString(arr, rows, cols);
  console.log(title, s)
}
function PrintMoveList() {
  var index;
  var move;
  console.log("MoveList:");
  for (index = brd_moveListStart[brd_ply]; index < brd_moveListStart[brd_ply + 1]; ++index) {
    move = brd_moveList[index];
    console.log("Move:" + (index + 1) + " > " + PrMove(move));
  }
}
function PrintPceLists() {
  var piece, pceNum;
  for (piece = PIECES.wP; piece <= PIECES.bK; ++piece) {
    for (pceNum = 0; pceNum < brd_pceNum[piece]; ++pceNum) {
      console.log("Piece " + PceChar[piece] + " on " + PrSq(brd_pList[PCEINDEX(piece, pceNum)]));
    }
  }
}
function PrintPieceLists() {
  var piece, pceNum;
  for (piece = PIECES.wP; piece <= PIECES.bK; ++piece) {
    for (pceNum = 0; pceNum < BFBoard.pceNum[piece]; ++pceNum) {
      console.log('Piece ' + PceChar[piece] + ' on ' + PrSq(BFBoard.pList[PCEINDEX(piece, pceNum)]));
    }
  }
}
function PrintSqAttacked() {
  var sq, file, rank, piece;
  console.log("\nAttacked:\n");
  for (rank = RANKS.RANK_8; rank >= RANKS.RANK_1; rank--) {
    var line = ((rank + 1) + "  ");
    for (file = FILES.FILE_A; file <= FILES.FILE_H; file++) {
      sq = FR2SQ(file, rank);
      if (SqAttacked(sq, COLOURS.BLACK) == BOOL.TRUE) piece = "X";
      else piece = "-";
      line += (" " + piece + " ");
    }
    console.log(line);
  }
  console.log("");
}
function printState(state, cols, rows) {
  let formattedString = '';
  state.forEach((cell, index) => {
    formattedString += isdef(cell) ? ` ${cell == '0' ? ' ' : cell} |` : '   |';
    if ((index + 1) % cols == 0) {
      formattedString = formattedString.slice(0, -1);
      if (index < rows * cols - 1) {
        let s = '\u2015\u2015\u2015 '.repeat(cols);
        formattedString += '\n' + s + '\n';
      }
    }
  });
  console.log('%c' + formattedString, 'color: #6d4e42;font-size:10px');
  console.log();
}
function prj(j) {
}
function prjstart(j) {
}
function prlist(arr) {
  if (isList(arr)) {
    if (isEmpty(arr)) return '';
    else return '[' + prlist(arr[0]) + arr.slice(1).map(x => ',' + prlist(x)) + ']';
  } else return arr;
}
function prll(ll) {
  if (!isList(ll)) {
    testHelpers('NOT a list', ll);
    return;
  }
  for (const l of ll) {
    if (!isList(ll)) {
      return;
    }
  }
  let s = '[';
  for (const l of ll) {
    s += '[' + l.toString() + ']';
  }
  s += ']';
  testHelpers(s);
}
function PrMove(move) {
  var MvStr;
  var ff = FilesBrd[FROMSQ(move)];
  var rf = RanksBrd[FROMSQ(move)];
  var ft = FilesBrd[TOSQ(move)];
  var rt = RanksBrd[TOSQ(move)];
  MvStr = String.fromCharCode('a'.charCodeAt() + ff) + String.fromCharCode('1'.charCodeAt() + rf) +
    String.fromCharCode('a'.charCodeAt() + ft) + String.fromCharCode('1'.charCodeAt() + rt)
  var promoted = PROMOTED(move);
  if (promoted != PIECES.EMPTY) {
    var pchar = 'q';
    if (PieceKnight[promoted] == BOOL.TRUE) {
      pchar = 'n';
    } else if (PieceRookQueen[promoted] == BOOL.TRUE && PieceBishopQueen[promoted] == BOOL.FALSE) {
      pchar = 'r';
    } else if (PieceRookQueen[promoted] == BOOL.FALSE && PieceBishopQueen[promoted] == BOOL.TRUE) {
      pchar = 'b';
    }
    MvStr += pchar;
  }
  return MvStr;
}
function ProbePvTable() {
  var index = brd_posKey % PVENTRIES;
  if (brd_PvTable[index].posKey == brd_posKey) {
    return brd_PvTable[index].move;
  }
  return NOMOVE;
}
function proceed(nextLevel) {
  if (nundef(nextLevel)) nextLevel = currentLevel;
  if (nextLevel > MAXLEVEL) {
    let iGame = gameSequence.indexOf(currentGame) + 1;
    if (iGame == gameSequence.length) {
      soundGoodBye();
      mClass(document.body, 'aniSlowlyDisappear');
      show(dLevelComplete);
      dLevelComplete.innerHTML = 'CONGRATULATIONS! You are done!';
    } else {
      let nextGame = gameSequence[iGame];
      startGame(nextGame);
    }
  } else if (LevelChange) startLevel(nextLevel);
  else startRound();
}
function proceed_to_newcards_selection() {
  let fen = Z.fen;
  let selorder = fen.selorder = sortByFuncDescending(fen.church_order, x => fen.players[x].tithes.val);
  fen.toBeSelected = jsCopy(selorder);
  fen.plorder = selorder;
  Z.turn = [selorder[0]];
  Z.stage = 19;
  take_turn_fen();
}
function proceedIfNotStepByStep(nextLevel) {
  if (!StepByStepMode) { proceed(nextLevel); }
}
function proceedRedraw() {
  flags.specAndDOM = true;
  let xdata = G.serverData;
  G = { table: {}, players: {}, signals: {} };
  UIS = {};
  IdOwner = {};
  id2oids = {};
  oid2ids = {};
  id2uids = {};
  initDom();
  gameStep(xdata);
}
function proceedToConfig() {
  populateGamenames();
  hideEventList();
  showGameConfig();
  setMessage('Setup new game!');
  hide('bJoinGame');
  hide('bCreateGame');
  show('bLobbyOk');
  show('bLobbyCancel');
  show('bResumeGame');
  updateGamename(S.settings.game);
  updatePlayersForGame();
  updatePlaymode(S.settings.playmode);
  updatePlayersForMode();
}
function process_auction() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  if (isEmpty(A.selected)) A.selected = [0];
  let playerbid = Number(valf(A.items[A.selected[0]].a, '0'));
  lookupSet(fen, ['auction', uplayer], playerbid);
  let iturn = fen.plorder.indexOf(uplayer) + 1;
  if (iturn >= fen.plorder.length) {
    let list = dict2list(fen.auction, 'uplayer');
    list = sortByDescending(list, 'value');
    let max = list[0].value;
    if (max == 0) {
      Z.stage = 4;
      Z.turn = [fen.plorder[0]];
      take_turn_fen();
      return;
    }
    let second = fen.second_most = list.length == 1 ? randomNumber(0, max) : list[1].value;
    Z.stage = 13;
    let maxplayers = fen.maxplayers = list.filter(x => x.value == max).map(x => x.uplayer);
    Z.turn = [maxplayers[0]];
    for (const plname of plorder) {
      ari_history_list([`${plname} bids ${fen.auction[plname]}`], 'auction');
    }
    ari_history_list([`auction winner${if_plural(fen.maxplayers.length)}: ${fen.maxplayers.join(', ')} (price: ${fen.second_most} coin)`], 'auction');
  } else {
    Z.turn = [fen.plorder[iturn]];
  }
  take_turn_fen();
}
function process_blackmail() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  console.log('selected building to blackmail:', item);
  let building_owner = stringAfter(item.o.path, '.'); building_owner = stringBefore(building_owner, '.');
  let path = item.o.path;
  fen.blackmail = { blackmailer: uplayer, blackmailed: building_owner, payment: A.payment, building_path: path };
  let fenbuilding = lookup(fen, path.split('.'));
  console.log('blackmail:', fen.blackmail);
  fenbuilding.isblackmailed = true;
  ari_history_list([`${uplayer} is blackmailing ${building_owner}`], 'blackmail');
  [Z.stage, Z.turn] = [33, [building_owner]];
  console.log('hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh')
  process_payment();
  setTimeout(take_turn_fen, 1000);
}
function process_comm_setup() {
  let [fen, A, uplayer, plorder, pl] = [Z.fen, Z.A, Z.uplayer, Z.plorder, Z.pl];
  assertion(fen.keeppolling == true, "keeppolling must be true for process_comm_setup!!!");
  if (DA.hallo) {
    console.log('process_comm_setup:', Z.playerdata, Z.stage, uplayer, pl);
    return;
  }
  let items = A.selected.map(x => A.items[x]);
  let next = get_next_player(Z, uplayer);
  let receiver = next;
  let giver = uplayer;
  let keys = items.map(x => x.key);
  Z.state = { giver: giver, receiver: receiver, keys: keys };
  assertion(isdef(Z.playerdata), "Z.playerdata must be defined for process_comm_setup!!!");
  let data = firstCond(Z.playerdata, x => x.name == uplayer);
  assertion(isdef(data), `MISSING: playerdata for ${uplayer}`);
  data.state = Z.state;
  let can_resolve = check_resolve();
  if (can_resolve) {
    Z.turn = [Z.host];
    Z.stage = 104; //'next_comm_setup_stage';
    take_turn_fen_write();
  } else {
    if (Z.mode == 'hotseat') { Z.turn = [get_next_player(Z, uplayer)]; take_turn_fen_write(); }
    else take_turn_multi();
  }
}
function process_command() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  let item = A.last_selected;
  if (nundef(item)) { post_pass(); return; }
  A.selected = [item.index];
  let a = A.items[A.selected[0]];
  A.command = a.key;
  ari_pre_action();
}
function process_commission() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  A.commission = A.items[A.selected[0]];
  if (A.commission.similar.length > 1) {
    Z.stage = 37;
  } else {
    A.commission_stall_item = A.commission.similar[0];
    Z.stage = 16;
  }
  ari_pre_action();
}
function process_commission_stall() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  console.log('process_commission_stall selected', A.selected, 'item', A.items[A.selected[0]]);
  Z.A.commission_stall_item = A.items[A.selected[0]];
  Z.stage = 16;
  ari_pre_action();
}
function process_downgrade() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  A.building = A.items[A.selected[0]];
  fen.stage = Z.stage = 103;
  let items = ui_get_hidden_building_items(A.building.o);
  items.map(x => face_up(x.o));
  A.possible_downgrade_cards = items;
  ari_pre_action();
}
function process_inspect() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  let cards = item.o.items;
  cards.map(x => face_up(x))
  weiter_process_inspect();
}
function process_journey() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  if (isEmpty(A.selected)) {
    if (nundef(fen.passed)) fen.passed = []; fen.passed.push(uplayer);
    [Z.stage, Z.turn] = set_journey_or_stall_stage(fen, Z.options, Z.phase);
    take_turn_fen();
    return;
  }
  let sel = A.selected.map(x => A.items[x].key);
  let [carditems, journeyitem, jlegal] = check_correct_journey(A, fen, uplayer);
  if (!carditems) return;
  delete fen.passed;
  [A.carditems, A.journeyitem, A.jlegal] = [carditems, journeyitem, jlegal];
  Z.stage = A.journeyitem ? 30 : 31;
  ari_pre_action();
}
function process_payment() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let item = A.payment;
  is_coin_pay = nundef(item.o);
  if (is_coin_pay) a2_pay_with_coin(uplayer); else a2_pay_with_card(item);
  ari_history_list(get_pay_history(is_coin_pay ? 'coin' : item.o.key, uplayer), 'payment');
  A.payment_complete = true;
  return is_coin_pay;
}
function process_rumor() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let items = A.selected.map(x => A.items[x]);
  let building = firstCond(items, x => x.path.includes('building'));
  let rumor = firstCond(items, x => !x.path.includes('building'));
  if (nundef(building) || nundef(rumor)) {
    select_error('you must select exactly one building and one rumor card!');
    return;
  }
  let fenbuilding = lookup(fen, building.path.split('.'));
  lookupAddToList(fenbuilding, ['rumors'], rumor.key);
  removeInPlace(fen.players[uplayer].rumors, rumor.key);
  ari_history_list([`${uplayer} added rumor to ${ari_get_building_type(fenbuilding)}`,], 'rumor');
  ari_next_action(fen, uplayer);
}
function process_rumor_discard() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  console.log('.........items', A.items, A.selected, item);
  let rumor = item.key;
  removeInPlace(fen.players[uplayer].rumors, rumor);
  ari_history_list([`building is correct! ${uplayer} had to discard rumor (${rumor})`], 'rumor');
  ari_next_action();
}
function process_rumors_setup() {
  let [fen, A, uplayer, plorder, data] = [Z.fen, Z.A, Z.uplayer, Z.plorder, Z.uplayer_data];
  let items = A.selected.map(x => A.items[x]);
  let receiver = firstCond(items, x => plorder.includes(x.key)).key;
  let rumor = firstCond(items, x => !plorder.includes(x.key));
  if (nundef(receiver) || nundef(rumor)) {
    select_error('you must select exactly one player and one rumor card!');
    return;
  }
  assertion(isdef(data), 'no data for player ' + uplayer);
  rumor_update_playerdata(data, receiver, rumor);
  let playerdata_complete = rumor_playerdata_complete();
  if (playerdata_complete) {
    Z.turn = [Z.host];
    Z.stage = 105; //'next_rumors_setup_stage';
    clear_transaction();
    take_turn_fen_write();
  } else if (isEmpty(data.state.remaining)) {
    clear_transaction();
    take_turn_write();
  } else {
    add_transaction('rumorsetup');
    take_turn_write();
  }
}
function process_upgrade() {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let n = A.selected.length;
  if (n > 2 || n == 2 && !has_farm(uplayer)) {
    select_error('too many cards selected!');
    return;
  } else if (n == 0) {
    select_error('please select hand or stall card(s) to upgrade!');
    return;
  }
  A.upgrade_cards = A.selected.map(x => A.items[x]);
  Z.stage = fen.stage = 102;
  ari_pre_action();
}
function process_visit() {
  alert('NOT IMPLEMENTED!');
  process_payment();
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let item = A.items[A.selected[0]];
  let obuilding = lookup(fen, item.path.split('.'));
  let parts = item.path.split('.');
  let owner = parts[1];
  if (isdef(obuilding.schweine)) {
    Z.stage = 46;
    A.building = item;
    A.obuilding = obuilding;
    A.buildingowner = owner;
    ari_pre_action();
    return;
  } else {
    let cards = item.o.items;
    let key = cards[0].rank;
    for (const c of cards) {
      if (c.rank != key) { schweine = true; schweine = c.key; face_up(c); break; }
    }
    if (schweine) {
      if (fen.players[owner].coins > 0) {
        fen.players[owner].coins--;
        fen.players[uplayer].coins++;
      }
      let b = lookup(fen, item.path.split('.'));
      b.schweine = schweine;
    }
    ari_history_list([
      `${uplayer} visited ${ari_get_building_type(obuilding)} of ${owner} resulting in ${schweine ? 'schweine' : 'ok'} ${ari_get_building_type(obuilding)}`,
    ], 'visit');
  }
}
function processActions(data) {
  if (nundef(G.serverData.options)) { G.tupleGroups = null; return false; }
  G.tupleGroups = getTupleGroups();
  return true;
}
function processCsvData(allText) {
  var numHeadings = 5;
  var allTextLines = allText.split(/\r\n|\n/);
  var headings = allTextLines[0].split(',');
  numHeadings = headings.length;
  let entries = allTextLines.splice(1);
  var records = { headings: headings };
  for (const e of entries) {
    let o = {};
    let values = e.split(',');
    for (let i = 0; i < numHeadings; i++) {
      let k = headings[i];
      o[k] = values[i];
    }
    o.order = Number(last(values));
    records[o.hexcode] = o;
  }
  return records;
}
function processCsvData_from_CBII(allText) {
  var numHeadings = 5;
  var allTextLines = allText.split(/\r\n|\n/);
  var headings = allTextLines[0].split(',');
  numHeadings = headings.length;
  let entries = allTextLines.splice(1);
  var records = { headings: headings };
  var recordsByName = {};
  for (const e of entries) {
    let o = {};
    let values = e.split(',');
    for (let i = 0; i < numHeadings; i++) {
      let k = headings[i];
      o[k] = values[i];
    }
    records[o.hexcode] = o;
    recordsByName[o.annotation] = o.hexcode;
  }
  return { records: records, recordsByName: recordsByName };
}
function processData(data) {
  if (G.end) {
    stopBlinking('a_d_status');
    stopInteraction();
    clearLog();
  }
  S.gameInProgress = true;
  G.serverData = data;
  G.phase = G.serverData.phase;
  processTable(data);
  processPlayers(data);
  if (!S_useSimpleCode) updateCollections();
  processLog(data);
  if (processEnd(data)) return;
  if (!processActions(data)) { processWaitingFor(); }
}
function processEnd(data) {
  G.end = data.end;
  if (G.end) {
    if (G.signals.receivedEndMessage) delete G.signals.receivedEndMessage;
    else socketEmitMessage({ type: 'end', data: G.player });
    setAutoplayFunctionForMode();
  }
  return G.end;
}
function processLocOids(cycle, max_cycles, isCyclic, R) {
  if (isEmpty(cycle)) return;
  let cycles = 0;
  let locOids = cycle;
  if (isCyclic) {
    let i = 0; let top = null;
    while (isEmpty(top)) {
      let oid = cycle[i];
      top = einhaengen(oid, R.getO(oid), R);
      if (!isEmpty(top)) break;
      i += 1; if (i > cycle.length - 1) break;
    }
    if (i > cycle.length - 1) {
      return;
    }
    locOids = arrRotate(cycle, i);
  }
  while (true) {
    cycles += 1;
    if (cycles > max_cycles) {
      return;
    }
    let changed = false;
    for (const oid of locOids) {
      let top = einhaengen(oid, R.getO(oid), R);
      if (!isEmpty(top)) {
        changed = true;
      }
    }
    if (!changed) { break; }
  }
}
function processLog(data) {
  if (!G.log) G.log = {};
  let pl = G.player;
  if (!G.log[pl]) G.log[pl] = {};
  let dict = G.log[pl];
  G.logUpdated = [];
  if (isdef(data.log)) {
    for (const logEntry of data.log) {
      let key = '' + logCounter + '_' + logEntry.line.map(x => isSimple(x) ? x : x.val).join(' ');
      logCounter += 1;
      if (dict[key]) continue;
      dict[key] = logEntry;
      G.logUpdated.push(key);
    }
  }
}
function processMessage(msg) {
  console.log('*** processMessage *** message is:\n', msg);
  let omsg = tryConvertToJSON(msg);
  if (omsg) {
    let msgType = omsg.type;
    console.log('got message', msgType, omsg);
    if (omsg.type == 'gc') {
      S.gameConfig = omsg.data;
      addMessage('updated game configuration!');
    } else if (omsg.type == 'started') {
      addMessage(omsg.data);
      if (iAmInGame() && !iAmStarter()) {
        console.log('I,', USERNAME, 'am in the game!!!!!')
        _startNewGame('joiner');
      }
    } else if (omsg.type == 'poll') {
      let pl = omsg.data;
      if (isMyPlayer(pl)) {
        let uname = getUsernameForPlayer(pl);
        sendStatus(uname, [gameStep]);
      }
    } else if (omsg.type == 'end') {
      console.log('received end!!!');
      G.signals.receivedEndMessage = true;
      let pl = omsg.data;
      if (!isMyPlayer(pl)) {
        let uname = getUsernameForPlayer(pl);
        sendStatus(uname, [gameStep]);
      }
    }
    return;
  }
  addMessage(msg);
  let parts = msg.split(' ');
  if (parts.length > 3 && startsWith(parts[1], 'join')) {
    let uname = parts[0];
    let plid = parts[3].trim();
    let players = S.gameConfig.players;
    let plChosen = firstCond(players, x => x.id == plid);
    if (plChosen) {
      if (isJoinMenuOpen()) closeJoinConfig();
      plChosen.username = uname;
      if (checkGameConfigComplete() && iAmStarter()) {
        _startNewGame('starter');
      }
    }
  }
}
function processPlayerChange() {
  if (isdef(G.serverData.end)) return;
  let players = G.serverData.players;
  let player = null;
  for (const plid in players) {
    let pl = players[plid];
    if (pl.obj_type == 'GamePlayer') {
      player = plid;
      break;
    }
  }
  if (!player) {
    error('NO GamePlayer obj_type in G.serverData.players!!!!!!!!!!!!!');
  }
  if (player != G.player) {
    G.player = player;
    G.playerChanged = true;
    setBackgroundToPlayerColor();
  } else {
    delete G.playerChanged;
  }
}
function processPlayers(data) {
  if (!S.players) _initPlayers();
  G.playersCreated = [];
  G.playersRemoved = [];
  G.playersUpdated = {};
  G.previousPlayer = G.player;
  let canProceed = false;
  delete G.playerChanged;
  if (data.players) {
    let plkeys = union(Object.keys(G.players), Object.keys(data.players));
    for (id of plkeys) {
      let pl_new = id in data.players ? data.players[id] : null;
      let pl_old = id in G.players ? G.players[id] : null;
      let changes = propDiffSimple(pl_old, pl_new);
      if (changes.hasChanged) {
        G.playersUpdated[id] = changes;
        if (nundef(pl_old)) {
          G.playersCreated.push(id);
        } else if (nundef(pl_new)) {
          G.playersRemoved.push(id);
        }
      }
      if (pl_new.obj_type == 'GamePlayer') {
        if (id != G.previousPlayer) G.playerChanged = true;
        if (nundef(G.player) || isMyPlayer(id) || G.player == id || isMyPlayer(G.previousPlayer) && isFrontAIPlayer(id)) {
          G.player = id;
          G.playerIndex = S.players[id].index;
          canProceed = true;
        } else {
        }
      }
    }
    G.players = data.players;
    G.playersAugmented = jsCopy(G.players);
    for (const pl in G.players) {
      G.playersAugmented[pl].color = S.players[pl].color;
      G.playersAugmented[pl].altName = S.players[pl].altName;
      G.playersAugmented[pl].id = pl;
      G.playersAugmented[pl].index = S.players[pl].index;
      G.playersAugmented[pl].username = S.players[pl].username;
      G.playersAugmented[pl].playerType = S.players[pl].playerType;
      G.playersAugmented[pl].agentType = S.players[pl].agentType;
    }
  }
  return canProceed;
}
function processServerdata(obj, cmd) {
  if (isdef(Serverdata.table)) Serverdata.prevtable = jsCopy(Serverdata.table);
  if (isdef(obj.playerdata)) {
    let old_playerdata = valf(Serverdata.playerdata, []);
    let di = list2dict(old_playerdata, 'name');
    Serverdata.playerdata = if_stringified(obj.playerdata);
    Serverdata.playerdata_changed_for = [];
    for (const o of Serverdata.playerdata) {
      let old = di[o.name];
      o.state = isEmpty(o.state) ? '' : if_stringified(o.state);
      let changed = nundef(old) ? true : !simpleCompare(old, o);
      if (changed) {
        Serverdata.playerdata_changed_for.push(o.name);
      }
    }
  } else if (isdef(Serverdata.playerdata)) {
    Serverdata.playerdata_changed_for = Serverdata.playerdata.map(x => x.name);
    Serverdata.playerdata = [];
  } else Serverdata.playerdata_changed_for = [];
  for (const k in obj) {
    if (k == 'tables') Serverdata.tables = obj.tables.map(x => unpack_table(x));
    else if (k == 'table') { Serverdata.table = unpack_table(obj.table); }
    else if (k == 'users') Serverdata[k] = obj[k];
    else if (k == 'playerdata') continue;
    else if (cmd != 'assets') Serverdata[k] = obj[k];
  }
  if (isdef(obj.table)) {
    assertion(isdef(Serverdata.table) && obj.table.id == Serverdata.table.id, 'table NOT in Serverdata or table id mismatch');
    let i = Serverdata.tables.findIndex(x => x.id == obj.table.id);
    if (i != -1) { Serverdata.tables[i] = Serverdata.table; } else Serverdata.tables.push(Serverdata.table);
  }
  else if (isdef(Serverdata.table)) {
    let t = Serverdata.tables.find(x => x.id == Serverdata.table.id);
    if (nundef(t)) delete Serverdata.table;
  }
}
function processStatus() {
  if (isdef(G.serverData.status)) {
    let msg = G.serverData.status;
    if (Array.isArray(msg)) {
      msg = msg[0];
    }
    if (typeof msg == 'object') msg = msg.line;
    if (Array.isArray(msg)) msg = msg.join('');
    msg = G.players[G.player].name + ', ' + msg;
    setStatus(msg);
  }
}
function processTable(data) {
  if (!G.table) G.table = {};
  G.tableCreated = [];
  G.tableRemoved = [];
  G.tableUpdated = {};
  if (data.table) {
    let allkeys = union(Object.keys(G.table), Object.keys(data.table));
    for (id of allkeys) {
      let o_new = id in data.table ? data.table[id] : null;
      let o_old = id in G.table ? G.table[id] : null;
      let changes = propDiffSimple(o_old, o_new);
      if (changes.hasChanged) {
        G.tableUpdated[id] = changes;
        if (nundef(o_old)) {
          G.tableCreated.push(id);
        } else if (nundef(o_new)) {
          G.tableRemoved.push(id);
        }
      }
    }
    G.table = data.table;
  }
}
function processWaitingFor() {
  if (nundef(G.serverData.waiting_for)) {
    error('No options AND No waiting_for data!!!!!!!!!!');
    return;
  }
}
function PROMOTED(m) { return (((m) >> 20) & 0xF); }
function prompt() {
  QuestionCounter += 1;
  showStats();
  G.trialNumber = 0;
  G.instance.prompt();
}
function promptML() {
  showPictures(false, () => fleetingMessage('just enter the missing letter!'));
  setGoal();
  showInstruction(bestWord, currentLanguage == 'E' ? 'complete' : "ergänze", dTitle, true);
  mLinebreak(dTable);
  let style = { margin: 6, fg: 'white', display: 'inline', bg: 'transparent', align: 'center', border: 'transparent', outline: 'none', family: 'Consolas', fz: 80 };
  let d = createLetterInputs(bestWord.toUpperCase(), dTable, style);
  let indices = getIndicesCondi(bestWord, (x, i) => isAlphaNum(x) && i <= MaxPosMissing);
  nMissing = Math.min(indices.length, NumMissingLetters);
  let ilist = choose(indices, nMissing); sortNumbers(ilist);
  for (const idx of ilist) {
    let inp = d.children[idx];
    inp.innerHTML = '_';
    mClass(inp, 'blink');
    inputs.push({ letter: bestWord[idx].toUpperCase(), div: inp, index: idx });
  }
  mLinebreak(dTable);
  showFleetingMessage(composeFleetingMessage(), 3000);
  return 10;
}
function promptNextTrial() {
  QuestionCounter += 1;
  clearTimeout(TOTrial);
  uiActivated = false;
  let delay = G.instance.trialPrompt(G.trialNumber);
  TOMain = setTimeout(activateUi, delay);
}
function promptSP() {
  showPictures(true, () => mBy(defaultFocusElement).focus());
  setGoal();
  showInstruction(bestWord, currentLanguage == 'E' ? 'say:' : "sage: ", dTitle);
  mLinebreak(dTable);
  MicrophoneUi = mMicrophone(dTable);
  return 10;
}
function promptSPA() {
  showPictures(true, () => mBy(defaultFocusElement).focus(), undefined, [currentKeys[NextPictureIndex]]);
  NextPictureIndex += 1;
  setGoal();
  showInstruction(bestWord, currentLanguage == 'E' ? 'say:' : "sage: ", dTitle);
  mLinebreak(dTable);
  MicrophoneUi = mMicrophone(dTable);
  return 10;
}
function promptStart() {
  beforeActivationUI();
  isINTERRUPT = false;
  dTable = dLineTableMiddle;
  dTitle = dLineTitleMiddle;
  if (nundef(dTable)) return;
  clearTable();
  let delay = GFUNC[currentGame].prompt();
  setTimeout(activateUi, delay);
}
function promptTC() {
  let colors = choose(SIMPLE_COLORS, NumColors);
  showPictures(false, evaluate, colors);
  setGoal(randomNumber(0, NumPics * colors.length - 1));
  Goal.correctionPhrase = Goal.shade + ' ' + Goal.label;
  let spoken = `click the ${Goal.shade} ${bestWord}`;
  showInstruction(bestWord, `click the <span style='color:${Goal.shade}'>${Goal.shade.toUpperCase()}</span>`,
    dTitle, true, spoken);
  return 10;
}
function promptTP() {
  showPictures(false, evaluate);
  setGoal();
  showInstruction(bestWord, 'click', dTitle, true);
  return 10;
}
function promptWP() {
  showPictures(true, () => mBy(defaultFocusElement).focus());
  setGoal();
  showInstruction(bestWord, currentLanguage == 'E' ? 'type' : "schreib'", dTitle, true);
  mLinebreak(dTable);
  inputBox = addNthInputElement(dTable, trialNumber);
  defaultFocusElement = inputBox.id;
  return 10;
}
function propDiff(o_old, o_new) {
  let onlyOld = [];
  let onlyNew = [];
  let propChange = [];
  let summary = [];
  let hasChanged = false;
  for (const prop in o_new) {
    if (o_new.hasOwnProperty(prop)) {
      if (!(prop in o_old)) {
        addIf_dep(prop, onlyNew);
        addIf_dep(prop, summary);
        hasChanged = true;
      } else if (o_new[prop] != o_old[prop]) {
        if (prop == 'visible') {
          let visOld = getVisibleSet(o_old);
          let visNew = getVisibleSet(o_new);
          if (sameList(visOld, visNew)) {
            continue;
          }
        } else if (typeof o_new[prop] == 'object') {
          if (hasSameProps(o_new[prop], o_old[prop])) {
            continue;
          }
        }
        addIf_dep({ prop: prop, old: o_old[prop], new: o_new[prop] }, propChange);
        addIf_dep(prop, summary);
        hasChanged = true;
      }
    }
  }
  for (const prop in o_old) {
    if (o_old.hasOwnProperty(prop)) {
      if (!(prop in o_new)) {
        addIf_dep(prop, onlyOld);
        addIf_dep(prop, summary);
        hasChanged = true;
      }
    }
  }
  return { onlyOld: onlyOld, onlyNew: onlyNew, propChange: propChange, summary: summary, hasChanged: hasChanged };
}
function propDiffFast_dep(o_old, o_new, deepCheck = false, optInOut = {}) {
  let onlyOld = [];
  let onlyNew = [];
  let propChange = [];
  let summary = [];
  let hasChanged = false;
  for (const prop in o_new) {
    if (fundef(optInOut[prop])) continue;
    let nprop = o_new[prop];
    let oprop = o_old[prop];
    if (isdef(nprop)) {
      let nval = o_new[prop];
      if (nundef(oprop)) {
        addIf(onlyNew, prop);
        addIf(summary, prop);
        hasChanged = true;
      } else if (nval != o_old[prop]) {
        if (!isSimple(nval)) {
          if (!deepCheck) continue;
          if (JSON.stringify(nval) == JSON.stringify(o_old[prop])) {
            console.log(JSON.stringify(nval), JSON.stringify(o_old[prop]));
            continue;
          }
        }
        addIf(propChange, { prop: prop, old: o_old[prop], new: o_new[prop] });
        addIf(summary, prop);
        hasChanged = true;
      }
    }
  }
  for (const prop in o_old) {
    if (fundef(optInOut[prop])) continue;
    if (nundef(o_new[prop])) {
      addIf(onlyOld, prop);
      addIf(summary, prop);
      hasChanged = true;
    }
  }
  return { onlyOld: onlyOld, onlyNew: onlyNew, propChange: propChange, summary: summary, hasChanged: hasChanged };
}
function propDiffGSM_dep(o_old, o_new, deepCheck = false, optInOut = {}) {
  let onlyOld = [];
  let onlyNew = [];
  let propChange = [];
  let summary = [];
  let hasChanged = false;
  for (const prop in o_new) {
    if (fundef(optInOut[prop])) continue;
    let nprop = o_new[prop];
    let oprop = o_old[prop];
    if (isdef(nprop)) {
      let nval = o_new[prop];
      if (nundef(oprop)) {
        addIf(onlyNew, prop);
        addIf(summary, prop);
        hasChanged = true;
      } else if (nval != o_old[prop]) {
        if (!deepCheck && !isSimple(nval)) continue;
        if (prop == 'visible') {
          console.log('visibility', nval);
          let visOld = getVisibleList(o_old);
          let visNew = getVisibleList(o_new);
          if (sameList(visOld, visNew)) continue;
        } else if (typeof nval == 'object' && sameProps(nval, o_old[prop])) {
          continue;
        } else if (isList(nval) && sameList(nval, o_old[prop])) {
          continue;
        }
        addIf(propChange, { prop: prop, old: o_old[prop], new: o_new[prop] });
        addIf(summary, prop);
        hasChanged = true;
      }
    }
  }
  for (const prop in o_old) {
    if (fundef(optInOut[prop])) continue;
    if (nundef(o_new[prop])) {
      addIf(onlyOld, prop);
      addIf(summary, prop);
      hasChanged = true;
    }
  }
  return { onlyOld: onlyOld, onlyNew: onlyNew, propChange: propChange, summary: summary, hasChanged: hasChanged };
}
function propDiffPlus_dep(o_old, o_new, deepCheck = false, optInOut = {}) {
  let onlyOld = [];
  let onlyNew = [];
  let propChange = [];
  let summary = [];
  let hasChanged = false;
  for (const prop in o_new) {
    if (fundef(optInOut[prop])) continue;
    let nprop = o_new[prop];
    let oprop = o_old[prop];
    if (isdef(nprop)) {
      let nval = o_new[prop];
      if (nundef(oprop)) {
        addIf(onlyNew, prop);
        addIf(summary, prop);
        hasChanged = true;
      } else if (nval != o_old[prop]) {
        if (!deepCheck && !isSimple(nval)) continue;
        if (typeof nval == 'object' && hasSameProps(nval, o_old[prop])) {
          continue;
        } else if (isList(nval) && sameList(nval, o_old[prop])) {
          continue;
        }
        addIf(propChange, { prop: prop, old: o_old[prop], new: o_new[prop] });
        addIf(summary, prop);
        hasChanged = true;
      }
    }
  }
  for (const prop in o_old) {
    if (fundef(optInOut[prop])) continue;
    if (nundef(o_new[prop])) {
      addIf(onlyOld, prop);
      addIf(summary, prop);
      hasChanged = true;
    }
  }
  return { onlyOld: onlyOld, onlyNew: onlyNew, propChange: propChange, summary: summary, hasChanged: hasChanged };
}
function propDiffSimple(o_old, o_new, props = null) {
  let onlyOld = [];
  let onlyNew = [];
  let propChange = [];
  let summary = [];
  let hasChanged = false;
  if (!o_old) {
    return { onlyOld: [], onlyNew: Object.keys(o_new), propChange: [], summary: Object.keys(o_new), hasChanged: true };
  } else if (!o_new) {
    return { onlyOld: Object.keys(o_old), onlyNew: [], propChange: [], summary: Object.keys(o_old), hasChanged: true };
  }
  if (nundef(props)) props = union(Object.keys(o_old), Object.keys(o_new));
  for (const prop of props) {
    let nval = o_new[prop];
    let oval = o_old[prop];
    if (isdef(nval) && isdef(oval)) {
      if (nval == oval) continue;
      else if (typeof nval == 'object' && sameStringify(nval, oval)) {
        continue;
      } else if (isList(nval) && sameList(nval, oval)) {
        continue;
      }
      addIf(propChange, { prop: prop, old: oval, new: nval });
      addIf(summary, prop);
      hasChanged = true;
    } else if (nundef(oval)) {
      addIf(onlyNew, prop);
      addIf(summary, prop);
      hasChanged = true;
    } else if (nundef(nval)) {
      addIf(onlyOld, prop);
      addIf(summary, prop);
      hasChanged = true;
    }
  }
  return { onlyOld: onlyOld, onlyNew: onlyNew, propChange: propChange, summary: summary, hasChanged: hasChanged };
}
function propertyGiver(o, prop, setter, getter) {
  Object.defineProperty(o, prop, {
    get: function () { return getter(); },
    set: function (val) { setter(val); }
  });
}
function propertyGiverW0(o, prop, setter) {
  Object.defineProperty(o, prop, {
    get: function () { return this.val; },
    set: function (val) { setter(val); }
  });
}
function PrSq(sq) {
  var file = FilesBrd[sq];
  var rank = RanksBrd[sq];
  var sqStr = String.fromCharCode('a'.charCodeAt() + file) + String.fromCharCode('1'.charCodeAt() + rank);
  return sqStr;
}
function pSBC(p, c0, c1, l) {
  let r,
    g,
    b,
    P,
    f,
    t,
    h,
    i = parseInt,
    m = Math.round,
    a = typeof c1 == 'string';
  if (typeof p != 'number' || p < -1 || p > 1 || typeof c0 != 'string' || (c0[0] != 'r' && c0[0] != '#') || (c1 && !a)) return null;
  if (!this.pSBCr)
    this.pSBCr = d => {
      let n = d.length,
        x = {};
      if (n > 9) {
        ([r, g, b, a] = d = d.split(',')), (n = d.length);
        if (n < 3 || n > 4) return null;
        (x.r = i(r[3] == 'a' ? r.slice(5) : r.slice(4))), (x.g = i(g)), (x.b = i(b)), (x.a = a ? parseFloat(a) : -1);
      } else {
        if (n == 8 || n == 6 || n < 4) return null;
        if (n < 6) d = '#' + d[1] + d[1] + d[2] + d[2] + d[3] + d[3] + (n > 4 ? d[4] + d[4] : '');
        d = i(d.slice(1), 16);
        if (n == 9 || n == 5) (x.r = (d >> 24) & 255), (x.g = (d >> 16) & 255), (x.b = (d >> 8) & 255), (x.a = m((d & 255) / 0.255) / 1000);
        else (x.r = d >> 16), (x.g = (d >> 8) & 255), (x.b = d & 255), (x.a = -1);
      }
      return x;
    };
  (h = c0.length > 9),
    (h = a ? (c1.length > 9 ? true : c1 == 'c' ? !h : false) : h),
    (f = pSBCr(c0)),
    (P = p < 0),
    (t = c1 && c1 != 'c' ? pSBCr(c1) : P ? { r: 0, g: 0, b: 0, a: -1 } : { r: 255, g: 255, b: 255, a: -1 }),
    (p = P ? p * -1 : p),
    (P = 1 - p);
  if (!f || !t) return null;
  if (l) (r = m(P * f.r + p * t.r)), (g = m(P * f.g + p * t.g)), (b = m(P * f.b + p * t.b));
  else (r = m((P * f.r ** 2 + p * t.r ** 2) ** 0.5)), (g = m((P * f.g ** 2 + p * t.g ** 2) ** 0.5)), (b = m((P * f.b ** 2 + p * t.b ** 2) ** 0.5));
  (a = f.a), (t = t.a), (f = a >= 0 || t >= 0), (a = f ? (a < 0 ? t : t < 0 ? a : a * P + t * p) : 0);
  if (h) return 'rgb' + (f ? 'a(' : '(') + r + ',' + g + ',' + b + (f ? ',' + m(a * 1000) / 1000 : '') + ')';
  else return '#' + (4294967296 + r * 16777216 + g * 65536 + b * 256 + (f ? m(a * 255) : 0)).toString(16).slice(1, f ? undefined : -2);
}
function pTest0() {
  let state = DB.tables.t0;
  console.log('state', state);
  let dMiddle = makePage();
  mStyle(dMiddle, { padding: 20, overflow: 'auto' });
  mCenterCenterFlex(dMiddle)
  let dTable = mDiv100(dMiddle, { wmax: 800, box: true, rounding: 12 });
  dTable.style.overflow = 'auto';
  console.log('dTable', dTable)
  present0(dTable, state);
  return;
  mCenterCenterFlex(dTable);
  let d1 = mDiv(dTable);
  let d2 = present_structured1(d1, state);
}
function pureId(id) { return id.substring(4) }
function purge(elem) {
  var a = elem.attributes, i, l, n;
  if (a) {
    for (i = a.length - 1; i >= 0; i -= 1) {
      n = a[i].name;
      if (typeof elem[n] === 'function') {
        elem[n] = null;
      }
    }
  }
  a = elem.childNodes;
  if (a) {
    l = a.length;
    for (i = a.length - 1; i >= 0; i -= 1) {
      purge(elem.childNodes[i]);
    }
  }
  elem.remove();
}
function push_hist() { let o = { i: G.i, items: G.selist.map(x => iStrip(x)) }; G.hist.push(o); }
function pVal(dParent, val) { let d = pPanel(dParent); d.innerHTML = val; return d; }
function pxToNumber(s) {
  return (Number(s.substring(0, s.length - 2)));
}
function q_mirror_fen() {
  let fen = Z.fen;
  for (const prop of arguments) {
    let ui = UI[prop];
    fen[prop] = ui.list;
  }
  qanim();
}
function q_move_topmost(uideck, uito) {
  let topmost = pop_top(uideck);
  let dfrom = iDiv(topmost);
  dfrom.remove();
  dfrom.style.position = 'static';
  dfrom.style.zIndex = 0;
  uito.items.push(topmost);
  uito.list = uito.items.map(x => x.key);
  mAppend(uito.cardcontainer, dfrom);
  qanim();
}
function q0() {
  let list = dict2list(EMO.emoscale, 'k').map(x => ({ name: x.k, key: x.key, color: x.color, text: x.list }));
  show_prompt('how are you feeling right now?', list, a0);
}
function q1() {
  let list = [];
  for (const item of G.selist) {
    let alpha = .4;
    for (const w of item.text.split(',')) {
      let o = { name: w.trim(), key: item.key, color: colorTrans(item.color, alpha), text: w.trim() };
      alpha += .2;
      list.push(o);
    }
  }
  show_prompt('select the 2 dominant feelings', list, a1);
}
function q2() {
  console.log('G', G)
  const transitions = {
    worried: {
      money: {},
      time: {},
      past: {},
      future: {},
      material: {},
    },
  };
  let step1 = ''
}
function qanim() {
  if (!isEmpty(DA.qanim)) {
    let [f, params] = DA.qanim.shift();
    f(...params);
  }
}
function qanim_flip(card, ms = 400) {
  mAnimate(iDiv(card), 'transform', [`scale(1,1)`, `scale(0,1)`],
    () => {
      if (card.faceUp) face_down(card); else face_up(card);
      mAnimate(iDiv(card), 'transform', [`scale(0,1)`, `scale(1,1)`], qanim, ms / 2, 'ease-in', 0, 'both');
    },
    ms / 2, 'ease-out', 0, 'both');
}
function qanim_flip_topmost(deck, ms = 400) {
  qanim_flip(deck.get_topcard(), ms);
}
function qanim_move(card, uifrom, uito, ms = 400) {
  let dfrom = iDiv(card);
  let dto = isEmpty(uito.items) ? uito.cardcontainer : iDiv(arrLast(uito.items));
  let dParent = find_common_ancestor(dfrom, dto);
  let rfrom = getRect(dfrom, dParent);
  let rto = getRect(dto, dParent);
  dfrom.style.zIndex = 100;
  let [offx, offy] = isEmpty(uito.items) ? [4, 4] : [card.w, 0];
  let a = mAnimate(dfrom, 'transform',
    [`translate(${offx + rto.l - rfrom.l}px, ${offy + rto.t - rfrom.t}px)`], qanim,
    ms, 'ease');
}
function qanim_move_topmost(uideck, uito, ms = 400) {
  let card = uideck.get_topcard();
  qanim_move(card, uideck, uito, ms);
}
function qOptions(bg = BLUEGREEN) {
  let options = {
    bCaption: '☰',
    bStyles: { fz: 30, margin: 4 },
    menuStyles: { bg: wblack, alpha: .65 },
    sbStyles: { bg: wblack, alpha: .25 },
    divStyles: { bg: wwhite, alpha: .25 },
    innerStyles: {},
    outerStyles: { bg: bg },
  };
  return options;
}
function qPageMST(dParent, options) {
  mStyle(dParent, { h: '100%', w: '100%', box: true, bg: 'silver' });
  setRect(dParent);
  let item = iMenuSidebarDiv(dParent, options);
  return { item: item, sidebar: iGetl(item, 'sidebar'), dContent: iGetl(item, 'dContent'), dMenu: iGetl(item, 'dMenu') };
}
function QReset() {
  console.log('...', getFunctionCallerName());
  clearTimeout(TOQ);
  clearTimeout(TOQRunner);
  Q = [];
  AkQ = [];
}
function QRunner() {
  if (QCancelAutoreset) { QRunnerRunning = false; QCancelAutoreset = false; restartQ(); }
  else if (isEmpty(Q)) TOQRunner = setTimeout(QRunner, 1000);
  else _runQ(QRunner);
}
function QStop() {
  console.log('...', getFunctionCallerName());
  QCancelAutoreset = true;
}
function qTable(dParent, options) {
  mStyleX(dParent, { h: '100%', w: '100%', box: true, bg: 'silver' });
  setRect(dParent);
  let item = iMenuSidebarDiv(dParent, options);
  return { item: item, sidebar: iGetl(item, 'sidebar'), dContent: iGetl(item, 'dContent'), dMenu: iGetl(item, 'dMenu') };
}
function quadCenters(rows, cols, wCell, hCell) {
  let offX = wCell / 2, offY = hCell / 2;
  let centers = [];
  let x = 0; y = 0;
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      let center = { x: x + offX, y: y + offY };
      centers.push(center);
      x += wCell;
    }
    y += hCell; x = 0;
  }
  return [centers, wCell * cols, hCell * rows];
}
function quadGrid(soDict, loc, condList) {
  let [idBoard, sBoard] = findMatch(soDict, condList);
  return _quadGrid(loc, idBoard, sBoard, soDict);
}
function quadGrid_old(soDict, loc, sBoard, idBoard) {
  return _quadGrid(loc, idBoard, sBoard, soDict);
}
function queryINSERT(data) {
  let newData = {};
  for (const k in data) {
    let val = data[k];
    if (!isNumber(val)) newData[k] = "'" + val + "'"; else newData[k] = val;
  }
  let q = 'INSERT INTO users (' + Object.keys(newData).join() + ') VALUES (' + Object.values(newData).join(',') + ')';
  return q;
}
function querySelectUser(data) {
  let newData = {};
  for (const k in data) {
    let val = data[k];
    if (!isNumber(val)) newData[k] = "'" + val + "'"; else newData[k] = val;
  }
  let q = 'SELECT * FROM users WHERE username = ' + newData.username;
  return q;
}
function queryStringToJson() {
  let q = window.location.search;
  if (isEmpty(q)) return {};
  q = q.substring(1);
  let result = {};
  let parts = q.split('&');
  for (const p of parts) {
    let key = stringBefore(p, '=');
    let val = stringAfter(p, '=');
    result[key] = val;
  }
  return result;
}
function question2(ev) {
  let id = evToId(ev);
  let item = Items[id];
  console.log('item', item);
  say(`why do you feel ${item.list}???`, 'uk', show_reasons, .5, .8);
}
function Quiescence(alpha, beta) {
  if ((srch_nodes & 2047) == 0) CheckUp();
  srch_nodes++;
  if (IsRepetition() || brd_fiftyMove >= 100) {
    return 0;
  }
  if (brd_ply > MAXDEPTH - 1) {
    return EvalPosition();
  }
  var Score = EvalPosition();
  if (Score >= beta) {
    return beta;
  }
  if (Score > alpha) {
    alpha = Score;
  }
  GenerateCaptures();
  var MoveNum = 0;
  var Legal = 0;
  var OldAlpha = alpha;
  var BestMove = NOMOVE;
  Score = -INFINITE;
  var PvMove = ProbePvTable();
  if (PvMove != NOMOVE) {
    for (MoveNum = brd_moveListStart[brd_ply]; MoveNum < brd_moveListStart[brd_ply + 1]; ++MoveNum) {
      if (brd_moveList[MoveNum] == PvMove) {
        brd_moveScores[MoveNum].score = 2000000;
        break;
      }
    }
  }
  for (MoveNum = brd_moveListStart[brd_ply]; MoveNum < brd_moveListStart[brd_ply + 1]; ++MoveNum) {
    PickNextMove(MoveNum);
    if (MakeMove(brd_moveList[MoveNum]) == BOOL.FALSE) {
      continue;
    }
    Legal++;
    Score = -Quiescence(-beta, -alpha);
    TakeMove();
    if (srch_stop == BOOL.TRUE) return 0;
    if (Score > alpha) {
      if (Score >= beta) {
        if (Legal == 1) {
          srch_fhf++;
        }
        srch_fh++;
        return beta;
      }
      alpha = Score;
      BestMove = brd_moveList[MoveNum];
    }
  }
  if (alpha != OldAlpha) {
    StorePvMove(BestMove);
  }
  return alpha;
}
function race_check_endcondition() {
  let players = get_values(Session.cur_players);
  let winners = players.filter(x => x.score >= Session.winning_score).map(x => x.name);
  return winners;
}
function race_open_prompt(fen) {
  console.assert(!uiActivated, 'open_prompt_ with uiActivated ON !!!!!!!!!!!!!!!!!!!!!!!!!!');
  let g = update_game_values();
  clearTable(); set_background_color(g.color);
  QContextCounter += 1;
  show_game_name(g.friendly);
  show_title(g.table.friendly);
  show_level(g.level, g.maxlevel);
  if (Session.is_badges) g.level = setBadgeLevel(g.level, Session.cur_user, Session.cur_game, g.maxlevel);
  g.startTime = get_timestamp();
  mLinebreak(dTable, 15);
  Session.cur_funcs.prompt(g, fen);
  Selected = null;
  if (nundef(fen)) uiActivated = true;
}
function race_present_table(obj) {
  console.assert(isdef(obj.table), 'present_table without obj.table!!!!!!!!!!!!!!');
  if (obj.table.status != 'past') { update_table_options_for_user(Session.cur_user, obj.table.pl_options, obj.table.game); }
  update_session(obj);
  let table_status = Session.cur_table.status;
  if (is_admin() && table_status == 'past') { in_game_off(); in_game_open_prompt_off(); status_message_off(); get_games(); return; }
  if (!in_game()) { open_game_ui(); in_game_on(); }
  let d = mBy('table'); d.animate([{ opacity: 0, transform: 'translateY(50px)' }, { opacity: 1, transform: 'translateY(0px)' },], { fill: 'both', duration: 1000, easing: 'ease' });
  let my_status = Session.cur_me.player_status;
  let have_move = my_status == 'joined';
  if (!have_move) { if (!in_game_open_prompt()) race_open_prompt(Session.cur_me.state); }
  else if (!in_game_open_prompt()) { race_open_prompt(); in_game_open_prompt_on(); }
  else { uiActivated = true; }
  ui_game_stats(Session.cur_players);
  if (table_status != 'started') {
    stop_game();
    let winners = Session.winners = race_check_endcondition();
    if (!isEmpty(winners)) {
      stop_game();
      show_gameover_new(winners);
    }
  } else Session.scoring_complete = false;
}
function race_set_fen() {
  let me = Session.cur_players[Session.cur_user];
  let fen = Session.cur_funcs.fen();
  me.state = fen;
}
function race_update_my_score(inc) {
  let me = Session.cur_me;
  me.score += inc;
  if (me.score >= Session.winning_score) me.player_status = 'done';
}
function rAdd(dmin = -1, dmax = 1) { return x => x + dmin + Math.random() * (dmax - dmin); }
function rAddSub(d) { return x => x + (coin() ? d : -d); }
function rAddSubRange(d) { return x => x + (Math.random() * 2 * d - d); }
function rAlphanums(n) { return rChoose(toLetters('0123456789abcdefghijklmnopq'), n); }
function RAND_32() { return (Math.floor((Math.random() * 255) + 1) << 23) | (Math.floor((Math.random() * 255) + 1) << 16) | (Math.floor((Math.random() * 255) + 1) << 8) | Math.floor((Math.random() * 255) + 1); }
function random_motto() { return chooseRandom(["time to play!", "life's good", "one game at a time!", "let's play!", "no place like home", "cafe landmann"]) }
function randomAlphanum() {
  let s = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  return s[randomNumber(0, s.length - 1)];
}
function randomBotName() { return (coin() ? randomVowel() : '') + randomConsonant() + randomVowel() + 'bot'; }
function randomC52() { return Card52.getShortString(randomCard52()); }
function randomCard52() { return Card52.random(); }
function randomColor() { return rColor(); }
function randomColorDark(contrastTo) { return randomColorX(contrastTo, 10, 30); }
function randomColorLight(contrastTo) { return randomColorX(contrastTo); }
function randomColorX(contrastColor, minContrast = 25, mod = 60, startWheel = 0, minLum = 70, maxLum = 90, minSat = 100, maxSat = 100) {
  let hue = getContrastingHueX(contrastColor, minContrast, mod, startWheel);
  let sat = minSat + (maxSat - minSat) * Math.random();
  let lum = minLum + (maxLum - minLum) * Math.random();
  let result = "hsl(" + hue + ',' + sat + '%,' + lum + '%)';
  return result;
}
function randomConsonant() { let s = 'bcdfghjklmnpqrstvwxz'; return s[randomNumber(0, s.length - 1)]; }
function randomContent(type) {
  if (nundef(type)) { type = randomType(); }
  let content = window['random' + capitalize(type)]();
  if (isDict(content)) { content.type = type; } else content = { content: content, type: type };
  return content;
}
function randomDarkColor() {
  let s = '#';
  for (let i = 0; i < 3; i++) {
    s += chooseRandom([0, 1, 2, 3, 4, 5, 6, 7]) + chooseRandom(['f', 'c', '9', '6', '3', '0']);
  }
  return s;
}
function randomDigit() { let s = '0123456789'; return s[randomNumber(0, s.length - 1)]; }
function randomHexColor() {
  let s = '#';
  for (let i = 0; i < 6; i++) {
    s += chooseRandom(['f', 'c', '9', '6', '3', '0']);
  }
  return s;
}
function randomHslaColor(s = 100, l = 70, a = 1) {
  var hue = Math.round(Math.random() * 360);
  return hslToHslaString(hue, s, l, a);
}
function randomizeNum(n, percentUp = 25, percentDown = 25) {
  let max = n * percentUp / 100;
  let min = n * percentDown / 100;
  return randomNumber(n - min, n + max);
}
function randomLetter() { let s = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; return s[randomNumber(0, s.length - 1)]; }
function randomLightColor() {
  let s = '#';
  for (let i = 0; i < 3; i++) {
    s += chooseRandom(['A', 'B', 'C', 'D', 'E', 'F']) + chooseRandom(['f', 'c', '9', '6', '3', '0']);
  }
  return s;
}
function randomList(len = 3, onlySimple = true, elType) {
  if (nundef(elType)) { elType = randomType(onlySimple); }
  let result = [];
  for (let i = 0; i < len; i++) {
    let c = randomContent(elType);
    result.push(isdef(c.content) ? c.content : c);
  }
  return { content: result, elType: elType };
}
function randomName() { return chooseRandom(coin() ? GirlNames : BoyNames); }
function randomNumber(min = 0, max = 100) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function randomObject(len = 3, onlySimple = true, elTypes) {
  if (nundef(elTypes)) { elTypes = Array.from({ length: len, }, () => randomType(true)); }
  let result = { id: getUID('o') };
  let i = 0;
  for (const t of elTypes) {
    let key = t + '_' + i; i += 1;
    let val = randomContent(t);
    result[key] = isdef(val.content) ? val.content : val;
  }
  return result;
}
function randomRank() { return Card52.randomRankSuit[0]; }
function randomString(len = 4, startLetter) {
  let s = '';
  if (isdef(startLetter)) { s = startLetter; len -= 1; }
  let isVowel = coin() ? true : false;
  for (let i = 0; i < len; i++) {
    if (isVowel) s += randomVowel(); else s += randomConsonant();
    isVowel = !isVowel;
  }
  return s;
}
function randomSuit() { return Card52.randomRankSuit[1]; }
function randomType(onlySimple = false) {
  let complexTypes = ['list'];
  let simpleTypes = ['number', 'string', 'varLenString', 'C52', 'Card52'];//'card'?,'html','DOM'];
  let allTypes = complexTypes.concat(simpleTypes);
  type = chooseRandom(onlySimple ? simpleTypes : allTypes);
  return type;
}
function randomUnitTuple() {
  let tile = chooseRandom(assets.tileNames);
  let nationality = chooseRandom(assets.nationalityNames);
  let unitType = chooseRandom(assets.unitTypeNames);
  return [nationality, tile, unitType, 2];
}
function randomUserId(len = 20, isNumeric = false) {
  let id = '';
  if (isNumeric) for (let i = 0; i < len; i++) { id += randomDigit(); }
  else for (let i = 0; i < len; i++) { id += randomAlphanum(); }
  return id;
}
function randomVarLenString(lmin = 3, lmax = 12, startLetter) { let len = randomNumber(lmin, lmax); return randomString(len, startLetter); }
function randomVowel() { let s = 'aeiouy'; return s[randomNumber(0, s.length - 1)]; }
function range(f, t, st = 1) {
  if (nundef(t)) {
    t = f - 1;
    f = 0;
  }
  let arr = [];
  for (let i = f; i <= t; i += st) {
    arr.push(i);
  }
  return arr;
}
function rAreas() {
  let d1 = mDiv(dTable, { bg: 'blue', w: 800, h: 600 }, 'd1');
  SPEC = { views: { d1: { layout: ['T', 'P O'] } } };
  console.log(SPEC)
  for (const k in SPEC.views) { createLayout(k, SPEC.views[k].layout); }
}
function rAreas_0() {
  let color = SPEC.color.theme;
  document.body.style.backgroundColor = color;
  let fg = colorIdealText(color)
  document.body.style.color = fg;
  let palette = getTransPalette9();
  let ipal = 1;
  let d = document.getElementById('areaTable');
  setTableSize(...SPEC.tableSize);
  let s = '';
  let m = [];
  for (const line of SPEC.layout) {
    s += '"' + line + '" ';
    let letters = line.split(' ');
    let arr = [];
    for (const l of letters) { if (!isEmpty(l)) arr.push(l); }
    m.push(arr);
  }
  d.style.gridTemplateAreas = s;
  if (SPEC.collapseEmptySmallLetterAreas) { collapseSmallLetterAreas(m, d); }
  else fixedSizeGrid(m, d);
  for (const k in SPEC.areas) {
    let areaName = SPEC.areas[k];
    let d1 = document.createElement('div');
    d1.id = areaName;
    d1.style.gridArea = k;
    if (SPEC.shadeAreaBackgrounds) { d1.style.backgroundColor = palette[ipal]; ipal = (ipal + 1) % palette.length; }
    if (SPEC.showAreaNames) { d1.innerHTML = makeAreaNameDomel(areaName); }
    UIS[areaName] = { elem: d1, children: [] };
    d.appendChild(d1);
  }
}
function rBehaviorCode() {
  for (const key of ['table', 'players']) {
    let pool = serverData[key];
    for (const oid in pool) {
      let o = pool[oid];
      for (const cond in COND) {
        console.log('try', cond)
        let todo = COND[cond](o);
        if (isdef(todo)) {
          FUNCS[todo.f](oid, o);
          DONE[oid] = true;
        }
      }
    }
  }
}
function rCard(postfix = 'n', ranks = '*A23456789TJQK', suits = 'HSDC') { return rChoose(ranks) + rChoose(suits) + postfix; }
function rChoose(arr, n = 1, func = null, exceptIndices = null) {
  let indices = arrRange(0, arr.length - 1);
  if (isdef(exceptIndices)) {
    for (const i of exceptIndices) removeInPlace(indices, i);
  }
  if (isdef(func)) indices = indices.filter(x => func(arr[x]));
  if (n == 1) {
    let idx = Math.floor(Math.random() * indices.length);
    return arr[indices[idx]];
  }
  arrShufflip(indices);
  return indices.slice(0, n).map(x => arr[x]);
}
function rCoin(percent = 50) {
  let r = Math.random();
  r *= 100;
  return r < percent;
}
function rColor(cbrightness, c2, alpha = null) {
  if (isdef(c2)) {
    let c = colorMix(cbrightness, c2, rNumber(0, 100));
    return colorTrans(c, alpha ?? Math.random());
  }
  if (isdef(cbrightness)) {
    let hue = rHue();
    let sat = 100;
    let b = isNumber(cbrightness) ? cbrightness : cbrightness == 'dark' ? 25 : cbrightness == 'light' ? 75 : 50;
    return colorFromHSL(hue, sat, b);
  }
  let s = '#';
  for (let i = 0; i < 6; i++) {
    s += rChoose(['f', 'c', '9', '6', '3', '0']);
  }
  return s;
}
function rConsonant(w, except = []) { let vowels = w ? getConsonants(w, except) : toLetters('aeiouy'); return chooseRandom(vowels); }
function rDate(before, after) {
  let after_date = new Date(after);
  let before_date = new Date(before);
  let random_date = new Date(Math.random() * (before_date.getTime() - after_date.getTime()) + after_date.getTime());
  return random_date;
}
function rDigits(n) { return rChoose(toLetters('0123456789'), n); }
function reAddServerObject(label) {
  let tv = TV[label];
  if (nundef(tv)) {
    console.log('this object has NOT been entered in TV!!! did you remove the object?!?', label);
    return;
  }
  let oid = tv.oid;
  let o = tv.o;
  addServerObject(oid, o, R);
}
function readExp() { }
function realTimeIfTrue(f, cnt) {
  console.log('counter', cnt)
  if (f()) setTimeout(() => realtimeIfTrue(f, cnt + 1), 10);
}
function rec_create_nodes_tree(r, t, path, keys) {
  if (isLiteral(t)) {
    let type = is_game_card(t) ? 'card' : typeof t;
    return register_node(t, type, getUID('o'), path, r);
  } else if (isList(t)) {
    let content = t;
    let type;
    if (startsWith(path, 'deck') || startsWith(path, 'achievements')) {
      type = 'deck';
    } else if (!isEmpty(t) && is_game_card(t[0])) {
      type = 'cardlist';
    }
    else {
      type = 'string';
    }
    let n = register_node(content, type, getUID('o'), path, r);
    if (type == 'cardlist') {
      let ch = [];
      let i = 0;
      for (const el of t) {
        if (!isLiteral(el)) continue;
        let type = is_game_card(el) ? 'card' : typeof t;
        let n1 = register_node(el, type, getUID('o'), path + '.' + el, r);
        i += 1;
        ch.push(n1.oid);
      }
      n.children = ch;
    }
    return n;
  } else if (isDict(t)) {
    let n = register_node(stringAfterLast(path, '.'), 'string', getUID('o'), path, r);
    let ch = [];
    for (const k in t) {
      if (nundef(keys[k]) && k.length > 1) { continue; }
      let pnew = isEmpty(path) ? k : path + '.' + k;
      let tnew = t[k];
      let n1 = rec_create_nodes_tree(r, tnew, pnew, keys);
      ch.push(n1.oid);
    }
    n.children = ch;
    return n;
  } else {
    let type = 'null';
    return register_node('null', type, getUID('o'), path, r);
  }
}
function rec_create_nodes_tree_akku(r, t, path, keys, akku) {
  if (isLiteral(t)) {
    let type = is_game_card(t) ? 'card' : typeof t;
    return register_node(t, type, getUID('o'), path, r);
  } else if (isList(t)) {
    let content = t;
    let type;
    if (startsWith(path, 'deck') || startsWith(path, 'achievements')) {
      type = 'deck';
    } else if (!isEmpty(t) && is_game_card(t[0])) {
      type = 'cardlist';
    }
    else {
      type = 'string';
    }
    let n = register_node(content, type, getUID('o'), path, r);
    if (type == 'cardlist') {
      let ch = [];
      let i = 0;
      for (const el of t) {
        if (!isLiteral(el)) continue;
        let type = is_game_card(el) ? 'card' : typeof t;
        let n1 = register_node(el, type, getUID('o'), path + '.' + el, r);
        i += 1;
        ch.push(n1.oid);
      }
      n.children = ch;
    }
    return n;
  } else if (isDict(t)) {
    let n = register_node(stringAfterLast(path, '.'), 'string', getUID('o'), path, r);
    let ch = [];
    for (const k in t) {
      if (nundef(keys[k]) && k.length > 1) { continue; }
      let pnew = isEmpty(path) ? k : path + '.' + k;
      akku.push(pnew);
      let tnew = t[k];
      let n1 = rec_create_nodes_tree_akku(r, tnew, pnew, keys, akku);
      ch.push(n1.oid);
    }
    n.children = ch;
    return n;
  } else {
    let type = 'null';
    return register_node('null', type, getUID('o'), path, r);
  }
}
function recAdjustDirtyContainers(uid, R, verbose = false) {
  let nui = R.uiNodes[uid];
  if (isdef(nui.children)) {
    for (const ch of nui.children) recAdjustDirtyContainers(ch, R, verbose);
  }
  if (nui.adirty) {
    adjustContainerLayout(nui, R);
  }
}
function recAdjustDirtyContainers_dep(uid, R, verbose = false) {
  let nui = R.uiNodes[uid];
  if (nui.adirty) {
    adjustContainerLayout(nui, R);
  }
  if (nundef(nui.children)) return;
  for (const ch of nui.children) recAdjustDirtyContainers(ch, R, verbose);
}
function recAllNodes(n, f, p, tailrec, safe = false) {
  if (safe) { ___enteredRecursion += 1; if (___enteredRecursion > MAX_RECURSIONS) { error('MAX_RECURSIONS reached!!!' + f.name); return; } }
  if (isList(n)) {
    if (tailrec) f(n, p);
    n.map(x => recAllNodes(x, f, p, tailrec));
    if (!tailrec) f(n, p);
  } else if (isDict(n)) {
    if (tailrec) f(n, p);
    for (const k in n) { recAllNodes(n[k], f, p, tailrec); }
    if (!tailrec) f(n, p);
  }
}
function recArrangeContent(uid, R) {
  let n = R.uiNodes[uid];
  if (nundef(n.children)) return;
  let parentPadding = isdef(n.params.paddingAroundChildren) ? n.params.paddingAroundChildren : DEFS.defaultPadding;
  let childMargin = isdef(n.params.gapBetweenChildren) ? n.params.gapBetweenChildren : DEFS.defaultGap;
  let posModified = false;
  let sizeModified = false;
  let children = n.children.map(x => R.uiNodes[x]);
  if (isdef(n.params.contentwalign) && n.params.contentwalign == 'center') {
    let children = n.children.map(x => R.uiNodes[x]);
    let xchimin = Math.min(...children.map(x => x.pos.x));
    let xchimax = Math.max(...children.map(x => x.pos.x + x.size.w));
    let diff = xchimax - xchimin;
    let wpar = n.size.w - 2 * parentPadding;
    let displ = (wpar - diff) / 2;
    if (displ >= 1) {
      posModified = true;
      for (const ch of children) { ch.params.pos = { x: ch.pos.x + displ, y: ch.pos.y }; }
    }
  }
  if (isdef(n.params.contenthalign) && n.params.contenthalign == 'center') {
    let ychimin = Math.min(...children.map(ch => ch.pos.y));
    let ychimax = Math.max(...children.map(ch => ch.pos.y + ch.size.h));
    let diff = ychimax - ychimin;
    let hpar = n.size.h - 2 * parentPadding;
    let displ = (hpar - diff) / 2;
    if (displ >= 1) {
      posModified = true;
      for (const ch of children) { ch.params.pos = { x: ch.pos.x, y: ch.pos.y + displ }; }
    }
  }
  if (posModified || sizeModified) {
    for (const ch of children) { setFixedSizeAndPos(ch); }
  }
  for (const ch of n.children) recArrangeContent(ch, R);
}
function recBuildRTree(n, key, path, parent, sp, R, oid) {
  CYCLES += 1; if (CYCLES > MAX_CYCLES) return;
  console.log('***', n, path, parent, sp)
  let n1 = { uid: getUID(), key: key, uidParent: parent ? parent.uid : null, path: path };
  if (isdef(oid)) n1.oid = oid;
  let locProp = '_id';
  let nodeName = n[locProp];
  if (isString(nodeName)) {
    lookupAddToList(R.Locations, [nodeName], n1.uid);
    n1.here = nodeName;
    let nSpec = sp[nodeName];
    console.log(nodeName, nSpec)
    if (nundef(nSpec.cond)) {
      let branch = recBuildRTree(nSpec, nodeName, '.', n1, sp, R, oid);
      R.rNodes[branch.uid] = branch;
      n1.children = [branch.uid];
    } else {
    }
  }
  let chProp = 'sub';
  let chlist = n[chProp];
  if (isdef(chlist)) {
    n1.children = [];
    let i = 0;
    for (const chInfo of chlist) {
      let newPath = extendPath(path, i);
      i += 1;
      let ch = recBuildRTree(chInfo, key, newPath, n1, sp, R, oid);
      R.rNodes[ch.uid] = ch;
      n1.children.push(ch.uid);
    }
  }
  return n1;
}
function recBuildUiFromNode(n, uidParent, R, iParams = {}) {
  CYCLES += 1; if (CYCLES > MAX_CYCLES) return;
  let n1 = {};
  let sp = R.getSpec();
  n1.uid = n.uid;
  if (isdef(n.children)) {
    n1.children = n.children.map(x => x);
    n1.adirty = true;
  }
  let parent = lookup(R.rNodes, [uidParent]);
  let nsp = sp[n.key];
  let nsub = evalSpecPath(nsp, n.path, R);
  n1.type = nsub.type;
  n1.data = nsub.data;
  n1.params = isdef(nsub.params) ? nsub.params : {};
  n1.defParams = jsCopy(iParams);
  let oid = n1.oid = n.oid;
  let o = oid ? R.getO(oid) : null;
  if (n1.data) {
    n1.content = calcContentFromData(oid, o, n1.data, R);
    if (isString(n1.content)) {
      console.log(n1.content)
      let oid1 = n1.content;
      console.log('oid of card', oid1, '\noid of n1', oid);
      if (oid1 != oid) {
        let o1 = R.getO(oid1);
        if (o1) {
          let oidNode1 = R.oidNodes[oid1];
          if (isdef(oidNode1)) {
            let key1list = Object.keys(oidNode1);
            console.log('following keys available for', oid1, key1list);
            let key1 = key1list[0];
            console.log('FOUND BETTER REP FOR O', oid1, key1, '\nWAS JETZT???????');
            console.log('der rNode muss doch existieren!!!', R.rNodes[n.uid])
            instantiateOidKeyAtParent(oid1, key1, uidParent, R);
            console.log('HALLOOOOOOOO');
          }
        }
      }
    }
  }
  if (n1.type == 'grid') {
    createBoard(n1, uidParent, R, iParams);
  } else {
    n1.ui = createUi(n1, uidParent, R, iParams);
  }
  R.uiNodes[n1.uid] = n1;
  if (R.isUiActive) n1.act.activate(highSelfAndRelatives, unhighSelfAndRelatives, selectUid);
  if (nundef(n1.children) || n1.type == 'grid') { return; }
  iParams = jsCopy(iParams);
  if (nundef(iParams[n1.type])) iParams[n1.type] = {};
  iParams[n1.type].params = n1.defParams;
  for (const ch of n1.children) {
    let nNew = R.rNodes[ch];
    recBuildUiFromNode(nNew, n1.uid, R, iParams, n1.oid);
  }
}
function recCollect(n, cond, akku, safe = false) {
  if (safe) { ___enteredRecursion += 1; if (___enteredRecursion > MAX_RECURSIONS) { error('MAX_RECURSIONS reached!!!' + f.name); return; } }
  if (cond(n)) akku.push(n);
  if (nundef(n.children)) return;
  for (const ch of n.children) {
    recCollect(ch, cond, akku, safe);
  }
}
function recCollectSizeInfo(t, R, uiNodeSizes) {
  if (nundef(t.size)) return;
  uiNodeSizes[t.uid] = { w: Math.floor(t.size.w), h: Math.floor(t.size.h) };
  if (nundef(t.children)) return;
  for (const ch of t.children) { recCollectSizeInfo(R.uiNodes[ch], R, uiNodeSizes); }
}
function recConvertLists(o, maxlen = 25) {
  for (const k in o) {
    let val = o[k];
    if (isList(val)) {
      if (val.length > maxlen) val = val.slice(0, maxlen).toString() + '...';
      else val = val.toString();
      o[k] = val;
    } else if (isDict(val)) recConvertLists(val);
  }
}
function recConvertToList(n, listOfProps) {
  if (isList(n)) { n.map(x => recConvertToList(x, listOfProps)); }
  else if (isDict(n) && isList(listOfProps)) {
    for (const prop of listOfProps) {
      let lst = n[prop];
      if (isList(lst) && !isEmpty(lst)) { n[prop] = lst.join(' '); }
    }
    for (const k in n) { recConvertToList(n[k], listOfProps); }
  }
}
function recConvertToSimpleList(n, listOfProps) {
  if (isList(n)) { n.map(x => recConvertToList(x, listOfProps)); }
  else if (isDict(n) && isList(listOfProps)) {
    for (const prop of listOfProps) {
      let conv = dictOrListToString(n[prop]);
      if (conv) n[prop] = conv;
    }
    for (const k in n) { recConvertToList(n[k], listOfProps); }
  }
}
function recDeleteEmptyObjects(o) {
  if (isLiteral(o)) return o;
  else if (isList(o)) return o.map(x => recDeleteEmptyObjects(x));
  let onew = {};
  for (const k in o) {
    if (!isEmpty(o[k])) {
      onew[k] = recDeleteEmptyObjects(jsCopy(o[k]));
    }
  }
  return onew;
}
function recDeleteKeys(o, deleteEmpty = true, omitProps) {
  if (isLiteral(o)) return o;
  else if (isList(o)) return o.map(x => recDeleteKeys(x, deleteEmpty, omitProps));
  let onew = {};
  for (const k in o) {
    if (omitProps.includes(k)) continue;
    if (isLiteral(o[k]) || !isEmpty(o[k])) {
      onew[k] = recDeleteKeys(jsCopy(o[k]), deleteEmpty, omitProps);
    } else {
    }
  }
  return onew;
}
function Receptor(div, board) {
  var self = this;
  this.div = div;
  this.board = board;
}
function recFindDOMs(o) {
  if (!isDict(o)) return [];
  if (isDOM(iDiv(o))) return [iDiv(o)];
  let akku = [];
  for (const k in o) {
    let val = o[k];
    akku = akku.concat(recFindDOMs(val));
  }
  return akku;
}
function recFindExecute(o, prop, func) {
  if (!isDict(o) && !Array.isArray(o)) { return; }
  if (isDict(o)) {
    if (o[prop]) { func(o); }
    for (const k in o) { recFindExecute(o[k], prop, func); }
  } else if (isList(o)) {
    for (let i = 0; i < o.length; i++) {
      this.recFindExecute(o[i], prop, func);
    }
  }
}
function recFindProp(o, prop, path, akku) {
  if (!isDict(o) && !Array.isArray(o)) { return; }
  if (isDict(o)) {
    if (o[prop]) { akku[path] = { name: o[prop], node: o }; }
    for (const k in o) { recFindProp(o[k], prop, path + '.' + k, akku); }
  } else if (isList(o)) {
    for (let i = 0; i < o.length; i++) {
      this.recFindProp(o[i], prop, path + '.' + i, akku);
    }
  }
}
function recFindProp_dep(o, prop, path, akku) {
  if (!isDict(o) && !Array.isArray(o)) { return; }
  if (isDict(o)) {
    if (o[prop]) { akku[path] = o[prop]; }
    for (const k in o) { recFindProp(o[k], prop, path + '.' + k, akku); }
  } else if (isList(o)) {
    for (let i = 0; i < o.length; i++) {
      this.recFindProp(o[i], prop, path + '.' + i, akku);
    }
  }
}
function recFlattenLists(o) {
  for (const k in o) {
    let cand = o[k];
    if (isList(cand)) o[k] = cand.join(' ');
    else if (isDict(cand)) recFlattenLists(cand);
  }
}
function recListToString(lst) {
  if (!isList(lst)) return lst;
  if (isListOfLiterals(lst)) return lst.join(',');
  else {
    let res = [];
    for (const el of lst) {
      let elString = recListToString(el);
      res.push(elString);
    }
    return res;
  }
}
function recMeasureAbs(uid, R) {
  let n = R.uiNodes[uid];
  if (isdef(n.children)) {
    for (const ch of n.children) {
      recMeasureAbs(ch, R);
    }
  }
  n.sizeMeasured = calcSizeMeasured(n, R);
  n.sizeNeeded = uniformSizeToContent(uid, R);
  n.size = {
    w: Math.max(n.sizeMeasured.w, n.sizeNeeded.w),
    h: Math.max(n.sizeMeasured.h, n.sizeNeeded.h)
  }
  n.ui.style.width = n.size.w + 'px';
  n.ui.style.height = n.size.h + 'px';
}
function recMeasureArrangeFixedSizeAndPos(uid, R) {
  let n = R.uiNodes[uid];
  let [minx, maxx, miny, maxy] = [100000, 0, 100000, 0];
  if (isdef(n.children)) {
    for (const ch of n.children) {
      let [xmin, xmax, ymin, ymax] = recMeasureArrangeFixedSizeAndPos(ch, R);
      minx = Math.min(minx, xmin);
      maxx = Math.max(maxx, xmax);
      miny = Math.min(miny, ymin);
      maxy = Math.max(maxy, ymax);
    }
    if (nundef(n.params.pos)) {
      return [minx, maxx, miny, maxy];
    }
    let wParent = Math.max(n.params.size.w, maxx);
    let hParent = Math.max(n.params.size.h, maxy);
    n.params.size.w = wParent + 4;
    n.params.size.h = hParent + 4;
    setFixedSizeAndPos(n);
    n.ui.style.opacity = .5;
    minx = Math.min(minx, n.pos.x);
    maxx = Math.max(maxx, n.pos.x + n.size.w);
    miny = Math.min(miny, n.pos.y);
    maxy = Math.max(maxy, n.pos.y + n.size.h);
    return [minx, maxx, miny, maxy];
  } else {
    setFixedSizeAndPos(n);
    let b = getBounds(n.ui);
    return [n.pos.x, n.pos.x + b.width, n.pos.y, n.pos.y + b.height];
  }
}
function recMeasureOverride(uid, R) {
  let n = R.uiNodes[uid];
  if (isdef(n.children)) { for (const ch of n.children) { recMeasureOverride(ch, R); } }
  n.sizeMeasured = calcSizeMeasured(n, R);
  n.sizeNeeded = arrangeOverride(n, R);
  n.size = {
    w: Math.max(n.sizeMeasured.w, n.sizeNeeded.w),
    h: Math.max(n.sizeMeasured.h, n.sizeNeeded.h)
  }
}
function recMergeSpecNode(n, sp, spNew) {
  if (isList(n._NODE)) {
    let lst = n._NODE;
    let combiName = getCombNodeName(lst);
    let nComb = {};
    for (const name of lst) {
      nComb = mergedSpecNode(nComb, sp[name]);
    }
    spNew[combiName] = nComb;
    n._NODE = combiName;
  }
  if (isdef(n.sub)) {
    for (const n1 of n.sub) recMergeSpecNode(n1, sp, spNew);
  }
}
function recNormalize(n, sp) {
  let n1 = jsCopy(n);
  let t = n1.type = nundef(n.type) ? inferType(n) : n.type;
  let locProp = 'panel';
  if (locProp != 'p') {
    n1.p = n[locProp];
    delete n1[locProp];
  }
  let contProp = 'sub';
  if (contProp && isdef(n[contProp])) {
    n1.ch = n[contProp].map(x => recNormalize(x, sp));
    delete n1[contProp];
  }
  return n1;
}
function recomputeBestED() {
  for (const k in symbolDict) {
    let info = symbolDict[k];
    if (info.type == 'emo' && isString(info.D) && isString(info.E)) {
      info.bestD = stringAfterLast(info.D, '|').trim().toLowerCase();
      info.bestE = stringAfterLast(info.E, '|').trim().toLowerCase();
    } else if (nundef(info.E) || isNumber(info.E) || isdef(info.bestE)) continue;
    if (info.type == 'emo') continue;
    if (info.E.includes('|')) {
      console.log('he das gibt es doch nicht!!!', k, info);
    } else {
      info.bestE = info.E;
    }
    if (nundef(info.D)) {
      console.log('he das gibt es doch nicht!!! KEIN DEUTSCH!', k, info);
    } else {
      info.bestD = stringBefore(info.D, '|').trim().toLowerCase();
    }
  }
  downloadAsYaml(symbolDict, 'sym');
}
function record(lang, best) {
  if (!isGameWithSpeechRecognition()) return;
  let wordlist = ['du', 'bist', 'ein', 'vogel', best];
  if (!isdef(recognition)) {
    speech00(lang);
    setTimeout(record(lang, wordlist), 3000);
    return;
  }
  setVocabulary(wordlist);
  if (isdef(recognition) && isRunning) {
    console.log('.......................stopping recog');
    recordCallback = () => record(lang, wordlist);
    recognition.stop();
  } else {
    isRunning = true;
    recognition.start();
  }
}
function record_winners(winners, game) { ensure_winnerlist(game).push(winners); }
function recoverStateAndSettings() {
  onClickRetrieveState();
  let settings = localStorage.getItem('settings');
  if (isdef(settings)) {
    settings = JSON.parse(settings);
    console.log('retrieved settings (baseColor)', settings.baseColor);
    G.settings = settings;
    Socket.emit('settings', { settings: G.settings });
  } else {
    console.log('no settings in localStorage!');
  }
}
function recPopulateTree(t, R, levels) {
  if (levels > 0) {
    addRandomChildren(t, R);
    if (Object.keys(R.rNodes).length >= MAXNODES) { console.log('MAXNODES REACHED!!!'); return; }
    for (const id of t.children) {
      if (chooseRandom([true, false])) {
        recPopulateTree(R.rNodes[id], R, levels - 1);
      }
    }
  }
}
function recPosRandomUiTreeX(uid, R, context) {
  let n = R.uiNodes[uid];
  let gran = context.granularity;
  n.params.size = { w: randomNumber(1, context.wmax) * gran, h: randomNumber(1, context.hmax) * gran };
  n.params.pos = { x: randomNumber(1, context.xmax) * gran, y: randomNumber(1, context.ymax) * gran }
  n.params.sizing = 'fixed';
  if (nundef(n.children)) return;
  for (const ch of n.children) { recPosRandomUiTreeX(ch, R, context); }
}
function recPosRegularUiTree(uid, R) {
  let n = R.uiNodes[uid];
  n.params.sizing = 'fixed';
  if (nundef(n.children)) return;
  for (const ch of n.children) { recPosRegularUiTree(ch, R); }
  let num = n.children.length;
  if ([2, 4, 6, 9, 12, 16, 20, 25, 30, 36, 42, 29, 56, 64].includes(num)) arrangeChildrenAsQuad(n, R);
  else if ([3, 8, 15, 24, 35, 48, 63].includes(num)) {
    let lower = Math.floor(Math.sqrt(num));
    console.assert(num == lower * (lowe + 2), 'RECHNUNG FALSCH IN recPosRegularUiTree');
    arrangeChildrenAsMatrix(n, R, lower, lower + 2);
  } else if (num > 1 && num < 10) arrangeChildrenAsCircle(n, R);
}
function recPresent(n, level, dLevel, nDict, treeProp, { lstFlatten, lstShow, lstOmit } = {}) {
  mNodeFilter(n, { dParent: dLevel[level], lstFlatten: lstFlatten, lstShow: lstShow, lstOmit: lstOmit });
  if (nundef(n.children)) return level;
  let max = 0;
  for (const x of n.children) {
    let nx = nDict[x];
    let newMax = recPresent(nx, level + 1, dLevel, nDict, treeProp, { lstFlatten: lstFlatten, lstShow: lstShow, lstOmit: lstOmit });
    if (newMax > max) max = newMax;
  }
  return max;
}
function recPresent_dep(n, level, dLevel, { lstFlatten, lstShow, lstOmit } = {}) {
  let n1 = jsCopy(n);
  n1 = filterByNoKey(n, lstOmit);
  mNode(n1, { dParent: dLevel[level], listOfProps: lstFlatten });
  if (nundef(n.children)) return level;
  let max = 0;
  for (const x of n.children) {
    let newMax = recPresent_dep(x, level + 1, dLevel, { lstFlatten: lstFlatten, lstShow: lstShow, lstOmit: lstOmit });
    if (newMax > max) max = newMax;
  }
  return max;
}
function recPresent_dep1(n, level, dLevel, lstFlatten, lstShow) {
  let n1 = jsCopy(n);
  n1 = filterByNoKey(n, ['sub', '_id', '_ref', 'children', 'source', 'specKey', 'params', 'cssParams', 'typParams', 'stdParams', 'uid', 'ui'])
  mNode(n1, { dParent: dLevel[level], listOfProps: lstFlatten });
  if (nundef(n.children)) return level;
  let max = 0;
  for (const x of n.children) {
    let newMax = recPresent_dep1(x, level + 1, dLevel, lstFlatten, lstShow);
    if (newMax > max) max = newMax;
  }
  return max;
}
function recPresentFilter(n, level, dLevel, { lf, ls, lo } = {}) {
  mNodeFilter(n, { dParent: dLevel[level], lstFlatten: lf, lstShow: ls, lstOmit: lo });
  if (nundef(n.children)) return level;
  let max = 0;
  for (const x of n.children) {
    let newMax = recPresentFilter(x, level + 1, dLevel, { lf: lf, ls: ls, lo: lo });
    if (newMax > max) max = newMax;
  }
  return max;
}
function recPresentNode_dep(n, R, sizing) {
  console.log('sizing', n.uid, sizing);
  if (isdef(n.children)) {
    for (const ch of n.children) {
      let n1 = R.uiNodes[ch];
      recPresentNode_dep(n1, R, getSizing(n1, R, sizing));
    }
  }
  if (sizing == 'sizeToContent') { }
  else if (sizing == 'fixed') { }
  else if (sizing == 'sizeChildren') { }
  else {
    if (isdef(n.children)) {
      let fLayout = n.params.layout;
      if (nundef(fLayout)) fLayout = RLAYOUT[n.type];
      if (nundef(fLayout)) fLayout = panelLayout;
      let szNeeded = fLayout(n, R);
    }
  }
}
function recRemove(n, R) {
  if (isdef(n.children)) {
    let ids = jsCopy(n.children);
    for (const ch of ids) recRemove(R.rNodes[ch], R);
  }
  delete R.rNodes[n.uid];
  R.unregisterNode(n);
  delete R.uiNodes[n.uid];
  let parent = R.rNodes[n.uidParent];
  removeInPlace(parent.children, n.uid);
  if (isEmpty(parent.children)) delete parent.children;
  let uiParent = R.uiNodes[n.uidParent];
  removeInPlace(uiParent.children, n.uid);
  if (isEmpty(uiParent.children)) delete uiParent.children;
}
function recShowHints(ilist, rc, delay = 3000, fProgression = d => d * 1.5) {
  if (isEmpty(ilist) || QContextCounter != rc) return;
  let i = ilist.shift();
  TOTrial = setTimeout(() => recShowHintsNext(i, ilist, rc, fProgression(delay), fProgression), delay);
}
function recShowHintsNext(i, ilist, rc, delay, fProgression) {
  showSayHint(i);
  if (QContextCounter == rc) recShowHints(ilist, rc, delay, fProgression);
}
function recShowTree(o, indent, childrenKeys, lstShow, lstOmit) {
  showObject(o, indent, true, lstShow, lstOmit);
  let chkey = findFirstListKey(o, childrenKeys);
  if (chkey) {
    console.log(' '.repeat(indent + 2) + chkey + ':');
    for (const ch of o[chkey]) {
      recShowTree(ch, indent + 4, childrenKeys, lstShow, lstOmit);
    }
  }
}
function recTree(n, rParent, R, oid, key) {
  let uid = getUID();
  let n1 = {};
  let chanav;
  [n, chanav] = mixinChannel(n, rParent, R);
  let expandProp = '_NODE'; let nodeName = n[expandProp];
  if (isString(nodeName)) {
    let nSpec = R.getSpec(nodeName);
    if (nundef(n.cond) && nundef(nSpec.cond)) {
      let merged = merge1(nSpec, n, { dataMerge: 'reverse' });
      delete merged._NODE;
      if (isdef(nSpec._NODE)) merged._NODE = nSpec._NODE;
      return recTree(merged, rParent, R, oid, key);
    } else if (n.cond) {
      n = merge1(nSpec, n, { dataMerge: 'none' });
      delete n._NODE;
    } else {
      if (n.cond) { console.log('ja, n.cond kann sein!!!!', '\nn', n, '\nnSpec', nSpec) }
      lookupAddToList(R.Locations, [nodeName], uid);
      n1.here = nodeName;
      if (nundef(n.data) && nundef(n.type)) n1.type = 'invisible';
    }
  } else if (isList(nodeName)) {
    console.log('REINGEFALLEN!!!!!!!!!!!!!!!!!!!!!!')
  }
  n1 = mergeOverrideArrays(n, n1);
  if (isdef(n1.sub)) delete n1.sub;
  n1.uid = uid;
  n1.uidParent = rParent ? rParent.uid : null;
  if (isdef(oid)) n1.oid = oid;
  if (chanav) n1.chanav = chanav;
  let chProp = 'sub'; let chlist = n[chProp];
  if (isdef(chlist)) {
    n1.children = [];
    for (const chInfo of chlist) {
      let ch = recTree(chInfo, n1, R, oid, key);
      R.rNodes[ch.uid] = ch;
      n1.children.push(ch.uid);
    }
  }
  return n1;
}
function recUi(n, R, area, oid, key) {
  let n1 = R.uiNodes[n.uid] = jsCopy(n);
  let o = isdef(oid) ? R.getO(oid) : null;
  if (isdef(n1.data)) { n1.content = calcContentFromData(oid, o, n1.data, R, n1.default_data); }
  if (n1.type == 'grid') {
    createBoard(n1, R, area);
  } else {
    let lst = getElements(n1.content);
    if (isdef(lst) && !isEmpty(lst)) {
      let o = R.getO(lst[0]);
      if (isListOfLiterals(lst) && isdef(o)) { handleListOfObjectIds(lst, n1, area, R); }
      else if (isListOfLists(lst) && isdef(o[0])) {
        for (const l of lst) { handleListOfObjectIds(l, n1, area, R); }
      }
      else {
        if (nundef(n1.type)) n1.type = 'info';
        n1.content = lst.join(' ');
        n1.ui = createUi(n1, R, area);
      }
      let rTreePanel = R.rNodes[n1.uid];
      n1.children = rTreePanel.children;
    } else {
      n1.ui = createUi(n1, R, area);
    }
  }
  if (nundef(n1.children) || n1.type == 'grid') return n1;
  n1.adirty = true;
  for (const ch of n1.children) {
    if (isdef(R.uiNodes[ch])) { continue; }
    recUi(R.rNodes[ch], R, n1.uid, oid, key);
  }
  return n1;
}
function recUiTestX(n, R) {
  let n1 = R.uiNodes[n.uid] = jsCopy(n);
  let area = isdef(n1.uidParent) ? n1.uidParent : R.baseArea;
  n1.ui = createUiTestX(n1, R, area);
  if (nundef(n1.children)) return;
  for (const ch of n1.children) {
    recUiTestX(R.rNodes[ch], R);
  }
}
function recVerify(series, index, maxIndex) {
  if (index > maxIndex) return;
  else setTimeout(() => doNext(series, index, maxIndex), 1000);
}
function redrawScreen() {
  checkCleanup_II();
  if (S.settings.userBehaviors) {
    loadCode0(userCode.asText, 'setUserSpecAndCode();proceedRedraw();', () => {
      console.log('setting code now!')
      setUserSpecAndCode();
      proceedRedraw();
    });
    console.log('userCode', userCode);
  }
  else proceedRedraw();
}
function reduce_to_current_players() {
  let d = mBy('d_players');
  let checkboxes = d.getElementsByTagName('input');
  let list = [];
  for (const chk of checkboxes) {
    if (chk.checked) {
      list.push(chk.value);
    }
  }
  populate_players(list);
}
function reduceBoard(board, rNew, cNew, iModify) {
  let [boardArrOld, rOld, cOld] = [board.fields.map(x => isdef(x.item) ? x.item.index : null), board.rows, board.cols];
  let rest = [];
  if (rOld > rNew) { rest = bGetRow(boardArrOld, iModify, rOld, cOld).filter(x => x != null); }
  else if (cOld > cNew) { rest = bGetCol(boardArrOld, iModify, rOld, cOld).filter(x => x != null); }
  let boardArrNew = new Array(rNew * cNew);
  for (let r = 0; r < rNew; r++) {
    for (let c = 0; c < cNew; c++) {
      let i = iFromRowCol(r, c, rNew, cNew);
      let x = (rOld != rNew) ? r : c;
      if (x < iModify) {
        let iOld = iFromRowCol(r, c, rOld, cOld);
        boardArrNew[i] = boardArrOld[iOld];
      }
      else {
        let [ir, ic] = (rOld != rNew) ? [r + 1, c] : [r, c + 1];
        let iOld = iFromRowCol(ir, ic, rOld, cOld);
        boardArrNew[i] = boardArrOld[iOld];
      }
    }
  }
  return { rows: rNew, cols: cNew, boardArr: boardArrNew, extras: rest };
}
function refillCharInput(inp, ch) { fillCharInput(inp, ch); }
function register(el, id, type, x, y, nid1, nid2) {
  let lst = addIfKeys(EC, [y, x], []);
  lst.push(el);
  lst = addIfKeys(ET, [type], []);
  lst.push(el);
  if (id in EID) {
  }
  EID[id] = el;
  if (type == 'edge' && nid1 !== undefined && nid2 !== undefined) {
    ENN[comp_(nid1, nid2)] = el;
  }
}
function register_menu_item(elem, key, handler) { }
function register_node(content, type, oid, path, r) {
  let n = {
    content: content,
    type: type,
    oid: oid,
    path: path,
    children: [],
  };
  r.add_node(n, oid);
  return n;
}
function registerAsNewItem(item) { item.id = iRegister(item); return item; }
function registeredItemCopy(orig) { let item = jsCopy(orig); item.id = iRegister(item); return item; }
function registerElement(mobj) {
  elements[mobj.id] = mobj;
}
function registerItems(items) {
  for (const i of items) UIS[i.div.id] = i;
}
function registerObject(what, props, mapping, mParentId) {
  ensureUIS();
  let mk = new MK();
  let id = mk.id = getUID();
  if (mParentId) mk.mParentId = mParentId;
  let oid = mk.oid = isDict(what) ? mapping.oid : what;
  let o = mk.o = isDict(what) ? what : isEmpty(props) ? getServerObject(oid) : mapping.omap;
  let myPath = mk.myPath = isDict(what) ? mapping.path + o.key : oid == mapping.oid ? oid + mapping.props.join('.') : what;
  mk.isLeaf = isDict(what) || oid != mapping.oid;
  let idType = mk.idType = 'm';
  listKey(path2mainIds, myPath, id);
  mk.mapping = mapping;
  linkObjects(id, oid);
  listKey(IdOwner, idType, id);
  UIS[id] = mk;
  return mk;
}
function registerObject_dep(o, idType, loc, rsgType) {
  let id = getUID();
  let mk = new MK();
  mk.o = o.o;
  mk.info = o.info;
  let oid = stringBefore(o.oid, '.');
  mk.oid = oid;
  mk.path = o.oid;
  mk.rsg = rsgType;
  mk.id = id;
  mk.idType = idType;
  mk.loc = loc;
  if (o.ui) registerUiFor(mk, o.ui);
  linkObjects(id, oid);
  listKey(IdOwner, idType, id);
  UIS[id] = mk;
  return mk;
}
function registerUiFor(mk, ui) { mk.elem = ui; mk.elem.id = mk.id; mk.parts.elem = ui; mk.domType = getTypeOf(ui); mk.cat = DOMCATS[mk.domType]; }
function reindex_items(items) { let i = 0; items.map(x => { x.index = i; i++; }); }
function reload() {
  console.log('reload!!!')
  if (radio_contacts.checked == true) get_contacts();
  else if (radio_chat.checked == true) get_chats();
  else if (radio_games.checked == true) get_games();
  else if (radio_play.checked == true) get_play();
}
function reload_assets() {
  const asset_names = {
    'Syms': 'allSyms',
    'users': 'db_users',
    'games': 'db_games',
    'tables': 'db_tables',
  }
  assets_get(arguments);
}
function reload_last_game_state() { if (!in_game_open_prompt()) open_prompt(Session.cur_me.state); }
function reload_prompt(fen) {
  console.assert(!uiActivated, 'open_prompt with uiActivated ON !!!!!!!!!!!!!!!!!!!!!!!!!!');
  let game = Session.cur_game;
  let uname = Session.cur_user;
  let g = Session;
  let next = lookup(DB.games, [game]); if (next) copyKeys(next, g);
  next = lookup(DB.users, [uname, 'games', game]); if (next) copyKeys(next, g);
  let level = g.level = valf(g.startlevel, g.def_startlevel);
  lookupSet(DB.users, [uname, 'games', game, 'startlevel'], level);
  next = lookup(DB.games, [game, 'levels']);
  if (next) copyKeys(next[level], g);
  g.maxlevel = valf(get_keys(next).length, 0) - 1;
  g.color = getColorDictColor(g.color);
  g.winning_score = Session.cur_table.options.winning_score;
  delete g.levels;
  clearTable(); set_background_color(g.color);
  QContextCounter += 1;
  show_game_name(g.friendly);
  show_title(g.table.friendly);
  show_level(g.level, g.maxlevel);
  if (Session.is_badges) setBadgeLevel(g.level);
  g.startTime = get_timestamp();
  mLinebreak(dTable, 15);
  let items = g.items = spotit_deal(g.num_cards, g.rows, g.cols, g.vocab, g.lang, g.min_scale, g.max_scale, fen);
  Selected = null;
}
function remove_card_shadow(c) { iDiv(c).firstChild.setAttribute('class', null); }
function remove_from_selection(card) {
  if (nundef(Z.A)) return;
  let A = Z.A;
  let item = firstCond(A.items, x => x.id == card.id);
  if (isdef(item)) {
    let idx = item.index;
    A.items.splice(item.index, 1);
    removeInPlace(A.selected, item.index);
    make_card_unselectable(item);
    make_card_unselected(item);
    reindex_items(A.items);
  }
}
function remove_hourglass(uname) { let d = mBy(`dh_${uname}`); if (isdef(d)) mRemove(d); }
function remove_hover_ui(b) { b.onmouseenter = null; b.onmouseleave = null; }
function remove_player(fen, uname) {
  if (nundef(fen.original_players)) fen.original_players = jsCopy(fen.players);
  removeInPlace(fen.plorder, uname);
  delete fen.players[uname];
  return fen.plorder;
}
function remove_tides_from_play(fen, plname, tides) {
  let pl = fen.players[plname];
  if (nundef(tides)) tides = pl.tides.keys;
  for (const tide of tides) {
    if (tide.path.includes('hand')) { removeInPlace(pl.hand, tide.key); }
    else if (tide.path.includes('stall')) { removeInPlace(pl.stall, tide.key); }
  }
  ari_history_list([`${plname} tides ${tides.map(x => x.key).join(', ')}!`], 'tide');
}
function remove_tithes_from_play(fen, plname, tithes) {
  let pl = fen.players[plname];
  if (nundef(tithes)) tithes = pl.tithes.keys;
  for (const tithe of tithes) {
    if (tithe.path.includes('hand')) { removeInPlace(pl.hand, tithe.key); }
    else if (tithe.path.includes('stall')) { removeInPlace(pl.stall, tithe.key); }
  }
  ari_history_list([`${plname} tithes ${tithes.map(x => x.key).join(', ')}!`], 'tithe');
}
function remove_ui_items(items) {
  console.log('remove_ui_items', items);
  for (const item of items) {
    let card = item.o;
    make_card_unselectable(item);
    iDiv(item.o).remove();
  }
}
function removeAllEvents(elem) {
  var a = elem.attributes, i, l, n;
  if (a) {
    for (i = a.length - 1; i >= 0; i -= 1) {
      n = a[i].name;
      if (typeof elem[n] === 'function') {
        console.log('.......removing', n, 'from', elem.id)
        elem[n] = null;
      }
    }
  }
}
function removeAllGlobalHandlers() {
  removeEventListener('keyup', keyUpHandler);
  removeEventListener('keydown', keyDownHandler);
  document.getElementById('login_form').removeEventListener('submit', onLoginSubmitted);
  document.getElementById('bLogout').removeEventListener('click', onClickLogout);
  if (USE_SOCKETIO) document.getElementById('chat_form').removeEventListener('submit', onChatSubmitted);
  document.getElementById('bJoinGame').removeEventListener('click', onClickJoinGameLobby);
  document.getElementById('bCreateGame').removeEventListener('click', onClickCreateGameLobby);
  document.getElementById('bResumeGame').removeEventListener('click', onClickResumeGameLobby);
}
function removeAllHighlighting(id) { let ms = UIS[id]; ms.unhighAll(); }
function removeAttributes(elem) {
  while (elem.attributes.length > 0) {
    elem.removeAttribute(elem.attributes[0].name);
  }
}
function removeBadgeAndRevertLevel() {
  removeBadges(dLeiste, currentLevel);
  setBackgroundColor();
  proceedIfNotStepByStep();
}
function removeBadges(dParent, level) {
  while (badges.length > level) {
    let badge = badges.pop();
    mRemove(iDiv(badge));
  }
}
function removeBoard(R) {
  let oid = detectFirstBoardObject(R);
  removeServerObject(oid, 'board');
}
function removeBorder(elem) {
  elem.style.border = null;
}
function removeByProp(arr, prop, val) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i][prop] === val) {
      arr.splice(i, 1);
      i--;
      return;
    }
  }
}
function removeCard(c, deck) { removeInPlace(deck, c); }
function removeCardFromHand(oid, hand, subArea) {
  let id = getMainId(oid);
  if (isdef(id)) {
    let mobj = UIS[id];
    mobj.detach();
    mobj.hand = null;
  }
  if (nundef(hand)) return;
  removeInPlace(hand.cards, oid);
  hand.numCards = hand.cards.length;
  _repositionCards(hand, subArea);
}
function removeCards(deck) {
  return removeTopNCards(deck, getNumCards(deck));
}
function removeCardsFromTo(deck, iFrom, iTo) {
  let n = iTo - iFrom + 1;
  return removeNCardsFrom(deck, iFrom, n);
}
function removeClass(el, clName) { if (!el) return; el.classList.remove(clName); }
function removeClickHandler(id) { let ms = UIS[id]; ms.removeHandlers(); }
function removeColNew(board, cClick) { return reduceBoard(board, board.rows, board.cols - 1, cClick); }
function removeCommentsFromLine(line) {
  let l = line;
  if (!l.includes("`//") && !l.includes("'//") && !l.includes("//'") && !l.includes("http")) {
    l = replaceAllFast(line, '://', ':@@');
    l = replaceAllFast(l, '//#', '@@#');
    l = stringBefore(l, '//');
    l = replaceAllFast(l, '@@#', '//#');
    l = replaceAllFast(l, ':@@', '://');
  }
  if (l.trim().endsWith('*/')) l = stringBefore(l, '/*');
  return l;
}
function removeDOM(elem) { purge(elem); }
function removeDuplicates(keys, prop) {
  let di = {};
  let res = [];
  let items = keys.map(x => Syms[x]);
  for (const item of items) {
    if (isdef(di[item.best])) { continue; }
    res.push(item);
    di[item.key] = true;
  }
  return res.map(x => x.key);
}
function removeElem(elem) {
  removeAllEvents(elem);
  elem.remove();
}
function removeEvents(elem) {
  for (const evname of arguments) {
    elem['on' + evname] = null;
  }
}
function removeFilterHighlight(ms) { ms.unhighC(); }
function RemoveGUIPiece(sq) {
  $(".Piece").each(function (index) {
    if ((RanksBrd[sq] == 7 - Math.round($(this).position().top / 60)) && (FilesBrd[sq] == Math.round($(this).position().left / 60))) {
      $(this).remove();
    }
  });
}
function removeHoverHandlers(id) { let ms = UIS[id]; ms.removeHandlers(); }
function removeIf(arr, el) { removeInPlace(arr, el); }
function removeInPlace(arr, el) {
  arrRemovip(arr, el);
}
function removeInPlaceKeys(dict, keys) {
  for (const k of keys) {
    delete dict[k];
  }
}
function removeInteraction(id) { let ms = UIS[id]; ms.removeHandlers(); ms.unhighAll(); }
function removeKeyHandler(k) {
  let f = lookup(DA, ['keyup', k]);
  if (lookup(DA, ['keyup', k])) {
    delete DA.keyup[k];
  }
  if (lookup(DA, ['keydown', k])) {
    delete DA.keydown[k];
  }
}
function removeLabel(item) {
  if (isdef(item.live.dLabel)) {
    item.live.dLabel.remove();
    delete item.live.dLabel;
  }
  return item;
}
function removeMarkers() {
  for (const m of Markers) {
    mRemoveGracefully(m);
  }
  Markers = [];
}
function removeNCardsFrom(deck, iFrom, n) {
  n = Math.min(getNumCards(deck), n);
  return deck.cards.splice(iFrom, n);
}
function removeNonAlphanum(s) {
  let res = '';
  let nonalphas = '';
  for (const l of s) {
    if (isAlphaNumeric(l)) res += l; else nonalphas += l;
  }
  return { alphas: res, whites: nonalphas };
}
function removeOidKey(oid, key, R) {
  let nodeInstances = lookup(R.rNodesOidKey, [oid, key]);
  if (!nodeInstances) {
    console.log('nothing to remove!', oid, key);
    return;
  }
  for (const uid of nodeInstances) {
    let n1 = R.rNodes[uid];
    recRemove(n1, R);
  }
}
function removeOuterDoors(house) {
  console.log(house.doors);
  for (const did of jsCopy(house.doors)) {
    console.log(did)
    let door = Items[did];
    iDiv(door).remove();
    console.log('door', door);
    for (const rid of door.rooms) { removeInPlace(Items[rid].doors, did); }
    removeInPlace(house.doors, did);
  }
  console.log(house.doors);
}
function removePeepFromCrowd(peep) {
  removeItemFromArray(crowd, peep)
  availablePeeps.push(peep)
}
function removePic(item) {
  let div = item.div;
  let newItem = getLbl(item.key, item.sz, item.bg, item.label);
  clearElement(div);
  mAppend(div, newItem.div.children[0]);
  delete item.pic;
  item.text = newItem.text;
}
function removePicture(pic, reorder = false) {
  removeInPlace(Pictures, pic);
  if (reorder) {
    iDiv(pic).remove();
    maLayout(Pictures, dTable);
  } else {
    iDiv(pic).style.opacity = 0;
  }
}
function removeRobber(R) {
  let robberOid = firstCondDict(R._sd, x => x.o.obj_type == 'robber');
  if (nundef(robberOid)) {
    console.log('this test is not applicable!');
  }
  removeServerObject(robberOid, 'robber');
}
function removeRowNew(board, cClick) { return reduceBoard(board, board.rows - 1, board.cols, cClick); }
function removeServerObject(oid, label) {
  let o = R.getO(oid);
  if (nundef(o)) {
    console.log('object cannot be removed because not in R', oid);
    return;
  }
  if (isdef(label)) TV[label] = { oid: oid, o: o };
  let activate = R.isUiActive;
  if (activate) deactivateUis(R);
  delete sData[oid];
  completelyRemoveServerObjectFromRsg(oid, R);
  console.log('removed oid', oid);
  updateOutput(R);
  if (activate) activateUis(R);
}
function removeTopNCards(deck, n) {
  n = Math.min(getNumCards(deck), n);
  return deck.cards.splice(-n);
}
function render() {
  canvas.width = canvas.width
  cx.save()
  cx.scale(devicePixelRatio, devicePixelRatio)
  crowd.forEach((peep) => {
    peep.render(cx)
  })
  cx.restore()
}
function renderVisualStructures(ipal = 2) {
  for (const key in visualStructures) {
    let msList = visualStructures[key];
    let board = msList[0];
    board.setbg(getpal(ipal)).draw();
    ipal += 1;
    for (let i = 1; i < msList.length; i++) {
      msList[i].setbg(getpal(ipal)).draw();
    }
  }
}
function renewTimer(G, elem, onTimeOver = null) { if (nundef(GameTimer)) GameTimer = new TimerClass(G); GameTimer.restart(G, elem, onTimeOver); }
function replace_jolly(key, j) {
  let jolly_idx = find_index_of_jolly(j);
  j[jolly_idx] = key;
}
function replaceAll(str, sSub, sBy) {
  let regex = new RegExp(sSub, 'g');
  return str.replace(regex, sBy);
}
function replaceAllFast(str, sSub, sBy) { return replaceAll(str, sSub, sBy); }
function replaceAllSafe(str, sSub, sBy) { return replaceAllSpecialChars(str, sSub, sBy); }
function replaceAllSpecialChars(str, sSub, sBy) { return str.split(sSub).join(sBy); }
function replaceAllX(str, sSub, sBy) { return replaceAllSpecialChars(str, sSub, sBy); }
function replaceAtString(s, i, ssub) { return s.substring(0, i) + ssub + s.substring(i + 1); }
function replaceEvery(w, letter, nth) {
  let res = '';
  for (let i = 1; i < w.length; i += 2) {
    res += letter;
    res += w[i];
  }
  if (w.length % 2) res += w[0];
  return res;
}
function replaceFractionOfWordBy(w, letter = 'w', fr = .5) {
  let len = Math.ceil(w.length * fr);
  let len1 = Math.floor(w.length * fr);
  let sub = letter.repeat(len);
  w = sub + w.substring(0, len1);
  return w;
}
function replaceIdName(sssname, R, workingSpec) {
  let newSpecNodeUids = {};
  for (const id of R.idarr) {
    let name = id.idName;
    if (name != sssname) continue;
    let spk = id.specKey;
    let idpath = id.ppath;
    let [key, obj] = findAddress(spk, workingSpec, idpath);
    let sub = [];
    for (const ref of R.refarr) {
      if (ref.idName != name) continue;
      let idnode = obj[key];
      let uid = getUID('sp');
      newSpecNodeUids[uid] = { uid: uid, ref: ref, id: id };
      //#region other versions
      //#endregion
      let merged;
      if (isdef(idnode._merge) && idnode._merge == 'blend') {
        merged = merge1(ref.node, idnode);
        sub.push({ _NODE: uid });
      } else {
        merged = jsCopy(ref.node);
        let resultNode = jsCopy(idnode);
        resultNode._NODE = uid;
        delete resultNode._id;
        sub.push(resultNode);
      }
      delete merged._ref;
      delete merged._id;
      workingSpec[uid] = merged;
    }
    if (sub.length == 0) {
      if (isdef(R.lastSpec[name])) {
        obj[key]._NODE = name;
        delete obj[key]._id;
        alert('SPEC ERROR! =>please replace _id:' + name + ' by _NODE:', name);
      } else {
      }
    } else if (sub.length == 1) {
      if (isdef(obj[key]._NODE)) {
        let x = obj[key]._NODE;
        if (isList(x)) {
          x.unshift(sub[0]._NODE);
          obj[key]._NODE = jsCopy(x);
        } else {
          obj[key]._NODE = [x, sub[0]._NODE];
        }
      } else obj[key] = sub[0];
    } else {
      let res = obj[key];
      if (isdef(res._NODE)) {
        let x = res._NODE;
        for (let i = 0; i < sub.length; i++) sub[i]._NODE = [x, sub[i]._NODE];
        obj[key] = { sub: sub };
      } else obj[key] = { sub: sub };
    }
  }
  return newSpecNodeUids;
}
function replaceLabel(item, label) { }
function replaceNonEmptyByRandom(s, letters) {
  let res = '';
  for (const l of s) {
    if (l == ' ') res += ' '; else res += chooseRandom(letters);
  }
  return res;
}
function replacePic(item, key) { }
function replacePicAndLabel(item, key, label) {
  let div = item.div;
  let newItem = getPic(key, item.sz, item.bg, label);
  clearElement(div);
  mAppend(div, newItem.div.children[0]);
  mAppend(div, newItem.div.children[0]);
  item.pic = newItem.pic;
  item.text = newItem.text;
}
function replaceSol(sol, diop) {
  let rhs = stringBefore(sol, '=');
  let type = rhs.includes('*') ? rhs.includes('R') ? 'div' : 'mult' : rhs.includes('R') ? 'minus' : 'plus';
  let i = 0;
  while (i < rhs.length) {
    if (rhs[i] == 'R') { diop.R = getOperand(type); i += 1; }
    else if (rhs[i] == 'r' && !isLetter(rhs[i + 1])) { if (nundef(diop.r)) diop.r = getOperand(type); i += 1; }
    else if (rhs[i] == 'N') {
      i += 1;
      let inum = Number(rhs[i]);
      let k = 'N' + inum;
      if (nundef(diop[k])) diop[k] = getOperand(type);
      i += 1;
    } else if (rhs[i] == 'D') {
      i += 1;
      let inum = Number(rhs[i]);
      let k = 'D' + inum;
      i += 1;
      if (rhs[i] == '{') {
        let subs = rhs.substring(i);
        let inKlammern = stringBefore(subs, '}');
        rhs = rhs.substring(0, i) + stringAfter(subs, '}');
        i += inKlammern.length;
        let nums = allNumbers(inKlammern);
        diop[k] = chooseRandom(nums);
      } else if (nundef(diop[k])) {
        diop[k] = randomNumber(2, 9);
      }
    } else if (rhs[i] == 'F') {
      if (isdef(diop[rhs.substring(i, i + 2)])) { i += 2; continue; }
      let s_ab_i = rhs.substring(i);
      let s_vor_klammer_zu = stringBefore(s_ab_i, ')');
      let lenRaus = s_vor_klammer_zu.length + 1;
      let s_nach_fraction = stringAfter(s_ab_i, ')');
      let kFraction = s_ab_i.substring(0, 2);
      let kNum = s_ab_i.substring(3); kNum = stringBefore(kNum, ',');
      let kDenom = stringAfter(s_ab_i, ','); kDenom = stringBefore(kDenom, ')');
      rhs = rhs.substring(0, i) + 'math.fraction(' + kNum + ',' + kDenom + ')' + s_nach_fraction;
      let num = isNumber(kNum) ? Number(kNum) : isdef(diop[kNum]) ? diop[kNum] : null;
      let denom = isNumber(kDenom) ? Number(kDenom) : isdef(diop[kDenom]) ? diop[kDenom] : null;
      let fr = getRandomFraction(num, denom);
      diop[kFraction] = fr;
      if (!num) diop[kNum] = fr.n;
      if (!denom) diop[kDenom] = fr.d;
      i += 20;
    } else i += 1;
  }
  i = 0;
  while (i < rhs.length) {
    if (rhs[i] == 'n') {
      i += 1;
      let inum = Number(rhs[i]);
      let k = 'n' + inum;
      let kN = 'N' + inum;
      let x = diop[kN];
      if (nundef(diop[k])) diop[k] = randomNumber(2, x - 1);
      i += 1;
    } else i += 1;
  }
  let eq = rhs;
  for (const k in diop) {
    let val = diop[k];
    if (isFractionType(val)) val = `math.fraction(${val.n},${val.d})`;
    eq = eq.replace(k, val);
  }
  let result = eval(eq);
  let lhs = stringAfter(sol, '=').trim();
  if (isEmpty(lhs)) lhs = 'R';
  diop[lhs] = result;
  return [result, eq];
}
function replaceWhite(s, sby = '_') { let w = toWords(s); return w.join(sby); }
function report_poll(obj) {
  polling_shield_off();
  update_cur_table(obj);
  status_message_off();
  get_games();
}
function repositionCards(msCollection) {
  if (msCollection.numCards == 0) return;
  let dTitle = msCollection.parts.title;
  let dBody = msCollection.parts.hand;
  let dHand = msCollection.elem;
  let bTitle = getBounds(dTitle);
  let bBody = getBounds(dBody, true);
  let bHand = getBounds(dHand);
  let yBody = bTitle.height;
  let hHand = msCollection.hHand;
  let hAvailable = hHand - yBody;
  let wHand = bHand.width;
  let W = wHand;
  let H = hHand;
  let w = msCollection.wCard;
  let h = msCollection.hCard;
  let n = msCollection.numCards;
  let x, y, dx, padding;
  let offset = { x: 0, y: 0 };
  if (msCollection.adjustSize) {
    W = w + (n) * w / 4;
    H = h;
    padding = 0;
    msCollection.setSize(W + 2 * padding + yBody, H);
    x = padding + offset.x;
    y = padding + offset.y;
  } else {
    padding = x = y = 0;
  }
  dx = n > 1 ? (W - w) / (n - 1) : 0;
  if (dx > w) dx = w;
  let i = 0;
  for (const oidCard of msCollection.cards) {
    let id = getMainId(oidCard);
    let c = UIS[id];
    c.zIndex = c.elem.style.zIndex = i;
    i += 1;
    c.setPos(x, y);
    x += dx;
  }
}
function reset_context() { CONTEXT = null; }
function reset_db_values() {
  reset_winnerlist_for_all_games();
  reset_game_values_for_all_users();
}
function reset_elo(user, game) { set_elo(user, game, 100); }
function reset_game_values_for_all_users() { for (const uname in DB.users) { reset_game_values_for_user(uname); } }
function reset_game_values_for_user(user) {
  let defaults = {
    'gul': { gSpotit: { startlevel: 0 }, gMaze: { startlevel: 0 }, gAnagram: { startlevel: 0 } },
    'nasi': { gSpotit: { startlevel: 0 }, gMaze: { startlevel: 0 }, gAnagram: { startlevel: 0 } },
    'felix': { gSpotit: { startlevel: 5 }, gMaze: { startlevel: 5 }, gAnagram: { startlevel: 3 } },
    'lauren': { gSpotit: { startlevel: 5 }, gMaze: { startlevel: 5 }, gAnagram: { startlevel: 5 } },
    'mimi': { gSpotit: { startlevel: 0 }, gMaze: { startlevel: 0 }, gAnagram: { startlevel: 0 } },
  };
  let norm = {};
  for (const g in DB.games) {
    norm[g] = { startlevel: DB.games[g].def_startlevel };
  }
  lookupSetOverride(DB.users, [user, 'games'], valf(defaults[user], norm));
}
function reset_settings() {
  for (const k in settings) { settings[k] = defaults[k]; }
  show_settings();
}
function reset_winnerlist_for_all_games() { for (const gname in DB.games) { reset_winnerlist_for_game(gname); } }
function reset_winnerlist_for_game(game) { lookupSetOverride(DB.games, [game, 'winnerlist'], []); }
function reset_zoom_on_resize() {
  window.onresize = null;
  bodyZoom = 1.0;
  document.body.style.transform = 'none';
}
function resetActiveButton() {
  if (ActiveButton != null) {
    let ba = ActiveButton;
    mStyleX(ba, { bg: 'white', fg: 'black' });
    let caption = ba.id.substring(2);
    caption = separateAtCapitals(caption);
    ba.innerHTML = caption;
    ActiveButton = null;
  } else {
  }
}
function ResetBoard() {
  var index = 0;
  for (index = 0; index < BRD_SQ_NUM; ++index) {
    brd_pieces[index] = SQUARES.OFFBOARD;
  }
  for (index = 0; index < 64; ++index) {
    brd_pieces[SQ120(index)] = PIECES.EMPTY;
  }
  for (index = 0; index < 14 * 120; ++index) {
    brd_pList[index] = PIECES.EMPTY;
  }
  for (index = 0; index < 2; ++index) {
    brd_material[index] = 0;
  }
  for (index = 0; index < 13; ++index) {
    brd_pceNum[index] = 0;
  }
  brd_side = COLOURS.BOTH;
  brd_enPas = SQUARES.NO_SQ;
  brd_fiftyMove = 0;
  brd_ply = 0;
  brd_hisPly = 0;
  brd_castlePerm = 0;
  brd_posKey = 0;
  brd_moveListStart[brd_ply] = 0;
}
function resetPlayerCards() {
  for (const plid in serverData.players) {
    let pl = serverData.players[plid];
    if (GAME == 'catan') pl.devcards = { _set: [] }; else pl.hand = { _set: [] };
  }
}
function resetRound() {
  clearTimeouts();
  clearFleetingMessage();
  clearTable();
}
function resetScore() {
  Score = { gameChange: true, levelChange: true, nTotal: 0, nCorrect: 0, nCorrect1: 0, nPos: 0, nNeg: 0, labels: true };
}
function resetState() {
  clearTimeouts();
  pauseSound();
  onkeydown = null; onkeypress = null; onkeyup = null;
  lastPosition = 0;
  DELAY = 1000;
  setBackgroundColor();
}
function resetUIDs() { UIDCounter = 0; FRUIDCounter = -1; }
function resetUIS() {
  UIS = {};
  IdOwner = {};
  id2oids = {};
  oid2ids = {};
  id2uids = {};
}
function resize() {
  stage.width = canvas.clientWidth
  stage.height = canvas.clientHeight
  canvas.width = stage.width * devicePixelRatio
  canvas.height = stage.height * devicePixelRatio
  crowd.forEach((peep) => {
    peep.walk.kill()
  })
  crowd.length = 0
  availablePeeps.length = 0
  availablePeeps.push(...allPeeps)
  initCrowd()
}
function resizeBoard(nuiBoard, R) {
  let uidBoard = nuiBoard.uid;
  let sz = updateSizes(nuiBoard);
  nuiBoard.params.sizes = sz.sNew;
  let params = nuiBoard.params;
  let gap = params.field_spacing - sz.sOrig.f;
  params.field_spacing = sz.sNew.f + gap;
  for (const name of ['fields', 'edges', 'corners']) {
    let group = nuiBoard.bi[name];
    for (const oid in group) {
      let elSize_old = sz.sOrig[name[0]];
      let elSize = sz.sNew[name[0]];
      if (elSize_old == elSize) { continue; }
      let uid = R.getUidWithParent(oid, uidBoard);
      let n = R.uiNodes[uid];
      let ui = n.ui;
      let info = n.info;
      let shape = n.info.shape;
      n.info.size = elSize;
      n.size = { w: elSize, h: elSize };
      n.sizeMeasured = jsCopy(n.size);
      gSize(ui, elSize, elSize, shape);
      n.typParams.size = n.params.size = elSize;
    }
  }
  gridLayout(nuiBoard, R);
}
function resplay_container(targetgroup, ovpercent) {
  let d = iDiv(targetgroup);
  let card = Items[targetgroup.ids[0]];
  let ov = valf(targetgroup.ov, .1222)
  mContainerSplay(d, 2, card.w, card.h, arrChildren(d).length, ov * card.w);
  let items = arrChildren(d).map(x => Items[x.id]);
  ui_add_cards_to_hand_container(d, items);
}
function rest() {
}
function restart_selection_process() {
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  if (Z.game != 'ferro') {
    console.log('attempt to restart selection process in non-ferro game!!!');
    return;
  }
  A.selectedCards.map(x => ari_make_unselected(x));
  mClear('dSelections0');
  Z.A = { level: 0, di: {}, ll: [], items: [], selected: [], tree: null, breadcrumbs: [], sib: [], command: null };
  Z.stage = 'card_selection';
  ferro_pre_action();
}
async function restartGame() {
  await sendRestart();
  d3.select('button').text('NEXT MOVE').on('click', interaction);
  gameStep();
}
function restartHost(callback) { let route = '/restart'; _sendRouteJS(route, callback); }
function restartQ() {
  QReset();
  console.log('===>RESET', QCounter, Q, AkQ);
}
function restartTime(elem) { TimestampStarted = msNow(); TimeElapsed = 0; startTime(elem); }
function restoreBehaviors() {
  PLAYER_UPDATE = {};
  TABLE_UPDATE = {};
  FUNCS = {};
  PLAYER_CREATE = {};
  TABLE_CREATE = {};
  V = {};
}
function restoreServerData() {
  resetPlayerCards();
  let opt = serverData.options;
  if (opt) {
    let keys = Object.keys(opt);
    let firstKey = keys[0];
    let actions = opt[firstKey].actions._set[0]._tuple[0]._set;
    removedActions.map(x => actions.push(x));
    removedActions = [];
  }
}
function retrieveState(prefix = '') {
  let pack = localStorage.getItem(prefix + '_pack');
  if (isdef(pack)) {
    pack = JSON.parse(pack);
    console.log('retrieved settings (baseColor)', pack.settings.baseColor);
    G.settings = pack.settings;
    Socket.emit('state', pack);
  } else {
    alert(`no settings ${prefix} in localStorage!`);
  }
}
function return_elem_to_deck_from(el, arr, deck) { elem_from_to(el, arr, deck); }
function reveal_church_cards() {
  let [fen, A, uplayer, plorder] = [Z.fen, Z.A, Z.uplayer, Z.plorder];
  let pl = fen.players[uplayer];
  let uichurch = UI.church;
  let dOpenTable = UI.dOpenTable;
  let church_cards = uichurch.items;
  uichurch.container.remove();
  UI.church = uichurch = ui_type_market(fen.church, dOpenTable, { maleft: 25 }, 'church', 'church');
}
function reverse(x) {
  if (isString(x)) {
    var newString = "";
    for (var i = x.length - 1; i >= 0; i--) {
      newString += x[i];
    }
    return newString;
  }
  if (isList(x)) return x.reverse();
  if (isDict(x)) return dict2list(x, 'value').reverse();
  return x;
}
function reverseString(s) {
  return toLetterList(s).reverse().join('');
}
function rFloat(min = -1, max = 1) { return Math.random() * (max - min) + min; }
function rGaussian(min, max, int = false) {
  function rGauss() {
    var rand = 0;
    for (var i = 0; i < 6; i += 1) { rand += Math.random(); }
    return rand / 6;
  }
  return int ? Math.floor(min + rGauss() * (max - min + 1)) : min + rGauss() * (max - min);
}
function rgb2float(rgba) {
  return [
    rgba[0] / 255,
    rgba[1] / 255,
    rgba[2] / 255,
    rgba[3]
  ]
}
function rgb2hex(rgba) {
  var dig, hex = '#';
  for (var i = 0; i < 3; ++i) {
    dig = rgba[i];
    dig = dig.toString(16);
    hex += ('00' + dig).substr(dig.length);
  }
  return hex;
}
function rgb2hsl(r, g, b) {
  (r /= 255), (g /= 255), (b /= 255);
  var max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  var h,
    s,
    l = (max + min) / 2;
  if (max == min) {
    h = s = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return [h, s, l];
}
function rgb2hsv(r, g, b) {
  let v = Math.max(r, g, b);
  let n = v - Math.min(r, g, b);
  let h = n && (v == r ? (g - b) / n : v == g ? 2 + (b - r) / n : 4 + (r - g) / n);
  h = 60 * (h < 0 ? h + 6 : h);
  s = v && n / v;
  return {
    h: h,
    s: s * 100,
    v: (v * 100) / 255
  };
}
function rgbaStr(rgba) {
  return 'rgba(' + rgba.join(',') + ')';
}
function RGBAToHex9(rgba) {
  let n = allNumbers(rgba);
  if (n.length < 3) {
    return randomHexColor();
  }
  let a = n.length > 3 ? n[3] : 1;
  let sa = alphaToHex(a);
  if (rgba.includes('%')) {
    n[0] = Math.round((n[0] * 255) / 100);
    n[1] = Math.round((n[1] * 255) / 100);
    n[2] = Math.round((n[2] * 255) / 100);
  }
  return '#' + ((1 << 24) + (n[0] << 16) + (n[1] << 8) + n[2]).toString(16).slice(1) + sa;
}
function RGBAToHSLA(rgba) {
  let ex = /^rgba\((((((((1?[1-9]?\d)|10\d|(2[0-4]\d)|25[0-5]),\s?)){3})|(((([1-9]?\d(\.\d+)?)|100|(\.\d+))%,\s?){3}))|(((((1?[1-9]?\d)|10\d|(2[0-4]\d)|25[0-5])\s){3})|(((([1-9]?\d(\.\d+)?)|100|(\.\d+))%\s){3}))\/\s)((0?\.\d+)|[01]|(([1-9]?\d(\.\d+)?)|100|(\.\d+))%)\)$/i;
  if (ex.test(rgba)) {
    let sep = rgba.indexOf(',') > -1 ? ',' : ' ';
    rgba = rgba
      .substr(5)
      .split(')')[0]
      .split(sep);
    if (rgba.indexOf('/') > -1) rgba.splice(3, 1);
    for (let R in rgba) {
      let r = rgba[R];
      if (r.indexOf('%') > -1) {
        let p = r.substr(0, r.length - 1) / 100;
        if (R < 3) {
          rgba[R] = Math.round(p * 255);
        }
      }
    }
    let r = rgba[0] / 255,
      g = rgba[1] / 255,
      b = rgba[2] / 255,
      a = rgba[3],
      cmin = Math.min(r, g, b),
      cmax = Math.max(r, g, b),
      delta = cmax - cmin,
      h = 0,
      s = 0,
      l = 0;
    if (delta == 0) h = 0;
    else if (cmax == r) h = ((g - b) / delta) % 6;
    else if (cmax == g) h = (b - r) / delta + 2;
    else h = (r - g) / delta + 4;
    h = Math.round(h * 60);
    if (h < 0) h += 360;
    l = (cmax + cmin) / 2;
    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
    s = +(s * 100).toFixed(1);
    l = +(l * 100).toFixed(1);
    return 'hsla(' + h + ',' + s + '%,' + l + '%,' + a + ')';
  } else {
    return 'Invalid input color';
  }
}
function RGBtoHCV(RGB) {
  let P = RGB.g < RGB.b ? float4(RGB.bg, -1.0, 2.0 / 3.0) : float4(RGB.gb, 0.0, -1.0 / 3.0);
  let Q = RGB.r < P.x ? float4(P.xyw, RGB.r) : float4(RGB.r, P.yzx);
  let C = Q.x - min(Q.w, Q.y);
  let H = abs((Q.w - Q.y) / (6 * C + Epsilon) + Q.z);
  return float3(H, C, Q.x);
}
function rgbToHex(rgbStr) { return rgbStr && '#' + rgbStr.slice(4, -1).split(',').map(x => (+x).toString(16).padStart(2, '0')).join(''); }
function RGBToHex7(c) {
  let n = allNumbers(c);
  if (c.includes('%')) {
    n[0] = Math.round((n[0] * 255) / 100);
    n[1] = Math.round((n[1] * 255) / 100);
    n[2] = Math.round((n[2] * 255) / 100);
  }
  return '#' + ((1 << 24) + (n[0] << 16) + (n[1] << 8) + n[2]).toString(16).slice(1);
}
function RGBToHSL(rgb) {
  let ex = /^rgb\((((((((1?[1-9]?\d)|10\d|(2[0-4]\d)|25[0-5]),\s?)){2}|((((1?[1-9]?\d)|10\d|(2[0-4]\d)|25[0-5])\s)){2})((1?[1-9]?\d)|10\d|(2[0-4]\d)|25[0-5]))|((((([1-9]?\d(\.\d+)?)|100|(\.\d+))%,\s?){2}|((([1-9]?\d(\.\d+)?)|100|(\.\d+))%\s){2})(([1-9]?\d(\.\d+)?)|100|(\.\d+))%))\)$/i;
  if (ex.test(rgb)) {
    let sep = rgb.indexOf(',') > -1 ? ',' : ' ';
    rgb = rgb
      .substr(4)
      .split(')')[0]
      .split(sep);
    for (let R in rgb) {
      let r = rgb[R];
      if (r.indexOf('%') > -1) rgb[R] = Math.round((r.substr(0, r.length - 1) / 100) * 255);
    }
    let r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      cmin = Math.min(r, g, b),
      cmax = Math.max(r, g, b),
      delta = cmax - cmin,
      h = 0,
      s = 0,
      l = 0;
    if (delta == 0) h = 0;
    else if (cmax == r) h = ((g - b) / delta) % 6;
    else if (cmax == g) h = (b - r) / delta + 2;
    else h = (r - g) / delta + 4;
    h = Math.round(h * 60);
    if (h < 0) h += 360;
    l = (cmax + cmin) / 2;
    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
    s = +(s * 100).toFixed(1);
    l = +(l * 100).toFixed(1);
    return 'hsl(' + h + ',' + s + '%,' + l + '%)';
  } else {
    return 'Invalid input color';
  }
}
function rgbToHsl(r, g, b) {
  (r /= 255), (g /= 255), (b /= 255);
  var max = Math.max(r, g, b),
    min = Math.min(r, g, b);
  var h,
    s,
    l = (max + min) / 2;
  if (max == min) {
    h = s = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return [h, s, l];
}
function rgbToHsv(r, g, b) {
  let v = Math.max(r, g, b);
  let n = v - Math.min(r, g, b);
  let h = n && (v == r ? (g - b) / n : v == g ? 2 + (b - r) / n : 4 + (r - g) / n);
  h = 60 * (h < 0 ? h + 6 : h);
  s = v && n / v;
  return {
    h: h,
    s: s * 100,
    v: (v * 100) / 255
  };
}
function Rgen(R, cycle) {
  if (cycle > 10) { console.log('MAX!!!!!!!!!'); return; }
  let workingSpec = jsCopy(R.lastSpec);
  RgenIdRef(R);
  RgenArrays(R);
  let name = RsortIds(workingSpec, R);
  let genKey = 'G';
  R.gens[genKey].push(workingSpec);
  R.lastSpec = workingSpec;
  R.ROOT = R.lastSpec.ROOT;
  if (name && !isEmpty(R.allIdRefNames)) Rgen(R, cycle + 1);
}
function RgenArrays(R) {
  R.idarr = [];
  R.refarr = [];
  for (const name in R.places) {
    let idByName = R.places[name];
    for (const spk in idByName) {
      let placelist = idByName[spk];
      for (const el of placelist) {
        R.idarr.push(el);
      }
    }
  }
  for (const name in R.refs) {
    let refByName = R.refs[name];
    for (const spk in refByName) {
      let refslist = refByName[spk];
      for (const el of refslist) {
        R.refarr.push(el);
      }
    }
  }
  R.idByNode = {};
  R.idByName = {};
  for (const name in R.places) {
    let idByName = R.places[name];
    for (const spk in idByName) {
      let list = idByName[spk];
      for (const el of list) {
        lookupAddToList(R.idByNode, [spk], el);
        lookupAddToList(R.idByName, [name], el);
      }
    }
  }
  R.refByNode = {};
  R.refByName = {};
  for (const name in R.refs) {
    let refByName = R.refs[name];
    for (const spk in refByName) {
      let list = refByName[spk];
      for (const el of list) {
        lookupAddToList(R.refByNode, [spk], el);
        lookupAddToList(R.refByName, [name], el);
      }
    }
  }
  for (const id of R.idarr) {
  }
  if (nundef(R.allIdRefNames)) R.allIdRefNames = intersection(Object.keys(R.idByName), Object.keys(R.refByName));
}
function RgenIdRef(R, genKey = 'G') {
  let gen = R.lastSpec;
  if (nundef(R.orig_places) && !isEmpty(R.places)) R.orig_places = R.places;
  if (nundef(R.orig_refs) && !isEmpty(R.refs)) R.orig_refs = R.refs;
  R.places = {};
  R.refs = {};
  for (const k in gen) {
    let n = gen[k];
    R.check_ref(k, n);
  }
  for (const k in gen) {
    let n = gen[k];
    R.check_id(k, n, R);
  }
}
function rHue() { return (rNumber(0, 36) * 10) % 360; }
function rInc(o, prop, min, max) { o[prop] += rNumber(min, max); return o[prop]; }
function rLetter(except) { return rLetters(1, except)[0]; }
function rLetters(n, except = []) {
  let all = 'abcdefghijklmnopqrstuvwxyz';
  for (const l of except) all = all.replace(l, '');
  console.log('all', all, except)
  return rChoose(toLetters(all), n);
}
function rMappings() {
  mappings = SPEC.mappings;
  if (nundef(mappings)) return false;
  let lst = odict2olist(mappings);
  console.log('_______________', mappings, lst);
  mappings = odict2olist(mappings).map(x => { let k = stringBefore(x.id, '.'); mappingTypes[k] = x[k] = true; return x; });
  console.log('mappings', mappings, mappingTypes);
}
function rMergeSpec() {
  SPEC = deepmerge(defaultSpec, userSpec, { arrayMerge: overwriteMerge });
  if (userSpec.layout_alias) { SPEC.areas = userSpec.layout_alias; }
  if (userSpec.areas) { SPEC.areas = userSpec.areas; }
  delete SPEC.layout_alias;
  delete SPEC.asText;
  if (SHOW_SPEC) mById('SPEC').innerHTML = '<pre>"' + jsonToYaml(SPEC) + '"</pre>';
  _initAutoplayToActionButtons();
  _initCheatButtons();
  _initScenarioButtons();
}
function rName(n = 1) { let arr = MyNames; return rChoose(arr, n); }
function rNoise(channel, min, max, speed = 0.02) {
  if (nundef(Perlin.channels[channel])) Perlin.channels[channel] = rNumber(0, 10000);
  let lastx = Perlin.channels[channel];
  if (nundef(speed)) speed = Perlin.speed;
  lastx += speed;
  Perlin.channels[channel] = lastx;
  let r01 = rPerlin(lastx);
  let n = map_range(r01, 0, 1, min, max);
  return n;
}
function rnPosition(o, speed) {
  let [xoff, yoff] = isdef(o.origin) ? [-o.origin.x, -o.origin.y] : [0, 0];
  return [o.x, o.y] = [rNoise('x', 0, o.w, speed) + xoff, rNoise('y', 0, o.h, speed) + yoff];
}
function rNumber(min = 0, max = 100) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function robbedDescInBoats() {
  for (const id of IdOwner.a) {
    let boat = UIS[id];
    let desc = boat.desc;
    if (desc == 'robbed') {
      console.log('skip robbed!');
      return true;
    }
  }
  return false;
}
function rollback() {
  if (isdef(DA.snapshot)) {
    Z.fen = DA.snapshot.fen;
    Z.stage = DA.snapshot.stage;
    Z.round = DA.snapshot.round;
    Z.phase = DA.snapshot.phase;
    Z.turn = DA.snapshot.turn;
  }
}
function roomAdjacency(house) {
  let rooms = house.rooms.map(x => Items[x]);
  for (let i = 0; i < rooms.length; i++) {
    for (let j = i + 1; j < rooms.length; j++) {
      let [r1, r2] = [rooms[i], rooms[j]];
      let [e1, e2] = [r1.rect, r2.rect];
      let rhoeher = e1.t < e2.t ? r1 : r2;
      let rleft = e1.x < e2.x ? r1 : r2;
      let rniedriger = (rhoeher == r1 ? r2 : r1);
      let rright = (rleft == r1 ? r2 : r1);
      let diff = 2 * house.wallWidth;
      let y1 = Math.max(e1.t, e2.t);
      let y2 = Math.min(e1.b, e2.b);
      let dCommony = y2 - y1;
      if (dCommony > diff && isCloseTo(rright.rect.l, rleft.rect.r)) {
        let dr = {
          x: rleft.rect.r - house.rect.l,
          y: rniedriger.rect.t - house.rect.t,
          w: rright.rect.l - rleft.rect.r,
          h: dCommony,
        };
        extendRect(dr);
        addAdjacencyFromTo(rleft, rright, 'e', dr);
      }
      let x1 = Math.max(e1.l, e2.l);
      let x2 = Math.min(e1.r, e2.r);
      let dCommonx = x2 - x1;
      if (dCommonx > diff && isCloseTo(rniedriger.rect.t, rhoeher.rect.b)) {
        let dr = {
          x: rright.rect.l - house.rect.l,
          y: rhoeher.rect.b - house.rect.t,
          w: dCommonx,
          h: house.wallWidth
        };
        extendRect(dr);
        addAdjacencyFromTo(rhoeher, rniedriger, 's', dr);
      }
    }
  }
  for (let i = 0; i < rooms.length; i++) {
    let r = rooms[i];
    if (isCloseTo(r.rect.l, house.rect.l)) {
      let wallRect = { x: house.rect.l, y: r.rect.t, w: house.wallWidth, h: r.rect.h };
      extendRect(wallRect);
      addAdjacencyFromTo(r, null, 'w', wallRect);
    }
    if (isCloseTo(r.rect.r, house.rect.r)) {
      let wallRect = { x: r.rect.r, y: r.rect.t, w: house.wallWidth, h: r.rect.h };
      extendRect(wallRect);
      addAdjacencyFromTo(r, null, 'e', wallRect);
    }
    if (isCloseTo(r.rect.t, house.rect.t)) {
      let wallRect = { x: r.rect.l, y: house.rect.t, w: r.rect.w, h: house.wallWidth };
      extendRect(wallRect);
      addAdjacencyFromTo(r, null, 'n', wallRect);
    }
    if (isCloseTo(r.rect.b, house.rect.b)) {
      let wallRect = { x: r.rect.l, y: r.rect.b, w: r.rect.w, h: house.wallWidth };
      extendRect(wallRect);
      addAdjacencyFromTo(r, null, 's', wallRect);
    }
  }
}
function root(areaName) {
  setTableSize(areaName, 400, 300);
  UIROOT = jsCopy(SPEC.staticSpec.root);
  for (const k in AREAS) delete AREAS[k];
  PROTO = {};
  INFO = {};
  staticArea(areaName, UIROOT);
  addAREA('root', UIROOT);
}
function round_change_animation(n = 2) {
  let [stage, A, fen, plorder, uplayer, deck] = [Z.stage, Z.A, Z.fen, Z.plorder, Z.uplayer, Z.deck];
  let pl = fen.players[uplayer];
  if (pl.roundchange) {
    let d = mBy('dTitleLeft');
    mStyle(d, { 'transform-origin': '0% 0%' });
    mPulse(d, n * 1000);
    show_special_message(`${fen.round_winner} won round ${Z.round - 1}!!!`)
    delete pl.roundchange;
  }
}
function roundEven(n) {
  let res = Math.round(n);
  return res % 2 != 0 ? res - 1 : res;
}
function roundNumber(x, n) { return x.toFixed(n); }
async function route_allGames() {
  let gameNames = await route_server_js('/game/available');
  let res = {};
  for (const name of gameNames) {
    if (USE_ALL_GAMES_ROUTE) {
      res[name] = await route_server_js('/game/info/' + name);
    } else {
      let url = '/games/' + name + '/info.yaml';
      res[name] = await route_path_yaml_dict(url);
    }
  }
  return res;
}
async function route_begin_status(username, seed = SEED) {
  await fetch_wrapper(SERVER + '/begin/' + seed);
  let data = await route_status(username);
  return data;
}
async function route_c52() {
  return await route_rsg_asset('c52_blackBorder', 'yaml');
}
async function route_iconChars() {
  let gaIcons = await route_rsg_asset('gameIconCodes');
  let faIcons = await route_rsg_asset('faIconCodes');
  let dIcons = {};
  for (const k in faIcons) {
    dIcons[k] = faIcons[k];
  }
  for (const k in gaIcons) {
    dIcons[k] = gaIcons[k];
  }
  return dIcons;
}
async function route_initGame(game, gc, username, seed = SEED) {
  await fetch_wrapper(SERVER + '/restart');
  await fetch_wrapper(SERVER + '/game/select/' + game);
  let nPlayers = gc.numPlayers;
  for (plid in gc.players) {
    let plInfo = gc.players[plid];
    let isAI = plInfo.agentType !== null;
    if (isAI) {
      await postData(SERVER + '/add/client/agent/' + plInfo.username, { agent_type: plInfo.agentType, timeout: null });
    }
    await fetch_wrapper(SERVER + '/add/player/' + plInfo.username + '/' + plInfo);
  }
  return await route_begin_status(username, seed);
}
async function route_path_asText_dict(url) {
  let data = await fetch_wrapper(url);
  let res = {};
  res.asText = await data.text();
  return res;
}
async function route_path_json(url) {
  let data = await fetch(url);
  let o = await data.json();
  return o;
}
async function route_path_json_dict(url) {
  let data = await fetch_wrapper(url);
  let json = await data.json();
  return json;
}
async function route_path_text(url) {
  let data = await fetch(url);
  let text = await data.text();
  return text;
}
async function route_path_yaml_dict(url) {
  let data = await fetch(url);
  let text = await data.text();
  let dict = jsyaml.load(text);
  return dict;
}
function route_post_json(url, o, callback) { post_json(url, o, callback); }
async function route_rsg_asset(filename, ext = 'yml') {
  let url = '/assets/' + filename + '.' + ext;
  let response = await route_path_yaml_dict(url);
  return response;
}
async function route_rsg_raw_asset(filename, ext = 'yml') {
  let url = '/assets/raw/' + filename + '.' + ext;
  let response = await route_path_yaml_dict(url);
  return response;
}
async function route_server(url) { await fetch_wrapper(SERVER + url); }
async function route_server_js(url) {
  let data = await fetch_wrapper(SERVER + url);
  return await data.json();
}
async function route_server_text(url) {
  let data = await fetch_wrapper(SERVER + url);
  let text = await data.text();
  return text;
}
async function route_status(username) { return await route_server_js('/status/' + username); }
async function route_svgDict(filename = 'svgDict') {
  let url = '/assets/' + filename + '.yaml';
  let response = await route_path_yaml_dict(url);
  return response;
}
async function route_symbolDict(filename = 'symbolDict') {
  let url = '/assets/' + filename + '.yaml';
  let response = await route_path_yaml_dict(url);
  return response;
}
async function route_test_userSpec(url) {
  try {
    let text = await route_path_text(url);
    let spec = jsyaml.load(text);
    spec.asText = text;
    return spec;
  } catch (error) {
    return { asText: '' };
  }
}
async function route_userCode(game, fname) {
  try {
    let url = '/RSG/' + game + (isdef(fname) ? '/' + fname : '');
    let text = await route_server_text(url);
    return { asText: text };
  } catch (error) { return {}; }
}
async function route_userSpec(game, fname) {
  try {
    let url = '/spec/' + game + (isdef(fname) ? '/' + fname : '');
    let text = await route_server_text(url);
    let spec = jsyaml.load(text);
    spec.asText = text;
    return spec;
  } catch (error) {
    return { asText: '' };
  }
}
async function rParse(source, context) {
  R = await generateTree(source, context);
  timit.show('present');
  await presentTree(R.root, R);
  showSetSizes(R.root, R);
  adjustTableSize(R);
  if (ACTIVATE_UI) {
    activateUis(R);
  }
  timit.show('done!')
  updateOutput(R);
  if (source == 'main') testEngine.verify(R);
}
function rPassword(n) { return rChoose(toLetters('0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!.?*&%$#@:;_'), n).join(''); }
function rPerlin(x, y = 0, z = 0) {
  Perlin.lastx = x;
  if (Perlin.perlin == null) {
    Perlin.perlin = new Array(Perlin.PERLIN_SIZE + 1);
    for (let i = 0; i < Perlin.PERLIN_SIZE + 1; i++) {
      Perlin.perlin[i] = Math.random();
    }
  }
  if (x < 0) { x = -x; }
  if (y < 0) { y = -y; }
  if (z < 0) { z = -z; }
  let xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);
  let xf = x - xi;
  let yf = y - yi;
  let zf = z - zi;
  let rxf, ryf;
  let r = 0;
  let ampl = 0.5;
  let n1, n2, n3;
  for (let o = 0; o < Perlin.perlin_octaves; o++) {
    let of = xi + (yi << Perlin.PERLIN_YWRAPB) + (zi << Perlin.PERLIN_ZWRAPB);
    rxf = Perlin.scaled_cosine(xf);
    ryf = Perlin.scaled_cosine(yf);
    n1 = Perlin.perlin[of & Perlin.PERLIN_SIZE];
    n1 += rxf * (Perlin.perlin[(of + 1) & Perlin.PERLIN_SIZE] - n1);
    n2 = Perlin.perlin[(of + Perlin.PERLIN_YWRAP) & Perlin.PERLIN_SIZE];
    n2 += rxf * (Perlin.perlin[(of + Perlin.PERLIN_YWRAP + 1) & Perlin.PERLIN_SIZE] - n2);
    n1 += ryf * (n2 - n1);
    of += Perlin.PERLIN_ZWRAP;
    n2 = Perlin.perlin[of & Perlin.PERLIN_SIZE];
    n2 += rxf * (Perlin.perlin[(of + 1) & Perlin.PERLIN_SIZE] - n2);
    n3 = Perlin.perlin[(of + Perlin.PERLIN_YWRAP) & Perlin.PERLIN_SIZE];
    n3 += rxf * (Perlin.perlin[(of + Perlin.PERLIN_YWRAP + 1) & Perlin.PERLIN_SIZE] - n3);
    n2 += ryf * (n3 - n2);
    n1 += Perlin.scaled_cosine(zf) * (n2 - n1);
    r += n1 * ampl;
    ampl *= Perlin.perlin_amp_falloff;
    xi <<= 1;
    xf *= 2;
    yi <<= 1;
    yf *= 2;
    zi <<= 1;
    zf *= 2;
    if (xf >= 1.0) { xi++; xf--; }
    if (yf >= 1.0) { yi++; yf--; }
    if (zf >= 1.0) { zi++; zf--; }
  }
  return r;
};
function rPlayerOrder(players) { return shuffle(jsCopy(players)); }
function rPlayerStatsAreas() {
  if (nundef(serverData.players)) return;
  if (nundef(SPEC.playerStatsAreas)) return;
  let loc = SPEC.playerStatsAreas.loc;
  let dOthers = mById(loc);
  if (nundef(dOthers)) return;
  let func = SPEC.playerStatsAreas.type;
  let objects = [];
  for (const plid in serverData.players) {
    let o = serverData.players[plid];
    if (plid != GAMEPLID) {
      o.id = plid;
      objects.push(o)
    }
  }
  let areaNames = objects.map(x => x.name);
  let structObject = window[func](areaNames, loc);
}
function rPosition(o) {
  let [xoff, yoff] = isdef(o.origin) ? [-o.origin.x, -o.origin.y] : [0, 0];
  return [o.x, o.y] = [rNumber(0, o.w) + xoff, rNumber(0, o.h) + yoff];
}
function rPresentDefault() {
  for (const kPool of ['table', 'players']) {
    let pool = serverData[kPool];
    let isTable = kPool == 'table';
    for (const oid in pool) {
      let o = pool[oid];
      let otype = o.obj_type;
      let mk = getVisual(oid);
      let mkDefault = getDefaultVisual(oid);
      if (!mk) {
        if ('loc' in o && SPEC.useLocPropertyForPlacement) mk = makeMainBoardElementVisual(oid, o);
      }
      if (!mk && !mkDefault && SPEC.table && SPEC.table.createDefault != false) {
        let loc = SPEC[kPool] && SPEC[kPool].defaultArea ? SPEC[kPool].defaultArea : 'a_d_objects';
        mkDefault = makeDefaultObject(oid, o, loc);
      }
      if (mkMan.getDone(oid)) continue;
      if (mk) {
        if (o.loc && SPEC.useLocPropertyForPlacement) _presentLocationChange(oid, o, mk, isTable);
        if (otype in mappingTypes && SPEC.ignoreStructureTypesInPresentation) continue;
        presentMain(oid, o, mk);
      }
      if (mkDefault) {
        presentDefault(oid, o, mkDefault, isTable);
      }
    }
  }
}
function rPresentMappings() {
  if (isdef(serverData.players)) {
    presentMappings(GAMEPLID, serverData.players[GAMEPLID]);
  }
  for (const plid in serverData.players) {
    if (plid != GAMEPLID) presentMappings(plid, serverData.players[plid]);
  }
  for (const oid in serverData.table) { presentMappings(oid, serverData.table[oid]); }
}
function rPrimaryColor() { let c = '#' + rChoose(['ff', '00']) + rChoose(['ff', '00']); c += c == '#0000' ? 'ff' : c == '#ffff' ? '00' : rChoose(['ff', '00']); return c; }
function rRank(ranks = 'A23456789TJQK') { return rChoose(ranks); }
function rrto(r1, r2) {
  let r = jsCopy(r1);
  r.x -= r2.x; r.l -= r2.x; r.r -= r2.x;
  r.y -= r2.y; r.t -= r2.y; r.b -= r2.y;
  return r;
}
function RsortIds(workingSpec, R) {
  let hasid = {};
  let noid = {};
  let cycles1 = 0; let max1 = 2;
  let cycles2 = 0; let max2 = 2;
  for (const name in R.idByName) {
    let reflist = R.refByName[name];
    for (const ref of reflist) {
      let nref = ref.node;
      let akku = {};
      recFindProp(nref, '_id', 'self', akku);
      if (isEmpty(akku)) {
        ref.hasid = false;
        if (nundef(noid[name])) noid[name] = [];
        noid[name].push(ref);
      } else {
        ref.hasid = true;
        ref.idOccurrences = jsCopy(akku);
        if (nundef(hasid[name])) hasid[name] = []; hasid[name].push(ref);
      }
    }
  }
  if (isEmpty(noid)) {
    return null;
  } else {
    let name = Object.keys(noid)[0];
    let newSpecUids = replaceIdName(name, R, workingSpec);
    if (nundef(R.namesReplaced)) R.namesReplaced = [];
    R.namesReplaced.push(name);
    removeInPlace(R.allIdRefNames, name);
    return name;
  }
  return null;
}
function rSuit(suit = 'HSDC') { return rChoose(suit); }
function rumor_playerdata_complete() {
  for (const pldata of Z.playerdata) {
    if (isEmpty(pldata.state) || !isEmpty(pldata.state.remaining)) return false;
  }
  return true;
}
function rumor_update_playerdata(data, receiver, rumor) {
  let remaining = arrMinus(data.state.remaining, rumor.key);
  lookupAddToList(data, ['state', 'di', receiver], rumor.key);
  lookupAddToList(data, ['state', 'receivers'], receiver);
  lookupSetOverride(data, ['state', 'remaining'], remaining);
  Z.state = data.state;
}
function run_for_seconds(secs, f, interval = 50) {
  DA.start = get_now(); doit(secs, f, interval);
}
function run03(sp, defaults, sdata) {
  R = new RSG(sp, defaults, sdata);
  console.log('before gen10 habe', R.gens.G.length, R.getSpec());
  phase = 1013;
  R.gen10();
  R.gen11();
  R.gen12();
  R.gen13();
  phase = 14;
  R.gen14();
  phase = 21;
  R.gen21('table');
  presentRoot_dep(R.getSpec().ROOT, 'tree');
}
function run04(sp, defaults, sdata) {
  WR.G = R1 = new RSG(sp, defaults, sdata);
  genG('table', R1);
  setTimeout(() => binding01(WR.G), 500);
}
function run05(sp, defaults, sdata) {
  WR.inc = R = new RSG(sp, defaults, sdata);
  ensureRtree(R);
  generateUis('table', R);
  updateOutput(R);
}
function run06(sp, defaults, sdata) {
  WR.inc = T = R = new RSG(sp, defaults, sdata);
  ensureRtree(R);
  R.baseArea = 'table';
  createStaticUi(R.baseArea, R);
  updateOutput(R);
  addNewlyCreatedServerObjects(sdata, R);
  updateOutput(R);
  for (let i = 0; i < 5; i++) testAddObject(R);
  updateOutput(R);
  activateUis(R);
}
function run07() {
  let d = mDiv(mBy('table'));
  mSize(d, 400, 300);
  mColor(d, 'blue');
  let canvas = aSvgg(d);
  let svg = d.children[0];
  console.log('svg', svg);
  createfilter(svg, "-50%", "-50%", "200%", "200%", ["feGaussianBlur"], ["stdDeviation", "5"]);
  let g1 = agShape(canvas, 'circle', 50, 50, 'gold');
  let ci = g1.children[0];
  console.log(ci);
  addClass(d, 'blur')
}
function run08() {
  let d = mDiv(mBy('table'));
  mSize(d, 400, 300);
  mColor(d, 'blue');
  let canvas = aSvgg(d);
  let svg = d.children[0];
  // var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  let g1 = agShape(canvas, 'rect', 250, 250, 'gold');
  let text = agText(g1, 'hallo', 'black', '16px AlgerianRegular').elem;
  let ci = g1.children[0];
  // var obj = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  var defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
  var filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
  filter.setAttribute("id", "f1");
  var gaussianFilter = document.createElementNS("http://www.w3.org/2000/svg", "feGaussianBlur");
  gaussianFilter.setAttribute("stdDeviation", "2");
  filter.appendChild(gaussianFilter);
  defs.appendChild(filter);
  svg.appendChild(defs);
  text.setAttribute("filter", "url(#f1)");
}
function run09() {
  let paper = mDivG('table', 400, 300, 'blue');
  let svg = paper.parentNode;
  let u = `<use x="100" y="100" xlink:href="assets/svg/animals.svg#bird" />`;
  console.log(svg);
  return;
  let g = agShape(canvas, 'rect', 250, 250, 'gold');
}
function runAllTests() {
  iTEST = 0;
  startTestLoop();
}
function runAllTestSeries() {
  iTEST = 0;
  iTESTSERIES = 1;
  startTestSeries();
}
function runBEHAVIOR(oid, pool, behList, VisList) {
  let res = {};
  for (const functionPair of behList) {
    let doFilterFunc = functionPair[0];
    let doFunc = functionPair[1];
    let o = pool[oid];
    if (nundef(o) || !doFilterFunc(oid, o)) {
      continue;
    }
    for (const functionPair of VisList) {
      let visFilterFunc = functionPair[0];
      let visFunc = functionPair[1];
      console.log(o);
      if (visFilterFunc(oid, o)) {
        let params = doFunc(oid, o);
        visFunc(oid, o, ...params);
        for (const par of params) {
          if (isDict(par) && 'id' in par) res[par.id] = par;
        }
      }
    }
  }
  return res;
}
function runBEHAVIOR_new(oid, pool, behaviors) {
  let res = {};
  for (const name in behaviors) {
    let o = pool[oid];
    let todo = behaviors[name](oid, o, G.serverData.phase);
    if (isdef(todo)) {
      let params = isdef(todo.vis) ? todo.vis.map(x => getVisual(x)) : [];
      for (const vis of params) clearElement(vis.elem);
      let res = todo.f(oid, o, ...params);
    }
  }
  return res;
}
function runBehaviors(oid, pool, behaviors) {
  let res = [];
  for (const name in behaviors) {
    let o = pool[oid];
    let todo = behaviors[name](oid, o, G.serverData.phase);
    if (isdef(todo)) {
      let visualsToBeUpdated = isdef(todo.vis) ? todo.vis.map(x => getVisual(x)) : [];
      let updated = FUNCS[todo.f](oid, o, ...visualsToBeUpdated);
      if (updated) res.push(oid);
    }
  }
  return res;
}
function runBindings(oid, pool) {
  for (const k in BINDINGS) {
  }
}
function runClientTest() {
  imageFileTests();
}
function runcode(code, callback = null) {
  let x = eval(code);
  if (callback) callback(x);
  else {
    console.log('===>result:', x);
    if (isdef(dMessage)) dMessage.innerHTML = isDict(x) ? JSON.stringify(x) : isdef(x) ? x.toString() : x;
  }
}
function runderkreis(color, id) {
  return `<div id=${id} style='width:20px;height:20px;border-radius:50%;background-color:${color};color:white;position:absolute;left:0px;top:0px;'>` + '' + "</div>";
}
function rUniqueId(n) { return rChoose(toLetters('0123456789abcdefghijklmnopqABCDEFGHIJKLMNOPQRSTUVWXYZ_'), n).join(''); }
async function runNextSeries(listSeries, series, from, to) {
  let timeOUT = 500;
  if (isEmpty(listSeries)) {
    console.log('*** ALL TESTS COMPLETED! ***');
    hide('btnStop');
    isTraceOn = SHOW_TRACE;
    return;
  } else if (STOP) {
    STOP = false;
    isTraceOn = SHOW_TRACE;
    hide('btnStop');
    return;
  } else if (from >= to) {
    let series = testEngine.series;
    removeInPlace(listSeries, series);
    if (isEmpty(listSeries)) {
      console.log('*** ALL TESTS COMPLETED! ***');
      STOP = false;
      isTraceOn = SHOW_TRACE;
      hide('btnStop');
      return;
    }
    series = listSeries[0];
    let imax = await testEngine.loadSeries(series);
    setTimeout(async () => { await runNextSeries(listSeries, series, 0, imax); }, timeOUT * 2);
  } else {
    let series = listSeries[0];
    let index = from;
    await testEngine.loadTestCase(series, index);
    await rParse(RSG_SOURCE, { defs: testEngine.defs, spec: testEngine.spec, sdata: testEngine.sdata });
    setTimeout(async () => { await runNextSeries(listSeries, series, from + 1, to); }, timeOUT);
  }
}
function runTest() {
  editLayoutTests();
}
function runToDevdeckAction() { onClickRunToAction('devdeck'); }
function rVowel(w, except = []) { let vowels = w ? getVowels(w, except) : toLetters('aeiouy'); return chooseRandom(vowels); }
function rWheel(n = 1, hue = null, sat = 100, bri = 50) {
  let d = 360 / n;
  let h = valf(hue, rHue());
  let arr = [];
  for (let i = 0; i < n; i++) {
    console.log('h', h)
    let r = colorFromHSL(h, sat, bri);
    h = (h + d) % 360;
    arr.push(r);
  }
  return arr;
}
function safeLoop(func, params) {
  let max = 100, i = 0;
  while (i < max) {
    i += 1;
    let res = func(...params);
    if (isdef(res)) return res;
  }
  console.log('safeLoop: max reached!!!!!!!!!');
  return null;
}
function safeMerge(a, b) {
  if (nundef(a) && nundef(b)) return {};
  else if (nundef(a)) return jsCopy(b);
  else if (nundef(b)) return jsCopy(a);
  else return mergeOverrideArrays(a, b);
}
function safeRecurse(o, func, params, tailrec) {
  ___enteredRecursion = 0;
  let arr = Array.from(arguments);
  arr = arr.slice(1);
  recAllNodes(o, func, params, tailrec, true);
  return ___enteredRecursion;
}
function sameCaseIn(s1, s2) {
  return s1.toLowerCase() == s2.toLowerCase();
}
function sameCaseIndep(s1, s2) {
  return s1.toLowerCase() == s2.toLowerCase();
}
function sameCaseInsensitive(s1, s2) {
  return s1.toLowerCase() == s2.toLowerCase();
}
function sameList(l1, l2) {
  if (l1.length != l2.length) return false;
  for (const s of l1) {
    if (!l2.includes(s)) return false;
  }
  return true;
}
function sameProps(o1, o2) {
  let diff = propDiffGSM(o1, o2);
  return !diff.hasChanged;
}
function sameStringify(o1, o2) {
  return JSON.stringify(o1) == JSON.stringify(o2);
}
function sat() {
  let R = T;
  let rtree = normalizeRTree(R);
  let sol = {};
  sol[testEngine.index] = rtree;
  downloadFile(sol, 'sol' + testEngine.index);
}
function satall() { testEngine.saveSolutions(); }
function save_all() {
  let data = [];
  for (const edit of DA.edits) {
    let rect = getRect(edit);
    let text = edit.innerHTML;
    let o = { x: rect.x, y: rect.y, text: text };
    data.push(o);
  }
  route_post_json('http://localhost:3000/post/json', { data: data, filename: 'page' }, response => {
  });
}
function save_image_at_server(id, uploadFilename) {
  if (nundef(uploadFilename)) uploadFilename = 'baustellenimage';
  window.scrollTo(0, 0);
  html2canvas(document.getElementById(id)).then(function (canvas) {
    let imgData = canvas.toDataURL("image/jpeg", 0.9);
    var ajax = new XMLHttpRequest();
    ajax.open("POST", "server/save_url_encoded_image.php", true);
    ajax.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    ajax.send("image=" + canvas.toDataURL("image/jpeg", 0.9) + "&filename=" + uploadFilename + ".jpg");
    ajax.onreadystatechange = function () {
      if (this.readyState == 4 && this.status == 200) {
        let udata = get_current_userdata();
        if (!udata.image) { udata.image = true; db_save(); }
        get_login();
      }
    };
  });
}
function save_users(db_dirty = true) {
  if (isdef(G)) U.lastGame = G.id;
  if (!startsWith(Session.cur_user, 'test')) localStorage.setItem('user', Session.cur_user);
  DB.users[Session.cur_user] = U;
  if (db_dirty) db_save();
}
function saveAnswerStatistic() {
  let g = CurrentGameData;
  let items = last(g.levels).items;
  console.log(items);
  let correctAnswers = items.filter(x => x.isCorrect && x.answer == x.reqAnswer);
  console.log('correctAnswers', correctAnswers)
  let saveable = correctAnswers.map(x => {
    console.log(x); return { key: x.key, reqAnswer: x.reqAnswer, answer: x.answer };
  });
  saveable.map(x => console.log('correct:', x.key, x.reqAnswer, x.answer));
  downloadAsYaml({ correct: saveable }, 'CORRECT');
}
function saveEnv() {
  fiddleSave();
}
function saveFile(name, type, data) {
  if (data != null && navigator.msSaveBlob) return navigator.msSaveBlob(new Blob([data], { type: type }), name);
  var a = $("<a style='display: none;'/>");
  var url = window.URL.createObjectURL(new Blob([data], { type: type }));
  a.attr('href', url);
  a.attr('download', name);
  $('body').append(a);
  a[0].click();
  setTimeout(function () {
    window.URL.revokeObjectURL(url);
    a.remove();
  }, 500);
}
function saveFileAtClient(name, type, data) {
  if (data != null && navigator.msSaveBlob) return navigator.msSaveBlob(new Blob([data], { type: type }), name);
  let a = document.createElement('a');
  a.style.display = 'none';
  let url = window.URL.createObjectURL(new Blob([data], { type: type }));
  a.href = url;
  a.download = name;
  document.body.appendChild(a);
  simulateClick(a);
  setTimeout(function () {
    window.URL.revokeObjectURL(url);
    a.remove();
  }, 500);
}
function saveGame() { }
function saveJsonAtServer(jsonObject, filename) {
  event.preventDefault();
  var labels = ['hallo', 'das', 'ist'];
  $.ajax({
    url: '/postTest',
    type: 'POST',
    data: JSON.stringify(jsonObject),
    processData: false,
    contentType: 'application/json; charset=UTF-8',
    success: function (response) {
      testHelpers(response);
    },
    error: function (error) {
      testHelpers(error);
    }
  });
}
function saveListOfWords() {
  let phrases = Object.keys(DD);
  phrases.sort();
  let text = phrases.join('\n');
  downloadAsText(text, 'listOfWords');
}
function saveObject(o, name) { localStorage.setItem(name, JSON.stringify(o)); }
function saveSettings() {
}
async function saveSIMA() {
  if (BlockServerSend) {
    setTimeout(saveSIMA, 1000);
  } else {
    let url = SERVERURL + 'speechGames';
    BlockServerSend = true;
    fetch(url, {
      method: 'PUT',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(DB)
    }).then(() => { BlockServerSend = false; });
  }
}
async function saveSolutions(series, solutions) {
  let keys = Object.keys(solutions);
  let n = firstNumber(keys[0]);
  keys.sort(x => Number(x)).reverse();
  let sortedObject = {};
  for (const k of keys) {
    let x = sortKeys(solutions[k]);
    sortedObject[' ' + k + ' '] = x;
  }
  downloadFile(sortedObject, 'solutions' + series);
}
function saveState(prefix = '') {
  let st = G.state;
  let state = { boardArr: st.boardArr, poolArr: st.poolArr, pool: {} };
  for (const k in st.pool) {
    let oNew = state.pool[k] = {};
    copyKeys(st.pool[k], oNew, {}, ['index', 'key']);
  }
  let pack = { settings: G.settings, state: state, randomIndices: G.randomIndices };
  localStorage.setItem(prefix + '_pack', JSON.stringify(pack));
  return pack;
}
function saveStateAndSettings() {
  onClickSaveState();
  console.assert(BaseColor == G.settings.baseColor, 'Colors do NOT match at saving state!!!')
  onClickSaveSettings();
}
function saveStats() {
  let g = lastCond(CurrentSessionData.games, x => x.name == 'gSayPicAuto');
  let xxx = last(g.levels).items
  let yyy = xxx.map(x => {
    let res = { key: x.goal.key, answer: x.goal.answer, req: x.goal.reqAnswer, conf: x.goal.confidence, isCorrect: x.isCorrect };
    return res;
  });
  downloadAsYaml({ data: yyy }, 'dataSIMPLE');
}
function saveSymbolDict() {
  let y = jsonToYaml(symbolDict);
  downloadTextFile(y, 'symbolDict', 'yaml');
}
function saveTable(sendToDB = false) { lookupSet(DB.tables, [Tablename], T); if (sendToDB) dbSave(); }
function saveToDownloads(data, fname) {
  json_str = JSON.stringify(data);
  saveFile(fname + '.json', 'data:application/json', new Blob([json_str], { type: '' }));
}
function saveUnit() { saveUser(); }
function saveUser() {
  U.lastGame = G.id;
  if (!startsWith(Username, 'test')) localStorage.setItem('user', Username);
  DB.users[Username] = U;
  dbSaveX();
}
function say(text, lang, callback, volume, rate, pitch) {
  function sayit(text, lang, callback, volume, rate, pitch) {
    var text = valf(text, 'Hello, world!');
    var msg = new SpeechSynthesisUtterance();
    var voices = DA.voicelist;
    let voice = voices.filter(x => x.lang.includes(lang));
    if (isEmpty(voice)) voice = voices.filter(x => x.name.toLowerCase().includes(lang));
    msg.voice = valf(rChoose(voice), rChoose(voices));
    if (isdef(volume)) msg.volume = volume;
    if (isdef(rate)) msg.rate = rate;
    if (isdef(pitch)) msg.pitch = pitch;
    msg.text = text;
    msg.onend = e => {
      if (callback) callback(); else console.log('ENDE', e.utterance, 'Finished in ' + e.elapsedTime + ' seconds.');
    };
    speechSynthesis.speak(msg);
  }
  if (!('speechSynthesis' in window)) { alert('speech not supported!!! connect to internet?'); return; }
  if (nundef(DA.voicelist)) {
    speechSynthesis.onvoiceschanged = function () {
      DA.voicelist = speechSynthesis.getVoices();
      sayit(text, lang, callback, volume, rate, pitch);
    }
  } else sayit(text, lang, callback, volume, rate, pitch);
}
function sayRandomVoice(e, g, voice = 'random') {
  if (arguments.length == 1) voice = 'random';
  let [r, p, v] = [.8, .9, 1];
  if (!G.silentMode) Speech.say(G.language == 'E' || nundef(g) ? e : g, r, p, v, voice);
}
function sayTryAgain() { sayRandomVoice('try again!', 'nochmal'); }
function Scene() {
  touchable = 'createTouch' in document;
  this.canvas = document.createElement("canvas");
  document.body.appendChild(this.canvas);
  this.context = this.canvas.getContext("2d");
  this.clear = function () {
    this.context.clearRect(0, 0, this.width, this.height);
  }
  this.start = function () {
    if (!touchable) {
      this.initKeys();
      document.onkeydown = this.updateKeys;
      document.onkeyup = this.clearKeys;
    }
    this.intID = setInterval(localUpdate, 1000 / FRAMERATE);
  }
  this.stop = function () {
    clearInterval(this.intID);
  }
  this.updateKeys = function (e) {
    currentKey = e.keyCode;
    keysDown[e.keyCode] = true;
  }
  this.clearKeys = function (e) {
    currentKey = null;
    keysDown[e.keyCode] = false;
  }
  this.initKeys = function () {
    for (keyNum = 0; keyNum < 256; keyNum++) {
      keysDown[keyNum] = false;
    }
  }
  this.setSizePos = function (height, width, top, left) {
    styleString = "";
    styleString += "position: absolute; \n";
    styleString += "height: " + height + "px;\n";
    styleString += "width: " + width + "px;\n";
    styleString += "top: " + top + "px;\n";
    styleString += "left: " + left + "px;\n";
    this.height = height;
    this.width = width;
    this.top = top;
    this.left = left;
    this.canvas.width = this.width;
    this.canvas.height = this.height;
    this.canvas.style.left = this.left;
    this.canvas.style.top = this.top;
  }
  this.setSize = function (width, height) {
    this.width = width;
    this.height = height;
    this.canvas.width = this.width;
    this.canvas.height = this.height;
  }
  this.setPos = function (left, top) {
    this.left = left;
    this.top = top;
    this.canvas.style.left = left;
    this.canvas.style.top = top;
  }
  this.setBG = function (color) {
    this.canvas.style.backgroundColor = color;
  }
  this.setSize(SCENEWIDTH, SCENEHEIGHT);
  this.setPos(10, 100);
  this.setBG("lightgray");
}
function scoring(isCorrect) {
  Score.nTotal += 1;
  if (isCorrect) { Score.nCorrect += 1; if (G.trialNumber == 1) Score.nCorrect1 += 1; }
  percentageCorrect = Math.round(100 * Score.nCorrect / Score.nTotal);
  if (isCorrect) { Score.nPos += 1; Score.nNeg = 0; } else { Score.nPos = 0; Score.nNeg += 1; }
  let levelChange = 0;
  let gameChange = false;
  let nextLevel = G.level;
  let toggle = G.pictureLabels == 'toggle';
  let hasLabels = G.showLabels == true;
  let boundary = G.samplesPerGame;
  let pos = G.incrementLevelOnPositiveStreak;
  let posSeq = pos > 0 && Score.nPos >= pos;
  let halfposSeq = pos > 0 && Score.nPos >= pos / 2;
  let neg = G.decrementLevelOnNegativeStreak;
  let negSeq = neg > 0 && Score.nNeg >= neg;
  let halfnegSeq = neg > 0 && Score.nNeg >= neg / 2;
  let labelsNextRound = G.showLabels;
  if (halfposSeq && hasLabels && toggle) { labelsNextRound = false; }
  else if (posSeq) { levelChange = 1; nextLevel += 1; Score.nPos = 0; }
  if (halfnegSeq && !hasLabels && toggle) { labelsNextRound = true; }
  else if (negSeq) { levelChange = -1; if (nextLevel > 0) nextLevel -= 1; Score.nNeg = 0; }
  if (nextLevel != G.Level && nextLevel > 0 && nextLevel <= G.maxLevel) {
    userUpdate(['games', G.id, 'startLevel'], nextLevel);
  }
  if (Score.nTotal >= boundary) {
    gameChange = true; levelChange = false;
  }
  if (levelChange || gameChange) {
    if (toggle) labelsNextRound = true;
  } else if (!halfnegSeq && toggle && hasLabels && Score.nTotal >= G.samplesPerGame / 2) {
    labelsNextRound = false;
  }
  G.showLabels = labelsNextRound;
  Score.gameChange = gameChange;
  Score.levelChange = levelChange;
  return nextLevel;
}
function scoring_update(players, winners, game) {
  for (const p of players) {
    let info = lookupSet(DB.users, [p, 'games', game], {});
    let total = lookupSet(info, ['total'], 0);
    let wins = lookupSet(info, ['wins'], 0);
    lookupSetOverride(info, ['total'], total + 1);
  }
  for (const p of winners) {
    let info = lookup(DB.users, [p, 'games', game]);
    let wins = lookup(info, ['wins']);
    console.assert(isdef(info) && isdef(wins), 'SCORING DB INFO MISSING FOR ' + p);
    lookupSetOverride(info, ['wins'], wins + 1);
  }
}
function scrambleInputs(d) {
  let children = Array.from(d.children);
  shuffle(children);
  for (const ch of children) {
    mAppend(d, ch);
  }
}
function screen_transition(idnew, idold) {
  if (isdef(idold)) mFade(idold, 500, () => mClassReplace(idold, 'd-block', 'd-none'), 'linear');
  mAppear(idnew, 500, () => mClassReplace(idnew, 'd-none', 'd-block'), 'linear');
}
function scrollToTop() {
  document.body.scrollTop = 0;
  document.documentElement.scrollTop = 0;
}
function search_end_point(f, min, max, lower, upper) {
  if (SICHERER-- < 0) { console.log('!!!!!!!!!!'); return 0; }
  let x = min + (max - min) / 2;
  let y = f(x);
  if (y > upper) { return search_end_point(f, x, max, lower, upper); }
  else if (y < lower) { return search_end_point(f, min, x, lower, upper); }
  else return x;
}
function SearchPosition() {
  var bestMove = NOMOVE;
  var bestScore = -INFINITE;
  var currentDepth = 0;
  var pvNum = 0;
  var line;
  ClearForSearch();
  if (GameController.BookLoaded == BOOL.TRUE) {
    bestMove = BookMove();
    if (bestMove != NOMOVE) {
      $("#OrderingOut").text("Ordering:");
      $("#DepthOut").text("Depth: ");
      $("#ScoreOut").text("Score:");
      $("#NodesOut").text("Nodes:");
      $("#TimeOut").text("Time: 0s");
      $("#BestOut").text("BestMove: " + PrMove(bestMove) + '(Book)');
      srch_best = bestMove;
      srch_thinking = BOOL.FALSE;
      return;
    }
  }
  for (currentDepth = 1; currentDepth <= srch_depth; ++currentDepth) {
    bestScore = AlphaBeta(-INFINITE, INFINITE, currentDepth, BOOL.TRUE);
    if (srch_stop == BOOL.TRUE) break;
    pvNum = GetPvLine(currentDepth);
    bestMove = brd_PvArray[0];
    line = ("Depth:" + currentDepth + " best:" + PrMove(bestMove) + " Score:" + bestScore + " nodes:" + srch_nodes);
    if (currentDepth != 1) {
      line += (" Ordering:" + ((srch_fhf / srch_fh) * 100).toFixed(2) + "%");
    }
    domUpdate_depth = currentDepth;
    domUpdate_move = bestMove;
    domUpdate_score = bestScore;
    domUpdate_nodes = srch_nodes;
    domUpdate_ordering = ((srch_fhf / srch_fh) * 100).toFixed(2);
  }
  $("#BestOut").text("BestMove: " + PrMove(bestMove));
  UpdateDOMStats();
  srch_best = bestMove;
  srch_thinking = BOOL.FALSE;
}
function select_action(r, action, uname, item) {
  uiActivated = false;
  r.selected = action;
  console.log('action selected:', r.key, uname, action, item);
  window[r.key + '_post'](Session.otree, r, uname, action, item);
}
function select_add_items(items, callback = null, instruction = null, min = 0, max = 100, prevent_autoselect = false) {
  let A = Z.A;
  select_clear_previous_level();
  A.level++; A.items = items; A.callback = callback; A.selected = []; A.minselected = min; A.maxselected = max;
  console.log('A.level', A.level)
  show_stage();
  let dInstruction = mBy('dSelections0');
  mClass(dInstruction, 'instruction');
  mCenterCenterFlex(dInstruction);
  dInstruction.innerHTML = (Z.role == 'active' ? `${get_waiting_html()}<span style="color:red;font-weight:bold;max-height:25px">You</span>` : `${Z.uplayer}`) + "&nbsp;" + instruction;
  if (too_many_string_items(A)) { mLinebreak(dInstruction, 4); }
  let has_submit_items = false;
  let buttonstyle = { maleft: 10, vmargin: 2, rounding: 6, padding: '4px 12px 5px 12px', border: '0px solid transparent', outline: 'none' }
  for (const item of A.items) {
    let type = item.itemtype = is_card(item) ? 'card' : isdef(item.o) ? 'container' : 'string';
    if (isdef(item.submit_on_click)) { has_submit_items = true; }
    let id = item.id = lookup(item, ['o', 'id']) ? item.o.id : getUID(); A.di[id] = item;
    if (type == 'string') {
      let handler = ev => select_last(item, isdef(item.submit_on_click) ? callback : select_toggle, ev);
      item.div = mButton(item.a, handler, dInstruction, buttonstyle, null, id);
    } else {
      let ui = item.div = iDiv(item.o);
      ui.onclick = ev => select_last(item, select_toggle, ev);
      ui.id = id;
    }
  }
  let show_submit_button = !has_submit_items && (A.minselected != A.maxselected || !A.autosubmit);
  if (show_submit_button) { mButton('submit', callback, dInstruction, buttonstyle, 'selectable_button', 'bSubmit'); }
  let show_restart_button = A.level > 1;
  if (show_restart_button) { mButton('restart', onclick_reload, dInstruction, buttonstyle, 'selectable_button', 'bReload'); }
  let dParent = window[`dActions${A.level}`];
  for (const item of A.items) { ari_make_selectable(item, dParent, dInstruction); }
  assertion(A.items.length >= min, 'less options than min selection!!!!', A.items.length, 'min is', min);
  if (A.items.length == min && !is_ai_player() && !prevent_autoselect) {
    for (const item of A.items) { A.selected.push(item.index); ari_make_selected(item); }
    if (A.autosubmit) {
      loader_on();
      setTimeout(() => { if (callback) callback(); loader_off(); }, 800);
    }
  } else if (is_ai_player()) {
    ai_move();
  } else if (TESTING && isdef(DA.test)) {
    if (DA.test.iter >= DA.auto_moves.length) {
      if (isdef(DA.test.end)) DA.test.end();
      activate_ui();
      return;
    }
    let selection = DA.auto_moves[DA.test.iter++];
    if (selection) {
      deactivate_ui();
      let numbers = [];
      for (const el of selection) {
        if (el == 'last') {
          numbers.push(A.items.length - 1);
        } else if (el == 'random') {
          numbers.push(rNumber(0, A.items.length - 1));
        } else if (isString(el)) {
          let commands = A.items.map(x => x.key);
          let idx = commands.indexOf(el);
          numbers.push(idx);
        } else numbers.push(el);
      }
      selection = numbers;
      A.selected = selection;
      if (selection.length == 1) A.command = A.items[A.selected[0]].key;
      A.last_selected = A.items[A.selected[0]];
      select_highlight();
      setTimeout(() => {
        if (A.callback) A.callback();
      }, 1000);
    } else { activate_ui(); }
  } else { activate_ui(); }
}
function select_clear_previous_level() {
  let A = Z.A;
  if (!isEmpty(A.items)) {
    console.assert(A.level >= 1, 'have items but level is ' + A.level);
    A.ll.push({ items: A.items, selected: A.selected });
    let dsel = mBy(`dSelections1`);
    mStyle(dsel, { display: 'flex', 'align-items': 'center', padding: 10, box: true, gap: 10 });
    for (const item of A.items) {
      ari_make_unselectable(item);
      if (A.keep_selection) continue;
      ari_make_unselected(item);
      if (!A.selected.includes(item.index)) continue;
      if (item.itemtype == 'card') {
        let d = iDiv(item);
        let card = item.o;
        let mini = mDiv(dsel, { bg: 'yellow', fg: 'black', hpadding: 2, border: '1px solid black' }, null, card.friendly);
      } else if (item.itemtype == 'container') {
        let list = item.o.list;
        let cards = list.map(x => ari_get_card(x, 30, 30 * .7));
        let cont2 = ui_make_hand_container(cards, dsel, { bg: 'transparent' });
        ui_add_cards_to_hand_container(cont2, cards, list);
      } else if (item.itemtype == 'string') {
        let db = mDiv(dsel, { bg: 'yellow', fg: 'black', border: 'black', hpadding: 4 }, item.id, item.a);
      }
    }
  }
}
function select_confirm_weiter(callback) {
  select_add_items(ui_get_string_items(['weiter']), callback, 'may click to continue', 1, 1, Z.mode == 'multi');
}
function select_error(msg, callback = null, stay = false) {
  let [A] = [Z.A];
  DA.callback = callback;
  if (A.maxselected == 1 && A.selected.length > 0) {
    let item = A.items[A.selected[0]];
    ari_make_unselected(item);
    A.selected = [];
  } else if (A.selected.length == 2) {
    let item = A.items[A.selected[1]];
    ari_make_unselected(item);
    A.selected = [A.selected[0]];
  }
  dError.innerHTML = msg;
  if (stay) {
    dError.innerHTML += '<br><button onclick="continue_after_error()">CLICK TO CONTINUE</button>';
  } else {
    TO.error = setTimeout(continue_after_error, 3000);
  }
}
function select_finalize(ev) {
  if (!uiActivated) { console.log('ui is deactivated!!!'); return; }
  let A = z.A;
  let id = evToId(ev);
  let a = A.di[id];
  A.selected = [a.index];
  A.selected_key = A.items[a.index].key;
  mStyle(mBy(a.idButton), { bg: 'yellow' });
  if (isdef(a.idCard)) mClass(mBy(a.idCard), 'card_selected');
  if (A.callback) A.callback();
}
function select_goto_post() {
  if (!uiActivated) { console.log('ui is deactivated!!!'); return; }
  ari_post_action();
}
function select_goto_pre() {
  if (!uiActivated) { console.log('ui is deactivated!!!'); return; }
  ari_pre_action();
}
function select_highlight() { let A = Z.A; for (const i of A.selected) { let a = A.items[i]; ari_make_selected(a, true); } }
function select_last(item, callback, ev) {
  if (isdef(ev)) evNoBubble(ev);
  Z.A.last_selected = item; callback(item, ev);
}
function select_timer(ms, callback) {
  let d = mBy('dSelections0');
  let dtimer = mDiv(d, { w: 80, maleft: 10, fg: 'red', weight: 'bold' }, 'dTimer');
  if (isdef(DA.timer)) { DA.timer.clear(); DA.timer = null; }
  let timer = DA.timer = new SimpleTimer(dtimer, 1000, null, ms, callback);
  timer.start();
  return dtimer;
}
function select_toggle() {
  if (!uiActivated) { console.log('ui is deactivated!!!'); return; }
  let A = Z.A;
  let item = A.last_selected;
  if (A.selected.includes(item.index)) {
    removeInPlace(A.selected, item.index);
    ari_make_unselected(item);
  } else {
    if (A.maxselected == 1 && !isEmpty(A.selected)) { ari_make_unselected(A.items[A.selected[0]]); A.selected = []; }
    A.selected.push(item.index);
    ari_make_selected(item);
    if (!DA.ai_is_moving && A.selected.length >= A.maxselected && A.autosubmit) {
      setTimeout(() => A.callback(), 100);
    }
  }
}
function selectBuyDeckcard() { onClickSelectTuple(null, strategicBoat(['devdeck'])); }
function selectColor(color) {
  document.getElementsByClassName(selected_color)[0].classList.remove('selected');
  document.getElementsByClassName(color)[0].classList.add('selected');
  selected_color = color;
}
function selectGame(callback) { let route = '/game/select/' + GAME; _sendRouteJS(route, callback); }
function selectStyle(feature) {
  const color = feature.get('COLOR') || '#eeeeee';
  selected.getFill().setColor(color);
  return selected;
}
function selectText(el) {
  if (el instanceof HTMLTextAreaElement) { el.select(); return; }
  var sel, range;
  if (window.getSelection && document.createRange) {
    sel = window.getSelection();
    if (sel.toString() == '') {
      window.setTimeout(function () {
        range = document.createRange();
        range.selectNodeContents(el);
        sel.removeAllRanges();
        sel.addRange(range);
      }, 1);
    }
  } else if (document.selection) {
    sel = document.selection.createRange();
    if (sel.text == '') {
      range = document.body.createTextRange();
      range.moveToElementText(el);
      range.select();
    }
  }
}
function selectTextOrig(id) {
  var sel, range;
  var el = document.getElementById(id);
  if (window.getSelection && document.createRange) {
    sel = window.getSelection();
    if (sel.toString() == '') {
      window.setTimeout(function () {
        range = document.createRange();
        range.selectNodeContents(el);
        sel.removeAllRanges();
        sel.addRange(range);
      }, 1);
    }
  } else if (document.selection) {
    sel = document.selection.createRange();
    if (sel.text == '') {
      range = document.body.createTextRange();
      range.moveToElementText(el);
      range.select();
    }
  }
}
function selectUid(uid, R) {
  console.log('user has selected', uid);
}
function selectWord(info, bestWordIsShortest, except = []) {
  let candidates = info.words.filter(x => x.length >= MinWordLength && x.length <= MaxWordLength);
  let w = bestWordIsShortest ? getShortestWord(candidates, false) : last(candidates);
  if (except.includes(w)) {
    let wNew = lastCond(info.words, x => !except.includes(w));
    if (wNew) w = wNew;
  }
  return w;
}
async function send_files() {
  const myFiles = document.getElementById('myFiles').files;
  const formData = new FormData();
  Object.keys(myFiles).forEach(key => {
    formData.append(myFiles.item(key).name, myFiles.item(key));
  })
  const response = await fetch(SERVERURL + '/upload', {
    method: 'POST',
    body: formData
  });
  const json = await response.json();
  const h2 = document.querySelector('h2');
  h2.textContent = `Status: ${json?.status}`;
  const h3 = document.querySelector('h3');
  h3.textContent = json?.message;
  console.log(json);
}
function send_image(files) {
  console.log('files', files);
  var filename = files[0].name;
  var ext_start = filename.lastIndexOf(".");
  var ext = filename.substr(ext_start + 1, 3);
  if (!(ext == "jpg" || ext == "JPG")) {
    alert("This file type is not allowed");
    return;
  }
  var xml = new XMLHttpRequest();
  xml.onload = function () {
    if (xml.readyState == 4 || xml.status == 200) {
      handle_result(xml.responseText, "send_image");
    }
  }
  let data = new FormData();
  data.append('file', files[0]);
  data.append('data_type', "send_image");
  data.append('sender', Username);
  data.append('receiver', CURRENT_CHAT_USER);
  xml.open("POST", "uploader.php", true);
  xml.send(data);
}
function send_message(e) {
  e.cancelBubble = true;
  var message_text = mBy("message_text");
  if (message_text.value.trim() == "") {
    alert("please type something to send");
    return;
  }
  get_data({
    message: message_text.value.trim(),
    username: CURRENT_CHAT_USER
  }, "send_message");
}
function send_move() {
  let me = Session.cur_players[Session.cur_user];
  if (me.player_status == 'lamov') me.player_status = 'done';
  let o = { tid: Session.cur_tid, player_status: me.player_status, score: me.score, state: me.state, uname: me.name };
  to_server(o, 'send_move');
}
function send_move_dep(game, uname, tid, step, move) {
  Session.cur_menu = 'games';
  let data = { game: game, uname: uname, tid: tid, step: step, move: move };
  to_server(data, "send_move");
}
function send_or_sim(o, cmd) {
  Counter.server += 1;
  phpPost(o, cmd);
}
function send_pause() { socket.emit('pause'); }
function send_reset() { socket.emit('reset'); }
function send_resume() { socket.emit('resume'); }
function send_timer_ticker() {
  let me = Session.cur_players[Session.cur_user];
  to_server({ tid: Session.cur_tid, score: me.score, state: me.state, uname: me.name }, 'ticker_status_send_receive');
}
async function sendAction(boat, username) {
  if (TESTING) {
    modifyServerDataRandom(username);
  } else {
    _syncUsernameOfSender(username);
    if (nundef(boat)) boat = chooseRandom(boats);
    let route = '/action/' + Username + '/' + serverData.key + '/' + boat.desc + '/';
    let t = boat.tuple;
    route += t.map(x => _pickStringForAction(x)).join('+');
    let result = await route_server_js(route);
    prevServerData = serverData;
    serverData = result;
  }
}
function sendAction_old(player, tuple, callback, ms = 30) {
  setTimeout(() => {
    testOutput({ 1: ['sending action:' + player + tuple + callback.name] });
    testOutput({ 0: [player + ' selects:' + tuple] });
    let chain = ['action/' + player + '/' + tuple.join('+'), 'info/' + player, 'status/' + player];
    sender.chainSend(chain, player, callback);
  }, ms);
}
function sendChangePlayer(data, callback) {
  player = data.waiting_for.set[0];
  if (!assets.factionNames.includes(player)) {
    logFormattedData(data, msgCounter, 'ERROR: waiting_for data corrupt!!!' + player);
  } else {
    let chain = ['info/' + player, 'status/' + player];
    sender.chainSend(chain, player, callback);
  }
}
function sendChangeToPlayer(nextPlayer, callback) {
  let chain = ['info/' + nextPlayer, 'status/' + nextPlayer];
  sender.chainSend(chain, nextPlayer, callback);
}
function sendEditAction(player, tuple, callback, ms = 30) {
  setTimeout(() => {
    testOutput({ 1: ['sending action:' + player + tuple + callback.name] });
    testOutput({ 0: [player + ' selects:' + tuple] });
    sender.send('edit/' + player + '/' + tuple.join('+'), callback);
  }, ms);
}
function sendEmptyAction(player, callback) {
  testOutput({ 1: ['sending empty action!!!'] });
  sendAction(player, ['none'], callback);
}
async function sendfen(o, plname) {
  let gamerec = await post_test2(o, '/post');
  let oldrec = firstCond(Serverdata.games, x => x.name == gamerec.name);
  if (oldrec) arrRemovip(Serverdata.games, oldrec);
  Serverdata.games.unshift(gamerec);
  processServerdata();
  console.log('Serverdata', Serverdata);
  DA.gameItems = show_gametable(mBy('dAllTables'));
  let turn = gamerec.fen.turn;
  let uname = isdef(plname) ? plname : isdef(U) ? U.name : turn[0];
  show_table_for(gamerec, dParent, uname);
  if (Pollmode == 'auto') TO.poll = setTimeout(poll, 5000);
}
function sendFilename(msg) { logClientSend('filename', msg); Socket.emit('filename', { msg }); }
function sendgameover(plname, friendly, fen, scoring) {
  let o = { winners: plname, friendly: friendly, fen: fen, scoring: scoring };
  phpPost(o, 'gameover');
}
function sendGetGameInfo() {
  timit.showTime('sending select game');
  _sendRoute('/game/select/' + S.settings.game, d2 => {
    timit.showTime('sending game info');
    _sendRoute('/game/info/' + S.settings.game, d4 => {
      console.log('gameInfo', d4, getTypeOf(d4));
      S.gameInfo = JSON.parse(d4);
      console.log(S.gameInfo);
      _sendRoute('/game/players', d5 => {
        console.log('players', d5, getTypeOf(d5));
        S.gameInfo = JSON.parse(d5);
        console.log(S.gameInfo);
        waitForLogin();
      });
    });
  });
}
function sendHtml(id, filename) {
  window.scrollTo(0, 0);
  html2canvas(document.getElementById(id)).then(function (canvas) {
    let imgData = canvas.toDataURL("image/jpeg", 0.9);
    var profile_image = mBy("profile_image");
    profile_image.src = imgData;
    mBy('imgPreview').src = imgData;
    var ajax = new XMLHttpRequest();
    ajax.open("POST", "server/save_url_encoded_image.php", true);
    ajax.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    ajax.send("image=" + canvas.toDataURL("image/jpeg", 0.9) + "&filename=" + filename + ".jpg");
    ajax.onreadystatechange = function () {
      if (this.readyState == 4 && this.status == 200) {
        let udata = get_current_userdata();
        if (!udata.image) { udata.image = true; db_save(); }
        get_login();
      }
    };
  });
}
function sendHtml_dep(id, filename) {
  window.scrollTo(0, 0);
  html2canvas(document.getElementById(id)).then(function (canvas) {
    let imgData = canvas.toDataURL("image/jpeg", 0.9);
    var profile_image = mBy("profile_image");
    profile_image.src = imgData;
    mBy('imgPreview').src = imgData;
    var ajax = new XMLHttpRequest();
    ajax.open("POST", "server/save_url_encoded_image.php", true);
    ajax.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    ajax.send("image=" + canvas.toDataURL("image/jpeg", 0.9) + "&filename=" + filename + ".jpg");
    ajax.onreadystatechange = function () {
      if (this.readyState == 4 && this.status == 200) {
        console.log('RESPONSE IMAGE UPLOAD!!!!!!!', this.responseText);
        window.location.replace('index.html');
      }
    };
  });
}
function sendInit() {
  timit.showTime('sending status');
  _sendRouteJS('/status/' + USERNAME, d7 => {
    data = d7.response;
    if (S.settings.playMode == 'multiplayer') {
      if ('players' in data) {
        for (const id in data.players) {
          let pl = data.players[id];
          if (pl.obj_type == 'GamePlayer') {
            if (pl != G.player) {
              if (!(id in S.plAddedByMe)) {
                enterWaitingLoop(); return;
              }
            }
          }
        }
      }
    }
    processData(data);
    specAndDOM([gameStep]);
  });
}
function sendInit_old(player, callback, seed = 1) {
  var chain = ['init/hotseat/' + player + '/' + seed, 'info/' + player, 'status/' + player];
  sender.chainSend(chain, player, callback);
}
function sendInitNewGame() {
  timit.showTime('sending restart');
  _sendRoute('/restart', d0 => {
    timit.showTime('sending select game');
    _sendRoute('/game/select/' + S.settings.game, d2 => {
      timit.showTime('sending game info');
      _sendRoute('/game/info/' + S.settings.game, d4 => {
        S.gameInfo = JSON.parse(d4);
        let chain = [];
        let i = 0;
        S.gameInfo.userList = [];
        for (const pl of S.gameInfo.player_names) {
          let user = i > 0 ? USERNAME + i : USERNAME;
          let cmd = '/add/player/' + user + '/' + pl;
          S.gameInfo.userList.push(user);
          i += 1;
          chain.push(cmd);
        }
        timit.showTime('sending player logins');
        chainSend(chain, d5 => {
          _sendRoute('/begin/1', d6 => {
            let user = S.gameInfo.userList[0];
            timit.showTime('sending status');
            _sendRoute('/status/' + user, d7 => {
              let data = JSON.parse(d7);
              processData(data);
              specAndDOM([gameStep]);
            });
          });
        });
      });
    });
  });
}
function sendInitSeed(player, seed, callback) {
  let url = 'init_test/hotseat/' + player;
  if (seed != null) url += '/' + seed;
  unitTestSender('url:', url);
  sender.send(url, dInit => {
    unitTestSender('dInit:', dInit);
    dInit.info.game.player = player;
    callback(dInit);
  });
}
function sendInitSeed_old(player, seed, callback) {
  sender.send('init/hotseat/' + player + '/' + seed, dInit => {
    sender.send('info/' + player, dInfo => {
      dInit = extend(true, dInit, dInfo);
      dInit.game.player = player;
      callback(dInit);
    });
  });
}
function sendLoading(player, filename, callback) {
  unitTestLoad('loading', filename);
  var sData = {};
  sender.send('myload/' + filename + '.json', d1 => {
    unitTestLoad('myload response:', d1);
    sender.send('refresh/' + player, d2 => {
      unitTestLoad('refresh response:', d2);
      sData.created = d2;
      sender.send('status_test/' + player, d3 => {
        sData = augment(sData, d3);
        unitTestLoad('status_test response:', d3, 'akku:', sData, 'player', player);
        actionOrWaiting(player, sData, callback);
      });
    });
  });
}
function sendLoading_old(filename, player, callback, outputOption = 'none') {
  execOptions.output = outputOption;
  var sData = {};
  sender.send('myload/' + filename + '.json', data => {
    sender.send('refresh/' + player, data => {
      sData.created = data;
      let chain = ['info/' + player, 'status/' + player];
      sender.chainSend(chain, player, data => {
        sData = augment(sData, data);
        sData.created = augment(sData.created, sData.updated);
        if ('waiting_for' in data && empty(getSet(data, 'waiting_for'))) {
          sender.send('action/' + player + '/none', data => {
            sData = augment(sData, data);
            if (callback) callback(sData);
          });
        } else {
          if (callback) callback(sData);
        }
      });
    });
  });
}
function sendLoadScenario(player, filename, callback) {
  unitTestScenario('loading', filename);
  var sData = {};
  sender.send('myloadScenario/' + filename + '.json', d1 => {
    unitTestScenario('myloadScenario response:', d1);
    callback(d1);
  });
}
function sendLoadScenario2(player, filename, callback) {
  unitTestScenario('_____________________loading scenario', filename);
  var sData = {};
  sender.send('myloadScenario2/' + filename + '.yml', d1 => {
    unitTestScenario('server response:', d1);
    callback(d1);
  });
}
function sendLogin(username) { logClientSend('login', username); Socket.emit('login', { data: username }); }
function sendMousePosition(ev) {
  if (nundef(Socket)) return;
  if (!ev.altKey || ev.ctrlKey) return;
  let [x, y] = [ev.pageX, ev.pageY];
  x = (ev.pageX - $('#dFieldArea').offset().left);
  y = (ev.pageY - $('#dFieldArea').offset().top);
  if (Math.abs(x - LastPositionX) > MOUSED || Math.abs(y - LastPositionY) > MOUSED) {
    LastPositionX = x; LastPositionY = y;
    MouseMoveCounter = 0;
    Socket.emit('mouse', { username: Username, x: x, y: y });
  } else MouseMoveCounter += 1;
}
function sendmove(plname, fen, action, expected, step) {
  pollStop();
  let o = { type: 'move', uname: plname, game: G.name, fen: fen, action: action, expected: expected, step: step };
  sendfen(o, plname);
}
function sendMoveField(f) {
  let data = { dxy: f.item.dxy, iField: f.index, username: Username };
  logClientSend('moveField', data);
  Socket.emit('moveField', data);
}
function sendMovePerle(perle, fFrom, fTo, dis) {
  let data = { dxy: perle.dxy, iPerle: perle.index, iFrom: fFrom.index, iTo: fTo.index, displaced: isdef(dis) ? dis.index : null, username: Username };
  logClientSend('movePerle', data);
  Socket.emit('movePerle', data);
}
function sendPlacePerle(perle, field, dis) {
  let data = { dxy: perle.dxy, iPerle: perle.index, iField: field.index, displaced: isdef(dis) ? dis.index : null, username: Username };
  logClientSend('placePerle', data);
  Socket.emit('placePerle', data);
}
function sendRandom(G, n, callback) { }
function sendRelayout(rows, cols, boardArr, poolArr) {
  let data = { rows: rows, cols: cols, boardArr: boardArr, username: Username };
  if (isdef(poolArr)) data.poolArr = poolArr;
  logClientSend('relayout', data);
  Socket.emit('relayout', data);
}
function sendRemovePerle(perle, fFrom) {
  let data = { iPerle: perle.index, iFrom: fFrom.index, username: Username };
  logClientSend('removePerle', data);
  Socket.emit('removePerle', data);
}
function sendReset(settings) { logClientSend('reset', Username); Socket.emit('reset', { settings: settings, username: Username }); }
async function sendRestart(username) {
  _syncUsernameOfSender(username);
  if (TESTING) serverData = await loadInitialServerData(Username);
  else serverData = await route_begin_status(Username);
}
function sendSettings() {
  logClientSend('settings', G.settings);
  console.assert(G.settings == Settings.o, "wrong settings object!!!!!!!")
  Socket.emit('settings', { settings: G.settings, nFields: calcNFields(G.settings) });
}
function sendSettingsWithBoardImage(pack) {
  logClientSend('sendSettingsWithBoardImage', pack.filename);
  console.log('pack', pack);
  Socket.emit('settingsWithBoardImage', pack);
}
function sendSIMSIM(o, exclusive = false, saveFromZ = false) {
  o = data_from_client(o);
  let result = apiphp(o, saveFromZ);
  if (TESTING && o.cmd == 'startgame') { for (const func of DA.test.mods) func(result.table); }
  let res = JSON.stringify(result);
  if (exclusive) { if_hotseat_autoswitch(result); handle_result(res, o.cmd); } else { console.log('sendSIMSIM testresult', result); }
}
function sendStartOrJoinPerlenGame() {
  if (STARTED) {
    if (isdef(G)) { saveStateAndSettings(); }
    console.log('SERVER RESTART?!?!?!!!');
    return;
  }
  STARTED = true;
  let data = Username;
  logClientSend('startOrJoinPerlen', data);
  Socket.emit('startOrJoinPerlen', data);
  window.onkeydown = keyDownHandler;
  window.onkeyup = keyUpHandler;
  mBy('sidebar').ondblclick = () => { closeAux(); hide('sidebar') };
  G = new SimpleClass7();
  startingSetup();
}
async function sendStatus(username) {
  _syncUsernameOfSender(username);
  if (!TESTING) serverData = await route_status(Username);
}
function sendToBack(ui) {
  ui.style.zIndex = 0;
}
function sendUserMessage(data) { logClientSend('userMessage', data.username); Socket.emit('userMessage', { data: data }); }
function separateAtCapitals(s) {
  let sNew = '';
  for (let i = 0; i < s.length; i++) {
    let ch = s[i];
    if (ch.toUpperCase() != ch) sNew += ch;
    else sNew += ' ' + ch.toLowerCase();
  }
  return sNew;
}
function sepWordListFromString(s, seplist) {
  let words = multiSplit(s, seplist);
  return words.map(x => x.replace('"', '').trim());
}
function sepWords(text, voiceKey, s = '') {
  text = text.toLowerCase();
  if (voiceKey == 'zira') {
    return text;
  } else if (startsWith(voiceKey, 'u')) { return text; }
  let words = text.split(' ');
  //s='? ';//' - ';
  text = words.join(' '); text += s;
  return text;
}
function serialize_all() {
  let list = [];
  for (const id in Items) {
    let res = default_item_serializer(Items[id]);
    list.push(res);
  }
  console.log('list', list)
  downloadAsYaml(list, '_all');
  toLocalStorage(list);
}
function server_offline(req, type) {
  if (type == 'user_info') console.log('_______to server offline!', 'req', req, 'type', type, 'Session.cur_user', Session.cur_user);
  let response = {};
  switch (type) {
    case 'user_info':
    case 'account':
      if (nundef(req.user)) req.user = Session.cur_user;
      let u = response.message = DB.users[req.user];
      console.log('udata', u);
      response.name = u.name;
      break;
    case 'contacts':
      let usernames = get_user_names().filter(x => x != Session.cur_user);
      response.users = usernames.map(x => DB.users[x]);
      break;
  }
  response.type = type;
  from_server(JSON.stringify(response), type);
}
function server_online(req, type) {
  var xml = new XMLHttpRequest();
  var loader_holder = mBy("loader_holder");
  loader_holder.className = "loader_on";
  xml.onload = function () {
    if (xml.readyState == 4 || xml.status == 200) {
      loader_holder.className = "loader_off";
      from_server(xml.responseText, type);
    }
  }
  var data = { req: req, type: type };
  data = JSON.stringify(data);
  xml.open("POST", "./server/apisi.php", true);
  xml.send(data);
}
function serverGet(cmd, { game = 'catan', iTuple = 0 }, callback) {
  S.count.msg += 1;
  let url = SERVER_URL + (cmd == 'init' ? 'init/' + game : cmd == 'action' ? 'action/' + G.player + '/' + iTuple : 'status/' + G.player);
  $.ajax({
    url: url,
    type: 'GET',
    success: response => {
      if (response[0] != '{') {
        error('server response is NOT JSON string!!!... transforming...');
        if (callback) callback(JSON.parse('{"response":"' + response + '"}'));
      } else {
        let data = JSON.parse(response);
        if ('error' in data) {
          error(data);
          alert(JSON.stringify(data.error));
        } else {
          if (callback) callback(data);
        }
      }
    },
    error: err => {
      error(err);
      alert(err);
    },
  });
}
async function serverTest00_postData() {
  console.log('hallo');
  let o = { liste: [1, 2, 3], hut: 'hutX' };
  let path = './DATA/file.yaml';
  let resp = await postData('http://localhost:3000/db', { obj: o, path: path });
  console.log('response', resp); return;
}
async function SessionStart() {
  await loadCorrectWords(); await loadAssets(); ensureSymBySet(); makeHigherOrderGroups();
  initTable();
  initSidebar();
  initSettingsP0();
  CurrentSessionData = { user: currentUser, games: [] };
  if (immediateStart && IS_TESTING) { hide('freezer'); show('divControls'); startGame(); }
  else if (immediateStart) { show('freezer'); hide('divControls'); }
  else { hide('freezer'); hide('divControls'); openSettings(); }
}
function set_auction_phase(o) {
  fen = o.fen;
  fen.phase = o.phase = 'jack';
  fen.turn = [fen.plorder[0]];
  fen.stage = 12;
  ensure_market(fen, 3);
}
function set_background_color(color, elem) { if (nundef(elem)) elem = mBy('md').parentNode; mStyle(elem, { bg: getColorDictColor(color) }); }
function set_bar(id, val, speed) {
  let bar = DA.bars[id];
  let goal = Math.min(100, Math.max(0, val));
  if (goal == bar.w) return;
  let i = goal > bar.w ? speed : -speed;
  clearInterval(bar.ti);
  bar.ti = setInterval(() => anim(bar, i, goal), 10);
  function anim(bar, i, goal) {
    if (i < 0 && bar.w <= goal || i > 0 && bar.w >= goal) {
      clearInterval(bar.ti);
    } else {
      bar.w += i;
      bar.div.style.width = bar.w + '%';
    }
  }
}
function set_blackmail_owner_stage(o) {
  set_queen_phase(o);
  let fen = o.fen;
  let uplayer = fen.turn[0];
  console.log('blackmailed is', uplayer)
  give_various_buildings_to(o, uplayer);
  let other = firstCond(fen.plorder, (p) => p != uplayer);
  let building = get_building_with_rumor(o.fen, uplayer);
  let payment = { o: null, a: 'coin', key: 'coin', friendly: 'coin', path: null };
  fen.blackmail = { blackmailer: other, blackmailed: uplayer, payment: payment, building_path: building.path };
  building.isblackmailed = true;
  fen.stage = o.stage = 33;
}
function set_blackmail_owner_stage_defend(o) {
  set_blackmail_owner_stage(o);
  console.log('==>blackmailed is', o.fen.turn[0])
  let fen = o.fen;
  let uplayer = fen.turn[0];
  console.log('==>blackmailed is', uplayer)
  let building = path2fen(fen, fen.blackmail.building_path);
  let lead = building.lead;
  fen.players[uplayer].rumors.push(`${lead[0]}Cr`);
  let plname = fen.blackmail.blackmailed;
  let rumors = fen.players[plname].rumors;
  console.log('lead', lead, 'blackmailed rumors', rumors);
}
function set_boa_score(inc) { S.score += inc; if (S.score < 0) S.score = 0; boa_save(); }
function set_card_border(item, thickness = 1, color = 'black', dasharray) {
  let d = iDiv(item);
  let rect = lastDescendantOfType('rect', d);
  assertion(rect, 'NO RECT FOUND IN ELEM', d);
  if (rect) {
    rect.setAttribute('stroke-width', thickness);
    rect.setAttribute('stroke', color);
    if (isdef(dasharray)) rect.setAttribute('stroke-dasharray', dasharray);
  }
}
function set_card_constants(w, h, ranks, suits, deckletters, numjokers = 0, ovdeck = .25, ovw = '20%', ovh = '20%') {
  Card = {};
  Card.sz = valf(h, 300);
  Card.h = h;
  Card.w = isdef(w) ? w : Card.sz * .7;
  Card.gap = Card.sz * .05;
  Card.ovdeck = ovdeck;
  Card.ovw = isString(ovw) ? Card.w * firstNumber(ovw) / 100 : ovw;
  Card.ovh = isString(ovh) ? Card.h * firstNumber(ovh) / 100 : ovh;
  Card.ranks = valf(ranks, '23456789TJQKA');
  Card.suits = valf(suits, 'SHDC');
  Card.decks = valf(deckletters, 'rb');
  Card.numdecks = deckletters.length;
  Card.numjokers = numjokers;
}
function set_card_style(item, styles = {}, className) {
  console.log('set_card_style', item, styles);
  let d = iDiv(item);
  let svg = findDescendantOfType('svg', d);
  let rect = findDescendantOfType('rect', svg);
  if (isdef(styles.shadow)) {
    let shadow = styles.shadow;
    delete styles.shadow;
    let hexcolor = colorFrom(styles.shadow);
    svg.style.filter = `drop-shadow(4px 5px 2px ${hexcolor})`;
  }
  if (isdef(styles.bg)) {
    let hexcolor = colorFrom(styles.bg);
    rect.setAttribute('stroke-width', 14); rect.setAttribute('stroke', hexcolor);
  }
  assertion(rect, 'NO RECT FOUND IN ELEM', d);
  mStyle(d, styles);
  if (isdef(className)) mClass(svg, className);
}
function set_card_style_works(c, styles, className) {
  let d = iDiv(c);
  mStyle(d, styles);
  d.firstChild.setAttribute('class', className);
}
function set_context(item) {
  CONTEXT = isDict(item) ? item
    : isString(item) && isdef(Items[item]) ? Items[item]
      : isNumber(item) && isdef(Items[`_${item}`]) ? Items[`_${item}`]
        : get_values(Items)[0];
}
function set_cur_tid_for_game() {
  console.assert(isdef(Session.tables_by_game) && isdef(Session.cur_game), "set_cur_tid_for_game");
  let tables = Session.tables_by_game;
  let game = Session.cur_game;
  if (!isEmpty(tables[game])) Session.cur_tid = tables[game][0].id;
  else Session.cur_tid = null;
}
function set_elo(user, game, val) { lookupSetOverride(DB.users, [user, 'games', game, 'elo'], val); }
function set_g_index(i) { G.i = i; call_question(i); }
function set_hover_card(b, d, val = 'silver', prop = 'fill') {
  b.onmouseenter = () => {
    let rs = Array.from(d.getElementsByTagName('rect'));
    let r = arrLast(rs);
    b[prop] = r.getAttribute(prop);
    r.setAttribute(prop, val);
  }
  b.onmouseleave = () => {
    let rs = Array.from(d.getElementsByTagName('rect'));
    let r = arrLast(rs);
    r.setAttribute(prop, b[prop]);
  }
}
function set_hover_div(b, d, val, prop) {
  b.onmouseenter = () => {
    d[prop] = mGetStyleX(d, prop);
    let style = {}; style[prop] = val; mStyle(d, style);
  }
  b.onmouseleave = () => {
    let style = {}; style[prop] = d.bg; mStyle(d, style);
  }
}
function set_hover_ui(b, item) {
  let isCard = isdef(item.c52key);
  let d = iDiv(item);
  b.onmouseenter = () => {
    if (isCard) {
      let rs = Array.from(d.getElementsByTagName('rect'));
      let r = arrLast(rs);
      let fill = b.fill = r.getAttribute('fill');
      r.setAttribute('fill', 'silver');
    } else {
      let hallo = mGetStyle(d, 'bg');
      let bg = isEmpty(hallo) ? 'transparent' : valf(mGetStyle(d, 'bg'), 'transparent');
      d.setAttribute('bg', bg);
      mStyle(d, { bg: 'silver' });
    }
  }
  b.onmouseleave = () => {
    if (isCard) {
      let rs = Array.from(d.getElementsByTagName('rect'));
      let r = arrLast(rs);
      r.setAttribute('fill', b.fill);
    } else {
      let bg = d.getAttribute('bg');
      mStyle(d, { bg: bg });
    }
  }
}
function set_image_as_background(id, elem) {
  window.scrollTo(0, 0);
  html2canvas(document.getElementById(id)).then(function (canvas) {
    console.log('haaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')
    let imgData = canvas.toDataURL("image/jpeg", 0.9);
    const rgbArray = buildRgb(imageData.data);
    const quantColors = quantization(rgbArray, 0);
    buildPalette(quantColors);
  });
}
function set_journey_or_stall_stage(fen, options, phase) {
  let pljourney = exp_journeys(options) ? find_players_with_potential_journey(fen) : [];
  let stage, turn;
  if (isEmpty(pljourney)) { delete fen.passed; turn = [fen.plorder[0]]; ari_ensure_deck(fen, phase == 'jack' ? 3 : 2); stage = 3; }
  else { turn = [pljourney[0]]; stage = 1; }
  return [stage, turn];
}
function set_king_phase(o) { set_queen_phase(o); o.phase = o.fen.phase = 'king'; }
function set_language(lang = 'E', update_ui = true) {
  console.log('lang', lang);
  if (isdef(G)) {
    G.language = G.lang = lang; lookupSetOverride(U.games, [G.id, 'language'], lang);
    Speech.setLanguage(lang);
  }
}
function set_most_recent_table_as_cur_tid(tables) { if (!isEmpty(tables)) Session.cur_tid = tables[0].id; }
function set_new_goal(id, goal, speed = .1) {
  let bar = DA.bars[id];
  goal = Math.min(100, Math.max(0, goal));
  if (goal == bar.w) return;
  let i = goal > bar.w ? speed : -speed;
  clearInterval(bar.ti);
  bar.ti = setInterval(() => anim(bar, i, goal), 10);
  function anim(bar, i, goal) {
    if (i < 0 && bar.w <= goal || i > 0 && bar.w >= goal) {
      clearInterval(bar.ti);
    } else {
      bar.w += i;
      bar.div.style.width = bar.w + '%';
    }
  }
}
function set_new_password() {
  let len = Math.min(20, S.master_password.length + 1);
  let pnew = rPassword(len);
  console.log('new password: ', pnew);
  S.master_password = pnew;
  S.score = 0;
  boa_save();
}
function set_palette(hue = 0, nHues = 2, sat = 100, a = 1) {
  palette = gen_palette(hue, nHues, sat, a);
  return palette;
}
function set_player(name, fen) {
  if (isdef(PL) && PL.name != name) { Z.prev.pl = PL; Z.prev.uplayer = PL.name; }
  PL = Z.pl = firstCond(Serverdata.users, x => x.name == name);
  copyKeys(fen.players[name], PL);
  Z.uplayer = name;
}
function set_player_strategy(val) {
  Z.strategy = Clientdata.strategy = Z.pl.strategy = val;
  mRemove('dOptions')
}
function set_player_tides(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let min = 1000, minplayer = null;
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    let hkey = pl.hand[0];
    let val = ari_get_card(hkey).val;
    pl.tides = { keys: [hkey], val: val };
    if (val < min) { min = val; minplayer = plname; }
    console.log('player', plname, 'tides', pl.tides);
  }
  let sorted = sortByDescending(fen.plorder, x => fen.players[x].tides.val);
  fen.church_order = jsCopy(fen.plorder);
  fen.tide_minimum =
    fen.stage = 21;
}
function set_player_tithes(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  let min = 1000, minplayer = null;
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    let hkey = pl.hand[0];
    let val = ari_get_card(hkey).val;
    pl.tithes = { keys: [hkey], val: val };
    if (val < min) { min = val; minplayer = plname; }
    console.log('player', plname, 'tithes', pl.tithes);
  }
  let sorted = sortByDescending(fen.plorder, x => fen.players[x].tithes.val);
  fen.church_order = jsCopy(fen.plorder);
  fen.tithe_minimum =
    fen.stage = 21;
}
function set_preferred_lang(uname, val) { val = val.toUpperCase(); if ('EDSFC'.indexOf(val) >= 0) return lookupSetOverride(DB.users, [uname, 'lang'], val); }
function set_queen_phase(o) {
  fen = o.fen;
  fen.phase = o.phase = 'queen';
  arisim_stage_3(fen);
  arisim_stage_4_all(fen, 3, false);
  ensure_actions(fen);
  fen.turn = [fen.plorder[0]];
}
function set_run_state(singleclient = true, sockets = false, port = 3000, localhost = true, testing = true, liveserver = true, nodejs = true) {
  SERVER = localhost ? '127.0.0.1' : '216.250.112.218';
  PORT = port;
  SERVERURL = `http:/` + `${SERVER}:${PORT}`;
  NODEJS = nodejs;
  LIVE_SERVER = liveserver;
  TESTING = testing;
  SINGLECLIENT = singleclient;
  if (sockets) {
    Socket = liveserver ? io(SERVERURL) : io();
    Socket.on('message', x => console.log('got message', x));
    Socket.on('disconnect', x => console.log('got disconnect', x));
    Socket.on('update', x => console.log('got update', x));
  }
  console.log('SERVER:' + SERVERURL, 'LIVE:' + LIVE_SERVER, 'Socket:' + Socket, TESTING ? 'TESTING' : '', SINGLECLIENT ? 'SINGLE' : '');
}
function set_run_state_local() {
  set_run_state(true, false, 3000, true, false, true, true);
}
function set_run_state_no_server() {
  set_run_state(true, false, 3000, true, true, true, false);
}
function set_run_state_vps() {
  set_run_state(false, false, 3000, false, false, false, true);
}
function set_seen(e) { SEEN_STATUS = true; }
function set_sound(silent = false) {
  let b = mBy('b_sound');
  if (silent) {
    b.className = 'statusbutton sym enabled off';
    b.innerHTML = '🔈️';
  } else {
    b.className = 'statusbutton sym enabled on';
    b.innerHTML = '🔊';
  }
}
function set_start_data_from_fen(fen, game) {
  let parts = fen.split(',');
  for (const p of parts) {
    let [name, startlevel, lang] = p.split(':');
    startlevel = Number(startlevel);
    set_startlevel(name, game, startlevel);
    set_preferred_lang(name, lang);
  }
}
function set_startlevel(user, game, val) { return lookupSetOverride(DB.users, [user, 'games', game, 'startlevel'], val); }
function set_state_numbers(otree) {
  let [step, stage, iturn, round, phase] = [valf(otree.step, 0), valf(otree.stage, 0), valf(otree.iturn, 0), valf(otree.round, []), valf(otree.phase, 'king')];
  otree.step = step;
  otree.stage = stage;
  otree.iturn = iturn;
  otree.round = round;
  otree.phase = phase;
  let plturn = otree.plturn = otree.plorder[iturn];
  return [step, stage, iturn, round, phase, plturn];
}
function set_style_from_options(layer, options = {}) {
  let style = isdef(options.colorfunc) ? get_style_func(options.colorfunc, valf(options.bg, 'lime'), valf(options.fg, 'orange'))
    : get_style(valf(options.bg, 'yellow'), valf(options.fg, 'yellow'));
  layer.setStyle(style);
}
function set_tables_by_game(obj, is_set_cur_id = true) {
  let tables = Session.tables = obj.tables;
  let bygame = Session.tables_by_game = {};
  if (isEmpty(tables)) {
    Session.cur_tid = null;
    Session.tables_by_game = {};
  } else {
    if (is_set_cur_id) {
      let t = tables[0];
      Session.cur_tid = t.id;
      Session.cur_game = t.game;
    }
    for (const t of tables) { lookupAddToList(bygame, [t.game], t); }
  }
  return bygame;
}
function set_user(name) {
  if (isdef(Z) && isdef(U) && U.name != name) {
    Z.prev.u = U;
    Z.prev.uname = U.name;
  }
  U = firstCond(Serverdata.users, x => x.name == name);
  if (isdef(Z)) {
    Z.u = U;
    Z.uname = Z.uplayer = name;
  }
}
function set_user_tables_by_game(obj) {
  let user_tables = obj.user_tables;
  let bygame = Session.user_tables_by_game = {};
  if (isEmpty(user_tables)) {
    Session.cur_tid = null;
    Session.user_tables_by_game = {};
  } else {
    Session.cur_tid = user_tables[0].id;
    for (const t of user_tables) { lookupAddToList(bygame, [t.game], t); }
  }
  return bygame;
}
function setActiveButton(button) {
  ActiveButton = button;
  mStyleX(button, { bg: 'dimgray', fg: 'white' });
  button.innerHTML = 'submit command!';
}
function setApply(prop, val) {
  let s = G.settings;
  if (isNumber(val)) val = Number(val);
  s[prop] = val;
  G.clientBoard = applySettings(G.clientBoard, s);
}
function setAreaHeight(areaName, h) {
  let varName = AREAS[areaName][1];
  let hAttr = isNumber(h) ? '' + h + 'px' : h;
  setCSSVariable(varName, hAttr);
  if (UIS[areaName]) UIS[areaName].h = h;
}
function setAreaWidth(areaName, w) {
  if (!(areaName in AREAS)) { alert('not in AREAS!!! ' + areaName) }
  let wString;
  let wNum = null;
  if (isString(w)) {
    let n = firstNumber(w);
    if (isNumber(n)) wNum = n;
    wString = w;
  } else {
    wNum = w;
    wString = '' + w + 'px';
  }
  let varName = AREAS[areaName][0];
  setCSSVariable(varName, wString);
  if (UIS[areaName] && wNum) UIS[areaName].w = wNum;
}
function setAutoplayFunctionForMode(mode, isStartup = false) {
  if (nundef(mode)) mode = S.settings.playmode;
  if (!isStartup) S_autoplayFunction = (_g, _) => isFrontAIPlayer(_g.player);
}
function setBackgroundColor(c) { mStyleX(document.body, { bg: getColorDictColor(isdef(c) ? c : G.color) }); }
function setBackgroundToPlayerColor() {
  let c = G.playersAugmented[G.player].color;
}
function setBadgeLevel(i) {
  G.level = i;
  Score.levelChange = true;
  if (isEmpty(badges)) showBadgesX(dLeiste, G.level, onClickBadgeX, G.maxLevel);
  for (let iBadge = 0; iBadge < G.level; iBadge++) {
    let d1 = iDiv(badges[iBadge]);
    d1.style.opacity = .75;
    d1.style.border = 'transparent';
    d1.children[1].innerHTML = '* ' + (iBadge + 1) + ' *';
    d1.children[0].style.color = 'white';
  }
  let d = iDiv(badges[G.level]);
  d.style.border = '1px solid #00000080';
  d.style.opacity = 1;
  d.children[1].innerHTML = 'Level ' + (G.level + 1);
  d.children[0].style.color = 'white';
  for (let iBadge = G.level + 1; iBadge < badges.length; iBadge++) {
    let d1 = iDiv(badges[iBadge]);
    d1.style.border = 'transparent';
    d1.style.opacity = .25;
    d1.children[1].innerHTML = 'Level ' + (iBadge + 1);
    d1.children[0].style.color = 'black';
  }
}
function setCategories(groupNameList) {
  ensureSymBySet();
  let keys = [];
  for (const cat of groupNameList) {
    let name = cat.toLowerCase();
    for (const k of symKeysBySet[name]) {
      keys.push(k);
    }
  }
  return keys;
}
function setColorPalette(colors, type = 'shade') {
  let pals = colors.map(x => getPalette(x));
  let i = 0;
  let d = 0;
  let ch = ['0', '1', 'h'];
  for (const p of pals) {
    for (const c of p) {
      setCSSVariable('--pal' + ch[i] + '_' + d, c);
      d += 1;
    }
    i += 1;
    d = 0;
  }
  if (nundef(S.pals)) S.pals = pals;
  else { S.pals[0] = pals[0]; S.pals[1] = pals[1]; S.pals[2] = pals[2]; }
}
function setCSSButtonColors(palset, ihue = 0) {
  let root = document.documentElement;
  let pal = palset[ihue];
  let len = pal.length;
  root.style.setProperty('--bbg', pal[2]);
  root.style.setProperty('--bhbg', pal[0]);
  root.style.setProperty('--babg', pal[5]);
  root.style.setProperty('--baltbg', pal[3]);
}
function setCssVar(varname, val) { document.body.style.setProperty(varname, val); }
function setCSSVariable(varName, val) {
  let root = document.documentElement;
  root.style.setProperty(varName, val);
}
function setCurrent(id) {
  if (dCurrent && dCurrent.id == id) return;
  else if (dCurrent) hideCurrent();
  dCurrent = mBy(id); mStyle(dCurrent, { overflow: 'hidden' }); show(id); return dCurrent;
}
function setCurrentInfo(item) {
  currentInfo = item.info;
  matchingWords = currentInfo.words;
  validSounds = currentInfo.valid;
  bestWord = Goal.label;
  hintWord = '_'.repeat(bestWord.length);
}
function setCurrentPath(fname) {
  let pathDictionary = DOC_vault;
  let key = firstCondDict(pathDictionary, x => sameCaseInsensitive(x.filename, fname));
  let entry = DOC_vault[key];
  let index = entry.index;
  setCurrentPathIndex(index);
}
function setCurrentPathIndex(i) {
  if (i == DOC_CURRENT_PATH_INDEX) {
    console.log('current path already set to', i);
    return;
  }
  let curPath = isdef(DOC_CURRENT_PATH_INDEX) ? DOC_dvIndex[DOC_CURRENT_PATH_INDEX] : null;
  let newPath = i >= 0 && i <= DOC_dvIndex.length ? DOC_dvIndex[i] : null;
  if (curPath) {
    let curEntry = DOC_vault[curPath];
    let idDiv = curEntry.idPathContainer;
    hide(idDiv);
  }
  if (newPath) {
    let newEntry = DOC_vault[newPath];
    let idDiv = newEntry.idPathContainer;
    show(idDiv);
    DOC_CURRENT_PATH_INDEX = i;
  }
}
function setDefaultOptions() {
  let opt = { present: { object: {}, player: {} }, game: {} };
  opt.present.object.createDefault = true;
  opt.present.player.createDefault = true;
  opt.present.object.optin = null;
  opt.present.object.optout = ['obj_type', 'id'];
  opt.present.player.optin = null;
  opt.present.player.optout = ['obj_type', 'id'];
  opt.colors = ['#07061c', '#6a1c81', '#f4695c'];
  opt.gap = 0;
  opt.outerGap = false;
  S.options = opt;
}
function setDefaultRSGSettings() {
  S.settings.table.createDefault = true;
  S.settings.player.createDefault = true;
  S.settings.boardDetection = S_boardDetection;
  S.settings.deckDetection = S_deckDetection;
  S.settings.useColorHintForProperties = S_useColorHintForProperties;
  S.settings.useColorHintForObjects = S_useColorHintForObjects;
  S.settings.gameAreaSize = S_boardDetection ? [1000, 800] : [1000, '65vh'];
  S.settings.table.defaultArea = S_defaultObjectArea;
  S.settings.player.defaultArea = S_defaultPlayerArea;
  S.settings.table.optin = null;
  S.settings.table.optout = ['obj_type', 'id'];
  S.settings.onlySimpleValues = true;
  S.settings.player.optin = null;
  S.settings.player.optout = ['id', 'color', 'altName', 'index'];
  S.settings.extendedOptout = { color: 1, altName: 1, index: 1, username: 1, playerType: 1, player: 1, agentType: 1, obj_type: 1, id: 1, visible: 1, neighbors: 1, fields: 1, edges: 1, corners: 1, row: 1, col: 1 };
  S.settings.useExtendedOptout = true;
  S.settings.table.ignoreTypes = [];
  S.settings.pieceSizeRelativeToLoc = {};
  S.settings.pieceSizeRelativeToLoc.corner = ['w', 100];
  S.settings.pieceSizeRelativeToLoc.field = ['w', 30];
  S.settings.pieceSizeRelativeToLoc.edge = ['length', 100];
  S.settings.addSymbolToEdges = false;
  S.settings.symbols = {};
  S.settings.color.theme = '#6B7A8F';
  S.settings.gap = 4;
  S.settings.outerGap = false;
}
function setDefaultSettings() {
  document.getElementById('c_b_TTip').textContent = 'tooltips: ' + S_tooltips;
  let checkedModeInput = document.getElementById('c_b_mm_' + PLAYMODE.toLowerCase());
  checkedModeInput.checked = true;
  S.settings = { table: {}, player: {}, game: {}, color: {} };
  S.settings.seed = SEED;
  S.settings.game = GAME;
  S.settings.playmode = PLAYMODE;
  S.settings.clickToSelect = true;
  S.settings.tooltips = document.getElementById('c_b_TTip').textContent.includes('ON');
  S.settings.openTab = S_openTab;
  S.settings.userSettings = S_userSettings;
  S.settings.userStructures = S_userStructures;
  S.settings.userBehaviors = S_userBehaviors;
  setDefaultRSGSettings();
}
function setDivBg(d1, bg) {
  d1.style.setProperty('background-color', bg);
}
function setDivSize(d1, w, h, unit = 'px') {
  d1.style.setProperty('width', makeUnitString(w, unit));
  d1.style.setProperty('height', makeUnitString(h, unit));
}
function setDropPosition(ev, elem, targetElem, dropPos) {
  if (dropPos == 'mouse') {
    var elm = $(targetElem);
    x = ev.pageX - elm.offset().left - dragStartOffset.x;
    y = ev.pageY - elm.offset().top - dragStartOffset.y;
    posXY(elem, targetElem, x, y);
  } else if (dropPos == 'none') {
    return;
  } else if (dropPos == 'center') {
    elem.style.position = elem.style.left = elem.style.top = '';
    elem.classList.add('centeredTL');
  } else if (dropPos == 'centerCentered') {
    elem.style.position = elem.style.left = elem.style.top = '';
    elem.classList.add('centerCentered');
  } else {
    dropPos(ev, elem, targetElem);
  }
}
function setDropZones(items, handler) {
  DropZones = [];
  DropZoneItems = [];
  for (let i = 0; i < items.length; i++) {
    let d = iDiv(items[i]);
    d.onmouseup = () => handler(items[i]);
    mClass(d, 'dropzone');
    DropZones.push(d);
    DropZoneItems.push(items[i]);
  }
}
function setEquationGoal() {
  let blank = blankWordInputs(G.words, G.numMissing, G.posMissing);
  Goal = { seq: G.seq, words: G.words, chars: G.letters, blankWords: blank.words, blankChars: blank.letters, iFocus: blank.iFocus };
  Goal.qCharIndices = Goal.blankChars.map(x => x.index);
  Goal.qWordIndices = Goal.blankWords.map(x => x.iWord);
  let yes = true;
  for (let i = 0; i < Goal.chars.length; i++) if (Goal.chars[i].index != i) yes = false;
  console.assert(yes == true);
}
function setExpGoal() { }
function setFixedSizeAndPos(n) {
  let ui = n.ui;
  if (nundef(n.params.size)) return;
  n.size = jsCopy(n.params.size);
  n.pos = jsCopy(n.params.pos);
  n.pos.cx = n.pos.x + n.size.w / 2;
  n.pos.cy = n.pos.y + n.size.h / 2;
  ui.style.position = 'absolute';
  ui.style.left = n.pos.x + 'px';
  ui.style.top = n.pos.y + 'px';
  ui.style.minWidth = n.size.w + 'px';
  ui.style.minHeight = n.size.h + 'px';
}
function setFullscreenKey() {
  addKeyup('F11', (ev) => {
    let k = ev.keyCode;
    let key = ev.key;
    toggleSidebar(ev, k, key);
  });
}
function setGame(game, immediate = false) {
  cleanupOldGame();
  resetUIDs();
  if (isdef(G) && G.id != game) Score.gameChange = true;
  G = new (classByName(capitalize(game)))(game, DB.games[game]);
  Settings = new SettingsClass(G, dAux);
  if (nundef(U.games[game])) {
    if (G.controllerType == 'solitaire') { U.games[game] = { nTotal: 0, nCorrect: 0, nCorrect1: 0, startLevel: 0 }; }
    else U.games[game] = {};
  }
  if (isdef(G.maxLevel)) G.level = Math.min(getUserStartLevel(game), G.maxLevel);
  Settings.updateGameValues(U, G);
  saveUser();
  switch (G.controllerType) {
    case 'solitaire': GC = new ControllerSolitaire(G, U); break;
    case 'solo': GC = new ControllerTTT(G, U); break;
    case 'multi': GC = new ControllerMulti(G, U); break;
  }
  G.controller = GC;
  showGameTitle();
  if (immediate) GC.startGame();
}
function setGame_dep(game, immediate = false) {
  cleanupOldGame();
  resetUIDs();
  if (isdef(G) && G.id != game) Score.gameChange = true;
  G = new (classByName(capitalize(game)))(game, DB.games[game]);
  Settings = new SettingsClass(G, dAux);
  if (nundef(U.games[game])) {
    if (G.controllerType == 'solitaire') { U.games[game] = { nTotal: 0, nCorrect: 0, nCorrect1: 0, startlevel: 0 }; }
    else U.games[game] = {};
  }
  if (isdef(G.maxlevel)) G.level = Math.min(getUserStartLevel(game), G.maxlevel);
  Settings.updateGameValues(U, G);
  save_users();
  let s = valf(G.av_modes, 'training');
  let modes = s.split(',');
  if (!modes.includes(Session.def_playmode)) Session.def_playmode = modes[0];
  G.playmode = Session.def_playmode;
  if (nundef(G.controller_class)) G.controller_class = `Controller${capitalize(G.playmode)}`;
  GC = new (classByName(G.controller_class))(G, U);
  G.controller = GC;
  showGameTitle();
  if (immediate) GC.startGame();
}
function setGamePlayer(username) {
  Username = username;
  GAMEPLID = firstCondDict(playerConfig[GAME].players, p => p.username == username);
}
function setGoal(index) {
  if (nundef(index)) {
    let rnd = G.numPics < 2 ? 0 : randomNumber(0, G.numPics - 2);
    if (G.numPics >= 2 && rnd == lastPosition && coin(70)) rnd = G.numPics - 1;
    index = rnd;
  }
  lastPosition = index;
  Goal = Pictures[index];
}
function setGradientImageBackground(d, path, color1 = 'red', color2 = 'green') {
  d.style.background = color1;
  d.style.backgroundImage = `url(${path})`;
  d.style.backgroundImage = `url(${path}), linear-gradient(${color1}, ${color2})`;
  d.style.backgroundSize = '100%';
}
function setGranularityFactor(s, f = 2) {
  let lines = s.split('"');
  let lines1 = lines.filter(x => !isEmptyOrWhiteSpace(x));
  let lines2 = [];
  for (const l of lines1) {
    let lNew = '';
    for (let i = 0; i < l.length; i++) {
      if (l[i] == ' ') continue;
      for (let x = 0; x < f; x++) lNew += l[i] + ' ';
    }
    lines2.push(lNew.trim());
  }
  let lines3 = [];
  for (const l of lines2) { for (let i = 0; i < f; i++) { lines3.push(l); } }
  return lines3;
}
function setGroup(groupName) {
  ensureSymBySet();
  return jsCopy(symKeysBySet[groupName]);
}
function setHNeeded(elem) {
  let sz = getSizeNeeded(elem);
  let r = getRect(elem);
  if (sz.h > r.h && elem.style.height != '100%') { r.h = sz.h; mStyle(elem, { h: r.h }); }
  elem.setAttribute('rect', `${r.w} ${r.h} ${r.t} ${r.l} ${r.b} ${r.r}`);
  return r.h;
}
function SetInitialBoardPieces() {
  var sq;
  var sq120;
  var file, rank;
  var rankName;
  var fileName;
  var imageString;
  var pieceFileName;
  var pce;
  ClearAllPieces();
  for (sq = 0; sq < 64; ++sq) {
    sq120 = SQ120(sq);
    pce = brd_pieces[sq120];
    if (GameController.BoardFlipped == BOOL.TRUE) {
      sq120 = MIRROR120(sq120);
    }
    file = FilesBrd[sq120];
    rank = RanksBrd[sq120];
    if (pce >= PIECES.wP && pce <= PIECES.bK) {
      rankName = "rank" + (rank + 1);
      fileName = "file" + (file + 1);
      pieceFileName = "../base/assets/images/chess/" + SideChar[PieceCol[pce]] + PceChar[pce].toUpperCase() + ".png";
      imageString = "<image src=\"" + pieceFileName + "\" class=\"Piece " + rankName + " " + fileName + "\"/>";
      $("#ChessBoard").append(imageString);
    }
  }
}
function setIsReallyMultiplayer() {
  let gc = S.gameConfig;
  let players = gc.players;
  let foreign = firstCond(players, x => !isMyPlayer(x.id) && x.playerType == 'human');
  isReallyMultiplayer = (foreign != null);
  disableButtonsForMultiplayerGame();
}
function setKeys({ allowDuplicates, nMin = 25, lang, key, keySets, filterFunc, param, confidence, sortByFunc } = {}) {
  let keys = jsCopy(keySets[key]);
  if (isdef(nMin)) {
    let diff = nMin - keys.length;
    let additionalSet = diff > 0 ? nMin > 100 ? firstCondDictKeys(keySets, k => k != key && keySets[k].length > diff) : 'best100' : null;
    if (additionalSet) KeySets[additionalSet].map(x => addIf(keys, x));
  }
  let primary = [];
  let spare = [];
  for (const k of keys) {
    let info = Syms[k];
    info.best = info[lang];
    if (nundef(info.best)) {
      let ersatzLang = (lang == 'D' ? 'D' : 'E');
      let klang = 'best' + ersatzLang;
      if (nundef(info[klang])) info[klang] = lastOfLanguage(k, ersatzLang);
    }
    let isMatch = true;
    if (isdef(filterFunc)) isMatch = isMatch && filterFunc(param, k, info.best);
    if (isdef(confidence)) isMatch = info[klang + 'Conf'] >= confidence;
    if (isMatch) { primary.push(k); } else { spare.push(k); }
  }
  if (isdef(nMin)) {
    let len = primary.length;
    let nMissing = nMin - len;
    if (nMissing > 0) { let list = choose(spare, nMissing); spare = arrMinus(spare, list); primary = primary.concat(list); }
  }
  if (isdef(sortByFunc)) { sortBy(primary, sortByFunc); }
  if (isdef(nMin)) console.assert(primary.length >= nMin);
  if (nundef(allowDuplicates)) {
    primary = removeDuplicates(primary);
  }
  return primary;
}
function setKeysG(g, filterFunc, nMin, key) {
  if (nundef(nMin)) nMin = 25;
  if (isdef(g.numPics)) nMin = Math.max(25, g.numPics);
  return setKeys({ nMin: nMin, lang: g.language, key: valf(key, g.vocab), keySets: KeySets, filterFunc: filterFunc, param: g });
}
function setKeysX({ cats, bestOnly = false, correctOnly = false, sortAccessor }) {
  currentKeys = getKeySetX(isdef(cats) ? cats : currentCategories, currentLanguage, MinWordLength, MaxWordLength,
    bestOnly, sortAccessor, correctOnly, reqOnly);
  if (isdef(sortByFunc)) { sortBy(currentKeys, sortAccessor); }
}
function setLanguage(x) { currentLanguage = x; startLevel(); }
function setLanguageHALLO(l) { Settings.language = G.language = l; Speech.setLanguage(l); console.log('SET LANGUAGE TO', l, G.language, G.lang); }
function setLinearBackground(d, cInner = '#00000080', percentWide, cOuter = 'transparent') {
  if (typeof cInner == 'function') cInner = cInner();
  d.style.background = `linear-gradient(to right, ${cOuter} 0%, ${cInner} ${percentWide}%,${cInner} ${100 - percentWide}%, ${cOuter}) 100%`;
}
function setMessage(msg) { const parent = document.getElementById('status_message'); parent.innerHTML = msg; }
function setMultiGoal(n, indices) {
  Goal = { pics: [] };
  if (nundef(indices)) {
    Goal.pics = choose(Pictures, n);
  } else {
    for (const i of indices) Goal.pics.push(Pictures[i]);
  }
}
function setNewBackgroundColor(bg) {
  if (nundef(bg)) bg = randomDarkColor();
  BaseColor = bg; HeaderColor = colorDarker(BaseColor); SidebarColor = colorLighter(BaseColor, .125);
  setBackgroundColor(bg);
  mStyleX(dHeader, { bg: HeaderColor });
  mStyleX(mBy('sidebar'), { bg: SidebarColor });
  mStyleX(mBy('dAux'), { bg: SidebarColor });
  localStorage.setItem('BaseColor', BaseColor);
  if (isdef(G)) G.settings.baseColor = bg;
}
function setNextGame() {
  let game = G.id;
  let i = U.avGames.indexOf(game);
  let iNew = (i + 1) % U.avGames.length;
  setGame(U.avGames[iNew]);
}
function setNumberSequenceGoal() {
  let blank = blankWordInputs(G.words, G.numMissing, G.posMissing);
  Goal = { seq: G.seq, words: G.words, chars: G.letters, blankWords: blank.words, blankChars: blank.letters, iFocus: blank.iFocus };
  Goal.qCharIndices = Goal.blankChars.map(x => x.index);
  Goal.qWordIndices = Goal.blankWords.map(x => x.iWord);
}
function setOrigin(g, center = true) {
  if (center) g.setAttribute('class', 'gCentered');
  else g.setAttribute('class', null);
}
function setPageBackground(bg, fg = 'white', isBase = true) {
  bg = colorHex(bg);
  if (isBase) DA.pageBaseColor = bg;
  mStyleX(dMain, { bg: bg, fg: isdef(fg) ? fg : 'contrast' });
}
function setPicsPerLevel() {
  let inp = mBy('inputPicsPerLevel');
  inp.select();
  let x = getSelection();
  let n = Number(x.toString());
  inp.value = n;
  getSelection().removeAllRanges();
  PICS_PER_LEVEL = n;
  SAMPLES_PER_LEVEL = new Array(20).fill(PICS_PER_LEVEL);
  boundary = SAMPLES_PER_LEVEL[currentLevel];
}
function setPlayer(g, pl) {
  let idx;
  if (isdef(g.iPlayer)) {
    idx = (g.iPlayer + 1) % g.players.length;
  } else if (isdef(pl)) {
    idx = g.players.indexOf(pl);
  } else idx = 0;
  pl = g.players[idx];
  [GC.iPlayer, GC.plTurn] = [g.iPlayer, g.plTurn] = [idx, pl];
}
function setPlayMode(mode, isStartup = false) {
  if (mode != S.settings.playMode) S.playModeChanged = true;
  PLAYMODE = mode;
  console.log('playMode:', S.settings.playMode, 'PLAYMODE', PLAYMODE)
  setAutoplayFunctionForMode(mode, isStartup);
  if (mode == 'solo') {
    hide(document.getElementById('c_b_join'));
    hide(document.getElementById('c_b_NextPlayer'));
    hide(document.getElementById('c_b_RunToEnd'));
  } else if (mode == 'hotseat') {
    hide(document.getElementById('c_b_join'));
    show(document.getElementById('c_b_NextPlayer'));
    show(document.getElementById('c_b_RunToEnd'));
  } else if (mode == 'multiplayer') {
    show(document.getElementById('c_b_join'));
    hide(document.getElementById('c_b_NextPlayer'));
    hide(document.getElementById('c_b_RunToEnd'));
  }
}
function setPlaymode(mode, isStartup = false) {
  if (mode != S.settings.playmode) S.playModeChanged = true;
  S.settings.playmode = PLAYMODE = mode;
  setAutoplayFunctionForMode(mode, isStartup);
  return mode;
}
function setPositionData(g1) {
  let ids = g1.getNodeIds();
  for (const id of ids) {
    let pos = g1.getProp(id, 'center');
    g1.setPosition(id, pos.x, pos.y);
  }
  g1.reset();
}
function setRect(elem, options) {
  let r = getRect(elem);
  elem.rect = r;
  elem.setAttribute('rect', `${r.w} ${r.h} ${r.t} ${r.l} ${r.b} ${r.r}`);
  if (isDict(options)) {
    if (options.hgrow) mStyle(elem, { hmin: r.h });
    else if (options.hfix) mStyle(elem, { h: r.h });
    else if (options.hshrink) mStyle(elem, { hmax: r.h });
    if (options.wgrow) mStyle(elem, { wmin: r.w });
    else if (options.wfix) mStyle(elem, { w: r.w });
    else if (options.wshrink) mStyle(elem, { wmax: r.w });
  }
  return r;
}
function setRectInt(elem, options) {
  let r = getRectInt(elem);
  elem.rect = r;
  elem.setAttribute('rect', `${r.w} ${r.h} ${r.t} ${r.l} ${r.b} ${r.r}`);
  if (isDict(options)) {
    if (options.hgrow) mStyle(elem, { hmin: r.h });
    else if (options.hfix) mStyle(elem, { h: r.h });
    else if (options.hshrink) mStyle(elem, { hmax: r.h });
    if (options.wgrow) mStyle(elem, { wmin: r.w });
    else if (options.wfix) mStyle(elem, { w: r.w });
    else if (options.wshrink) mStyle(elem, { wmax: r.w });
  }
  return r;
}
function setReloadOnClick() {
  window.onclick = (ev) => {
    if (!['dStatusLine', 'header', 'inner_left_panel', 'left_panel'].includes(ev.target.id)) return;
    reload();
    mBy('dStatusLine').innerHTML = 'last reload: ' + formatNow();
  };
}
function setRSG_SOURCE(val) {
  if (RSG_SOURCE == 'test' && val == 'main') {
    let d = mBy('table');
    clearElement(d);
    d.style.minHeight = 0;
    d.style.minWidth = 0;
  }
  RSG_SOURCE = val;
  showMenu(val);
}
function setSettingsKeys(elem) {
  let val = elem.type == 'number' ? Number(elem.value) : elem.type == 'checkbox' ? elem.checked : elem.value;
  lookupSetOverride(Settings, elem.keyList, val);
  SettingsChanged = true;
  console.log(elem.keyList, val)
}
function setSettingsKeysSelect(elem) {
  let val;
  for (const opt of elem.children) {
    if (opt.selected) val = opt.value;
  }
  SettingsChanged = true;
  lookupSetOverride(Settings, elem.keyList, val);
}
function setSide(cardDiv, newSide) {
  if (!cardDiv.isCard) return;
  let faceElem = cardDiv.faceElem;
  let backElem = cardDiv.backElem;
  if (newSide === 'front') {
    if (cardDiv.side === 'back') {
      cardDiv.removeChild(backElem);
    }
    cardDiv.side = 'front';
    cardDiv.appendChild(faceElem);
    cardDiv.setAttribute('class', 'cardMy ' + getSuitName(cardDiv.suit) + ' rank' + cardDiv.rank);
  } else {
    if (cardDiv.side === 'front') {
      cardDiv.removeChild(faceElem);
    }
    cardDiv.side = 'back';
    cardDiv.appendChild(backElem);
    cardDiv.setAttribute('class', 'cardMy');
  }
}
function setSizeNeeded(elem) {
  let sz = getSizeNeeded(elem);
  let r = getRect(elem);
  if (sz.w > r.w && elem.style.width != '100%') { r.w = sz.w; mStyle(elem, { w: r.w }); }
  if (sz.h > r.h && elem.style.height != '100%') { r.h = sz.h; mStyle(elem, { h: r.h }); }
  elem.setAttribute('rect', `${r.w} ${r.h} ${r.t} ${r.l} ${r.b} ${r.r}`);
  return r;
}
function setSP(n) {
  let ui = n.ui;
  let b = getBounds(ui, true);
  n.size = { w: b.width, h: b.height };
  n.pos = { x: b.x, y: b.y };
}
function setSpeechResult(transcript, conf1, conf2, isFinal = false) {
  Goal.reqAnswer = bestWord;
  Goal.answer = transcript;
  Goal.confidence = conf1;
  Goal.confidence2 = conf2;
  Goal.isSpeechResultFinal = isFinal;
  if (RecogHighPriorityOutput)
    console.log('*=' + (isFinal ? 'final' : 'interim') + '==>', 'best:' + bestWord, 'got:' + transcript,
      '(confid: ' + conf1 + '/' + conf2 + ')');
}
function SetSqSelected(sq) {
  if (GameController.BoardFlipped == BOOL.TRUE) {
    sq = MIRROR120(sq);
  }
  $(".Square").each(function (index) {
    if ((RanksBrd[sq] == 7 - Math.round($(this).position().top / 60)) && (FilesBrd[sq] == Math.round($(this).position().left / 60))) {
      $(this).addClass('SqSelected');
    }
  });
}
function setStatus(s) {
  let areaName = isPlain() ? 'c_d_statusInHeaderText' : 'c_d_statusText';
  let d = document.getElementById(areaName);
  let mobj = UIS[areaName];
  mobj.clear(); clearElement(d);
  d.innerHTML = s;
}
function setSubtitle(s) { mBy('dSubtitle').innerHTML = s; }
function setSymLabel(g, id, key, styles = {}) {
  if (nundef(Syms[key])) return;
  let info = Syms[key];
  console.log('family', info.family);
  g.setLabel(id, info.text, addKeys({ fz: 40, family: info.family }, styles));
}
function setTableBackground(bg, fg = 'white', isBase = true) {
  bg = colorHex(bg);
  if (isBase) DA.tableBaseColor = bg;
  mStyleX(dTableBackground, { bg: bg, fg: isdef(fg) ? fg : 'contrast' });
}
function setTableSize(w, h, unit = 'px') {
  let d = mBy('areaTable');
  mStyle(d, { 'min-width': w, 'min-height': h }, unit);
}
function setText(card, text, fz = '8') {
  let el = card.elem;
  if (el.children.length > 1) {
    let elTitle = el.firstChild;
    clearElement(el);
    el.appendChild(elTitle);
  }
  let dText = document.createElement('div');
  el.appendChild(dText);
  dText.style.color = 'black';
  dText.innerHTML = text;
  dText.style.margin = '8px';
  dText.style.fontSize = fz + 'px';
}
function setTheme_dep(isDark = true) {
  let bg = dMain.style.backgroundColor;
  let lum = getBrightness(bg);
  console.log('bg is', bg, 'lum', lum)
  if (isDark) {
    if (lum < .5) return;
    else {
      bg = colorDarker(bg);
      setPageBackground(bg);
    }
  } else if (lum > .5) return; else { setPageBackground(colorLighter(bg)); }
}
function setTitle(s) { mBy('hTitle').innerHTML = s; }
function setTransformDOM(el, { x, y, scaleX, scaleY, rotDeg } = {}) {
  let info = getTransformInfoDOM(el);
  console.log('______________\n', info)
  let xNew, yNew, scaleXNew, scaleYNew, rotNew;
  if (isdef(x)) xNew = x; else xNew = info.translateX;
  if (isdef(y)) yNew = y; else yNew = info.translateY;
  if (isdef(scaleX)) scaleXNew = scaleX; else scaleXNew = info.scaleX;
  if (isdef(scaleY)) scaleYNew = scaleY; else scaleYNew = info.scaleY;
  if (isdef(rotDeg)) rotNew = rotDeg; else rotNew = info.rotation;
  let sTrans = ''; let sScale = ''; let sRot = '';
  console.log('xNew', xNew, 'yNew', yNew, 'scaleXNew', scaleXNew, 'scaleYNew', scaleYNew, 'rotNew', rotNew)
  if (xNew != 0 || yNew != 0) sTrans = `translate(${xNew}, ${yNew})`;
  if (scaleXNew != 1 || scaleYNew != 1) sScale = `scale(${scaleXNew} ${scaleYNew})`;
  if (rotNew != 0) sRot = `rotate(${rotNew})`;
  let s = (sTrans + ' ' + sScale + ' ' + sRot).trim();
  console.log('new transform:', s)
  el.style.transform = s;
}
function setup() {
  axiom = system.axiom;
  rules = system.rules;
  factor = valf(system.factor, 1);
  angle = radians(valf(system.angle, 60));
  sentence = axiom;
  let button = createButton("generate"); button.mousePressed(generate);
  button = createButton("animate"); button.mousePressed(() => interval_id = setInterval(generate, 500));
  createCanvas(400, 400);
  background(51);
  createP(axiom);
  turtle();
}
function setUpMinuteHands() {
  var containers = document.querySelectorAll('.minutes-container');
  var secondAngle = containers[0].getAttribute("data-second-angle");
  if (secondAngle > 0) {
    var delay = (((360 - secondAngle) / 6) + 0.1) * 1000;
    setTimeout(function () {
      moveMinuteHands(containers);
    }, delay);
  }
}
function setUserData(username) {
  if (nundef(DB.users[username])) {
    U = DB.users[username] = jsCopy(DB.users.guest0);
    U.id = U.name = U.username = Username = username;
  } else {
    U = DB.users[username]; U.name = U.username = Username = U.id;
  }
  U.clientId = ClientId;
}
function setUsername(inputElem) {
  USERNAME = inputElem.value.toString();
}
function setUserSpecAndCode() {
  S.user.spec = userSpec;
  S.user.specText = userSpec.asText;
  S.user.script = userCode.asText;
}
function setVocabulary(words) {
  var grammar = '#JSGF V1.0; grammar colors; public <color> = hallo';
  for (const w of words) {
    grammar += ' | ' + w;
  }
  var speechRecognitionList = new webkitSpeechGrammarList();
  speechRecognitionList.addFromString(grammar, 1);
  recognition.grammars = speechRecognitionList;
}
function setWNeeded(elem) {
  let sz = getSizeNeeded(elem);
  let r = getRect(elem);
  if (sz.w > r.w && elem.style.width != '100%') { r.w = sz.w; mStyle(elem, { w: r.w }); }
  elem.setAttribute('rect', `${r.w} ${r.h} ${r.t} ${r.l} ${r.b} ${r.r}`);
  return r.w;
}
function setzeEineCheckbox(dParent, label, init, skeys) {
  let d = mDiv(dParent);
  let val = lookup(Settings, skeys);
  if (nundef(val)) val = init;
  let inp = createElementFromHTML(
    `<input type="checkbox" class="checkbox" ` + (val === true ? 'checked=true' : '') + ` onfocusout="setSettingsKeys(this)" >`
  );
  let labelui = createElementFromHTML(`<label>${label}</label>`);
  mAppend(d, labelui);
  mAppend(labelui, inp);
  mStyleX(inp, { maleft: 12, mabottom: 4 });
  mClass(inp, 'input');
  inp.keyList = skeys;
}
function setzeEineZahl(dParent, label, init, skeys) {
  let d = mDiv(dParent);
  let val = lookup(Settings, skeys);
  if (nundef(val)) val = init;
  let inp = createElementFromHTML(
    `<input type="number" class="input" value="${val}" onfocusout="setSettingsKeys(this)" />`);
  let labelui = createElementFromHTML(`<label>${label}</label>`);
  mAppend(d, labelui);
  mAppend(labelui, inp);
  mStyleX(inp, { maleft: 12, mabottom: 4 });
  mClass(inp, 'input');
  inp.keyList = skeys;
}
function setzeEinOptions(dParent, label, optionList, friendlyList, init, skeys) {
  let d = mDiv(dParent);
  let val = lookup(Settings, skeys);
  if (nundef(val)) val = init;
  let inp = createElementFromHTML(`<select class="options" onfocusout="setSettingsKeysSelect(this)"></select>`);
  for (let i = 0; i < optionList.length; i++) {
    let opt = optionList[i];
    let friendly = friendlyList[i];
    let optElem = createElementFromHTML(`<option value="${opt}">${friendly}</option>`);
    mAppend(inp, optElem);
    if (opt == val) optElem.selected = true;
  }
  let labelui = createElementFromHTML(`<label>${label}</label>`);
  mAppend(d, labelui);
  mAppend(labelui, inp);
  mStyleX(inp, { maleft: 12, mabottom: 4 });
  inp.keyList = skeys;
}
function shake_and_sieve(items) { }
function sheriff() {
  function sheriff_activate() {
    sheriff_pre_action();
  }
  function sheriff_check_gameover(z) {
    let [fen, round] = [z.fen, z.round];
    if (round <= z.rounds) return false;
    return arr_get_max(fen.plorder, x => fen.players[x].score);
  }
  function sheriff_setup(players, options) {
    let fen = { players: {}, plorder: jsCopy(players), history: [] };
    let di = SHERIFF.cards;
    let deck = fen.deck = [];
    deck.push(...Array(48).fill('apples'));
    deck.push(...Array(36).fill('cheese'));
    deck.push(...Array(24).fill('pineapple'));
    deck.push(...Array(36).fill('bread'));
    deck.push(...Array(22).fill('pepper'));
    deck.push(...Array(21).fill('mead'));
    deck.push(...Array(12).fill('silk'));
    deck.push(...Array(5).fill('crossbow'));
    for (const name of ['chestnut', 'pear', 'pie', 'baguette', 'cherries']) deck.push(...Array(2).fill(name));
    for (const name of ['pretzel', 'grapes']) deck.push(name);
    shuffle(deck);
    console.log('deck', deck);
    for (const plname of players) {
      let pl = fen.players[plname] = {
        hand: deck_deal(deck, 6),
        coins: 50,
        vps: 0,
        score: 0,
        color: get_user_color(plname),
      };
    }
    console.log('fen', fen)
    fen.phase = 'market';
    fen.stage = 1;
    fen.turn = [fen.plorder[0]];
    return fen;
  }
  function sheriff_present(z, dParent, uplayer) {
    let [fen, ui] = [z.fen, UI];
    let [dOben, dOpenTable, dMiddle, dRechts] = tableLayoutMR(dParent);
    ari_player_stats(z, dRechts);
    show_history(fen, dRechts);
    let deck = ui.deck = ui_type_deck(fen.deck, dOpenTable, { maleft: 12 }, 'deck', 'deck', ari_get_card);
    let market = ui.market = ui_type_market(fen.market, dOpenTable, { maleft: 12 }, 'market', 'market', ari_get_card, true);
    let open_discard = ui.open_discard = ui_type_market(fen.open_discard, dOpenTable, { maleft: 12 }, 'open_discard', 'discard', ari_get_card);
    let deck_discard = ui.deck_discard = ui_type_deck(fen.deck_discard, dOpenTable, { maleft: 12 }, 'deck_discard', '', ari_get_card);
    if (exp_commissions(z.options)) {
      let open_commissions = ui.open_commissions = ui_type_market(fen.open_commissions, dOpenTable, { maleft: 12 }, 'open_commissions', 'bank', ari_get_card);
      mMagnifyOnHoverControlPopup(ui.open_commissions.cardcontainer);
      let deck_commission = ui.deck_commission = ui_type_deck(fen.deck_commission, dOpenTable, { maleft: 4 }, 'deck_commission', '', ari_get_card);
      let comm = ui.commissioned = ui_type_rank_count(fen.commissioned, dOpenTable, {}, 'commissioned', 'sentiment', ari_get_card);
      if (comm.items.length > 0) { let isent = arrLast(comm.items); let dsent = iDiv(isent); set_card_border(dsent, 15, 'green'); }
    }
    let order = [uplayer].concat(fen.plorder.filter(x => x != uplayer));
    for (const plname of order) {
      let pl = fen.players[plname];
      let playerstyles = { w: '100%', bg: '#ffffff80', fg: 'black', padding: 4, margin: 4, rounding: 10, border: `2px ${get_user_color(plname)} solid` };
      let d = mDiv(dMiddle, playerstyles, null, get_user_pic_html(plname, 25));
      mFlexWrap(d);
      mLinebreak(d, 10);
      ari_present_player(z, plname, d, plname != uplayer);
    }
    if (isdef(fen.winners)) ari_reveal_all_buildings(fen);
  }
  function ari_present_player(g, plname, d, ishidden = false) {
    let fen = g.fen;
    let pl = fen.players[plname];
    let ui = UI.players[plname] = {};
    pl.hand = fen.stage == '1' ? sort_cards(pl.hand, true, 'CDSH', true, 'A23456789TJQK') : sort_cards(pl.hand, false, null, true, 'A23456789TJQK');
    let hand = ui.hand = ui_type_hand(pl.hand, d, {}, `players.${plname}.hand`, 'hand', ari_get_card);
    if (ishidden) { hand.items.map(x => face_down(x)); }
    let stall = ui.stall = ui_type_market(pl.stall, d, { maleft: 12 }, `players.${plname}.stall`, 'stall', ari_get_card);
    if (fen.stage < 5 && ishidden) { stall.items.map(x => face_down(x)); }
    ui.buildinglist = [];
    for (const k in pl.buildings) {
      let i = 0;
      for (const b of pl.buildings[k]) {
        let type = k;
        let b_ui = ui_type_building(b, d, { maleft: 8 }, `players.${plname}.buildings.${k}.${i}`, type, ari_get_card);
        b_ui.type = k;
        ui.buildinglist.push(b_ui);
        lookupAddToList(ui, ['buildings', k], b_ui);
        i += 1;
      }
    }
    if (exp_commissions(g.options) && (!ishidden || isdef(fen.winners))) {
      pl.commissions.sort();
      ui.commissions = ui_type_market(pl.commissions, d, { maleft: 12 }, `players.${plname}.commissions`, 'commissions', ari_get_card);
      mMagnifyOnHoverControlPopup(ui.commissions.cardcontainer);
    }
    ui.journeys = [];
    let i = 0;
    for (const j of pl.journeys) {
      let jui = ui_type_hand(j, d, { maleft: 12 }, `players.${plname}.journeys.${i}`, '', ari_get_card);
      i += 1;
      ui.journeys.push(jui);
    }
  }
  function ari_player_stats(z, dParent) {
    let player_stat_items = UI.player_stat_items = ui_player_info(z, dParent);
    let fen = z.fen;
    let herald = fen.heraldorder[0];
    for (const uname of fen.plorder) {
      let pl = fen.players[uname];
      let item = player_stat_items[uname];
      let d = iDiv(item); mCenterFlex(d); mLinebreak(d);
      if (uname == herald) {
        mSym('tied-scroll', d, { fg: 'gold', fz: 24, padding: 4 }, 'TR');
      }
      player_stat_count('coin', pl.coins, d);
      if (!isEmpty(fen.players[uname].stall) && fen.stage >= 5 && fen.stage <= 6) {
        player_stat_count('shinto shrine', !fen.actionsCompleted.includes(uname) || fen.stage < 6 ? calc_stall_value(fen, uname) : '_', d);
      }
      player_stat_count('star', uname == U.name || isdef(fen.winners) ? ari_calc_real_vps(fen, uname) : ari_calc_fictive_vps(fen, uname), d);
      if (fen.turn.includes(uname)) {
        show_hourglass(uname, d, 30, { left: 10, top: 'calc( 50% - 36px )' });
      }
    }
  }
  function sheriff_state(dParent) {
    function get_phase_html() {
      if (isEmpty(Z.phase) || Z.phase == 'over') return null;
      let rank = Z.phase[0].toUpperCase();
      let card = ari_get_card(rank + 'Hn', 40);
      let d = iDiv(card);
      mClassRemove(d.firstChild, 'card');
      return iDiv(card).outerHTML;
    }
    let user_html = get_user_pic_html(Z.uplayer, 30);
    let phase_html = get_phase_html();
    if (phase_html) dParent.innerHTML = `${Z.phase}:&nbsp;${phase_html}&nbsp;player: ${user_html} `;
  }
  return { state_info: sheriff_state, setup: sheriff_setup, present: sheriff_present, present_player: ari_present_player, check_gameover: sheriff_check_gameover, stats: ari_player_stats, activate_ui: sheriff_activate };
}
function sheriff_card(name, color) {
  let di = SHERIFF.cards;
  let info = valf(di[name], { ksym: 'crossbow', kcenter: 'green apple', label: 'crossbow', type: 'contraband', value: 9, penalty: 4 });
  let bcolor = SHERIFF.color[info.type];
  let c = cPortrait(null, { margin: 12, border: `solid 4px ${bcolor}`, bg: valf(color, colorLight('gold', 60)) });
  let d = iDiv(c);
  let ds = mSym(info.ksym, d, { sz: 30 }, 'tl');
  ds = mSymText(info.value, d, { sz: 25, rounding: '50%', bg: 'gold', margin: 3 }, 'tr');
  ds = mText(info.label.toUpperCase(), d, { family: 'Algerian', w: '100%', fz: 12, align: 'center', position: 'absolute', bottom: 0 });
  ds = mText(info.label.toUpperCase(), d, { family: 'Algerian', w: '100%', fz: 12, align: 'center', position: 'absolute', top: 0 });
  ds = mSymText(info.penalty, d, { sz: 25, rounding: '50%', bg: 'crimson', margin: 3 }, 'br');
  ds = mSym(info.kcenter, d, { sz: 70 }, 'cc'); mPos(ds, 'calc( 50% - 35px )', 'calc( 50% - 35px )');
  return c;
}
function sheriff_pre_action() {
  let [stage, A, fen, phase, uplayer, deck, market] = [Z.stage, Z.A, Z.fen, Z.phase, Z.uplayer, Z.deck, Z.market];
  if (Z.num_actions > 0) fen.progress = `(action ${Z.action_number} of ${Z.total_pl_actions})`; else delete fen.progress;
  switch (ARI.stage[stage]) {
    case 'journey': select_add_items(ui_get_hand_and_journey_items(uplayer), process_journey, 'may form new journey or add cards to existing one'); break;
    case 'add new journey': post_new_journey(); break;
    case 'auto market': ari_open_market(fen, phase, deck, market); break;
    case 'stall selection': select_add_items(ui_get_hand_items(uplayer), post_stall_selected, 'must select your stall'); break;
    case 'action: command': Z.stage = 6; select_add_items(ui_get_commands(uplayer), process_command, 'must select an action', 1, 1); break;
    case 'tax': let n = fen.pl_tax[uplayer]; select_add_items(ui_get_hand_items(uplayer), post_tax, 'must pay tax', n, n); break;
    case 'action step 2':
      switch (A.command) {
        case 'trade': select_add_items(ui_get_trade_items(uplayer), post_trade, 'must select 2 cards to trade', 2, 2); break;
        case 'build': select_add_items(ui_get_payment_items('K'), payment_complete, 'must select payment for building', 1, 1); break;
        case 'upgrade': select_add_items(ui_get_payment_items('K'), payment_complete, 'must select payment for upgrade', 1, 1); break;
        case 'downgrade': select_add_items(ui_get_building_items(uplayer, A.payment), process_downgrade, 'must select a building to downgrade', 1, 1); break;
        case 'pickup': select_add_items(ui_get_stall_items(uplayer), post_pickup, 'must select a stall card to take into your hand', 1, 1); break;
        case 'harvest': select_add_items(ui_get_harvest_items(uplayer), post_harvest, 'must select a farm to harvest from', 1, 1); break;
        case 'sell': select_add_items(ui_get_stall_items(uplayer), post_sell, 'must select 2 stall cards to sell', 2, 2); break;
        case 'buy': select_add_items(ui_get_payment_items('J'), payment_complete, 'must select payment option', 1, 1); break;
        case 'exchange': select_add_items(ui_get_exchange_items(uplayer), post_exchange, 'must select cards to exchange', 2, 2); break;
        case 'visit': select_add_items(ui_get_payment_items('Q'), payment_complete, 'must select payment for visiting', 1, 1); break;
        case 'commission': select_add_items(ui_get_commission_items(uplayer), process_commission, 'must select a card to commission', 1, 1); break;
        case 'pass': post_pass(); break;
      }
      break;
    case 'build': select_add_items(ui_get_build_items(uplayer, A.payment), post_build, 'must select cards to build (first card determines rank)', 4, 6); break;
    case 'commission new': select_add_items(ui_get_commission_new_items(uplayer), post_commission, 'must select a new commission', 1, 1); break;
    case 'upgrade': select_add_items(ui_get_build_items(uplayer, A.payment), process_upgrade, 'must select card(s) to upgrade a building', 1); break;
    case 'select building to upgrade': select_add_items(ui_get_farms_estates_items(uplayer), post_upgrade, 'must select a building', 1, 1); break;
    case 'select downgrade cards': select_add_items(A.possible_downgrade_cards, post_downgrade, 'must select card(s) to downgrade a building', 1); break;
    case 'buy': select_add_items(ui_get_open_discard_items(uplayer, A.payment), post_buy, 'must select a card to buy', 1, 1); break;
    case 'visit': select_add_items(ui_get_other_buildings(uplayer, A.payment), process_visit, 'must select a farm to visit', 1, 1); break;
    case 'visit destroy': select_add_items(ui_get_string_items(['destroy', 'get cash']), post_visit, 'must destroy the building or select the cash', 1, 1); break;
    case 'ball': select_add_items(ui_get_hand_items(uplayer), post_ball, 'may add cards to the ball'); break;
    case 'auction: bid': select_add_items(ui_get_coin_amounts(uplayer), process_auction, 'must bid for the auction', 1, 1); break;
    case 'auction: buy': select_add_items(ui_get_market_items(), post_auction, 'must buy a card', 1, 1); break;
    case 'end game?': select_add_items(ui_get_endgame(uplayer), post_endgame, 'may end the game here and now or go on!', 1, 1); break;
    case 'pick luxury or journey cards': select_add_items(ui_get_string_items(['luxury cards', 'journey cards']), post_luxury_or_journey_cards, 'must select luxury cards or getting cards from the other end of the journey', 1, 1); break;
    default: console.log('stage is', stage); break;
  }
}
function shield_off() {
  mStyle('dAdmin', { bg: 'white' });
}
function shield_on() {
  mShield(dTable.firstChild.childNodes[1]);
  mStyle('dAdmin', { bg: 'silver' });
}
function shortHintPic() {
  mClass(mBy(Goal.id), 'onPulse1');
  TOMain = setTimeout(() => shortHintPicRemove(), 800);
}
function shortHintPicRemove() {
  mRemoveClass(mBy(Goal.id), 'onPulse1');
}
function show(elem, isInline = false) {
  if (isString(elem)) elem = document.getElementById(elem);
  if (isSvg(elem)) {
    elem.setAttribute('style', 'visibility:visible');
  } else {
    elem.style.display = isInline ? 'inline-block' : null;
  }
  return elem;
}
function show_account() {
  if (isdef(mBy('dAccount').firstChild)) { console.log('NOPE!'); return; }
  DA.imageChanged = false;
  let dParent = mBy('dAccount');
  clearElement(dParent);
  let d = mDiv(dParent, { matop: 20 });
  let dir = '../base/assets/images/';
  let imagePath = dir + (Userdata.hasImage ? Username : 'unknown_user') + '.jpg';
  d.append(createElementFromHtml(`
  <div class="wrapper" style="margin-top:5%; animation: appear 4s ease;">
  <div id="error">some text</div>
  <form id="myform" autocomplete="off" action="index.php" method="POST">
    <div id='dImage'>
      <span style="font-size:11px;">drag and drop an image to change</span><br>
      <img id="imgPreview" src='${imagePath}' ondragover="handle_drag_and_drop(event)" ondrop="handle_drag_and_drop(event)" ondragleave="handle_drag_and_drop(event)"
        style="height:200px;margin:10px;" />
    </div>
    <input id='iUsername' type="text" name="username" placeholder='username' value="${Username}" autofocus />
    <br />
    <!-- <input type="password" name="password" />
    <br /> -->
    <input type="submit" />
  </form>
  </div>
  `));
  var form = document.getElementById('myform');
  form.onsubmit = e => {
    e.preventDefault();
    let el = document.getElementById('iUsername');
    let val = el.value;
    if (Username != val) {
      onClickSubmitUsernameChange(val);
    } else if (DA.imageChanged) {
      onClickSubmitImageChange();
    }
  };
}
function show_admin_ui() {
  for (const id of ['bSpotitStart', 'bClearAck', 'bRandomMove', 'bSkipPlayer', 'bRestartMove']) hide(id);
  if (Z.game == 'spotit' && Z.uname == Z.host && Z.stage == 'init') show('bSpotitStart');
  else if (Z.game == 'bluff' && Z.uname == Z.host && Z.stage == 1) show('bClearAck');
  else if (Z.uname == Z.host && Z.stage == 'round_end') show('bClearAck');
  else if (Z.game == 'ferro' && Z.uname == 'mimi' && Z.stage != 'card_selection') show('bClearAck');
  if (['ferro', 'bluff', 'aristo', 'a_game'].includes(Z.game) && (Z.role == 'active' || Z.mode == 'hotseat')) {
    show('bRandomMove');
  }
  if (Z.uname == Z.host || Z.uname == 'mimi') show('dHostButtons'); else hide('dHostButtons');
  if (DA.TEST0 == true) show('dTestButtons'); else hide('dTestButtons');
}
function show_advanced_ui() {
  show('dButtons');
  show('dTest0');
  show('dTopAdvanced');
  DA.testing = true;
  DA.test = { iter: 0, maxiter: 200, running: false, step: true, suiteRunning: false, number: 0, list: [100, 101] };
  DA.test.list = arrRange(100, 101);
  DA.test.number = 306;
  DA.staged_moves = []; DA.iter = 100; DA.auto_moves = {};
}
function show_all_players() { populate_players(get_def_players_for_user(Session.cur_user)); }
function show_apps(ms = 500) {
  let dParent = mBy('dApps');
  if (!isEmpty(arrChildren(dParent))) { show(dParent); return; }
  show_standard_title(dParent, 'Apps');
  let d = mDiv(dParent, { fg: 'white' }, 'apps_menu');
  mCenterFlex(d);
  let applist = 'action book fitbit howto magic meditate therapy';
  for (const id of toWords(applist)) {
    let app = DB.apps[id]; app.name = id; let f = get_app_presenter(app.id); f(d, app);
  }
}
function show_available_voices() { say('', 'english male', () => console.log(DA.voicelist.map(x => x.name))); }
function show_bars() {
  let d = mDiv(dTable, { w: '100%', box: true, opacity: 0 }, 'dBars');
  mLinebreak(d);
  let dgreen = get_plus_progressbar(d, 'green');
  mLinebreak(d);
  let dred = get_plus_progressbar(d, 'red');
  mLinebreak(d);
  DA.bars = {
    green: dgreen,
    red: dred,
  };
  return d;
}
function show_bill_button() {
  if (isdef(mBy('tbbill'))) return;
  let tb = mBy('dTopRight');
  let b = mDiv(tb, {}, `tbbill`, `<a href="javascript:onclick_bill()"><img src="../rechnung/images/bill.png" height="30"/></a>`);
  mInsert(tb, b);
}
function show_card(dParent, key, type = 'aristo') {
  if (type == 'spotit') {
    Card.sz = 200;
    let [rows, cols, numCards, setName] = [3, 2, 2, valf(key, 'animals')];
    let infos = spotitDeal(rows, cols, numCards, setName);
    let items = [];
    for (const info of infos) {
      let item = spotitCard(info, dParent, { margin: 10 }, spotitOnClickSymbol);
      mStyle(iDiv(item), { padding: 12 });
      items.push(item);
    }
  } else if (type == 'aristo') {
    let card = ari_get_card(valf(key, 'ASr'));
    mAppend(dParent, iDiv(card))
  }
}
function show_checkmark(dParent, styles = { fg: 'limegreen' }) {
  let b = getRect(dParent);
  let fz = b.h;
  if (nundef(styles.fz)) styles.fz = fz;
  let d1 = mDiv(document.body, { position: 'fixed', w: b.w, h: b.h, top: b.t, left: b.l, align: 'center', overflow: 'visible' });
  let d2 = mDiv(d1);//,{},null,'A');  //&#10003;');//'H');
  mClass(d1, 'no_events');
  d2.innerHTML = 'A';
  d2.style.fontSize = '' + Math.round(b.h) + 'px';
  d2.style.color = 'green';
  Markers.push(d1);
  // let d=mDiv(document.body,styles1,null,'hallo'); //'&#10003;');
}
function show_click_vocab() {
  let cmd = 'click';
  let vocab = Goal.label;
  let voice = G.language;
  let dParent = dTitle;
  let fz = 36;
  let fSpeak = () => {
    Speech.say(cmd, 1, .8, .9, 'random', () => {
      Speech.say(vocab, 1, .8, .9, voice);
    }, 'E');
  };
  fSpeak();
  clearElement(dParent);
  let d = mDiv(dParent);
  mStyle(d, { margin: 15 })
  mClass(d, 'flexWrap');
  let msg = cmd + " " + `<b>${vocab.toUpperCase()}</b>`;
  if (nundef(fz)) fz = 36;
  let d1 = mText(msg, d, { fz: fz, display: 'inline-block' });
  let sym = symbolDict.speaker;
  let d2 = mText(sym.text, d, {
    fz: fz + 2, weight: 900, display: 'inline-block',
    family: sym.family, 'padding-left': 14
  });
  dFeedback = dInstruction = d;
  dInstruction.addEventListener('click', () => ani_say(dInstruction, () => {
    Speech.say(vocab, 1, .8, .9, voice);
  }));
}
function show_code(res, download = false) {
  if (isdef(res.target)) { res.key = res.target.innerHTML; res.text = CODE.justcode[res.key]; }
  dTable = mBy('dTable');
  let ta = dTable.getElementsByTagName('textarea')[0];
  let text = res.text;
  if (nundef(ta)) ta = mTextarea(null, null, dTable, { w: '100%', h: '100%' });
  ta.value = text;
  if (download) downloadAsText(text, 'hallo', 'js');
  ta.scrollTop = ta.scrollHeight;
  return res;
}
function show_code_editor() {
  mHide('fSearch')
  mClear(dTable);
  mDiv(dTable, { w: '100%' }, null, 'Enter Code:');
  let d = mTextArea(25, 120, dTable, { fz: 16, margin: 'auto', padding: 10, outline: 'none', border: 'none' }, 'dCode');
  let dButtons = mDiv(dTable, { display: 'flex', w: '100%' });
  let asave = mLink("javascript:void(0)", dButtons, {}, null, 'Save Code', 'a');
  asave.onclick = db_add_code;
  let aclear = mLink("javascript:void(0)", dButtons, {}, null, 'Clear Code', 'a');
  aclear.onclick = () => d.value = '';
}
function show_code_list(list) {
  mClear(dTable);
  for (const code of list) {
    let d = mDiv(dTable, { w: '100%' });
    let dkw = mDiv(d, {}, null, code.kw);
    let text = code.c; let lines = text.split('\n'); let rows = lines.length;
    let dcode = mDiv(d, {}, null, `<textarea rows=${rows} cols=120>${code.c}</textarea>`);
  }
}
function show_compose() { mCardButton('compose', onclick_compose, dTable); }
function show_correct_location(k) {
  hide('dPopup');
  for (const k1 in DIBOA) { hide(`d${capitalize(k1)}`); }
  S.location = k;
  show(`d${capitalize(k)}`);
}
function show_dd_click_letters(word, dTable, wTotal, gap = 4) {
  let wmax = wTotal / word.length;
  let fzMax = wmax - 3 * gap;
  fz = Math.min(60, fzMax);
  let dp = createLetterInputsX(word, dTable, { bg: 'silver', display: 'inline-block', fz: fz, w: fz, h: fz * 1.1, margin: 4 });
  shuffle_children(dp);
  let letters = Array.from(dp.children);
  for (let i = 0; i < letters.length; i++) {
    let l = letters[i];
    l.setAttribute('draggable', true);
    ipaddX(l, 'source');
    l.id = 'letter' + i;
  }
  return letters;
}
function show_div_ids() {
  let divs = Array.from(document.getElementsByTagName('div')).filter(d => !isEmptyOrWhiteSpace(d.id) && !isEmpty(d.innerHTML));
  for (const d of divs) {
    let d1 = mDiv(d, { fz: 12, bg: 'black', fg: 'white', hpadding: 4, rounding: 12 }, null, d.id);
    mPlace(d1, 'tr', 2, 2);
  }
}
function show_emos() {
  let d = mDiv(dTable, DA.styles);
  for (const k in EMO.emoscale) {
    let emo = EMO.emoscale[k];
    let sym = Syms[emo.key];
    let item = { name: k, key: emo.key, text: sym.text, color: emo.color, family: sym.family, list: emo.list };
    let handler = question2;
    let d1 = ui_type_item_line(d, item, { cursor: 'pointer', aitems: 'center', vpadding: 6, hpadding: 12, gap: 4, margin: 6, rounding: 12, bg: item.color, fg: 'contrast' }, handler, ['text', 'list']);
    iAdd(item, { div: d1 });
  }
}
function show_eval_message(correct, msg = null, callback = null) {
  if (isdef(DA.anim)) { DA.anim.onfinish = null; DA.anim.cancel(); }
  if (nundef(msg)) msg = correct ? `Congratulations!!! You passed the ${DA.name} challenge!` : 'Wrong solution - Try Again!';
  let d = valf(mBy('dBandMessage'), mDiv(document.body, {}, 'dBandMessage'));
  show(d);
  clearElement(d);
  d.innerHTML = msg; //'blablablablabllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaa'; //msg;
  mStyle(d, { display: 'block', position: 'fixed', top: 127, left: 0, bg: 'red', fg: 'white', w: '100%', h: 40, hmin: 40, hmax: 40, fz: 24, align: 'center', vpadding: 10, classname: 'slow_gradient_blink' });
  DA.anim = mFadeRemove(d, 4000, callback);
}
function show_feedback(is_correct, correction = true) {
  function success() {
    if (isdef(Selected) && isdef(Selected.feedbackUI)) {
      let uilist;
      if (isdef(Selected.positiveFeedbackUI)) uilist = [Selected.positiveFeedbackUI];
      else uilist = isList(Selected.feedbackUI) ? Selected.feedbackUI : [Selected.feedbackUI];
      let sz = getRect(uilist[0]).h;
      for (const ui of uilist) {
        mpOver(markerSuccess(), ui, sz, 'green', 'segoeBlack');
      }
    }
    return 500;
  }
  function fail() {
    if (isdef(Selected) && isdef(Selected.feedbackUI)) {
      let uilist = isList(Selected.feedbackUI) ? Selected.feedbackUI : [Selected.feedbackUI];
      let sz = getRect(uilist[0]).h;
      for (const ui of uilist) {
        mpOver(markerFail(), ui, sz, 'red', 'segoeBlack');
      }
    }
    return 1000;
  }
  if (is_correct) { return success(); }
  else {
    if (correction) {
      let anim = valf(Selected.animation, 'onPulse5');
      for (const ui of Selected.correctUis) { mClass(ui, anim); }
    }
    return fail();
  }
}
function show_fiddle() { fiddleInit(); }
function show_fleeting_message(s, dParent, styles, id, ms = 2000) {
  let d = mDiv(dParent, styles, id, s);
  mFadeRemove(d, ms);
}
function show_game_name(gname) { dGameTitle.innerHTML = gname; }
function show_game_options(dParent, game) {
  mRemoveChildrenFromIndex(dParent, 2);
  let poss = Config.games[game].options;
  if (nundef(poss)) return;
  for (const p in poss) {
    let key = p;
    let val = poss[p];
    if (isString(val)) {
      let list = val.split(',');
      let fs = mRadioGroup(dParent, {}, `d_${key}`, key);
      for (const v of list) { mRadio(v, isNumber(v) ? Number(v) : v, key, fs, { cursor: 'pointer' }, null, key, true); }
      measure_fieldset(fs);
    }
  }
}
function show_game_options_menu(gamename) {
  let dMenu = mBy('dMenu'); iClear(dMenu);
  show_standard_title(dMenu, 'Game Options');
  let d = mDiv(dMenu, { align: 'center' }, 'fMenuInput');
  let dOptions = mDiv(d, {}, 'dMenuInput'); mCenterFlex(dOptions);
  let dButtons = mDiv(d, { display: 'flex', justify: 'center', w: '100%' }, 'dMenuButtons');
  DA.playerlist = null;
  show_game_options(dOptions, gamename);
  let astart = maButton('Start', start_game, dButtons);
  let acancel = maButton('Cancel', cancel_game, dButtons);
}
function show_game_screen(host = true) {
  if (in_game_screen) return;
  in_game_screen = true;
  screen_transition('dTable', 'dHeader');
  is_host = host;
  granularity = 100 / window.innerWidth; console.log('granularity:', granularity);
  mClear(dTable);
  mStyle(dTable, { hmin: 300 });
  let d = mDiv(dTable, { w: '100%', box: true, opacity: 0 }, 'dBars');
  mAppear(d, 500, null, 'linear');
  mLinebreak(d, 20);
  let dp = mDiv(d, { margin: 10, padding: 20 }, null, null, 'card')
  mLinebreak(dp, 20);
  dgreen = get_progressbar(dp, 'green', '+').bar;
  mLinebreak(dp, 20);
  dred = get_progressbar(dp, 'red', '-').bar;
  mLinebreak(dp, 20);
  if (!is_host) return;
  let d1 = mDiv(dp, { gap: 12 }, 'dButtons', null, ['d-flex', 'justify-content-center']);
  mButton('reset', send_reset, d1, {}, 'button');
  mButton('pause', send_pause, d1, {}, 'button');
  mButton('resume', send_resume, d1, {}, 'button');
  mLinebreak(dp, 20);
  mBy('dSettingsButton').style.opacity = 1;
}
function show_gameover(winners) {
  let pl = Session.cur_players[winners[0]];
  let styles = { bg: pl.color, fg: 'contrast', top: 220, };
  if (winners.length > 1) {
    status_message(`GAME OVER - The winners are ${winners.join(', ')}!!!`, styles);
  } else {
    status_message(`GAME OVER - The winner is ${winners[0]}!!!`, styles);
  }
}
function show_gameover_new(winners) {
  let game = Session.cur_game;
  let table = Session.cur_table;
  if (!Session.scoring_complete) {
    console.log('======>scoring!!!!!', table.friendly);
    scoring_update(get_keys(Session.cur_players), winners, game);
    if (Session.level_setting == 'player') {
      inc_level_on_winstreak(winners, game);
      dec_level_on_losestreak();
    }
    out1();
    Session.scoring_complete = true;
  }
  let pl = Session.cur_players[winners[0]];
  let styles = { bg: pl.color, alpha: .75, fg: 'contrast', top: 220, };
  let msg = 'GAME OVER - The ' + (winners.length > 1 ? `winners are ${winners.join(', ')}!!!` : `winner is ${winners[0]}!!!`);
  let d = status_message(msg, styles);
  let end_scores = table.status == 'past' ? table.end_scoring : get_scores_from_cur_players();
  show_score_table(end_scores, table.friendly, d);
  mLinebreak(d);
  mButton('click to close', onclick_gameover_new, d, { fz: 20 }, ['buttonClass', 'donebutton']);
}
function show_games(ms = 500) {
  let dParent = mBy('dGames');
  mClear(dParent);
  mText(`<h2>start new game</h2>`, dParent, { maleft: 12 });
  let d = mDiv(dParent, { fg: 'white', animation: 'appear 1s ease both' }, 'game_menu');
  mCenterFlex(d);
  let gamelist = 'aristo bluff spotit ferro fritz'; if (DA.TEST0) gamelist += ' a_game';
  for (const g of dict2list(Config.games)) {
    if (gamelist.includes(g.id)) {
      let [sym, bg, color, id] = [Syms[g.logo], g.color, null, getUID()];
      let d1 = mDiv(d, { cursor: 'pointer', rounding: 10, margin: 10, vpadding: 15, wmin: 140, bg: bg, position: 'relative' }, g.id);
      d1.setAttribute('gamename', g.id);
      d1.onclick = onclick_game_menu_item;
      mCenterFlex(d1);
      mDiv(d1, { fz: 50, family: sym.family, 'line-height': 55 }, null, sym.text);
      mLinebreak(d1);
      mDiv(d1, { fz: 18, align: 'center' }, null, g.friendly);
    }
  }
}
function show_games_menu() {
  console.assert(isdef(S.tables_by_game), 'ERROR', getFunctionCallerName(), 'S.tables_by_game not set!');
  console.log('tables for user', U.name, S.tables);
  let html = `<div id='game_menu' style="text-align: center; animation: appear 1s ease both">`;
  for (const g of dict2list(DB.games)) { html += ui_game_menu_item(g, S.tables_by_game[g.id]); }
  mBy('inner_left_panel').innerHTML = html;
  mCenterCenterFlex(mBy('game_menu'));
}
function show_gametable(dParent, clickplayer = 'onclick_player_in_gametable', clickgame = 'onclick_game') {
  clear_gametable();
  if (isEmpty(Serverdata.games)) return [];
  let items = mDataTable(Serverdata.games, dParent, null, ['name', 'gamename', 'turn', 'players', 'step', 'round']);
  mTableCommandify(items, {
    0: (item, val) => hFunc(val, clickgame, val),
    2: (item, val) => mTableCommandifyList(item, val, (rowitem, valpart) => hFunc(valpart, clickplayer, valpart, rowitem.o.name)),
    3: (item, val) => mTableCommandifyList(item, val, (rowitem, valpart) => hFunc(valpart, clickplayer, valpart, rowitem.o.name)),
  });
  return items;
}
function show_guest_screen() { get_intro(); }
function show_handsorting_buttons_for(plname, styles = {}) {
  if (Z.role == 'spectator' || isdef(mBy('dHandButtons'))) return;
  let fen = Z.fen;
  let pl = fen.players[plname];
  if (pl.hand.length <= 1) return;
  let d = UI.players[plname].hand.container; mStyle(d, { position: 'relative', wmin: 155 });
  addKeys({ position: 'absolute', left: 58, bottom: -8, height: 25 }, styles);
  let dHandButtons = mDiv(d, styles, 'dHandButtons');
  show_player_button('rank', dHandButtons, onclick_by_rank);
  show_player_button('suit', dHandButtons, onclick_by_suit);
}
function show_history(fen, dParent) {
  if (!isEmpty(fen.history)) {
    let html = '';
    for (const o of jsCopy(fen.history).reverse()) {
      html += beautify_history(o.lines, o.title, fen);
    }
    let dHistory = mDiv(dParent, { paleft: 12, bg: colorLight('#EDC690', .5), box: true, matop: 4, rounding: 10, patop: 10, pabottom: 10, w: '100%', hmax: `calc( 100vh - 250px )`, 'overflow-y': 'auto', w: 260 }, null, html);
    UI.dHistoryParent = dParent;
    UI.dHistory = dHistory;
    if (isdef(Clientdata.historyLayout)) {
      show_history_layout(Clientdata.historyLayout);
    }
  }
}
function show_history_layout(layout) {
  assertion(isdef(UI.dHistoryParent) && isdef(UI.dHistory), 'UI.dHistoryParent && UI.dHistory do NOT exist!!!');
  if (layout == 'ph') PHLayout();
  else if (layout == 'hp') HPLayout();
  else if (layout == 'prh') PRHLayout();
  else if (layout == 'hrp') HRPLayout();
  else PHLayout();
}
function show_history_popup() {
  if (isEmpty(Z.fen.history)) return;
  assertion(isdef(UI.dHistoryParent) && isdef(UI.dHistory), 'UI.dHistoryParent && UI.dHistory do NOT exist!!!');
  let l = valf(Clientdata.historyLayout, 'ph');
  let cycle = ['ph', 'hp', 'prh', 'hrp'];
  let i = (cycle.indexOf(l) + 1) % cycle.length;
  show_history_layout(cycle[i]);
}
function show_home() {
  console.log('hallo! should clear table!!!')
  mClear(dTable);
  show_motto();
  mLinebreak(dTable, 40);
  show_compose();
  mLinebreak(dTable, 4);
  show_recent_contributions();
}
function show_home_logo() {
  let bg = colorLight();
  let dParent = mBy('dAdminLeft');
  clearElement(dParent);
  let d = miPic('castle', dParent, { cursor: 'pointer', fz: 24, padding: 6, h: 36, box: true, margin: 2 });
  d.onclick = db_load;
  let version = 'v0.0.1';
  let html = `version ${version}`
  mText(html, dParent, { fz: 12 });
}
function show_hourglass(uname, d, sz, stylesPos = {}) {
  let html = get_waiting_html(sz);
  mStyle(d, { position: 'relative' });
  addKeys({ position: 'absolute' }, stylesPos);
  let dw = mDiv(d, stylesPos, `dh_${uname}`, html);
}
function show_instruction(msg) { mBy('dSelections0').innerHTML = msg; }
function show_instruction_different(dParent, wlist, slist, styles) {
  wlist = [
    { phrase: 'click', styles: { fg: 'red' } },
    { phrase: 'tomato', styles: { fg: 'red' } },
  ];
  slist = [
    { phrase: 'click', voice: 'default', }
  ];
  console.assert(isdef(Speech));
  clearElement(dParent);
  let d = mDiv(dParent);
  mStyle(d, { margin: 15 })
  mClass(d, 'flexWrap');
  let msg = cmd + " " + `<b>${text.toUpperCase()}</b>`;
  if (nundef(fz)) fz = 36;
  let d1 = mText(msg, d, { fz: fz, display: 'inline-block' });
  if (nundef(fz)) fz = 36;
  d1 = mText(written, d, { fz: fz, display: 'inline-block' });
  if (isSpoken) {
    let sym = symbolDict.speaker;
    let d2 = mText(sym.text, d, {
      fz: fz + 2, weight: 900, display: 'inline-block',
      family: sym.family, 'padding-left': 14
    });
  }
  dFeedback = dInstruction = d;
  spoken = isSpoken ? isdef(spoken) ? spoken : cmd + " " + text : null;
  dInstruction.addEventListener('click', () => aniInstruction(spoken));
  if (!isSpoken) return;
  sayRandomVoice(isdef(spoken) ? spoken : (cmd + " " + text), null, "david");
  let sym = symbolDict.speaker;
  let d2 = mText(sym.text, d, {
    fz: fz + 2, weight: 900, display: 'inline-block',
    family: sym.family, 'padding-left': 14
  });
  dFeedback = dInstruction = d;
  dInstruction.addEventListener('click', () => aniInstruction(spoken));
  if (isdef(spoken)) sayRandomVoice(spoken, spoken, voice);
}
function show_intro_screen() {
  if (!in_game_screen) return;
  in_game_screen = false;
  screen_transition('dHeader', 'dTable');
  mBy('dSettingsButton').style.opacity = 0;
}
function show_jittering() { let b = mBy('bJittering'); b.innerHTML = jittering ? 'repair' : 'desintegrate'; }
function show_letter_inputs(word, dTable, wTotal, gap = 4) {
  let fzMax = wTotal / word.length - 3 * gap;
  let fz = Math.min(70, fzMax);
  let dpEmpty = createLetterInputsX(word, dTable, { pabottom: 5, bg: 'grey', display: 'inline-block', fz: fz, w: fz, h: fz * 1.1, margin: gap });
  let inputs = blankInputs(dpEmpty, range(0, word.length - 1), false);
  for (let i = 0; i < inputs.length; i++) {
    let l = iDiv(inputs[i]);
    ipaddX(l, 'both');
    mClass(l, 'dropzone');
    l.id = 'input' + i;
  }
  return inputs;
}
function show_level(level, maxlevel) {
  let handicap = maxlevel - level;
  dLevel.innerHTML = `level: ${level}`;
  mStyle(dLevel, { fg: level >= 8 ? get_user_color() : 'white' });
}
function show_logged_in_user_simple() {
  let uname = U.name;
  let sz = 36;
  let html = `
  <div username='${uname}' style='display:flex;align-items:center;gap:6px;height:100%'>
    <img src='../base/assets/images/${uname}.jpg' width='${sz}' height='${sz}' class='img_person' style='border:3px solid ${U.color};margin:0'>
    <span>${uname}</span>
  </div>`;
  show_title_right(html, { fg: U.color });
}
function show_map_dims() {
  let map = M.map;
  console.log('________ at zoom', map.getZoom());
  console.log('meters per pixel', get_meters_per_pixel());
  console.log('map dims in meters', get_map_dims_in_meters());
  console.log('map dims in lat lon', get_map_dims_in_lat_long());
  console.log('map dims in pixel', get_map_dims_in_pixel());
}
function show_master_password() {
  let score = localStorage.getItem('score');
  show_special_message('the bitwarden master password is ' + S.master_password, false, 5000, 2000, { bg: 'dodgerblue', classname: '', top: 400 });
}
function show_medium_ui() { DA.testing = false; hide('dButtons'); hide('dTest0'); hide('dTopAdvanced'); toggle_games_off(); }
function show_message(msg = '', stay = false) {
  mStyle(dTable, { transition: 'all 1s ease' });
  let d = mBy('dMessage'); d.innerHTML = msg;
  if (stay) return;
  let ms = 1000, delay = 3000;
  let anim = d.animate([{ transform: `scale(1,1)`, opacity: 1 }, { transform: `scale(1,0)`, opacity: 0 },], { duration: 1000, easing: 'ease', delay: delay });
  dTable.animate([{ transform: 'translateY(0px)' }, { transform: 'translateY(-56px)' },], { fill: 'none', duration: ms, easing: 'ease', delay: delay });
  anim.onfinish = () => {
    mClear(d);
  }
}
function show_MMM(msg) { show_fleeting_message(msg, mBy('dMMM')); }
function show_motto() {
  let d = mBy('dMotto');
  mLinebreak(d, 6);
  mDiv(d, {}, null, `Chillax. Dream. Let Go.`);
  mLinebreak(d);
  mDiv(d, {}, null, `Life made simple and light.`);
}
function show_my_role(role) {
  let dRoles = mBy('dRoles');
  dRoles.innerHTML = `<h1>${role}</h1>`;
  Clientdata.role = role;
  mAppear(dRoles, 1000, null, 'linear');
  let d = show_bars();
  mAppear(d, 1000, null, 'linear');
  if (role == 'host') {
    mButton('reset', onclick_reset_progressbars, d, { h: 30, w: 100 });
    disable_bar_ui();
  } else if (role == 'guest') {
    if (nundef(Clientdata.uid)) Clientdata.uid = rUniqueId(30);
    Clientdata.new_clicks = 0;
  }
  autopoll();
}
function show_my_score() { let me = Session.cur_players[Session.cur_user]; console.log('my', me.name, 'score is', me.score); }
function show_one_skype_message(dParent, o) {
  let d = mDiv(dParent, { rounding: 12, hpadding: 6, vpadding: 6, margin: 4, gap: 12 }); mFlex(d);
  let [sz] = [40];
  let dimg = get_skype_phone_icon(o.color);
  mAppend(d, dimg);
  let dmiddle = mDiv(d, { flex: 8, wmax: '75%' });
  let dnum = mDiv(dmiddle, { fz: 11, fg: 'grey' }, null, `<div>${o.num} ${format_date(o.date)}</div>`);
  let msg = get_skype_expanded_message(o.msg);
  S.boa_authorization_code = stringAfter(msg, 'Code ').substring(0, 6);
  let dmsg = mDiv(dmiddle, { bg: '#EEE', fz: 14, fg: 'black', rounding: 8, padding: 8 }, null, `<div>${msg}</div>`);
}
function show_options_popup(options) {
  let opresent = {};
  let di = { mode: 'gamemode', yes: true, no: false };
  let keys = get_keys(options);
  keys.sort();
  for (const k of get_keys(options).sort()) {
    let key = valf(di[k], k);
    let val = valf(di[options[k]], options[k]);
    opresent[key] = val;
  }
  let x = mYaml(mCreate('div'), opresent);
  let dpop = mPopup(x.innerHTML, dTable, { fz: 16, fg: 'white', top: 0, right: 0, border: 'white', padding: 10, bg: 'dimgray' }, 'dOptions');
  mInsert(dpop, mCreateFrom(`<div style="text-align:center;width:100%;font-family:Algerian;font-size:22px;">${Z.game}</div>`));
}
function show_player_button(caption, ui_item, handler) {
  let d = ui_item.container ?? iDiv(ui_item);
  let styles = { rounding: 6, bg: 'silver', fg: 'black', border: 0, maleft: 10 };
  let b = mButton(caption, handler, d, styles, 'enabled');
  return b;
}
function show_player_mode(dParent, g, uname) {
  let dplmode = valf(mBy('dPlayerMode'), mDiv(dParent, { fg: 'blue', fz: 12, padding: 4 }, 'dPlayerMode'));
  mCenterCenterFlex(dplmode);
  let plmode = lookupSet(g.fen, ['players', uname, 'playmode'], 'human');
  dplmode.innerHTML = plmode;
  if (g.fen.turn.includes(uname)) {
    dplmode.onclick = () => {
      let playermode = lookup(g.fen, ['players', uname, 'playmode']);
      playermode = lookupSetOverride(g.fen, ['players', uname, 'playmode'], playermode == 'human' ? 'bot' : 'human');
      dplmode.innerHTML = playermode;
      if (playermode == 'bot') ai_move();
    }
    mStyle(dplmode, { cursor: 'pointer' });
  }
}
function show_playerdatastate() {
  for (const pldata of Z.playerdata) {
    console.log('player', pldata.name, `status=${isEmpty(pldata.player_status) ? 'none' : pldata.player_status}`, pldata.state);
  }
}
function show_polling_signal() {
  if (DA.TEST0 != true) return;
  let d1 = mDiv(mBy('dAdmin'), { position: 'fixed', top: 10, left: 73 });
  let bg = Z.skip_presentation == true ? 'grey' : 'green';
  let d2 = mDiv(d1, { width: 20, height: 20, bg: bg, rounding: 10, display: 'inline-block' });
  mFadeRemove(d1, 1000);
}
function show_project_editor() {
  console.log('display the project editor!');
  mClear(dTable);
  let d = mCard(dTable, {}, 'coform'); mCenterFlex(d);
  mLinebreak(d, 40);
  let d1 = mText('New Composition', d, {}, 'fett');
  mPlace(d1, 'tl', 10);
  let d2 = mButtonX(d, onclick_close_project_editor);
  mPlace(d2, 'tr', 10);
  let i = 0;
  let d3 = mInput(d, {}, 'inTitle', 'Title', 'coinput', i++);
  let d4 = mInput(d, {}, 'inCreator', 'Creator', 'coinput', i++, isdef(U) ? U.name : '');
  let d5 = mInput(d, {}, 'inDescription', 'Short Description', 'coinput', i++);
  let b = mButton('next', onclick_add_question, d, {}, ['fett', 'no_outline', 'btn']);
}
function show_prompt(q, list, handler) {
  mClear(dTable);
  console.log('list', list)
  let dqcont = mDiv(dTable, G.stcont);
  mLinebreak(dTable);
  let dq = mDiv(dqcont, G.stq, `q_${G.i}`, q);
  let qitem = iAdd({ type: 'q', index: G.i, text: q }, { cont: dqcont, div: dq });
  let dacont = mDiv(dTable, G.stcont);
  mLinebreak(dTable);
  let tb = mToolbar(['back', 'clear', 'next'], handle_command, dTable, { align: 'center' }, { margin: 8, fz: 30, cursor: 'pointer' });
  G.buttons = tb.children;
  let aslist = [];
  list.map(x => {
    let da = ui_type_sym_text_line(dacont, x, dict_augment({ bg: x.color }, G.sta), handler);
    let item = iAdd(x, { div: da });
    aslist.push(item.id);
  });
  G.q = qitem.id;
  G.alist = aslist;
  G.selist = [];
  dTable.setAttribute('transition-style', "in:wipe:bottom-right");
  toolbar_check();
}
function show_question_editor() {
  mLinebreak(dTable, 4)
  let d = mCard(dTable, {}, 'coform'); mCenterFlex(d);
  let iform = arrChildren(dTable).length;
  console.log('this is question number', iform);
  let d1 = mText('New Composition', d, {}, 'fett'); mPlace(d1, 'tl', 10);
  let d2 = mButtonX(d, onclick_close_question_editor);
  mPlace(d2, 'tr', 10);
  mLinebreak(d, 40);
  let i = 0;
  let d3 = mInput(d, {}, 'inTitle' + iform, 'Title', 'coinput', i++);
  let d4 = mInput(d, {}, 'inCreator' + iform, 'Creator', 'coinput', i++, isdef(U) ? U.name : '');
  let d5 = mInput(d, {}, 'inDescription' + iform, 'Short Description', 'coinput', i++);
  let b = mButton('next', onclick_add_question, d, {}, ['fett', 'no_outline', 'btn']);
}
function show_rankings(dParent) {
  csv = make_csv_for_rankings();
  let ch = csv[csv.length - 1];
  if (ch == '%' || isNumber(ch)) {
    let d = mDiv(dParent, { align: 'center' }, null, `<h1>All Time Ranking</h1>`);
    let d1 = mDiv(d, { align: 'center', display: 'flex' });
    mCenterCenterFlex(d1);
    present_table_from_csv(csv, d1);
    mLinebreak(dParent);
  }
}
function show_recent_contributions() {
  let d = mCard(dTable);
  let contrib = Serverdata.contrib;
  if (isEmpty(contrib)) { d.innerHTML = 'no projects yet...'; return; }
}
function show_role() {
  let d = mBy('dAdminMiddle');
  clearElement(d);
  let hotseatplayer = Z.uname != Z.uplayer && Z.mode == 'hotseat' && Z.host == Z.uname;
  let styles, text;
  let boldstyle = { fg: 'red', weight: 'bold', fz: 20 };
  let normalstyle = { fg: 'black', weight: null, fz: null };
  let location = '';
  if (hotseatplayer) {
    styles = boldstyle;
    text = `your turn for ${Z.uplayer}`;
  } else if (Z.role == 'spectator') {
    styles = normalstyle;
    text = `(spectating)`;
  } else if (Z.role == 'active') {
    styles = boldstyle;
    text = `It's your turn!!!`;
  } else if (Z.role == 'waiting') {
    text = `waiting for players to complete their moves...`;
  } else {
    assertion(Z.role == 'inactive', 'role is not active or inactive or spectating ' + Z.role);
    styles = normalstyle;
    text = `(${Z.turn[0]}'s turn)`;
  }
  d.innerHTML = location + text;
  mStyle(d, styles);
}
function show_roles() {
  let d = mDiv(dTable, {}, 'dRoles', null, 'grid_roles');
  mButton('host', () => onclick_role('host'), d, {}, ['donebutton', 'enabled']);
  mButton('guest', () => onclick_role('guest'), d, {}, ['donebutton', 'enabled']);
}
function show_route(map, pts, color, callback) {
  let control = L.Routing.control({
    waypoints: points_to_waypoints(pts),
    lineOptions: { styles: [{ color: color, opacity: 1, weight: 3 }], },
    draggableWaypoints: false,
    createMarker: function () { return false; },
    show: false,
  }).addTo(map);
  control.on('routesfound', callback);
  return control;
}
function show_score_table(fen, game_title, dParent) {
  let d = mDiv(dParent, { margin: 'auto', wmin: 300, wmax: 500 });
  html = `<div style='text-align:center;margin-top:100px'>
  <h1>${game_title}</h1>
  <table id='customers'><tr><th>player</th><th>score</th></tr>
  `;
  let plparts = fen.split(',');
  for (const pl of plparts) {
    html += `<tr><td>${stringBefore(pl, ':')}</td><td>${stringAfter(pl, ':')}</td></tr>`
  }
  html += '</table></div>';
  d.innerHTML = html;
}
function show_settings(dParent) {
  let [options, fen, uplayer] = [Z.options, Z.fen, Z.uplayer];
  clearElement(dParent);
  mFlex(dParent);
  mStyle(dParent, { 'justify-content': 'end', gap: 12, paright: 10 })
  let playmode = get_playmode(uplayer);
  let game_mode = Z.mode;
  let st = { fz: 20, padding: 0, h: 40, box: true, matop: 2, rounding: '50%', cursor: 'pointer' };
  let dHistoryButton = miPic('scroll', dParent, st);
  dHistoryButton.onclick = show_history_popup;
  if (isdef(Config.games[Z.game].options.strategy)) {
    let dStrategy = miPic('chess pawn', dParent, st);
    dStrategy.onclick = show_strategy_popup;
  }
  let d = miPic('gear', dParent, st);
  options.playmode = playmode;
  d.onmouseenter = () => show_options_popup(options);
  d.onmouseleave = hide_options_popup;
}
function show_settings_orig(options) {
  clearElement('dTitleRight');
  let dParent = mDiv(mBy('dTitleRight'), { display: 'flex', fg: 'red' }, null, options.mode == 'hotseat' ? 'h' : '');
  let d = miPic('gear', dParent, { fz: 20, padding: 6, h: 40, box: true, matop: 2, rounding: '50%', cursor: 'pointer' });
  d.onmouseenter = () => show_options_popup(options);
  d.onmouseleave = hide_options_popup;
}
function show_shield(msg) {
  mBy('dShield').style.display = 'block';
  mBy('dShield').innerHTML = msg;
}
function show_sidebar(list, handler) {
  dSidebar = mBy('dSidebar'); mClear(dSidebar); mStyle(dSidebar, { w: 200, h: window.innerHeight - 68, overy: 'auto' });
  for (const k of list) {
    let d = mDiv(dSidebar, { cursor: 'pointer', wmin: 100 }, null, k, 'hop1')
    if (isdef(handler)) d.onclick = handler;
  }
}
function show_simple_ui(name) {
  U = firstCond(Serverdata.users, x => x.name == name);
  localStorage.setItem('uname', U.name);
  dTitle = mBy('dTitle');
  show_title();
  show_logged_in_user_simple();
  dTitle.animate([{ opacity: 0 }, { opacity: 1 },], { fill: 'both', duration: 1000, easing: 'ease-in' });
  dTable = mBy('dTable');
  hide('dUsers'); show('aLogout');
  hide('dTopMenu')
  let dStatus = mBy('dStatus'); mStyle(dStatus, { left: 10, width: '50%', right: null });
  onclick_tables();
  DA.testing = false; return;
  hide('dButtons');
  hide('dTest0');
  hide('dTopAdvanced');
  toggle_games_off();
  toggle_tables_off();
  toggle_users_on();
}
function show_simple_ui_orig() {
  DA.testing = false;
  hide('dButtons');
  hide('dTest0');
  hide('dTopAdvanced');
  toggle_games_off();
  toggle_tables_off();
  toggle_users_on();
}
function show_skype_contact(dParent) {
  let c = S.skype_contact;
  if (isdef(c)) {
    mClear(dParent);
    let d = mDiv(dParent, { h: 'calc( 100vh - 200px )', 'overflow-y': 'scroll' });
    let dfooter = mDiv(dParent, { h: 190, padding: 10 });
    let address = c.num;
    dfooter.innerHTML = `to: ${address} via Skype<br>`;
    let dform = mDiv(dfooter, { vmargin: 14 }); mFlex(dform);
    let denter = mInput(dform, { border: 'none', w: '85%', h: 40, bg: '#EEE', fg: '#000', fz: 14, padding: 10, hmargin: 14, rounding: 25 }, null, 'Type an SMS here');
    let b = skype_go_button();
    mAppend(dform, b);
    for (let i = 0; i < 20; i++) {
      show_one_skype_message(d, c)
    }
    d.scrollTop = d.scrollHeight;
  }
}
function show_special_message(msg, stay = false, ms = 3000, delay = 0, styles = {}, callback = null) {
  let dParent = mBy('dBandMessage');
  if (nundef(dParent)) dParent = mDiv(document.body, {}, 'dBandMessage');
  show(dParent);
  clearElement(dParent);
  addKeys({ position: 'fixed', top: 200, classname: 'slow_gradient_blink', vpadding: 10, align: 'center', position: 'absolute', fg: 'white', fz: 24, w: '100vw' }, styles);
  if (!isEmpty(styles.classname)) { mClass(dParent, styles.classname); }
  delete styles.classname;
  mStyle(dParent, styles);
  dParent.innerHTML = msg;
  if (delay > 0) TO.special = setTimeout(() => { mFadeRemove(dParent, ms, callback); }, delay);
  else mFadeRemove(dParent, ms, callback);
}
function show_stage() {
  if (isdef(Z.fen.progress)) {
    let d = mBy('dTitleLeft');
    let former = mBy('dProgress');
    if (isdef(former)) former.remove();
    let dprogress = mDiv(d, {}, 'dProgress', `<div>${Z.fen.progress}</div>`);
  }
}
function show_standard_title(dParent, title) { mText(title, dParent, { margin: 20, fz: 24 }); }
function show_status(s) {
  if (is_advanced_user()) {
    clear_status();
    if (!TESTING && !s.includes('reload')) show_fleeting_message(s, 'dTest', { fz: 14, position: 'absolute', top: 5, right: 10 }, 'dStatus');
  }
}
function show_status_orig(msg = '', stay) {
  if (isdef(stay)) showFleetingMessage(msg, mBy('dStatus'), { fg: 'red' }, 1000, 0, false);
  else showFleetingMessage(msg, mBy('dStatus'), { fg: 'black' });
}
function show_status_simple() {
}
function show_strategy_popup() {
  let dpop = mPopup('', dTable, { fz: 16, fg: 'white', top: 0, right: 0, border: 'white', padding: 10, bg: 'dimgray' }, 'dOptions');
  mAppend(dpop, mCreateFrom(`<div style="text-align:center;width:100%;font-family:Algerian;font-size:22px;">${Z.game}</div>`));
  mDiv(dpop, { matop: 5, maleft: 10 }, null, `choose strategy:`);
  let vals = Config.games[Z.game].options.strategy.split(',');
  let key = 'strategy';
  let fs = mRadioGroup(dpop, { fg: 'white' }, `d_${key}`);
  for (const v of vals) { mRadio(v, isNumber(v) ? Number(v) : v, key, fs, { cursor: 'pointer' }, set_player_strategy, key, v == Z.strategy); }
  measure_fieldset(fs);
}
function show_table() {
  console.log('show_table S', S)
}
function show_table_for(g, dParent, uname) {
  let present = false;
  if (!UBEF || uname != UBEF) present = true;
  else if (!GBEF || g.name != GBEF) present = true;
  else {
    if (!EBEF) present = true;
    else {
      let keybef = get_keys(EBEF);
      let keys = get_keys(g.expected);
      console.log('keys', keybef, keys);
      if (!sameList(keybef, keys)) present = true;
      console.log('uname', uname)
      let ubef = EBEF[uname];
      let u = g.expected[uname];
      console.log('uname', ubef, u)
      console.log('STEP!!!', ubef.step, u.step)
      if (ubef.type != u.type || ubef.step != u.step) present = true;
    }
  }
  console.log('need to present:', present);
  U = firstCond(Serverdata.users, x => x.name == uname);
  UBEF = U.name;
  G = g;
  GBEF = G.name;
  EBEF = jsCopy(G.expected);
  if (!present) return;
  show_title();
  show_user();
  clearElement(dParent);
  //dTable.innerHTML = `<img src='http://localhost:8080/aroot/base/assets/images/wolfgang.jpg' />`;
  ui_game_stats(dParent, G.fen.players);
  mLinebreak(dParent, 10)
  show_message(G.fen.message);
  show_instruction(isdef(G.expected[uname]) ? G.fen.instruction : 'NOT YOUR TURN');
  show_status(G.fen.status);
  window[`${G.gamename}_present`](G, dParent, uname);
  if (!isdef(G.expected[uname])) mShield(dParent);
  if (G.turn.includes(uname)) activate_ui();
}
function show_table_for_old(g, dParent, uname) {
  console.assert(isdef(g.fen), `game ${g.name} does not have a fen!`)
  console.assert(isDict(g.fen), "fen is NOT an object!!! " + g.name)
  console.assert(isdef(uname), `uname ${uname}`);
  Prevturn = isdef(Turn) ? jsCopy(Turn) : null;
  console.log('g.fen.turn', g.fen.turn)
  Turn = jsCopy(g.fen.turn);
  let sameuser = isdef(U) && U.name == uname;
  let samegame = isdef(G) && G.name == g.name;
  let sameturn = sameuser && samegame && isList(Prevturn) && isList(Turn) && sameList(Prevturn, Turn);
  G = g;
  U = firstCond(Serverdata.users, x => x.name == uname);
  let wasmyturn = isList(Prevturn) && Prevturn.includes(U.name);
  let ismyturn = isList(Turn) && Turn.includes(U.name);
  if (sameturn) return;
  show_title();
  show_user();
  clearElement(dParent);
  //dTable.innerHTML = `<img src='http://localhost:8080/aroot/base/assets/images/wolfgang.jpg' />`;
  ui_game_stats(dParent, G.fen.players);
  mLinebreak(dParent, 10)
  show_message(G.fen.message);
  show_instruction(ismyturn ? G.fen.instruction : 'NOT YOUR TURN');
  show_status(G.fen.status);
  window[`${G.gamename}_present`](G, dParent, uname);
  if (!ismyturn) mShield(dParent);
  if (G.turn.includes(uname)) activate_ui();
}
function show_table_if_winner(otree) {
  table_shield_off();
  if (isdef(otree.winner)) {
    stop_game();
    ari_reveal_all_buildings(otree);
    if (!DA.test.running) turn_show_gameover(otree);
  }
}
function show_table_simple(tablename) {
  hide('dTables');
  show('dTable');
  stopgame();
  let table = firstCond(Serverdata.tables, x => x.friendly == tablename);
  ensure_polling();
  phpPost({ friendly: tablename }, 'table');
}
function show_tables(ms = 500) {
  clear_screen();
  let dParent = mBy('dTables');
  mClear(dParent);
  show_games();
  let tables = Serverdata.tables;
  if (isEmpty(tables)) { mText('no active game tables', dParent); return []; }
  tables.map(x => x.game_friendly = Config.games[x.game].friendly);
  mText(`<h2>game tables</h2>`, dParent, { maleft: 12 })
  let t = mDataTable(tables, dParent, null, ['friendly', 'game_friendly', 'players'], 'tables', false);
  mTableCommandify(t.rowitems, {
    0: (item, val) => hFunc(val, 'onclick_table', val, item.id),
  });
  let d = iDiv(t);
  for (const ri of t.rowitems) {
    let r = iDiv(ri);
    let h = hFunc('delete', 'delete_table', ri.o.friendly);
    c = mAppend(r, mCreate('td'));
    c.innerHTML = h;
  }
}
function show_tables_simple() {
  let dParent = mBy('dTables');
  show(dParent); hide('dTable');
  clearElement(dParent);
  let tables = Serverdata.tables;
  if (isEmpty(tables)) { mText('no active game tables', dParent); return []; }
  mText(`<h1>game tables</h1>`, dParent, { maleft: 12 })
  let t = mDataTable(tables, dParent, null, ['game', 'friendly', 'players'], 'tables');
  mTableCommandify(t.rowitems, {
    1: (item, val) => hFunc(val, 'onclick_game_in_gametable', val, item.id),
  });
}
function show_tagged() {
  if (isdef(DA.tags)) get_values(DA.tags).map(x => x.remove());
  let tpop = mPopup('', document.body)
  DA.tags = {};
  for (const id in Items) {
    let el = mBy(id);
    if (nundef(el)) {
      let item = Items[id];
      el = iDiv(item);
      if (nundef(el)) continue;
      if (nundef(item.live)) { item.live = { div: el }; el.id = id; delete Items[id].div; }
    }
    console.log('id', id)
    let r = getRect(el);
    let dtag = mDiv(tpop, { fz: 12, bg: 'black', fg: 'white', hpadding: 4, rounding: 12 }, null, id)
    mPos(dtag, r.l, r.t);
    DA.tags[id] = dtag;
  }
}
function show_title() {
  Z.func.state_info(mBy('dTitleLeft'));
  show_settings(mBy('dTitleRight'));
  mBy('dTablename').innerHTML = Z.friendly;
}
function show_title_left(s, styles, funnyLetters = false) {
  let d = mBy('dTitleLeft');
  d.innerHTML = `${funnyLetters ? mColorLetters(s) : s}`;
  if (isdef(styles)) mStyle(d, styles);
}
function show_title_right(s, styles, funnyLetters = false) {
  let d = mBy('dTitleRight');
  d.innerHTML = `${funnyLetters ? mColorLetters(s) : s}`;
  if (isdef(styles)) mStyle(d, styles);
}
function show_user() {
  if (isdef(U) && U.name != 'anonymous') {
    let uname = U.name;
    let sz = 36;
    let html = `
    <div username='${uname}' style='display:flex;align-items:center;gap:6px;height:100%'>
      <img src='../base/assets/images/${uname}.jpg' width='${sz}' height='${sz}' class='img_person' style='border:3px solid ${U.color};margin:0'>
      <span>${uname}</span>
    </div>`;
    show_title_left(html, { fg: U.color });
  }
  else show_home_logo();
}
function show_user_image(uname, dParent, sz = 300) {
  let d = mDiv(dParent, { margin: 'auto', w: sz });
  let html = `
  <div style='text-align:center;margin-top:50px'>
    <img src='../base/assets/images/${uname}.jpg' class="img_person" height=150 />
  </div>
  `;
  d.innerHTML = html;
  return d;
}
function show_user_intro_screen(is_show_ranking = false, is_start_poll = true) {
  show('dIntro'); clearElement('dIntro');
  intro_show_user_image(Session.cur_user);
  status_message(`hi, ${capitalize(Session.cur_user)}, a game is starting soon...`, { top: 330, classname: 'slow_gradient_blink' });
  if (is_show_ranking) {
    let t = Session.cur_table;
    let fen = t.status == 'past' ? t.fen : get_score_fen_from_cur_players();
    intro_create_score_table(fen);
  }
  if (is_start_poll) poll_for_table_started();
}
function show_user_version_0() {
  if (isdef(U) && U.name != 'anonymous') show_title_left(U.name, { fg: U.color });
  else show_home_logo();
}
function show_username() {
  let uname = U.name;
  let dpic = get_user_pic(uname, 30);
  let d = mBy('dAdminRight');
  mClear(d);
  mAppend(d, get_logout_button());
  mAppend(d, dpic);
  if (is_advanced_user()) { show('dAdvanced1'); } else { hide('dAdvanced'); hide('dAdvanced1'); }
  //console.log('DA.running',DA.running); //'Z',Z,'dTable',dTable,mBy('dTable'),isVisible('dTable'));
  if (!TESTING && !DA.running) phpPost({ app: 'easy' }, 'tables');
}
function show_users(ms = 300) {
  let dParent = mBy('dUsers');
  mClear(dParent);
  for (const u of Serverdata.users) {
    if (['ally', 'bob', 'leo'].includes(u.name)) continue;
    let d = get_user_pic_and_name(u.name, dParent);
    d.onclick = () => onclick_user(u.name);
    mStyle(d, { cursor: 'pointer' });
  }
  mFall(dParent, ms);
}
function show_users_version_0() {
  let dParent = mBy('dAllTables');
  show(dParent);
  clearElement(dParent);
  let headers = ['id', 'name', 'motto', 'commands'];
  let t = mDataTable(Serverdata.users, dParent, rec => ({ fg: 'contrast', bg: rec.color }), headers, 'users');
  mTableCommandify(t.rowitems, {
    1: (item, val) => hFunc(val, 'onclick_user', val),
  });
  return t;
}
function show_view_buildings_button(plname) {
  if (Z.role == 'spectator' || isdef(mBy('dPlayerButtons'))) return;
  if (isEmpty(UI.players[plname].buildinglist)) return;
  let d1 = iDiv(UI.players[plname]); mStyle(d1, { position: 'relative' });
  let d2 = mDiv(d1, { position: 'absolute', top: 8, left: 50, height: 25 }, 'dPlayerButtons');
  show_player_button('view buildings', d2, onclick_view_buildings);
}
function show_waiting_for_ack_message() {
  let dInstruction = mBy('dSelections0');
  mClass(dInstruction, 'instruction');
  mCenterCenterFlex(dInstruction);
  mBy('dSelections0').innerHTML = 'waiting for next round to start...';
}
function show_waiting_message(msg) {
  let dInstruction = mBy('dSelections0');
  mClass(dInstruction, 'instruction');
  mCenterCenterFlex(dInstruction);
  mBy('dSelections0').innerHTML = msg;
}
function show_winners() {
  let winners = Z.fen.winners;
  let multiple_winners = winners.length > 1;
  let winners_html = winners.map(x => get_user_pic_html(x, 35)).join(' ');
  let msg = `
    <div style="display:flex;gap:10px;align-items:center">
      <div style="color:red;font-size:22px;font-weight:bold;">GAME OVER! the winner${multiple_winners ? 's are: ' : ' is '}</div>
      <div style="padding-top:5px;">${winners_html}</div>
    </div>
  `;
  show_message(msg, true);
  mShield(dTable);
  hide('bRestartMove');
  return Z.fen.winners;
}
function show_x_button(dParent) {
  let b = mButton('close', () => hide(dParent), dParent, { maleft: '95%' });
}
function show0(id) { mBy(id).style.display = "block"; }
function show100() {
  let table = mBy('table');
  clearElement(table);
  let picLabelStyles = getHarmoniousStylesXX(100, 100, 10, 'arial', 'random', 'random', true);
  let picStyles = getHarmoniousStylesXX(100, 100, 10, 'arial', 'random', 'random', false);
  ensureSymByType();
  mButton('download key set', downloadKeySet, table, { fz: 30 });
  mButton('next 100', () => show100(), table, { fz: 30 });
  mLinebreak(table);
  let keys = takeFromTo(IconSet, lastIndex, lastIndex + 100);
  lastIndex += 100;
  console.log('JAJAJAJAJ lastIndex', lastIndex);
  gridLabeled(keys, picLabelStyles);
}
function showActiveMessage(msg, handler, styles = {}, fade = false) {
  let defStyles = { fz: 22, rounding: 10, vpadding: 12, hpadding: 0, matop: 50 };
  styles = mergeOverride(defStyles, styles);
  if (nundef(styles.fg)) styles.fg = colorIdealText(Session.color);
  clearFleetingMessage();
  let d = fleetingMessage(msg, styles, fade);
  d.onclick = handler;
}
function showAllInnoCards(dParent) {
  Pictures = [];
  let allKeys = Object.keys(cinno);
  console.group(allKeys);
  let dims = calcRowsColsX(allKeys.length);
  let idx = 0;
  for (let i = 0; i < dims.rows; i++) {
    for (let j = 0; j < dims.cols; j++) {
      if (allKeys.length <= idx) break;
      let c = cardInnoz(allKeys[idx]); idx += 1;
      mAppend(dParent, c.div);
      c.row = i;
      c.col = j;
      Pictures.push(c);
    }
  }
}
function showAxes(ctx, axes) {
  var x0 = axes.x0, w = ctx.canvas.width;
  var y0 = axes.y0, h = ctx.canvas.height;
  var xmin = axes.doNegativeX ? 0 : x0;
  ctx.beginPath();
  ctx.strokeStyle = "rgb(128,128,128)";
  ctx.moveTo(xmin, y0); ctx.lineTo(w, y0);
  ctx.moveTo(x0, 0); ctx.lineTo(x0, h);
  ctx.stroke();
}
function showBadges(dParent, level, clickHandler) {
  clearElement(dParent); badges = [];
  for (let i = 1; i <= level; i++) {
    addBadge(dParent, i, clickHandler);
  }
}
function showBadgesX(dParent, level, clickHandler, maxLevel) {
  clearElement(dParent);
  badges = [];
  for (let i = 1; i <= maxLevel + 1; i++) {
    if (i > level) {
      let b = addBadge(dParent, i, clickHandler, false);
      b.live.div.style.opacity = .25;
      b.achieved = false;
    } else {
      let b = addBadge(dParent, i, clickHandler, true);
      b.achieved = true;
    }
  }
}
function showBoat(id) { let ms = UIS[id]; ms.show(); ms.o.weg = false; }
function showCard(card, { size = 90, area, hand, layout } = {}) {
  let d = document.getElementById(area);
  mStyle(card, { width: size * .66, height: size });
  if (nundef(layout)) card.style.setProperty('float', 'left');
  let dHand = isdef(hand) ? d.getElementById(hand)
    : d.childElementCount >= 1 ? d.lastChild
      : addDivPosTo(d, 12, 25, 'auto', size, 'px', null);
  dHand.appendChild(card);
}
function showCards(o, type) {
  let d2 = iDiv(o);
  if (nundef(type)) type = isdef(o.type) ? o.type : 'hand';
  let arr = type == 'deck' ? o.deck.cards() : o.cards;
  let cont = type == 'deck' ? stdDeckContainer(d2, arr.length) : startsWith(type, 'cards') ? stdCardsContainer(d2, arr.length) : stdHandContainer(d2, arr.length);
  let items = arr.map(x => Card52.getItem(x % 52));
  if (endsWith(type, 'Hidden') || type == 'deck') items.map(x => Card52.turnFaceDown(x, BG_CARD_BACK));
  items.map(x => mAppend(cont, iDiv(x)));
  return items;
}
function showCardSimple(card, area) {
  let hCard = getBounds(mById(area)).height - 30;
  showCard(card, { size: 80, area: area });
}
function showChatWindow() { let d = mBy('dChatWindow'); mStyle(d, { display: 'block' }); return d; }
function ShowChessMessage(s, ms) {
  console.log('message:', s);
  $("#GameStatus").text(s);
  if (isdef(ms)) setTimeout(() => $("#GameStatus").text(''), ms)
}
function showChildren(n) {
  console.log('children:')
  if (nundef(n.children)) {
    console.log('NO Children!!!', n)
  } else if (isList(n.children)) {
    n.children.map(x => console.log(x));
  } else {
    console.log(n.children);
  }
}
function showCollapsibleContent(ev) {
  let id = evToClosestId(ev);
  mBy('pageContent').scrollTo(0, 0);
  ev.cancelBubble = true;
  setCurrentPathIndex(firstNumber(id));
}
function showCollection(coll, idCollection) {
  if (coll.tbd == 'add' || coll.tbd == 'update') {
    _clearHand(idCollection, 'hand');
    let msCollection = UIS[idCollection];
    let collectionAreaName = getAreaName(idCollection);
    let els = coll.type == '_obj' ? coll.arr.map(x => x._obj) : coll.arr;
    if (coll.type == '_obj') {
      for (const oid of els) {
        let mobj = getVisual(oid);
        if (nundef(mobj)) {
          mobj = makeCard(oid, G.table[oid], idCollection);
        }
        if (!_isInHand(oid, idCollection)) {
          addCardToCollectionArea(oid, idCollection);
        }
      }
      repositionCards(msCollection);
    }
  }
}
function showCollections(pool, oid, keys, cardFunc, areaName) {
  let propName = keys.shift();
  let collDict = getCollections(pool, oid, propName);
  if (nundef(collDict)) return;
  let msArea = getMainArea(areaName);
  if (!msArea) {
    return;
  }
  for (const key in collDict) {
    let coll = collDict[key];
    let idCollection = getCollectionArea(key, msArea);
    showCollection(coll, idCollection);
  }
}
function showCorrectLabelSwapping() {
  for (const p of Pictures) {
    for (const l of p.letters) {
      let sw = l.swapInfo;
      if (isdef(sw)) {
        iDiv(l).innerHTML = sw.correct.l;
        if (l.i == p.iLetter) animate(iDiv(l), 'komisch', 2300);
      }
    }
  }
  DELAY = 3000;
  return 3000;
}
function showCorrectPictureLabels(sayit = true) { return 1000; }
function showCorrectUis() {
  let anim = 'onPulse5';
  for (const ui of Selected.correctUis) { mClass(ui, anim); }
  return Selected.correctionDelay;
}
function showCorrectWord(sayit = true) {
  let anim = G.spokenFeedback ? 'onPulse' : 'onPulse1';
  let div = mBy(Goal.id);
  mClass(div, anim);
  if (!sayit || !G.spokenFeedback) G.spokenFeedback ? 3000 : 300;
  let correctionPhrase = isdef(Goal.correctionPhrase) ? Goal.correctionPhrase : Goal.label;
  sayRandomVoice(correctionPhrase);
  return G.spokenFeedback ? 3000 : 300;
}
function showCorrectWordInTitle(sayit = true) {
  let anim = G.spokenFeedback ? 'onPulse' : 'onPulse1';
  clearElement(dInstruction);
  let d1 = mText(`<b>${Goal.label}</b>`, dInstruction, { fz: 36, display: 'inline-block' });
  mClass(dInstruction, anim);
  showFleetingMessage(Goal.label);
  if (!sayit || !G.spokenFeedback) G.spokenFeedback ? 3000 : 300;
  let correctionPhrase = isdef(Goal.correctionPhrase) ? Goal.correctionPhrase : Goal.label;
  sayRandomVoice(correctionPhrase);
  return G.spokenFeedback ? 3000 : 300;
}
function showCorrectWords(sayit = true) {
  if (nundef(TOList)) TOList = {};
  TOList.correctWords = [];
  let anim = 'onPulse2';
  let to = 0;
  let speaking = sayit && G.spokenFeedback;
  let ms = speaking ? 2000 : 1000;
  for (const goal of Goal.pics) {
    TOList.correctWords.push(setTimeout(() => {
      let div = mBy(goal.id);
      mClass(div, anim);
      if (speaking) sayRandomVoice((G.language == 'E' ? 'the ' : ' ') + goal.correctionPhrase);
    }, to));
    to += ms;
  }
  if (!sayit || !G.spokenFeedback) return to;
  return to + ms;
}
function showCurrent(id) { if (isdef(dCurrent) && dCurrent.id == id) { return 0; } else { dCurrent = mBy(id); mStyle(dCurrent, { overflow: 'hidden' }); show(id); return DELAY_APPEAR } };
function showDeck(keys, dParent, splay, w, h) {
  let d = mDiv(dParent);
  mStyleX(d, { display: 'block', position: 'relative', bg: 'green', padding: 25 });
  let gap = 10;
  let ovPercent = 20;
  let overlap = w * ovPercent / 100;
  let x = y = gap;
  for (let i = 0; i < keys.length; i++) {
    let k = keys[i];
    let c = zInno(k, d);
    mAppend(d, c.div);
    mStyleX(c.div, { position: 'absolute', left: x, top: y });
    c.row = 0;
    c.col = i;
    x += overlap;
    Pictures.push(c);
  }
  d.style.width = (x - overlap + w) + 'px';
  console.log(Pictures[0])
  console.log(Pictures[0].div)
  d.style.height = firstNumber(Pictures[0].div.style.height) + 'px';
}
function showElemProps(e) { console.log(e.id + '(' + getTypeOf(e) + ')' + ': x', e.offsetLeft, 'y', e.offsetTop, 'w', e.offsetWidth, 'h', e.offsetHeight, 'bg', e.style.backgroundColor, 'fg', e.style.color); }
function showElems(idlist) {
  for (const fid of idlist) {
    EID[fid].ms.show();
  }
}
function showElemSize(e) { console.log(e.id + ': x', e.offsetLeft, 'y', e.offsetTop, 'w', e.offsetWidth, 'h', e.offsetHeight); }
function showEquation(words, dParent, idForContainerDiv, sep = null, styleContainer = {}, styleWord = {}, styleLetter = {}, styleSep = {}, colorWhiteSpaceChars = true, preserveColorsBetweenWhiteSpace = true) {
  if (isEmpty(styleWord)) {
    let sz = 80;
    let fg = helleFarbe(G.color);
    styleWord = {
      margin: 8, padding: 8, rounding: '50%', w: 'auto', h: sz, display: 'flex', fg: fg, bg: 'transparent',
      'align-items': 'center', border: 'transparent', outline: 'none', fz: sz, 'justify-content': 'center',
    };
  }
  let dContainer = mDiv(dParent);
  if (!isEmpty(styleContainer)) mStyleX(dContainer, styleContainer); else mClass(dContainer, 'flexWrap');
  dContainer.id = idForContainerDiv;
  let inputGroups = [];
  let charInputs = [];
  let iWord = 0;
  let idx = 0;
  let numWords = words.length;
  for (const w of words) {
    let dGroup = mDiv(dContainer);
    mStyleX(dGroup, styleWord);
    dGroup.id = idForContainerDiv + '_' + iWord;
    let g = { dParent: dContainer, word: w, iWord: iWord, div: dGroup, oStyle: styleWord, ofg: dGroup.style.color, obg: dGroup.style.backgroundColor };
    inputGroups.push(g);
    let inputs = [];
    let iLetter = 0;
    let wString = w.toString();
    for (const l of wString) {
      let dLetter = mDiv(dGroup);
      if (!isEmpty(styleLetter)) mStyleX(dLetter, styleLetter);
      dLetter.innerHTML = l;
      let inp = { group: g, div: dLetter, letter: l, iLetter: iLetter, index: idx, oStyle: styleLetter, ofg: dLetter.style.color, obg: dLetter.style.backgroundColor };
      charInputs.push(inp);
      inputs.push(inp);
      iLetter += 1; idx += 1;
    }
    g.charInputs = inputs;
    if (iWord < words.length - 1 && isdef(sep)) {
      let dSep = mDiv(dContainer);
      dSep.innerHTML = sep;
      if (isdef(styleSep)) mStyleX(dSep, styleSep);
    }
    iWord += 1;
  }
  return [inputGroups, charInputs];
}
function showEventList() { document.getElementById('events').style.display = null; }
function ShowFenPosition() {
  $("#currentFenSpan").text(BoardToFen());
  let pl = SideChar[brd_side] == 'b' ? 'BLACK (AI)' : 'WHITE (you)';
  mStyle(dTitle, { align: 'left' });
  dTitle.innerHTML = `<div style='margin-left:78px;width:483px;text-align:center;'>Turn: ${pl}</div>`;
}
function showFleetingMessage(msg, dParent, styles = {}, ms = 3000, msDelay = 0, fade = true) {
  clearFleetingMessage();
  dFleetingMessage = mDiv(dParent);
  if (msDelay) {
    TOFleetingMessage = setTimeout(() => fleetingMessage(msg, dFleetingMessage, styles, ms, fade), msDelay);
  } else {
    TOFleetingMessage = setTimeout(() => fleetingMessage(msg, dFleetingMessage, styles, ms, fade), 10);
  }
}
function showFullObject(o, indent = 0, onlySimple = false) {
  for (const k in o) {
    if (isSimple(o[k])) console.log(' '.repeat(indent), k, o[k]);
    else if (!onlySimple) console.log(' '.repeat(indent), k, anyString3(o[k]));
    else {
      console.log(' '.repeat(indent), k);
      showFullObject(o[k], indent + 2);
    }
  }
}
function showGame() { document.getElementById('R_d_root').style.display = null; }
function showGameConfig() { document.getElementById('gameConfig').style.display = null; }
function showGameTitle() { dGameTitle.innerHTML = G.friendly; }
function showGlobals() {
  getGlobals();
  console.log('Globals', Globals)
  dTable = mBy('dTable');
  let d = mDiv(dTable);
  for (const k in Globals) {
    let d1 = mDiv(d, {}, null, k);
    let d2 = mDiv(d, {}, null, Globals[k].map(x => x.key).join(',')); mFlexWrap(d2);
  }
}
function showGrid(cards, dParent) {
}
function showHand52(cards, dParent, splayed = 'left', w, h) {
}
function showHands(oid, propList, cardFunc, areaName) {
}
function showHiddenThumbsUpDown(sz = 100) {
  let d = mDiv(dTable, { hmin: sz * 1.5 });
  mCenterFlex(d);
  let keys = ['thumbs up', 'thumbs down'];
  let options = getOptionsMinimalistic(d, null, 300, 100, { bg: 'transparent', display: 'inline' }, {}, G);
  let items = Pictures = genItemsFromKeys(keys, options);
  for (const item of items) {
    let d1 = makeItemDiv(item, options);
    mAppend(d, d1);
    mStyleX(d1.firstChild, { fz: sz, mabottom: 12 });
    mStyleX(d1, { opacity: 0 });
  }
}
function showInnoCards(keys, dParent, wCard = 200) {
  Pictures = [];
  let dims = calcRowsColsX(keys.length);
  let idx = 0;
  for (let i = 0; i < dims.rows; i++) {
    for (let j = 0; j < dims.cols; j++) {
      if (keys.length <= idx) break;
      let c = cardInnoz(keys[idx], wCard); idx += 1;
      mAppend(dParent, c.div);
      c.row = i;
      c.col = j;
      Pictures.push(c);
    }
  }
}
function showInstruction(text, cmd, dParent, isSpoken, spoken, fz, voice) {
  clearElement(dParent);
  let d = mDiv(dParent);
  mStyleX(d, { margin: 15 })
  mClass(d, 'flexWrap');
  let msg = cmd + " " + `<b>${text.toUpperCase()}</b>`;
  if (nundef(fz)) fz = 36;
  let d1 = mText(msg, d, { fz: fz, display: 'inline-block' });
  if (isSpoken) {
    let sym = symbolDict.speaker;
    let d2 = mText(sym.text, d, {
      fz: fz + 2, weight: 900, display: 'inline-block',
      family: sym.family, 'padding-left': 14
    });
  }
  dFeedback = dInstruction = d;
  spoken = isSpoken ? isdef(spoken) ? spoken : cmd + " " + text : null;
  dInstruction.addEventListener('click', () => aniInstruction(spoken));
  if (!isSpoken) return;
  sayRandomVoice(isdef(spoken) ? spoken : (cmd + " " + text), null, "david");
}
function showInstructionX(written, dParent, spoken, { fz, voice } = {}) {
  clearElement(dParent);
  let d = mDiv(dParent);
  mStyleX(d, { margin: 15 })
  mClass(d, 'flexWrap');
  if (nundef(fz)) fz = 36;
  let d1 = mText(written, d, { fz: fz, display: 'inline-block' });
  let sym = symbolDict.speaker;
  let d2 = mText(sym.text, d, {
    fz: fz + 2, weight: 900, display: 'inline-block',
    family: sym.family, 'padding-left': 14
  });
  dFeedback = dInstruction = d;
  dInstruction.addEventListener('click', () => aniInstruction(spoken));
  if (isdef(spoken)) sayRandomVoice(spoken, spoken, voice);
}
function showJoinConfig() { show('joinConfig'); }
function showLabelPercentHintAfter(percent, msecs) {
  let len = Goal.label.length;
  let sublen = Math.floor(len * percent / 100); let restlen = len - sublen;
  let hintWord = Goal.label.substring(0, sublen);
  for (let i = 0; i < restlen; i++) hintWord += ' _';
  hintWord = hintWord.toUpperCase();
  showFleetingMessage(hintWord, msecs, { fz: 32 });
}
function showLbls(onClickPictureHandler, ifs = {}, options = {}, keys, labels) {
  let items = getLbls(onClickPictureHandler, ifs, options, keys, labels);
  presentItems(items, dTable, 1);
  return items;
}
function showLevel() {
  dLevel.innerHTML = 'level: ' + (G.level + 1) + '/' + (G.maxLevel + 1);
}
function showLevelComplete() {
  if (!skipAnimations) {
    soundLevelComplete();
    mClass(mBy('dLevelComplete'), 'aniFadeInOut');
    show('dLevelComplete');
    setTimeout(levelStep10, 1500);
  } else {
    addBadge(dLeiste, currentLevel);
    setBackgroundColor();
    proceedIfNotStepByStep();
  }
}
function showListOfLists(arr) { let s = ''; arr.map(x => { s += '[' + x.toString() + '] ' }); return s; }
function showLoader() { mBy('dLoader').style.display = "unset"; }
function showLobby() {
  document.getElementById('a_d_lobby').style.display = null;
  if (!USE_SOCKETIO) { document.getElementById('a_d_chat').style.display = 'none'; }
}
function showLog(pl) { let d = LOG[pl]; if (d) show(d); }
function showLogin() { document.getElementById('a_d_login').style.display = null; }
function showMenu(desc) {
  let d = mBy('div' + desc);
  if (!isVisible(d)) {
    let b = mBy('b' + desc);
    show(d);
    d.style.display = 'inline';
    b.innerHTML = '-' + desc[0];
  }
}
function showMouse() {
  var x = dTable.getElementsByTagName("DIV");
  if (nundef(x) || nundef(x[0]) || nundef(x[0].prevCursor)) { console.log('did NOT hide mouse!'); return; }
  for (const el of x) {
    mRemoveClass(el, 'noCursor');
  }
  for (const el of x) { el.style.cursor = el.prevCursor; }
  for (const p of Pictures) {
    mRemoveClass(iDiv(p), 'noCursor');
    mClass(iDiv(p), 'frameOnHover'); iDiv(p).style.cursor = 'pointer';
    for (const ch of iDiv(p).children) ch.style.cursor = 'pointer';
  }
}
function showMouseAvatar(username) { show(getAvatar(username)); }
function showNodeInfo(n, title, lst, lstOmit) {
  if (nundef(title)) title = 'node';
  let args = [];
  if (isList(lst)) {
    for (const prop of lst) {
      if (isdef(n[prop])) args.push(prop + ': ' + anyString3(n[prop]));
    }
  } else {
    for (const prop in n) {
      if (lstOmit.includes(prop)) continue;
      args.push(prop + ': ' + anyString3(n[prop]));
    }
  }
  let s = title + '\n' + args.join('\n');
  console.log(s);
}
function showNumberSequence(words, dParent, idForContainerDiv = 'seqContainer', sep = null, styleContainer = {}, styleWord = {}, styleLetter = {}, styleSep = {}, colorWhiteSpaceChars = true, preserveColorsBetweenWhiteSpace = true) {
  if (isEmpty(styleWord)) {
    let sz = 80;
    styleWord = {
      margin: 10, padding: 4, rounding: '50%', w: sz, h: sz, display: 'flex', fg: 'lime', bg: 'yellow', 'align-items': 'center',
      border: 'transparent', outline: 'none', fz: sz - 25, 'justify-content': 'center',
    };
  }
  let dContainer = mDiv(dParent);
  if (!isEmpty(styleContainer)) mStyleX(dContainer, styleContainer); else mClass(dContainer, 'flexWrap');
  dContainer.id = idForContainerDiv;
  let inputGroups = [];
  let charInputs = [];
  let iWord = 0;
  let idx = 0;
  let numWords = words.length;
  let wheel = getHueWheel(G.color, 40, numWords <= 4 ? 60 : numWords <= 10 ? 30 : 15, 0);
  wheel = wheel.map(x => colorHSLBuild(x, 100, 50));
  wheel = shuffle(wheel);
  let wheel1 = colorPalShadeX(colorFrom(wheel[0]), numWords);
  wheel = jsCopy(wheel1);
  if (G.op == 'plus') wheel.reverse();
  for (const w of words) {
    let dGroup = mDiv(dContainer);
    mStyleX(dGroup, styleWord);
    let bg = wheel[iWord]; // dGroup.style.backgroundColor=randomColorX(G.color,40,60,0,50,50);//'yellow';//randomColorX(G.color,70,80);
    dGroup.style.backgroundColor = bg;
    dGroup.style.color = colorIdealText(bg);
    dGroup.id = idForContainerDiv + '_' + iWord;
    let g = { dParent: dContainer, word: w, iWord: iWord, div: dGroup, oStyle: styleWord, ofg: dGroup.style.color, obg: dGroup.style.backgroundColor };
    inputGroups.push(g);
    let inputs = [];
    let iLetter = 0;
    let wString = w.toString();
    for (const l of wString) {
      let dLetter = mDiv(dGroup);
      if (!isEmpty(styleLetter)) mStyleX(dLetter, styleLetter);
      dLetter.innerHTML = l;
      let inp = { group: g, div: dLetter, letter: l, iLetter: iLetter, index: idx, oStyle: styleLetter, ofg: dLetter.style.color, obg: dLetter.style.backgroundColor };
      charInputs.push(inp);
      inputs.push(inp);
      iLetter += 1; idx += 1;
    }
    g.charInputs = inputs;
    if (iWord < words.length - 1 && isdef(sep)) {
      let dSep = mDiv(dContainer);
      dSep.innerHTML = sep;
      if (isdef(styleSep)) mStyleX(dSep, styleSep);
    }
    iWord += 1;
  }
  return [inputGroups, charInputs];
  return { words: inputGroups, letters: charInputs };
  return [wi.words, wi.letters];
}
function showObject(o, indent = 0, simple = true, lstShow = null, lstOmit = null) {
  let s = extendedObjectString(o, indent, simple, lstShow, lstOmit);
  console.log(s);
}
function showPackages(data, domid = 'OLDCODE') {
  let d = mBy(domid);
  if (d) { d.innerHTML = '<pre>' + jsonToYaml(data) + '</pre>'; }
}
function showPicLabel(key, label, area, color = 'blue', x = 0, y = 0, sz = 50, gap = 4) {
  console.log(key, label, area, color, x, y, sz, gap)
  let dOuter = mCreate('div');
  let wOuter = sz;
  let wInner = sz - 2 * gap;
  mStyle(dOuter, {
    color: 'black',
    width: wOuter,
    left: x,
    top: y,
    padding: 0,
    position: 'absolute',
    'text-align': 'center',
    'background-color': randomColor(),
    display: 'inline'
  });
  let dPic = addPictoDiv(key, dOuter, color, wInner);
  mStyle(dPic, { margin: gap, 'margin-bottom': 1 })
  let dText = mAppendText(dOuter, label);
  dText.classList.add('truncate');
  mStyle(dText, { 'margin-bottom': gap, width: wOuter });
  area = asElem(area);
  mPosRel(area);
  mAppend(area, dOuter);
}
function showPicLabelCentered(key, label, area, color = 'blue', sz = 50, gap = 4) {
  let d = showPicLabel(key, label, area, color, 0, 0, sz, gap);
}
function showPics(onClickPictureHandler, ifs = {}, options = {}, keys, labels) {
  let items = getPics(onClickPictureHandler, ifs, options, keys, labels);
  console.log(items);
  presentItems(items, dTable, options.rows);
  return items;
}
function showPicsS(onClickPictureHandler, ifs = {}, options = {}, keys, labels) {
  let items = getPicsS(onClickPictureHandler, ifs, options, keys, labels);
  presentItems(items, dTable, options.rows);
  return items;
}
function showPictoDiv(key, area, color = 'blue', x = 0, y = 0, w = 50, h = 0) {
  let d = pictoDiv(key, color, w, h ? h : w);
  mAppend(area, d);
  mPos(d, x, y);
  return d;
}
function showPictoDivCentered(key, area, color = 'blue', sz = 50) {
  let d = pictoDiv(key, color, sz, sz);
  mAppend(area, d);
  posCIC(d);
  return d;
}
function showPictureGrid(n = 9, dParent, ifs = {}, options = {}) {
  let items = detectItems(n);
  console.log('item', items[0]);
  for (let i = 0; i < items.length; i++) {
    let info = items[i].info;
    let d = mDiv(dParent, { w: 200, h: 200, bg: 'red' });
    d.innerHTML = 'hallo';
    let dpic = mDiv(d, { fz: 100, family: 'emoNoto' });
    dpic.innerHTML = info.text;
  }
}
function showPictureHints(items, dParentProp) {
  for (const item of items) {
    let d1 = item[dParentProp];
    mRemoveChildrenFromIndex(d1, 1);
    let dHint = item.dHint = miPic(item, d1);
  }
}
function showPictures(dParent, handler, ifs = {}, options = {}, keys, labels) {
  options = getOptionsMinimalistic(dParent, handler, options.w, options.h, ifs, options, G);
  if (nundef(keys)) keys = choose(G.keys, G.numPics);
  let items = genItemsFromKeys(keys, options);
  if (isdef(labels)) {
    options.showLabels = true;
    for (let i = 0; i < items.length; i++) item[i].label = labels[i % labels.length];
  }
  let dArea = mDiv(dParent);
  let rect = myPresent(dArea, items, options);
  return items;
}
function showPlayer(i) {
  let id;
  id = getidNum(i); show(id);
  id = getidSpan(i); show(id);
  id = getidType(i); show(id);
}
function showPlayerHand(oid, propName, cardFunc, areaName) { showCollections(collections, oid, [propName], cardFunc, areaName); }
function showPlayerHand_dep(plid, propName, areaName) {
  let oPlayer = G.playersAugmented[plid];
  let oCards = oPlayer[propName];
  if (isSet(oCards)) oCards = oCards._set;
  if (!isListOfLiterals(oCards)) { alert('wrong format of cards property: ' + propName); }
  let oids = oCards.map(x => x._obj);
  let idHand = getIdArea(areaName);
  if (_handChanged(oids, idHand)) {
    _clearHand(idHand);
    _showHand(oids, idHand);
  }
}
function showPlayerHandNew(name, cardArr, areaName) {
  if (isSet(cardArr)) cardArr = cardArr._set;
  if (!isListOfLiterals(cardArr)) { alert('wrong format of cards property: ' + propName); }
  let oids = cardArr.map(x => isdef(x._obj) ? x._obj : x);
  let idHand = getIdArea(areaName);
  if (_handChanged(oids, idHand)) {
    _clearHand(idHand, 'hand');
    _showHand(oids, idHand, 'hand');
  }
}
function showPlayerStats(plid, propName, areaName) {
  let oPlayer = G.playersAugmented[plid];
  let oStatsVal = oPlayer[propName];
  let msStats = UIS[getIdArea(areaName)];
}
function showProps(ms) { console.log(ms.id + '(' + getTypeOf(ms) + ')' + ': x', ms.x, 'y', ms.y, 'w', ms.w, 'h', ms.h, 'bg', ms.bg, 'fg', ms.fg); }
function showRect(s, o) {
  let r = o.rect;
  console.log('\n', s, 'w', Math.round(r.w), '=', Math.round(r.l), Math.round(r.r), 'h', Math.round(r.h), '=', Math.round(r.t), Math.round(r.b));
}
function showRectReal(s, o) {
  let r = o.rect;
  console.log('\n', s, 'w', r.w, '=', r.l, r.r, 'h', r.h, '=', r.t, r.b);
}
function showSayHint(i) {
  let [spoken, written] = G.hintFunc(i);
  if (spoken) sayRandomVoice(spoken);
  if (written) showFleetingMessage(written, 0, { fz: 40 });
}
function showScore() {
  if (G.controllerType == 'solitaire') {
    if (Score.gameChange) showBadgesX(dLeiste, G.level, onClickBadgeX, G.maxLevel);
    let scoreString = 'question: ' + (Score.nTotal + 1) + '/' + G.samplesPerGame;
    if (Score.levelChange) {
      dScore.innerHTML = scoreString;
      setBadgeLevel(G.level);
    } else {
      setTimeout(() => {
        dScore.innerHTML = scoreString;
        setBadgeLevel(G.level);
      }, 300);
    }
  } else {
    setTimeout(() => { dScore.innerHTML = 'score ' + GC.human.score + ':' + GC.ai.score; }, 300);
  }
}
function showScore_dep(showScoreString = true) {
  if (G.controllerType == 'solitaire') {
    if (Score.gameChange) showBadgesX(dLeiste, G.level, onClickBadgeX, G.maxlevel);
    if (showScoreString) scoreString = 'question: ' + (Score.nTotal + 1) + '/' + G.samplesPerGame;
    if (Score.levelChange) {
      if (showScoreString) dScore.innerHTML = scoreString;
      setBadgeLevel(G.level);
    } else {
      setTimeout(() => {
        if (showScoreString) dScore.innerHTML = scoreString;
        setBadgeLevel(G.level);
      }, 300);
    }
  } else {
    setTimeout(() => { if (showScoreString) dScore.innerHTML = 'score ' + GC.human.score + ':' + GC.ai.score; }, 300);
  }
}
function showServerData(data, domid = 'SERVERDATA') {
  let d = mBy(domid);
  if (d && SHOW_SERVERDATA) { d.innerHTML = '<pre>' + jsonToYaml(data) + '</pre>'; }
}
function showSetSizes(nLast, R) {
  for (const uid in R.uiNodes) {
    let n = R.uiNodes[uid];
    if (nundef(n.size)) setSP(n);
  }
}
function showShield() { mBy('dShield').style.display = 'block'; }
function showSignatureContent(ev) {
  let id = evToClosestId(ev);
  ev.cancelBubble = true;
  let ifunc = firstNumber(id);
  let path = stringAfter(id, '@');
  let pathEntry = DOC_vault[path];
  let funcName = pathEntry.funcIndex[ifunc];
  let funcEntry = pathEntry.funcDict[funcName];
  let divPath = document.getElementById(pathEntry.idPathContainer);
  if (!isVisible(divPath)) setCurrentPath(pathEntry.filename);
  let funcDiv = mBy(funcEntry.idDiv);
  funcDiv.scrollIntoView(true);
}
function showSingle52(dParent, rank, suit, w, h) {
  let c = card52(rank, suit, w, h);
  mAppend(dParent, c.div);
  return c;
}
function showSize(ms) { console.log(ms.id + ': x', ms.x, 'y', ms.y, 'w', ms.w, 'h', ms.h); }
function showSizes(nLast, R) {
  for (const uid in R.uiNodes) {
    let n = R.uiNodes[uid];
    if (isdef(n.size) && isdef(n.sizeNeeded)) {
      console.log(n.uid, 'size', n.size.w, n.size.h, 'measured', n.sizeMeasured.w, n.sizeMeasured.h, 'needed', n.sizeNeeded.w, n.sizeNeeded.h,);
    } else {
      setSP(n);
      console.log(n.uid, 'size', n.size.w, n.size.h, 'pos', n.pos.x, n.pos.y);
    }
  }
}
function showSpoken() { }
function showState() {
  console.log('______________', G.friendly);
  console.log(T.players)
}
function showStats() {
  if (nundef(Score)) initScore();
  showGameTitle();
  showLevel();
  showScore();
  Score.levelChange = false;
  Score.gameChange = false;
}
function showString(x, proplist, include = true) {
  console.log(anyString3(x, 0, proplist, include));
}
function showsub(n) {
  console.log('sub:')
  if (nundef(n.sub)) {
    console.log('NO sub!!!', n)
  } else if (isList(n.sub)) {
    n.sub.map(x => console.log(x));
  } else {
    console.log(n.sub);
  }
}
function showSvg(elem) {
  elem.setAttribute('style', 'visibility:visible');
}
function showTextHints(items, dParentProp, textProp, removeFirst = true) {
  for (const item of items) {
    let d1 = item[dParentProp];
    let hint = item[textProp];
    let dHint = item.dHint = mText(hint, d1);
  }
}
function showTree(o, childrenKeys = ['sub', 'elm'], plus, minus) {
  recShowTree(o, 0, childrenKeys, plus, minus);
}
function showTrick() {
  let dZone = Zones.table.dData;
  let d = mDiv(dZone);
  mStyleX(d, { display: 'flex', position: 'relative' });
  let zIndex = 1;
  for (let i = 0; i < T.trick.length; i++) {
    let c = T.trick[i];
    let direction = i == 0 ? { x: 0, y: -1 } : { x: 0, y: 1 };
    let displ = 10;
    let offset = { x: -35 + direction.x * displ, y: direction.y * displ };
    let d1 = c.div;
    mAppend(d, d1);
    mStyleX(d1, { position: 'absolute', left: offset.x, top: offset.y, z: zIndex });
    zIndex += 1;
  }
}
function showTT(ev) {
  if (TTMS) {
    $(TTMS.elem).off('mouseover');
    console.log('hallo')
    let d = document.getElementById('tooltip');
    clearElement(d);
    let t = tableElem(TTMS.o);
    d.appendChild(t);
    $('div#tooltip').css({
      display: 'inline-block',
      top: ev.pageY,
      left: ev.pageX,
    });
    TTMS = null;
  }
}
function showUsernameOnScreen(isEditable = true) {
  let uiName = 'spUser';
  let dUser = mBy(uiName);
  if (isdef(dUser)) return;
  dUser = isEditable ? editableUsernameUi(dLineTopLeft) : mText(Session.cur_user, dLineTopLeft);
  dUser.id = uiName;
}
function showWritten(cmd, vocab, dParent, styles) { }
function shuffle(arr) { if (isEmpty(arr)) return []; else return fisherYates(arr); }
function shuffle_children(d) {
  let arr = Array.from(d.children);
  shuffle(arr);
  for (const ch of arr) { mAppend(d, ch); }
}
function shuffleChildren(dParent) { shuffle_children(dParent); }
function shuffletest(list) {
  for (let i = 0; i < 100; i++) {
    shuffle(list);
    console.log('shuffle: ' + jsCopy(list));
  }
}
function sidebar_transition_off() {
  let d = mBy('left_panel');
  mClass(d, 'notransition');
}
function sidebar_transition_on() {
  let d = mBy('left_panel');
  mClass(d, 'alltransition');
}
function sieveLocOids(R) {
  if (isEmpty(R.locOids)) return;
  calcCycles(R);
  for (const k in R.partitions) {
    let cycle = R.partitions[k];
    let max_cycles = cycle.isCycle ? DEFS.cycleLengthAllowed : 1;
    processLocOids(cycle.oids, max_cycles, cycle.isCycle, R);
  }
}
function simple_gaussian(canvas) {
  var mean = 100;
  var b = 25;
  var stdev = 10;
  let variance = stdev * stdev;
  var cv = canvas.cv;
  var cx = canvas.cx;
  cx.strokeStyle = 'silver';
  let width_of_rect = cv.width / (4 * b); let w = width_of_rect;
  for (var j = 0; j < 2 * b; j++) {
    let x = j - b;
    var y = mean / Math.E ** (((j - b) ** 2) / (2 * variance));
    console.log('x', x, 'y', y)
    cx.rect(j * w + 125, cv.height - y, w, y);
    cx.stroke();
  }
}
function simpleColors(c = 'powderblue') {
  let pal = getPalette(c);
  S.settings.palette = pal;
  ROOT.children.map(x => UIS[x].setBg(pal[2], true));
  setCSSVariable('--bgBody', pal[5]);
  UIS['a_d_header'].setBg(pal[7]);
  UIS['a_d_action_header'].setBg(pal[3]);
  UIS['a_d_history_header'].setBg(pal[3]);
  UIS['a_d_game'].setBg(pal[1]);
  let c1 = pal[1];
  setCSSVariable('--bgTabActive', c1);
  setCSSVariable('--bgTabContent', c1);
  UIS['a_d_testing'].setBg(pal[2]);
  UIS['a_d_testing'].children.map(x => { UIS[x].setBg(c1); UIS[x].setFg('silver'); });
  setCSSVariable('--bgButton', pal[0]);
  setCSSVariable('--fgButton', 'white');
  setCSSVariable('--bgButtonHover', pal[3]);
  setCSSVariable('--bgButtonActive', pal[5]);
}
function simpleCompare(o1, o2) {
  let s1 = object2string(o1);
  let s2 = object2string(o2);
  return s1 == s2;
}
function simpleFit(text, wmax, hmax, fz) {
  let sz = { h: 10000 };
  while (sz.h > hmax && fz > 8) {
    sz = getSizeWithStyles(text, { w: wmax, fz: fz });
    fz -= 1;
  }
  sz.fz = fz;
  return sz;
}
function simpleGridToServerData(b1) {
  let bo1 = {};
  let fields = bo1.fields = { _set: b1.fields.map(oid => { return { _obj: oid }; }) };
  let edges = null;
  if (b1.hasEdges) {
    edges = bo1.edges = { _set: b1.edges.map(oid => { return { _obj: oid }; }) };
  }
  let corners = null;
  if (b1.hasNodes) {
    corners = bo1.corners = { _set: b1.corners.map(oid => { return { _obj: oid }; }) };
  }
  bo1.rows = b1.rows;
  bo1.cols = b1.mapData[0].length;
  let obj_type = bo1.obj_type = 'Board';
  if (this.shape == 'hex') {
    let maxColIndex = 2 * b1.colarr[b1.imiddleRow] - 1;
    console.assert(maxColIndex == bo1.cols, 'maxColIndex is NOT correct!!!!!!!!', maxColIndex, bo1.cols)
  }
  bo1.map = b1.mapData;
  return bo1;
}
function simpleLayoutForOneChildPosition(nBoard, tile, R) {
  let ch = tile.children[0];
  let robber = R.uiNodes[ch];
  let ui = robber.ui;
  ui.style.position = 'absolute';
  ui.style.display = 'inline-block';
  let x = nBoard.size.w / 2 + tile.pos.x - robber.size.w / 2;
  let y = nBoard.size.h / 2 + tile.pos.y - robber.size.h / 2;
  ui.style.left = x + 'px';
  ui.style.top = y + 'px';
  robber.pos = { x: x, y: y };
  ui.style.margin = '0px';
}
function simpleLayoutForOneChildSizeNeeded(ch, R) {
  let nChild = R.uiNodes[ch];
  let wNeeded = nChild.size.w + 12;
  let hNeeded = nChild.size.h + 12;
  return { w: wNeeded, h: hNeeded };
}
function simpleRep(val) {
  if (nundef(val) || val === '') {
    return '_';
  } else if (isSimple(val)) return val;
  else if (isList(val)) {
    return '[' + val.map(x => simpleRep(x)).join(', ') + ']';
  } else if (typeof val == 'object') {
    let s = [];
    for (const k in val) {
      if (isEmpty(val[k])) continue;
      let s1 = simpleRep(val[k]);
      if (k == '_set') s1 = '{' + s1.substring(1, s1.length - 1) + '}';
      s.push(s1);
    }
    return s.join(', ');
  }
}
function simpleSizes(wGame = 1000, hGame = 800, wSide = 200) {
  return;
  setCSSVariable('--wGame', wGame + 'px');
  setCSSVariable('--hGame', hGame + 'px');
  setCSSVariable('--wActions', wSide + 'px');
  setCSSVariable('--wLog', wSide + 'px');
  setCSSVariable('--hStatus', 'auto');
  setCSSVariable('--hTesting', '100%');
}
function simpleSizes_unused(wGame = 1000, hGame = 800, wSide = 200) {
  setCSSVariable('--wGame', wGame + 'px');
  setCSSVariable('--hGame', hGame + 'px');
  setCSSVariable('--wActions', wSide + 'px');
  setCSSVariable('--wLog', wSide + 'px');
  setCSSVariable('--hStatus', 'auto');
  setCSSVariable('--hTesting', '100%');
}
function simplest_game_open_for_move_dep(obj) {
  for (const k in obj) { if (isdef(Session[k])) copyKeys(obj[k], Session[k]); else Session[k] = obj[k]; }
  Session.cur_table = Session.table;
  console.assert(isdef(Session.cur_user) && Session.cur_game == Session.table.game && Session.cur_tid == Session.table.id, "SESSION MISMATCH IN GAME_OPEN_FOR_MOVE!!!!!!!!!!!!!!!!!!!!!");
  open_game_ui();
  G = open_game(Session.cur_user, Session.cur_game);
  G.make_players(Session.table);
  G.startGame(Session.cur_fen);
}
function simplestPerlenGame() {
  hide('dMainContent');
  show('dGameScreen');
  setTitle('Glasperlenspiel');
  setSubtitle('logged in as ' + Username);
  mStyleX(document.body, { opacity: 1 });
  initTable(null, 2); initSidebar(); initAux(); initScore();
  ColorThiefObject = new ColorThief();
  sendStartOrJoinPerlenGame();
}
function simpleWordListFromString(s, sep = [' ']) {
  let lst = listFromString(s);
  let res = [];
  for (const w of lst) {
    let parts = w.split(sep);
    parts.map(x => addIf(res, x));
  }
  return res;
}
function simplifyFraction(numerator, denominator) {
  var gcd = function gcd(a, b) {
    return b ? gcd(b, a % b) : a;
  };
  gcd = gcd(numerator, denominator);
  return [numerator / gcd, denominator / gcd];
}
function simulateClick(elem) {
  var evt = new MouseEvent('click', { bubbles: true, cancelable: true, view: window });
  var canceled = !elem.dispatchEvent(evt);
}
function single_poly_feature(f) {
  if (f.geometry.type == 'MultiPolygon') {
    let max_area_polygon;
    let max_area = 0;
    for (poly in (f.geometry.coordinates)) {
      let polygon1 = turf.polygon((f.geometry.coordinates)[poly])
      area = turf.area(polygon1);
      if (area > max_area) {
        max_area = area
        max_area_polygon = polygon1;
      }
    }
    return max_area_polygon;
  } else return f;
}
function size2hex(w = 100, h = 0, x = 0, y = 0) {
  let hexPoints = [{ X: 0.5, Y: 0 }, { X: 1, Y: 0.25 }, { X: 1, Y: 0.75 }, { X: 0.5, Y: 1 }, { X: 0, Y: 0.75 }, { X: 0, Y: 0.25 }];
  if (h == 0) {
    h = (2 * w) / 1.73;
  }
  return polyPointsFrom(w, h, x, y, hexPoints);
}
function size2tridown(w = 100, h = 0, x = 0, y = 0) {
  let triPoints = [{ X: 1, Y: 0 }, { X: 0.5, Y: 1 }, { X: 0, Y: 0 }];
  if (h == 0) { h = w; }
  return polyPointsFrom(w, h, x, y, triPoints);
}
function size2triup(w = 100, h = 0, x = 0, y = 0) {
  let triPoints = [{ X: 0.5, Y: 0 }, { X: 1, Y: 1 }, { X: 0, Y: 1 }];
  if (h == 0) { h = w; }
  return polyPointsFrom(w, h, x, y, triPoints);
}
function sizedCard123(w, h) { return o => card123(o, w, h); }
function sizeToContent(uid) {
  let n = R.uiNodes[uid];
  if (nundef(n.children)) return { w: 0, h: 0 }
  parentPadding = isdef(n.params.paddingAroundChildren) ? n.params.paddingAroundChildren : DEFS.defaultPadding;
  childMargin = isdef(n.params.gapBetweenChildren) ? n.params.gapBetweenChildren : DEFS.defaultGap;
  let or = n.params.orientation;
  let bl = n.params.baseline;
  let [y0, wTitle] = calcParentContentYOffsetAndWidth(n, parentPadding);
  let children = n.children.map(x => R.uiNodes[x]);
  let axMain, ax2;
  if (or == 'v') { axMain = 'h'; ax2 = 'w'; } else { axMain = 'w'; ax2 = 'h'; }
  let ax2Max = Math.max(...children.map(x => x.size[ax2]));
  let axMainSum = children.reduce((a, b) => a + (b.size[axMain] || 0), 0);
  axMainSum += childMargin * (children.length - 1);
  let wmax = (or == 'v' ? ax2Max : axMainSum);
  let xoff = 0;
  if (wTitle > wmax) xoff = (wTitle - wmax) / 2;
  let x0 = parentPadding + xoff;
  let x = x0;
  let y = y0;
  let lastChild = R.uiNodes[n.children[n.children.length - 1]];
  for (const n1 of children) {
    if (or == 'v') {
      switch (bl) {
        case 'start': x = x0; break;
        case 'end': x = x0 + ax2Max - n1.size[ax2]; break;
        case 'centered': x = x0 + (ax2Max - n1.size[ax2]) / 2; break;
        case 'stretch':
          x = x0;
          if (n1.size.w < ax2Max) {
            n1.size.w = ax2Max;
            n1.ui.style.minWidth = n1.size.w + 'px';
          }
          break;
        default: x = x0 + (ax2Max - n1.size[ax2]) / 2; break;
      }
      n1.pos = { x: x, y: y, cx: x + n1.size.w / 2, cy: y + n1.size.h / 2 };
      y += n1.size[axMain];
      if (n1 != lastChild) y += childMargin;
    } else {
      switch (bl) {
        case 'start': y = y0; break;
        case 'end': y = y0 + ax2Max - n1.size[ax2]; break;
        case 'centered': y = y0 + (ax2Max - n1.size[ax2]) / 2; break;
        case 'stretch':
          y = y0;
          if (n1.size.h < ax2Max) {
            n1.size.h = ax2Max;
            n1.ui.style.minHeight = n1.size.h + 'px';
          }
          break;
        default: y = y0 + (ax2Max - n1.size[ax2]) / 2; break;
      }
      n1.pos = { x: x, y: y, cx: x + n1.size.w / 2, cy: y + n1.size.h / 2 };
      x += n1.size.w;
      if (n1 != lastChild) x += childMargin;
    }
    n1.ui.style.left = n1.pos.x + 'px';
    n1.ui.style.top = n1.pos.y + 'px';
  }
  let wParent, hParent;
  if (or == 'h') {
    wParent = Math.max(wTitle + parentPadding * 2, x + parentPadding);
    hParent = y0 + ax2Max + parentPadding;
  } else {
    wParent = Math.max(wTitle + parentPadding * 2, ax2Max + 2 * x0);
    hParent = y0 + axMainSum + parentPadding;
  }
  return { w: wParent, h: hParent };
}
function skipToLine(lines, i, options) {
  options = convertToList(options);
  while (i < lines.length) {
    for (const s of options) {
      if (lines[i].includes(s)) {
        return { index: i, option: s };
      }
    }
    i += 1;
  }
  return { index: i, option: null };
}
function skype_go_button() {
  let html = `
    <button
      role="button"
      title="Send message"
      aria-label="Send message"
      aria-disabled="false"
      style="
        position: relative;
        display: flex;
        flex-direction: column;
        flex-grow: 0;
        flex-shrink: 0;
        overflow: visible;
        align-items: center;
        justify-content: center;
        app-region: no-drag;
        background-color: transparent;
        border-color: transparent;
        text-align: left;
        border-width: 0px;
        height: 44px;
        width: 44px;
        padding: 0px;
        cursor: pointer;
        border-style: solid;
      "
    >
      <div
        role="none"
        style="
          position: absolute;
          display: flex;
          flex-direction: column;
          flex-grow: 0;
          flex-shrink: 0;
          overflow: hidden;
          align-items: center;
          background: linear-gradient(135deg, rgb(0, 188, 242), rgb(0, 120, 212));
          height: 40px;
          width: 40px;
          border-radius: 20px;
          top: 2px;
          left: 2px;
          justify-content: center;
        "
      >
        <div
          role="none"
          aria-hidden="true"
          style="position: relative; display: flex; flex-direction: column; flex-grow: 0; flex-shrink: 0; overflow: hidden; align-items: stretch; margin-left: 2px"
        >
          <svg width="20" height="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#FFFFFF" gradientcolor1="#FFFFFF" gradientcolor2="#FFFFFF">
            <path
              d="M5.694 12L2.299 3.272c-.236-.608.356-1.189.942-.982l.093.04 18 9a.75.75 0 01.097 1.283l-.097.058-18 9c-.583.291-1.217-.245-1.065-.847l.03-.096L5.694 12 2.299 3.272 5.694 12zM4.402 4.54l2.61 6.71h6.627a.75.75 0 01.743.648l.007.102a.75.75 0 01-.649.743l-.101.007H7.01l-2.609 6.71L19.322 12 4.401 4.54z"
            ></path>
          </svg>
        </div>
      </div>
    </button>
  `;
  return mCreateFrom(html);
}
function skype_start() {
  let d = mBy('dSkype'); mClear(d);
  mStyle(d, { h: 'calc( 100vh - 56px )', 'overflow-y': 'hidden' });
  let d0 = mDiv(d);
  let [dl, dr] = mColFlex(d, [1, 3]);
  mStyle(dl, { border: '1px dotted silver' }); mStyle(dr, { border: '1px dotted silver' });
  mDiv(dl, {}, null, img_html('skypeTopLeft.jpg'));
  let d1 = mDiv(dl);
  DIBOA.skype.divRight = dr;
  DIBOA.skype.divLeft = dl;
  let contacts = DIBOA.skype.contacts = generate_skype_contacts(25); console.log(contacts)
  for (const o of contacts) {
    let dc = mDiv(d1, { rounding: 12, hpadding: 6, vpadding: 6, margin: 4, gap: 12, overflow: 'hidden' }, null, null, 'skypecontact');
    mFlex(dc);
    o.div = dc;
    dc.onclick = () => { S.skype_contact = toggleSelection(o, S.skype_contact, 'skypecontact_active'); show_skype_contact(dr) };
    let [sz] = [40];
    let dimg = get_skype_phone_icon(o.color);
    mAppend(dc, dimg);
    let dmiddle = mDiv(dc, { flex: 8 });
    let dnum = mDiv(dmiddle, { fz: 14, fg: 'black' }, null, `<div>${o.num}</div>`);
    let dmsg = mDiv(dmiddle, { fz: 11, fg: 'grey' }, null, `<div>${o.msg}</div>`);
    let ddate = mDiv(dc, { flex: 1, fz: 11, fg: 'grey' }, null, `<div>${format_date(o.date)}</div>`);
  }
}
function sleepX(msecs) {
  //#region doc 
  //#endregion 
  return new Promise(r => setTimeout(r, msecs));
}
function slowlyTurnFaceDown(pic, secs = 5, removeBg = false) {
  let ui = iDiv(pic);
  for (const p1 of ui.children) {
    p1.style.transition = `opacity ${secs}s ease-in-out`;
    p1.style.opacity = 0;
  }
  if (removeBg) {
    ui.style.transition = `background-color ${secs}s ease-in-out`;
    ui.style.backgroundColor = 'dimgray';
  }
  pic.isFaceUp = false;
}
function small_hands(o) {
  let [fen, uplayer] = [o.fen, o.fen.turn[0]];
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    pl.hand.sort();
    pl.hand = arrTake(pl.hand, 7);
  }
}
function snail(p, o, d) {
  if (o.length == 0) return;
  testHelpers(p, o);
  o[0].setPos(p.x, p.y);
  n = o.length;
  let step = 1;
  let k = 1;
  while (true) {
    for (i = 0; i < step; i++) {
      if (k < n) {
        p = mup(o[k], p, d);
        k += 1;
      } else return;
    }
    for (i = 0; i < step; i++) {
      if (k < n) {
        p = mri(o[k], p, d);
        k += 1;
      } else return;
    }
    step += 1;
    for (i = 0; i < step; i++) {
      if (k < n) {
        p = mdo(o[k], p, d);
        k += 1;
      } else return;
    }
    for (i = 0; i < step; i++) {
      if (k < n) {
        p = mle(o[k], p, d);
        k += 1;
      } else return;
    }
    step += 1;
  }
}
function socketEmitChat(msg = '') {
  if (!USE_SOCKETIO) return;
  let text = msg + getInputValue('chat');
  if (!isEmpty(text)) { socket.emit('chat', text); }
}
function socketEmitMessage(msg) {
  if (!USE_SOCKETIO) return;
  if (isDict(msg)) msg = JSON.stringify(msg);
  socket.emit('message', msg);
}
function solve(board) {
  let updated = true, solved = false
  while (updated && !solved) {
    updated = one_value_cell_constraint(board)
    solved = is_solved(board)
  }
  if (!solved) {
    board = backtrack_based(board)
    solved = is_solved(board)
  }
  return board
}
function someFunction() {
  testHelpers('hhhhhhhhhhhhhhhhhhhhhhhhhhh');
}
function someVisualExists(oid) { return firstCond(oid2ids[oid], x => x[0] == 'd' || x[0] == 'm'); }
function sort_cards(hand, bySuit = true, suits = 'CDHS', byRank = true, rankstr = '23456789TJQKA') {
  if (bySuit && byRank) {
    let buckets = arrBuckets(hand, x => x[1], suits);
    for (const b of buckets) { sort_cards(b.list, false, null, true, rankstr); }
    hand.length = 0; buckets.map(x => x.list.map(y => hand.push(y)));
  } else if (bySuit) hand.sort((a, b) => suits.indexOf(a[1]) - suits.indexOf(b[1]));
  else if (byRank) hand.sort((a, b) => rankstr.indexOf(a[0]) - rankstr.indexOf(b[0]));
  return hand;
}
function sort_cards_orig(hand, bysuit = true, byrank = true) {
  let ranked = hand.map(x => ({ x: x, r: x[0], s: x[1] }));
  let rankstr = 'A23456789TJQK';
  if (bysuit && byrank) {
    sortByFunc(ranked, x => 3 * x.s.charCodeAt(0) + 2 * rankstr.indexOf(x.r));
  } else if (bysuit) {
    sortByFunc(ranked, x => x.s.charCodeAt(0));
  } else if (byrank) {
    sortByFunc(ranked, x => rankstr.indexOf(x.r));
  }
  return ranked.map(x => x.x);
}
function sortBy(arr, key) { arr.sort((a, b) => (a[key] < b[key] ? -1 : 1)); return arr; }
function sortByDescending(arr, key) { arr.sort((a, b) => (a[key] > b[key] ? -1 : 1)); return arr; }
function sortByFunc(arr, func) { arr.sort((a, b) => (func(a) < func(b) ? -1 : 1)); return arr; }
function sortByFuncDescending(arr, func) { arr.sort((a, b) => (func(a) > func(b) ? -1 : 1)); return arr; }
function sortByRank(ckeys, rankstr = '23456789TJQKA') {
  let ranks = toLetters(rankstr);
  ckeys.sort((a, b) => ranks.indexOf(a[0]) - ranks.indexOf(b[0]));
  return ckeys;
}
function sortCardItemsByRank(items, rankstr = '23456789TJQKA') {
  let ranks = toLetters(rankstr);
  items.sort((a, b) => ranks.indexOf(a.key[0]) - ranks.indexOf(b.key[0]));
  return items;
}
function sortCardItemsBySuit(items, suitstr = 'CDSH') {
  let ranks = toLetters(suitstr);
  items.sort((a, b) => ranks.indexOf(a.key[1]) - ranks.indexOf(b.key[1]));
  return items;
}
function sortCardItemsToSequence(items, rankstr = '23456789TJQKA', jolly_allowed = 1) {
  let ranks = toLetters(rankstr);
  let n = items.length;
  let jollies = items.filter(x => is_joker(x));
  if (jollies.length > jolly_allowed) { return null; }
  let no_jolly = items.filter(x => !is_joker(x));
  let sorted = sortCardItemsByRank(no_jolly, rankstr);
  let partial_sequences = [], seq = [sorted[0]], first, second;
  for (let i = 0; i < sorted.length - 1; i++) {
    first = sorted[i];
    second = sorted[i + 1];
    diff = second.irank - first.irank;
    if (diff == 1) { seq.push(second); }
    else {
      partial_sequences.push({ seq: seq, len: seq.length, diff_to_next: diff });
      seq = [second];
    }
  }
  diff = sorted[0].irank - (sorted[sorted.length - 1].irank - rankstr.length)
  if (!isEmpty(seq)) {
    partial_sequences.push({ seq: seq, len: seq.length, diff_to_next: diff });
  } else {
    arrLast(partial_sequences).diff_to_next = diff;
  }
  let i_max_diff = partial_sequences.findIndex(x => x.diff_to_next == Math.max(...partial_sequences.map(x => x.diff_to_next)));
  let max_diff = partial_sequences[i_max_diff].diff_to_next;
  let istart = (i_max_diff + 1) % partial_sequences.length;
  let final_sequence = [];
  let jollies_needed = 0;
  let len = partial_sequences.length;
  let ij = 0;
  for (let i = 0; i < len; i++) {
    let index = (i + istart) % len;
    let list = partial_sequences[index].seq;
    final_sequence = final_sequence.concat(list);
    let nj = partial_sequences[index].diff_to_next - 1;
    if (i < len - 1) {
      for (let j = 0; j < nj; j++) { final_sequence.push(jollies[ij++]); }
      jollies_needed += nj;
    }
  }
  for (let i = 0; i < final_sequence.length; i++) { items[i] = final_sequence[i]; }
  return jollies_needed;
}
function sortCaseInsensitive(list) {
  list.sort((a, b) => { return a.toLowerCase().localeCompare(b.toLowerCase()); });
  return list;
}
function sortClassKeys(di) {
  let classes = dict2list(di.cla, 'key');
  let classesWithoutExtends = classes.filter(x => !x.code.includes(' extends '));
  let keys = sortCaseInsensitive(classesWithoutExtends.map(x => x.key));
  let dinew = {};
  for (const el of keys) { dinew[el] = di.cla[el]; }
  let classesWithExtends = classes.filter(x => x.code.includes(' extends '));
  let MAX = 150, i = 0;
  console.log('starting class loop')
  while (!isEmpty(classesWithExtends)) {
    if (++i > MAX) { console.log("WRONG!!!"); return []; }
    let o = classesWithExtends.find(x => {
      let ext = firstWordAfter(x.code, 'extends', true).trim();
      if (nundef(di.cla[ext])) return true;
      return isdef(dinew[ext]);
    });
    if (isdef(o)) { dinew[o.key] = o; removeInPlace(classesWithExtends, o); }
  }
  return Object.keys(dinew);
}
function sortConstKeys(di) {
  let tbd = dict2list(di.const, 'key');
  let donelist = [];
  tbd = sortBy(tbd, x => x.code.length);
  let dinew = {};
  let MAX = 3000, i1 = 0, i2 = 0, i3 = 0;
  console.log('starting const loop');
  console.log('const keys', tbd.length);
  while (!isEmpty(tbd)) {
    if (++i1 > MAX) { console.log("WRONG!!!"); return donelist; }
    let o = null;
    i2 = 0;
    for (const c of tbd) {
      if (++i2 > MAX) { console.log("WRONG!!!"); return donelist; }
      i3 = 0;
      let ok = true;
      for (const c1 of tbd) {
        if (++i3 > MAX) { console.log("WRONG!!!"); return donelist; }
        if (c1 == c) continue;
        if (c.code.includes(c1.key)) ok = false;
      }
      if (ok) { o = c; break; }
    }
    if (isdef(o)) { donelist.push(o); dinew[o.key] = o; removeInPlace(tbd, o); }
  }
  return donelist;
}
function sortKeys(o) {
  if (Array.isArray(o)) {
    return o.map(sortKeys);
  } else if (isObject(o)) {
    return Object
      .keys(o)
      .sort()
      .reduce(function (a, k) {
        a[k] = sortKeys(o[k]);
        return a;
      }, {});
  }
  return o;
}
function sortKeys (o) {
  if (Array.isArray(o)) {
    return o.map(sortKeys); 
  } else if (isObject(o)) {
    return Object
      .keys(o)
      .sort()
      .reduce(function (a, k) {
        a[k] = sortKeys(o[k]);
        return a;
      }, {});
  }
  return o;
}
function sortKeysNonRecursive(o) {
  if (Array.isArray(o)) {
    return o.map(sortKeysNonRecursive);
  } else if (isObject(o)) {
    return Object
      .keys(o)
      .sort()
      .reduce(function (a, k) {
        a[k] = o[k];
        return a;
      }, {});
  }
  return o;
}
function sortKeysNonRecursiveDescending(o) {
  if (Array.isArray(o)) {
    return o.map(sortKeysNonRecursiveDescending);
  } else if (isObject(o)) {
    return Object
      .keys(o)
      .reverse()
      .reduce(function (a, k) {
        a[k] = o[k];
        return a;
      }, {});
  }
  return o;
}
function sortNumbers(ilist) { ilist.sort(function (a, b) { return a - b }); return ilist; }
function Sound(src) {
  this.snd = document.createElement("audio");
  this.snd.src = src;
  this.play = function () {
    this.snd.play();
  }
}
function soundsSimilar(w1, w2, lang) {
  w1 = convertTimesAndNumbersToWords(w1);
  w2 = convertTimesAndNumbersToWords(w2);
  const syllableRegex = /[^aeiouy]*[aeiouy]+(?:[^aeiouy]*$|[^aeiouy](?=[^aeiouy]))?/gi;
  function syllabify(words) {
    return words.match(syllableRegex);
  }
  let a1 = syllabify(w1);
  let a2 = syllabify(w2);
  if (!a1) a1 = [w1];
  if (!a2) a2 = [w2];
  if (lang == 'D' && isdef(germanNumbers[a1]) && germanNumbers[a1] == germanNumbers[a2]) return true;
  if (a1.length != a2.length) return false;
  let SUPER_WEAK_SIMILARTY = false;
  if (SUPER_WEAK_SIMILARTY) {
    for (let i = 0; i < a1.length; i++) {
      let s1 = a1[i];
      let s2 = a2[i];
      if (s1 == s2) return true;
      let x1 = stringAfterLeadingConsonants(s1);
      let x2 = stringAfterLeadingConsonants(s2);
      if (lang == 'E' && 'ou'.includes(x1) && 'ou'.includes(x2) && x1.substring(1) == x2.substring(1)) return true;
      if (lang == 'E' && 'oa'.includes(x1) && 'ao'.includes(x2) && x1.substring(1) == x2.substring(1)) return true;
      if (lang == 'E' && x1.replace('ee', 'i') == x2.replace('ee', 'i')) return true;
      if (lang == 'E' && x1.replace('ea', 'ai') == x2.replace('ea', 'ai')) return true;
      if (lang == 'E' && x1.replace('au', 'o') == x2.replace('au', 'o')) return true;
    }
  } else {
    for (let i = 0; i < a1.length; i++) {
      let yesItsAMatch = false;
      let s1 = a1[i];
      let s2 = a2[i];
      if (s1 == s2) yesItsAMatch = true;
      let x1 = stringAfterLeadingConsonants(s1);
      let x2 = stringAfterLeadingConsonants(s2);
      if (x1 == x2) yesItsAMatch = true;
      if (lang == 'E' && 'ou'.includes(x1) && 'ou'.includes(x2) && x1.substring(1) == x2.substring(1)) yesItsAMatch = true;
      if (lang == 'E' && 'oa'.includes(x1) && 'ao'.includes(x2) && x1.substring(1) == x2.substring(1)) yesItsAMatch = true;
      if (lang == 'E' && x1.replace('ee', 'i') == x2.replace('ee', 'i')) yesItsAMatch = true;
      if (lang == 'E' && x1.replace('ea', 'ai') == x2.replace('ea', 'ai')) yesItsAMatch = true;
      if (lang == 'E' && x1.replace('au', 'o') == x2.replace('au', 'o')) yesItsAMatch = true;
      if (!yesItsAMatch) return false;
    }
    return true;
  }
  return false;
}
function specAndDOM(callbacks = []) {
  flags.specAndDOM = false;
  initSETTINGS();
  initPageHeader();
  initTABLES();
  initDom();
  presentSpecAndCode();
  let hasStructure = false;
  if (S.settings.userStructures) hasStructure = initSTRUCTURES();
  if (!hasStructure && S.settings.boardDetection) {
    detectBoard(G.table, 'a_d_game');
    timit.showTime('*** board end ***')
  }
  if (!hasStructure && S.settings.deckDetection) {
    detectDecks(G.table, 'a_d_game');
  }
  openTabTesting(S.settings.openTab);
  if (!isEmpty(callbacks)) callbacks[0](arrFromIndex(callbacks, 1));
}
function specialTableElem(o, keys) {
  let t = document.createElement('table');
  t.classList.add('tttable');
  let s = '';
  for (const k in o) {
    if (isdef(keys) && !keys.includes(k)) continue;
    s += '<tr><th>' + k + '</th><td>';
    let val = o[k];
    let sval = null;
    if (isListOf_Obj(val)) {
      sval = `<div class='obj' onmouseenter='highlightContentIds(this);' onmouseleave='unhighlightContentIds(this);'>${val.map(x => !x ? '_' : x._obj).toString()}</div>`;
    } else if (val && isDict(val) && '_obj' in val) {
      sval = `<button onclick='onClickListOfObj(this);'>${val._obj.toString()}</button>`;
    }
    if (!sval) sval = isSet(val) ? empty(val._set) ? '{ }' : simpleRep(val) : isDict(val) ? specialTreee2(val, 4) : simpleRep(val);
    s += sval + '</td>';
  }
  t.innerHTML = s;
  return t;
}
function specialTreee2(o) {
  let s = '<table class="tttable up10">';
  for (const k in o) {
    s += '<tr><th>' + k + '</th><td>';
    let val = o[k];
    let sval = null;
    if (isListOf_Obj(val)) sval = `<button onclick='onClickListOfObj(this);'>${val.map(x => !x ? '_' : x._obj).toString()}</button>`;
    else if (val && isDict(val) && '_obj' in val) sval = `<button onclick='onClickListOfObj(this);'>${val._obj.toString()}</button>`;
    if (!sval) sval = isSet(val) ? empty(val._set) ? '{ }' : simpleRep(val) : isDict(val) ? specialTreee2(val) : simpleRep(val);
    s += sval + '</td>';
  }
  s += '</table>';
  return s;
}
function speech00(lang) {
  if (typeof (webkitSpeechRecognition) != "function") { alert("Unable to use the Speech Recognition API"); }
  recognition = new webkitSpeechRecognition();
  recognition.continuous = true;
  recognition.interimResults = true;
  recognition.maxAlternatives = 5;
  recognition.lang = isEnglish(lang) ? 'en-US' : 'de-DE';
  addErrorHandler();
  addStartHandler();
  addEndHandler();
  addResultHandler();
}
function speechEngineGo(lang, matchingWords) {
  words = matchingWords;
  grammar = '#JSGF V1.0; grammar colors; public <color> = ' + words.join(' | ') + ' ;'
  recognition = new SpeechRecognition();
  speechRecognitionList = new SpeechGrammarList();
  speechRecognitionList.addFromString(grammar, 1);
  recognition.grammars = speechRecognitionList;
  recognition.continuous = false;
  recognition.lang = isEnglish(lang) ? 'en-US' : 'de-DE'; //'en-US';
  recognition.interimResults = false;
  recognition.maxAlternatives = 1;
  recognition.onresult = function (event) {
    let word = event.results[0][0].transcript;
    resultMessage.textContent = 'Result received: ' + word + '.';
    console.log('Confidence: ' + event.results[0][0].confidence);
    recognition.stop();
    let b = mBy('bStart');
    b.innerHTML = 'NEXT';
    show('bStart');
  }
  recognition.onspeechend = function () {
    console.log('onSpeechEnd happened!')
    recognition.stop();
  }
  recognition.onnomatch = function (event) {
    resultMessage.textContent = "I didn't recognise that word! - try again";
    recognition.stop();
  }
  recognition.onerror = function (event) {
    resultMessage.textContent = 'Error occurred in recognition: ' + event.error;
    recognition.stop();
  }
  document.body.onclick = function () {
    recognition.start();
    console.log('Ready to receive a color command.');
  }
}
function splayout(elems, dParent, w, h, x, y, overlap = 20, splay = 'right') {
  function splayRight(elems, d, x, y, overlap) {
    for (const c of elems) {
      mAppend(d, c);
      mStyle(c, { position: 'absolute', left: x, top: y });
      x += overlap;
    }
    return [x, y];
  }
  function splayLeft(elems, d, x, y, overlap) {
    x += (elems.length - 2) * overlap;
    let xLast = x;
    for (const c of elems) {
      mAppend(d, c);
      mStyle(c, { position: 'absolute', left: x, top: y });
      x -= overlap;
    }
    return [xLast, y];
  }
  function splayDown(elems, d, x, y, overlap) {
    for (const c of elems) {
      mAppend(d, c);
      mStyle(c, { position: 'absolute', left: x, top: y });
      y += overlap;
    }
    return [x, y];
  }
  function splayUp(elems, d, x, y, overlap) {
    y += (elems.length - 1) * overlap;
    let yLast = y;
    for (const c of elems) {
      mAppend(d, c);
      mStyle(c, { position: 'absolute', left: x, top: y });
      y -= overlap;
    }
    return [x, yLast];
  }
  if (isEmpty(elems)) return { w: 0, h: 0 };
  mStyle(dParent, { display: 'block', position: 'relative' });
  [x, y] = (eval('splay' + capitalize(splay)))(elems, dParent, x, y, overlap);
  let isHorizontal = splay == 'right' || splay == 'left';
  let sz = { w: (isHorizontal ? (x - overlap + w) : w), h: (isHorizontal ? h : (y - overlap + h)) };
  return sz;
}
function splitAtAnyOf(s, sep) {
  let arr = [], w = '';
  for (let i = 0; i < s.length; i++) {
    let ch = s[i];
    if (sep.includes(ch)) {
      if (!isEmpty(w)) arr.push(w);
      w = '';
    } else {
      w += ch;
    }
  }
  if (!isEmpty(w)) arr.push(w);
  return arr;
}
function splitAtWhiteSpace(s) { return s.split(/[-/ ,]+/); }
function splitIntoNumbersAndWords(s) {
  let arr = [], i = 0;
  while (i < s.length) {
    let ch = s[i];
    let w = '';
    if (isDigit(ch)) while (i < s.length && isDigit(ch)) { w += ch; i++; ch = s[i]; }
    else if (isLetter(ch)) while (i < s.length && isLetter(ch)) { w += ch; i++; ch = s[i]; }
    else { i++; continue; }
    arr.push(w);
  }
  return arr;
}
function spotit() {
  function setup(players, options) {
    let fen = { players: {}, plorder: jsCopy(players), turn: [players[0]], stage: 'init', phase: '' };
    for (const plname of players) {
      fen.players[plname] = {
        score: 0, name: plname, color: get_user_color(plname),
      };
    }
    fen.items = spotit_item_fen(options);
    if (nundef(options.mode)) options.mode = 'multi';
    return fen;
  }
  function check_gameover() {
    for (const uname of Z.plorder) {
      let cond = get_player_score(uname) >= Z.options.winning_score;
      if (cond) { Z.fen.winners = [uname]; return Z.fen.winners; }
    }
    return false;
  }
  function state_info(dParent) { spotit_state(dParent); }
  function present(dParent) { spotit_present(dParent); }
  function stats(dParent) { spotit_stats(dParent); }
  function activate_ui() { spotit_activate(); }
  return { setup, activate_ui, check_gameover, present, state_info, stats };
}
function spotit_activate() {
  let [stage, uplayer, host, plorder, fen] = [Z.stage, Z.uplayer, Z.host, Z.plorder, Z.fen];
  if (stage == 'move' && uplayer == host && get_player_score(host) >= 1) {
    let bots = plorder.filter(x => fen.players[x].playmode == 'bot');
    if (isEmpty(bots)) return;
    let bot = rChoose(bots);
    TO.main = setTimeout(() => spotit_move(bot, true), rNumber(2000, 9000));
  }
}
function spotit_card(info, dParent, cardStyles, onClickSym) {
  Card.sz = 300;
  copyKeys({ w: Card.sz, h: Card.sz }, cardStyles);
  let card = cRound(dParent, cardStyles, info.id);
  addKeys(info, card);
  card.faceUp = true;
  let zipped = [];
  for (let i = 0; i < card.keys.length; i++) {
    zipped.push({ key: card.keys[i], scale: card.scales[i] });
  }
  card.pattern = fillColarr(card.colarr, zipped);
  let symStyles = { sz: Card.sz / (card.rows + 1), fg: 'random', hmargin: 10, vmargin: 6, cursor: 'pointer' };
  let syms = [];
  mRowsX(iDiv(card), card.pattern, symStyles, { 'justify-content': 'center' }, { 'justify-content': 'center' }, syms);
  for (let i = 0; i < info.keys.length; i++) {
    let key = card.keys[i];
    let sym = syms[i];
    card.live[key] = sym;
    sym.setAttribute('key', key);
    sym.onclick = ev => onClickSym(ev, key);
  }
  return card;
}
function spotit_check_endcondition() {
  let players = get_values(Session.cur_players);
  let winners = players.filter(x => x.score >= 2).map(x => x.name);
  return winners;
}
function spotit_check_gameover(z) {
  for (const uname of z.plorder) {
    let cond = get_player_score(uname) >= z.options.winning_score;
    if (cond) { z.fen.winners = [uname]; return z.fen.winners; }
  }
  return false;
}
function spotit_clear_score() {
  assertion(isdef(Z.notes), 'Z.notes not defined');
  Z.notes = {};
}
function spotit_create_sample(numCards, numSyms, vocab, lang, min_scale, max_scale) {
  lang = valf(lang, 'E');
  let [rows, cols, colarr] = calc_syms(numSyms);
  let perCard = arrSum(colarr);
  let nShared = (numCards * (numCards - 1)) / 2;
  let nUnique = perCard - numCards + 1;
  let numKeysNeeded = nShared + numCards * nUnique;
  let nMin = numKeysNeeded + 3;
  let keypool = setKeys({ nMin: nMin, lang: valf(lang, 'E'), key: valf(vocab, 'animals'), keySets: KeySets, filterFunc: (_, x) => !x.includes(' ') });
  let keys = choose(keypool, numKeysNeeded);
  let dupls = keys.slice(0, nShared);
  let uniqs = keys.slice(nShared);
  let infos = [];
  for (let i = 0; i < numCards; i++) {
    let keylist = uniqs.slice(i * nUnique, (i + 1) * nUnique);
    let info = { id: getUID(), shares: {}, keys: keylist, rows: rows, cols: cols, colarr: colarr, num_syms: perCard };
    infos.push(info);
  }
  let iShared = 0;
  for (let i = 0; i < numCards; i++) {
    for (let j = i + 1; j < numCards; j++) {
      let c1 = infos[i];
      let c2 = infos[j];
      let dupl = dupls[iShared++];
      c1.keys.push(dupl);
      c1.shares[c2.id] = dupl;
      c2.shares[c1.id] = dupl;
      c2.keys.push(dupl);
    }
  }
  for (const info of infos) { shuffle(info.keys); }
  for (const info of infos) {
    info.scales = info.keys.map(x => chooseRandom([.5, .75, 1, 1.2]));
  }
  for (const info of infos) {
    let zipped = [];
    for (let i = 0; i < info.keys.length; i++) {
      zipped.push({ key: info.keys[i], scale: info.scales[i] });
    }
    info.pattern = fillColarr(info.colarr, zipped);
  }
  return infos;
}
function spotit_deal(numCards, rows, cols, vocab, lang, min_scale, max_scale, fen) {
  lang = valf(lang, 'E');
  let colarr = _calc_hex_col_array(rows, cols);
  if (rows == 3 && cols == 1) { colarr = [1, 3, 1]; }
  else if (rows == 2 && cols == 1) { colarr = [1, 2]; }
  else if (rows == 4 && cols == 1) { rows = 3; colarr = [2, 3, 1]; }
  else if (rows == 5 && cols == 1) { rows = 4; cols = 1; colarr = [1, 3, 3, 1]; }
  else if (rows == 5 && cols == 3) { rows = 5; cols = 1; colarr = [1, 3, 4, 3, 1]; }
  else if (rows == 6 && cols == 2) { rows = 5.5; colarr = [2, 4, 5, 4, 2]; }
  let perCard = arrSum(colarr);
  let nShared = (numCards * (numCards - 1)) / 2;
  let nUnique = perCard - numCards + 1;
  let numKeysNeeded = nShared + numCards * nUnique;
  let nMin = numKeysNeeded + 3;
  let keypool = setKeys({ nMin: nMin, lang: valf(lang, 'E'), key: valf(vocab, 'animals'), keySets: KeySets, filterFunc: (_, x) => !x.includes(' ') });
  let keys = choose(keypool, numKeysNeeded);
  let dupls = keys.slice(0, nShared);
  let uniqs = keys.slice(nShared);
  let infos = [];
  for (let i = 0; i < numCards; i++) {
    let keylist = uniqs.slice(i * nUnique, (i + 1) * nUnique);
    let info = { id: getUID(), shares: {}, keys: keylist, rows: rows, cols: cols, colarr: colarr, num_syms: perCard };
    infos.push(info);
  }
  let iShared = 0;
  for (let i = 0; i < numCards; i++) {
    for (let j = i + 1; j < numCards; j++) {
      let c1 = infos[i];
      let c2 = infos[j];
      let dupl = dupls[iShared++];
      c1.keys.push(dupl);
      c1.shares[c2.id] = dupl;
      c2.shares[c1.id] = dupl;
      c2.keys.push(dupl);
    }
  }
  for (const info of infos) { shuffle(info.keys); }
  for (const info of infos) {
    info.scales = info.keys.map(x => randomNumber(min_scale * 100, max_scale * 100) / 100);
  }
  if (isdef(fen)) {
    let ks_for_cards = fen.split(',');
    for (let i = 0; i < infos.length; i++) {
      let info = infos[i];
      let ks_list = ks_for_cards[i].split(' ');
      info.keys = ks_list.map(x => stringBefore(x, ':'));
      info.scales = ks_list.map(x => stringAfter(x, ':')).map(x => Number(x));
    }
  }
  let items = [];
  for (const info of infos) {
    let item = spotit_card(info, dTable, { margin: 20 }, spotit_interact);
    items.push(item);
  }
  return items;
}
function spotit_evaluate() {
  if (!canAct()) return;
  uiActivated = false; clearTimeouts();
  IsAnswerCorrect = Selected.isCorrect;
  update_my_score(IsAnswerCorrect ? 1 : 0);
  let me = Session.cur_me;
  if (me.score >= Session.winning_score) me.player_status = 'done';
  let delay = show_feedback(IsAnswerCorrect);
  setTimeout(() => {
    in_game_open_prompt_off();
    clear_table_events();
    send_move();
  }, delay);
}
function spotit_fail() { spotit_move(G, U.name, false); }
function spotit_fen() {
  let me = Session.cur_players[Session.cur_user];
  let items = Session.items;
  let fen = items.map(x => x.keys.join(' ')).join(',');
  let item_fens = [];
  for (const item of items) {
    let arr = arrFlatten(item.pattern);
    let ifen = arr.map(x => `${x.key}:${x.scale}`).join(' ');
    item_fens.push(ifen);
  }
  fen = item_fens.join(',');
  me.state = fen;
}
function spotit_find_shared(card, keyClicked) {
  let success = false, othercard = null;
  for (const c of Z.cards) {
    if (c == card) continue;
    if (c.keys.includes(keyClicked)) { success = true; othercard = c; }
  }
  return [success, othercard];
}
function spotit_get_shared_symbols() {
  let result = [];
  for (const item of Session.items) {
    for (const id in item.shares) {
      let k = item.shares[id];
      let ui = iGetl(item, k);
      result.push(ui);
    }
  }
  return result;
}
function spotit_interact(ev, key) {
  ev.cancelBubble = true;
  if (!uiActivated) { console.log('ui NOT activated'); return; }
  let keyClicked = evToProp(ev, 'key');
  let id = evToId(ev);
  if (isdef(keyClicked) && isdef(Items[id])) {
    let item = Items[id];
    let dsym = ev.target;
    let card = Items[id];
    let [success, othercard] = spotit_find_shared(card, keyClicked);
    spotit_move(Z.uplayer, success);
  }
}
function spotit_item_fen(options) {
  let o = {
    num_cards: valf(options.num_cards, 2),
    num_symbols: options.adaptive == 'yes' ? 14 : valf(options.num_symbols, 7),
    vocab: valf(options.vocab, 'lifePlus'),
    lang: 'E',
    min_scale: valf(options.min_scale, 0.75),
    max_scale: valf(options.max_scale, 1.25),
  };
  let items = spotit_create_sample(o.num_cards, o.num_symbols, o.vocab, o.lang, o.min_scale, o.max_scale);
  let item_fens = [];
  for (const item of items) {
    let arr = arrFlatten(item.pattern);
    let ifen = arr.map(x => `${x.key}:${x.scale}`).join(' ');
    item_fens.push(ifen);
  }
  let res = item_fens.join(',');
  return res;
}
function spotit_move(uplayer, success) {
  if (success) {
    inc_player_score(uplayer);
    assertion(get_player_score(uplayer) >= 1, 'player score should be >= 1');
    Z.fen.items = spotit_item_fen(Z.options);
    Z.state = { score: get_player_score(uplayer) };
    take_turn_spotit();
  } else {
    let d = mShield(dTable, { bg: '#000000aa', fg: 'red', fz: 60, align: 'center' });
    d.innerHTML = 'NOPE!!! try again!';
    TO.spotit_penalty = setTimeout(() => d.remove(), 2000);
  }
}
function spotit_parse_fen() {
}
function spotit_populate_settings(dParent) {
  Session.game_options.game = {};
  let poss = DB.games[Session.cur_game].options;
  if (nundef(poss)) return;
  for (const p in poss) {
    let key = p;
    let val = poss[p];
    if (isString(val)) {
      let list = val.split(',');
      let fs = mRadioGroup(dParent, {}, `d_${key}`, key);
      let checkfirst = true;
      for (const v of list) {
        let d = mRadio(v, isNumber(v) ? Number(v) : v, fs, { cursor: 'pointer' }, null, key);
        if (checkfirst) {
          let inp = d.firstChild;
          inp.setAttribute('checked', true);
          checkfirst = false;
        }
      }
      measure_fieldset(fs);
    } else if (val === true || val === false) {
      console.log('should make a checkbox for', key);
    }
  }
}
function spotit_present(dParent) {
  let [fen, ui, stage, uplayer] = [Z.fen, UI, Z.stage, Z.uplayer];
  let [dOben, dOpenTable, dMiddle, dRechts] = tableLayoutMR(dParent, 1, 0);
  spotit_read_all_scores();
  let dt = dOpenTable; clearElement(dt); mCenterFlex(dt);
  spotit_stats(dt);
  mLinebreak(dt, 10);
  let ks_for_cards = fen.items.split(',');
  let numCards = ks_for_cards.length;
  let items = Z.items = [];
  Items = [];
  let i = 0;
  for (const s of ks_for_cards) {
    let ks_list = s.split(' ');
    let item = {};
    item.keys = ks_list.map(x => stringBefore(x, ':'));
    item.scales = ks_list.map(x => stringAfter(x, ':')).map(x => Number(x));
    item.index = i; i++;
    let n = item.numSyms = item.keys.length;
    let [rows, cols, colarr] = calc_syms(item.numSyms);
    item.colarr = colarr;
    item.rows = rows;
    items.push(item);
  }
  Z.cards = [];
  let is_adaptive = Z.options.adaptive == 'yes';
  let nsyms = is_adaptive ? cal_num_syms_adaptive() : Z.options.num_symbols;
  for (const item of items) {
    if (is_adaptive) { modify_item_for_adaptive(item, items, nsyms); }
    let card = spotit_card(item, dt, { margin: 20, padding: 10 }, spotit_interact);
    Z.cards.push(card);
    if (Z.stage == 'init') {
      face_down(card, GREEN, 'food');
    }
  }
  mLinebreak(dt, 10);
}
function spotit_read_all_scores() {
  if (nundef(Z.playerdata)) {
    Z.playerdata = [];
    for (const pl in Z.fen.players) {
      Z.playerdata.push({
        name: pl,
        state: { score: 0 },
      });
    }
  }
  for (const pldata of Z.playerdata) {
    let plname = pldata.name;
    let state = pldata.state;
    let score = !isEmpty(state) ? state.score : 0;
    let fenscore = lookupSet(Z.fen, ['players', plname, 'score'], score);
    Z.fen.players[plname].score = Math.max(fenscore, score);
  }
}
function spotit_setup(players) {
  Card.sz = 200;
  let fen = { cards: ['ASr', 'QHb'], players: {}, step: 0, plorder: jsCopy(players), turn: jsCopy(players) };
  let expected = {};
  for (const uname of players) {
    fen.players[uname] = { score: 0 };
    expected[uname] = { step: 0, type: 'move' }
  }
  return { fen: fen, expected: expected };
}
function spotit_start() { startgame('spotit', ['amanda', 'felix']); }
function spotit_state(dParent) {
  let user_html = get_user_pic_html(Z.uplayer, 30);
  let msg = Z.stage == 'init' ? `getting ready...` : `player: ${user_html}`;
  dParent.innerHTML = `Round ${Z.round}:&nbsp;${msg} `;
}
function spotit_stats(d) {
  let players = Z.fen.players;
  let d1 = mDiv(d, { display: 'flex', 'justify-content': 'center', 'align-items': 'space-evenly' });
  for (const plname of get_present_order()) {
    let pl = players[plname];
    let onturn = Z.turn.includes(plname);
    let sz = 50;
    let bcolor = plname == Z.uplayer ? 'lime' : 'silver';
    let border = pl.playmode == 'bot' ? `double 5px ${bcolor}` : `solid 5px ${bcolor}`;
    let rounding = pl.playmode == 'bot' ? '0px' : '50%';
    let d2 = mDiv(d1, { margin: 4, align: 'center' }, null, `<img src='../base/assets/images/${plname}.jpg' style="border-radius:${rounding};display:block;border:${border};box-sizing:border-box" class='img_person' width=${sz} height=${sz}>${get_player_score(plname)}`);
  }
}
function spotit_success() { spotit_move(G, U.name, true); }
function spotit_test1(g, dParent, uname) {
  console.log('from server:', g, dParent, uname);
  spotit_present(g, dParent, uname)
}
function spotitCard(info, dParent, cardStyles, onClickSym) {
  let styles = copyKeys({ w: Card.sz, h: Card.sz }, cardStyles);
  let card = cRound(dParent, cardStyles, info.id);
  addKeys(info, card);
  let d = iDiv(card);
  card.pattern = fillColarr(card.colarr, card.keys);
  let symStyles = { sz: Card.sz / (card.rows + 1), fg: 'random', hmargin: 8, vmargin: 4, cursor: 'pointer' };
  let syms = [];
  mRows(iDiv(card), card.pattern, symStyles, { 'justify-content': 'center' }, { 'justify-content': 'center' }, syms);
  for (let i = 0; i < info.keys.length; i++) {
    let key = card.keys[i];
    let sym = syms[i];
    card.live[key] = sym;
    sym.setAttribute('key', key);
    sym.onclick = onClickSym;
  }
  return card;
}
function spotitDeal(rows, cols, numCards, setName) {
  let colarr = _calc_hex_col_array(rows, cols);
  let perCard = arrSum(colarr);
  let nShared = (numCards * (numCards - 1)) / 2;
  let nUnique = perCard - numCards + 1;
  let keys = choose(oneWordKeys(KeySets[setName]), nShared + numCards * nUnique);
  let dupls = keys.slice(0, nShared);
  let uniqs = keys.slice(nShared);
  let infos = [];
  for (let i = 0; i < numCards; i++) {
    let keylist = uniqs.slice(i * nUnique, i * nUnique + nUnique);
    let info = { id: getUID(), shares: {}, keys: keylist, rows: rows, cols: cols, colarr: colarr };
    infos.push(info);
  }
  let iShared = 0;
  for (let i = 0; i < numCards; i++) {
    for (let j = i + 1; j < numCards; j++) {
      let c1 = infos[i];
      let c2 = infos[j];
      let dupl = dupls[iShared++];
      c1.keys.push(dupl);
      c1.shares[c2.id] = dupl;
      c2.shares[c1.id] = dupl;
      c2.keys.push(dupl);
    }
  }
  for (const info of infos) { shuffle(info.keys); }
  return infos;
}
function spotitFindCardSharingSymbol(card, key) {
  let id = firstCondDict(card.shares, x => x == key);
  return Items[id];
}
function spotitFindSymbol(card, key) { let k = firstCondDictKey(card.live, x => x == key); return card.live[k]; }
function spotitOnClickSymbol(ev) {
  let keyClicked = evToProp(ev, 'key');
  let id = evToId(ev);
  if (isdef(keyClicked) && isdef(Items[id])) {
    let item = Items[id];
    console.log('clicked key', keyClicked, 'of card', id, item);
    if (Object.values(item.shares).includes(keyClicked)) {
      console.log('success!!!');
      let otherCard = spotitFindCardSharingSymbol(item, keyClicked);
      let cardSymbol = ev.target;
      let otherSymbol = spotitFindSymbol(otherCard, keyClicked);
      Selected = { success: true, feedbackUI: [cardSymbol, otherSymbol] };
    } else {
      console.log('fail!!!!!!!!');
      let cardSymbol = ev.target;
      Selected = { success: false, feedbackUI: [cardSymbol] };
    }
  }
}
function spread_hand(path, ov) {
  let hand = lookup(UI, path.split('.'));
  assertion(hand, 'hand does NOT exist', path);
  if (hand.ctype != 'hand') return;
  if (isEmpty(hand.items)) return;
  let card = hand.items[0];
  if (nundef(ov)) ov = card.ov;
  if (hand.ov == ov) return;
  hand.ov = ov;
  let cont = hand.cardcontainer;
  let items = hand.items;
  mContainerSplay(cont, hand.splay, card.w, card.h, items.length, ov * card.w);
}
function Sprite(scene, imageFile, width, height) {
  this.canvas = scene.canvas;
  this.context = this.canvas.getContext("2d");
  this.image = new Image();
  this.image.src = imageFile;
  this.animation = false;
  this.width = width;
  this.height = height;
  this.cHeight = parseInt(this.canvas.height);
  this.cWidth = parseInt(this.canvas.width);
  this.x = 200;
  this.y = 200;
  this.dx = 10;
  this.dy = 0;
  this.imgAngle = 0;
  this.moveAngle = 0;
  this.speed = 10;
  this.camera = false;
  this.setPosition = function (x, y) {
    this.x = x;
    this.y = y;
  }
  this.setX = function (nx) { this.x = nx; }
  this.setY = function (ny) { this.y = ny; }
  this.setChangeX = function (ndx) { this.dx = ndx; }
  this.setChangeY = function (ndy) { this.dx = ndx; }
  this.changeXby = function (tdx) { this.x += tdx };
  this.changeYby = function (tdy) { this.y += tdy };
  this.draw = function () {
    ctx = this.context;
    ctx.save();
    if (this.camera) { ctx.translate(this.x - this.camera.cameraOffsetX, this.y - this.camera.cameraOffsetY); }
    else { ctx.translate(this.x, this.y); }
    ctx.rotate(this.imgAngle);
    if (this.animation != false) {
      this.animation.drawFrame(ctx);
    }
    else {
      ctx.drawImage(this.image,
        0 - (this.width / 2),
        0 - (this.height / 2),
        this.width, this.height);
    }
    ctx.restore();
  }
  this.update = function () {
    this.x += this.dx;
    this.y += this.dy;
    this.checkBounds();
    this.draw();
  }
  this.checkBounds = function () {
    camX = 0;
    camY = 0;
    if (this.camera) { camX = this.camera.cameraOffsetX; camY = this.camera.cameraOffsetY; }
    rightBorder = this.cWidth + camX;
    leftBorder = camX;
    topBorder = camY;
    bottomBorder = this.cHeight + camY;
    if (this.x > rightBorder) {
      this.x = leftBorder;
    }
    if (this.y > bottomBorder) {
      this.y = topBorder;
    }
    if (this.x < leftBorder) {
      this.x = rightBorder;
    }
    if (this.y < topBorder) {
      this.y = bottomBorder;
    }
  }
  this.loadAnimation = function (imgWidth, imgHeight, cellWidth, cellHeight) {
    this.animation = new Animation(this.image, imgWidth, imgHeight, cellWidth, cellHeight);
    this.animation.setup();
  }
  this.generateAnimationCycles = function (slicingFlag, framesArray) {
    cWidth = this.animation.cellWidth;
    cHeight = this.animation.cellHeight;
    iWidth = this.animation.imgWidth;
    iHeight = this.animation.imgHeight;
    numCycles = 0;
    nextStartingFrame = 0;
    if (typeof framesArray == "number" || typeof slicingFlag == "undefined") {
      if (slicingFlag == SINGLE_COLUMN) { numCycles = (iHeight / cHeight) / framesArray; }
      else if (typeof slicingFlag == "undefined") { numCycles = (iHeight / cHeight); framesArray = iWidth / cWidth; }
      else { numCycles = (iWidth / cWidth) / framesArray; }
      for (i = 0; i < numCycles; i++) {
        cycleName = "cycle" + (i + 1);
        this.specifyCycle(cycleName, i * framesArray, framesArray);
      }
    }
    else {
      numCycles = framesArray.length;
      for (i = 0; i < numCycles; i++) {
        cycleName = "cycle" + (i + 1);
        this.specifyCycle(cycleName, nextStartingFrame, framesArray[i]);
        nextStartingFrame += framesArray[i];
      }
    }
    this.setCurrentCycle("cycle1");
  }
  this.renameCycles = function (cycleNames) { this.animation.renameCycles(cycleNames); }
  this.specifyCycle = function (cycleName, startingCell, frames) { this.animation.addCycle(cycleName, startingCell, frames); }
  this.specifyState = function (stateName, cellName) { this.animation.addCycle(stateName, cellName, 1); }
  this.setCurrentCycle = function (cycleName) { this.animation.setCycle(cycleName); }
  this.pauseAnimation = function () { this.animation.pause(); }
  this.playAnimation = function () { this.animation.play(); }
  this.resetAnimation = function () { this.animation.reset(); }
  this.setAnimationSpeed = function (speed) { this.animation.setAnimationSpeed(speed); }
  this.calcVector = function () {
    this.dx = this.speed * Math.cos(this.moveAngle);
    this.dy = this.speed * Math.sin(this.moveAngle);
  }
  this.setSpeed = function (speed) {
    this.speed = speed;
    this.calcVector();
  }
  this.changeSpeedBy = function (diff) {
    this.speed += diff;
    this.calcVector();
  }
  this.setImgAngle = function (degrees) {
    degrees = degrees - 90;
    this.imgAngle = degrees * Math.PI / 180;
  }
  this.changeImgAngleBy = function (degrees) {
    rad = degrees * Math.PI / 180;
    this.imgAngle += rad;
  }
  this.setMoveAngle = function (degrees) {
    degrees = degrees - 90
    this.moveAngle = degrees * Math.PI / 180;
    this.calcVector();
  }
  this.changeMoveAngleBy = function (degrees) {
    diffRad = degrees * Math.PI / 180;
    this.moveAngle += diffRad;
    this.calcVector();
  }
  this.setAngle = function (degrees) {
    this.setMoveAngle(degrees);
    this.setImgAngle(degrees);
  }
  this.changeAngleBy = function (degrees) {
    this.changeMoveAngleBy(degrees);
    this.changeImgAngleBy(degrees);
  }
  this.collidesWith = function (sprite) {
    myLeft = this.x;
    myRight = this.x + this.width;
    myTop = this.y;
    myBottom = this.y + this.height;
    otherLeft = sprite.x;
    otherRight = sprite.x + sprite.width;
    otherTop = sprite.y;
    otherBottom = sprite.y + sprite.height;
    collision = true;
    if ((myBottom < otherTop) ||
      (myTop > otherBottom) ||
      (myRight < otherLeft) ||
      (myLeft > otherRight)) {
      collision = false;
    }
    return collision;
  }
  this.setCameraRelative = function (cam) { this.camera = cam; }
  this.report = function () {
    console.log("x: " + this.x + ", y: " + this.y + ", dx: "
      + this.dx + ", dy: " + this.dy
      + ", speed: " + this.speed
      + ", angle: " + this.moveAngle);
  }
}
function SQ120(sq64) { return Sq64ToSq120[(sq64)]; }
function SQ64(sq120) { return Sq120ToSq64[(sq120)]; }
function SqAttacked(sq, side) {
  var pce;
  var t_sq;
  var index;
  if (side == COLOURS.WHITE) {
    if (brd_pieces[sq - 11] == PIECES.wP || brd_pieces[sq - 9] == PIECES.wP) {
      return BOOL.TRUE;
    }
  } else {
    if (brd_pieces[sq + 11] == PIECES.bP || brd_pieces[sq + 9] == PIECES.bP) {
      return BOOL.TRUE;
    }
  }
  for (index = 0; index < 8; ++index) {
    pce = brd_pieces[sq + KnDir[index]];
    if (pce != SQUARES.OFFBOARD && PieceKnight[pce] == BOOL.TRUE && PieceCol[pce] == side) {
      return BOOL.TRUE;
    }
  }
  for (index = 0; index < 4; ++index) {
    dir = RkDir[index];
    t_sq = sq + dir;
    pce = brd_pieces[t_sq];
    while (pce != SQUARES.OFFBOARD) {
      if (pce != PIECES.EMPTY) {
        if (PieceRookQueen[pce] == BOOL.TRUE && PieceCol[pce] == side) {
          return BOOL.TRUE;
        }
        break;
      }
      t_sq += dir;
      pce = brd_pieces[t_sq];
    }
  }
  for (index = 0; index < 4; ++index) {
    dir = BiDir[index];
    t_sq = sq + dir;
    pce = brd_pieces[t_sq];
    while (pce != SQUARES.OFFBOARD) {
      if (pce != PIECES.EMPTY) {
        if (PieceBishopQueen[pce] == BOOL.TRUE && PieceCol[pce] == side) {
          return BOOL.TRUE;
        }
        break;
      }
      t_sq += dir;
      pce = brd_pieces[t_sq];
    }
  }
  for (index = 0; index < 8; ++index) {
    pce = brd_pieces[sq + KiDir[index]];
    if (pce != SQUARES.OFFBOARD && PieceKing[pce] == BOOL.TRUE && PieceCol[pce] == side) {
      return BOOL.TRUE;
    }
  }
  return BOOL.FALSE;
}
function SqFromAlg(moveAlg) {
  if (moveAlg.length != 2) return SQUARES.NO_SQ;
  if (moveAlg[0] > 'h' || moveAlg[0] < 'a') return SQUARES.NO_SQ;
  if (moveAlg[1] > '8' || moveAlg[1] < '1') return SQUARES.NO_SQ;
  file = moveAlg[0].charCodeAt() - 'a'.charCodeAt();
  rank = moveAlg[1].charCodeAt() - '1'.charCodeAt();
  return FR2SQ(file, rank);
}
function SQOFFBOARD(sq) { if (FilesBrd[sq] == SQUARES.OFFBOARD) return BOOL.TRUE; return BOOL.FALSE; }
function sss() { show_playerdatastate(); }
function sss1() {
  let [fen, A, uplayer, plorder, data] = [Z.fen, Z.A, Z.uplayer, Z.plorder, Z.uplayer_data];
  let s = 'no data.state for player ' + uplayer;
  if (isDict(data.state)) {
    s = `${uplayer} passes `;
    for (const k in data.state.di) {
      s += `${k} ${data.state.di[k]}, `;
    }
  }
  console.log(s);
}
function stabilizeBodyZoom() {
  if (Math.abs(bodyZoom - 1) < .2) bodyZoom = 1;
}
function stadtland_accept(fen, plname) {
  let message = `${plname} has accepted`;
  arrRemovip(fen.turn, plname);
  fen.players[plname].hasAccepted = true;
  if (isEmpty(fen.turn)) { stadtland_newround(fen, true); }
  sendmove(plname, fen);
}
function stadtland_answer(fen, plname) {
  let move = stadtland_createmove(fen, plname);
  let islegal = stadtland_evalmove(fen, plname, move);
  if (islegal) {
    fen.move = move;
    let message = `${move.uname} has answered first: `;
    for (const k in move.data) {
      message += `<div>${k}: ${move.data[k]}</div>`;
      fen.players[plname].answer[k] = move.data[k];
    }
    fen.first = plname;
    fen.content = message;
    fen.phase = 'accept';
    arrRemovip(fen.turn, plname);
    sendmove(plname, fen, true);
  } else {
    show_instruction('your move is not complete!')
  }
}
function stadtland_createmove(fen, plname) {
  let inputs = dParent.getElementsByTagName('input');
  let move = { uname: U.name, table: G.name, data: {} };
  for (const inp of inputs) {
    if (fen.cats.includes(inp.name)) {
      move.data[inp.name] = inp.value;
    }
  }
  return move;
}
function stadtland_evalmove(fen, plname, move) {
  for (const cat of fen.cats) {
    if (isEmpty(move.data[cat])) move.data[cat] = 'hallo';
  }
  return true;
}
function stadtland_newround(fen, score) {
  fen.phase = "create";
  fen.turn = jsCopy(fen.plorder);
  fen.round = [];
  fen.letter = rLetter(fen.letters);
  lookupAddToList(fen, ['letters'], fen.letter);
  fen.instruction = 'complete each category, then click DONE!';
  if (score && isdef(fen.first)) fen.players[fen.first].score += 1;
  for (const uname of fen.plorder) {
    for (const cat of fen.cats) fen.players[uname].answer[cat] = '';
  }
  delete fen.first;
  delete fen.move;
  delete fen.message;
}
function stadtland_present(fen, dParent, plname) {
  if (fen.phase == 'create') {
    let d1 = mDiv(dParent, { w: 400, align: 'left' }, null, `<h1>letter: ${fen.letter.toUpperCase()}</h1>`);
    for (const cat of fen.cats) {
      mLinebreak(d1, 10);
      let html = `
      <div style="display:inline-block;width:150px">${cat.toUpperCase()}:</div>
      <input class:'input' style="width:150px" type='text' name="${cat}">
      `;
      let d2 = mDiv(d1, {}, null, html);
    }
    let d2 = mDiv(d1, { w: '100%', padding: 20 });
    mButton('SUBMIT', () => interaction(fen, plname, stadtland_answer), d2, {}, 'button', 'bSendMove');
  } else if (fen.phase == 'accept') {
    let d1 = mDiv(dParent, { w: 400, align: 'left' }, null, `<h1>${fen.content}</h1>`);
    let d2 = mDiv(d1, { w: '100%', padding: 20 });
    if (!fen.turn.includes(plname)) return;
    mButton('ACCEPT', () => interaction(fen, plname, stadtland_accept), d2, { hmargin: 20 }, 'button');
    mButton('REJECT', () => interaction(fen, plname, stadtland_reject), d2, {}, 'button');
  }
}
function stadtland_reject(fen, plname) {
  let winner = fen.first;
  stadtland_newround(fen, false);
  fen.status = `last solution from ${winner} was rejected by ${plname}`;
  sendmove(fen, plname);
}
function stadtland_setup(players) {
  let fen = {};
  fen.cats = rChoose(['stadt', 'land', 'tier', 'name', 'plant', 'sport', 'object', 'brand', 'dessert', 'vegetable', 'fruit', 'profession', 'hobby', 'noun', 'emotion', 'landmark'], 4);
  fen.players = {};
  fen.plorder = rPlayerOrder(players);
  fen.letters = ['q', 'x', 'y'];
  for (const uname of players) {
    let pl = fen.players[uname] = { answer: {}, score: 0 };
  }
  stadtland_newround(fen, false);
  return fen;
}
function stage_building(fen, i_pl, type) {
  let n = type == 'chateau' ? 6 : type == 'estate' ? 5 : 4;
  type += 's';
  let uname = fen.plorder[i_pl];
  fen.players[uname].buildings[type].push({ list: deck_deal(fen.deck, n), h: null });
}
function stage_building_new(fen, i_pl, type, n_openschwein, n_closedschwein) {
  let n = type == 'chateau' ? 6 : type == 'estate' ? 5 : 4;
  let plname = fen.plorder[i_pl];
  lookupSet(fen.players[plname], ['buildings', type], []);
  let building = { list: deck_deal(fen.deck, 1), h: null, type: type, schweine: [] };
  let k = building.lead = building.list[0];
  let other = k[0] == 'Q' ? '2' : 'Q';
  let i, j;
  for (i = 1; i <= n_openschwein; i++) { building.schweine.push(i); building.list.push(other + rSuit('CSHD') + 'n'); }
  for (j = 1; j <= n_closedschwein; j++) { building.list.push(other + rSuit('CSHD') + 'n'); }
  while (building.list.length < n) { building.list.push(k); j++; }
  fen.players[plname].buildings[type].push(building);
  return building;
}
function stage_correct_buildings(fen, o) {
  let ranks = toLetters(RANKS);
  let irank = 0;
  for (const uname in o) {
    let pl = fen.players[uname];
    let bo = pl.buildings;
    let dinums = o[uname];
    for (const type in dinums) {
      let n = dinums[type];
      for (let i = 0; i < n; i++) {
        let r = ranks[irank]; irank++;
        let s = type == 'farms' ? `${r}Cy ${r}Sy ${r}Sy ${r}Dy` :
          type == 'estates' ? `${r}Cy ${r}Sy ${r}Sy ${r}Dy ${r}Cg` : `${r}Cy ${r}Sy ${r}Sy ${r}Dy ${r}Cg ${r}Hg`;
        bo[type].push({ list: s.split(' '), h: null });
      }
    }
  }
}
function stage_moves() {
  for (const a of arguments) {
    let [uname, x, cardname] = a.split('.');
    DA.chain.push(() => {
      let g = Session;
      let state = { selected: {} };
      state.selected[uname] = [a];
      let o = { uname: uname, tid: g.table.id, state: state, player_status: 'joined' };
      to_server(o, 'turn_update');
    })
  }
}
function stage1_makeUis(omap, objectPool, w, h, gap, domelFunc) {
  let olist = mapOMap(omap, objectPool);
  if (isEmpty(olist)) return null;
  let otrans = olist;
  let uis = getUis(otrans, domelFunc(w, h));
  return uis;
}
function stage2_prepArea(area) { let d = mBy(area); mClass(d, 'flexWrap'); return d; }
function stage3_prepContainer(area) { let container = mDiv(area); mPosRel(container); return container; }
function stage4_layout(uis, container, w, h, gap, layoutFunc) {
  let [wTotal, hTotal] = layoutFunc(uis, container, w, h, gap);
  mStyle(container, { width: wTotal, height: hTotal, 'border-radius': gap });
}
function standardize_color(str) {
  var c = document.createElement('canvas').getContext('2d');
  c.fillStyle = str;
  return c.fillStyle;
}
function start() { let uname = DA.secretuser = localStorage.getItem('uname'); if (isdef(uname)) U = { name: uname }; phpPost({ app: 'simple' }, 'assets'); }
function start_advanced() {
  dTable = mBy('dTable'); dTitle = mBy('dTitle');
  show('dTopAdvanced');
  show_tables();
  show_games();
  show_title();
  show_home_logo();
  dTitle.animate([{ opacity: 0 }, { opacity: 1 },], { fill: 'both', duration: 1000, easing: 'ease-in' });
  dTable = mBy('dTable');
  show_users();
  if (!isEmpty(Serverdata.tables)) onclick_game_in_gametable(Serverdata.tables[0].friendly);
}
function start_bots(obj) {
  if (is_admin() && DA.is_first_move == true) {
    DA.bots = [];
    let bots = { bob: 5000 };
    for (const botname in bots) {
      if (obj.table.players.includes(botname)) { start_poll_bot_send_move(botname, bots[botname]); }
    }
  }
  DA.is_first_move = false;
}
function start_challenge1() {
  DA.challenge = 1;
  DA.name = 'Login';
  scrollToTop();
  onclick_location('boa');
}
function start_challenge2() {
  DA.challenge = 2;
  DA.name = 'Bill Pay';
  scrollToTop();
  boamain_start();
  show_bill_button();
}
function start_challenge3() {
  DA.challenge = 3;
  DA.name = 'Full Bill Pay';
  scrollToTop();
  onclick_location('boa');
}
function start_challenge4() {
  DA.challenge = 4;
  DA.name = 'Password';
  scrollToTop();
  if (S.bw_state == 'loggedin') toggle_bw_symbol();
  S.bw_state = (coin(25) || !S.master_password) ? 'expired' : 'loggedout';
}
function start_chat(e) {
  e.preventDefault(); e.cancelBubble = true;
  var username = e.target.getAttribute("username");
  if (e.target.id == "") {
    username = e.target.parentNode.getAttribute("username");
  }
  CURRENT_CHAT_USER = username;
  get_chats();
  mBy("radio_chat").checked = true;
}
function start_creeping_down() {
  for (const k in Z.fen) {
    set_new_goal(k, 0);
  }
}
function start_downgrade_ticker() {
  TO.main = setTimeout(degrade_bars, 5000);
}
function start_game() {
  let gamename = DA.gamename;
  let options = collect_game_specific_options(gamename);
  let players = DA.playerlist ? DA.playerlist.map(x => ({ name: x.uname, playmode: x.playmode, strategy: valf(x.strategy, options.strategy, 'random') })) : create_random_players(options.nplayers);
  _start_game(gamename, players, options); hide('dMenu');
}
async function start_leaflet() {
  TESTING = 'nosockets';
  if (TESTING != 'nosockets') {
    Socket = TESTING == 'live' ? io('http://127.0.0.1:3000') : TESTING == 'nginx' ? io('http://216.250.112.218:3000') : io();
    Socket.on('message', x => console.log('got message', x));
    Socket.on('disconnect', x => console.log('got disconnect', x));
    Socket.on('update', x => console.log('got update', x));
  }
  var cities = L.layerGroup();
  var mLittleton = L.marker([39.61, -105.02]).bindPopup('This is Littleton, CO.').addTo(cities);
  var mDenver = L.marker([39.74, -104.99]).bindPopup('This is Denver, CO.').addTo(cities);
  var mAurora = L.marker([39.73, -104.8]).bindPopup('This is Aurora, CO.').addTo(cities);
  var mGolden = L.marker([39.77, -105.23]).bindPopup('This is Golden, CO.').addTo(cities);
  var mbAttr = 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>';
  var mbUrl = 'https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw';
  var streets = L.tileLayer(mbUrl, { id: 'mapbox/streets-v11', tileSize: 512, zoomOffset: -1, attribution: mbAttr });
  var osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
  });
  var map = L.map('map', {
    center: [39.73, -104.99],
    zoom: 10,
    layers: [osm, cities]
  });
  var baseLayers = {
    'OpenStreetMap': osm,
    'Streets': streets
  };
  var overlays = {
    'Cities': cities
  };
  var layerControl = L.control.layers(baseLayers, overlays).addTo(map);
  var crownHill = L.marker([39.75, -105.09]).bindPopup('This is Crown Hill Park.');
  var rubyHill = L.marker([39.68, -105.00]).bindPopup('This is Ruby Hill Park.');
  var parks = L.layerGroup([crownHill, rubyHill]);
  var satellite = L.tileLayer(mbUrl, { id: 'mapbox/satellite-v9', tileSize: 512, zoomOffset: -1, attribution: mbAttr });
  layerControl.addBaseLayer(satellite, 'Satellite');
  layerControl.addOverlay(parks, 'Parks');
}
function start_loop() {
  TO.running = setInterval(() => {
    for (const item of G.items) {
    }
  }, 100);
}
function start_new_round_ferro() {
  let [plorder, stage, A, fen, uplayer] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer];
  let pl = fen.players[uplayer];
  Z.stage = 'card_selection';
  fen.plorder = arrCycle(plorder, 1);
  let starter = fen.plorder[0];
  Z.turn = fen.turn = [starter];
  let deck = fen.deck = create_fen_deck('n', fen.num_decks, fen.num_decks * 4);
  let deck_discard = fen.deck_discard = [];
  shuffle(deck);
  let handsize = valf(Number(Z.options.handsize), 11);
  for (const plname of fen.plorder) {
    let pl = fen.players[plname];
    pl.hand = deck_deal(deck, plname == starter ? handsize + 1 : handsize);
    pl.journeys = [];
    pl.roundgoal = false;
    pl.roundchange = true;
    delete pl.handsorting;
  }
  Z.round += 1;
  if (Z.round > Z.options.maxrounds) {
    ari_history_list([`game over`], 'game');
    Z.stage = 'game_over';
    fen.winners = find_players_with_min_score();
  }
}
function start_new_todo_list(otree, r) {
  let i_last = otree.plorder.indexOf(r.uname);
  let i_next = (i_last + 1) % otree.plorder.length;
  otree.todo = inno_todo_regular(otree, otree.plorder[i_next]);
}
function start_poll_bot_send_move(botname = 'bob', ms = 3000) {
  DA.bots.push(botname);
  if (DB.games[Session.cur_game].game_type == 'race') {
    let o = { tid: Session.cur_tid, player_status: 'joined', score: 0, state: 'bot', uname: botname };
    start_polling(o, 'poll_bot_send_move', on_poll_bot_send_move, ms, create_ai_move);
  } else {
  }
}
function start_polling(data, type, onsuccess, ms = 5000, func) {
  delete DA.poll; allow_polling();
  DA.poll = {
    data: data,
    type: type,
    onsuccess: onsuccess,
    ms: ms,
    func: func
  };
  poll();
}
function start_prelims() {
  Speech = new Speaker('E');
  TOMan = new TimeoutManager();
  ColorThiefObject = new ColorThief();
  init_internet();
  init_keyhandlers();
  mBy('label_games').onclick = onclick_games;
  mBy('label_play').onclick = onclick_play;
  mBy('label_account').onclick = onclick_account;
  mBy('label_login').onclick = onclick_login;
  mBy('label_settings').onclick = onclick_settings;
  Session.cur_user = valf(queryStringToJson().user, 'guest');
  Session.cur_menu = 'games';
  Session.cur_game = 'gSpotit';
  Session.def_playmode = 'multi';
  Session.def_players = ['mimi', 'felix'];
  Session.def_players = ['mimi', 'afia', 'amanda', 'annabel', 'blade', 'felix', 'gul', 'lauren', 'mac', 'nasi', 'sarah', 'valerie'];
  Session.cur_chatter = 'gul';
  go_online();
  get_data(queryStringToJson(), 'user_info');
}
function start_simple() {
  let uname = localStorage.getItem('uname');
  if (isdef(uname)) onclick_user(uname); else show_users();
}
function start_simple_ack_round(ackstage, ack_players, nextplayer, callbackname_after_ack, keeppolling = false) {
  let fen = Z.fen;
  fen.ack_players = ack_players;
  fen.lastplayer = arrLast(ack_players);
  fen.nextplayer = nextplayer;
  fen.turn_after_ack = [nextplayer];
  fen.callbackname_after_ack = callbackname_after_ack;
  fen.keeppolling = keeppolling;
  Z.stage = ackstage;
  Z.turn = [ack_players[0]];
}
function start_simple_timer(dtimer, msInterval, onTick, msTotal, onElapsed) {
  if (isdef(DA.timer)) { DA.timer.clear(); DA.timer = null; }
  let timer = DA.timer = new SimpleTimer(dtimer, msInterval, onTick, msTotal, onElapsed);
  timer.start();
}
function start_sound() {
}
function start_table(uname, tid) {
  to_server({ uname: uname, tid: tid }, 'start_table');
}
function start_table_dep(tid) {
  let t = DB.tables[tid];
  Session.cur_tid = tid;
  t.status = 'started';
  t.moves = {};
  t.players.map(x => t.moves[x] = []);
  makemove(t);
}
function start_tests() {
  fentest_wise();
  //#region old tests
  //#endregion
}
function start_transaction() {
  if (DA.simulate) return;
  DA.simulate = true;
  DA.snapshot = { fen: jsCopy(Z.fen), stage: Z.stage, round: Z.round, phase: Z.phase, turn: Z.turn };
  DA.transactionlist = [];
}
function start_with_assets() {
  DA.isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1; if (DA.isFirefox) console.log('using Firefox!')
  show_home_logo();
  if (nundef(U)) { show_users(); return; }
  show_username();
  if (DA.TEST0) show('dTestButtons');
  //#region TESTING
  //#endregion
}
function start_with_basic_assets() {
  //wenn mit https://www.telecave.net/aroot/bg gestartet wird, ist man hier ein guest!
  if (is_admin()) {
    hide('dIntro');
    let user = load_user(Session.cur_user);
    loader_off();
    DA.next = get_dictionary();
    get_games();
    show('b_polling');
  } else {
    close_sidebar();
    mBy('user_info_mini').style.display = 'flex';
    mBy('b_toggle_sidebar').style.display = 'none';
    show('dIntro');
    get_intro();
  }
}
async function start0() {
  TESTING = 'nosockets';
  if (TESTING != 'nosockets') {
    Socket = TESTING == 'live' ? io('http://127.0.0.1:3000') : TESTING == 'nginx' ? io('http://216.250.112.218:3000') : io();
    Socket.on('message', x => console.log('got message', x));
    Socket.on('disconnect', x => console.log('got disconnect', x));
    Socket.on('update', x => console.log('got update', x));
  }
  let [citylist, capitals] = [M.cities, M.capitals] = await get_cities_and_capitals();
  await load_syms();
  let list = dict2list(citylist).filter(x => x.pop > 1000000 && x.type == 'capital');
  console.log('list', list);
  let cities = M.layers.cities = L.layerGroup();
  let markers = M.markers = [];
  for (const c of list) {
    let m = L.marker(c.center).bindPopup(c.name);
    addKeys(c, m);
    markers.push(m);
  }
  M.layers = {};
  cities.type == 'overlay';
  let osm = M.layers.osm = get_layer('osm', { opacity: 1, type: 'base' });
  let map = M.map = L.map('map', { center: Geo.places.tuerkenschanzpark, zoom: 2, layers: [osm, cities] });
  var baseMaps = { osm: osm };
  var overlayMaps = { cities: citylist };
  var layerControl = M.layer_control = L.control.layers(baseMaps, overlayMaps).addTo(map);
  return;
  let players = [{ name: 'felix', city: 'Paris' }, { name: 'amanda', city: 'Vienna' }, { name: 'mimi', city: 'Madrid' }];
  M.markers = {};
  players.map(x => M.markers[x.name] = get_marker(map, citylist[x.city].center, { user: x.name, draggable: true }));
  map.on('zoomend', ev => {
    let x = ev.target;
    dZoom.innerHTML = 'zoom: ' + x.getZoom();
  });
  console.log('marker in geojson: ', M.markers.felix.toGeoJSON());
  map.on('click', function (e) {
    document.getElementById('dPosition').innerHTML =
      "Lat, Lon : " + e.latlng.lat + ", " + e.latlng.lng;
  });
  L.streetView({ position: 'topleft', mapillaryId: 'RC1ZRTBfaVlhWmJmUGVqRk5CYnAxQTpmMGE3OTU0MzM0MTljZTA4' }).addTo(map);
  var marker = L.marker(map.getCenter()).addTo(map);
  map.on('move', function () { marker.setLatLng(map.getCenter()); });
}
function startBlinking(item, items, unique = true) {
  if (unique) {
    let prevLetter = firstCond(items, x => x.isBlinking == true);
    stopBlinking(prevLetter);
  }
  mClass(iDiv(item), 'blink');
  item.isBlinking = true;
}
function StartChessGame() {
  InitFilesRanksBrd();
  InitSq120To64();
  InitHashKeys();
  InitBoardVars();
  InitMvvLva();
  InitBoardSquares();
  EvalInit();
  srch_thinking = BOOL.FALSE;
  $('#fenIn').val(START_FEN);
  NewGame();
  NewGameAjax();
}
async function startClientTest() {
  hide('dMainContent');
  show('dGameScreen');
  setTitle('*** Testing ***');
  setSubtitle('logged in as ' + Username);
  mStyleX(document.body, { opacity: 1 });
  initTable(null, 2); initSidebar(); initAux(); initScore();
  runClientTest();
}
function startgame(game, players, options = {}) {
  if (nundef(game)) game = 'a_game';
  let default_options = {}; for (const k in Config.games[game].options) default_options[k] = arrLast(Config.games[game].options[k].split(','));
  addKeys(default_options, options);
  if (nundef(players)) players = rChoose(Serverdata.users, 2).map(x => ({ name: x.name }));
  let playernames = players.map(x => x.name);
  let fen = window[game]().setup(playernames, options);
  if (nundef(fen.round)) fen.round = 1;
  if (nundef(fen.phase)) fen.phase = '';
  if (nundef(fen.stage)) fen.stage = 0;
  if (nundef(fen.step)) fen.step = 0;
  if (nundef(fen.turn)) fen.turn = [fen.plorder[0]]; else if (DA.TESTSTART1 && fen.turn.length == 1) fen.turn = [playernames[0]];
  players.map(x => { let pl = fen.players[x.name]; pl.playmode = valf(x.playmode, 'human'); pl.strategy = valf(x.strategy, valf(options.strategy, 'random')); });
  if (options.mode == 'solo') {
    let me = isdef(U) && isdef(fen.players[U.name]) ? U.name : rChoose(playernames);
    for (const plname of playernames) {
      if (plname == me) continue;
      fen.players[plname].playmode = 'bot';
    }
    options.mode = 'hotseat';
  }
  for (const k in options) { if (isNumber(options[k])) options[k] = parseInt(options[k]); }
  let o = {
    friendly: generate_table_name(players.length), game: game, host: playernames[0], players: playernames,
    fen: fen, options: options
  };
  ensure_polling();
  phpPost(o, 'startgame');
}
function startGame() {
  meme = new component(30, 30, 'red', 10, 120);
  meme.gravity = 0.05;
  score = new component('30px', 'Consolas', 'black', 280, 40, 'text');
  myGameArea.start();
}
function startGameML() { }
function startGameSP() { }
function startGameSPA() { }
function startGameTC() { }
function startGameTP() { }
function startGameWP() {
  onkeydown = ev => {
    if (uiPaused) return;
    if (isdef(inputBox)) { inputBox.focus(); }
  }
}
function startingSetup() {
}
function startInteraction() {
  boatFilters = [];
  if (isdef(IdOwner.a)) IdOwner.a.map(x => _addStandardInteraction(x));
  if (isdef(IdOwner.l)) IdOwner.l.map(x => _addStandardInteraction(x));
  if (isdef(IdOwner.p)) IdOwner.p.map(x => _addStandardInteraction(x));
  if (isdef(IdOwner.r)) IdOwner.r.map(x => _addStandardInteraction(x));
  if (isdef(IdOwner.t)) IdOwner.t.map(x => _addStandardInteraction(x));
  _preselectFirstVisualsForBoats();
  choiceCompleted = false;
  let nBoats = getBoatIds().length;
  let autoplay = S_autoplayFunction(G) || nBoats < 2 || robbedDescInBoats();
  if (autoplay) {
    setTimeout(onClickStep, S_AIThinkingTime);
    return;
  } else if (!isEmpty(scenarioQ)) {
    let func = scenarioQ.shift();
    func();
  } else {
    scenarioRunning = false;
    setAutoplayFunctionForMode();
    unfreezeUI();
  }
}
function startLevel() {
  Speech.setLanguage(Settings.language);
  getGameValues(Username, G.id, G.level);
  G.instance.startLevel();
  if (G.keys.length < G.numPics) { updateKeySettings(G.numPics + 5); }
  startRound();
}
function startLevelML() { levelML(); }
function startLevelSP() { levelSP(); }
function startLevelSPA() { levelSPA(); }
function startLevelTC() { levelTC(); }
function startLevelTP() { levelTP(); }
function startLevelWP() { levelWP(); }
async function startloading() {
  let path = `${Basepath}/DB.yaml`;
  var DB = await route_path_yaml_dict(path);
}
function startloop() { FR = 30; DA.interval = setInterval(update_draw_items, 1000 / FR) }
function startPulsating(item, items, unique = true) {
  if (unique) {
    let prevLetter = firstCond(items, x => x.isPulsating == true);
    stopPulsating(prevLetter);
  }
  mClass(iDiv(item), 'onPulse');
  item.isPulsating = true;
}
function startQRunner() {
  if (QRunnerRunning) return;
  QRunnerRunning = true;
  QRunner();
}
function startRound() {
  if (G.addonActive != true && isTimeForAddon()) {
    G.addonActive = true;
    exitToAddon(startRound); return;
  } else G.addonActive = false;
  resetRound();
  uiActivated = false;
  G.instance.startRound();
  TOMain = setTimeout(() => prompt(), 300);
}
function startRoundML() { }
function startRoundReally() {
  clearFleetingMessage();
  showStats();
  LevelChange = false;
  if (ROUND_OUTPUT) {
  }
  trialNumber = 0;
  GFUNC[currentGame].startRound();
  promptStart();
}
function startRoundSP() { }
function startRoundSPA() { }
function startRoundTC() {
  uiActivatedTC = false;
}
function startRoundTP() {
  uiActivated = false;
}
function startRoundWP() { }
function StartSearch() {
  srch_depth = MAXDEPTH;
  var t = $.now();
  var tt = $('#ThinkTimeChoice').val();
  if (nundef(tt)) tt = 6;
  srch_time = parseInt(tt) * 1000;
  SearchPosition();
  StopThinking();
  if (FLAG_HINT_ONLY) {
    FLAG_HINT_ONLY = false;
    let info = Move2FromTo(srch_best);
    let sq = info.from.sq;
    HintAnimation(sq, 1000);
  } else {
    MakeMove(srch_best);
    MoveGUIPiece(srch_best);
    CheckAndSet();
  }
}
function startsWith(s, sSub) {
  return s.substring(0, sSub.length) == sSub;
}
function startsWithCaseIn(s, ssub) {
  return startsWith(s.toLowerCase(), ssub.toLowerCase());
}
function startsWithCaseIndep(s, ssub) {
  return startsWith(s.toLowerCase(), ssub.toLowerCase());
}
function startsWithCaseInsensitive(s, ssub) {
  return startsWith(s.toLowerCase(), ssub.toLowerCase());
}
async function startTesting() {
  hide('dMainContent');
  show('dGameScreen');
  setTitle('*** Testing ***');
  setSubtitle('logged in as ' + Username);
  let color = USERNAME_SELECTION == 'local' ? localStorage.getItem('BaseColor') : null;
  setNewBackgroundColor(color);
  mStyleX(document.body, { opacity: 1 });
  initTable(null, 2); initSidebar(); initAux(); initScore();
  runTest();
}
function startTestLoop() {
  if (isLastTestOfSeries()) {
    isTraceOn = SHOW_TRACE;
    console.log('TESTS COMPLETED!');
  } else {
    nextTestOfSeries();
    if (!isLastTestOfSeries()) setTimeout(startTestLoop, 1000);
  }
}
function startTestSeries() {
  let numSeries = Object.keys(ALLTESTS).length;
  if (iTESTSERIES >= numSeries) {
    console.log('TEST SERIES COMPLETED!');
    isTraceOn = SHOW_TRACE;
    return;
  } else if (isLastTestOfSeries()) {
    iTESTSERIES += 1;
    iTEST = 0;
  } else {
    nextTestOfSeries();
  }
  if (iTESTSERIES < numSeries) setTimeout(startTestSeries, 1000);
}
function StartThinking() {
  let img = mBy('ThinkingPng');
  show(img);
  mClass(img, 'blinkFast');
  mBy('dShield').style.display = 'block';
}
function startTime(elem) {
  if (nundef(Settings.showTime) || !Settings.showTime) return;
  if (nundef(TimestampStarted)) { TimestampStarted = msNow(); TimeElapsed = 0; }
  if (nundef(elem) && isdef(TimeElem)) { elem = TimeElem; }
  else { if (isString(elem)) elem = mBy(elem); TimeElem = elem; }
  var timeLeft = TimeLeft = Settings.minutesPerUnit * 60000 - getTimeElapsed();
  if (timeLeft > 0) {
    let t = msToTime(timeLeft);
    let s = format2Digits(t.h) + ":" + format2Digits(t.m) + ":" + format2Digits(t.s);
    elem.innerHTML = s;
    setTimeout(() => startTime(elem), 500);
  } else {
    elem.innerHTML = '00:00:00';
    if (OnTimeOver) OnTimeOver();
  }
}
function startTimeCD(elem, ms, callback) {
  if (isdef(ms)) { MSTimeClock = ms; MSTimeDiff = 0; MSTimeStart = Date.now(); MSTimeCallback = callback; }
  else { MSTimeDiff = (Date.now() - MSTimeStart); }
  if (MSTimeDiff > MSTimeClock) {
    MSTimeCallback();
    return;
  }
  let t = msToTime(MSTimeClock - MSTimeDiff);
  if (isString(elem)) elem = mBy(elem); elem.innerHTML = t.h + ":" + format2Digits(t.m) + ":" + format2Digits(t.s);
  MSTimeTO = setTimeout(() => startTimeCD(elem), 500);
}
function startTimeClock(elem) {
  if (nundef(Settings.showTime) || !Settings.showTime) return;
  var today = new Date(),
    h = format2Digits(today.getHours()),
    m = format2Digits(today.getMinutes()),
    s = format2Digits(today.getSeconds());
  if (isString(elem)) elem = mBy(elem); elem.innerHTML = h + ":" + m + ":" + s;
  TOList.clock = setTimeout(() => startTimeClock(elem), 500);
}
function startTurn() {
  let me = getTurnPlayer();
  changeUserTo(me.id)
  showHands();
  present();
  optionsFor(me);
}
function startUnit() {
  renewTimer(G, 'time');
  U.session = {};
  if (START_IN_MENU) { START_IN_MENU = false; onClickTemple(); } else GC.startGame();
}
function staticArea(areaName, oSpec) {
  func = correctFuncName(oSpec.type);
  oSpec.ui = window[func](areaName, oSpec);
}
function staticPos(ms) {
  let gameArea = UIS['a_d_game'];
  let actionArea = UIS['a_d_actions'];
  let pageHeaderArea = UIS['a_d_header'];
  let statusArea = UIS['a_d_status'];
  let x = actionArea.w + gameArea.w / 2 + ms.x;
  let y = pageHeaderArea.h + statusArea.h + gameArea.h / 2 + ms.y;
  return { x: x, y: y };
}
function staticTitle() {
  clearInterval(TO.titleInterval);
  let url = window.location.href;
  let loc = url.includes('telecave') ? 'telecave' : 'local';
  let game = isdef(Z) ? stringAfter(Z.friendly, 'of ') : '♠ GAMES ♠';
  document.title = `(${loc}) ${game}`;
}
function status_message(msg, styles = {}) {
  let d = mBy('dMessage'); show(d); clearElement(d);
  let def_styles = { padding: 20, align: 'center', position: 'absolute', fg: 'contrast', fz: 24, w: '100vw' };
  copyKeys(styles, def_styles);
  let dContent = mDiv(d, def_styles, null, msg);
  return dContent;
}
function status_message_new(msg, dParent, styles = {}) {
}
function status_message_off() {
  let d = mBy('dMessage');
  clearElement(d);
  hide(d);
  onclick = null;
}
function std2fold(dMain) {
  let dOuter = mDiv(dMain, { bg: 'random', flex: '1 0 auto', display: 'flex', 'flex-flow': 'row wrap' });
  let dLeft = mDiv(dOuter, { bg: 'random', w: 100 }, 'dLeft', 'left');
  let dMiddle = mDiv(dOuter, { bg: 'random', flex: '1 0 auto' }, 'dMiddle', 'middle');
  return [dLeft, dMiddle];
}
function std3fold(dMain) {
  let dOuter = mDiv(dMain, { flex: '1 0 auto', display: 'flex', 'flex-flow': 'row' });
  let dLeft = mDiv(dOuter, { w: 100 }, 'dLeft', 'left');
  let dMiddle = mDiv(dOuter, { position: 'relative', bg: '#ffffff80', flex: '1 0 auto' }, 'dMiddle');
  let dRight = mDiv(dOuter, { w: 100, overflow: 'hidden' }, 'dRight', 'right');
  return [dLeft, dMiddle, dRight];
}
function std3title(dMain, title, titleStyles) {
  let prefix = 'title';
  let dOuter = mDiv(dMain, { bg: '#000000', alpha: .5, display: 'flex', 'flex-flow': 'row' });
  let dLeft = mDiv(dOuter, { w: 100 }, `d${prefix}Left`);
  let dMiddle = mDiv(dOuter, { align: 'center', flex: '1 0 auto' }, `d${prefix}Middle`, title);
  mCenterCenterFlex(dMiddle);
  if (isdef(titleStyles)) mStyle(dMiddle, titleStyles);
  let dRight = mDiv(dOuter, { align: 'right', wmin: 100, overflow: 'hidden' }, `d${prefix}Right`);
  return [dLeft, dMiddle, dRight];
}
function stdCardsContainer(dParent, n, ov = 80, styles = {}) { return stdRowOverlapContainer(dParent, n, n * ov + 22, ov, addKeys({ paleft: 20, patop: 10 }, styles)); }
function stdColOverlapContainer(dParent, n, wGrid, wCell, styles) {
  addKeys({
    h: wGrid,
    gap: 0,
    display: 'inline-grid',
    'grid-template-rows': `repeat(${n}, ${wCell}px)`
  }, styles);
  return mDiv(dParent, styles);
}
function stdContainerCenterColWrap(dParent) { return stdFlexContainer(dParent, { dir: 'col', 'align-content': 'center' }); }
function stdContainerCenterRowWrap(dParent) { return stdFlexContainer(dParent, { 'justify-content': 'center' }); }
function stdContainerColWrap(dParent) { return stdFlexContainer(dParent, { dir: 'col' }); }
function stdContainerRowWrap(dParent) { return stdFlexContainer(dParent); }
function stdDeckContainer(dParent, n, ov = .25, styles = {}) { return stdRowOverlapContainer(dParent, n, 140, ov, addKeys({ padding: 10 }, styles)); }
function stdFlexContainer(dParent, styles = {}) {
  addKeys({
    wmax: '96%',
    margin: 'auto',
    padding: 10,
    gap: 10,
    display: 'flex',
    flex: '1 0 auto',
    wrap: true,
  }, styles);
  return mDiv(dParent, styles);
}
function stdGridContainer(dParent, wCell, styles = {}) {
  addKeys({
    wmax: 500,
    margin: 'auto',
    padding: 10,
    gap: 0,
    display: 'grid',
    bg: 'green',
    'grid-template-columns': `repeat(${20}, ${wCell}px)`
  }, styles);
  return mDiv(dParent, styles);
}
function stdHandContainer(dParent, n, ov = 20, styles = {}) { return stdRowOverlapContainer(dParent, n, 76 + n * ov + 22, ov, addKeys({ padding: 10 }, styles)); }
function stdInput(dParent, styles) {
  let defStyles = { fz: 20, padding: 12 };
  if (nundef(styles)) styles = {};
  let newStyles = deepmergeOverride(defStyles, styles);
  return mInputX(dParent, newStyles,
    { textPadding: 4, autoComplete: 'off', autoFocus: true, autoSelect: false })
}
function stdInputSubmit(dParent, styles, handler) {
  let defStyles = { fz: 20, padding: 12 };
  if (nundef(styles)) styles = {};
  let newStyles = deepmergeOverride(defStyles, styles);
  return mInputX(dParent, newStyles,
    { textPadding: 4, autoComplete: 'off', submitOnEnter: true, autoFocus: true, autoSelect: false, handler: handler })
}
function stdInputVal(dParent, styles, val, autoSelect = true) {
  let defStyles = { fz: 20, padding: 12 };
  if (nundef(styles)) styles = {};
  let newStyles = deepmergeOverride(defStyles, styles);
  return mInputX(dParent, newStyles,
    { value: val, textPadding: 4, autoComplete: 'off', submitOnEnter: true, autoFocus: true, autoSelect: autoSelect })
}
function stdInstruction(written, dParent, spoken, { fz, voice, lang } = {}) {
  if (isdef(lang) && lang == 'D' && nundef(voice)) voice = 'deutsch';
  else if (isdef(lang) && lang == 'E' && nundef(voice)) voice = 'random';
  if (nundef(voice)) voice = 'random';
  let d;
  if (isdef(dParent)) clearElement(dParent);
  dInstruction = d = mDiv(dParent);
  mStyleX(d, { margin: 15 })
  mClass(d, 'flexWrap');
  if (nundef(fz)) fz = 36;
  let d1 = mText(written, d, { fz: fz, display: 'inline-block' });
  if (isdef(spoken)) {
    let sym = symbolDict.speaker;
    let d2 = mText(sym.text, d, {
      fz: fz + 2, weight: 900, display: 'inline-block',
      family: sym.family, 'padding-left': 14
    });
    sayRandomVoice(spoken, spoken, voice);
  }
  dInstruction.onclick = () => aniInstruction(spoken);
  return d;
}
function stdMenuButton(parent, styles = {}) { return mButton(UnicodeSymbols.menu, null, parent, styles, 'mybutton'); }
function stdRowOverlapContainer(dParent, n, wGrid, wCell, styles) {
  addKeys({
    w: wGrid,
    gap: 0,
    display: 'inline-grid',
    'grid-template-columns': `repeat(${n}, ${wCell}px)`
  }, styles);
  return mDiv(dParent, styles);
}
function stdRowsColsContainer(dParent, cols, styles = {}) {
  addKeys({
    margin: 'auto',
    padding: 10,
    gap: 10,
    display: 'grid',
    bg: 'green',
    'grid-template-columns': `repeat(${cols}, 1fr)`
  }, styles);
  return mDiv(dParent, styles);
}
function stdSidebarController(button, id) {
  let [ms, easing] = [500, 'cubic-bezier(.1,.67,.81,.68)'];
  button.onclick = () => {
    let d = mBy(id);
    let open = nundef(d.isOpen) || d.isOpen == true;
    d.isOpen = !open;
    let [from, to] = open ? [100, 0] : [0, 100];
    d.animate([{ width: `${from}px` }, { width: `${to}px` }], { duration: ms, easing: easing });
    setTimeout(() => d.style.width = `${to}px`, ms - 10);
  }
}
function step() {
}
function stop_game() { console.log('stopgame'); }
function stop_polling() { clearTimeout(TOTicker); IS_POLLING_ALLOWED = false; if (isdef(DA.poll)) console.log('...polling is OFF'); }
function stop_simple_timer() { if (isdef(DA.timer)) { DA.timer.clear(); DA.timer = null; } }
function stop_timer() {
  if (isdef(DA.timer)) {
    let res = DA.timer.clear();
    DA.timer = null;
    return isNumber(res) ? res : 0;
  }
  return 0;
}
function stopAllHighlighting() {
  if (isdef(IdOwner.a)) IdOwner.a.map(x => _removeAllHighlighting(x));
  if (isdef(IdOwner.l)) IdOwner.l.map(x => _removeAllHighlighting(x));
  if (isdef(IdOwner.p)) IdOwner.p.map(x => _removeAllHighlighting(x));
  if (isdef(IdOwner.r)) IdOwner.r.map(x => _removeAllHighlighting(x));
  if (isdef(IdOwner.s)) IdOwner.s.map(x => _removeAllHighlighting(x));
  if (isdef(IdOwner.t)) IdOwner.t.map(x => _removeAllHighlighting(x));
  setTimeout(hideTooltip, 500);
}
function stopBlinking(item) { if (isdef(item)) { item.isBlinking = false; mRemoveClass(iDiv(item), 'blink'); } }
function stopgame() {
  if (!DA.running) return;
  DA.running = false;
  DA.noshow = 0;
  clear_timeouts();
  hide('bRestartMove');
  hide('dHostButtons');
  mStyle('dAdmin', { bg: 'white' });
  mClear('dAdminMiddle')
  for (const id of ['bSpotitStart', 'bClearAck', 'bRandomMove', 'bSkipPlayer']) hide(id);
  pollStop();
  Z = null; delete Serverdata.table; delete Serverdata.playerdata; Clientdata = {};
  staticTitle();
}
function stopGame() {
  resetState();
}
function stopInteraction() {
  if (isdef(IdOwner.a)) IdOwner.a.map(x => _removeInteraction(x));
  if (isdef(IdOwner.l)) IdOwner.l.map(x => _removeInteraction(x));
  if (isdef(IdOwner.p)) IdOwner.p.map(x => _removeInteraction(x));
  if (isdef(IdOwner.r)) IdOwner.r.map(x => _removeInteraction(x));
  if (isdef(IdOwner.s)) IdOwner.s.map(x => _removeInteraction(x));
  if (isdef(IdOwner.t)) IdOwner.t.map(x => _removeInteraction(x));
  setTimeout(hideTooltip, 500);
}
function stopInteractionH() {
  if (isdef(IdOwner.a)) IdOwner.a.map(x => removeAllHighlighting(x));
  if (isdef(IdOwner.l)) IdOwner.l.map(x => removeAllHighlighting(x));
  if (isdef(IdOwner.p)) IdOwner.p.map(x => removeAllHighlighting(x));
  if (isdef(IdOwner.r)) IdOwner.r.map(x => removeAllHighlighting(x));
  if (isdef(IdOwner.s)) IdOwner.s.map(x => removeAllHighlighting(x));
  if (isdef(IdOwner.t)) IdOwner.t.map(x => removeAllHighlighting(x));
  setTimeout(hideTooltip, 500);
}
function STOPP() { stopgame(); clear_screen(); assertion(Z == null, "ZZZZZZZZZZ NOT NULL") }
function stopPolling() { pollStop(); }
function stopPulsating(item) { if (isdef(item)) { item.isPulsating = false; mRemoveClass(iDiv(item), 'onPulse'); } }
function StopThinking() {
  let img = mBy('ThinkingPng');
  mClassRemove(img, 'blinkFast');
  hide(img);
  hideShield();
}
function storePositionData(g1) {
  let ids = g1.getNodeIds();
  let x = 10; let y = 10;
  for (const id of ids) {
    g1.setProp(id, 'center', { x: x, y: y });
    x += 50; y += 50; if (y > 250) { y = 10; } if (x > 550) { x = 10; }
  }
}
function StorePvMove(move) {
  var index = brd_posKey % PVENTRIES;
  brd_PvTable[index].move = move;
  brd_PvTable[index].posKey = brd_posKey;
}
function storeRoomPositions(g1, house) {
  let ids = g1.getNodeIds();
  let di = g1.posDict = {};
  for (const id of ids) {
    let r = Items[id];
    let center = getCenter(iDiv(r));
    center.x += r.rect.x;
    center.y += r.rect.y;
    g1.setProp(id, 'center', center);
    di[id] = center;
  }
}
function strategicBoat(goodlist, badlist) {
  let boats = getBoats();
  let goodBoats = boats;
  if (isdef(badlist)) {
    goodBoats = [];
    for (const b of boats) {
      if (isEmpty(badlist.filter(x => b.o.text.join(',').includes(x)))) goodBoats.push(b);
    }
  }
  if (isdef(goodlist)) {
    for (const kw of goodlist) {
      for (const b of boats) {
        if (b.o.text.join(',').includes(kw) || b.o.desc.includes(kw)) return b;
      }
    }
  }
  return chooseRandom(goodBoats);
}
function stressTest() {
  initRSGData(); showGame(); initDom();
  timit.reset();
  let board = makeDrawingArea('board', 'a_d_game', true);
  coll = drawTest(board, 3);
}
function stressTest01(area) {
  timit.showTime('*test')
  let n = 500;
  for (let index = 0; index < n; index++) {
    showPictoDivCentered('crow', area, randomColor(), n + 25 - index);
  }
  timit.showTime('*test done...');
  if (testCounter > 0) { testCounter -= 1; setTimeout(_startStep, 0); }
  else {
    let t = timit.getTotalTimeElapsed();
    console.log('avg msecs per cycle:', t / 100, 'cycle size:', n)
  }
}
function stringAfter(sFull, sSub) {
  let idx = sFull.indexOf(sSub);
  if (idx < 0) return '';
  return sFull.substring(idx + sSub.length);
}
function stringAfterLast(sFull, sSub) {
  let parts = sFull.split(sSub);
  return arrLast(parts);
}
function stringAfterLeadingConsonants(s) {
  let regexpcons = /^([^aeiou])+/g;
  let x = s.match(regexpcons);
  return x ? s.substring(x[0].length) : s;
}
function stringBefore(sFull, sSub) {
  let idx = sFull.indexOf(sSub);
  if (idx < 0) return sFull;
  return sFull.substring(0, idx);
}
function stringBeforeLast(sFull, sSub) {
  let parts = sFull.split(sSub);
  return sFull.substring(0, sFull.length - arrLast(parts).length - 1);
}
function stringBetween(sFull, sStart, sEnd) {
  return stringBefore(stringAfter(sFull, sStart), isdef(sEnd) ? sEnd : sStart);
}
function stringBetweenLast(sFull, sStart, sEnd) {
  let s1 = stringBeforeLast(sFull, isdef(sEnd) ? sEnd : sStart);
  return stringAfterLast(s1, sStart);
}
function stringDivider(str, width, spaceReplacer) {
  if (str.length > width) {
    let p = width;
    while (p > 0 && str[p] != ' ' && str[p] != '-') {
      p--;
    }
    if (p > 0) {
      let left;
      if (str.substring(p, p + 1) == '-') {
        left = str.substring(0, p + 1);
      } else {
        left = str.substring(0, p);
      }
      const right = str.substring(p + 1);
      return left + spaceReplacer + stringDivider(right, width, spaceReplacer);
    }
  }
  return str;
}
function stringLast(s, n) { return s.substring(s.length - n, s.length); }
function stringToMatrix(s, rows, cols) {
  if (isNumber(s)) s = String(s);
  let letters = toLetterArray(s);
  let nums = letters.map(x => Number(x));
  let matrix = arrToMatrix(nums, rows, cols);
}
function stripObject(o, keysToDelete) {
  for (const k of keysToDelete) {
    if (isdef(o[k])) delete o[k];
  }
}
function stripSet(x) {
  if (isListOfListOfActions(x)) return x;
  else if (isActionElement(x)) return [[x]];
  else if (isList(x) && isActionElement(x[0])) return [x];
  else return [].concat(...x.map(stripSet));
}
function stripToKeys(o, di) {
  let res = {};
  for (const k in o) {
    if (isdef(di[k])) res[k] = o[k];
  }
  return res;
}
function strKeys(dict) { return getKeys(dict).toString(); }
function stubPlayerConfig(gameInfo) {
  gcs = {};
  for (const gName in gameInfo) {
    let info = gameInfo[gName]
    let nPlayers = info.num_players[0];
    let pls = [];
    for (let i = 0; i < nPlayers; i++) {
      let pl = { id: info.player_names[i], playerType: 'me', agentType: null, username: USERNAME + (i > 0 ? i : '') };
      pls.push(pl);
    }
    gcs[gName] = { numPlayers: nPlayers, players: pls };
  }
  return gcs;
}
function style_not_playing(item, game, list) {
  console.log('item', item, 'game', game, 'list', list)
  let ui = iDiv(item); let uname = ui.getAttribute('username');
  mStyle(ui, { bg: 'transparent', fg: 'black' });
  arrLast(arrChildren(ui)).innerHTML = uname;
  item.ifunc = 0; item.playmode = 'none'; removeInPlace(list, item);
}
function style_playing_as_bot(item, game, list) {
  let ui = iDiv(item); let uname = ui.getAttribute('username'); let bg = get_game_color(game);
  mStyle(ui, { bg: bg, fg: colorIdealText(bg) });
  arrLast(arrChildren(ui)).innerHTML = uname.substring(0, 3) + 'bot';
  item.ifunc = 2; item.playmode = 'bot';
}
function style_playing_as_human(item, game, list) {
  let ui = iDiv(item); let uname = ui.getAttribute('username');
  mStyle(ui, { bg: get_user_color(uname), fg: colorIdealText(get_user_color(uname)) });
  arrLast(arrChildren(ui)).innerHTML = uname;
  item.ifunc = 1; item.playmode = 'human'; list.push(item);
}
function styles_to_leaflet_options(o) {
  let res = {};
  let di = {
    fg: 'color', bg: 'fillColor', opacity: 'fillOpacity', sz: 'radius'
  };
  for (const k in o) {
    if (k == 'sz') o[k] /= 2;
    res[isdef(di[k]) ? di[k] : k] = o[k];
  }
  return res;
}
function subDict(d, keys) {
  let dNew = {};
  for (const key of keys) {
    if (key in d) {
      dNew[key] = d[key];
    }
  }
  return dNew;
}
function subdictOf(dict1, keylist) {
  let res = {};
  for (const k of keylist) {
    res[k] = dict1[k];
  }
  return res;
}
function submit_form(fname) {
  if (typeof document.getElementById(fname).submit === "object") {
    document.getElementById(fname).submit.remove();
  }
  document.getElementById(fname).submit();
}
function substringOfMinLength(s, minStartIndex, minLength) {
  let res = s.substring(minStartIndex).trim();
  let i = 0;
  let res1 = '';
  while (res1.trim().length < minLength && i < res.length) { res1 += res[i]; i += 1; }
  return res1.trim();
}
function success_pic_goal(withComment = true) {
  let lang = G.language;
  if (withComment && G.spokenFeedback) {
    const comments = {
      E: ['YEAH!', 'Excellent!!!', 'CORRECT!', 'Great!!!'],
      D: ['gut', 'Sehr Gut!!!', 'richtig!!', 'Bravo!!!'],
      S: ['bien', 'muy bien!!!', 'eccelente!!', 'bravo!!!'],
      F: ['bien', 'tres bien!!!', 'fantastique!!', 'bravo!!!', 'excellent!!!'],
      C: ['优秀', '好的!!!', '正确的!!', 'Bravo!!!'],
    }[lang];
    say(chooseRandom(comments), lang);
  }
  if (isdef(Selected) && isdef(Selected.feedbackUI)) {
    let uilist;
    if (isdef(Selected.positiveFeedbackUI)) uilist = [Selected.positiveFeedbackUI];
    else uilist = isList(Selected.feedbackUI) ? Selected.feedbackUI : [Selected.feedbackUI];
    let sz = getRect(uilist[0]).h;
    for (const ui of uilist) {
      let d = markerSuccess();
      mpOver(d, ui, sz * (4 / 5), 'limegreen', 'segoeBlack');
    }
  }
}
function successPictureGoal(withComment = true) {
  if (withComment && G.spokenFeedback) {
    const comments = (G.language == 'E' ? ['YEAH!', 'Excellent!!!', 'CORRECT!', 'Great!!!'] : ['gut', 'Sehr Gut!!!', 'richtig!!', 'Bravo!!!']);
    sayRandomVoice(chooseRandom(comments));
  }
  if (isdef(Selected) && isdef(Selected.feedbackUI)) {
    let uilist;
    if (isdef(Selected.positiveFeedbackUI)) uilist = [Selected.positiveFeedbackUI];
    else uilist = isList(Selected.feedbackUI) ? Selected.feedbackUI : [Selected.feedbackUI];
    let sz = getRect(uilist[0]).h;
    for (const ui of uilist) {
      let d = markerSuccess();
      mpOver(d, ui, sz * (4 / 5), 'limegreen', 'segoeBlack');
    }
  }
}
function successThumbsUp(withComment = true) {
  if (withComment && G.spokenFeedback) {
    const comments = (G.language == 'E' ? ['YEAH!', 'Excellent!!!', 'CORRECT!', 'Great!!!'] : ['gut', 'Sehr Gut!!!', 'richtig!!', 'Bravo!!!']);
    sayRandomVoice(chooseRandom(comments));
  }
  let p1 = firstCond(Pictures, x => x.key == 'thumbs up');
  iDiv(p1).style.opacity = 1;
  let p2 = firstCond(Pictures, x => x.key == 'thumbs down');
  iDiv(p2).style.display = 'none';
}
function successThumbsUpPlus(withComment = true) {
  if (withComment && G.spokenFeedback) {
    const comments = (G.language == 'E' ? ['YEAH!', 'Excellent!!!', 'CORRECT!', 'Great!!!'] : ['gut', 'Sehr Gut!!!', 'richtig!!', 'Bravo!!!']);
    sayRandomVoice(chooseRandom(comments));
  }
  let p1 = firstCond(Pictures, x => x.key == 'thumbs up');
  iDiv(p1).style.opacity = 1;
  let p2 = firstCond(Pictures, x => x.key == 'thumbs down');
  iDiv(p2).style.display = 'none';
  if (isdef(Selected) && isdef(Selected.feedbackUI)) {
    let uilist;
    if (isdef(Selected.positiveFeedbackUI)) uilist = [Selected.positiveFeedbackUI];
    else uilist = isList(Selected.feedbackUI) ? Selected.feedbackUI : [Selected.feedbackUI];
    let sz = getRect(uilist[0]).h;
    for (const ui of uilist) {
      let d = markerSuccess();
      mpOver(d, ui, sz * (4 / 5), 'limegreen', 'segoeBlack');
    }
  }
}
function sudoku99Examples() {
  var veryeasyGameArr = [
    [2, 0, 3, 0, 0, 8, 6, 0, 7],
    [1, 4, 0, 7, 2, 6, 0, 0, 9],
    [5, 0, 7, 1, 3, 9, 4, 2, 8],
    [0, 2, 5, 0, 8, 1, 9, 0, 4],
    [4, 1, 0, 9, 0, 3, 2, 0, 5],
    [0, 7, 9, 2, 0, 5, 0, 3, 6],
    [6, 0, 2, 0, 1, 0, 0, 9, 3],
    [7, 0, 0, 5, 0, 2, 0, 0, 1],
    [0, 8, 1, 3, 6, 7, 0, 4, 0]
  ];
  var easyGameArr = [
    [0, 3, 0, 0, 0, 0, 0, 0, 0],
    [0, 2, 0, 9, 0, 6, 3, 0, 0],
    [0, 6, 0, 4, 0, 2, 0, 9, 0],
    [1, 0, 0, 0, 9, 0, 4, 0, 0],
    [0, 0, 8, 1, 0, 3, 5, 0, 0],
    [0, 0, 5, 0, 7, 0, 0, 0, 3],
    [0, 5, 0, 3, 0, 1, 0, 6, 0],
    [0, 0, 4, 6, 0, 7, 0, 3, 0],
    [0, 0, 0, 0, 0, 0, 0, 8, 0]
  ];
  var mediumGameArr = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 3, 0, 8, 5],
    [0, 0, 1, 0, 2, 0, 0, 0, 0],
    [0, 0, 0, 5, 0, 7, 0, 0, 0],
    [0, 0, 4, 0, 0, 0, 1, 0, 0],
    [0, 9, 0, 0, 0, 0, 0, 0, 0],
    [5, 0, 0, 0, 0, 0, 0, 7, 3],
    [0, 0, 2, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 4, 0, 0, 0, 9]
  ];
  var hardGameArr = [
    [0, 0, 0, 0, 0, 7, 0, 0, 0],
    [0, 0, 2, 4, 0, 6, 3, 0, 0],
    [0, 1, 7, 0, 0, 0, 9, 6, 0],
    [5, 8, 0, 0, 0, 0, 0, 3, 0],
    [0, 0, 0, 0, 9, 0, 0, 0, 0],
    [0, 7, 0, 0, 0, 0, 0, 4, 2],
    [0, 9, 4, 0, 0, 0, 6, 5, 0],
    [0, 0, 5, 2, 0, 8, 1, 0, 0],
    [0, 0, 0, 5, 0, 0, 0, 0, 0]
  ];
  var hardGameArr2 = [
    [0, 4, 3, 0, 1, 0, 0, 0, 0],
    [0, 0, 2, 0, 7, 0, 0, 3, 1],
    [8, 0, 0, 0, 0, 9, 0, 0, 0],
    [3, 0, 9, 0, 0, 5, 0, 0, 0],
    [0, 2, 5, 0, 0, 0, 4, 7, 0],
    [0, 0, 0, 7, 0, 0, 3, 0, 6],
    [0, 0, 0, 9, 0, 0, 0, 0, 5],
    [9, 5, 0, 0, 2, 0, 1, 0, 0],
    [0, 0, 0, 0, 5, 0, 6, 9, 0]
  ];
  var hardGameArr3 = [
    [0, 3, 0, 0, 5, 0, 2, 0, 8],
    [0, 0, 4, 0, 0, 0, 9, 0, 0],
    [0, 0, 0, 6, 0, 0, 0, 1, 0],
    [0, 6, 7, 5, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 8, 0, 0, 0, 0],
    [0, 0, 1, 0, 0, 9, 8, 4, 0],
    [0, 7, 0, 0, 0, 6, 0, 0, 0],
    [0, 0, 8, 0, 0, 0, 3, 0, 0],
    [1, 0, 2, 0, 4, 0, 0, 8, 0]
  ];
  var evilGameArr = [
    [8, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 3, 6, 0, 0, 0, 0, 0],
    [0, 7, 0, 0, 9, 0, 2, 0, 0],
    [0, 5, 0, 0, 0, 7, 0, 0, 0],
    [0, 0, 0, 0, 4, 5, 7, 0, 0],
    [0, 0, 0, 1, 0, 0, 0, 3, 0],
    [0, 0, 1, 0, 0, 0, 0, 6, 8],
    [0, 0, 8, 5, 0, 0, 0, 1, 0],
    [0, 9, 0, 0, 0, 0, 4, 0, 0]
  ];
  var evilGameArr2 = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 3, 0, 8, 5],
    [0, 0, 1, 0, 2, 0, 0, 0, 0],
    [0, 0, 0, 5, 0, 7, 0, 0, 0],
    [0, 0, 4, 0, 0, 0, 1, 0, 0],
    [0, 9, 0, 0, 0, 0, 0, 0, 0],
    [5, 0, 0, 0, 0, 0, 0, 7, 3],
    [0, 0, 2, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 4, 0, 0, 0, 9]
  ];
  console.log("");
  console.log("Starting game - VERY EASY")
  print_board(veryeasyGameArr)
  console.log("");
  console.log("Completed solution")
  print_board(solve(veryeasyGameArr))
  console.log("");
  console.log("Starting game - EASY")
  print_board(easyGameArr)
  console.log("");
  console.log("Completed solution")
  print_board(solve(easyGameArr))
  console.log("");
  console.log("Starting game - MEDIUM")
  print_board(mediumGameArr)
  console.log("");
  console.log("Completed solution")
  print_board(solve(mediumGameArr))
  console.log("");
  console.log("Starting game - HARD")
  print_board(hardGameArr)
  console.log("");
  console.log("Completed solution")
  print_board(solve(hardGameArr))
  console.log("");
  console.log("Starting game - HARD #2")
  print_board(hardGameArr2)
  console.log("");
  console.log("Completed solution")
  print_board(solve(hardGameArr2))
  console.log("");
  console.log("Starting game - HARD #3")
  print_board(hardGameArr3)
  console.log("");
  console.log("Completed solution")
  print_board(solve(hardGameArr3))
  console.log("");
  console.log("Starting game - EVIL")
  print_board(evilGameArr)
  console.log("");
  console.log("Completed solution")
  print_board(solve(evilGameArr))
  console.log("");
  console.log("Starting game - EVIL #2")
  print_board(evilGameArr2)
  console.log("");
  console.log("Completed solution")
  print_board(solve(evilGameArr2))
}
function sudokuSampleToIndexMatrix(s, rows, cols) {
  if (isNumber(s)) s = String(s);
  let letters = toLetterArray(s);
  let nums = letters.map(x => Number(x));
  let res = [];
  for (const n of nums) {
    if (n === 0) res.push(' ');
    else res.push(n - 1);
  }
  let matrix = arrToMatrix(res, rows, cols);
  return matrix;
}
function sumProp(olist, prop) {
  let res = 0;
  for (const d of olist) {
    res += d[prop];
  }
  return res;
}
function suTest00() {
  let [rows, cols] = [4, 4];
  let pattern = getSudokuPattern(rows, cols);
  printMatrix(pattern, 'pattern');
  let colarrs = bGetCols(pattern); printMatrix(colarrs, 'transposed');
  let rowarrs = bGetCols(colarrs); printMatrix(rowarrs, 'normal');
  let cFlat = arrFlatten(rowarrs);
  let aRows = bGetRows(pattern);
  let rFlat = arrFlatten(aRows);
  console.assert(sameList(cFlat, rFlat), 'TRANSPOSE DOES NOT WORK!!!!!!!!!!!!!!!')
  let correct = checkSudokuRule(pattern);
}
function switch_uname(plname) {
  set_user(plname);
  show_username();
}
function switchPlayerArea() {
  if (G.previousPlayer) {
    let msPrevPlayerArea = getPlayerArea(G.previousPlayer);
    if (msPrevPlayerArea) {
      msPrevPlayerArea.hide();
    }
  }
  let msPlayerArea = getPlayerArea(G.player);
  if (msPlayerArea) {
    msPlayerArea.show();
  }
}
function symbolcolor(card, color) {
  let d = iDiv(card);
  let els = d.getElementsByTagName('symbol');
  console.log('list', els)
  for (const el of els) {
    let html = el.innerHTML;
    let html1 = replaceAll(html, 'red', color);
    let html2 = replaceAll(html1, 'black', color);
    el.innerHTML = html2;
  }
}
function symbolMeasuring() {
  clearElement('wrapper');
  dTable = mDiv(mBy('wrapper'), { position: 'absolute', padding: 10, bg: 'white', overflow: 'scroll' });
  let items = []; let n = SymKeys.length;
  for (let i = 0; i < n; i++) {
    let k = SymKeys[i];
    let info = Syms[k];
    let d = mDiv(dTable, { fz: 100, family: info.family, bg: 'random', display: 'inline' }, null, info.text);
    let item = { div: d, k: k, info: info };
    items.push(item);
  }
  setTimeout(() => symbolMeasuring2(items), 5000);
}
function symbolMeasuring2(items) {
  for (let i = 0; i < items.length; i++) {
    let item = items[i];
    let r = getRect(item.div);
    item.info.w = Math.round(r.w);
    item.info.h = Math.round(r.h);
  }
  let newDict = {};
  for (const item of items) {
    newDict[item.k] = item.info;
  }
  downloadAsYaml(newDict, 'syms');
}
function sync_users(php_users) {
  let result = [];
  let changed = false;
  for (const udata of php_users) {
    if (nundef(udata.id)) return php_users;
    let name = udata.username;
    let u = DB.users[name];
    if (nundef(u)) {
      changed = true;
      let db_user = { name: name, color: randomColor(), motto: random_motto(), image: startsWith(udata.image, name), games: {}, tables: {}, };
      add_new_user(db_user, false);
      result.push(db_user);
    } else result.push(u)
  }
  if (changed) db_save();
  if (!is_online()) return result;
  let di = {}; php_users.map(x => di[x.username] = x);
  let not_in_sql_db = [];
  for (const name in DB.users) {
    let u = DB.users[name];
    if (nundef(di[name]) && name != Session.cur_user) { not_in_sql_db.push(name); addIf(result, u); }
  }
  if (!isEmpty(not_in_sql_db)) add_users_to_sql_db(not_in_sql_db);
  return result;
}
function sysColor(iPalette, ipal) { return S.pals[iPalette][ipal]; }
function t0_textarea() {
  dTable = mBy('dTable'); mCenterFlex(dTable);
  mDiv(dTable, { w: '100%' }, null, 'Enter Code:');
  let d = mTextArea(25, 120, dTable, { fz: 16, margin: 'auto', padding: 10, outline: 'none', border: 'none' }, 'dCode');
  let dButtons = mDiv(dTable, { display: 'flex', w: '100%' });
  let asave = mLink("javascript:void(0)", dButtons, {}, null, 'Save Code', 'a');
  asave.onclick = db_add_code;
  let aclear = mLink("javascript:void(0)", dButtons, {}, null, 'Clear Code', 'a');
  aclear.onclick = () => console.log('click clear code!');
}
async function t00_makeWordProblemsDict() { let wp = await makeWordProblemsDict(); }
async function t00_oldTests() {
}
async function t00_timitTests() {
  timit.show('*'); console.assert(isdef(DB));
  timit.show('DONE')
}
async function t00_wpInstantiate() {
  let wp = await route_path_yaml_dict('../assets/math/allWP.yaml');
  let p = firstCond(wp, x => x.index == 40);
  instantiateWP(p);
}
function t01() {
  showPictureGrid(['cockroach'], dTable)
}
function t01_fractions() {
  console.log(math.add(math.fraction(0.1), math.fraction(0.2)))
  console.log(math.divide(math.fraction(0.3), math.fraction(0.2)))
  console.log(math.subtract(math.fraction(0.1), math.fraction(0.2)))
}
function t01_getTextForFraction() { mText('you have 5 ' + getTextForFraction(1, 2) + ' muffins', dTable, { fz: 100 }); }
function t01_numbers() {
  var array1 = [0, 1, 2];
  var array2 = [3, 4, 5];
  let x = numbers.matrix.addition(array1, array2);
  console.log(x);
  numbers.matrix.transpose(x);
  console.log(numbers.prime.simple(171));
}
function t1() {
  let a1 = { type: 1 };
  let a2 = { type: 2 };
  let a3 = { type: 3 };
  let a = {
    tic: {
      actions:
      {
        _set:
          [{ _tuple: [{ _set: [a1, a2, a3] }] }]
      }
    }
  };
}
function t2(act) {
  let res = [];
  for (const key in act) {
    let data = act[key].actions;
    let e = exp(data);
    res.push(e)
  }
  return res;
}
function table_options_to_game_options(t) {
  console.log('t', t);
  let settings = { game: {} };
  copyKeys(t.options, settings.game);
  return settings;
}
function table_shield_off() {
  if (isdef(dTableShield)) { dTableShield.remove(); dTableShield = null; }
}
function table_shield_on() {
  if (nundef(dTableShield)) {
    dTableShield = mDiv(dTable, { position: 'absolute', bg: '#0000ff80', w: '100%', h: '100%' });
    dTableShield.style.zIndex = 1000;
  }
}
function tableDimensions(w, h) {
  setCSSVariable('--wGame', '' + w + 'px');
  setCSSVariable('--hGame', '' + h + 'px');
  return { w: w, h: h };
}
function tableElem(o, keys) {
  let t = document.createElement('table');
  t.classList.add('tttable');
  let s = '';
  for (const k in o) {
    if (isdef(keys) && !keys.includes(k)) continue;
    s += '<tr><th>' + k + '</th><td>';
    let val = o[k];
    let sval = null;
    if (isListOf_Obj(val)) {
      sval = `<div class='up10 hallo'>${val.map(x => !x ? '_' : x._obj).toString()}</div>`;
    } else if (val && isDict(val) && '_obj' in val) {
      sval = `<div class='up10 hallo'>${val._obj.toString()}</div>`;
    }
    if (!sval) sval = isSet(val) ? empty(val._set) ? '{ }' : simpleRep(val) : isDict(val) ? tableHTML(val, 4) : simpleRep(val);
    s += sval + '</td>';
  }
  t.innerHTML = s;
  return t;
}
function tableElemX(o, keys) {
  let t = document.createElement('table');
  t.classList.add('tttable');
  let refs = [];
  let s = '';
  for (const k in o) {
    if (isdef(keys) && !keys.includes(k)) continue;
    s += '<tr><th>' + k + '</th><td>';
    let sval = transformToString(k, o[k], refs);
    s += sval + '</td>';
  }
  t.innerHTML = s;
  return { table: t, refs: refs };
}
function tableElemY(o, keys) {
  let t = document.createElement('table');
  t.classList.add('tttable');
  let refs = [];
  let s = '';
  for (const k in o) {
    if (isdef(keys) && !keys.includes(k)) continue;
    s += '<tr><th>' + k + '</th><td>';
    let val = o[k];
    let sval = null;
    if (isListOf(val, '_obj')) {
      let cl = 't_r_' + getUID(); let ref = { oids: val.filter(x => isdef(x)).map(x => x._obj), id: cl }; refs.push(ref);
      sval = `<div id=${cl} class='up10 hallo'>${val.map(x => !x ? '_' : x._obj).toString()}</div>`;
    } else if (val && isDict(val) && '_obj' in val) {
      let cl = 't_r_' + getUID(); let ref = { oids: [val._obj], id: cl }; refs.push(ref);
      sval = `<div id=${cl} class='up10 hallo'>${val._obj.toString()}</div>`;
    } else if (val && isDict(val) && '_ndarray' in val) {
      let rows = val._ndarray;
      sval = `<div>`;
      let rowClass = 'up2 hallo';
      for (const row of rows) {
        let cl = 't_r_' + getUID(); let ref = { oids: row.filter(x => isdef(x)).map(x => x._obj), id: cl }; refs.push(ref);
        sval += `<div id=${cl} class='${rowClass}'>${row.map(x => !x ? '_' : x._obj).toString()}</div><br>`;
        rowClass = 'hallo';
      }
      sval += '</div>';
    } else if (val && isDict(val) && '_player' in val) {
      let cl = 'p_r_' + getUID(); let ref = { oids: [val._player], id: cl }; refs.push(ref);
      sval = `<div id=${cl} class='up10 hallo'>${val._player.toString()}</div>`;
    }
    if (!sval) {
      sval = isSet(val) ? empty(val._set) ? '{ }' : simpleRep(val) : isDict(val) ? tableHTMLY(val, refs) : simpleRep(val);
    }
    s += sval + '</td>';
  }
  t.innerHTML = s;
  return { table: t, refs: refs };
}
function tableHTML(o) {
  let s = '<table class="tttable up10">';
  for (const k in o) {
    s += '<tr><th>' + k + '</th><td>';
    let val = o[k];
    let sval = null;
    if (isListOf_Obj(val)) sval = `<div class='up10 hallo'>${val.map(x => !x ? '_' : x._obj).toString()}</div>`;
    else if (val && isDict(val) && '_obj' in val) sval = `<div class='up10 hallo'>${val._obj.toString()}</div>`;
    if (!sval) sval = isSet(val) ? empty(val._set) ? '{ }' : simpleRep(val) : isDict(val) ? tableHTML(val) : simpleRep(val);
    s += sval + '</td>';
  }
  s += '</table>';
  return s;
}
function tableHTMLX(o, refs) {
  let s = '<table class="tttable up10">';
  for (const k in o) {
    s += '<tr><th>' + k + '</th><td>';
    let sval = transformToString(k, o[k], refs);
    s += sval + '</td>';
  }
  s += '</table>';
  return s;
}
function tableHTMLY(o, refs) {
  let s = '<table class="tttable up10">';
  for (const k in o) {
    s += '<tr><th>' + k + '</th><td>';
    let val = o[k];
    let sval = null;
    if (isListOf_Obj(val)) {
      let cl = 't_r_' + getUID(); let ref = { oids: val.filter(x => isdef(x)).map(x => x._obj), id: cl }; refs.push(ref);
      sval = `<div class='up10 hallo'>${val.map(x => !x ? '_' : x._obj).toString()}</div>`;
    } else if (val && isDict(val) && '_obj' in val) {
      let cl = 't_r_' + getUID(); let ref = { oids: [val._obj], id: cl }; refs.push(ref);
      sval = `<div class='up10 hallo'>${val._obj.toString()}</div>`;
    }
    if (!sval) sval = isSet(val) ? empty(val._set) ? '{ }' : simpleRep(val) : isDict(val) ? tableHTMLY(val, refs) : simpleRep(val);
    s += sval + '</td>';
  }
  s += '</table>';
  return s;
}
function tableLayoutMR(dParent, m = 7, r = 1) {
  let ui = UI; ui.players = {};
  clearElement(dParent);
  let bg = 'transparent';
  let [dMiddle, dRechts] = [ui.dMiddle, ui.dRechts] = mColFlex(dParent, [m, r], [bg, bg]);
  mCenterFlex(dMiddle, false);
  let dOben = ui.dOben = mDiv(dMiddle, { w: '100%', display: 'block' }, 'dOben');
  let dSelections = ui.dSelections = mDiv(dOben, {}, 'dSelections');
  for (let i = 0; i <= 5; i++) { ui[`dSelections${i}`] = mDiv(dSelections, {}, `dSelections${i}`); }
  let dActions = ui.dActions = mDiv(dOben, { w: '100%' });
  for (let i = 0; i <= 5; i++) { ui[`dActions${i}`] = mDiv(dActions, { w: '100%' }, `dActions${i}`); }
  ui.dError = mDiv(dOben, { w: '100%', bg: 'red', fg: 'yellow', hpadding: 12, box: true }, 'dError');
  let dSubmitOrRestart = ui.dSubmitOrRestart = mDiv(dOben, { w: '100%' });
  let dOpenTable = ui.dOpenTable = mDiv(dMiddle, { w: '100%', padding: 10 }); mFlexWrap(dOpenTable);
  return [dOben, dOpenTable, dMiddle, dRechts];
}
function take_feedback_host(write_fen = true, write_player = false, clear_players = false, player_status = null) {
  prep_move();
  let o = { uname: Z.uplayer, friendly: Z.friendly };
  if (isdef(Z.fen)) o.fen = Z.fen;
  if (write_fen) { assertion(isdef(Z.fen) && isdef(Z.fen.turn), 'write_fen without fen!!!!'); o.write_fen = true; }
  if (write_player) { o.write_player = true; o.state = Z.state; }
  if (clear_players) o.clear_players = true;
  o.player_status = player_status;
  o.auto = true;
  let cmd = 'table';
  send_or_sim(o, cmd);
}
function take_turn(write_fen = true, write_player = false, clear_players = false, player_status = null) {
  prep_move();
  let o = { uname: Z.uplayer, friendly: Z.friendly };
  if (isdef(Z.fen)) o.fen = Z.fen;
  if (write_fen) { assertion(isdef(Z.fen) && isdef(Z.fen.turn), 'write_fen without fen!!!!'); o.write_fen = true; }
  if (write_player) { o.write_player = true; o.state = Z.state; }
  if (clear_players) o.clear_players = true;
  o.player_status = player_status;
  let cmd = 'table';
  send_or_sim(o, cmd);
}
function take_turn_ack() {
  prep_move();
  let o = { uname: Z.uplayer, friendly: Z.friendly, fen: Z.fen, state: { ack: true }, write_player: true };
  let cmd = 'table';
  send_or_sim(o, cmd);
}
function take_turn_clear() {
  prep_move();
  let o = { uname: Z.uplayer, friendly: Z.friendly, fen: Z.fen, players: Z.playerlist };
  let cmd = 'clear';
  send_or_sim(o, cmd);
}
function take_turn_collect_open() {
  prep_move();
  let o = { uname: Z.uplayer, friendly: Z.friendly, fen: Z.fen, state: Z.state, write_player: true };
  let cmd = 'table';
  send_or_sim(o, cmd);
}
function take_turn_fen() { take_turn(); }
function take_turn_fen_clear() { take_turn(true, false, true); }
function take_turn_fen_write() { take_turn(true, true); }
function take_turn_multi() { if (isdef(Z.state)) take_turn(false, true); else take_turn(false, false); }
function take_turn_resolve(notes) {
  prep_move();
  let o = { uname: Z.uplayer, friendly: Z.friendly, fen: Z.fen, write_fen: true, write_notes: notes };
  let cmd = 'table';
  send_or_sim(o, cmd);
}
function take_turn_spotit() { take_turn(true, true); }
function take_turn_waiting() { take_turn(true, false, false, null); }
function take_turn_write() { take_turn_multi(); }
function takeFromStart(ad, n) {
  if (isDict(ad)) {
    let keys = Object.keys(ad);
    return keys.slice(0, n).map(x => (ad[x]));
  } else return ad.slice(0, n);
}
function takeFromTo(ad, from, to) {
  if (isDict(ad)) {
    let keys = Object.keys(ad);
    return keys.slice(from, to).map(x => (ad[x]));
  } else return ad.slice(from, to);
}
function TakeMove() {
  brd_hisPly--;
  brd_ply--;
  var move = brd_history[brd_hisPly].move;
  var from = FROMSQ(move);
  var to = TOSQ(move);
  if (brd_enPas != SQUARES.NO_SQ) HASH_EP();
  HASH_CA();
  brd_castlePerm = brd_history[brd_hisPly].castlePerm;
  brd_fiftyMove = brd_history[brd_hisPly].fiftyMove;
  brd_enPas = brd_history[brd_hisPly].enPas;
  if (brd_enPas != SQUARES.NO_SQ) HASH_EP();
  HASH_CA();
  brd_side ^= 1;
  HASH_SIDE();
  if ((MFLAGEP & move) != 0) {
    if (brd_side == COLOURS.WHITE) {
      AddPiece(to - 10, PIECES.bP);
    } else {
      AddPiece(to + 10, PIECES.wP);
    }
  } else if ((MFLAGCA & move) != 0) {
    switch (to) {
      case SQUARES.C1: MovePiece(SQUARES.D1, SQUARES.A1); break;
      case SQUARES.C8: MovePiece(SQUARES.D8, SQUARES.A8); break;
      case SQUARES.G1: MovePiece(SQUARES.F1, SQUARES.H1); break;
      case SQUARES.G8: MovePiece(SQUARES.F8, SQUARES.H8); break;
      default: break;
    }
  }
  MovePiece(to, from);
  var captured = CAPTURED(move);
  if (captured != PIECES.EMPTY) {
    AddPiece(to, captured);
  }
  if (PROMOTED(move) != PIECES.EMPTY) {
    ClearPiece(from);
    AddPiece(from, (PieceCol[PROMOTED(move)] == COLOURS.WHITE ? PIECES.wP : PIECES.bP));
  }
}
function takeYourSeats() {
  Zones = {};
  if (T.numPlayers == 2) {
    Zones[T.players[0].id] = createPlayerZone(T.players[0]);
    mLinebreak(dTable);
    Zones.table = createTableZone(true);
    mLinebreak(dTable);
    Zones[T.players[1].id] = createPlayerZone(T.players[1], 'bottom');
  }
}
function test() {
  for (i = 0; i < 10; i++) {
    circles += 1;
    createcircle((i * w / 10), "50%", "100", "0", "hsla(" + (i * 36) + ",100%,50%,0.5)", "url(#f" + circles + ")"); createfilter("-50%", "-50%", "200%", "200%", ["feGaussianBlur"], ["stdDeviation", "5"]);
  }
}
function test_1() {
  deck.mount(d);
}
function test_add_building() {
  let [A, fen, uname] = [Z.A, Z.fen, Z.uname];
  let type = rChoose(['farm', 'estate', 'chateau']);
  add_a_correct_building_to(fen, uname, type);
  take_turn_fen();
}
function test_add_schwein() {
  let [A, fen, uname] = [Z.A, Z.fen, Z.uname];
  let type = rChoose(['farm', 'estate', 'chateau']);
  let keys = deck_deal(fen.deck, type[0] == 'f' ? 4 : type[0] == 'e' ? 5 : 6);
  fen.players[uname].buildings[type].push({ list: keys, h: null });
  take_turn_fen();
}
function test_endgame() {
  let [A, fen, uname] = [Z.A, Z.fen, Z.uname];
  fen.actionsCompleted = [];
  for (const plname of fen.plorder) {
    add_a_correct_building_to(fen, plname, 'chateau');
    add_a_correct_building_to(fen, plname, rChoose(['farm', 'estate', 'chateau']));
    if (coin()) add_a_correct_building_to(fen, plname, rChoose(['farm', 'estate', 'chateau']));
    fen.actionsCompleted.push(plname);
  }
  Z.stage = 5;
  Z.phase = 'king';
  take_turn_fen();
}
function test_engine_run_next(list) {
  if (nundef(list)) {
    list = TestList = arrRange(100, TestNumber - 1);
  }
  if (isEmpty(list)) {
    console.log('*** all tests finished ***');
    TestSuiteRunning = TestRunning = false;
    shield_off();
    return;
  }
  let n = list.shift();
  ITER = 0;
  onclick_ut_n('ari', n);
}
function test_ferro_goal_sorting() {
  let av = ['7R', '3', '5', '33'];
  av = ['33', '3', '5', '4'];
  av.sort((a, b) => Z.fen.allGoals.indexOf(a) - Z.fen.allGoals.indexOf(b));
  return av;
}
function test_ferro_is_set() {
  let cards = ['9Sn', '7Sn', '8Sn', '9Sn'].map(x => fritz_get_card(x));
  let set = ferro_is_set(cards, 1, 3);
  console.log(set);
}
function test_formula0() {
  let fi = nerdamer(`integrate(formula1(x),x)`).buildFunction();
  let y = fi(100);
  console.log('')
  let f = x => formula0(x, 100, 115);
  let sum = 0;
  for (let x = 100; x <= 145; x++) {
    let y = formula0(x, 100, 15);
    sum += y;
    console.log('x', x, 'y', Math.round(y * 100), Math.round(sum));
  }
}
function test_mNode0() {
  console.log('liste', [1, 2, 3].toString());
  let o = dixit_setup(['felix', 'amanda', 'mimi']);
  console.log('o', o);
  recConvertLists(o);
  console.log('converted', o);
  mNode(o, mBy('inpre'), 'setup');
  inpost.innerHTML = jsonToYaml(o)
}
function test_skip_to_actions() {
  let [A, fen, uname] = [Z.A, Z.fen, Z.uname];
  Z.phase = 'king';
  Z.stage = 5;
  fen.actionsCompleted = [];
  let i = arrMinMax(fen.plorder, x => fen.players[x].hand.length).imin;
  let pl_min_hand = fen.plorder[i];
  console.log('pl w/ min hand is', pl_min_hand);
  let pl = fen.players[pl_min_hand];
  pl.hand = pl.hand.concat(fen.market);
  fen.market = deck_deal(fen.deck, 2);
  for (const plname of fen.plorder) {
    pl = fen.players[plname];
    let n = rNumber(1, pl.hand.length);
    pl.stall = pl.hand.splice(0, n);
  }
  Z.turn = [fen.plorder[rNumber(0, fen.plorder.length - 1)]];
  fen.total_pl_actions = fen.num_actions = fen.players[Z.turn[0]].stall.length;
  fen.action_number = 1;
  take_turn_fen();
}
function test_skip_to_tax() {
  let [A, fen, uname] = [Z.A, Z.fen, Z.uname];
  Z.phase = 'jack';
  Z.stage = 5;
  let iturn = fen.plorder.length - 1;
  Z.turn = [fen.plorder[iturn]];
  fen.actionsCompleted = fen.plorder.slice(0, iturn);
  console.log('fen.actionsCompleted', fen.actionsCompleted);
  for (const plname in fen.players) {
    let pl = fen.players[plname];
    pl.hand = pl.hand.concat(deck_deal(fen.deck, rNumber(0, 5)));
  }
  take_turn_fen();
}
function test_start_aristo(n = 3, mode = 'multi') {
  let game = 'aristo';
  let playernames = arrTake(['mimi', 'felix', 'amanda', 'lauren', 'gul', 'nasi'], n);
  let playmodes = ['human', 'human', 'human', 'human', 'human', 'human'];
  let strategies = ['random', 'random', 'random', 'random', 'random', 'random', 'random'];
  let i = 0; let players = playernames.map(x => ({ name: x, strategy: strategies[i], playmode: playmodes[i++] }));
  let options = { mode: mode, commission: 'no' };
  start_game(game, players, options);
}
function test_start_ferro(mode = 'multi') {
  let game = 'ferro';
  let playernames = ['mimi', 'lauren', 'felix'];
  let playmodes = ['human', 'human', 'human'];
  let strategies = ['random', 'random', 'random'];
  let i = 0; let players = playernames.map(x => ({ name: x, strategy: strategies[i], playmode: playmodes[i++] }));
  let options = { mode: mode, thinking_time: 20 };
  start_game(game, players, options);
}
async function test_start_test_user_endscreen() {
  console.log('na geh');
  let fen = "felix:20,amanda:14,mimi:13,gul:12";
  DB = await route_path_yaml_dict('./DB.yaml');
  console.log('DB', DB);
  present_non_admin_user('gul');
}
function test_timestep_js_vs_php() {
  console.log('js', get_timestamp());
  to_server({}, 'timestamp_test');
}
function test0() {
  dTable.onclick = game_add_default_item;
}
function test0_ari_flip_one_card() {
  let c = ari_get_card('QHo');
  mAppend(dTable, iDiv(c));
  face_down(c);
  iDiv(c).onclick = () => anim_toggle_face(c);
}
function test0_aristo_setup() {
  let g = { func: aristo(), options: get_default_options('aristo') };
  g.fen = g.func.setup(['felix', 'mimi'], {});
  console.log('fen', g.fen);
}
function test0_boa_bw_fa() {
  let d = mDiv('dHome', { w: 200, h: 200, bg: 'red' }, 'd', `<i class="fa fa-car"></i>`);
  d.onclick = () => toggle_bw_symbol(d.firstChild);
}
function test0_canvas_overlay() {
  let pin = canvas_overlay();
  let f = x => x + rGaussian(-.01, .04);
  run_for_seconds(2, () => map_moveby(pin, f, f))
}
function test0_car_nomath() {
  C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop);
  C.add({ w: 30, h: 25, color: 'red', draw: draw_car, update: update_car, turn_inc: 10, v: { a: 280, mag: 5 } });
  C.add({ x: 30, y: -100, color: 'green', w: 35, h: 25, draw: draw_car, update: update_car, v: { a: 0, mag: 3 } });
  C.draw();
}
function test0_divRestOfPage() {
  console.log('DB', DB);
  console.log('C52', C52);
  let state = DB.tables.t0;
  console.log('state', state);
  var dMain = document.getElementById('dMain');
  let dMenu = mDiv(dMain, { bg: 'blue' }, null, '<span>hallo</span>');
  let bMenu = mButton(UnicodeSymbols.menu, null, null, null, 'mybutton');
  mInsertFirst(dMenu, bMenu);
  let dRest = mDivRestOfPage(dMain, dMenu);
  let bTest = mButton('test', () => mSize(dMenu, 20, 80, '%'), dMenu, null, 'mybutton');
}
function test0_load_user() {
  let user = load_user(queryStringToJson().user);
}
function test0_nerd() {
  var core = nerdamer.getCore();
  var _ = core.PARSER;
  core.Math2.custom = function (x) { return (100 * formula1(x)).toFixed(4); };
  _.functions.custom = [, 1];
  var x = nerdamer('custom(140)').evaluate();
  console.log(x.toString());
}
function test0_orig() {
  var map = L.map('map');
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);
  L.Routing.control({
    waypoints: [
      L.latLng(57.74, 11.94),
      L.latLng(57.6792, 11.949)
    ],
    routeWhileDragging: true
  }).addTo(map);
}
function test0_random() {
  let n = rNumber(12, 20);
  console.log('n', n)
}
function test0_show_all_inno_cards() {
  clearElement(dTable);
  for (const k in InnoById) {
    let ci = InnoById[k];
    console.log('ci', ci);
    if (ci.exp[0] == 'F') inno_present_card(dTable, k);
  }
}
async function test0_simulateClick() {
  let info = await route_path_yaml_dict('../base/assets/lists/info.yaml');
  downloadAsYaml(info, 'info');
}
function test0_turn_loader_off() {
  mClassReplace(mBy('loader_holder'), 'loader_off');
}
async function test00() {
  set_run_state_no_server(); 
  onpagedeactivated(() => { fiddleSave(); dbSave(); });
  await load_syms(); 
  await load_db(); 
  let dicode = CODE.di = await route_path_yaml_dict('../basejs/z_all.yaml');
  let dijustcode = CODE.justcode = await route_path_yaml_dict('../basejs/z_allcode.yaml');
  let dihistory = CODE.history = await route_path_yaml_dict('../basejs/z_allhistory.yaml');
  dTable = mSection({ h: window.innerHeight - 68 }, 'dTable');
  fiddleInit();
  show_sidebar(sortCaseInsensitive(get_keys(dicode.func)), onclickCodeInSidebar);
  onclickCodeInSidebar('mAutocomplete')
}
function test00_div_mit_sidebar() {
  let dMain = mBy('dMain');
  mStyleX(dMain, { h: '100%', w: '100%', box: true, bg: 'silver', padding: 10 });
  let d = mDiv100(dMain, { bg: 'blue', position: 'relative', });
  let d1 = mDiv(d, { h: '100%', w: 100, position: 'absolute', z: 1, top: 0, left: 0, overflow: 'hidden', transition: '0.5s' }, null, 'hallo', ['w3-blue']);
  let d2 = mDiv(d, { maleft: 100, h: '100%', box: true, transition: '0.5s' }, null, null, ['w3-orange'])
  d2.onclick = () => {
    mToggle(d1, 'width', 0, 100); mToggle(d2, 'margin-left', 0, 100);
  }
}
function test0000000() {
  return 4;
}
function test01() {
  UIS.a_d_game.elem.style.textAlign = 'center';
  let svg = new MMS({ parent: UIS.a_d_game, type: 'svg' }).setDefaults().attach();
  let g = new MMS({ parent: svg, type: 'g' }).attach();
  addManualCircle(g);
}
function test01_modifyUser() {
  lookupAddToList(U, ['games', 'gAristocracy', 'running'], 2);
  changeUserTo('mia');
}
function test01_one_deck() {
  let d1 = document.createElement('div');
  d1.id = 'myContainer';
  document.body.appendChild(d1);
  var d = d1;
  let deck = createDeckWithJokers();
  attachTo(d, deck);
}
function test01_show_w3colors() {
  let dMain = mBy('dMain');
  mCenterCenterFlex(dMain);
  for (const c of [wblue, wred, worange, wgreen, wamber, wyellow, wbrown]) {
    let d = mDiv(dMain, { w: 100, h: 100, bg: c, margin: 10 });
  }
}
function test02() {
  let code = AU.ta.value;
  let disub = computeClosure(code);
  let keys = {};
  for (const type in disub) {
    let klist = sortCaseInsensitive(get_keys(disub[type]));
    klist.map(x => keys[x] = disub[type][x]);
  }
  CODE.lastClosure = disub;
  CODE.closureKeys = keys;
  let ksorted = [];
  for (const k of CODE.keysSorted) {
    if (isdef(CODE.closureKeys[k])) ksorted.push(k);
  }
  CODE.closureKeysSorted = ksorted;
}
function test02_div_mit_sidebar() {
  let dMain = mBy('dMain');
  mStyleX(dMain, { h: '100%', w: '100%', box: true, bg: 'silver', padding: 10 });
  let d = mDiv100(dMain, { position: 'relative', });
  let d1 = mDiv(d, { bg: wdeeporange });
  let d2 = mDiv(d, { bg: worange });
  makeSidebar00(d, d1, d2);
}
function test02_grid_rxc() {
  let d = addGridToBody(8, 8);
  d.style.setProperty('height', '50%')
}
function test02_show4Decks() {
  let hand = G.instance.players[0].hand.getIndices();
  console.log(hand)
  showCards52(hand, 'down');
  showCards52(hand);
  showCards52(hand, 'up');
  showCards52(hand, 'left');
  mLinebreak(dTable);
}
function test02_showCard() {
  G.instance.players[0].hand.map(x => Card52.show(x, dTable));
  mLinebreak(dTable, 25);
  G.instance.players[1].hand.map(x => Card52.show(x, dTable));
}
function test02_showDeckFaceDown() {
  let hand = G.instance.players[0].hand;
  hand.showDeck(dTable);
  console.log(hand[0].faceUp)
  hand.turnFaceDown();
}
function test02_turnCard() {
  let pl = G.instance.players[0];
  let card = pl.hand.topCard();
  console.log(card);
  Card52.show(card, dTable);
  setTimeout(() => Card52.turnFaceDown(card), 1000)
  setTimeout(() => Card52.turnFaceUp(card), 2000)
}
function test02_turnDeckFaceDown() {
  let hand = G.instance.players[0].hand;
  showCards52(hand, 'down');
  console.log(hand[0].faceUp)
  hand.turnFaceDown();
}
function test03() {
  if (nundef(CODE.closureKeysSorted)) test1();
  console.log('closure', CODE.closureKeysSorted);
  let text = CODE.closureKeysSorted.map(x => CODE.justcode[x]).join('\r\n');
  downloadAsText(text, 'hallo', 'js');
}
function test03_2Hands() {
  let h1 = iMakeHand([0, 1, 2, 3, 4], 'h1');
  let h2 = iMakeHand([13, 14, 15, 16, 17], 'h2');
  setTimeout(test03_2Hands_transferStarts, 1000);
}
function test03_2Hands_transfer() {
  let deck1 = Daat.h1.deck;
  let deck2 = Daat.h2.deck;
  let item = Daat.item;
  deck1.addTop(item.val);
  deck2.remove(item.val);
  iPresentHand(Daat.h1);
  iPresentHand(Daat.h2);
  iSortHand(Daat.h1)
}
function test03_2Hands_transferStarts() {
  let h1 = Daat.h1.iHand;
  let n1 = h1.items.length;
  let h2 = Daat.h2.iHand;
  let n2 = h2.items.length;
  let c = chooseRandom(h2.items);
  Daat.item = c;
  let w = c.w;
  let ov = w / 4;
  let xOffset = n1 * ov;
  iMoveFromTo(c, h2.div, h1.div, test03_2Hands_transfer, { x: xOffset, y: 0 });
}
function test03_2HandsRandom() {
  let h1 = iMakeHand([0, 1, 2, 3, 4], 'h1');
  let h2 = iMakeHand([13, 14, 15, 16, 17], 'h2');
  setTimeout(test03_2Hands_transferStarts, 1000);
}
function test03_addCard() {
  let h = Daat.hand;
  let n = h.count();
  console.log('hand has', n, 'cards');
  let c = Daat.item;
  let w = c.w;
  let ov = w / 4;
  let xOffset = n * ov;
  iMoveFromTo(Daat.item, Daat.item.div.parentNode, Daat.zone, transferElement, { x: xOffset, y: 0 });
}
function test03_addToZone() {
  let items = i52([3, 13, 23]);
  let z1 = mZone(dTable);
  iAppend(z1, items[0]);
  iStyle(z1, { padding: 20, box: true });
  let item2 = i52(20);
  iAppend(z1, item2)
  iCenter(item2, -25, 0);
  return;
  let iHand = iSplay(items, z1.div, null, 'right', 20, '%', false, false);
  console.log(iHand);
  mStyleX(iHand.div, { padding: 20, rounding: 10, bg: 'pink' });
}
function test03_basics() {
  let b = getBounds(dTable); console.log(b.width, b.height); mStyleX(dTable, { bg: 'red' });
  let deck = range(0, 51).map(x => i52(x));
  iResize52(deck, 40);
  iSplay(deck, dTable)
  mLinebreak(dTable, 10);
  let d = mCanvas(dTable);
  let item = iAppend52(13, d);
  mRot(item.div, 45);
  mLinebreak(dTable, 10);
}
function test03_centerToCenter() {
  let styles = { w: 200, h: 200, bg: 'random' };
  mStyleX(dTable, { bg: 'yellow' });
  let z1 = mZone(dTable, styles); z1.id = 'z1';
  mLinebreak(dTable, 10);
  let z2 = mZone(dTable, styles); z2.id = 'z2';
  let item1 = iAppend52(24, z1);
  let di1 = item1.div;
  mCenterAbs(di1);
  let item2 = iAppend52(28, z2);
  let di2 = item2.div;
  mCenterAbs(di2);
  console.log(di1.parentNode)
  iMoveFromTo(item2, z2, z1);
  setTimeout(() => iMoveFromTo(item1, z1, z2), 1000);
  setTimeout(() => iMoveFromTo(item2, z1, z2), 2000);
}
function test03_centerToCenter_trial1() {
  let z1 = mZone(dTable); z1.id = 'z1';
  mLinebreak(dTable, 10);
  let item = iAppend52(24, z1);
  let di = item.div;
  mCenterAbs(di);
  return;
  let z2 = mZone(dTable); z2.id = 'z2';
  let item2 = iAppend52(28, z2);
  let di2 = item2.div;
  mCenter(di2);
  console.log(di.parentNode)
  di.onclick = moveFromTo(item2, z2, z1);
}
function test03_div_mit_sidebar() {
  let dMain = mBy('dMain');
  mStyleX(dMain, { h: '100%', w: '100%', box: true, bg: 'silver', padding: 10 });
  let d = mDiv100(dMain, { position: 'relative', });
  let d1 = mDiv(d, { bg: wdeeporange });
  let d2 = mDiv(d, { bg: worange });
  let sb = iSidebar01(d, d1, d2, d2, 200);
  sb.fToggle();
}
function test03_grid_whrc() {
  let d1 = addDivToBody(100, 50, '%')
  addGridTo(d1, 8, 8);
}
function test03_habenItemsEinZNachSplay() {
  let items = i52([3, 13, 23]);
  console.log(items)
  console.log(items[0].z);
  iSplay(items, dTable);
  console.log(items[0].z);
}
function test03_komischeBubbles() {
  let dover = mDover(dTable); mStyleX(dover, { bg: '#00000080' });
  item = i52(25);
  item.div = mText('hallo', dover, { padding: 25 });
  container = dover;
  mClass(container, 'container');
  mClass(item.div, 'bubble2')
  item.div.style.setProperty('--xStart', '0px');
  item.div.style.setProperty('--xEnd', '100px');
  item.div.style.setProperty('--yStart', '0px');
  item.div.style.setProperty('--yEnd', '-100px');
  dTable.addEventListener("mousemove", updateBubbleColors);
}
function test03_left() {
  let d = mDover(dTable);
  let item = iAppend52(13, d);
  item.div.animate([
    { position: 'absolute', left: '0px', top: '0px' },
    { position: 'absolute', left: '220px', top: '110px' },
  ], {
    duration: 500,
    fill: 'forwards',
  });
}
function test03_richtungCenter() {
  let d = mDover(dTable);
  let item = iAppend52(13, d);
  let di = item.div;
  di.style.position = 'absolute';
  let parent = d;
  let tablePos = getBounds(di, false, dTable);
  console.log('tablePos', tablePos.x, tablePos.y);
  mLinebreak(dTable, 100)
  let dParent = mDiv(dTable, { w: 200, h: 200, bg: 'yellow' });
  let center = actualCenter(dParent, false, dTable);
  let b = getBounds(dParent, false, dTable);
  console.log('center of yellow', center.x, center.y, b)
  let offset = { w: 35, h: 55 };
  center.x -= offset.w;
  center.y -= offset.h;
  item.div.animate([
    { position: 'absolute', left: '0px', top: '0px' },
    { position: 'absolute', left: '' + center.x + 'px', top: center.y + 'px' },
  ], {
    duration: 500,
    fill: 'forwards',
  });
}
function test03_rotate() {
  let d = mCanvas(dTable);
  let item = iAppend52(13, d);
  item.div.animate([
    { transform: 'rotate(90deg)' },
  ], {
    duration: 500,
  });
}
function test03_sortDeck() {
  let h1 = iMakeHand([7, 10, 21, 2, 43, 4], 'h1');
  iSortHand(h1);
}
function test03_splayHand() {
  let h = Daat.hand = new Deck();
  h.init([3, 4, 5, 6, 13, 23]);
  console.log(h); let cards = h.cards(); console.log(cards);
  let zHand = Daat.zone = iHandZone();
  let items = i52(h.cards());
  let handItem = Daat.iHand = iSplay(items, zHand);
  let z = iHandZone();
  let item = Daat.item = iAppend52(18, z);
  console.log('Daat', Daat)
  setTimeout(test03_addCard, 1000);
}
function test03_translate() {
  let d = mCanvas(dTable);
  let item = iAppend52(13, d);
  item.div.animate([
    { transform: 'translate(0px,0px)' },
    { transform: 'translate(300px,200px)' }
  ], {
    duration: 500,
    iterations: Infinity,
    direction: 'alternate'
  });
}
function test03_trash() {
  let dover = mDover(dTable); mStyleX(dover, { bg: 'pink' });
  b = getBounds(dover); console.log('dover', b.width, b.height);
  mRemoveStyle(dover, ['background-color']);
  item = i52(35);
  mAppend(item.div, dover);
  anim1(item.div, 'left', 0, 200, 1000);
}
function test04() {
  dTable = mSection({ h: window.innerHeight - 68 }, 'dTable');
  dSearch = mSection({}, 'dSearch'); mInputLineWithButtons(dSearch, { Go: fiddleSearch }, 'grid');
  show_sidebar(sortCaseInsensitive(get_keys(CODE.di.func)), onclickCodeInSidebar);
  onclickCodeInSidebar(rChoose(CODE.keylist)); //'mAutocomplete')
}
function test04_div_mit_sidebar() {
  let dMain = mBy('dMain');
  mStyleX(dMain, { h: '100%', w: '100%', box: true, bg: 'silver', padding: 10 });
  let d = mDiv100(dMain, { position: 'relative', });
  let d1 = mDiv(d, { bg: wdeeporange });
  let d2 = mDiv(d, { bg: worange });
  let sb = iSidebar04(d, d1, d2, d2, 50);
  sb.addContent('wwwwwwwwwwwwwwwwwwwwwwwwww');
  sb.toggle();
  sb.addContent('s');
  sb.toggle();
}
function test04_grid9_whrc() {
  let d1 = addDivToBody(100, 50, '%')
  let cells = addGrid9To(d1, 1, 1);
  console.log(cells)
  let d = cells[1][1];
  describe(d);
  clearElement(d);
  describe(d);
  addGrid9To(d, 1, 1);
  describe(d);
}
function test04_textItems() {
  clearElement(dTable);
  let items = getRandomItems(24, 'object', true, false);
  registerItems(items);
  items.map(x => x.div.onclick = togglePic)
  console.log('items', items)
  presentItems(items, dTable, 4);
}
function test05() {
  dTable = mSection({ h: window.innerHeight - 128 }, 'dTable');
  dSearch = mSection({ padding: 2 }, 'dSearch'); mInputLineWithButtons(dSearch, { Go: fiddleSearch }, 'grid');
  show_sidebar(sortCaseInsensitive(get_keys(CODE.di.func)), onclickCodeInSidebar);
  onclickCodeInSidebar('SimpleGrid');
}
function test05_deck_in_grid() {
  let d1 = addDivToBody(100, 50, '%')
  let deck = createDeckWithJokers();
  attachTo(d1, deck);
}
function test05_div_mit_sidebar() {
  let dMain = mBy('dMain');
  mStyleX(dMain, { h: '100%', w: '100%', box: true, bg: 'silver', padding: 10 });
  let b = mButton('☰', null, dMain, { fz: 36 }, 'mybutton');
  let d = mDiv100(dMain, { matop: 4, position: 'relative', });
  let dSide = mDiv(d, { bg: 'silver' });
  let dContent = mDiv(d, { bg: worange });
  let sb = iSidebar(d, dSide, dContent, b, 120, false);
}
function test06() {
  let divnames = get_keys(CODE.di.var);
  divnames = divnames.filter(x => x[0] == 'd' && x[1] == x[1].toUpperCase() && !isNumber(x[x.length - 1]));
  show_sidebar(sortCaseInsensitive(divnames), onclickCodeInSidebar);
  console.log('divnames', divnames.join());
  let s = 'dActions,dAux,dAuxContent,dBottom,dButtons,dCenter,dCode,dConsole,dContent,dCurrent,dError';
  let s1 = 'dFeedback,dFiddle,dFleetingMessage,dFooter,dGameControls,dGames,dGameTitle,dHeader,dHelp,dHint';
  let s2 = 'dInstruction,dLeft,dLeiste,dLevel';
  let s3 = 'dLineBottom,dLineBottomLeft,dLineBottomMiddle,dLineBottomOuter,dLineBottomRight';
  let s4 = 'dLineTable,dLineTableLeft,dLineTableMiddle,dLineTableOuter,dLineTableRight';
  let s5 = 'dLineTitle,dLineTitleLeft,dLineTitleMiddle,dLineTitleOuter,dLineTitleRight';
  let s6 = 'dLineTop,dLineTopLeft,dLineTopMiddle,dLineTopOuter,dLineTopRight';
  let s7 = 'dLinks,dLoggedIn,dLogo,dMain,dMap,dMenu,dMessage,dMoveControls,dOben';
  let s7a = 'dPage,dParent,dPlayerNames,dPlayerStats';
  let s8 = 'dPuppet,dRechts,dRight,dScore,dSettings,dSidebar,dStatus,dSubmitMove';
  let s9 = 'dTable,dTableName,dTables,dTableShield,dTitle,dTop,dUnten,dUserControls,dUsers';
}
function test06_coButtonSidebarDiv() {
  let dMain = mBy('dMain');
  mStyleX(dMain, { h: '100%', w: '100%', box: true, bg: 'silver', padding: 10 });
  let co = coButtonSidebarDiv(dMain);
  console.log('co', co)
  let co2 = coButtonSidebarDiv(co.div);
}
function test06_one_deck() {
  let d1 = document.createElement('div');
  d1.id = 'myContainer';
  document.body.appendChild(d1);
  var d = d1;
  d.style.width = '100px';
  d.style.height = '100px';
  d.style.backgroundColor = 'blue';
  let deck = createDeckWithJokers();
  let card = deck.cards[54];
  deck.flip()
  attachTo(d, card);
  let domel = card.elem;
  let info = getTransformInfoDOM(domel)
}
function test07() {
  document.body.style.height = '100vh';
  let div1 = addDivToBody(100, 50, '%', 'blue');
  let div2 = addDivToBody(100, 50, '%', 'green');
  var deck1 = makeDeck({ kind: 'deck52', N: 30, nJokers: 5 });
  let ms1 = new DeckMS('deck1', deck1);
  ms1.attachTo(div1);
  deck1.cards.forEach(function (card, i) { card.enableDragging(); card.enableFlipping(); });
  var deck2 = makeDeck({ kind: 'deck52', N: 30, nJokers: 5 });
  let ms2 = new DeckMS('deck2', deck2);
  ms2.attachTo(div2);
}
function test07_menu_sidebar_div() {
  let dMain = mBy('dMain');
  mStyleX(dMain, { h: '100%', w: '100%', box: true, bg: 'silver', padding: 10 });
  setRect(dMain);
  let item = iMenuSidebarDiv(dMain, options);
  let dover = mDover(dMain, { bg: 'red', alpha: .25 });
  setTimeout(() => iDelete(item.live.sidebar), 5000)
}
function test08() {
  document.body.style.height = '100vh';
  let div1 = addDivToBody(100, 50, '%', 'blue');
  let div2 = addDivToBody(100, 50, '%', 'green');
  var deck1 = makeDeck({ kind: 'deck52', N: 30, nJokers: 5 });
  let ms1 = new DeckMS('deck1', deck1);
  ms1.attachTo(div1);
  let cells = addGridTo(div2, 2, 2, '10px');
  let d = cells[0][1];
  clearElement(d);
  var deck2 = makeDeck({ kind: 'deck52', N: 30, nJokers: 5 });
  let ms2 = new DeckMS('deck2', deck2);
  ms2.attachTo(d);
}
function test08_WTF() {
  let d = mBy('dMain');
  let menu = iMenuLine(d, { bg: 'dark' });
  console.log('iDiv', iDiv(menu));
  let title = mText('hello!', iDiv(menu), { fz: 30 });
}
function test09() {
  document.body.style.height = '100vh';
  let div1 = addDivToBody(100, 50, '%', 'blue');
  let div2 = addDivToBody(100, 50, '%', 'green');
  let rows1 = 3;
  let cols1 = 3;
  let cells = addGridTo(div2, rows1, cols1, '10px');
  console.log(cells);
  for (let i = 0; i < rows1; i++) {
    for (let j = 0; j < cols1; j++) {
      let cell = cells[i][j];
      clearElement(cell);
      let mobj = new DeckMS('d' + rows1 + '_' + cols1, makeDeck({ kind: 'deck52', N: 30, nJokers: 5 }));
      mobj.attachTo(cell);
      enableFlipForDeck(mobj.o);
      enableDragForDeck(mobj.o);
    }
  }
}
function test09_WTF_das_ist_ambra() {
  let comp = qPageMST(mBy('dMain'), qOptions());
  ex00_sidebar(comp.sidebar);
}
function test09_WTF_start() {
  ex01_table(comp.dContent);
  mCenterFlex(dTable);
  let tileStyles1 = { bg: 'pink', w: 300, h: 300, margin: 20 };
  let [rows, cols] = [5, 5];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      let d1 = mDiv(dTable, tileStyles1);
      if (coin()) iMenuSidebarDiv(d1, qOptions());
    }
    mGap(dTable, 0);
  }
}
function test1(map) {
  var baseballIcon = L.icon({
    iconUrl: '../leaf94/baseball-marker.png',
    iconSize: [32, 37],
    iconAnchor: [16, 37],
    popupAnchor: [0, -28]
  });
  function onEachFeature(feature, layer) {
    var popupContent = '<p>I started out as a GeoJSON ' +
      feature.geometry.type + ', but now I\'m a Leaflet vector!</p>';
    if (feature.properties && feature.properties.popupContent) {
      popupContent += feature.properties.popupContent;
    }
    layer.bindPopup(popupContent);
  }
  var bicycleRentalLayer = L.geoJSON([bicycleRental, campus], {
    style: function (feature) {
      return feature.properties && feature.properties.style;
    },
    onEachFeature: onEachFeature,
    pointToLayer: function (feature, latlng) {
      return L.circleMarker(latlng, {
        radius: 8,
        fillColor: '#ff7800',
        color: '#000',
        weight: 1,
        opacity: 1,
        fillOpacity: 0.8
      });
    }
  }).addTo(map);
  var freeBusLayer = L.geoJSON(freeBus, {
    filter: function (feature, layer) {
      if (feature.properties) {
        return feature.properties.underConstruction !== undefined ? !feature.properties.underConstruction : true;
      }
      return false;
    },
    onEachFeature: onEachFeature
  }).addTo(map);
  var coorsLayer = L.geoJSON(coorsField, {
    pointToLayer: function (feature, latlng) {
      return L.marker(latlng, { icon: baseballIcon });
    },
    onEachFeature: onEachFeature
  }).addTo(map);
}
function test1_3colHeaderFooter() {
  var dMain = document.getElementById('dMain');
  let dHeader = mDiv(dMain, { bg: '#ABC', hmin: 150 }, 'dHeader', 'header');
  let dOuter = mDiv(dMain, { bg: '#678', hmin: 500, display: 'flex', 'flex-flow': 'row wrap' }, 'dOuter');
  let dLeft = mDiv(dOuter, { bg: 'random', flex: '0 0 200px' }, 'dLeft', 'left');
  let dMiddle = mDiv(dOuter, { bg: 'random', flex: '1 0 auto' }, 'dMiddle', 'middle');
  let dRight = mDiv(dOuter, { bg: 'random', flex: '0 0 200px' }, 'dRight', 'right');
  let dFooter = mDiv(dMain, { bg: '#456', hmin: 100 }, 'dFooter', 'footer');
}
function test1_ari_10cards(otree) {
  let n = 10;
  let list = choose(get_keys(Aristocards), n);
  let items = list.map(x => ari_get_card(x));
  let cont = ui_make_deck_container(n, dTable, { bg: 'random', padding: 4 });
  let topmost = ui_add_cards_to_deck_container(cont, items, list);
  iDiv(topmost).onclick = () => anim_toggle_face(topmost);
}
function test1_basic() {
  var map = L.map('map');
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);
  console.log('geo', Geo)
  let [p1, p2] = [Geo.places.tuerkenschanzpark, Geo.places.vegagasse];
  map.setView(p1, 16)
  M = L.Routing.control({
    waypoints: [
      L.latLng(p1[0], p1[1]),
      L.latLng(p2[0], p2[1])
    ],
    routeWhileDragging: true
  }).addTo(map);
}
function test1_bw_widget_boa() {
  let dpop = mBy('dPopup');
  show(dpop);
  mStyle(dpop, { top: 50, right: 10 });
  let prefix = 'boa';
  let d = mDiv(dpop, { wmin: 200, hmin: 200, bg: 'red' }, 'dBw');
  let d2 = mDiv(d, { bg: 'dodgerblue', fg: 'white' }, null, 'your bitwarden vault');
  let d3 = mDiv(d, { bg: '#eee', fg: 'dimgray', padding: 8 }, null, 'LOGINS');
  let d4 = mDiv(d, { bg: 'white', fg: 'black' });
  let d5 = mDiv(d4, { display: 'flex' });
  let dimg = mDiv(d5, { bg: 'white', fg: 'black' }, null, `<img src='../rechnung/images/boa.png' height=14 style="margin:8px">`);
  let dtext = mDiv(d5, { cursor: 'pointer' }, null, `<div>boa</div><div style="font-size:12px;color:gray">gleeb69</div>`);
  dtext.onclick = () => onclick_bw_symbol(prefix)
  let d6 = mDiv(d4, { display: 'flex', padding: 2 });
  let disyms = {
    bwtext: { postfix: 'userid', matop: 2, maright: 0, mabottom: 0, maleft: 0, sz: 27 },
    bwcross: { postfix: 'cross', matop: 2, maright: 0, mabottom: 0, maleft: -13, sz: 25 },
    bwkey: { postfix: 'pwd', matop: 0, maright: 0, mabottom: 0, maleft: -12, sz: 27 },
    bwclock: { postfix: 'clock', matop: 0, maright: 0, mabottom: 0, maleft: 0, sz: 25 },
  }
  for (const k of ['bwtext', 'bwcross', 'bwkey']) {
    let o = disyms[k];
    let [filename, styles] = [k, disyms[k]];
    let path = `../rechnung/images/${filename}.png`;
    let [sz, ma] = [styles.sz, `${styles.matop}px ${styles.maright}px ${styles.mabottom}px ${styles.maleft}px`];
    console.log('ma', ma);
    let img = mDiv(d6, { paright: 16 }, null, `<img src='${path}' height=${sz} style="margin:${ma}">`);
    if (k != 'bwcross') {
      mStyle(img, { cursor: 'pointer' });
      img.onclick = () => onclick_bw_symbol(prefix, o.postfix);
    }
  }
  mFlexSpacebetween(d4);
  let d7 = mDiv(d, { bg: '#eee', fg: 'dimgray', padding: 7 }, null, 'CARDS');
  let d8 = mDiv(d, { bg: 'dodgerblue', fg: 'white' }, null, `<img src='../rechnung/images/rest_bw.jpg'>`);
}
async function test1_can_I_get_new_cities(min = 25000) {
  let info = await route_path_yaml_dict('../base/assets/lists/info.yaml');
  let text = await route_path_text('../base/mapdata/cities.csv');
  let cities = M.cities = csv2list(text);
  let capitals = [];
  let new_cities = {};
  let num = 0;
  for (const o of cities) {
    let n = o.population;
    if (nundef(n)) continue;
    n = Number(n);
    if (n < min) continue;
    let w1 = o.city_ascii.toLowerCase();
    if (nundef(o.country)) {
      console.log('missing country', o);
      continue;
    }
    num += 1;
    let land1 = o.country.toLowerCase();
    for (const k of info.capital) {
      let w = k.toLowerCase();
      if (w.includes(w1) && w.includes(land1)) {
        capitals.push(o);
        o.capital = 'capital';
      }
      let name = o.name = o.city_ascii;
      if (isdef(new_cities[name]) && new_cities[name].includes('capital')) continue;
      new_cities[name] = `${o.lng},${o.lat},${o.country},${o.capital},${o.population}`;
    }
  }
  downloadAsYaml(new_cities, 'cities');
  return new_cities;
}
function test1_car_math() {
  C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc', null, true);
  C.add({ w: 30, h: 25, color: 'red', draw: draw_car, update: update_car, turn_inc: 10, v: { a: 280, mag: 5 } });
  C.add({ x: 30, y: -100, color: 'green', w: 35, h: 25, draw: draw_car, update: update_car, v: { a: 0, mag: 3 } });
  C.draw();
}
function test1_change_user() {
  setTimeout(() => {
    mStyle(mBy('user_info'), { opacity: 0 });
    setTimeout(() => {
      let name = chooseRandom(get_user_names(), x => x != Session.cur_user);
      load_user(name);
    }, 1000);
  }, 2000)
}
function test1_maxBounds() { let m1 = create_map({ zoom: 0 }); }
function test1_nerd() {
  test0_nerd();
  let fi = nerdamer(`integrate(custom(x),x)`).buildFunction();
  let y = fi(100);
  console.log('fi(100)', y)
}
function test1_open_sidebar() {
  mBy('b_test').onclick = open_sidebar;
}
function test1_p5_init() {
  dTable = mBy('dTable'); mCenterFlex(dTable);
  let o = mCanvas(dTable, { w: 600, h: 400 }, {}, startloop, pauseloop, 'cc');
  iAdd(o, {}, { draw: draw_random_walk });
}
function test1_show_users() {
  show_users();
}
function test10(list) {
  console.log('codebase list', list);
  let text = list.map(x => x.text).join('\n');
  let funcnames = list[0].di.func;
  addModuleExports(funcnames);
}
function test10_0() {
  lookupSet(DA, ['svgsym', suit, color], html);
  let color = 'orange';
  let treff = `
  <path  d="M30 150C35 385 85 400 130 500L-130 500C-85 400 -35 385 -30 150A10 10 0 0 0 -50 150A210 210 0 1 1 -124 -51A10 10 0 0 0 -110 -65A230 230 0 1 1 110 -65A10 10 0 0 0 124 -51A210 210 0 1 1 50 150A10 10 0 0 0 30 150Z"  fill="${color}"></path>
  `;
  let idsym = getUID('x');
  let sym = `
  <symbol id="Treff" viewBox="-600 -600 1200 1200" preserveAspectRatio="xMinYMid">
  `
}
function test10_autocomplete() {
  let map = M.map = create_map({ zoom: 16 });
  map.on('moveend', function (e) { calc_map_dims(); console.log("dims", M.dims); });
  let tb = M.toolbar = create_toolbar(map);
  mButton('Dummy', dummy_reaction, tb);
  mAutocomplete(tb);
}
function test10_function() {
  C = new Plotter(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc');
  let canvas = C.cv;
  C.add({ astep: .1, a: 0, bstep: .1, b: 0, func: x => Math.sin(x), update: test10_update });
}
function test10_queen_html() {
  let htmlWORKS = `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      face="QS"
      height="100%"
      preserveAspectRatio="none"
      viewBox="-120 -168 240 336"
      width="100%"
      fill="#ffff00"
      stroke="green"
      >
      <defs><rect id="XSQ" width="164.8" height="260.8" x="-82.4" y="-130.4"></rect></defs>
      <symbol id="VSQ" viewBox="-500 -500 1000 1000" preserveAspectRatio="xMinYMid">
        <path
          d="M-260 100C40 100 -40 460 260 460M-175 0L-175 -285A175 175 0 0 1 175 -285L175 285A175 175 0 0 1 -175 285Z"
          stroke="green"
          stroke-width="80"
          stroke-linecap="square"
          stroke-miterlimit="1.5"
          fill="none"
        ></path>
      </symbol>
      <symbol id="SSQ" viewBox="-600 -600 1200 1200" preserveAspectRatio="xMinYMid">
        <path
          d="M0 -500C100 -250 355 -100 355 185A150 150 0 0 1 55 185A10 10 0 0 0 35 185C35 385 85 400 130 500L-130 500C-85 400 -35 385 -35 185A10 10 0 0 0 -55 185A150 150 0 0 1 -355 185C-355 -100 -100 -250 0 -500Z"
          fill="green"
        ></path>
      </symbol>
      <symbol id="SQ1" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="green"
          d="M635.39648,0 851.86719,312.33789C895.10685,299.11869 938.83136,290.34833 975,285 924.90197,188.22401 899.89439,94.153799 874.11133,0ZM295.52539,27.285156C246.27551,180.9799 142.75435,335.54042 209.25195,483.08398l-17.43359,13.44922c1.76531,151.10099 30.08527,286.57163 74.54102,398.60938 18.12594,21.287 38.56227,42.11564 61.47851,64.11523 3.61128,3.46683 7.28461,6.96262 11.33789,10.61914L901.47852,970l-0.41407,-0.51953c-0.12219,-0.138 -0.23745,-0.27418 -0.35937,-0.41211 15.27725,17.28278 32.6506,35.12574 52.3164,53.54294C1030.1434,1094.8366 1080,1150 1130,1250c52.9819,-70.6425 98.186,-110.0972 170,-152.7871v-37.6016c-68.6196,39.3343 -116.9422,76.6549 -164.5547,131.9668 -44.9491,-77.8482 -93.9175,-130.6069 -160.20897,-192.68943 -76.05982,-71.23062 -114.27421,-131.59148 -129.3711,-180.42578 -15.09688,-48.8343 -8.90849,-86.60287 7.94922,-120.96875 28.31708,-57.72677 91.51367,-102.35489 139.07032,-133.86328l-26.7793,-21.49024C896.53697,588.11019 793.22595,665.67487 806.10938,786.48828L699.86133,787.5 568.0625,939.89258 429.48438,939.86328C578.06034,763.29892 745.82856,594.02803 899.1875,455.09961l-9.56836,-10.99023c-28.86687,-3.02061 -55.64392,-10.37642 -80.51758,-21.42774 -1.77605,4.17261 -4.43372,8.02096 -7.94336,11.23438C665.11643,558.39566 525.46983,665.166 419.78906,829.43164L392.45703,811.84766C501.69344,642.05529 644.58723,533.12674 779.21875,409.9375l17.51367,6.86328c-17.74437,-8.98707 -34.48695,-19.8921 -50.29101,-32.48437 -124.71285,29.03155 -208.27492,36.48099 -267.26758,31.98242 0,0 -19.31641,14.60547 -29.31641,14.60547 -15,0 -25.58008,-5.64453 -30.58008,-5.64453 -5,0 -10,5 -25,5 -15,0 -30,-25 -40,-50 -1.51422,-2.01895 -3.01443,-4.07919 -4.23242,-5.79297l-39.21875,30.25586 10.50977,-0.54493c7.17244,138.45299 -1.25836,281.23598 43.02929,408.13477l-27.41796,17.66602c-1.32891,-2.13106 -2.43311,-4.45616 -3.26758,-6.95704C288.22851,692.7888 295.29422,552.70428 289.59766,421.09961l-69.70313,53.77344 20.20508,-16.59375C187.08454,297.85994 265.54029,182.85491 300.0957,58.960938ZM85,80c-55.000004,50 -100.000004,145 -35,145 9.343263,0 15.215964,-5.70961 19.599609,-15.58984l-0.05469,54.80664C63.116922,255.80043 55.218717,250 45,250c-34.999996,0 -39.999996,70 -5,70 24.46345,0 22.957588,-43.08208 10.8125,-44.93164 53.48157,5.0855 -15.809214,250.16385 -15.302734,296.2207 0.268193,24.38822 6.628431,48.73678 31.46289,56.20899C48.176742,632.49354 35,645.1697 35,660 35,674.30844 47.265656,686.61054 65.384766,692.25586 41.674751,699.57565 35,720.74035 35,740 35,776.24391 48.1356,836.13212 55.517578,866.33008 82.604368,846.54619 106.08392,825.42866 128.83984,800.21875 132.14826,778.91478 135,756.88968 135,740 135,720.60063 128.2285,699.26867 104.15234,691.95898 118.02756,686.75065 129.28173,676.58841 135,660c0,-14.83344 -13.18185,-27.51102 -30.78711,-32.89844 24.05654,-8.65812 30.01787,-32.21714 30.27734,-55.8125C134.99671,525.23221 65.705931,280.15386 119.1875,275.06836 107.04241,276.91792 105.53655,320 130,320c35,0 30,-70 -5,-70 -10.83425,0 -19.06007,6.52154 -25.074219,15.02148L100.25195,209.2793C104.49041,218.99863 110.42097,225 120,225 185,225 140,130 85,80Zm641.48047,287.83789c-86.62544,19.83455 -151.78802,28.17022 -200.80469,29.24219 -14.2248,6.27415 -30.07191,11.92239 -45.7793,18.95898 58.99266,4.49857 142.55438,-2.95118 267.19727,-32.03711 -7.7527,-5.20716 -14.38853,-10.76914 -20.61328,-16.16406zm-370.49024,88.29102c29.62693,11.74538 64.9141,21.55877 110.0293,25.15039 51.3028,4.08421 115.55629,0.48608 200.56445,-14.4043C568.01187,553.99998 468.15967,644.25595 384.25,765.71289 359.23837,670.90747 359.53927,564.67648 355.99023,456.12891ZM1182.5,473.75c-24.0403,0 -48.0562,17.34722 -29.8594,52.02344A45,42.5 0 0 1 1182.5,515a45,42.5 0 0 1 29.8652,10.76367C1230.552,491.09427 1206.538,473.75 1182.5,473.75Zm-54.6914,47.48047c-45.2477,0.77462 -37.6424,97.7377 22.793,66.2168A45,42.5 0 0 1 1137.5,557.5a45,42.5 0 0 1 13.1113,-29.94336c-8.6891,-4.53343 -16.2978,-6.43753 -22.8027,-6.32617zm109.3828,0c-6.5027,-0.11132 -14.1076,1.79222 -22.793,6.32226A45,42.5 0 0 1 1227.5,557.5a45,42.5 0 0 1 -13.1094,29.94336c60.4429,31.53409 68.0505,-65.43824 22.8008,-66.21289zm-24.8301,67.99414A45,42.5 0 0 1 1182.5,600 45,42.5 0 0 1 1152.6348,589.23633c-11.9875,22.85174 -5.6311,38.16959 6.9726,45.95898 -23.6821,34.46419 -48.941,66.02584 -74.9492,96.20703C1079.1653,675.69528 1058.4509,645.45798 1005,670c37.225,16.12754 38.5709,70.31699 75.9492,65.69727 -5.8664,6.76063 -11.768,13.45662 -17.6972,20.10156l15.207,1.88672c7.2551,-8.19076 14.4623,-16.46748 21.6113,-24.85352 5.1929,39.08146 35.0698,-7.57452 67.2129,-5.5 -16.4802,-41.743 -32.0495,-10.50502 -66.4785,4.63672 24.5708,-28.86629 48.4073,-59.08334 70.8027,-91.95508 26.5679,6.12811 61.7407,-10.79807 40.7539,-50.78906zM1255,655c-32.9633,38.74398 -63.8666,77.97963 -125,110 16.8191,30.21345 26.6544,60.2083 30,90 47.2312,18.32372 82.8871,51.83723 115,90 2.3419,-37.0436 -4.2974,-71.38724 -30,-100 23.3498,-4.99857 40.0029,-20.01884 50,-45 -14.5281,-24.40208 -35.9759,-32.69918 -60,-35 44.8752,-32.16719 30.2665,-71.33926 20,-110zM811.88477,817.78516c10.86486,41.66548 35.34229,88.00659 78.58593,139.42382 -4.92291,-5.82285 -9.66276,-11.58316 -14.2207,-17.2539l-286.46289,-0.0586 64.60547,-0.45703 75.1914,-86.93945 93.88282,-0.33984c-4.9028,-11.9067 -8.74345,-23.39087 -11.58203,-34.375zM377.5,842.5c4.42321,0 9.31831,2.00257 14.86719,9.24023C397.91606,858.97789 402.5,871.0223 402.5,885c0,13.9777 -4.58394,26.0221 -10.13281,33.25977C386.81831,925.49743 381.92321,927.5 377.5,927.5c-4.42321,0 -9.31831,-2.00257 -14.86719,-9.24023C357.08394,911.0221 352.5,898.9777 352.5,885c0,-13.9777 4.58394,-26.02211 10.13281,-33.25977C368.18169,844.50257 373.07679,842.5 377.5,842.5Z"
        ></path>
      </symbol>
      <symbol id="SQ2" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="red"
          d="M557.51758,0 805.9668,330.45703 851.01367,311.99805 635.36719,0Zm78.02148,0 63.76563,90.75C709.99966,65.000167 725,65 725,65 716.50651,26.779299 728.31462,17.104416 733.20117,0ZM820,265 851.86719,312.33789C877.5079,304.49903 903.31958,298.22492 927.6543,293.26562 907.75762,290.72138 885.5191,284.6565 865,270c-10,5 -30,10 -45,-5zm99.12695,216.28711C764.14521,621.01648 595.55342,787.07572 470.35547,940.01172L525,940 685,755h120.41797l-0.0547,-0.41211c6.37431,-102.76161 97.50088,-170.65811 160.41211,-212.22851zm-727.41992,15.5625 -59.86133,46.34766 -0.39648,0.30468c1.93099,12.0459 3.10803,21.69313 3.04101,27.78711 -0.25947,23.59536 -6.2208,47.15438 -30.27734,55.8125C121.81815,632.48898 135,645.16656 135,660 129.28173,676.58841 118.02756,686.75065 104.15234,691.95898 128.2285,699.26867 135,720.60063 135,740c0,16.88968 -2.85174,38.91478 -6.16016,60.21875 -1.95154,2.162 -3.90854,4.29257 -5.87304,6.39453C138.56664,789.96704 153.92711,771.43051 170,750 200.25102,810.50205 230.44886,854.59181 266.85742,895.71484 221.90196,783.10482 193.58426,647.63449 191.70703,496.84961ZM44.53125,610.36133 0,644.61523V902.7832C30.797744,884.46615 56.707359,866.73637 80.427734,846.89844 72.427991,853.57027 64.158102,860.01913 55.517578,866.33008 48.1356,836.13212 35,776.24391 35,740 35,720.74035 41.674751,699.57565 65.384766,692.25586 47.265656,686.61054 35,674.30844 35,660 35,645.1697 48.176742,632.49354 66.972656,627.49805 56.528563,624.35562 49.361734,618.22105 44.53125,610.36133Zm1190.09765,68.79687 -1.1211,1.04688c-20.0542,23.0427 -41.8711,45.665 -71.7441,65.72265 27.117,39.37142 36.6532,80.37363 27.7441,123.12891 25.4392,14.76465 47.2329,33.87001 67.875,55.8418 -10.0896,-28.95393 -26.9566,-68.05217 -64.6191,-89.36328C1229.865,829.72137 1245.3631,819.51581 1260,800c-28.5778,-21.24841 -50.4759,-15.94491 -77.3027,-15.66992 39.149,-21.89578 49.9371,-64.78262 51.9316,-105.17188zM110.74609,819.23828c-0.7889,0.78628 -1.58065,1.56702 -2.37304,2.3457 0.792,-0.77791 1.58362,-1.55961 2.37304,-2.3457zm-5.15234,5.05078c-0.76819,0.74251 -1.53476,1.48679 -2.30664,2.22266 0.77112,-0.73534 1.53841,-1.48017 2.30664,-2.22266zm-5.26172,5.00586c-2.077449,1.94603 -4.165139,3.87648 -6.273436,5.7793 2.104356,-1.90192 4.194747,-3.83083 6.273436,-5.7793zm-6.539061,6.02149c-1.467973,1.32281 -2.945132,2.63598 -4.429688,3.93945 1.482456,-1.30407 2.961518,-2.61456 4.429688,-3.93945zM377.5,862.5a11,22.5 0 0 0 -11,22.5 11,22.5 0 0 0 11,22.5 11,22.5 0 0 0 11,-22.5 11,22.5 0 0 0 -11,-22.5zm225.17578,127.46484a10,10 0 0 0 -10,10 10,10 0 0 0 10,9.99996 10,10 0 0 0 10,-9.99996 10,10 0 0 0 -10,-10zM420,990a10,10 0 0 0 -10,10 10,10 0 0 0 10,10 10,10 0 0 0 10,-10 10,10 0 0 0 -10,-10zm91.13281,0.41016a10,10 0 0 0 -10,10.00004 10,10 0 0 0 10,10 10,10 0 0 0 10,-10 10,10 0 0 0 -10,-10.00004z"
        ></path>
      </symbol>
      <symbol id="SQ3" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="#44F"
          d="M472.5,150a12.5,20 0 0 0 -12.5,20 12.5,20 0 0 0 12.5,20 12.5,20 0 0 0 12.5,-20 12.5,20 0 0 0 -12.5,-20zm-140,5a12.5,20 0 0 0 -12.5,20 12.5,20 0 0 0 12.5,20 12.5,20 0 0 0 12.5,-20 12.5,20 0 0 0 -12.5,-20zm23.49023,301.12891c3.54904,108.54757 3.24814,214.77856 28.25977,309.58398 83.90967,-121.45694 183.76187,-211.71291 282.33398,-298.83789 -85.00816,14.89038 -149.26165,18.48851 -200.56445,14.4043 -45.1152,-3.59162 -80.40237,-13.40501 -110.0293,-25.15039zm42.92579,22.92187c22.57573,0.10326 52.52779,2.34383 83.49804,6.2461 65.74558,8.28415 118.15335,21.65893 117.05469,29.87304 -1.09829,8.2139 -56.30922,5.07893 -122.05273,-3.20508 -65.73948,-8.28354 -117.1185,-18.57868 -116.02735,-26.79296 0.53448,-4.02047 14.07178,-6.22853 37.52735,-6.1211zM1117.5,492.5c2.4011,8.40385 4.2266,18.24941 5.4746,28.84375v0.36133c7.3876,-1.36391 16.4655,0.0837 27.2324,5.62304l-21.2675,-21.26757a1.50015,1.50015 0 0 1 1.0449,-2.57617 1.50015,1.50015 0 0 1 1.0761,0.45507l21.2676,21.26758c-5.5291,-10.74776 -6.9807,-19.81297 -5.6289,-27.19336 -10.7286,-1.24895 -20.7021,-3.08593 -29.1992,-5.51367zm130,0c-8.4251,2.40718 -18.2988,4.23414 -28.9238,5.48242h-0.2793c1.3613,7.38557 -0.087,16.46062 -5.6231,27.22266l21.2657,-21.26563a1.50015,1.50015 0 0 1 1.0312,-0.45312 1.50015,1.50015 0 0 1 1.0898,2.57422l-21.2675,21.26757c10.7565,-5.53399 19.8272,-6.98416 27.2109,-5.62695v-0.17187c1.2486,-10.6649 3.081,-20.57644 5.4961,-29.0293zm-853.59961,15.25781c20.38428,0.10329 47.42876,2.34386 75.39258,6.2461 59.36368,8.28422 106.68388,21.65899 105.69141,29.87304 -0.99271,8.21355 -49.91699,8.15671 -109.27735,-0.12695 -59.36371,-8.28422 -106.68391,-21.659 -105.69141,-29.87305 0.48636,-4.01928 12.70935,-6.22659 33.88477,-6.11914zm7.69531,34.67969c15.09367,-0.0753 32.61454,0.81411 50.47852,2.5625 51.50146,5.04084 94.00823,14.75226 93.67578,23.00391 -0.32891,8.2521 -42.34749,10.85536 -93.84961,5.81445C400.39893,568.77752 358.91755,558.00165 359.25,549.75c0.20345,-5.08688 15.52034,-7.17888 42.3457,-7.3125zm590.81446,21.09375c-26.28817,17.83124 -58.00395,39.71623 -85.84375,65.82227L1063.252,755.79883c5.9292,-6.64494 11.8308,-13.34093 17.6972,-20.10156C1043.5709,740.31699 1042.225,686.12754 1005,670c53.4509,-24.54202 74.1653,5.69528 79.6582,61.40234 18.288,-21.22222 36.2025,-43.13214 53.4609,-66.25 -50.4965,-31.89003 -99.3677,-65.63189 -145.70894,-101.62109zm92.24804,167.87109c-1.2353,1.43353 -2.4703,2.86748 -3.709,4.29493 1.3064,-0.16146 2.6533,-0.388 4.0508,-0.69727 -0.1038,-1.21628 -0.2241,-2.40447 -0.3418,-3.59766zm-21.4062,24.39649 1.3242,1.02344C1092.8236,758.22045 1130,765 1130,765c33.2353,-17.40792 57.5278,-36.95014 78.082,-57.38477 -19.9562,-11.65548 -39.7017,-23.55345 -59.2109,-35.71875 -15.5528,20.88792 -31.6462,40.7815 -48.0664,60.07227 34.429,-15.14174 49.9983,-46.37972 66.4785,-4.63672 -32.1431,-2.07452 -62.02,44.58146 -67.2129,5.5 -7.149,8.38604 -14.3562,16.66276 -21.6113,24.85352zM399.88477,574.98828c12.13924,-0.0753 26.23048,0.81416 40.59765,2.5625 41.42116,5.04089 74.78321,15.81675 74.51563,24.06836 -0.26463,8.25206 -34.05885,10.85531 -75.48047,5.81445 -41.42116,-5.04089 -74.78321,-15.81675 -74.51563,-24.06836 0.16364,-5.08693 13.30756,-8.24338 34.88282,-8.37695zm814.90823,12.6836 21.2675,21.26757a1.50015,1.50015 0 1 1 -2.121,2.1211l-21.2657,-21.26563c5.5369,10.76367 6.9837,19.84044 5.6211,27.22656h0.3223c10.6094,1.24816 20.4685,3.07443 28.8828,5.47852 -2.4278,-8.49731 -4.2627,-18.47029 -5.5117,-29.19922 -7.3807,1.35234 -16.4468,-0.0994 -27.1953,-5.6289zm-64.5879,0.002c-10.7501,5.53028 -19.8161,6.98044 -27.1973,5.62695v0.0723c-1.2488,10.70195 -3.0853,20.64836 -5.5078,29.12695 8.4975,-2.42785 18.4701,-4.26471 29.1992,-5.51367 -1.3518,-7.38039 0.1,-16.44561 5.6289,-27.19336l-21.2676,21.26758a1.50015,1.50015 0 1 1 -2.121,-2.1211zM399.95117,608.2207c7.75591,-0.014 16.33902,0.59569 25.04883,1.7793 30.51033,4.14665 55.19775,16.74619 55.24414,25 0.0491,8.25469 -24.64792,11.5847 -55.16016,7.4375 -30.51033,-4.14665 -55.28173,-14.19933 -55.32812,-22.45312 -0.0324,-5.62262 11.68692,-11.73096 30.19531,-11.76368zm2.94141,36.28321c3.92832,-0.0157 8.00124,0.15115 12.10742,0.49609 25.08573,2.10744 44.77796,7.02839 45.42188,14.97852 0.64298,7.94981 -19.17087,12.68576 -44.25586,10.57812 -25.08573,-2.10744 -45.94398,-10.26081 -46.5879,-18.21094 -0.52278,-6.4668 13.79255,-7.76393 33.31446,-7.84179zm-6.3711,30.78125c1.53788,10e-4 3.10151,0.0612 4.67383,0.17968 15.24356,1.1523 28.12847,7.43255 28.7793,14.02735 0.6519,6.59512 -11.17778,11.00764 -26.42188,9.85547 -15.24356,-1.1523 -28.12847,-7.43255 -28.77929,-14.02735 -0.57317,-5.81151 8.60794,-10.04793 21.74804,-10.03515zm-2.7207,30.4707c0.97501,0.002 1.96625,0.0499 2.96289,0.14453 9.66123,0.91446 17.82809,5.89851 18.24219,11.13281 0.4126,5.23472 -7.08576,8.73687 -16.74805,7.82227 -9.66123,-0.91446 -17.82809,-5.89851 -18.24219,-11.13281 -0.3645,-4.61356 5.45528,-7.97697 13.78516,-7.9668zm906.19922,0.0781 -34.2773,2.85547c0.2249,20.00253 -6.7832,39.15319 -30.7188,56.31055 24.0241,2.30082 45.4719,10.59792 60,35 -9.9971,24.98116 -26.6502,40.00143 -50,45 19.6816,21.91005 28.1768,47.18324 30.0293,74.45312l0.01,0.008 24.957,11.09375zm-167.2656,64.20508c0.2372,0.44647 0.4708,0.89347 0.7051,1.33985 -0.2343,-0.44637 -0.4679,-0.89339 -0.7051,-1.33985zm3.041,5.88282c0.083,0.16606 0.171,0.33199 0.2539,0.49804 -0.083,-0.16604 -0.1705,-0.33202 -0.2539,-0.49804zm2.6758,5.48437c0.2147,0.45253 0.425,0.90499 0.6367,1.35742 -0.2117,-0.45239 -0.4219,-0.90493 -0.6367,-1.35742zm2.455,5.32422c0.1795,0.40036 0.3641,0.80089 0.5411,1.20117 -0.177,-0.40029 -0.3615,-0.80081 -0.5411,-1.20117zm2.5958,5.98437c0.2099,0.50184 0.413,1.00415 0.6191,1.50586 -0.2062,-0.5018 -0.4092,-1.00393 -0.6191,-1.50586zm2.0703,5.11719c0.1975,0.50277 0.4,1.00516 0.5937,1.50781 -0.1937,-0.50252 -0.3962,-1.00516 -0.5937,-1.50781zm2.3418,6.1875c0.1922,0.53072 0.3764,1.06121 0.5644,1.5918 -0.188,-0.53055 -0.3722,-1.06112 -0.5644,-1.5918zm1.7324,4.96485c0.2042,0.60477 0.4106,1.20984 0.6094,1.81445 -0.1988,-0.60461 -0.4051,-1.20971 -0.6094,-1.81445zm2.0273,6.26562c0.1846,0.60177 0.3579,1.20308 0.5371,1.80469 -0.1792,-0.60139 -0.3525,-1.20313 -0.5371,-1.80469zm1.4688,5.00977c0.1799,0.63781 0.3593,1.27644 0.5332,1.91406 -0.174,-0.63786 -0.3532,-1.27602 -0.5332,-1.91406zM377.5,842.5c-4.42321,0 -9.31831,2.00257 -14.86719,9.24023C357.08394,858.97789 352.5,871.0223 352.5,885c0,13.9777 4.58394,26.0221 10.13281,33.25977 5.54888,7.23766 10.44398,9.24023 14.86719,9.24023 4.42321,0 9.31831,-2.00257 14.86719,-9.24023C397.91606,911.0221 402.5,898.9777 402.5,885c0,-13.9777 -4.58394,-26.02211 -10.13281,-33.25977C386.81831,844.50257 381.92321,842.5 377.5,842.5Zm-0.27344,4.79492c2.95574,0.0879 5.94922,5.08008 5.94922,10.70508 10.93128,-0.11104 14.67749,3.31056 5.67578,13 13.69744,3.7436 10.6454,8.69968 2.83789,14 7.80751,5.30032 10.85955,10.2564 -2.83789,14 9.00171,9.68944 5.2555,13.11104 -5.67578,13 0,10 -9.4596,18 -11.35156,0 -10.93128,0.11104 -14.67748,-3.31056 -5.67578,-13 -13.69744,-3.7436 -10.6454,-8.69968 -2.83789,-14 -7.80751,-5.30032 -10.85955,-10.2564 2.83789,-14 -9.0017,-9.68944 -5.2555,-13.11104 5.67578,-13 0.82773,-7.875 3.10344,-10.77344 5.40234,-10.70508zm352.35742,5.20508 -75.1914,86.93945 43.0039,-0.041L744.44531,885H840l-15,-32.5zm29.72266,65 -19.23047,22.23633L876.25,939.95508 860,917.5Zm-104.13476,52.41992 -315.75977,0.17969c2.43984,2.47881 4.98787,4.87423 7.56641,7.28906 15.37025,14.39437 29.32058,28.43253 41.91015,42.12693 1.06974,-4.4442 6.04965,-11.1309 16.11133,-19.5156 -30,-25 -15,-34.99999 15,-15 30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -11.06914,7.3794 -20.08451,10.6644 -25.5625,10.6289 1.31057,1.4627 2.62767,2.9262 3.90625,4.3809l256.41797,-0.1328zm-170.01172,4.44531C490.60938,974.21875 499.75,977.5 511,985c30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -30,20 -45,10 -15,-15 -18.75,-15.625 -19.92188,-25.39063 -10.83984,-25.63477zm91,0C581.60938,974.21875 590.75,977.5 602,985c30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -30,20 -45,10 -15,-15 -18.75,-15.625 -19.92188,-25.39063 -10.83984,-25.63477z"
        ></path>
      </symbol>
      <symbol id="SQ4" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="green"
          d="M499.67383,0C598.83088,212.42554 698.5156,423.78371 891.07812,444.24805L557.50781,0ZM299.89844,59.855469C265.54099,182.85387 187.08454,297.85994 240.09961,458.2793L349.875,372.94531C322.20549,333.64118 300,282.28964 300,255c0,-20 5.00324,-149.9992 5,-155 -10e-4,-2.004308 -2.41143,-19.27436 -5.10156,-40.144531zM899.91016,454.8418C746.55122,593.77022 578.78424,763.04072 429.50781,939.46875l40.84766,0.54297C595.55342,787.07576 764.14431,621.01748 918.95508,481.37891Zm65.79101,87.45703c-28.87179,19.18723 -64.12524,44.12835 -93.97851,75.52344l25.55078,20.04296c30.22964,-29.84438 65.96002,-54.59002 95.59961,-73.97851 -9.28135,-6.87909 -18.47109,-14.10656 -27.17188,-21.58789zM685,755 525.10156,939.88281 570,940 699.86133,787.5H806.65039L805,755Z"
        ></path>
      </symbol>
      <symbol id="SQ5" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          stroke="#44F"
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="6"
          fill="none"
          d="M435,885A57.5,75.000002 0 0 1 377.5,960.00001 57.5,75.000002 0 0 1 320,885 57.5,75.000002 0 0 1 377.5,810 57.5,75.000002 0 0 1 435,885v0M417.07718,940H876.02627M308.27069,940h28.75722M339.49097,970H901.47783M131.84482,543.19629 351.03451,374.58883M6.9310566e-5,644.61533 44.832165,610.1291M1138.1663,665.18229C1077.9926,627.18313 1020.1253,586.55302 965.29601,542.45758M1208.5796,707.90733c-20.1878,-11.78458 -40.1599,-23.81534 -59.8906,-36.12132M557.51806,-3.5577172e-4 965.44559,542.57786M1299.7291,1059.765c-68.4773,39.2778 -116.7334,76.5733 -164.2838,131.8131 -44.9491,-77.8482 -93.9175,-130.6069 -160.20897,-192.68943 -76.05982,-71.23062 -114.27421,-131.59148 -129.3711,-180.42578 -15.09688,-48.8343 -8.90849,-86.60287 7.94922,-120.96875 28.31708,-57.72677 91.51285,-102.35515 139.0695,-133.86354M499.68528,0.03748108C598.83742,212.45251 698.51437,423.77834 890.34164,443.851M364.36489,812.31243C320.07724,685.41364 328.50886,542.63024 321.33642,404.17725c76.71711,39.85219 163.35704,77.44074 457.8821,5.76082C644.587,533.12731 501.69292,642.05444 392.45651,811.84681M355.97656,456.125c29.62956,11.74764 64.92126,21.56216 110.04297,25.1543 51.30556,4.08443 115.56309,0.48617 200.57813,-14.40625 -98.57798,87.12824 -198.39177,177.48156 -282.2461,298.86133 -24.96545,-94.92731 -24.7974,-201.06283 -28.375,-309.60938v0M867.34252,440.4065C719.62961,574.07588 560.4386,730.57461 436.09373,879.43791M223.89186,472.86906c-0.82324,183.16931 37.98603,343.48203 98.11552,466.27071M191.49798,496.71315c2.08648,150.92196 30.40471,286.39171 75.55251,398.73891M429.507,939.46794C578.78343,763.03991 746.55158,593.76963 899.91052,454.84121M470.35494,940.01166C595.55289,787.0757 764.14488,621.01728 918.95565,481.37871M525,940 685,755h120.41872M567.92551,940.0502 699.86133,787.5h106.78892M611.46541,939.39021 714.72266,820h97.2642M654.39213,939.43943 729.58398,852.5h93.89714M697.39662,939.39902 744.44531,885h95.04566M740.07521,939.73575 759.30664,917.5H860M906.39152,629.42293 1063.7852,756.67736M871.92369,617.813 1043.2441,757.01082M459.61865,481.34795C414.86903,573.51288 406.45192,669.62669 385,765M303.65592,-0.00221915C259.09343,162.78907 138.61386,327.07777 209.42337,483.4732M240.09997,458.27954C187.0849,297.86018 265.54056,182.85405 300.09597,58.960082M805.81085,330.134c14.88787,-6.44544 30.42237,-12.16006 46.14865,-17.2138M0.09725143,902.73906C71.866196,860.06685 117.03718,820.61709 170,750c50,100 99.8567,155.1639 176.97865,227.3892 281.56105,263.6842 94.15072,409.6105 -13.08443,480.4695M377.5,842.5c4.42321,0 9.31831,2.00257 14.86719,9.24023C397.91606,858.97789 402.5,871.0223 402.5,885c0,13.9777 -4.58394,26.0221 -10.13281,33.25977C386.81831,925.49743 381.92321,927.5 377.5,927.5c-4.42321,0 -9.31831,-2.00257 -14.86719,-9.24023C357.08394,911.0221 352.5,898.9777 352.5,885c0,-13.9777 4.58394,-26.02211 10.13281,-33.25977C368.18169,844.50257 373.07679,842.5 377.5,842.5v0M1130,765c16.8191,30.21345 26.6544,60.2083 30,90 47.2312,18.32372 82.8871,51.83723 115,90 2.3419,-37.0436 -4.2974,-71.38724 -30,-100 23.3498,-4.99857 40.0029,-20.01884 50,-45 -14.5281,-24.40208 -35.9759,-32.69918 -60,-35 44.8752,-32.16719 30.2665,-71.33926 20,-110 -32.9633,38.74398 -63.8666,77.97963 -125,110v0M1300,705.83334l-34.3239,2.86032M1299.9997,930.55544l-26.1711,-11.63161M1192.7269,836.42558c37.6985,20.41997 54.5672,59.51932 65.2796,89.01033M1182.9686,784.9233c26.555,-0.86899 48.4536,-6.17171 77.0314,15.0767 -14.6369,19.51581 -30.1358,29.72065 -67.2011,34.6433M1234.6287,679.15791c-1.9945,40.38926 -12.7829,83.27561 -52.2037,104.5774M1162.3431,745.42454c26.5383,39.87481 36.0743,80.87688 26.979,123.43436M1130,765c0,0 -82.1675,-15 -95,-5 -12.8325,10 -32.9691,31.30714 -40,40 -31.97044,39.52731 3.64509,49.72935 20,30M1050,800c-59.31161,25.45028 -64.22618,120.61499 20,25M1041.1933,853.52948c-14.9444,32.29436 0.7581,60.30105 58.5,-5.24847M1062.1853,882.59071C1040.9944,921.29246 1103.755,918.14402 1160,855M1063.2524,755.79961c33.572,-37.62441 66.2866,-76.82735 96.4461,-120.73492M1078.4582,757.6865c32.4929,-36.68328 64.0954,-75.00591 93.2554,-117.82589M1085,735c-4.9523,-58.0017 -25.4042,-90.06768 -80,-65 38.526,16.69119 38.6175,74.15849 80,65v0M1005,670c37.8073,-6.25375 56.1399,40.79694 80,65M1100,732.33169c35,-15 50.6726,-47.07119 67.2824,-5 -32.2824,-2.08351 -62.2824,45 -67.2824,5v0M1100.0662,732.84533c26.3257,8.26747 52.4616,-23.9051 67.2162,-5.51364M1155.0001,585.00001C1080.0001,630 1080,484.99999 1155,530c-45,-75 100,-75 55,0 75,-45 75,100 10e-5,55 45,75.00001 -100.0001,74.99999 -55,10e-6v0M1242.5,557.5c-60,0 -60,0 -60,-60 0,60 0,60 -60,60 60,0 60,0 60,60 0,-60 0,-60 60,-60v0M1122.9743,521.34338c-1.248,-10.59434 -3.0726,-20.43952 -5.4737,-28.84337 8.5766,2.45046 18.6544,4.30045 29.4977,5.54996M1146.7554,616.97813c-10.7509,1.24908 -20.7424,3.08971 -29.255,5.52188 2.4225,-8.47859 4.2581,-18.42426 5.5069,-29.12621M1241.9485,592.9857c1.2496,10.84959 3.1002,20.93331 5.5519,29.5143 -8.4143,-2.40409 -18.2735,-4.23021 -28.8829,-5.47837M1218.5761,497.98319c10.625,-1.24828 20.4988,-3.07601 28.9239,-5.48319 -2.4151,8.45286 -4.2469,18.3639 -5.4955,29.0288M357.95908,386.26136c-4.7848,-2.30618 -9.52375,-4.6875 -14.28345,-7.12611M748.06895,383.93902C622.45119,413.08814 538.88863,420.5377 479.79194,417.07826M355.99023,456.12891c29.62693,11.74538 64.9141,21.55877 110.0293,25.15039 51.3028,4.08421 115.55629,0.48608 200.56445,-14.4043C568.01187,553.99998 468.15967,644.25595 384.25,765.71289 359.23837,670.90747 359.53927,564.67648 355.99023,456.12891v0M85,135c10.787262,31.12992 5,90 35,90 65,0 20,-95 -35,-145 -55.000004,50 -100.000004,145 -35,145 30,0 24.21273,-58.87008 35,-90v0M40,285c0,0 0,-10 10,-10 12.88094,0 15,45 -10,45 -34.999996,0 -29.999996,-70 5,-70 30,0 40,50 40,50 0,0 10,-50 40,-50 35,0 40,70 5,70 -25,0 -22.88094,-45 -10,-45 10,0 10,10 10,10M120,275c-55,2.66831 15,250 14.49097,296.289C134.16784,600.67311 125,630 85,630 45,630 35.832163,600.67311 35.509031,571.289 35,525 105,277.66831 50,275M70,264.98358V208.33333M100,265.18883V208.74384M103.20611,627.39263C121.81764,632.48836 135,645.16656 135,660c0,19.32997 -22.38576,35 -50,35 -27.614237,0 -50,-15.67003 -50,-35 0,-14.8303 13.176786,-27.50627 31.782083,-32.60414M65.931232,692.4756C41.674852,699.57662 35,720.74035 35,740c0,36.24391 13.136211,96.133 20.364326,126.34321M128.36935,800.67704C132.14739,778.91407 135,756.88968 135,740c0,-19.39937 -6.77205,-40.73054 -31.46191,-47.67672M256.89224,885h6.38602M1.1417102e-4,884.99999 28.737098,885M245.57157,870h11.90122M2.5229169e-5,870.00002 51.088175,870M233.67034,855h18.57752M4.1609595e-5,854.99999 52.539543,855M222.93022,840h24.09272M7.6084636e-5,840.00001 49.346532,840M212.77064,825h29.89819M4.2336546e-5,825.00002 46.443795,825M203.1916,810h34.54258M4.0905762e-6,810.00002 43.541058,810M194.48339,795h38.89668M129.46208,795h5.22493M-3.8457096e-5,795.00001 40.638321,795M186.06545,780h42.96051M131.78427,780h14.51368M-3.1733115e-5,780.00001 38.316131,780M178.22806,765h46.73407M133.81618,765h24.67327M10,765H36.284215M134.68701,750h86.50156M10,750H34.542573M134.97728,735h83.01828M15,735H35.12312M132.65509,720H205M15,720H37.844594M155,705h45M325,510c-11.82334,-17.57111 -24.45521,-31.94743 -45.42097,-47.16261 -21.67788,-15.73198 -32.01525,9.6364 -23.86278,22.70472M325,540c-13.68399,-15.7169 -40.72661,-39.31758 -62.25684,-51.80699 -20.39713,-11.83211 -26.52283,15.09906 -9.53546,27.99468M326.64903,572.53873c-13.68399,-15.7169 -40.42328,-39.85576 -62.25684,-51.80699 -33.04187,-18.08643 -43.83934,14.15892 -2.74316,31.80699M329.68204,632.14459c-13.68399,-15.7169 -40.42328,-39.85576 -62.25684,-51.80699 -30.81157,-16.86561 -37.65608,16.8659 -5.11631,35.80661M328.06764,597.68777c-13.86078,-13.59047 -33.31597,-27.70524 -50.77313,-39.51278 -22.07438,-14.9305 -34.10496,4.47364 -22.83565,17.22609M332.19576,659.38835c-13.77031,-13.23256 -32.62008,-26.88451 -49.58329,-38.35795 -24.04479,-16.26322 -36.17268,12.27173 -19.25152,25.31598M335.48063,686.60634C319.24375,673.64242 295.51352,659.7442 277.4252,650.3376c-31.2697,-16.26141 -36.88691,20.47944 -3.29829,37.12122M339.44241,709.94356C293.812,671.34406 241.20364,684.64228 285,715M345.57813,743.85785c-49.78299,-42.23381 -140.14002,-42.27022 -51.45386,5.50004M359.15379,797.42734C296.30783,757.35598 217.41506,767.9862 315.25691,808.08817M356.15219,815.71589c-43.41581,-18.1629 -92.79129,0.20988 -43.97099,13.65755M335.79649,833.55074c-36.46249,-11.38361 -55.92576,9.42664 -11.42381,20.21059M323.63736,467.38673c-7.1925,-7.58612 -15.51039,-14.89158 -25.85855,-22.4014 -17.52111,-12.71535 -26.71907,0.32727 -25.12324,12.4885M322.15877,428.22708c-1.31784,-1.00168 -2.67007,-2.00587 -4.05887,-3.01374 -19.41173,-14.0874 -28.60717,3.4419 -24.22651,16.36102M351.5017,769.34668c-41.8286,-32.62324 -87.13007,-22.98664 -57.82646,2.59886M396.50984,805.03398c97.55186,1.04019 65.93584,25.61549 21.19412,25.63392M410.20409,785.71584c31.87867,-11.92022 60.58013,-9.17207 74.95842,-1.62887 16.81695,8.82258 14.04006,24.2047 -26.16419,30.34906M430.54986,757.7319c58.57662,-11.0001 103.69453,13.94896 55.48459,26.1888M451.62343,729.60393c67.42086,-18.09697 125.45489,10.74224 49.42624,33.66324M469.15226,707.61747c69.25339,-23.47062 135.42699,4.47512 67.15155,28.14525M497.03474,675.73394c50.50234,-8.00778 88.6752,9.66559 55.551,28.0217M514.06286,656.56715c77.25396,-19.94453 157.95502,17.262 48.7626,27.75334M550.91529,618.31036c57.1762,-5.00205 100.00874,18.02731 40.2256,35.03407M568.89077,600.93936c75.24789,-19.79781 151.84194,14.60918 51.22446,34.33609M596.84001,574.15634c55.64482,-7.64299 102.46778,11.7471 64.24628,28.76475M620.73761,552.10789c71.56974,-16.51587 140.66537,14.62009 53.45997,34.06378M660.73433,515.56983c57.1151,-4.52529 99.00079,18.87447 36.45506,35.78648M684.38719,494.58861c73.88041,-16.89549 144.8643,16.89901 43.68109,36.08147M722.79564,460.82624c57.76542,-5.50387 101.75016,17.65976 42.02455,34.7974M748.43052,437.7647c68.01755,-11.92015 127.59071,17.4385 43.80212,36.02686M645.55164,273.86211C640.4516,285.47932 635.59316,297.26013 610,295c-14.37233,81.30224 -73.77303,98.38804 -130,120 0,0 -19.41945,15.64589 -29.41945,15.64589C435.58055,430.64589 425,425 420,425c-5,0 -10,5 -25,5 -15,0 -30,-25 -40,-50 -30,-40 -55,-96.04455 -55,-125 0,-20 5.003,-149.9992 5,-155 -0.002,-3.089335 -5.72781,-42.445846 -10.1037,-72.07356M622.93321,240.32144C616.61632,250.552 609.19352,264.74236 615,265c2.73428,0.12132 6.96971,-10.37759 10.24354,-19.90618M904.16018,494.81448l50.56379,54.17549M889.99031,508.2039l48.73454,52.21558M875.34795,521.08709l48.01937,51.44933M861.63691,534.96812l46.15447,49.45122M847.01655,547.87487l45.96336,49.24646M832.83302,561.24966l35.28817,37.80876M818.66315,574.63908l24.02599,25.74214M803.86532,587.3557l17.84203,19.11646M790.06402,601.14003l8.92784,9.56554M482.75862,925h55.41872M495.89491,910h55.00821M508.21018,895h55.82923M521.34647,880h55.41872M534.48276,865h55.41872M552.95566,845H585M790,820v32.5M765,820v32.5M740,820v32.5M703.26765,833.26765l22.578,22.578M684.08867,854.08867l23.39901,23.39901M665.93596,875.93596l22.78325,22.78325M648.19376,898.19376l22.578,22.578M629.22003,919.22003l20.73071,20.73071M791.29599,310.75526c15.62961,-6.29692 31.83381,-11.83473 48.11454,-16.69002M776.15664,290.35133c15.84539,-6.35519 32.2728,-11.93292 48.76488,-16.81275M760.82223,270.4856c16.18061,-6.50419 32.97255,-12.19625 49.8241,-17.16102M746.54814,252.22866c16.42632,-6.7965 33.54246,-12.73644 50.75899,-17.91046M739.12096,229.17409c11.71799,-4.608 23.73402,-8.79725 35.84163,-12.5995M726.54679,208.22774c8.46394,-3.2756 17.07495,-6.33535 25.75602,-9.1911M711.68624,188.33917c5.39484,-2.00758 10.85695,-3.94932 16.37032,-5.82515M900.40882,94.431781C848.5463,114.25376 796.72828,69.769511 761.4322,93.621964 715,125.00001 755,185 789.33498,165.18883 821.13528,146.84017 790,105 775,115c-9.30261,6.20174 -14.88842,18.30946 -10,25 6.18042,8.45885 10.48873,9.62814 20,5M901.46652,97.13303C861.76115,135.4564 879.34663,201.01228 842.74068,222.52055 794.42332,250.91 757.5027,188.96753 790.17065,166.51363c30.25635,-20.79631 54.6061,25.32412 39.1205,34.55428 -9.60379,5.72429 -22.93675,5.55043 -26.86936,-1.74304 -4.972,-9.22111 -4.17161,-13.61293 4.10189,-20.20332M765,180l90,-60M845,160c-10,-10 -45.467,-11.35662 -55,5 22.00764,-11.03808 34.76336,-24.75676 25,-45M795,230c25,30 50,20 75,10 24.05541,32.7653 64.66095,38.66637 105,45M725,130C715,110 740,85 755,75 749.14905,51.948962 757.70702,26.00987 766.59362,0.00490542M700,90c10,-25 25,-25 25,-25 -8.48271,-38.172217 3.28893,-47.867055 8.18679,-64.93099617M427.96416,0.01822477C445.06535,51.748024 483.31343,78.400493 539.31946,83.994433M446.67053,0.04362022C462.63103,38.843647 492.03631,61.699978 533.14043,70.683071M461.24526,0.01603427C475.22521,27.447203 496.92922,45.718691 525.58366,55.74792M476.99588,0.10806452C487.38028,16.453559 500.99836,28.964352 517.63646,37.893813M371.26432,0.04443925C356.34418,40.196712 340.91798,80.075485 304.69652,100.28589M355.60874,0.04353776C343.34293,31.804187 329.13875,61.845937 302.67098,80.298673M339.57059,0.02060224C329.73362,23.196287 317.89132,44.53011 299.71459,59.883794M325.15652,0.08430598C317.46458,14.722402 308.27692,27.964826 296.26758,38.544057M305,120c41.1016,-25.066138 61.56092,-14.28714 80,0 20,55 -15,110 -14.41945,151.6763 0.21559,15.47674 11.72696,13.44856 19.41945,13.3237 4.99934,-0.0811 15,10 15,10M305,125c29.58587,-20.97635 55.47603,-17.50669 80,-5M430,245c20,0 20,30 5,30 -40,5 -40,-10 -5,0M365,315v10l5,-5 -5,-5v0M455,320l5,-5v10l-5,-5v0M370,320c0,0 5,5 10,5 5,0 5.24415,-4.00984 12.32219,-4.4848C400,320 400,325 405,325c5,0 15,-10 20,-10 5,0 15,5 20,5h10M390,340c3.06957,28.45212 45.6136,8.68856 45,5 -5,5 -44.77199,31.85105 -45,-5v0M430,135c51.53607,-36.718861 85.86501,-16.18211 120,5 -35.40475,-25.98218 -85,-45 -120,-5v0M540,160C525,160 503.52953,134.61544 483.61398,136.45137 453.79885,139.1999 445,175 430,180 447.93464,158.59181 463.7944,151.78059 478.07024,151.93493 507.27438,152.25068 515,185 550,175M430,180c15,-10 32.80939,10.04302 45.17423,9.94542C504.08195,189.71723 519.49385,175 530,175M380,175c-20,0 -30.87367,-19.1648 -47.03192,-20.29027 -12.3413,-0.85961 -29.19452,12.61246 -29.19452,17.61246 0,7.07107 11.23734,20.70784 22.74316,23.25836C342.90794,199.21402 362.81244,175.3491 380,175v0M305,165c22.64276,-42.75014 64.95345,-9.49214 65,-5M820,265c15,15 35,10 45,5 20.5191,14.6565 42.75671,20.72048 62.68286,23.22939M851.86653 312.33707C895.10619 299.11787 938.83136 290.34833 975 285C924.90149 188.22308 899.90057 94.152754 874.11725 -0.0019513659 M851.86653,312.33707C895.10619,299.11787 938.83136,290.34833 975,285 924.90149,188.22308 899.90057,94.152754 874.11725,-0.00195137M851.01315,311.99775 635.36748,-2.4089679e-4M927.65339,293.26472C907.75671,290.72048 885.5191,284.6565 865,270c-10,5 -30,10 -45,-5"
        ></path>
      </symbol>
      <symbol id="SQ6" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          stroke="#44F"
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="3"
          fill="none"
          d="M986.60333,811.20184l17.52527,26.83701m3.5763,5.47663 14.2883,21.88014M993.49031,800.86775c12.59499,20.81314 26.36539,39.79428 40.67199,57.93996m3.6811,4.63683c6.0574,7.57938 12.2001,15.02588 18.3803,22.41378m3.5795,4.26824c4.9357,5.87225 9.8895,11.71638 14.8372,17.56998M1002.2895,791.27746c25.6547,42.89167 56.3312,77.95704 86.5273,113.77117M1011.3206,782.24417c26.5981,44.89853 58.7236,81.18275 90.1523,118.55299M1018.2105,775.40469C1045.4382,820.51985 1078.1971,857.01507 1110,895M91.990234,409.08984c5.346491,34.39969 12.364566,69.89746 17.978516,99.54297 5.61395,29.64551 9.60751,54.84672 9.52344,62.49219 -0.14502,13.18721 -2.60383,25.09508 -7.35157,32.2207C107.39289,610.47133 101.33414,615 85,615 68.665861,615 62.607113,610.47133 57.859375,603.3457M95.230469,511.42383c2.783382,14.69817 5.162021,28.28252 6.812501,38.99023 1.65048,10.70771 2.46055,19.51658 2.44922,20.54688 -0.12561,11.42229 -3.03694,21.37127 -4.833987,24.06836 -1.554361,2.33286 -1.96098,2.67133 -3.316406,3.33203C94.986371,599.02203 91.780811,600 85,600M99.244141,641.85938C113.48363,645.75807 120,654.05348 120,660c0,3.87456 -2.13436,8.18273 -8.24609,12.46094C105.64218,676.73915 95.96981,680 85,680 74.030191,680 64.357824,676.73915 58.246094,672.46094M99.476562,706.76367c8.835718,2.48582 12.847888,6.43575 15.929688,11.99805C118.48805,724.32402 120,732.04575 120,740c0,15.20071 -2.70618,36.77501 -6.41016,58.11133M102.94922,660.2832C99.903483,662.33803 92.860098,665 85,665c-7.997241,0 -15.198086,-2.76015 -18.152344,-4.82812M102.28516,726.03125C103.52282,728.2651 105,733.94656 105,740c0,13.42041 -2.56634,34.6744 -6.189453,55.54492M726.75998,368.27894C639.85431,387.67178 574.6926,396.00751 524.83867,397.57475M715.61309,356.58894C649.94086,370.7787 597.12268,378.4618 554.16847,381.63062M703.03893,344.25945c-49.76763,10.38288 -91.8849,16.91189 -127.75629,20.52287M690.7875,331.76901c-38.30305,7.6982 -71.90839,13.04175 -101.50758,16.49148M680.13806,318.87243c-30.03631,5.82677 -57.08899,10.16495 -81.51547,13.25269M670.20516,305.76564c-23.347,4.36958 -44.8345,7.81564 -64.64196,10.45774M659.57286,292.71511c-18.04772,3.23925 -34.94556,5.91034 -50.78275,8.07274M390,380c11.94547,-13.95601 27.22073,-12.69836 45,0M440,195c10,15 30,15 45,15M310,205c50,25 60,-30 70,-30M350.01995,162.05531c1.14299,3.17833 1.7863,6.76631 1.7863,10.56373 0,13.03628 -7.58139,23.60427 -16.9335,23.60427 -9.35211,0 -16.93349,-10.568 -16.93349,-23.60427 0,-5.79795 1.49965,-11.10766 3.98776,-15.21654M488.55832,153.60687c1.90775,3.81995 3.02626,8.46304 3.02626,13.4703 0,13.03628 -7.58139,23.60427 -16.9335,23.60427 -9.35211,0 -16.93349,-10.568 -16.93349,-23.60427 0,-4.03258 0.72545,-7.82898 2.00436,-11.14943"
        ></path>
        <use xlink:href="#SSQ" height="90" transform="translate(1188,935)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1194,1043)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1096,1033)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1022,947)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(918,851)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(897,726)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
      </symbol>
      <rect width="239" height="335" x="-119.5" y="-167.5" rx="12" ry="12" fill="white" stroke="green"></rect>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ1"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ1"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ2"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ2"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ3"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ3"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ4"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ4"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ5"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ5"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ6"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ6"></use>
      <use xlink:href="#VSQ" height="32" x="-114.4" y="-156"></use>
      <use xlink:href="#SSQ" height="26.769" x="-111.784" y="-119"></use>
      <use xlink:href="#SSQ" height="55.68" x="36.088" y="-132.16"></use>
      <g transform="rotate(180)">
        <use xlink:href="#VSQ" height="32" x="-114.4" y="-156"></use>
        <use xlink:href="#SSQ" height="26.769" x="-111.784" y="-119"></use>
        <use xlink:href="#SSQ" height="55.68" x="36.088" y="-132.16"></use>
      </g>
      <use xlink:href="#XSQ" stroke="#44F" fill="none"></use>
    </svg>
    `;
  let d1 = mDiv();
  d1.innerHTML = html;
  mAppend(dTable, d1);
}
function test10_update(canvas, item) {
  let [astep, a, bstep, b, func] = [item.astep, item.a, item.bstep, item.b, item.func];
  canvas.clear();
  [a, astep] = oscillate_between(a, 0, 5, astep);
  [b, bstep] = oscillate_between(b, 0, 5, bstep);
  [item.astep, item.a, item.bstep, item.b] = [astep, a, bstep, b];
  canvas.plot(x => b * func(a * x), "rgb(11,153,11)", 1);
  return false;
}
function test10_verrueckt() {
  let styles = { bg: 'yellow', fg: 'red', border: 'random', thickness: 20, shadow: 'green', rotate: 45, scale: 2 };
  let html = `
      <svg
      xmlns="http://www.w3.org/2000/svg"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      class="card"
      face="QS"
      height="100%"
      preserveAspectRatio="none"
      viewBox="-120 -168 240 336"
      width="100%"
      fill="#ffff00"
      stroke="#ff0000"
      >
      <defs><rect id="XSQ" width="164.8" height="260.8" x="-82.4" y="-130.4"></rect></defs>
      <symbol id="VSQ" viewBox="-500 -500 1000 1000" preserveAspectRatio="xMinYMid">
        <path
          d="M-260 100C40 100 -40 460 260 460M-175 0L-175 -285A175 175 0 0 1 175 -285L175 285A175 175 0 0 1 -175 285Z"
          stroke="black"
          stroke-width="80"
          stroke-linecap="square"
          stroke-miterlimit="1.5"
          fill="none"
        ></path>
      </symbol>
      <symbol id="SSQ" viewBox="-600 -600 1200 1200" preserveAspectRatio="xMinYMid">
        <path
          d="M0 -500C100 -250 355 -100 355 185A150 150 0 0 1 55 185A10 10 0 0 0 35 185C35 385 85 400 130 500L-130 500C-85 400 -35 385 -35 185A10 10 0 0 0 -55 185A150 150 0 0 1 -355 185C-355 -100 -100 -250 0 -500Z"
          fill="black"
        ></path>
      </symbol>
      <symbol id="SQ1" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="#FC4"
          d="M635.39648,0 851.86719,312.33789C895.10685,299.11869 938.83136,290.34833 975,285 924.90197,188.22401 899.89439,94.153799 874.11133,0ZM295.52539,27.285156C246.27551,180.9799 142.75435,335.54042 209.25195,483.08398l-17.43359,13.44922c1.76531,151.10099 30.08527,286.57163 74.54102,398.60938 18.12594,21.287 38.56227,42.11564 61.47851,64.11523 3.61128,3.46683 7.28461,6.96262 11.33789,10.61914L901.47852,970l-0.41407,-0.51953c-0.12219,-0.138 -0.23745,-0.27418 -0.35937,-0.41211 15.27725,17.28278 32.6506,35.12574 52.3164,53.54294C1030.1434,1094.8366 1080,1150 1130,1250c52.9819,-70.6425 98.186,-110.0972 170,-152.7871v-37.6016c-68.6196,39.3343 -116.9422,76.6549 -164.5547,131.9668 -44.9491,-77.8482 -93.9175,-130.6069 -160.20897,-192.68943 -76.05982,-71.23062 -114.27421,-131.59148 -129.3711,-180.42578 -15.09688,-48.8343 -8.90849,-86.60287 7.94922,-120.96875 28.31708,-57.72677 91.51367,-102.35489 139.07032,-133.86328l-26.7793,-21.49024C896.53697,588.11019 793.22595,665.67487 806.10938,786.48828L699.86133,787.5 568.0625,939.89258 429.48438,939.86328C578.06034,763.29892 745.82856,594.02803 899.1875,455.09961l-9.56836,-10.99023c-28.86687,-3.02061 -55.64392,-10.37642 -80.51758,-21.42774 -1.77605,4.17261 -4.43372,8.02096 -7.94336,11.23438C665.11643,558.39566 525.46983,665.166 419.78906,829.43164L392.45703,811.84766C501.69344,642.05529 644.58723,533.12674 779.21875,409.9375l17.51367,6.86328c-17.74437,-8.98707 -34.48695,-19.8921 -50.29101,-32.48437 -124.71285,29.03155 -208.27492,36.48099 -267.26758,31.98242 0,0 -19.31641,14.60547 -29.31641,14.60547 -15,0 -25.58008,-5.64453 -30.58008,-5.64453 -5,0 -10,5 -25,5 -15,0 -30,-25 -40,-50 -1.51422,-2.01895 -3.01443,-4.07919 -4.23242,-5.79297l-39.21875,30.25586 10.50977,-0.54493c7.17244,138.45299 -1.25836,281.23598 43.02929,408.13477l-27.41796,17.66602c-1.32891,-2.13106 -2.43311,-4.45616 -3.26758,-6.95704C288.22851,692.7888 295.29422,552.70428 289.59766,421.09961l-69.70313,53.77344 20.20508,-16.59375C187.08454,297.85994 265.54029,182.85491 300.0957,58.960938ZM85,80c-55.000004,50 -100.000004,145 -35,145 9.343263,0 15.215964,-5.70961 19.599609,-15.58984l-0.05469,54.80664C63.116922,255.80043 55.218717,250 45,250c-34.999996,0 -39.999996,70 -5,70 24.46345,0 22.957588,-43.08208 10.8125,-44.93164 53.48157,5.0855 -15.809214,250.16385 -15.302734,296.2207 0.268193,24.38822 6.628431,48.73678 31.46289,56.20899C48.176742,632.49354 35,645.1697 35,660 35,674.30844 47.265656,686.61054 65.384766,692.25586 41.674751,699.57565 35,720.74035 35,740 35,776.24391 48.1356,836.13212 55.517578,866.33008 82.604368,846.54619 106.08392,825.42866 128.83984,800.21875 132.14826,778.91478 135,756.88968 135,740 135,720.60063 128.2285,699.26867 104.15234,691.95898 118.02756,686.75065 129.28173,676.58841 135,660c0,-14.83344 -13.18185,-27.51102 -30.78711,-32.89844 24.05654,-8.65812 30.01787,-32.21714 30.27734,-55.8125C134.99671,525.23221 65.705931,280.15386 119.1875,275.06836 107.04241,276.91792 105.53655,320 130,320c35,0 30,-70 -5,-70 -10.83425,0 -19.06007,6.52154 -25.074219,15.02148L100.25195,209.2793C104.49041,218.99863 110.42097,225 120,225 185,225 140,130 85,80Zm641.48047,287.83789c-86.62544,19.83455 -151.78802,28.17022 -200.80469,29.24219 -14.2248,6.27415 -30.07191,11.92239 -45.7793,18.95898 58.99266,4.49857 142.55438,-2.95118 267.19727,-32.03711 -7.7527,-5.20716 -14.38853,-10.76914 -20.61328,-16.16406zm-370.49024,88.29102c29.62693,11.74538 64.9141,21.55877 110.0293,25.15039 51.3028,4.08421 115.55629,0.48608 200.56445,-14.4043C568.01187,553.99998 468.15967,644.25595 384.25,765.71289 359.23837,670.90747 359.53927,564.67648 355.99023,456.12891ZM1182.5,473.75c-24.0403,0 -48.0562,17.34722 -29.8594,52.02344A45,42.5 0 0 1 1182.5,515a45,42.5 0 0 1 29.8652,10.76367C1230.552,491.09427 1206.538,473.75 1182.5,473.75Zm-54.6914,47.48047c-45.2477,0.77462 -37.6424,97.7377 22.793,66.2168A45,42.5 0 0 1 1137.5,557.5a45,42.5 0 0 1 13.1113,-29.94336c-8.6891,-4.53343 -16.2978,-6.43753 -22.8027,-6.32617zm109.3828,0c-6.5027,-0.11132 -14.1076,1.79222 -22.793,6.32226A45,42.5 0 0 1 1227.5,557.5a45,42.5 0 0 1 -13.1094,29.94336c60.4429,31.53409 68.0505,-65.43824 22.8008,-66.21289zm-24.8301,67.99414A45,42.5 0 0 1 1182.5,600 45,42.5 0 0 1 1152.6348,589.23633c-11.9875,22.85174 -5.6311,38.16959 6.9726,45.95898 -23.6821,34.46419 -48.941,66.02584 -74.9492,96.20703C1079.1653,675.69528 1058.4509,645.45798 1005,670c37.225,16.12754 38.5709,70.31699 75.9492,65.69727 -5.8664,6.76063 -11.768,13.45662 -17.6972,20.10156l15.207,1.88672c7.2551,-8.19076 14.4623,-16.46748 21.6113,-24.85352 5.1929,39.08146 35.0698,-7.57452 67.2129,-5.5 -16.4802,-41.743 -32.0495,-10.50502 -66.4785,4.63672 24.5708,-28.86629 48.4073,-59.08334 70.8027,-91.95508 26.5679,6.12811 61.7407,-10.79807 40.7539,-50.78906zM1255,655c-32.9633,38.74398 -63.8666,77.97963 -125,110 16.8191,30.21345 26.6544,60.2083 30,90 47.2312,18.32372 82.8871,51.83723 115,90 2.3419,-37.0436 -4.2974,-71.38724 -30,-100 23.3498,-4.99857 40.0029,-20.01884 50,-45 -14.5281,-24.40208 -35.9759,-32.69918 -60,-35 44.8752,-32.16719 30.2665,-71.33926 20,-110zM811.88477,817.78516c10.86486,41.66548 35.34229,88.00659 78.58593,139.42382 -4.92291,-5.82285 -9.66276,-11.58316 -14.2207,-17.2539l-286.46289,-0.0586 64.60547,-0.45703 75.1914,-86.93945 93.88282,-0.33984c-4.9028,-11.9067 -8.74345,-23.39087 -11.58203,-34.375zM377.5,842.5c4.42321,0 9.31831,2.00257 14.86719,9.24023C397.91606,858.97789 402.5,871.0223 402.5,885c0,13.9777 -4.58394,26.0221 -10.13281,33.25977C386.81831,925.49743 381.92321,927.5 377.5,927.5c-4.42321,0 -9.31831,-2.00257 -14.86719,-9.24023C357.08394,911.0221 352.5,898.9777 352.5,885c0,-13.9777 4.58394,-26.02211 10.13281,-33.25977C368.18169,844.50257 373.07679,842.5 377.5,842.5Z"
        ></path>
      </symbol>
      <symbol id="SQ2" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="red"
          d="M557.51758,0 805.9668,330.45703 851.01367,311.99805 635.36719,0Zm78.02148,0 63.76563,90.75C709.99966,65.000167 725,65 725,65 716.50651,26.779299 728.31462,17.104416 733.20117,0ZM820,265 851.86719,312.33789C877.5079,304.49903 903.31958,298.22492 927.6543,293.26562 907.75762,290.72138 885.5191,284.6565 865,270c-10,5 -30,10 -45,-5zm99.12695,216.28711C764.14521,621.01648 595.55342,787.07572 470.35547,940.01172L525,940 685,755h120.41797l-0.0547,-0.41211c6.37431,-102.76161 97.50088,-170.65811 160.41211,-212.22851zm-727.41992,15.5625 -59.86133,46.34766 -0.39648,0.30468c1.93099,12.0459 3.10803,21.69313 3.04101,27.78711 -0.25947,23.59536 -6.2208,47.15438 -30.27734,55.8125C121.81815,632.48898 135,645.16656 135,660 129.28173,676.58841 118.02756,686.75065 104.15234,691.95898 128.2285,699.26867 135,720.60063 135,740c0,16.88968 -2.85174,38.91478 -6.16016,60.21875 -1.95154,2.162 -3.90854,4.29257 -5.87304,6.39453C138.56664,789.96704 153.92711,771.43051 170,750 200.25102,810.50205 230.44886,854.59181 266.85742,895.71484 221.90196,783.10482 193.58426,647.63449 191.70703,496.84961ZM44.53125,610.36133 0,644.61523V902.7832C30.797744,884.46615 56.707359,866.73637 80.427734,846.89844 72.427991,853.57027 64.158102,860.01913 55.517578,866.33008 48.1356,836.13212 35,776.24391 35,740 35,720.74035 41.674751,699.57565 65.384766,692.25586 47.265656,686.61054 35,674.30844 35,660 35,645.1697 48.176742,632.49354 66.972656,627.49805 56.528563,624.35562 49.361734,618.22105 44.53125,610.36133Zm1190.09765,68.79687 -1.1211,1.04688c-20.0542,23.0427 -41.8711,45.665 -71.7441,65.72265 27.117,39.37142 36.6532,80.37363 27.7441,123.12891 25.4392,14.76465 47.2329,33.87001 67.875,55.8418 -10.0896,-28.95393 -26.9566,-68.05217 -64.6191,-89.36328C1229.865,829.72137 1245.3631,819.51581 1260,800c-28.5778,-21.24841 -50.4759,-15.94491 -77.3027,-15.66992 39.149,-21.89578 49.9371,-64.78262 51.9316,-105.17188zM110.74609,819.23828c-0.7889,0.78628 -1.58065,1.56702 -2.37304,2.3457 0.792,-0.77791 1.58362,-1.55961 2.37304,-2.3457zm-5.15234,5.05078c-0.76819,0.74251 -1.53476,1.48679 -2.30664,2.22266 0.77112,-0.73534 1.53841,-1.48017 2.30664,-2.22266zm-5.26172,5.00586c-2.077449,1.94603 -4.165139,3.87648 -6.273436,5.7793 2.104356,-1.90192 4.194747,-3.83083 6.273436,-5.7793zm-6.539061,6.02149c-1.467973,1.32281 -2.945132,2.63598 -4.429688,3.93945 1.482456,-1.30407 2.961518,-2.61456 4.429688,-3.93945zM377.5,862.5a11,22.5 0 0 0 -11,22.5 11,22.5 0 0 0 11,22.5 11,22.5 0 0 0 11,-22.5 11,22.5 0 0 0 -11,-22.5zm225.17578,127.46484a10,10 0 0 0 -10,10 10,10 0 0 0 10,9.99996 10,10 0 0 0 10,-9.99996 10,10 0 0 0 -10,-10zM420,990a10,10 0 0 0 -10,10 10,10 0 0 0 10,10 10,10 0 0 0 10,-10 10,10 0 0 0 -10,-10zm91.13281,0.41016a10,10 0 0 0 -10,10.00004 10,10 0 0 0 10,10 10,10 0 0 0 10,-10 10,10 0 0 0 -10,-10.00004z"
        ></path>
      </symbol>
      <symbol id="SQ3" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="#44F"
          d="M472.5,150a12.5,20 0 0 0 -12.5,20 12.5,20 0 0 0 12.5,20 12.5,20 0 0 0 12.5,-20 12.5,20 0 0 0 -12.5,-20zm-140,5a12.5,20 0 0 0 -12.5,20 12.5,20 0 0 0 12.5,20 12.5,20 0 0 0 12.5,-20 12.5,20 0 0 0 -12.5,-20zm23.49023,301.12891c3.54904,108.54757 3.24814,214.77856 28.25977,309.58398 83.90967,-121.45694 183.76187,-211.71291 282.33398,-298.83789 -85.00816,14.89038 -149.26165,18.48851 -200.56445,14.4043 -45.1152,-3.59162 -80.40237,-13.40501 -110.0293,-25.15039zm42.92579,22.92187c22.57573,0.10326 52.52779,2.34383 83.49804,6.2461 65.74558,8.28415 118.15335,21.65893 117.05469,29.87304 -1.09829,8.2139 -56.30922,5.07893 -122.05273,-3.20508 -65.73948,-8.28354 -117.1185,-18.57868 -116.02735,-26.79296 0.53448,-4.02047 14.07178,-6.22853 37.52735,-6.1211zM1117.5,492.5c2.4011,8.40385 4.2266,18.24941 5.4746,28.84375v0.36133c7.3876,-1.36391 16.4655,0.0837 27.2324,5.62304l-21.2675,-21.26757a1.50015,1.50015 0 0 1 1.0449,-2.57617 1.50015,1.50015 0 0 1 1.0761,0.45507l21.2676,21.26758c-5.5291,-10.74776 -6.9807,-19.81297 -5.6289,-27.19336 -10.7286,-1.24895 -20.7021,-3.08593 -29.1992,-5.51367zm130,0c-8.4251,2.40718 -18.2988,4.23414 -28.9238,5.48242h-0.2793c1.3613,7.38557 -0.087,16.46062 -5.6231,27.22266l21.2657,-21.26563a1.50015,1.50015 0 0 1 1.0312,-0.45312 1.50015,1.50015 0 0 1 1.0898,2.57422l-21.2675,21.26757c10.7565,-5.53399 19.8272,-6.98416 27.2109,-5.62695v-0.17187c1.2486,-10.6649 3.081,-20.57644 5.4961,-29.0293zm-853.59961,15.25781c20.38428,0.10329 47.42876,2.34386 75.39258,6.2461 59.36368,8.28422 106.68388,21.65899 105.69141,29.87304 -0.99271,8.21355 -49.91699,8.15671 -109.27735,-0.12695 -59.36371,-8.28422 -106.68391,-21.659 -105.69141,-29.87305 0.48636,-4.01928 12.70935,-6.22659 33.88477,-6.11914zm7.69531,34.67969c15.09367,-0.0753 32.61454,0.81411 50.47852,2.5625 51.50146,5.04084 94.00823,14.75226 93.67578,23.00391 -0.32891,8.2521 -42.34749,10.85536 -93.84961,5.81445C400.39893,568.77752 358.91755,558.00165 359.25,549.75c0.20345,-5.08688 15.52034,-7.17888 42.3457,-7.3125zm590.81446,21.09375c-26.28817,17.83124 -58.00395,39.71623 -85.84375,65.82227L1063.252,755.79883c5.9292,-6.64494 11.8308,-13.34093 17.6972,-20.10156C1043.5709,740.31699 1042.225,686.12754 1005,670c53.4509,-24.54202 74.1653,5.69528 79.6582,61.40234 18.288,-21.22222 36.2025,-43.13214 53.4609,-66.25 -50.4965,-31.89003 -99.3677,-65.63189 -145.70894,-101.62109zm92.24804,167.87109c-1.2353,1.43353 -2.4703,2.86748 -3.709,4.29493 1.3064,-0.16146 2.6533,-0.388 4.0508,-0.69727 -0.1038,-1.21628 -0.2241,-2.40447 -0.3418,-3.59766zm-21.4062,24.39649 1.3242,1.02344C1092.8236,758.22045 1130,765 1130,765c33.2353,-17.40792 57.5278,-36.95014 78.082,-57.38477 -19.9562,-11.65548 -39.7017,-23.55345 -59.2109,-35.71875 -15.5528,20.88792 -31.6462,40.7815 -48.0664,60.07227 34.429,-15.14174 49.9983,-46.37972 66.4785,-4.63672 -32.1431,-2.07452 -62.02,44.58146 -67.2129,5.5 -7.149,8.38604 -14.3562,16.66276 -21.6113,24.85352zM399.88477,574.98828c12.13924,-0.0753 26.23048,0.81416 40.59765,2.5625 41.42116,5.04089 74.78321,15.81675 74.51563,24.06836 -0.26463,8.25206 -34.05885,10.85531 -75.48047,5.81445 -41.42116,-5.04089 -74.78321,-15.81675 -74.51563,-24.06836 0.16364,-5.08693 13.30756,-8.24338 34.88282,-8.37695zm814.90823,12.6836 21.2675,21.26757a1.50015,1.50015 0 1 1 -2.121,2.1211l-21.2657,-21.26563c5.5369,10.76367 6.9837,19.84044 5.6211,27.22656h0.3223c10.6094,1.24816 20.4685,3.07443 28.8828,5.47852 -2.4278,-8.49731 -4.2627,-18.47029 -5.5117,-29.19922 -7.3807,1.35234 -16.4468,-0.0994 -27.1953,-5.6289zm-64.5879,0.002c-10.7501,5.53028 -19.8161,6.98044 -27.1973,5.62695v0.0723c-1.2488,10.70195 -3.0853,20.64836 -5.5078,29.12695 8.4975,-2.42785 18.4701,-4.26471 29.1992,-5.51367 -1.3518,-7.38039 0.1,-16.44561 5.6289,-27.19336l-21.2676,21.26758a1.50015,1.50015 0 1 1 -2.121,-2.1211zM399.95117,608.2207c7.75591,-0.014 16.33902,0.59569 25.04883,1.7793 30.51033,4.14665 55.19775,16.74619 55.24414,25 0.0491,8.25469 -24.64792,11.5847 -55.16016,7.4375 -30.51033,-4.14665 -55.28173,-14.19933 -55.32812,-22.45312 -0.0324,-5.62262 11.68692,-11.73096 30.19531,-11.76368zm2.94141,36.28321c3.92832,-0.0157 8.00124,0.15115 12.10742,0.49609 25.08573,2.10744 44.77796,7.02839 45.42188,14.97852 0.64298,7.94981 -19.17087,12.68576 -44.25586,10.57812 -25.08573,-2.10744 -45.94398,-10.26081 -46.5879,-18.21094 -0.52278,-6.4668 13.79255,-7.76393 33.31446,-7.84179zm-6.3711,30.78125c1.53788,10e-4 3.10151,0.0612 4.67383,0.17968 15.24356,1.1523 28.12847,7.43255 28.7793,14.02735 0.6519,6.59512 -11.17778,11.00764 -26.42188,9.85547 -15.24356,-1.1523 -28.12847,-7.43255 -28.77929,-14.02735 -0.57317,-5.81151 8.60794,-10.04793 21.74804,-10.03515zm-2.7207,30.4707c0.97501,0.002 1.96625,0.0499 2.96289,0.14453 9.66123,0.91446 17.82809,5.89851 18.24219,11.13281 0.4126,5.23472 -7.08576,8.73687 -16.74805,7.82227 -9.66123,-0.91446 -17.82809,-5.89851 -18.24219,-11.13281 -0.3645,-4.61356 5.45528,-7.97697 13.78516,-7.9668zm906.19922,0.0781 -34.2773,2.85547c0.2249,20.00253 -6.7832,39.15319 -30.7188,56.31055 24.0241,2.30082 45.4719,10.59792 60,35 -9.9971,24.98116 -26.6502,40.00143 -50,45 19.6816,21.91005 28.1768,47.18324 30.0293,74.45312l0.01,0.008 24.957,11.09375zm-167.2656,64.20508c0.2372,0.44647 0.4708,0.89347 0.7051,1.33985 -0.2343,-0.44637 -0.4679,-0.89339 -0.7051,-1.33985zm3.041,5.88282c0.083,0.16606 0.171,0.33199 0.2539,0.49804 -0.083,-0.16604 -0.1705,-0.33202 -0.2539,-0.49804zm2.6758,5.48437c0.2147,0.45253 0.425,0.90499 0.6367,1.35742 -0.2117,-0.45239 -0.4219,-0.90493 -0.6367,-1.35742zm2.455,5.32422c0.1795,0.40036 0.3641,0.80089 0.5411,1.20117 -0.177,-0.40029 -0.3615,-0.80081 -0.5411,-1.20117zm2.5958,5.98437c0.2099,0.50184 0.413,1.00415 0.6191,1.50586 -0.2062,-0.5018 -0.4092,-1.00393 -0.6191,-1.50586zm2.0703,5.11719c0.1975,0.50277 0.4,1.00516 0.5937,1.50781 -0.1937,-0.50252 -0.3962,-1.00516 -0.5937,-1.50781zm2.3418,6.1875c0.1922,0.53072 0.3764,1.06121 0.5644,1.5918 -0.188,-0.53055 -0.3722,-1.06112 -0.5644,-1.5918zm1.7324,4.96485c0.2042,0.60477 0.4106,1.20984 0.6094,1.81445 -0.1988,-0.60461 -0.4051,-1.20971 -0.6094,-1.81445zm2.0273,6.26562c0.1846,0.60177 0.3579,1.20308 0.5371,1.80469 -0.1792,-0.60139 -0.3525,-1.20313 -0.5371,-1.80469zm1.4688,5.00977c0.1799,0.63781 0.3593,1.27644 0.5332,1.91406 -0.174,-0.63786 -0.3532,-1.27602 -0.5332,-1.91406zM377.5,842.5c-4.42321,0 -9.31831,2.00257 -14.86719,9.24023C357.08394,858.97789 352.5,871.0223 352.5,885c0,13.9777 4.58394,26.0221 10.13281,33.25977 5.54888,7.23766 10.44398,9.24023 14.86719,9.24023 4.42321,0 9.31831,-2.00257 14.86719,-9.24023C397.91606,911.0221 402.5,898.9777 402.5,885c0,-13.9777 -4.58394,-26.02211 -10.13281,-33.25977C386.81831,844.50257 381.92321,842.5 377.5,842.5Zm-0.27344,4.79492c2.95574,0.0879 5.94922,5.08008 5.94922,10.70508 10.93128,-0.11104 14.67749,3.31056 5.67578,13 13.69744,3.7436 10.6454,8.69968 2.83789,14 7.80751,5.30032 10.85955,10.2564 -2.83789,14 9.00171,9.68944 5.2555,13.11104 -5.67578,13 0,10 -9.4596,18 -11.35156,0 -10.93128,0.11104 -14.67748,-3.31056 -5.67578,-13 -13.69744,-3.7436 -10.6454,-8.69968 -2.83789,-14 -7.80751,-5.30032 -10.85955,-10.2564 2.83789,-14 -9.0017,-9.68944 -5.2555,-13.11104 5.67578,-13 0.82773,-7.875 3.10344,-10.77344 5.40234,-10.70508zm352.35742,5.20508 -75.1914,86.93945 43.0039,-0.041L744.44531,885H840l-15,-32.5zm29.72266,65 -19.23047,22.23633L876.25,939.95508 860,917.5Zm-104.13476,52.41992 -315.75977,0.17969c2.43984,2.47881 4.98787,4.87423 7.56641,7.28906 15.37025,14.39437 29.32058,28.43253 41.91015,42.12693 1.06974,-4.4442 6.04965,-11.1309 16.11133,-19.5156 -30,-25 -15,-34.99999 15,-15 30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -11.06914,7.3794 -20.08451,10.6644 -25.5625,10.6289 1.31057,1.4627 2.62767,2.9262 3.90625,4.3809l256.41797,-0.1328zm-170.01172,4.44531C490.60938,974.21875 499.75,977.5 511,985c30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -30,20 -45,10 -15,-15 -18.75,-15.625 -19.92188,-25.39063 -10.83984,-25.63477zm91,0C581.60938,974.21875 590.75,977.5 602,985c30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -30,20 -45,10 -15,-15 -18.75,-15.625 -19.92188,-25.39063 -10.83984,-25.63477z"
        ></path>
      </symbol>
      <symbol id="SQ4" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="black"
          d="M499.67383,0C598.83088,212.42554 698.5156,423.78371 891.07812,444.24805L557.50781,0ZM299.89844,59.855469C265.54099,182.85387 187.08454,297.85994 240.09961,458.2793L349.875,372.94531C322.20549,333.64118 300,282.28964 300,255c0,-20 5.00324,-149.9992 5,-155 -10e-4,-2.004308 -2.41143,-19.27436 -5.10156,-40.144531zM899.91016,454.8418C746.55122,593.77022 578.78424,763.04072 429.50781,939.46875l40.84766,0.54297C595.55342,787.07576 764.14431,621.01748 918.95508,481.37891Zm65.79101,87.45703c-28.87179,19.18723 -64.12524,44.12835 -93.97851,75.52344l25.55078,20.04296c30.22964,-29.84438 65.96002,-54.59002 95.59961,-73.97851 -9.28135,-6.87909 -18.47109,-14.10656 -27.17188,-21.58789zM685,755 525.10156,939.88281 570,940 699.86133,787.5H806.65039L805,755Z"
        ></path>
      </symbol>
      <symbol id="SQ5" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          stroke="#44F"
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="6"
          fill="none"
          d="M435,885A57.5,75.000002 0 0 1 377.5,960.00001 57.5,75.000002 0 0 1 320,885 57.5,75.000002 0 0 1 377.5,810 57.5,75.000002 0 0 1 435,885v0M417.07718,940H876.02627M308.27069,940h28.75722M339.49097,970H901.47783M131.84482,543.19629 351.03451,374.58883M6.9310566e-5,644.61533 44.832165,610.1291M1138.1663,665.18229C1077.9926,627.18313 1020.1253,586.55302 965.29601,542.45758M1208.5796,707.90733c-20.1878,-11.78458 -40.1599,-23.81534 -59.8906,-36.12132M557.51806,-3.5577172e-4 965.44559,542.57786M1299.7291,1059.765c-68.4773,39.2778 -116.7334,76.5733 -164.2838,131.8131 -44.9491,-77.8482 -93.9175,-130.6069 -160.20897,-192.68943 -76.05982,-71.23062 -114.27421,-131.59148 -129.3711,-180.42578 -15.09688,-48.8343 -8.90849,-86.60287 7.94922,-120.96875 28.31708,-57.72677 91.51285,-102.35515 139.0695,-133.86354M499.68528,0.03748108C598.83742,212.45251 698.51437,423.77834 890.34164,443.851M364.36489,812.31243C320.07724,685.41364 328.50886,542.63024 321.33642,404.17725c76.71711,39.85219 163.35704,77.44074 457.8821,5.76082C644.587,533.12731 501.69292,642.05444 392.45651,811.84681M355.97656,456.125c29.62956,11.74764 64.92126,21.56216 110.04297,25.1543 51.30556,4.08443 115.56309,0.48617 200.57813,-14.40625 -98.57798,87.12824 -198.39177,177.48156 -282.2461,298.86133 -24.96545,-94.92731 -24.7974,-201.06283 -28.375,-309.60938v0M867.34252,440.4065C719.62961,574.07588 560.4386,730.57461 436.09373,879.43791M223.89186,472.86906c-0.82324,183.16931 37.98603,343.48203 98.11552,466.27071M191.49798,496.71315c2.08648,150.92196 30.40471,286.39171 75.55251,398.73891M429.507,939.46794C578.78343,763.03991 746.55158,593.76963 899.91052,454.84121M470.35494,940.01166C595.55289,787.0757 764.14488,621.01728 918.95565,481.37871M525,940 685,755h120.41872M567.92551,940.0502 699.86133,787.5h106.78892M611.46541,939.39021 714.72266,820h97.2642M654.39213,939.43943 729.58398,852.5h93.89714M697.39662,939.39902 744.44531,885h95.04566M740.07521,939.73575 759.30664,917.5H860M906.39152,629.42293 1063.7852,756.67736M871.92369,617.813 1043.2441,757.01082M459.61865,481.34795C414.86903,573.51288 406.45192,669.62669 385,765M303.65592,-0.00221915C259.09343,162.78907 138.61386,327.07777 209.42337,483.4732M240.09997,458.27954C187.0849,297.86018 265.54056,182.85405 300.09597,58.960082M805.81085,330.134c14.88787,-6.44544 30.42237,-12.16006 46.14865,-17.2138M0.09725143,902.73906C71.866196,860.06685 117.03718,820.61709 170,750c50,100 99.8567,155.1639 176.97865,227.3892 281.56105,263.6842 94.15072,409.6105 -13.08443,480.4695M377.5,842.5c4.42321,0 9.31831,2.00257 14.86719,9.24023C397.91606,858.97789 402.5,871.0223 402.5,885c0,13.9777 -4.58394,26.0221 -10.13281,33.25977C386.81831,925.49743 381.92321,927.5 377.5,927.5c-4.42321,0 -9.31831,-2.00257 -14.86719,-9.24023C357.08394,911.0221 352.5,898.9777 352.5,885c0,-13.9777 4.58394,-26.02211 10.13281,-33.25977C368.18169,844.50257 373.07679,842.5 377.5,842.5v0M1130,765c16.8191,30.21345 26.6544,60.2083 30,90 47.2312,18.32372 82.8871,51.83723 115,90 2.3419,-37.0436 -4.2974,-71.38724 -30,-100 23.3498,-4.99857 40.0029,-20.01884 50,-45 -14.5281,-24.40208 -35.9759,-32.69918 -60,-35 44.8752,-32.16719 30.2665,-71.33926 20,-110 -32.9633,38.74398 -63.8666,77.97963 -125,110v0M1300,705.83334l-34.3239,2.86032M1299.9997,930.55544l-26.1711,-11.63161M1192.7269,836.42558c37.6985,20.41997 54.5672,59.51932 65.2796,89.01033M1182.9686,784.9233c26.555,-0.86899 48.4536,-6.17171 77.0314,15.0767 -14.6369,19.51581 -30.1358,29.72065 -67.2011,34.6433M1234.6287,679.15791c-1.9945,40.38926 -12.7829,83.27561 -52.2037,104.5774M1162.3431,745.42454c26.5383,39.87481 36.0743,80.87688 26.979,123.43436M1130,765c0,0 -82.1675,-15 -95,-5 -12.8325,10 -32.9691,31.30714 -40,40 -31.97044,39.52731 3.64509,49.72935 20,30M1050,800c-59.31161,25.45028 -64.22618,120.61499 20,25M1041.1933,853.52948c-14.9444,32.29436 0.7581,60.30105 58.5,-5.24847M1062.1853,882.59071C1040.9944,921.29246 1103.755,918.14402 1160,855M1063.2524,755.79961c33.572,-37.62441 66.2866,-76.82735 96.4461,-120.73492M1078.4582,757.6865c32.4929,-36.68328 64.0954,-75.00591 93.2554,-117.82589M1085,735c-4.9523,-58.0017 -25.4042,-90.06768 -80,-65 38.526,16.69119 38.6175,74.15849 80,65v0M1005,670c37.8073,-6.25375 56.1399,40.79694 80,65M1100,732.33169c35,-15 50.6726,-47.07119 67.2824,-5 -32.2824,-2.08351 -62.2824,45 -67.2824,5v0M1100.0662,732.84533c26.3257,8.26747 52.4616,-23.9051 67.2162,-5.51364M1155.0001,585.00001C1080.0001,630 1080,484.99999 1155,530c-45,-75 100,-75 55,0 75,-45 75,100 10e-5,55 45,75.00001 -100.0001,74.99999 -55,10e-6v0M1242.5,557.5c-60,0 -60,0 -60,-60 0,60 0,60 -60,60 60,0 60,0 60,60 0,-60 0,-60 60,-60v0M1122.9743,521.34338c-1.248,-10.59434 -3.0726,-20.43952 -5.4737,-28.84337 8.5766,2.45046 18.6544,4.30045 29.4977,5.54996M1146.7554,616.97813c-10.7509,1.24908 -20.7424,3.08971 -29.255,5.52188 2.4225,-8.47859 4.2581,-18.42426 5.5069,-29.12621M1241.9485,592.9857c1.2496,10.84959 3.1002,20.93331 5.5519,29.5143 -8.4143,-2.40409 -18.2735,-4.23021 -28.8829,-5.47837M1218.5761,497.98319c10.625,-1.24828 20.4988,-3.07601 28.9239,-5.48319 -2.4151,8.45286 -4.2469,18.3639 -5.4955,29.0288M357.95908,386.26136c-4.7848,-2.30618 -9.52375,-4.6875 -14.28345,-7.12611M748.06895,383.93902C622.45119,413.08814 538.88863,420.5377 479.79194,417.07826M355.99023,456.12891c29.62693,11.74538 64.9141,21.55877 110.0293,25.15039 51.3028,4.08421 115.55629,0.48608 200.56445,-14.4043C568.01187,553.99998 468.15967,644.25595 384.25,765.71289 359.23837,670.90747 359.53927,564.67648 355.99023,456.12891v0M85,135c10.787262,31.12992 5,90 35,90 65,0 20,-95 -35,-145 -55.000004,50 -100.000004,145 -35,145 30,0 24.21273,-58.87008 35,-90v0M40,285c0,0 0,-10 10,-10 12.88094,0 15,45 -10,45 -34.999996,0 -29.999996,-70 5,-70 30,0 40,50 40,50 0,0 10,-50 40,-50 35,0 40,70 5,70 -25,0 -22.88094,-45 -10,-45 10,0 10,10 10,10M120,275c-55,2.66831 15,250 14.49097,296.289C134.16784,600.67311 125,630 85,630 45,630 35.832163,600.67311 35.509031,571.289 35,525 105,277.66831 50,275M70,264.98358V208.33333M100,265.18883V208.74384M103.20611,627.39263C121.81764,632.48836 135,645.16656 135,660c0,19.32997 -22.38576,35 -50,35 -27.614237,0 -50,-15.67003 -50,-35 0,-14.8303 13.176786,-27.50627 31.782083,-32.60414M65.931232,692.4756C41.674852,699.57662 35,720.74035 35,740c0,36.24391 13.136211,96.133 20.364326,126.34321M128.36935,800.67704C132.14739,778.91407 135,756.88968 135,740c0,-19.39937 -6.77205,-40.73054 -31.46191,-47.67672M256.89224,885h6.38602M1.1417102e-4,884.99999 28.737098,885M245.57157,870h11.90122M2.5229169e-5,870.00002 51.088175,870M233.67034,855h18.57752M4.1609595e-5,854.99999 52.539543,855M222.93022,840h24.09272M7.6084636e-5,840.00001 49.346532,840M212.77064,825h29.89819M4.2336546e-5,825.00002 46.443795,825M203.1916,810h34.54258M4.0905762e-6,810.00002 43.541058,810M194.48339,795h38.89668M129.46208,795h5.22493M-3.8457096e-5,795.00001 40.638321,795M186.06545,780h42.96051M131.78427,780h14.51368M-3.1733115e-5,780.00001 38.316131,780M178.22806,765h46.73407M133.81618,765h24.67327M10,765H36.284215M134.68701,750h86.50156M10,750H34.542573M134.97728,735h83.01828M15,735H35.12312M132.65509,720H205M15,720H37.844594M155,705h45M325,510c-11.82334,-17.57111 -24.45521,-31.94743 -45.42097,-47.16261 -21.67788,-15.73198 -32.01525,9.6364 -23.86278,22.70472M325,540c-13.68399,-15.7169 -40.72661,-39.31758 -62.25684,-51.80699 -20.39713,-11.83211 -26.52283,15.09906 -9.53546,27.99468M326.64903,572.53873c-13.68399,-15.7169 -40.42328,-39.85576 -62.25684,-51.80699 -33.04187,-18.08643 -43.83934,14.15892 -2.74316,31.80699M329.68204,632.14459c-13.68399,-15.7169 -40.42328,-39.85576 -62.25684,-51.80699 -30.81157,-16.86561 -37.65608,16.8659 -5.11631,35.80661M328.06764,597.68777c-13.86078,-13.59047 -33.31597,-27.70524 -50.77313,-39.51278 -22.07438,-14.9305 -34.10496,4.47364 -22.83565,17.22609M332.19576,659.38835c-13.77031,-13.23256 -32.62008,-26.88451 -49.58329,-38.35795 -24.04479,-16.26322 -36.17268,12.27173 -19.25152,25.31598M335.48063,686.60634C319.24375,673.64242 295.51352,659.7442 277.4252,650.3376c-31.2697,-16.26141 -36.88691,20.47944 -3.29829,37.12122M339.44241,709.94356C293.812,671.34406 241.20364,684.64228 285,715M345.57813,743.85785c-49.78299,-42.23381 -140.14002,-42.27022 -51.45386,5.50004M359.15379,797.42734C296.30783,757.35598 217.41506,767.9862 315.25691,808.08817M356.15219,815.71589c-43.41581,-18.1629 -92.79129,0.20988 -43.97099,13.65755M335.79649,833.55074c-36.46249,-11.38361 -55.92576,9.42664 -11.42381,20.21059M323.63736,467.38673c-7.1925,-7.58612 -15.51039,-14.89158 -25.85855,-22.4014 -17.52111,-12.71535 -26.71907,0.32727 -25.12324,12.4885M322.15877,428.22708c-1.31784,-1.00168 -2.67007,-2.00587 -4.05887,-3.01374 -19.41173,-14.0874 -28.60717,3.4419 -24.22651,16.36102M351.5017,769.34668c-41.8286,-32.62324 -87.13007,-22.98664 -57.82646,2.59886M396.50984,805.03398c97.55186,1.04019 65.93584,25.61549 21.19412,25.63392M410.20409,785.71584c31.87867,-11.92022 60.58013,-9.17207 74.95842,-1.62887 16.81695,8.82258 14.04006,24.2047 -26.16419,30.34906M430.54986,757.7319c58.57662,-11.0001 103.69453,13.94896 55.48459,26.1888M451.62343,729.60393c67.42086,-18.09697 125.45489,10.74224 49.42624,33.66324M469.15226,707.61747c69.25339,-23.47062 135.42699,4.47512 67.15155,28.14525M497.03474,675.73394c50.50234,-8.00778 88.6752,9.66559 55.551,28.0217M514.06286,656.56715c77.25396,-19.94453 157.95502,17.262 48.7626,27.75334M550.91529,618.31036c57.1762,-5.00205 100.00874,18.02731 40.2256,35.03407M568.89077,600.93936c75.24789,-19.79781 151.84194,14.60918 51.22446,34.33609M596.84001,574.15634c55.64482,-7.64299 102.46778,11.7471 64.24628,28.76475M620.73761,552.10789c71.56974,-16.51587 140.66537,14.62009 53.45997,34.06378M660.73433,515.56983c57.1151,-4.52529 99.00079,18.87447 36.45506,35.78648M684.38719,494.58861c73.88041,-16.89549 144.8643,16.89901 43.68109,36.08147M722.79564,460.82624c57.76542,-5.50387 101.75016,17.65976 42.02455,34.7974M748.43052,437.7647c68.01755,-11.92015 127.59071,17.4385 43.80212,36.02686M645.55164,273.86211C640.4516,285.47932 635.59316,297.26013 610,295c-14.37233,81.30224 -73.77303,98.38804 -130,120 0,0 -19.41945,15.64589 -29.41945,15.64589C435.58055,430.64589 425,425 420,425c-5,0 -10,5 -25,5 -15,0 -30,-25 -40,-50 -30,-40 -55,-96.04455 -55,-125 0,-20 5.003,-149.9992 5,-155 -0.002,-3.089335 -5.72781,-42.445846 -10.1037,-72.07356M622.93321,240.32144C616.61632,250.552 609.19352,264.74236 615,265c2.73428,0.12132 6.96971,-10.37759 10.24354,-19.90618M904.16018,494.81448l50.56379,54.17549M889.99031,508.2039l48.73454,52.21558M875.34795,521.08709l48.01937,51.44933M861.63691,534.96812l46.15447,49.45122M847.01655,547.87487l45.96336,49.24646M832.83302,561.24966l35.28817,37.80876M818.66315,574.63908l24.02599,25.74214M803.86532,587.3557l17.84203,19.11646M790.06402,601.14003l8.92784,9.56554M482.75862,925h55.41872M495.89491,910h55.00821M508.21018,895h55.82923M521.34647,880h55.41872M534.48276,865h55.41872M552.95566,845H585M790,820v32.5M765,820v32.5M740,820v32.5M703.26765,833.26765l22.578,22.578M684.08867,854.08867l23.39901,23.39901M665.93596,875.93596l22.78325,22.78325M648.19376,898.19376l22.578,22.578M629.22003,919.22003l20.73071,20.73071M791.29599,310.75526c15.62961,-6.29692 31.83381,-11.83473 48.11454,-16.69002M776.15664,290.35133c15.84539,-6.35519 32.2728,-11.93292 48.76488,-16.81275M760.82223,270.4856c16.18061,-6.50419 32.97255,-12.19625 49.8241,-17.16102M746.54814,252.22866c16.42632,-6.7965 33.54246,-12.73644 50.75899,-17.91046M739.12096,229.17409c11.71799,-4.608 23.73402,-8.79725 35.84163,-12.5995M726.54679,208.22774c8.46394,-3.2756 17.07495,-6.33535 25.75602,-9.1911M711.68624,188.33917c5.39484,-2.00758 10.85695,-3.94932 16.37032,-5.82515M900.40882,94.431781C848.5463,114.25376 796.72828,69.769511 761.4322,93.621964 715,125.00001 755,185 789.33498,165.18883 821.13528,146.84017 790,105 775,115c-9.30261,6.20174 -14.88842,18.30946 -10,25 6.18042,8.45885 10.48873,9.62814 20,5M901.46652,97.13303C861.76115,135.4564 879.34663,201.01228 842.74068,222.52055 794.42332,250.91 757.5027,188.96753 790.17065,166.51363c30.25635,-20.79631 54.6061,25.32412 39.1205,34.55428 -9.60379,5.72429 -22.93675,5.55043 -26.86936,-1.74304 -4.972,-9.22111 -4.17161,-13.61293 4.10189,-20.20332M765,180l90,-60M845,160c-10,-10 -45.467,-11.35662 -55,5 22.00764,-11.03808 34.76336,-24.75676 25,-45M795,230c25,30 50,20 75,10 24.05541,32.7653 64.66095,38.66637 105,45M725,130C715,110 740,85 755,75 749.14905,51.948962 757.70702,26.00987 766.59362,0.00490542M700,90c10,-25 25,-25 25,-25 -8.48271,-38.172217 3.28893,-47.867055 8.18679,-64.93099617M427.96416,0.01822477C445.06535,51.748024 483.31343,78.400493 539.31946,83.994433M446.67053,0.04362022C462.63103,38.843647 492.03631,61.699978 533.14043,70.683071M461.24526,0.01603427C475.22521,27.447203 496.92922,45.718691 525.58366,55.74792M476.99588,0.10806452C487.38028,16.453559 500.99836,28.964352 517.63646,37.893813M371.26432,0.04443925C356.34418,40.196712 340.91798,80.075485 304.69652,100.28589M355.60874,0.04353776C343.34293,31.804187 329.13875,61.845937 302.67098,80.298673M339.57059,0.02060224C329.73362,23.196287 317.89132,44.53011 299.71459,59.883794M325.15652,0.08430598C317.46458,14.722402 308.27692,27.964826 296.26758,38.544057M305,120c41.1016,-25.066138 61.56092,-14.28714 80,0 20,55 -15,110 -14.41945,151.6763 0.21559,15.47674 11.72696,13.44856 19.41945,13.3237 4.99934,-0.0811 15,10 15,10M305,125c29.58587,-20.97635 55.47603,-17.50669 80,-5M430,245c20,0 20,30 5,30 -40,5 -40,-10 -5,0M365,315v10l5,-5 -5,-5v0M455,320l5,-5v10l-5,-5v0M370,320c0,0 5,5 10,5 5,0 5.24415,-4.00984 12.32219,-4.4848C400,320 400,325 405,325c5,0 15,-10 20,-10 5,0 15,5 20,5h10M390,340c3.06957,28.45212 45.6136,8.68856 45,5 -5,5 -44.77199,31.85105 -45,-5v0M430,135c51.53607,-36.718861 85.86501,-16.18211 120,5 -35.40475,-25.98218 -85,-45 -120,-5v0M540,160C525,160 503.52953,134.61544 483.61398,136.45137 453.79885,139.1999 445,175 430,180 447.93464,158.59181 463.7944,151.78059 478.07024,151.93493 507.27438,152.25068 515,185 550,175M430,180c15,-10 32.80939,10.04302 45.17423,9.94542C504.08195,189.71723 519.49385,175 530,175M380,175c-20,0 -30.87367,-19.1648 -47.03192,-20.29027 -12.3413,-0.85961 -29.19452,12.61246 -29.19452,17.61246 0,7.07107 11.23734,20.70784 22.74316,23.25836C342.90794,199.21402 362.81244,175.3491 380,175v0M305,165c22.64276,-42.75014 64.95345,-9.49214 65,-5M820,265c15,15 35,10 45,5 20.5191,14.6565 42.75671,20.72048 62.68286,23.22939M851.86653 312.33707C895.10619 299.11787 938.83136 290.34833 975 285C924.90149 188.22308 899.90057 94.152754 874.11725 -0.0019513659 M851.86653,312.33707C895.10619,299.11787 938.83136,290.34833 975,285 924.90149,188.22308 899.90057,94.152754 874.11725,-0.00195137M851.01315,311.99775 635.36748,-2.4089679e-4M927.65339,293.26472C907.75671,290.72048 885.5191,284.6565 865,270c-10,5 -30,10 -45,-5"
        ></path>
      </symbol>
      <symbol id="SQ6" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          stroke="#44F"
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="3"
          fill="none"
          d="M986.60333,811.20184l17.52527,26.83701m3.5763,5.47663 14.2883,21.88014M993.49031,800.86775c12.59499,20.81314 26.36539,39.79428 40.67199,57.93996m3.6811,4.63683c6.0574,7.57938 12.2001,15.02588 18.3803,22.41378m3.5795,4.26824c4.9357,5.87225 9.8895,11.71638 14.8372,17.56998M1002.2895,791.27746c25.6547,42.89167 56.3312,77.95704 86.5273,113.77117M1011.3206,782.24417c26.5981,44.89853 58.7236,81.18275 90.1523,118.55299M1018.2105,775.40469C1045.4382,820.51985 1078.1971,857.01507 1110,895M91.990234,409.08984c5.346491,34.39969 12.364566,69.89746 17.978516,99.54297 5.61395,29.64551 9.60751,54.84672 9.52344,62.49219 -0.14502,13.18721 -2.60383,25.09508 -7.35157,32.2207C107.39289,610.47133 101.33414,615 85,615 68.665861,615 62.607113,610.47133 57.859375,603.3457M95.230469,511.42383c2.783382,14.69817 5.162021,28.28252 6.812501,38.99023 1.65048,10.70771 2.46055,19.51658 2.44922,20.54688 -0.12561,11.42229 -3.03694,21.37127 -4.833987,24.06836 -1.554361,2.33286 -1.96098,2.67133 -3.316406,3.33203C94.986371,599.02203 91.780811,600 85,600M99.244141,641.85938C113.48363,645.75807 120,654.05348 120,660c0,3.87456 -2.13436,8.18273 -8.24609,12.46094C105.64218,676.73915 95.96981,680 85,680 74.030191,680 64.357824,676.73915 58.246094,672.46094M99.476562,706.76367c8.835718,2.48582 12.847888,6.43575 15.929688,11.99805C118.48805,724.32402 120,732.04575 120,740c0,15.20071 -2.70618,36.77501 -6.41016,58.11133M102.94922,660.2832C99.903483,662.33803 92.860098,665 85,665c-7.997241,0 -15.198086,-2.76015 -18.152344,-4.82812M102.28516,726.03125C103.52282,728.2651 105,733.94656 105,740c0,13.42041 -2.56634,34.6744 -6.189453,55.54492M726.75998,368.27894C639.85431,387.67178 574.6926,396.00751 524.83867,397.57475M715.61309,356.58894C649.94086,370.7787 597.12268,378.4618 554.16847,381.63062M703.03893,344.25945c-49.76763,10.38288 -91.8849,16.91189 -127.75629,20.52287M690.7875,331.76901c-38.30305,7.6982 -71.90839,13.04175 -101.50758,16.49148M680.13806,318.87243c-30.03631,5.82677 -57.08899,10.16495 -81.51547,13.25269M670.20516,305.76564c-23.347,4.36958 -44.8345,7.81564 -64.64196,10.45774M659.57286,292.71511c-18.04772,3.23925 -34.94556,5.91034 -50.78275,8.07274M390,380c11.94547,-13.95601 27.22073,-12.69836 45,0M440,195c10,15 30,15 45,15M310,205c50,25 60,-30 70,-30M350.01995,162.05531c1.14299,3.17833 1.7863,6.76631 1.7863,10.56373 0,13.03628 -7.58139,23.60427 -16.9335,23.60427 -9.35211,0 -16.93349,-10.568 -16.93349,-23.60427 0,-5.79795 1.49965,-11.10766 3.98776,-15.21654M488.55832,153.60687c1.90775,3.81995 3.02626,8.46304 3.02626,13.4703 0,13.03628 -7.58139,23.60427 -16.9335,23.60427 -9.35211,0 -16.93349,-10.568 -16.93349,-23.60427 0,-4.03258 0.72545,-7.82898 2.00436,-11.14943"
        ></path>
        <use xlink:href="#SSQ" height="90" transform="translate(1188,935)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1194,1043)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1096,1033)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1022,947)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(918,851)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(897,726)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
      </symbol>
      <rect width="239" height="335" x="-119.5" y="-167.5" rx="12" ry="12" fill="white" stroke="black"></rect>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ1"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ1"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ2"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ2"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ3"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ3"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ4"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ4"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ5"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ5"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ6"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ6"></use>
      <use xlink:href="#VSQ" height="32" x="-114.4" y="-156"></use>
      <use xlink:href="#SSQ" height="26.769" x="-111.784" y="-119"></use>
      <use xlink:href="#SSQ" height="55.68" x="36.088" y="-132.16"></use>
      <g transform="rotate(180)">
        <use xlink:href="#VSQ" height="32" x="-114.4" y="-156"></use>
        <use xlink:href="#SSQ" height="26.769" x="-111.784" y="-119"></use>
        <use xlink:href="#SSQ" height="55.68" x="36.088" y="-132.16"></use>
      </g>
      <use xlink:href="#XSQ" stroke="#44F" fill="none"></use>
    </svg>
  `;
  html = replaceAllFast(html, 'black', 'green');
  mDiv(dTable, {}, null, html);
  return;
}
function test100() {
  let keys = {};
  for (const k in CODE.di) { for (const k1 in CODE.di[k]) keys[k1] = CODE.di[k][k1]; }
  CODE.all = keys;
  CODE.keylist = Object.keys(keys)
  let inter = intersection(Object.keys(keys), Object.keys(window));
  let done = {};
  let tbd = ['_start'];
  let MAX = 1007, i = 0;
  let alltext = '';
  while (!isEmpty(tbd)) {
    if (++i > MAX) break;
    let sym = tbd[0];
    let o = CODE.all[sym];
    if (nundef(o)) o = getObjectFromWindow(sym);
    if (o.type != 'func') { tbd.shift(); lookupSet(done, [o.type, sym], o); continue; }
    let olive = window[sym];
    if (nundef(olive)) { tbd.shift(); lookupSet(done, [o.type, sym], o); continue; }
    let text = olive.toString();
    if (!isEmpty(text)) alltext += text + '\r\n';
    let words = toWords(text, true);
    for (const w of words) {
      if (nundef(done[w]) && w != sym && isdef(CODE.all[w])) addIf(tbd, w);
    }
    tbd.shift();
    lookupSet(done, [o.type, sym], o);
  }
  let tres = '';
  for (const k of ['const', 'var', 'cla', 'func']) {
    console.log('done', k, done[k])
    let o = done[k]; if (nundef(o)) continue;
    let klist = get_keys(o);
    if (k == 'func') klist = sortCaseInsensitive(klist);
    for (const k1 of klist) {
      if (isLetter(k1) && k1 == k1.toLowerCase()) continue;
      let code = CODE.justcode[k1];
      if (!isEmptyOrWhiteSpace(code)) tres += code;
    }
  }
}
function test100_partial_sequences() {
  let hand = ['AHn', '2Hn', '3Hn', '4Hn', '5Hn', '6Hn', '7Hn', '8Hn'];
  hand = ['AHn', '2Hn', '3Hn', '4Hn', '5Hn', '7Hn', '8Hn'];
  hand = ['4Hn', '7Hn', 'AHn', '2Hn', '5Hn', '6Hn', '3Hn', '8Hn'];
  hand = ['4Hn', '7Hn', 'AHn', '2Hn', '3Hn', '8Hn'];
  hand = ['4Hn', '7Hn', 'AHn', '2Hn', '9Hn', 'THn', 'QHn', '3Hn', '8Hn'];
  hand = ['4Hn', '7Hn', 'AHn', '2Hn', 'THn', 'QHn', '3Hn', '8Hn'];
  let items = hand.map(x => ferro_get_card(x));
  console.log('items', items);
  sortCardItemsToSequence(items);
}
function test11() {
  document.body.style.height = '100vh';
  let mobj = addDeckTo(makeDeck({ kind: 'deck52', N: 30, nJokers: 5 }), document.body, 'discardPile', true, true);
  mobj.setPos(0, -300);
}
function test11_besseresColoring() {
  var dMain = document.getElementById('dMain');
  mStyle(dMain, { bg: 'indigo' });
  let [dHeaderLeft, dTitle, dHeaderRight] = std3title(dMain, 'Aristocracy', { family: 'AlgerianRegular' });
  let [dLeft, dMiddle, dRight] = std3fold(dMain);
  let dFooter = mDiv(dMain, { bg: '#00000050' }, 'dFooter', 'footer');
  let bMenuLeft = stdMenuButton(dHeaderLeft);
  stdSidebarController(bMenuLeft, 'dLeft');
  let bMenuRight = stdMenuButton(dHeaderRight);
  stdSidebarController(bMenuRight, 'dRight');
}
function test11_cardcoloring() {
  let dTable = mBy('dTable'); clearElement(dTable);
  let card = ari_get_card('KHn');
  mAppend(dTable, iDiv(card));
  let d = mDiv(dTable, {}, null, queen_html());
}
function test11_function() {
  C = new Plotter(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc');
  C.add({ astep: .1, a: 0, bstep: .1, b: 0, color: 'skyblue', thickness: 1, basefunc: x => -x * (-Math.sign(x)), func: x => Math.sin(x), update: oscillator });
}
function test11_gengraph() {
  let items = create_nodes({ x: 0, y: 0, w: 500, h: 500 }, 20, 120);
  console.log('items', items, items[120]);
  dTable = toElem('map');
  plot_on_div(dTable, items);
  adjacency_init(items);
}
function test11_oest() {
  let map = M.map = create_map({ zoom: 7, center: Geo.cities.salzburg });
  let list = get_values(Geo.cities).filter(x => x.country == 'Austria');
  console.log('list', list);
  for (const c of list) {
    create_agent(map, c);
  }
}
async function test11_say() {
  say(germanize('wie fuehlst du dich gerade?'), 'pl', test12_iconviewer, 1, .8, .8);
}
function test12() {
  document.body.style.height = '100vh';
  let deck = makeDeck({ kind: 'deck52', N: 30, nJokers: 5 });
  clearElement(document.body);
  addDeckTo(deck, document.body, 'deck1', true, true);
}
function test12_backToPresent() {
  dMenu = mMenuLine(dMain);
  dMenu.style.display = 'block';
  let bToggle = mMenuButton(dMenu);
  let d = mDiv(dMain);
  mCenterFlex(d);
  let d1 = present_structured1(d, state);
  let sb = iSidebar(mDiv(d), d1, bToggle, 40, true);
}
function test12_cyto() {
}
function test12_europe() {
  let map = M.map = create_map({ zoom: 5, center: Geo.cities.stuttgart });
  let list = get_values(Geo.cities).filter(x => x.continent == 'Europe' && x.pop >= 1000000 && x.country == 'Austria');
  console.log('list', list);
  for (const c of list) {
    let m = create_fa(map, 'helicopter', c.center);
    break;
  }
}
function test12_fop() {
  let f = fprime('x*x'); let y = f(5); console.log('math.js y', y);
}
async function test12_iconviewer() {
  let items = findKeys('face').map(x => Syms[x]);
  items = KeySets['smileys-emotion'].map(x => Syms[x]);
  items = items.map(x => ({ key: x.key, text: x.text, E: x.E, D: x.D, family: x.family }));
  let items2 = Info.emotion.map(x => ({ key: x, E: x, D: '', family: 'opensans', text: '' }));
  sortBy(items2, 'key');
  items2 = arrRemoveDuplicates(items2, 'E');
  items = items.concat(items2);
  dTable = mBy('dTable');
  for (const item of items) ui_type_item(dTable, item, {}, null, item.key);
}
function test12_try_svg() {
}
function test13() {
  let d = document.body;
  dTable = mDiv(d, { box: true, padding: 4, w: '100vw', h: '100vh', bg: GREEN }, 'dTable');
  dFiddle = mDiv(dTable, { w: 200, h: 200, bg: RED, padding: 4 }, 'dFiddle');
  dTitle = mDiv(dFiddle, {}, null, 'Fiddle');
  AU.ta = mDom(dFiddle, { w: '100%', h: 'rest', bg: '#ffffff80' }, { id: 'ta', className: 'plain', tag: 'textarea' });
  console.log('AU.ta class', AU.ta)
}
function test13_doubleDD() {
  let dParent = addDivToBody();
  dParent.id = 'dParent';
  let d = addDivPosTo(dParent, 20, 50, 200, 200, unit = 'px', bg = 'red');
  let dTarget1 = addDivPosTo(dParent, 250, 50, 300, 200, unit = 'px', bg = 'purple');
  dTarget1.id = 'dTarget1';
  let dTarget2 = addDivPosTo(dTarget1, 50, 50, 200, 120, unit = 'px', bg = 'green');
  dTarget2.id = 'dTarget2';
  let pic = addPicto(d, 'whistle');
  pic.id = 'dPic';
  posXY(pic, dParent, 10, 20);
  pic.draggable = true;
  pic.ondragstart = drag;
  pic.isPic = true;
  dTarget1.ondragover = allowDrop;
  dTarget1.ondrop = drop;
  dTarget2.draggable = true;
  dTarget2.ondragstart = drag;
  dTarget2.isPic = false;
  dParent.ondragover = allowDrop;
  dParent.ondrop = drop;
}
function test13_get_the_div() {
  let map = M.map = create_map({ zoom: 5, center: Geo.cities.stuttgart });
  let dmap = document.getElementById('map');
  let dtiles = dmap.firstChild.firstChild;
  console.log('dtiles', dtiles);
}
function test13_load_yt_in_iframe() {
  var div = document.createElement('iframe');
  div.id = 'iframe1';
  mStyle(div, { w: 500, h: 300 })
  document.getElementById("map").appendChild(div);
  div.src = "https://www.youtube.com/embed/3pNpHZ1yv3I"; //YES!
  //iDiv.src = "https://www.youtube.com/embed/3pNpHZ1yv3I?autoplay=1";
}
function test13_makeDraggableTo() {
  let dParent = addDivToBody();
  dParent.id = 'dParent';
  let d = addDivPosTo(dParent, 20, 50, 200, 200, unit = 'px', bg = 'red');
  let dTarget1 = addDivPosTo(dParent, 250, 50, 300, 200, unit = 'px', bg = 'purple');
  dTarget1.id = 'dTarget1';
  let dTarget2 = addDivPosTo(dTarget1, 50, 50, 200, 120, unit = 'px', bg = 'green');
  dTarget2.id = 'dTarget2';
  let pic = addPicto(d, 'whistle');
  pic.id = 'dPic';
  posXY(pic, dParent, 10, 20);
  makeElemDraggableTo(pic, dTarget1);
  makeElemDraggableTo(dTarget2, dParent);
}
function test13_nerdamer() {
  nerdamer.setVar('M', 'matrix([1, 5], [4, 4])');
  var x = nerdamer('invert(M)');
  console.log(x.toString(), typeof x, x);
  var r = nerdamer('polarform(b*x+x*c*i)');
  console.log(r.toString());
  var t = nerdamer('polarform(5+i)')
  console.log(t.toString());
  nerdamer.setVar('M', 'matrix([x,y],[a,b])');
  console.log(nerdamer('transpose(M)').toString());
  nerdamer.setVar('M', 'matrix([4,5],[1,7])');
  x = nerdamer('determinant(M)');
  console.log(x.toString(), Number(x), typeof x, typeof Number(x), Number(x) + 1);
  console.log('==>', parseFloat(x));
  var x = nerdamer('limit(x^x-1,x,0)');
  console.log(x.toString());
  var y = nerdamer('limit((x^2+2*x-3)/(x^6+4),x,0)');
  console.log(y.toString());
  var x = nerdamer('solve(x^3+1, x)');
  console.log(x.toString());
  x = nerdamer.solve('x^2+2*x+1', 'x');
  console.log(x.toString());
  x = nerdamer.solve('3*(x+a)*(x-b)', 'x');
  console.log(x.toString());
  x = nerdamer.solve('3*(x+a)*(x-b)', 'x');
  console.log(x.toString());
  x = nerdamer('solve(x^4=1,x)');
  console.log(x.toString());
  x = nerdamer('solve(y=m*x+c, x)');
  console.log(x.toString());
  x = nerdamer.solve('x^2-1', 'x');
  console.log(x.toString());
  x = nerdamer.max(1, 4, 3, 5);
  console.log(x.toString());
  var x = nerdamer('sqcomp(9*x^2-18*x+17)');
  console.log(x.toString());
  var y = nerdamer('sqcomp(a*x^2+b*x-11*c, x)');
  console.log(y.toString());
  var x = nerdamer('roots(x^2-3*x-10)');
  console.log(x.toString())
  var y = nerdamer('roots(x^2+1)');
  console.log(y.toString());
  var x = nerdamer('divide(x^2+2*x+1, x+1)');
  console.log(x.toString())
  var y = nerdamer('divide(-b*z-a*z+b^3+a*b^2+a*b+a^2, b+a)');
  console.log(y.toString());
  var x = nerdamer('gcd(x^2+2*x+1, x^2+6*x+5)');
  console.log(x.toString())
  var y = nerdamer('gcd(b*z+a*z+b^2+a*b, a+b)');
  console.log(y.toString());
  var z = nerdamer('gcd(24,12,552)');
  console.log(z.toString());
  var x = nerdamer('product(x+1, x, 1, 20)');
  console.log(x.toString())
  var y = nerdamer('product(x+y, x, 1, 5)');
  console.log(y.toString());
  var z = nerdamer('product(x, x, 1, 5)');
  console.log(z.toString());
  var x = nerdamer('sum(x+1, x, 1, 5)');
  console.log(x.toString())
  var y = nerdamer('sum(x+y, x, 1, 20)');
  console.log(y.toString());
  console.log('_______simplify')
  var x = nerdamer('simplify((x^2+4*x-45)/(x^2+x-30))');
  console.log(x.toString());
  var y = nerdamer('simplify((17/2)*(-10+8*i)^(-1)-5*(-10+8*i)^(-1)*i)');
  console.log(y.toString());
  var z = nerdamer('simplify(1+1+3+5+13)');
  console.log(z, typeof z, Number(z) + 1);
  console.log('_______ defint')
  var x = nerdamer('defint(e^(cos(x)), 1, 2)');
  console.log(x.text());
  var y = nerdamer('defint(x^2+2*x+1,0, 10)');
  console.log(y.text());
  var y = nerdamer('defint(log(2cos(x/2)),-π,π,x)');
  console.log(y.text());
  console.log('_______ derivative diff')
  var x = nerdamer('diff(cos(x)*sin(x), x)');
  console.log(x.toString());
  var y = nerdamer('diff([x^2, cos(x), 1], x, 2)');
  console.log(y.toString());
  var y = nerdamer('diff(x^3+a*x^3+x^2, x, 2)');
  console.log(y.toString());
  x = nerdamer.diff(nerdamer('x^2').add(1).multiply('tan(x)'), 'x')
  console.log(x.toString());
  x = nerdamer('diff(a+b*x+c*x^2, x)');
  console.log(x.toString());
  x = nerdamer('diff(x^2, x)');
  console.log(x.toString());
  var x = nerdamer('sin(9+5)');
  console.log(x.toString());
  console.log(x.evaluate().toString());
  var x = nerdamer('integrate(x*2,x)');
  console.log(x.toString());
  y = x.evaluate();
  console.log('eval:', y);
  var x = nerdamer('integrate(10*q/(4*x^2+24*x+20), x)');
  console.log(x.toString());
  var y = nerdamer('integrate(sec(x)^2, x)');
  console.log(y.toString());
  var y = nerdamer('integrate([sec(x)^2, x^2, 2], x)');
  console.log(y.toString());
  var x = nerdamer('integrate(cos(x)*x^6, x)');
  console.log(x.toString());
  console.log(x.hasIntegral());
  x = nerdamer.integrate('sinh(x)*e^x');
  console.log(x.toString());
  var e = nerdamer('x^2+2*(cos(x)+x*x)', { x: 6 }).evaluate();
  var e = nerdamer('x^2+2*(cos(x)+x*x)', { x: 6 });
  var e = nerdamer('x^2+2*(cos(x)+x*x)', { x: 6 }).evaluate();
  console.log(e.text());
  console.log(e);
  var e = nerdamer('x^2+2*(cos(x)+x*x)');
  console.log(e.text());
  console.log(e);
  var result = nerdamer('cos(x)', { x: 6 });
  console.log(result.text());
  var result = nerdamer('cos(x)', { x: 6 }, 'numer');
  console.log(result.text());
  var result = nerdamer('cos(x)', { x: 6 }).evaluate();
  console.log(result.text());
  var f = nerdamer('integrate(x,x)').buildFunction();
  console.log(f(3));
  f = nerdamer('diff(x^3,x)').buildFunction();
  console.log(f(20));
}
function test13_simpleDD() {
  document.body.style.height = '100vh';
  let dParent = addDivToBody();
  dParent.id = 'dParent';
  let d = addDivPosTo(dParent, 20, 50, 200, 200, unit = 'px', bg = 'red');
  let purpleTarget = addDivPosTo(dParent, 250, 50, 300, 200, unit = 'px', bg = 'purple');
  let greenTarget = addDivPosTo(purpleTarget, 50, 50, 200, 120, unit = 'px', bg = 'green');
  let pic = createPicto({ key: 'whistle', parent: d, bg: 'yellow', border: '1px solid green', rounding: 12 });
  pic.type = 'pic';
  makeDraggable(pic);
  makeDroppable(purpleTarget);
  dropPosition = (ev, elem, target) => { posOverlap(elem, target, 10, 5, 'type'); };
}
function test13_simpleDDMultiple() {
  let dParent = addDivToBody();
  dParent.id = 'dParent';
  let purpleTarget = addDivPosTo(dParent, 250, 50, 300, 200, unit = 'px', bg = 'purple');
  let greenTarget = addDivPosTo(purpleTarget, 50, 50, 200, 120, unit = 'px', bg = 'green');
  let d = addDivPosTo(dParent, 20, 50, 200, 200, unit = 'px', bg = 'red');
  for (let i = 0; i < 7; i++) {
    let k = getRandomKey(iconChars);
    let pic = createPicto({ key: k, parent: d, bg: 'yellow', border: '1px solid green', rounding: 12 });
    pic.type = 'pic';
    posOverlap(pic, d, 120, 0, 'type');
    makeDraggable(pic);
  }
  makeDroppable(purpleTarget);
  dropPosition = (ev, elem, target) => { posOverlap(elem, target, 10, 5, 'type'); };
}
function test14() {
  show_emos();
  say('what do you feel right now???', 'uk', null, .5, .8);
}
function test14_divPosTest() {
  let dParent = addDivToBody();
  dParent.style.setProperty('float', 'right');
  dParent.style.setProperty('margin', '10px');
  setDivBg(dParent, 'green');
  setDivSize(dParent, 300, 200);
  let d = addDivPosTo(dParent, 20, 50, 100, 100, unit = 'px', bg = 'red');
}
function test14_factory() {
  let d = mSym('frog', 'map');
}
function test14_function() {
  C = new Plotter(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc');
  C.add({ astep: .1, a: 0, bstep: .1, b: 0, color: 'skyblue', thickness: 1, basefunc: x => -x * (-Math.sign(x)), func: x => Math.sin(x), update: oscillator });
  C.play();
}
function test15() {
  let d = document.body; mClass(d, 'fullpage');
  let areas = [
    'dTestButtons dTestButtons',
    'dSearch dSidebar',
    'dFiddle dSidebar',
    'dTable dSidebar',
  ];
  let cols = '1fr 200px';
  let rows = 'auto auto auto 1fr';
  dGrid = mGridFrom(d, areas, cols, rows);
  for (const ch of arrChildren(dGrid)) {
    console.log('rect', ch.id, getRect(ch))
  }
  mStyle(dGrid, { fg: 'white', bg: 'silver' })
  test15_weiter();
}
function test15_addDivU() {
  let dParent = addDivU({ dParent: document.body, bg: 'yellow', margin: 10, w: 300, h: 200, unit: 'px', float: 'right' });
  let d = addDivU({ dParent: dParent, x: 20, y: 50, w: 100, h: 100, unit: 'px', position: 'absolute', bg: 'red' });
}
function test15_fa_list() {
  dTable = mBy('map');
  let animations = ['beat', 'bounce', 'fade', 'flip', 'pulse', 'shake', 'spin'];
  let iani = 0;
  let list = Info.fa;
  for (const w of arrTake(list, 25)) {
    let an = 'pulse';
    let d = mDiv(dTable, { align: 'center', bg: 'blue', margin: 8, fg: 'white', display: 'inline-block', padding: 10 }, null, `<i class="fa fa-${w} fa-${an} fa-3x"></i><br>${w}`);
  }
}
function test15_function() {
  C = new Plotter(dTable);
  C.add({ color: 'skyblue', thickness: 1, func: x => Math.sin(x) });
  C.draw();
}
function test15_qa() {
  G = {
    i: 0,
    q: null,
    alist: null,
    selist: null,
    hist: [],
    stcont: { box: true, wmin: 600 },
    sta: { cursor: 'pointer', aitems: 'center', vpadding: 6, hpadding: 12, gap: 4, margin: 6, rounding: 12, fg: 'contrast' },
    stq: { padding: 12, weight: 'bold', family: 'opensans', fz: 28 },
  };
  q0();
}
function test15_weiter() {
  mStyle(dFiddle, { padding: 4, h: 400 });
  mClear(dFiddle)
  dTestButtons.innerHTML = 'Test Buttons'
  mDom(dFiddle, {}, { html: 'Fiddle' })
  AU.ta = mDom(dFiddle, { w100: true, hrest: true, bg: '#ffffff80' }, { tag: 'textarea', id: 'ta', className: 'plain hop1' });
  console.log('AU.ta', AU.ta)
}
function test16() {
  let d = document.body; mClass(d, 'fullpage');
  let areas = [
    'dTestButtons dTestButtons',
    'dSearch dSidebar',
    'dFiddle dSidebar',
    'dTable dSidebar',
  ];
  let cols = '1fr 200px';
  let rows = 'auto auto auto 1fr';
  dPage = mGridFrom(d, areas, cols, rows);
  mStyle(dPage, { fg: 'white', bg: 'silver' })
  mStyle(dFiddle, { h: 400, padding: 14, box: true });
  mDom(dFiddle, {}, { html: 'Fiddle' });
  AU.ta = mDom(dFiddle, { w100: true, box: true, h: 'rest', bg: '#ffffff80' }, { tag: 'textarea', id: 'ta', className: 'plain hop1' });
  maButton('test', onclickTest, dTestButtons, { className: 'a' });
}
function test16_fa_animation() {
  dTable = mBy('map');
  let fa = rChoose(Info.fa);
  mCenterCenterFlex(dTable); mStyle(dTable, { bg: 'white', position: 'relative' });
  let d0 = mDiv(dTable); mStyle(d0, { rounding: '50%', align: 'center', bg: 'blue', fg: 'white', display: 'inline-block' })
  let dfa = mDiv(d0, { padding: 40, }, null, `<i class="fa fa-${fa} fa-2x"></i>`);
}
function test16_function() {
  C = new Plotter(dTable);
  C.add({ color: 'skyblue', thickness: 1, func: nerdamer('integrate(x,x)').buildFunction() });
  C.draw();
}
function test16_g() {
  let dParent = addDivToBody();
  let g1 = addGFill('g1', dParent);
  let g2 = d3.select(g1).append('g').attr('fill', 'yellow').attr('stroke', 'black').attr('stroke-width', 5);
  g2.append('rect').attr('width', '50px').attr('height', '50px');
  let g3 = d3.select(g1).append('g').attr('fill', 'red').attr('stroke', 'white').attr('stroke-width', 5);
  let r3 = g3.append('rect').attr('width', '50%').attr('height', '50px');
  g3.node().style.transform = 'translate(-10px, -200px)';
  let g = g3.node();
  g.classList.add('green');
  g.classList.add('yellowStroke');
  let cl = g.classList;
  console.log(cl, typeof cl, cl.value, typeof cl.value);
  let cl2 = g.getAttribute('class')
  console.log(cl2, typeof cl2);
  console.log(g.getAttribute('class'))
  g.classList.remove('yellowStroke');
  let boundsG1 = getBounds(g1);
  let boundsG2 = getBounds(g2.node());
  let boundsG2_rel = getBounds(g2.node(), true);
  let boundsG3 = getBounds(g3.node());
  let boundsG3_rel = getBounds(g3.node(), true);
  let boundsDiv = getBounds(dParent);
  console.log('boundsG1', boundsG1)
  console.log('boundsG2', boundsG2)
  console.log('boundsG2_rel', boundsG2_rel)
  console.log('boundsG3', boundsG3)
  console.log('boundsG3_rel', boundsG3_rel)
  console.log('boundsDiv', boundsDiv)
  return;
  d3.select(g2).style('transform', 'translate(50%, 50%)')
  //first import d3.js: <script src="https://d3js.org/d3.v5.min.js"></script>
  let r = d3.select(g1).attr('fill', 'red').append('rect').attr('width', '100px').attr('height', '100px');
  console.log('g1', d3.select(g1).node());
  console.log('r', r.node());
  let rect = d3.select(g1.children[0]);
  console.log(rect, r);
  r.attr('stroke', 'green').attr('stroke-width', 5).attr('rx', 20).attr('ry', 20);
}
function test16_yt() {
  playt();
}
function test16a() {
  let d = document.body; mClass(d, 'fullpage');
  let areas = [
    'dTestButtons dTestButtons',
    'dSearch dSidebar',
    'dFiddle dSidebar',
    'dTable dSidebar',
  ];
  let cols = '1fr 200px';
  let rows = 'auto auto auto 1fr';
  dPage = mGridFrom(d, areas, cols, rows, { padding: 4, box: true });
  mStyle(dPage, { fg: 'white', bg: 'silver' }); 
  let elem = mSearch('keywords:',mySearch,dSearch); 
  mStyle(dFiddle, { h: 400 }); 
  mDom(dFiddle, {}, { html: 'Edit Code:' });
  AU.ta = mDom(dFiddle, { w100: true, box: true, h: 'rest', bg: '#ffffff80' }, { tag: 'textarea', id: 'ta', className: 'plain hop1' });
  mFlex(dTestButtons);
  mButton('TEST', onclickTest, dTestButtons); 
}
function test17_load_save_texte() {
  mStyle(dTable, { h: '100%', family: 'opensans', fz: 20, bg: ORANGE, fg: 'white', position: 'relative' }); mCenterFlex(dTable);
  let buttons = ['clear', 'magic'];
  dToolbar = mToolbar(buttons, onclick_toobar, 'dToolbar', { padding: 10, display: 'flex', gap: 10, bg: 'orange' });
  document.addEventListener('mouseleave', e => { console.log('page mouse left!!!'); save_all(); })
  document.addEventListener('visibilitychange', e => { if (document.visibilityState === 'visible') { console.log('page activated!'); } else { console.log('page deactivated!!!'); save_all(); } });
  load_all();
  onclick = open_invisible_input;
}
function test17_randomwalk() {
  C = new CCanvasNoClear(dTable, {}, {}, gameloop_start, gameloop_stop);
  C.add({ update: move_random, w: 2, h: 2 });
  C.add(new CItemWalker({ label: 'tom' }))
  C.play();
}
function test1ttt() {
  let board = new Board(dTable, 4, 4, ev => {
    let field = Items[ev.target.id];
    console.log('field', field);
    if (isdef(field.content)) return;
    let item = { field: field, container: ev.target, styles: { bg: 'red', w: 30, h: 30, rounding: '50%' } };
    game_add_item(item);
  });
}
function test2() {
}
function test2_2rows() {
  var dMain = document.getElementById('dMain');
  let dHeader = mDiv(dMain, {}, 'dHeader', 'header', ['div1']);
  let dOuter = mDiv(dMain, {}, 'dOuter', 'outer', ['div2']);
}
function test2_ari_deck_and_hand(otree) {
  let deck = ui_make_random_deck(10);
  let hand = ui_make_random_hand(1);
  let d = iDiv(deck.topmost);
  deck.items.map(x => { mStyle(iDiv(x), { cursor: 'pointer' }); iDiv(x).onclick = () => anim_from_deck_to_hand(x, deck, hand); });
}
function test2_boa_verify() {
  mAppear('dScreen', 100);
  if (FirstLoad) { FirstLoad = false; initialize_state(); }
  get_toolbar();
  onclick_location('boa');
  boaverify_start();
}
function test2_nerd() {
  var core = nerdamer.getCore();
  var _ = core.PARSER;
  core.Math2.custom = function (x) { return (100 * formula1(x)).toFixed(4); };
  _.functions.custom = [, 1];
  var x = nerdamer('custom(140)').evaluate();
  console.log(x.toString());
  let fi = nerdamer(`integrate(custom(x),x)`).buildFunction();
  let y = fi(100);
  console.log('fi(100)', y)
}
function test2_onclick_user() {
  let ms = 300;
  show_users(300);
  setTimeout(() => onclick_user('felix'), 400);
}
function test2_p5_perlin() {
  dTable = mBy('dTable'); mCenterFlex(dTable);
  let o = mCanvas(dTable, { w: 600, h: 400 }, {}, startloop, pauseloop, 'cc');
  iAdd(o, {}, { draw: draw_perlin_x });
  o.play();
}
function test2_pic_dicts() {
  create_pic_dicts(['d']);
}
function test2_point_nomath() {
  C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop);
  C.add();
  C.add({ x: -200, y: 100, color: 'pink', draw: draw_point });
  C.draw();
  C.play();
}
function test2_show_contacts() {
  get_login();
}
function test2_sit_around_table() {
  dTable = mBy('dTable');
  let r = getRect(dTable);
  let sz = 250;
  let pts = cCircle({ x: r.w / 2, y: r.h / 2 }, r.w - sz, 6, -90);
  for (const pt of pts) {
    console.log('pt', pt)
    mDiv(dTable, { round: true, x: pt.x - sz / 2, y: pt.y - sz / 2, position: 'absolute', w: sz, h: sz, bg: 'randdark' });
  }
}
async function test2_two_maps() {
  let [cities, capitals] = await get_cities_and_capitals();
  let o = { center: cities.Paris.center, zoom: 7, id: 'map' };
  let m1 = create_map(jsCopy(o));
  copyKeys({ id: 'map2', preferCanvas: true }, o);
  let m2 = create_map(o);
  let a1 = create_agent(m1);
  let a2 = create_agent(m2);
  let f1 = x => x + rFloat(-.01, .05);
  let f2 = x => x + rGaussian(-.01, .05);
  run_for_seconds(2, () => { map_moveby(a2, f2, f2); map_moveby(a1, f1, f1); })
}
function test2_waypointfallback() {
  var map = L.map('map');
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);
  console.log('geo', Geo)
  let [p1, p2] = [Geo.places.tuerkenschanzpark, Geo.places.vegagasse];
  map.setView(p1, 16)
  M = L.Routing.control({
    waypoints: [
      L.latLng(p1[0], p1[1]),
      L.latLng(p2[0], p2[1])
    ],
    waypointNameFallback: function (latLng) {
      function zeroPad(n) {
        n = Math.round(n);
        return n < 10 ? '0' + n : n;
      }
      function sexagesimal(p, pos, neg) {
        var n = Math.abs(p),
          degs = Math.floor(n),
          mins = (n - degs) * 60,
          secs = (mins - Math.floor(mins)) * 60,
          frac = Math.round((secs - Math.floor(secs)) * 100);
        return (n >= 0 ? pos : neg) + degs + '°' +
          zeroPad(mins) + '\'' +
          zeroPad(secs) + '.' + zeroPad(frac) + '"';
      }
      return sexagesimal(latLng.lat, 'N', 'S') + ' ' + sexagesimal(latLng.lng, 'E', 'W');
    },
    routeWhileDragging: true
  }).addTo(map);
}
function test20_aspect_ratio_image_card() {
  let d = mDiv(dTable, { display: 'grid', place: 'center', h: '100%' });
  let dcard = mDiv(d, { w: '50%', display: 'flex', dir: 'column', padding: '1rem' }, null, null, 'blue');
  let dtitle = mTag('h1', 'Video Title', dcard);
  let dimg = mDiv(dcard, { aspectRatio: '16 / 9' }, null, null, 'green');
  let ddesc = mTag('p', 'Descriptive Text goes here', dcard);
  return d;
}
function test20_imagePalette(dTable) {
  let pal = colorPaletteFromUrl('../base/assets/images/happy/ocean1.jpg');
  let hslist = pal.map(x => colorHSL(x, true));
  let i = 0; hslist = hslist.map(x => ({ h: x.h, s: x.s, l: x.l, color: pal[i], ipal: i++ }))
  i = 0; let byhue = sortBy(hslist, 'h').map(x => ({ color: x.color, ipal: x.ipal, ihue: i++, h: x.h, s: x.s, l: x.l }));
  i = 0; let bylum = sortBy(byhue, 'l').map(x => ({ color: x.color, ilum: i++, ihue: x.ihue, h: x.h, s: x.s, l: x.l }));
  let dmax = 0, c1max, c2max;
  let dlist = [];
  for (let i = 0; i < bylum.length - 1; i++) {
    for (let j = i + 1; j < bylum.length; j++) {
      let [c1, c2] = [bylum[i], bylum[j]];
      let d = colorDistance1(c1, c2);
      dlist.push({ c1: c1, c2: c2, d: d });
      if (d > dmax) { dmax = d; c1max = c1; c2max = c2; }
    }
  }
  sortByDescending(dlist, 'd');
  let lums = [2, 9];
  let hues = [6, 7];
  dlist = dlist.filter(x => x.d >= 30 && (lums.includes(x.c1.ilum) || hues.includes(x.c2.ihue)));
  console.log('===>result', dlist)
  let bestof = arrTake(dlist, 5);
  let crand = rChoose(bestof);
  mStyle(mBy('dAdmin'), { bg: crand.c2.color, fg: crand.c1.color });
  console.log('chosen:', crand.c1.color, crand.c2.color, crand.d);
}
function test21_centering_container() {
  let d = mDiv(dTable, { bg: 'yellow', w: '100%', h: '100%' }); mCenterCenter(d);
  let d1 = mDiv(d, { bg: 'red', 'place-content': 'center', w: '80%', display: 'grid', 'grid-template-columns': 'repeat(auto-fill, 100px)', 'grid-gap': '1rem' });
  for (let i = 0; i < 14; i++) {
    mDiv(d1, { w: rNumber(50, 150), h: 100, bg: 'random', margin: 10 });
  }
}
function test21_resizable() {
}
function test22_centering_container() {
  let d = mDiv(dTable, { bg: 'yellow', w: '100%', h: '100%', aitems: 'center' }); mCenterCenter(d);
  for (let i = 0; i < 14; i++) {
    mDiv(d, { display: 'inline-block', w: rNumber(50, 150), h: rNumber(50, 150), bg: 'random', margin: 10 });
  }
}
function test3() { test1(); }
function test3_3rows() {
  var dMain = document.getElementById('dMain');
  let dHeader = mDiv(dMain, { bg: 'random' }, 'dHeader', 'header');
  let dOuter = mDiv(dMain, { bg: 'random', flex: '1 0 auto' }, 'dOuter', 'outer');
  let dFooter = mDiv(dMain, { bg: 'random' }, 'dFooter', 'footer');
  mSize(dHeader, '100%', 50);
}
function test3_add_cities_layer(color) {
  let cities = rChoose(M.capitals, 20);
  for (const c of cities) map_add_city(M.cities[c]);
}
function test3_ari_deck_2_hands(otree) {
  let deck = ui_make_random_deck(10);
  let hand1 = ui_make_random_hand(1);
  let hand2 = ui_make_random_hand(1);
  let d = iDiv(deck.topmost);
  top_card_to_hands_abwechselnd(deck, hand1, hand2);
}
async function test3_better_agent() {
  M = create_map();
  console.log('M', M);
  let agent = new Agent(M, .0001, false);
  let c1 = create_button(M.map, 'hallo')
  let c2 = create_button(M.map, 'h2')
  let c3 = create_button(M.map, 'h3')
  console.log('buttons', c1, c2, c3)
}
function test3_boa_havecode() {
  mAppear('dScreen', 100);
  if (FirstLoad) { FirstLoad = false; initialize_state(); }
  get_toolbar();
  onclick_location('boa');
  S.boa_authorization_code = '123456';
  boahavecode_start();
}
function test3_cdf() {
  y = cumulative_distribution(85, 115, 100, 15);
  y = cumulative_distribution(105, 115, 100, 15);
  return;
  console.log('y', y); return;
  for (let x = 0; x <= 150; x += 25) {
    let y = cdf0(x);
    console.log('x', x, 'y', y)
  }
}
function test3_game_options() {
  present_game_options();
  close_sidebar();
}
async function test3_letters(l, n) {
  let text = await route_path_text(`../base/assets/words/${l}dict.txt`);
  let picdi = await route_path_yaml_dict(`../base/assets/words/${l}picdict.yaml`);
  let splitter = l == 'e' ? '\r\n' : '\n';
  let words = text.split(splitter);
  let result = words.filter(x => x.length == n);
  let result2 = result.filter(x => x in picdi);
  return { all: result, pic: result2 };
}
function test3_mapbounds() {
  var map = L.map('map');
  map.setView(Geo.places.vegagasse, 16)
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);
  let b = map.getBounds();
  console.log('b', b._southWest, b._northEast);
  let [p1, p2] = [[b._southWest.lat, b._southWest.lng], [b._northEast.lat, b._northEast.lng]];
  M = get_route_control(map, p1, p2);
}
function test3_p5_perlin_2d() {
  dTable = mBy('dTable'); mCenterFlex(dTable);
  let o = mCanvas(dTable, { w: 600, h: 400 }, {}, startloop, pauseloop, 'cc');
  iAdd(o, {}, { draw: draw_perlin_xy });
  o.play();
}
function test3_point_math() {
  C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc', null, true);
  C.add();
  C.add({ x: 50, y: 80, color: 'pink', draw: draw_point, update: update_move });
  C.add({ x: 50, y: -80, color: 'red', draw: draw_car, update: update_car, v: { a: 0, mag: 5 } });
  C.draw();
  C.play();
}
function test3_show_tables() {
  phpPost({ app: 'easy' }, 'tables');
}
function test3_sit_around_table(n = 4) {
  dTable = mBy('dTable');
  let r = getRect(dTable);
  let [w, h] = [r.w * .9, r.h * .9];
  let [offx, offy] = [r.w * .05, r.h * .05];
  let mindim = Math.min(w, h);
  let [szTable, szPlayer] = [mindim / 2, mindim / 4];
  let pTable = { x: offx + w / 2 - szTable / 2, y: offy + h / 2 - szTable / 2 };
  let styles = { round: true, x: pTable.x, y: pTable.y, position: 'absolute', w: szTable, h: szTable, classname: 'wood' };
  let d = mDiv(dTable, styles);
  let table = iAdd({ numplayers: n, styles: styles }, { div: d })
  let numPlayers = n;
  let sz = szPlayer;
  let pts = cCircle({ x: offx + w / 2, y: offy + h / 2 }, w - sz, numPlayers);
  console.log('pts', pts);
  let players = [];
  for (const pt of pts) {
    let [x, y] = [pt.x - sz / 2, pt.y - sz / 2];
    styles = { round: true, x: x, y: y, position: 'absolute', w: sz, h: sz, bg: colorFrom('randdark') };
    d = mDiv(dTable, styles);
    let player = iAdd({ styles: styles }, { div: d });
    players.push(player);
  }
  return [table, players];
}
function test4() { test2(); }
function test4_3rows() {
  var dMain = document.getElementById('dMain');
  let dHeader = mDiv(dMain, { bg: 'random' }, 'dHeader', 'header');
  let dOuter = mDiv(dMain, { bg: 'random', flex: '1 0 auto', display: 'flex', 'flex-flow': 'row wrap' });
  let dLeft = mDiv(dOuter, { bg: 'random', flex: '0 0 200px' }, 'dLeft', 'left');
  let dMiddle = mDiv(dOuter, { bg: 'random', flex: '1 0 auto' }, 'dMiddle', 'middle');
  let dRight = mDiv(dOuter, { bg: 'random', flex: '0 0 200px' }, 'dRight', 'right');
  let dFooter = mDiv(dMain, { bg: 'random' }, 'dFooter', 'footer');
  mSize(dHeader, '100%', 50);
}
function test4_ari_deck_2_fixed_size_hands(otree) {
  let deck = ui_make_random_deck(10);
  mLinebreak(dTable);
  let hand1 = ui_make_random_hand(1); mStyle(hand1.container, { w: '50%' });
  let hand2 = ui_make_random_hand(1); mStyle(hand2.container, { w: '50%' });
  let d = iDiv(deck.topmost);
  top_card_to_hands_abwechselnd(deck, hand1, hand2);
}
function test4_boa_main() {
  mAppear('dScreen', 100);
  if (FirstLoad) { FirstLoad = false; initialize_state(); }
  get_toolbar();
  onclick_location('boa');
  S.boa_authorization_code = '123456';
  boamain_start();
}
function test4_direct_login_onclick_user() {
  show_users();
  let uplayer = localStorage.getItem('uname');
  if (isdef(uplayer)) onclick_user(uplayer);
}
function test4_get_waypoints(mymap, p1, p2) {
  var routeData = L.Routing.control({
    waypoints: points_to_waypoints(p1, p2),
    lineOptions: { styles: [{ color: '#006a4e', opacity: 1, weight: 5 }], },
    draggableWaypoints: false,
    createMarker: function () { return false; },
    show: false,
  }).addTo(mymap);
  var routeArray = new Array();
  routeArray = routeData.getWaypoints();
  console.log(routeArray);
  return routeData;
  L.motion.polyline([[52.501737, -2.119792], [52.501267, -2.114707], [52.500313, -2.110361], [52.499243, -2.108751], [52.498596, -2.105886], [52.498812, -2.104953], [52.498798, -2.102591]], {
    color: "transparent"
  }, {
    auto: true,
    duration: 30000,
    easing: L.Motion.Ease.easeInOutQuart
  }, {
    removeOnEnd: false,
    showMarker: true,
    icon: L.icon({ iconUrl: 'marker.png', iconSize: [32, 37] })
  }).addTo(mymap);
}
function test4_intelli() {
  dTable = dTable = mSection({ position: 'relative' }, 'dTable'); mCenterFlex(dTable);
  let ta = mTextarea(10, 90, dTable, { padding: 20, position: 'relative' });
  setTimeout(() => ta.autofocus = true, 10);
  let buttons = mDiv(dTable, { w: '100%', align: 'right', maright: 4 });
  let st = { fz: 14 };
  maButton('RUN (ctl+Enter)', au_run, buttons, st);
  maButton('LINE (ctl+shft+Enter)', au_run_line, buttons, st);
  let tacon = mTextarea(3, 90, dTable, { matop: 4, padding: 20, position: 'relative' });
  ta.focus();
  AU.popup = mDiv(dTable, { position: 'absolute', wmin: 100, hmin: 100, hmax: 600, overy: 'auto', bg: 'blue', fg: 'white' });
  hide(AU.popup)
  AU.fnames = get_keys(CODE.funcs); AU.fnames.sort();
  AU.list = [];
  AU.prefix = '';
  AU.selected = null;
  AU.n = -1;
  AU.ta = ta;
  AU.tacon = tacon;
  ta.onkeydown = ev => {
    let k = ev.key;
    if (k == 'Enter' && AU.selected) ev.preventDefault();
  }
  ta.onkeyup = ev => {
    let k = ev.key;
    let fnames = AU.fnames;
    let popup = AU.popup;
    if (k == 'Enter' && ev.ctrlKey) {
      au_reset();
      let code = ev.shiftKey ? getTextAreaCurrentLine(AU.ta) : AU.ta.value;
      runcode(code);
    } else if (k == ' ' || k == ')') {
      AU.previous = AU.prefix;
      if (isdef(AU.fnames[AU.previous])) {
        let w = AU.selected = AU.previous;
        AU.uebernommen = CODE.funcs[w];
        popup.innerHTML = AU.previous + '(' + AU.uebernommen.params + ')';
      } else {
        au_reset();
      }
    } else if (k == 'Enter' && AU.selected) {
      let w = AU.selected.innerHTML;
      let s = stringAfter(w, AU.prefix);
      AU.ta.value = AU.ta.value + s;
      AU.uebernommen = CODE.funcs[w];
      popup.innerHTML = w + '(' + AU.uebernommen.params + ')';
    } else if (k == 'Backspace' && AU.prefix.length > 1) {
      AU.prefix = AU.prefix.slice(0, -1);
      au_show_list();
    } else if (k == 'ArrowDown' && !isEmpty(AU.list)) {
      if (AU.n < AU.list.length - 1) AU.n++;
      let ch = popup.children;
      if (AU.selected) mStyle(AU.selected, { bg: 'blue' });
      AU.selected = ch[AU.n];
      mStyle(AU.selected, { bg: 'green' });
    } else if (k == 'ArrowUp' && !isEmpty(AU.list)) {
      if (AU.n > 0) AU.n--;
      let ch = popup.children;
      if (AU.selected) mStyle(AU.selected, { bg: 'blue' });
      AU.selected = ch[AU.n];
      mStyle(AU.selected, { bg: 'green' });
    } else if (isLetter(k) || k == '_') {
      if (isEmpty(AU.prefix)) AU.selectionEnd = AU.ta.selectionEnd;
      AU.prefix += k;
      au_show_list();
    } else if (k != 'Shift') {
      au_reset();
    }
  }
}
function test4_load_games() {
}
async function test4_multiple_wordlists() {
  for (const l of ['e', 'd', 's', 'f']) {
    for (let i = 6; i < 15; i++) {
      let res = await test3_letters(l, i);
      let s = `${l} ${i} ${res.all.length} (davon: ${res.pic.length} ${Math.round((res.pic.length / res.all.length) * 100)}%)`;
      console.log('', s);
    }
    console.log('________');
  }
}
function test4_range_math_GEHT_NICHT() {
  C = new MathCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc', 10);
  let x = colorMix('yellow', 'red'); console.log('color', x)
  let p1 = C.point(5, 3, 'yellow');
  let p2 = C.point(25, 12, 'red');
  for (let i = 0.1; i < .9; i += .1) {
    let p3 = lerpoint(p1, p2, i);
    C.add(p3);
  }
  C.draw();
}
function test4_save() {
  let [table, players] = test3_sit_around_table(3);
  serialize_all();
}
function test4_tools() {
  let map = create_map();
  console.log('map', map);
  let d = map._controlContainer;
  console.log('control container', d);
  dMap = mDiv(d, { position: 'absolute', top: 0, left: 50, w: '100%', h: '100%' });
  dMap.style.zIndex = 12000;
  dTop = mDiv(dMap, { hmargin: 10, padding: 10, cursor: 'pointer' }, null, null, 'top'); mFlexWrap(dTop);
  let b = mButton('hallo', dummy_reaction, dTop);
  b = mButton('download', () => downloadJson({ hallo: 4343 }, '__test'), dTop);
  let a = mLink("http://duckduckgo.com", dTop, { color: 'dimgray' }, null, 'ein link');
  a = mLink("javascript:void(0)", dTop, { color: 'dimgray' }, null, 'ein link');
  a.onclick = dummy_reaction;
  b = mButton('Paris', () => map.setView(Geo.cities.Paris.center), dTop);
  b = mButton('London', () => map.flyTo(Geo.cities.London.center), dTop);
  let agent = new Agent(map, .0001, false);
  return;
  let x = create_toolbar(map); console.log('toolbar', x)
  let tb = x._container; console.log('toolbar', tb);
  mButton('click', () => console.log('clicked!'), tb, { cursor: 'pointer' })
}
function test5(map, p1, p2) {
  let control = M.control = test4_get_waypoints(map, p1, p2);
  M.coords = [];
  control.on('routeselected', function (e) {
    arrExtend(M.coords, e.route.coordinates);
    console.log('M', M)
  });
}
function test5_33mitMenuButtons() {
  let page = pageLayout33();
  let bMenuRight = stdMenuButton();
  mRight(page.dHeader, bMenuRight);
  let bMenuLeft = stdMenuButton();
  mLeft(page.dHeader, bMenuLeft);
}
function test5_ari_anim_deal_market(otree) {
  let deck = ui_make_random_deck(50);
  let market = ui_make_random_market(1);
  mLinebreak(dTable);
  let hand1 = ui_make_random_hand(7); mStyle(hand1.container, { w: '50%' });
  let hand2 = ui_make_random_hand(7); mStyle(hand2.container, { w: '50%' });
  top_card_to_market(deck, market);
}
function test5_bw_skin() {
  mAppear('dScreen', 100);
  if (FirstLoad) { FirstLoad = false; initialize_state(); }
  get_toolbar();
  bw_widget_popup('skype');
}
async function test5_letters_upto(l, n) {
  let text = await route_path_text(`../base/assets/words/${l}dict.txt`);
  let picdi = await route_path_yaml_dict(`../base/assets/words/${l}picdict.yaml`);
  let splitter = l == 'e' ? '\r\n' : '\n';
  let words = text.split(splitter);
  let result = words.filter(x => x.length >= 3 && x.length <= n);
  let result2 = result.filter(x => x in picdi);
  return { all: result, pic: result2 };
}
function test5_line_GEHT_NICHT() {
  C = new MathCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc', 10);
  let p1 = C.point(5, 3, 'yellow');
  let p2 = C.point(25, 12, 'red');
  for (let i = 0; i < 1; i += .01) {
    let p3 = lerpoint(p1, p2, i);
    C.add(p3);
  }
  C.draw();
}
function test5_load() {
  dTable = mDiv('dTable');
  load_all();
}
function test5_prelim() { }
function test5_showroute() {
  let map = M.map = create_map();
  let agent = M.agent = new Agent(map, .0001, false);
  let tb = M.toolbar = create_toolbar(map);
  let pts = [Geo.places.tuerkenschanzpark, Geo.places.vegagasse]
  let color = 'green';
  let callback = e => fit_points(map, pts);
  let control = M.router = show_route(map, pts, color, callback);
}
function test52CardsOther() {
  keys = ['spades', 'hearts', 'clubs', 'diamonds'];
  for (let i = 0; i < 4; i++) {
    let k = keys[i % keys.length];
    console.log('k', k);
    let card = Karte.random(k, 110);
    mAppend(dTable, iDiv(card));
  }
}
function test6(map, p1, p2) {
  let control = M.control = L.Routing.control({
    waypoints: points_to_waypoints(p1, p2),
    lineOptions: { styles: [{ color: '#006a4e', opacity: 1, weight: 5 }], },
    draggableWaypoints: false,
    createMarker: function () { return false; },
    show: false,
  }).addTo(map);
  M.coords = [];
  control.on('routesfound', function (e) {
    M.routes = e.routes;
    M.num_requests = e.target._requestCount;
    M.coords = arrExtend(M.coords, e.routes[0].coordinates);
    console.log('M', M)
  });
}
function test6_33mitMenuButtons() {
  let page = pageLayout33();
  let bMenuRight = stdMenuButton();
  mRight(page.dHeader, bMenuRight);
  let bMenuLeft = stdMenuButton();
  mLeft(page.dHeader, bMenuLeft);
  dLeft.style.flex = 'unset';//'1 1 200px';
  bMenuLeft.onclick = () => {
    mStyle(mBy('dLeft'), { wmin: 0, w: 0 });
  }
}
function test6_ari_anim_auto_deal(otree) {
  let deck = ui_make_random_deck(50);
  let market = ui_make_random_market(0);
  mLinebreak(dTable);
  let hand1 = ui_make_random_hand(7); mStyle(hand1.container, { w: '50%' });
  let hand2 = ui_make_random_hand(7); mStyle(hand2.container, { w: '50%' });
  top_card_to_market(deck, market);
}
function test6_click() {
  let map = M.map = create_map({ zoom: 16 });
  add_click_set_agent();
  let tb = M.toolbar = create_toolbar(map);
  mButton('route', () => {
    map.off('click');
    let pts = M.agents.map(x => x.pos);
    let color = 'red';
    let callback = e => fit_points(map, pts);
    M.router = show_route(map, pts, color, callback);
  }, tb);
  mButton('clear', () => { clear_router(); clear_agents(); add_click_set_agent(); }, tb);
}
function test6_func_GEHT_NICHT() {
  C = new MathCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc', 10);
  let f = x => Math.sqrt(x), d = .01;
  for (let x = C.minx; x < C.maxx; x += d) {
    let pt = C.point(x, f(x), 'yellow');
    C.add(pt);
  }
  C.draw();
}
function test6_generate_statement() {
  mAppear('dScreen', 100);
  if (FirstLoad) { FirstLoad = false; initialize_state(); }
  get_toolbar();
  generate_statement();
}
function test6_init() {
  let item = { styles: { bg: 'orange', w: 30, h: 30, round: true } };
  iInit(c1, item);
  iInit(c2, item);
  iInit(dTable, item);
  start_loop();
  setTimeout(() => item.styles.bg = BLUE, 2000);
}
async function test6_multiple_wordlists() {
  for (const l of ['e', 'd', 's', 'f']) {
    for (let i = 3; i < 15; i++) {
      let res = await test5_letters_upto(l, i);
      let s = `${l} ${i} ${res.all.length} (davon: ${res.pic.length} ${Math.round((res.pic.length / res.all.length) * 100)}%)`;
      console.log('', s);
    }
    console.log('________');
  }
}
function test7() {
  var dMain = document.getElementById('dMain');
  let dHeader = mDiv(dMain, { bg: 'random' }, 'dHeader', 'header');
  let [dLeft, dMiddle, dRight] = std3fold(dMain);
  let dFooter = mDiv(dMain, { bg: 'random' }, 'dFooter', 'footer');
  let bMenuLeft = stdMenuButton();
  mLeft(dHeader, bMenuLeft);
  stdSidebarController(bMenuLeft, 'dLeft');
  let bMenuRight = stdMenuButton();
  mRight(dHeader, bMenuRight);
  stdSidebarController(bMenuRight, 'dRight');
}
function test7_add_hand_card() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  let card = prompt('enter card (eg. 8H');
  fen.players[uplayer].hand.push(card + 'n');
  take_turn_fen();
}
function test7_ari_anim_auto_deal(otree) {
  let deck = ui_make_random_deck(50);
  let market = ui_make_random_market(0);
  mLinebreak(dTable);
  let hand1 = ui_make_random_hand(7); mStyle(hand1.container, { w: '50%' });
  let hand2 = ui_make_random_hand(7); mStyle(hand2.container, { w: '50%' });
  DA.qanim = [
    [anim_from_deck_to_marketX, [deck, market]],
    [anim_from_deck_to_marketX, [deck, market]],
  ];
  anim_from_deck_to_marketX(deck, market);
}
function test7_card() {
  dTable = mBy('dTable'); mCenterFlex(dTable);
  let x = ui_type_hand(['3Hn', '4Hn', '4Hl'], dTable); console.log('hand', x);
  iReg(x);
  let c = ari_get_card('QDn', 500); mAppend(dTable, iDiv(c));
  animatedTitle();
}
function test7_display_dims_on_moveend() {
  let map = M.map = create_map({ zoom: 16 });
  map.on('moveend', function (e) { calc_map_dims(); console.log("dims", M.dims); });
  let city = rChoose(M.capitals);
  console.log('city has been chosen:', city);
  map.flyTo(Geo.cities[city].center);
}
function test7_function() {
  C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc');
  let ctx = C.cx;
  let canvas = C.cv;
  let h = canvas.height;
  let w = canvas.width;
  let cw = w / 2;
  let ch = h / 2;
  let subStepCount = 10;
  let scale = 10;
  function plot(func, col, lineWidth) {
    let invScale = 1 / scale;
    let top = ch * invScale;
    let bottom = -ch * invScale;
    let subStep = invScale / subStepCount;
    let x, y, yy, xx, subX;
    let start = (-cw - 1) * invScale;
    let end = (cw + 1) * invScale;
    ctx.strokeStyle = col;
    ctx.lineWidth = lineWidth * invScale;
    ctx.beginPath();
    for (x = start; x < end; x += invScale) {
      for (subX = 0; subX < invScale; subX += subStep) {
        y = func(x + subX);
        if (yy !== undefined) {
          if (y > top || y < bottom) {
            if (yy < top && yy > bottom) {
              ctx.lineTo(x + subX, y);
            }
          } else {
            if (yy > top || yy < bottom) {
              ctx.moveTo(xx, yy);
            }
            if (subX === 0) {
              if (y > bottom && y < top) {
                if (Math.abs(yy - y) > (top - bottom) * (1 / 3)) {
                  ctx.moveTo(x, y);
                } else {
                  ctx.lineTo(x, y);
                }
              }
            }
          }
        } else {
          if (subX === 0) {
            ctx.moveTo(x, y);
          }
        }
        yy = y;
        xx = x + subX;
      }
    }
    ctx.stroke();
  }
  ctx.setTransform(scale, 0, 0, -scale, cw, ch);
  plot(x => 0, 'white', 2);
  plot(x => 5 * Math.sin(x), 'white', 2);
  plot(x => 5 * Math.sin(x), 'white', 2);
}
async function test7_letters_200from(l, n) {
  let text = await route_path_text(`../base/assets/words/${l}dict.txt`);
  let picdi = await route_path_yaml_dict(`../base/assets/words/${l}picdict.yaml`);
  let splitter = l == 'e' ? '\r\n' : '\n';
  let words = text.split(splitter);
  let result = words.filter(x => x.length >= n);
  let result2 = result.filter(x => x in picdi);
  result2.sort((a, b) => a.length - b.length);
  result3 = arrTake(result2, 200);
  return { all: result, pic: result2, sel: result3 };
}
function test7_uploadfile() {
  let o = { filename: 'ex', data: { text: 'jajajaaber geh jaaaa', id: 78912 } };
  route_post_json('http://localhost:3000/post/json', o, response => {
    console.log(JSON.stringify(response))
  });
}
function test8() {
  var dMain = document.getElementById('dMain');
  let dHeader = mDiv(dMain, { bg: 'random' }, 'dHeader', 'header');
  let [dLeft, dMiddle] = std2fold(dMain);
  let dFooter = mDiv(dMain, { bg: 'random' }, 'dFooter', 'footer');
  let bMenuLeft = stdMenuButton();
  mLeft(dHeader, bMenuLeft);
  stdSidebarController(bMenuLeft, 'dLeft');
}
function test8_function() {
  C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'tl');
  let canvas = C.cv;
  if (null == canvas || !canvas.getContext) return;
  var axes = {}, ctx = canvas.getContext("2d");
  axes.x0 = .5 + .5 * canvas.width;
  axes.y0 = .5 + .5 * canvas.height;
  axes.scale = 40;
  axes.doNegativeX = true;
  console.log('axes', axes)
  showAxes(ctx, axes);
  funGraph(ctx, axes, fun1, "rgb(11,153,11)", 1);
  funGraph(ctx, axes, fun2, "rgb(66,44,255)", 2);
}
function test8_load_googlemap_in_iframe() {
  var iDiv = document.createElement('iframe');
  iDiv.id = 'iframe1';
  mStyle(iDiv, { w: '100%', h: '100%' })
  document.getElementById("map").appendChild(iDiv);
  iDiv.src = 'https://maps.google.com/maps?q=48.2,16.3&output=embed';
  // iDiv.src = 'https://maps.google.com/maps?q=48.2,16.3&hl=fa;z=5&ie=UTF8&output=embed&hl=en';
}
function test8_mimi_hand_card_0_hover() {
  let hand = G.mimi.hand.items;
  let card = hand[0];
  mClass(iDiv(card), 'hoverScale');
}
async function test8_multiple_wordlists() {
  for (const l of ['e', 'd', 's', 'f']) {
    for (let i = 3; i < 15; i++) {
      let res = await test7_letters_200from(l, i);
      let s = `${l} >=${i} ${res.all.length} (davon: ${res.pic.length} ${Math.round((res.pic.length / res.all.length) * 100)}%)`;
      console.log('', s);
      console.log('result', res.sel)
    }
    console.log('________');
  }
}
function test8_simple_intellisense() {
  dTable = mBy('dTable');
  fiddleInit();
}
function test9() {
  var dMain = document.getElementById('dMain');
  let [dHeaderLeft, dTitle, dHeaderRight] = std3title(dMain, 'Aristocracy');
  let [dLeft, dMiddle] = std2fold(dMain);
  let dFooter = mDiv(dMain, { bg: 'random' }, 'dFooter', 'footer');
  let bMenuLeft = stdMenuButton(dHeaderLeft);
  stdSidebarController(bMenuLeft, 'dLeft');
}
function test9_dbSave() { DB.appdata.simple = [1, 2, 3, 4, 5]; }
function test9_function() {
  C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'tl');
  let canvas = C.cv;
  let axes = {}, ctx = canvas.getContext("2d");
  axes.x0 = .5 + .5 * canvas.width;
  axes.y0 = .5 + .5 * canvas.height;
  axes.scale = 40;
  axes.doNegativeX = true;
  C.add({ astep: .1, a: 0, bstep: .1, b: 0, func: x => Math.sin(x), axes: axes, update: geniales_sin_ease });
}
function test9_google() {
  mBy('dTable').innerHTML = `
  <iframe class='flat' id="gmap" src="http://maps.google.com/maps?z=15&t=m&q=loc:48.25+16.3&output=embed" width="100%" height="${window.innerWidth}"></iframe>  
  `;
  let x = document.getElementById('gmap');
  console.log('x', x);
  mStyle(x, { bg: 'blue' });
}
function test9_just_1_card() {
  let dTable = mBy('dTable')
  clearElement(dTable);
  let card = ari_get_card('QSn', 200);
  mAppend(dTable, iDiv(card));
  return card;
}
async function test9_only_syms(l) {
  let text = await route_path_text(`../base/assets/words/${l}dict.txt`);
  let picdi = await route_path_yaml_dict(`../base/assets/words/${l}picdict.yaml`);
  let syms = await route_path_yaml_dict(`../base/assets/allSyms.yaml`);
  let keys = Object.keys(syms);
  let lang = l.toUpperCase();
  let res = keys.filter(x => isdef(syms[x][lang]) && nundef(picdi[syms[x][lang].toLowerCase()]));
  console.log('only syms: lang', l, res.map(x => syms[x][lang]));
}
function test98() {
  let area = mBy(table);
}
function test99() {
  console.log('ah');
  let area = mBy('board'); mPosRel(area);
  let olist = getOlist();
  let size = 50, gap = 10;
  let uis = getUis(olist, colorLabelDiv(size));
  let container = mDivPosAbs(100, 100, area);
  let [w, h] = layoutRow(uis, container, size, size, gap);
  mStyle(container, { width: w, height: h, 'background-color': 'white', 'border-radius': gap });
  colorLabelRow(o)
}
async function testAblauf00(defs, spec, sdata0) {
  await testEngine.init(defs, sdata0, TEST_SERIES);
  let [sp, defaults, sdata] = [testEngine.spec, testEngine.defs, testEngine.sdata];
  T = R = new RSG(sp, defaults);
  R.initialChannels = [];
  ensureRtree(R);
  R.baseArea = 'table';
  createStaticUi(R.baseArea, R);
  for (const oid in sdata) { R.addObject(oid, sdata[oid]); R.addRForObject(oid); }
  for (const oid in sdata) {
    let o = sdata[oid];
    if (isdef(o.loc)) { continue; }
    let topUids;
    for (const key of R.getR(oid)) {
      let specNode = R.getSpec(key);
      if (o.loc && nundef(R.Locations[key]) && nundef(specNode._ref)) {
        topUids = addOidByLocProperty(oid, key, R);
      } else if (isdef(R.Locations[key])) {
        topUids = addOidByParentKeyLocation(oid, key, R);
      }
      if (isEmpty(topUids)) { continue; }
      for (const top of topUids) {
        let uiParent = R.uiNodes[top.uidParent];
        let rParent = R.rNodes[top.uidParent];
        if (isdef(uiParent)) {
          uiParent.adirty = true;
          uiParent.children = rParent.children.map(x => x);
        }
        recUi(R.rNodes[top.uid], R, top.uidParent, oid, key);
      }
    }
  }
  sieveLocOids(R);
  recAdjustDirtyContainers(R.tree.uid, R, true);
  updateOutput(R);
  testEngine.verify(R);
}
async function testAblauf01(defs, spec, sdata0) {
  await testEngine.init(defs, sdata0, TEST_SERIES);
  let [sp, defaults, sdata] = [testEngine.spec, testEngine.defs, testEngine.sdata];
  T = R = new RSG(sp, defaults);
  R.initialChannels = [];
  ensureRtree(R);
  R.baseArea = 'table';
  createStaticUi(R.baseArea, R);
  for (const oid in sdata) { R.addObject(oid, sdata[oid]); R.addRForObject(oid); }
  for (const oid in sdata) {
    let o = sdata[oid];
    if (isdef(o.loc)) { continue; }
    let topUids;
    for (const key of R.getR(oid)) {
      let parents = R.Locations[key];
      if (nundef(parents)) continue;
      topUids = [];
      for (const uidParent of parents) {
        if (parentHasThisChildAlready(uidParent, oid)) continue;
        let n1 = instantOidKey(oid, key, uidParent, R);
        topUids.push({ uid: n1.uid, uidParent: uidParent });
      }
      if (isEmpty(topUids)) { continue; }
      for (const top of topUids) {
        let uiParent = R.uiNodes[top.uidParent];
        let rParent = R.rNodes[top.uidParent];
        if (isdef(uiParent)) {
          uiParent.adirty = true;
          uiParent.children = rParent.children.map(x => x);
        }
        recUi(R.rNodes[top.uid], R, top.uidParent, oid, key);
      }
    }
  }
  recAdjustDirtyContainers(R.tree.uid, R, true);
  updateOutput(R);
  testEngine.verify(R);
}
async function testAblauf02(defs, spec, sdata0) {
  await testEngine.init(defs, sdata0, TEST_SERIES);
  let [sp, defaults, sdata] = [testEngine.spec, testEngine.defs, testEngine.sdata];
  T = R = new RSG(sp, defaults);
  R.initialChannels = [];
  ensureRtree(R);
  R.baseArea = 'table';
  createStaticUi(R.baseArea, R);
  for (const oid in sdata) { R.addObject(oid, sdata[oid]); R.addRForObject(oid); }
  for (const oid in sdata) {
    let o = sdata[oid];
    if (isdef(o.loc)) { continue; }
    let topUids;
    for (const key of R.getR(oid)) {
      let parents = R.Locations[key];
      if (nundef(parents)) continue;
      topUids = [];
      for (const uidParent of parents) {
        if (parentHasThisChildAlready(uidParent, oid)) continue;
        let rtreeParent = R.rNodes[uidParent];
        if (nundef(rtreeParent.children)) { rtreeParent.children = []; }
        let n1 = recTree(R.lastSpec[key], rtreeParent, R, oid, key);
        R.rNodes[n1.uid] = n1;
        rtreeParent.children.push(n1.uid);
        if (rtreeParent.children.length == 2 && rtreeParent.type == 'invisible' && lookup(rtreeParent, ['params', 'bg'])) {
          let uiParent = R.uiNodes[rtreeParent.uid];
          if (isdef(uiParent)) {
            rtreeParent.type = uiParent.type = 'panel';
            decodeParams(uiParent, R, {});
            uiParent.adirty = true;
            applyCssStyles(uiParent.ui, uiParent.cssParams);
          }
        }
        topUids.push({ uid: n1.uid, uidParent: uidParent });
      }
      if (isEmpty(topUids)) { continue; }
      for (const top of topUids) {
        let uiParent = R.uiNodes[top.uidParent];
        let rParent = R.rNodes[top.uidParent];
        if (isdef(uiParent)) {
          uiParent.adirty = true;
          uiParent.children = rParent.children.map(x => x);
        }
        recUi(R.rNodes[top.uid], R, top.uidParent, oid, key);
      }
    }
  }
  recAdjustDirtyContainers(R.tree.uid, R, true);
  updateOutput(R);
  testEngine.verify(R);
}
function testActivate(R) {
  console.log('testActivate', R)
  activateUis(R);
}
function testAdd10Cards() {
  let uilist = [], ch;
  for (let i = 0; i < 10; i++) {
    if (coin()) {
      let card = Card52.getItem();
      ch = iDiv(card);
      mAppend(dTable, ch);
    } else {
      ch = mDiv(dTable, { w: 76, h: 110, bg: 'random' });
      mClass(ch, 'card');
    }
    uilist.push(ch);
  }
}
function testAddBoard(R) {
  R.initRound();
  reAddServerObject('board');
}
function testAddInfluence(mapController, gObjects) {
  let data = {};
  addIf_dep("map", execOptions.activatedTests);
  data.created = {
    "507565": {
      value: 1,
      nation: "Canada",
      faction: "Axis",
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 507565
    },
    "531772": {
      value: 2,
      nation: "Ireland",
      faction: "West",
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 531772
    },
    "531773": {
      value: 3,
      nation: "Portugal",
      faction: "USSR",
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 531773
    },
    "531774": {
      value: 2,
      nation: "Norway",
      faction: "Axis",
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 531774
    },
    "531775": {
      value: 4,
      nation: "Latin_America",
      faction: "Axis",
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 531775
    }
  };
  mapController.update(data, gObjects);
}
function testAddLocObject(R) {
  R.initRound();
  let oidLoc = getRandomExistingObjectWithRep(R);
  let oid = getUID('o');
  let o = { name: 'felix' + oid, loc: oidLoc };
  addServerObject(oid, o, R);
}
function testAddObject(R) {
  R.initRound();
  let oid = getUID('o');
  let o = { obj_type: 'card' };
  o.short_name = chooseRandom(['K', 'Q', 'J', 'A', 2, 3, 4, 5, 6, 7, 8]);
  addServerObject(oid, o, R);
}
function testAddOidKey(R) {
  console.log(R.instantiable)
  let n = lastCond(R.instantiable, x => !lookup(R.rNodesOidKey, [x.oid, x.key]));
  if (!n) {
    console.log('all nodes are instantiated!!!');
    return;
  }
  let [oid, key] = [n.oid, n.key];
  let o = R.getO(oid);
  if (!o) {
    console.log('no object with oid', oid, 'found!!!');
    return;
  }
  if (o.loc) addOidByLocProperty(oid, key, R); else addOidByParentKeyLocation(oid, key, R);
  updateOutput(R);
}
function testAndSave() {
  sendRoute('/loadYML/icons', d => {
    console.log(d);
    let dictFont = JSON.parse(d);
    console.log(dictFont);
    let newDictFont = {};
    for (const key in dictFont) {
      newDictFont[key] = dictFont[key].unicode;
    }
    let json_str = JSON.stringify(newDictFont);
    saveFile("yourfilename.json", "data:application/json", new Blob([json_str], { type: "" }));
    console.log('DONE!')
  })
}
function testAndSave2() {
  let newDictFont = {};
  for (const key in faIcons) {
    newDictFont[key] = faIcons[key][3];
  }
  let json_str = JSON.stringify(newDictFont);
  saveFile("yourfilename.json", "data:application/json", new Blob([json_str], { type: "" }));
  console.log('DONE!')
}
function testanim0() {
  let [fen, phase, stage, deck, market] = [Z.fen, Z.phase, Z.stage, Z.deck, Z.market];
  let ms = 400;
  let item = deck.topmost;
  mAnimate(iDiv(item), 'transform', [`scale(1,1)`, `scale(0,1)`],
    () => {
      if (item.faceUp) face_down(item); else face_up(item);
      mAnimate(iDiv(item), 'transform', [`scale(0,1)`, `scale(1,1)`], null,
        ms / 2, 'ease-in', 0, 'both');
    }, ms / 2, 'ease-out', 100, 'both');
}
function testanim1() {
  let [fen, phase, deck, market] = [Z.fen, Z.phase, Z.deck, Z.market];
  DA.qanim = [];
  let n_market = phase == 'jack' ? 3 : 2;
  fen.stage = Z.stage = phase == 'jack' ? 12 : phase == 'queen' ? 11 : 4;
  for (let i = 0; i < n_market; i++) {
    DA.qanim = DA.qanim.concat([
      [qanim_flip_topmost, [deck]],
      [qanim_move_topmost, [deck, market]],
      [q_move_topmost, [deck, market]],
    ]);
  }
  DA.qanim.push([q_mirror_fen, ['deck', 'market']]);
  DA.qanim.push([ari_pre_action, []]);
  qanim();
}
function testBirdCards() {
  let keys = SymKeys.filter(x => Syms[x].family != 'emoNoto');
  console.log('groups', ByGroupSubgroup);
  console.log('keySets', KeySets);
  keys = KeySets['animal-bird'];
  for (let i = 0; i < 40; i++) {
    let k = chooseRandom(keys);
    console.log('k', k);
    let card = Karte.get(k, 300);
    mAppend(dTable, iDiv(card));
  }
}
function testbuttons_off() {
  let buttons = arrChildren(mBy('dTestButtons'));
  for (const b of arrFromIndex(buttons, 1)) {
    mClass(b, 'disabled');
    mClassRemove(b, 'enabled');
  }
  mBy('b_delete_table').innerHTML = 'delete most recent table';
}
function testbuttons_on() {
  let buttons = arrChildren(mBy('dTestButtons'));
  for (const b of arrFromIndex(buttons, 1)) {
    mClassRemove(b, 'disabled');
    mClass(b, 'enabled');
  }
  mBy('b_delete_table').innerHTML = 'delete current table';
}
async function testCard() {
  let sdata = genServerDataCards();
  console.log('sdata', sdata)
  let spec = {
    ROOT: { cond: 'all', data: '.short_name' }
  };
  await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
  mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}
function testCard52Cards() {
  for (let i = 0; i < 20; i++) {
    let card = Card52.random();
    mAppend(dTable, iDiv(card));
  }
}
function testCardContent0(card) {
  let dCard = iDiv(card);
  mRows(dCard, spotItPattern(5, 2), { sz: Card.sz / 6, fg: 'random', hmargin: 8, vmargin: 4 }, { 'justify-content': 'center' }, { 'justify-content': 'center' }); return;
  mRows(dCard, spotItPattern(5, 2), { sz: Card.sz / 8, fg: 'random', margin: 6 }, { 'justify-content': 'center' }, { 'justify-content': 'center' }); return;
  mRows(dCard, cardPattern(13, 'spade suit'), { sz: Card.sz / 8, fg: 'random', margin: 6 }, { 'justify-content': 'center' }, { 'justify-content': 'center' }); return;
  mRows(dCard, [['frog', 'frog', 'frog'], ['frog', 'frog'], ['frog', 'frog', 'frog']], { sz: Card.sz / 6, fg: 'random' }, { 'justify-content': 'center' }, { 'justify-content': 'center' }); return;
  mRows(dCard, [['frog', 'frog', 'frog'], ['frog', 'frog'], ['frog', 'frog', 'frog']], { sz: Card.sz / 5, fg: 'random' }, { 'justify-content': 'center' }, { 'justify-content': 'space-evenly' }); return;
  mSym('frog', dCard, {}, 'cc'); return;
  mRows(iDiv(card), [[['frog', 3], 'HALLO', 'bee'], ['frog', 'HALLO', 'bee'], ['frog', 'HALLO', 4, 'bee'], 'ja das ist es!']);
  return;
  let d = iDiv(dCard, { display: 'flex', dir: 'column', h: '100%', 'justify-content': 'center' }, 'dOuter');
  return;
  for (const arr of rows) {
    let dCol = mDiv(d, { display: 'flex', 'justify-content': 'space-between', 'align-items': 'center' });
    for (const c of arr) {
      let dc;
      if (isdef(Syms[c])) {
        dc = mDiv(dCol, { fg: 'black' });
        ds = mSym(dc, dCol, { sz: Card.sz / 5, fg: 'random' });
      } else {
        dc = mDiv(dCol, { fg: 'black' }, null, c);
      }
    }
  }
}
async function testCardDraw52() {
  let d = mBy('table');
  let ui = cardFace({ rank: 'K' }, 70, 110);
  mAppend(d, ui);
}
async function testCardHorizontal() {
  let sdata = genServerDataCards();
  let spec = {
    ROOT: { _NODE: 'cards', params: { orientation: 'h' } },
    cards: { cond: 'all', data: '.short_name' }
  };
  await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
  mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}
async function testCardHorizontal2() {
  let sdata = genServerDataCards();
  let spec = {
    ROOT: { type: 'panel', _NODE: 'cards' },
    cards: { cond: 'all', data: '.short_name' }
  };
  await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
  mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}
function testCards() {
  initRSGData(); hideLobby(); hideLogin(); showGame(); initDom();
  testPlayerHand1();
}
function testCardsGridOverlap() {
  dTable = stdGridContainer(dMiddle);
  testAdd10Cards();
}
function testCardsNoOverlap() {
  dTable = stdContainerRowWrap(dMiddle);
  testAdd10Cards();
}
async function testCardsUni(n, spec, cardGenerator = genServerDataCards) {
  let sdata = cardGenerator(n);
  await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
  mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}
async function testCatan(r, c) {
  let sdata = genServerDataCatan(r, c);
  let spec = { ROOT: { cond: { obj_type: 'Board' }, type: 'grid', data: '.uid' } };
  await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
  mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}
function testCenteredNode() {
  let dTable = mBy('table');
  let d = mDiv(dTable);
  mSize(d, 100, 100);
  mColor(d, 'blue');
  let d1 = mNode({ a: 'HALLO', b: 'geh' }, d);
  mCenterH(d1);
}
function testColarrVersions() {
  let tests = [[2, 2], [3, 2], [4, 2], [5, 2], [6, 2], [6, 3]];
  for (let i = 0; i < 50; i++) {
    let [rows, cols] = [randomNumber(1, 10), randomNumber(1, 10)];
    let carr1 = _calc_hex_col_array(rows, cols);
    let carr2 = _calc_hex_col_arrayNew(rows, cols);
    let even = (rows % 2) == 0;
    console.log('rows', rows, (even ? 'even' : 'odd'), 'cols', cols, '\nold', carr1, '\nnew', carr2);
    console.assert(even || sameList(carr1, carr2), 'FEHLER!!!!!!!!!!!!!!!!!!');
  }
}
async function testCommonKeys() {
  initRSGData(); showGame(); initDom();
  let gaIcons = await route_rsg_asset('gameIconCodes');
  let faIcons = await route_rsg_asset('faIconCodes');
  let smallIcons = await route_rsg_asset('iconTest');
  faKeys = [];
  for (const k in gaIcons) {
    if (isdef(faIcons[k])) faKeys.push(k);
  }
  console.log('common keys:', faKeys);
  let board = makeDrawingArea('board', 'a_d_game', true);
  setAreaWidth('a_d_game', 1400);
  setAreaHeight('a_d_game', 1000);
  let keys = faKeys;
  let xStart = -600;
  let yStart = -400;
  let y = yStart;
  let x = xStart;
  for (const k of keys) {
    addPictoFromChar('board', gaIcons[k], 50, x, y);
    if (y > -yStart) { y = yStart; x += 60; } else y += 60;
  }
  y = yStart; x += 60;
  for (const k of keys) {
    addPictoFromChar('board', faIcons[k], 50, x, y);
    if (y > -yStart) { y = yStart; x += 60; } else y += 60;
  }
  // let key = chooseRandom(Object.keys(faChars));//'clock';
}
function testComposeShapesAndResize() {
  let g = gCanvas('table', 400, 300, 'skyblue');
  testResizeHex(g);
}
function testControlFlow(player = "USSR", filename = "", seed = 4) {
  execOptions.output = "none";
  addIf_dep("control", execOptions.activatedTests);
  if (empty(filename)) {
    sendInit(player, gameloop, seed);
  } else {
    sendLoading(filename, player, gameloop);
  }
}
function testCreateDivWithDivFixedSize() {
  let d = mBy('table');
  clearElement(d);
  d.style.position = 'relative';
  let root = mDiv(d);
  root.style.position = 'relative';
  root.style.width = '200px';
  root.style.height = '100px';
  let ch = mDiv(root);
  ch.style.position = 'absolute';
  ch.style.left = '20px';
  ch.style.top = '10px';
  ch.style.width = '30px';
  ch.style.height = '60px';
  ch.style.backgroundColor = 'blue';
  root.style.backgroundColor = 'red';
}
function testCreateMultipleUnitsOnSameTile() {
  execOptions.output = "none";
  addIf_dep("units", execOptions.activatedTests);
  let data = generateUnitList();
  let player = "West";
  for (const id in data.created) {
    const o = data.created[id];
    o.tile = "London";
    o.nationality = "Britain";
    units.createUnit(id, o, player);
  }
  player = "USSR";
  for (const id in data.created) {
    let idNew = id + 200;
    const o = data.created[id];
    o.tile = "Berlin";
    o.nationality = "Germany";
    o._id = idNew;
    units.createUnit(idNew, o, player);
  }
}
function testCreateNCards() {
  let cman = new ACards(assets);
  let n = 20;
  for (let i = 0; i < n; i++) {
    let c = generateCard();
    cman.createCard(c.id, c.o);
  }
}
function testCreateOneCard() {
  let c = generateCard();
  let cman = new ACards(assets);
  cman.createCard(c.id, c.o);
}
function testCreateSingleUnit() {
  execOptions.output = "none";
  addIf_dep("units", execOptions.activatedTests);
  let data = generateUnitList();
  let player = "West";
  for (const id in data.created) {
    const o = data.created[id];
    units.createUnit(id, o, player);
    break;
  }
}
function testDeactivate(R) {
  deactivateUis(R);
}
function testDeal2() {
  deck.mount(d);
  bDeal.addEventListener('click', function () { deck.pokerN(1); });
  makeTestButton('deal2', () => deck.pokerN(2), topbar1);
}
function testDec() {
  let x = hexStringToDecimal('F');
  console.log('x', x);
  console.log('x', hexStringToDecimal('FFFF'));
  console.log('x', hexStringToDecimal('1A'));
  console.log('x', hexStringToDecimal('1F499'));
  console.log('x', hexStringToDecimal('1F981'));
}
async function testDirList() {
  let x = await (await fetch('/RSG/js')).text();
  while (!isEmpty(x)) {
    word = stringBefore(x, '"');
    console.log('______________word:', word);
    x = stringAfter(x, '<a href="/');
  }
  return;
  var regexp = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/i;
  var match, files = [];
  let max = 5;
  while ((match = regexp.exec(x)) != null) {
    files.push(match.index);
    max -= 1; if (max <= 0) break;
  }
  console.log('________________', files);
  return;
  var request = new XMLHttpRequest();
  request.open('GET', '/RSG/', true);
  let resp;
  request.onload = function () {
    if (request.status >= 200 && request.status < 400) {
      resp = request.responseText;
    }
  };
  request.send();
  let directory_listing = resp;
  var regexp = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/i;
  var match, files = [];
  while ((match = regexp.exec(resp)) != null) {
    files.push(match.index);
  }
  console.log(files);
}
async function testDocumentFile() {
  let akku = await documentFile('/RSG/js/done/docs/docfile.js');
  let keys = Object.keys(akku);
  keys.sort();
  keys.map(x => console.log('signature:', x, '\ncomment block:\n', akku[x]));
}
async function testDocumentVault() {
  let vault = [
    "/RSG/js/R/binding.js",
    "/RSG/js/R/rsgTypes.js",
    "/RSG/js/testing/engine.js",
    "/RSG/js/testing/onClick.js",
    "/RSG/js/testing/SimpleGrid.js",
    "/RSG/js/testing/testBoard.js",
    "/RSG/js/testing/testCards.js",
    "/RSG/js/testing/testFactory.js",
    "/RSG/js/testing/testData.js",
    "/RSG/js/testing/testing.js",
    "/RSG/js/done/activator.js",
    "/C/assets.js",
    "/RSG/js/done/index.js",
    "/RSG/js/done/utils.js",
  ];
  console.log(res);
}
function testEdit(origData, player = "USSR", filename = "test1", seed = 0) {
  execOptions.output = "none";
  sendInit(player, d1 => {
    freezeUI();
    let tuples = getTuples(d1);
    sendEditAction(player, ["France", "Vienna", "Fleet"], d2 => {
      gameloop(origData);
    });
  });
}
function testEditAddRandomUnit() {
  let tuple = randomUnitTuple();
}
function testEditModeCreateUnit() {
  player = "USSR";
  sendLoading("setup_complete", player, dInit => {
    sender.send("edit/" + player + "/USSR+Moscow+Infantry", dEdit => {
      let newUnit = Object.values(dEdit.created)[0];
      let newId = Object.keys(dEdit.created)[0];
      dInit.created[newId] = newUnit;
      gameloop(dInit);
    });
  });
}
function testEditModeCreateUnit_trial1() {
  sendInit(player, dInit => {
    gameloop(dInit);
  });
}
async function testFaKeysNotInGa() {
  initRSGData(); showGame(); initDom();
  let gaIcons = await route_rsg_asset('gameIconCodes');
  let faIcons = await route_rsg_asset('faIconCodes');
  let smallIcons = await route_rsg_asset('iconTest');
  faKeys = [];
  for (const k in faIcons) {
    if (nundef(gaIcons[k])) faKeys.push(k);
  }
  console.log('common keys:', faKeys);
  let board = makeDrawingArea('board', 'a_d_game', true);
  setAreaWidth('a_d_game', 2400);
  setAreaHeight('a_d_game', 1500);
  let keys = faKeys;
  let xStart = -1100;
  let yStart = -670;
  let y = yStart;
  let x = xStart;
  for (const k of keys) {
    addPictoFromChar('board', faIcons[k], 50, x, y);
    if (y > -yStart) { y = yStart; x += 60; } else y += 60;
  }
  // let key = chooseRandom(Object.keys(faChars));//'clock';
}
async function testFetchCsvAsTextAndSearch() {
  timit = new TimeIt('*timer', TIMIT_SHOW);
  await loadAssets();
  timit.show();
  mEmo('blue heart', 'table', 100);
  mFlexLinebreak('table');
  for (const k of ['cat', 'lion', 'tiger', 'leopard', 'horse', 'zebra', 'deer', 'ox', 'cow']) {
    let emo = mEmo(k, 'table', 50);
  }
}
function testFindKeys() {
}
async function testGeneralBoard(r, c, shape, hasNodes, hasEdges, { mapVariant, fieldContent, nodeContent, edgeContent } = {}) {
  let sdata = genServerDataGeneralBoard(r, c, shape, hasNodes, hasEdges, { mapVariant, fieldContent, nodeContent, edgeContent });
  console.log('sdata', sdata)
  let spec = {
    ROOT: { cond: { obj_type: 'Board' }, type: 'grid' }
  };
  if (isdef(fieldContent)) {
    spec.fields = { cond: { obj_type: 'Field' }, data: '.content' };
  }
  if (isdef(nodeContent)) {
    spec.nodes = { cond: { obj_type: 'Corner' }, data: '.content' };
  }
  if (isdef(edgeContent)) {
    spec.edges = { cond: { obj_type: 'Edge' }, data: '.content' };
  }
  await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
  mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}
function testGetElements() {
  let x = getElements([0, 1, 2]);
  console.log('x', x);
  x = getElements([[3, 2], [0, 1, 2]]);
  console.log('x', x);
}
function testGSM() {
  if (activatedTests.includes('GSM')) {
    console.log(...arguments);
  }
}
function testHelpers() {
  if (activatedTests.includes('helpers')) {
    console.log(...arguments);
  }
}
function testHexgrid() {
  if (activatedTests.includes('hexgrid')) {
    console.log(...arguments);
  }
}
function testIndenting() {
  let spc = '&nbsp;';
  let d = mDiv(mBy('table'));
  mSize(d, 200, 200);
  mColor(d, 'orange');
  let s = `
  hallo
    das ist
     ein
   string
    1
     2
      3`;
  s = s.replace('\t', '  ');
  let startLine = true;
  let lines = s.split('\n');
  let lineInfo = {};
  let html = '';
  for (let i = 0; i < lines.length; i += 1) {
    let line = lines[i];
    let n = countIndent(line, 4);
    console.log('_____________n=' + n, line);
    let x = spc.repeat(n) + line;
    html += x + '<br>';
    console.log(x)
  }
  let d1 = mText(html, d)
}
function TESTING_bar(fileName = getCurrentFileName(), myFunctionName = getFunctionsNameThatCalledThisFunction()) {
}
function TESTING_foo() {
  TESTING_bar();
}
function testingMS() {
  if (isdef(IdOwner.t)) IdOwner.t.map(x => addTestInteraction1(x));
}
function testInitToEnd(player = "USSR", seed = 0) {
  hide(bStop);
  sendInit(player, d => testRunToEnd(d, player), seed);
}
function testInno() {
}
function testInnoCardPhantasie() {
  dTable = mDiv(mBy('wrapper'), { position: 'absolute', padding: 10, w: '100vw', h: '100vh', bg: 'white' });
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable, { fg: 'black', bg: INNO.color.red, w: Card.sz, h: Card.sz * .65 });
  let [dCard, sz, szTitle, gap] = [iDiv(card), Card.sz / 4, 24, 8];
  let [dTitle, dMain] = cTitleArea(card, 32);
  let d = mAddContent(dTitle, 'MetalWorking', { bg: INNO.sym.tower.bg, fg: 'white', h: 32, fz: 23, align: 'center', position: 'relative' });
  mAddContent(d, '5', { float: 'right', hpadding: 10 });
  let s = mSym(INNO.sym.tower.key, d, { h: 22, fg: INNO.sym.tower.fg }, 'cl');
  let margin = 20;
  innoSym('leaf', dMain, sz, 'tl', margin);
  innoSym('crown', dMain, sz, 'bl', margin);
  innoSym('leaf', dMain, sz, 'bc', margin);
  innoSym('leaf', dMain, sz, 'br', margin);
  let box = mBoxFromMargins(dMain, 0, margin, sz + margin, sz + margin);
  let text = 'I demand if you get [tower] or [crown], immediately switch to age [2]. aber ich hab ja gott sei dank zeit! denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
  let t2 = innoText(text);
  mFillText(t2, box);
  return;
  box = mDiv(dMain, { w: sz, h: sz, bg: 'dimgrey', rounding: 10 }); mPlace(box, 'tl');
  s = mSym('white-tower', box, { sz: sz * .75, fg: 'silver' }, 'cc');
  box = mDiv(dMain, { w: sz, h: sz, bg: 'dimgrey', rounding: 10 }); mPlace(box, 'bl');
  s = mSym('frog', box, { sz: sz * .75, fg: 'silver' }, 'cc');
  box = mDiv(dMain, { w: sz, h: sz, bg: 'dimgrey', rounding: 10 }); mPlace(box, 'bc');
  s = mSym('maple-leaf', box, { sz: sz * .75, fg: 'silver' }, 'cc');
  box = mDiv(dMain, { w: sz, h: sz, bg: 'grey', alpha: .5, rounding: 10 }); mPlace(box, 'br');
  text = 'denn wenn es nicht geht und ich bin muede dann halt nicht!';
  mFillText(text, box);
  box = mBoxFromMargins(dMain, 4, 4, sz + 8, sz + 10);
  text = 'das muss jetzt ein viel laenderer text sein. aber ich hab ja gott sei dank zeit! denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
  mFillText(text, box);
  return;
  text = 'das ist ein sehr langer text ich hoffe er ist auf jeden fall zu lang fuer diese box. denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
  box = mPlaceText(text, [szTitle, 10, sz + gap, sz + gap], d, { fg: 'dimgrey' }, { bg: 'beige', border: '1px solid grey', rounding: 10 });
  text = 'denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
  box = mPlaceText(text, [sz, sz, 'bl'], d, { fg: 'dimgrey', bg: 'pink', rounding: 10, border: '5px solid pink' });
  let x1 = mSym('crow', d, { w: sz, h: sz, fg: 'green' }, 'br');
  x1 = mSym('abacus', d, { w: sz, h: sz }, 'bc');
  box = mPlaceText('hallo das ist noch ein echo!!!', [sz, sz, 'tl'], d, { fg: 'blue', bg: 'orange', rounding: 10 });
}
function testInnoMain() {
  mStyle(dTable, { gap: 10, pabottom: 150 });
  for (const k in Cinno) {
    if (isdef(Cinno[k].expansion)) cardInno(dTable, k);
  }
}
function testIntegrationCards(filename = "prod_complete", player = "Axis") {
  execOptions.output = "none";
  addIf_dep("cards", execOptions.activatedTests);
  if (empty(filename)) {
    sendInit(player, gameloop, 0);
  } else {
    sendLoading(filename, player, gameloop);
  }
}
function testIntegrationMap(filename = "prod_complete", player = "Axis") {
  execOptions.output = "none";
  addIf_dep("map", execOptions.activatedTests);
  if (empty(filename)) {
    sendInit(player, gameloop, 0);
  } else {
    sendLoading(filename, player, gameloop);
  }
}
function testIntegrationUnits(filename = "", player = "USSR", seed = 4) {
  execOptions.output = "none";
  addIf_dep("units", execOptions.activatedTests);
  if (empty(filename)) {
    sendInit(player, gameloop, seed);
  } else {
    sendLoading(filename, player, gameloop);
  }
}
function testjourney0() {
  let [fen, uname] = [Z.fen, Z.uname];
  let plist = find_players_with_potential_journey(fen);
  console.log('journey players', plist);
  if (!plist.includes(uname)) {
    set_nextplayer_after_journey();
    console.log('Z.turn', Z.turn)
    take_turn_fen();
  }
}
function testJustARect() {
  let svg = new MMS({ parent: UIS.a_d_game, type: 'svg' }).setDefaults({ bg: 'green' }).attach();
  let rect = new MMS({ parent: svg, type: 'rect' }).setDefaults({ w: 50, h: 50, bg: 'red' }).attach();
}
function testKarte0() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz;
  let suit = mSuit('Pik', d, { h: 300 });
  let p = suit.firstChild;
  console.log('p', p);
  console.log('child', p.firstChild);
}
function testKarte1() {
  let card = cLandscape(dTable);
  let sz = card.sz;
  console.log('sz', sz)
  let d = iDiv(card);
  let x = mShape('triangle', d, { bg: 'blue', w: sz / 4, h: sz / 4, position: 'absolute', top: 10, left: 10 });
  x = mShape('test1', d, { bg: 'red', w: sz / 4, h: sz / 4, position: 'absolute', bottom: 10, left: 10 });
  x = mSym('bee', d, { fz: sz / 5, position: 'absolute', bottom: 10, right: 10 });
  x = mDiv(d, { bg: YELLOW, w: sz / 4, h: sz / 4, position: 'absolute', top: 10, right: 10 }, null, null, 'triangle');
  let text = 'diese karte erlaubt es dir, zu verschwinden und aufzutauchen wo immer du willst.<br><br>pass jedoch auf: wenn du auf einer ungesicherten mine landest, verlierst du 1 leben!';
  let [fz, w, h] = fitFont(text, 20, sz, sz / 2);
  let pos = { left: (card.w - w) / 2, top: (card.h - h) / 2 }
  x = mDiv(d, { align: 'left', fz: fz, fg: 'black', w: w, h: h, top: pos.top, left: pos.left, display: 'inline-block', position: 'absolute' }, null, text);
  console.log('x', x)
  let sh0 = [
    `<div class="triangle"></div>`,
    `<div class="triangle type2" style="--b:linear-gradient(red,blue);"></div>`,
    `<div class="triangle type3" style="--b:conic-gradient(green,pink,green);"></div>`,
    `<div class="triangle hex" style="--b:url(https://picsum.photos/id/1067/200/200) center/cover;"></div>`,
    `<div class="triangle hex" style="--b:url(../assets/images/felix.jpg) center/cover;"></div>`,
  ];
  let sh = [
    `<div class="weired"></div>`,
    `<div class="weired" style="--b:linear-gradient(red,blue);"></div>`,
    `<div class="weired" style=
    "--b:conic-gradient(green,pink,green);
    --clip:polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    --patop:100%;
    "></div>`,
    //`<div class="triangle hex" style="--b:url(https://picsum.photos/id/1067/200/200) center/cover;"></div>`,
  ];
  for (const sh1 of sh) {
    x = createElementFromHtml(sh1);
    mStyle(x, { w: 80 });
    mAppend(dTable, x);
  }
  return;
  let styles = { margin: 10, bg: 'random' };
  for (let i = 0; i < 3; i++) { let d = mShape('triangle', dTable); console.log('d', d); }
}
function testKarte2() {
  let card = cLandscape(dTable);
  let isLandscape = card.w > card.h;
  let sz = card.sz;
  console.log('sz', sz)
  let text = 'diese karte erlaubt es dir, zu verschwinden und aufzutauchen wo immer du willst.<br><br>pass jedoch auf: wenn du auf einer ungesicherten mine landest, verlierst du 1 leben!';
  let d = iDiv(card);
  let sh = [
    { type: 'html', pos: 'TL', sz: 's', content: `<div class="weired"></div>` },
    { type: 'html', pos: 'TR', sz: 's', content: `<div class="weired" style="--b:linear-gradient(red,blue);"></div>` },
    {
      type: 'html', pos: 'BL', sz: 's', content: `<div class="weired" style=
    "--b:conic-gradient(green,pink,green);
    --clip:polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    --patop:100%;
    "></div>`},
    {
      type: 'html', pos: 'BR', sz: 's', content: `<div class="weired" style=
    "--b:url(../assets/images/felix.jpg) center/cover;
    --clip:polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    --patop:100%;
    "></div>`},
    { type: 'text', pos: 'CC', sz: 'l', content: 'diese karte erlaubt es dir, zu verschwinden und aufzutauchen wo immer du willst.<br><br>pass jedoch auf: wenn du auf einer ungesicherten mine landest, verlierst du 1 leben!' },
  ];
  var SZ = sz;
  var GAP = SZ * .1;
  var SIZE = { xs: SZ / 8, s: SZ / 4, m: SZ / 2, l: SZ * 2 / 3, xl: SZ };
  var POS = { TL: { top: GAP, left: GAP }, TR: { top: GAP, right: GAP }, BL: { bottom: GAP, right: GAP }, BR: { bottom: GAP, right: GAP } };
  for (const sh1 of sh) {
    let t = sh1.content;
    x = isString(t) ? t[0] == '<' ? createElementFromHtml(t) : makeText(t, sz, sz / 2) : t;
    mAppend(d, x);
    let pos = sh1.pos;
    if (pos != 'CC') {
      mStyle(x, { w: 80 });
      window['mPos' + sh1.pos](x, 10);
    }
  }
}
function testKarte3_svg() {
  mStyle(dTable, { gap: 10 }); let card;
  card = cBlankSvg(dTable);
  console.log('card', card);
  let g = iG(card); console.log('g', g);
  let x = mgSuit('Pik'); console.log('x', x);
  mgSize(x, Card.sz / 2);
  mgPos(card, x);
}
function testKarte4() {
  mStyle(dTable, { gap: 10 }); let card;
  card = cBlank(dTable);
  let d = iDiv(card);
  let sz = Card.sz;
  let arr = [];
  let suit = mSuit('Pik');
  let triangle = mShape('triangle', null, { bg: 'red' });
  let sym = mSym('frog');
  let shape = mShape('test1');
  let x = mShapeX98(); console.log('\nx', x); mAppend(d, x);
  return;
  let h = sz / 4;
  suit.setAttribute('height', h);
  mStyle(sym, { fz: h * .75 });
  mSize(shape, h * .75);
  mSize(triangle, h * .75);
  arr = [triangle, suit, sym, shape, x];
  console.log('\nx', x);
  mAppend(d, x); return;
  for (const x of arr) { mAppend(d, x); }
  gSizeToContent(suit);
}
function testKarte5() {
  for (let i = 0; i < 10; i++) {
    let n = i * 15;
    let x = mShapeR(); console.log('\nx', x);
    mStyle(x, { w: n }); mClassReplace(x, 'weired' + (n > 120 ? 8 : n > 80 ? 5 : n > 50 ? 3 : 1));
    mAppend(dTable, x);
  }
}
function testKarte6() {
  for (let i = 0; i < 10; i++) {
    let n = i * 15;
    let x = mShapeR('triup', dTable, { sz: n, bg: 'random' }); console.log('\nx', x); mAppend(dTable, x);
  }
}
function testKarte8() {
  for (let i = 0; i < 1; i++) {
    testKarte7();
  }
}
function testKartePosition1() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 4;
  let s3 = mSuit('Pik', d); mSuitSize(s3, 30); mSuitTL(s3); console.log('s3', s3);
  let s4 = mSuit('Treff', d); mSuitSize(s4, 30); mSuitPos(s4, 'bottom', 'right'); console.log('s4', s4);
  let s5 = mSuit('Herz', d, { sz: 30 }); mSuitPos(s5, 'bottom', 'left'); console.log('s5', s5);
  let s6 = mSuit('Karo', d, { sz: 30 }); mSuitPos(s6, 'top', 'right'); console.log('s6', s6);
  return;
  console.log('suit', suit);
  mPos(suit, 0, 0);
  mPos(suit1, -10, Card.h - sz);
  mPos(suit1, -10 * sz / 100, Card.h - sz);
}
function testKartePosition2() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 4;
  let s1 = mSuit('Pik', d, { sz: 25 }, 'tl'); console.log('s1', s1);
  let s2 = mSuit('Karo', d, { sz: 50 }, 'tr'); console.log('s2', s2);
  let s3 = mSuit('Herz', d, { sz: 75 }, 'bl'); console.log('s3', s3);
  let s4 = mSuit('Treff', d, { sz: 100 }, 'br'); console.log('s4', s4);
}
function testKartePositionSuit() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 6;
  let s1 = mSuit('Herz', d, { sz: sz }, 'tc');
  let s2 = mSuit('Herz', d, { sz: sz }, 'cr');
  let s3 = mSuit('Herz', d, { sz: sz }, 'bc');
  let s4 = mSuit('Herz', d, { sz: sz }, 'cl');
  let s5 = mSuit('Pik', d, { sz: sz * 2 }, 'cc');
  s5 = mSuit('Treff', d, { sz: sz * 1.5 }, 'tl');
  s5 = mSuit('Treff', d, { sz: sz * 1.5 }, 'tr');
  s5 = mSuit('Treff', d, { sz: sz * 1.5 }, 'bl');
  s5 = mSuit('Treff', d, { sz: sz * 1.5 }, 'br');
}
function testKartePositionSuitOuterCenters() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 4;
  let s1 = mSuit('Pik', d, { sz: 60 }, 'tc'); console.log('s1', s1);
  let s2 = mSuit('Karo', d, { sz: 60 }, 'cr'); console.log('s2', s2);
  let s3 = mSuit('Herz', d, { sz: 60 }, 'bc'); console.log('s3', s3);
  let s4 = mSuit('Treff', d, { sz: 60 }, 'cl'); console.log('s4', s4);
}
function testKarteSizing() {
  mStyle(dTable, { gap: 10 }); let card;
  card = cBlank(dTable);
  let d = iDiv(card);
  let sz = Card.sz;
  let arr = [];
  let suit = mSuit('Pik');
  let triangle = mShape('triangle', null, { bg: 'red' });
  let sym = mSym('frog');
  let shape = mShape('test1');
  let x = mShapeR();
  let h = sz / 4;
  suit.setAttribute('height', h);
  mStyle(sym, { fz: h * .75 });
  mSize(shape, h * .75);
  mSize(triangle, h * .75);
  mStyle(x, { w: h * .75 }); mClassReplace(x, 'weired1');
  arr = [triangle, suit, sym, shape, x];
  for (const x of arr) { mAppend(d, x); }
  gSizeToContent(suit);
}
function testKnight() {
  let c = makeCard(0, 'hallo');
  c.mount(d);
  c.setSide('front');
  blank(c);
  setTitle(c, 'Knight')
  setText(c, 'You can play this card whenever you want to move the robber!')
  moveTo(c, -100, -100);
}
function testLines() {
  initRSGData(); showGame(); initDom();
  let board = makeDrawingArea('board', 'a_d_game', true);
  let mobj = makeDrawingElement('el1', 'board');
  mobj.line({ thickness: 10, cap: 'round' }).setBg('red').attach();
  console.log(mobj)
  console.log(mobj.elem)
  let [x1, y1, x2, y2] = mobj.getEndPointsOfLineSegmentOfLength(40);
  let ms2 = makeDrawingElement('el2', 'board');
  ms2.line({ thickness: 15, x1: x1, y1: y1, x2: x2, y2: y2 }).setBg('blue').attach();
  [x1, y1, x2, y2] = mobj.getEndPointsOfLineSegmentOfLength(120);
  let ms3 = makeDrawingElement('el3', 'board');
  ms3.line({ thickness: 5, x1: x1, y1: y1, x2: x2, y2: y2 }).setBg('green').attach();
}
function testLoadSpring(filename = "spring_start", player = "Axis") {
  execOptions.output = "none";
  if (empty(filename)) {
    sendInit(player, gameloop, 5);
  } else {
    sendLoading(filename, player, gameloop);
  }
}
function testLoadToEnd(player = "Axis", filename = "setup_complete") {
  hide(bStop);
  sendLoading(filename, player, d => testRunToEnd(d, player), "raw");
}
function testLookupRemoveFromList() {
  let d = { a: { b: [2] } };
  let res = lookupRemoveFromList(d, ['a', 'b'], 2);
  console.log('res', res, 'd', d);
  d = { a: { b: [2] } };
  res = lookupRemoveFromList(d, ['a', 'b'], 2, true);
  console.log('res', res, 'd', d);
  d = { a: { b: [2, 3] } };
  res = lookupRemoveFromList(d, ['a', 'b'], 3, true);
  console.log('res', res, 'd', d);
  d = { a: [0, [2], { b: [] }] };
  res = lookupRemoveFromList(d, ['a', 1], 2);
  console.log('res', res, 'd', d);
}
function testMakeACanvas() {
  let dParent = mBy('table');
  let div = stage3_prepContainer(dParent);
  div.style.width = 400 + 'px';
  div.style.height = 300 + 'px';
  mColor(div, 'orange');
  let svg = gSvg();
  let style = `margin:0;padding:0;position:absolute;top:0px;left:0px;width:100%;height:100%;`
  svg.setAttribute('style', style);
  mColor(svg, 'green');
  div.appendChild(svg);
  let g = gG();
  g.style.transform = "translate(50%, 50%)";
  gBg(g, 'blue');
  svg.appendChild(g);
  return g;
}
function testMakeAreas(dParent) {
  let dGrid = mDiv(dParent, { gap: 10, bg: 'white', w: '90%', padding: 10, display: 'inline-grid', rounding: 10 }, 'dGrid');
  let layout = ['T', 'H A'];
  let x = createGridLayout(dGrid, layout);
  let areaStyles = { bg: 'green', hmin: 200, rounding: 6 };
  let contentStyles = { lowerRounding: 6 };
  let messageStyles = { fg: 'yellow' };
  let titleStyles = { bg: 'dimgray', family: 'AlgerianRegular', upperRounding: 6 };
  let areas = {
    T: { title: 'table', id: 'dTrick', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles, titleOnTop: true },
    H: { title: 'YOU', id: 'dHuman', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles, titleOnTop: false },
    A: { title: 'opponent', id: 'dAI', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles, titleOnTop: false },
  };
  let items = [];
  for (const k in areas) {
    let item = areas[k];
    item.areaStyles['grid-area'] = k;
    let dCell = mTitledMessageDiv(item.title, dGrid, item.id, item.areaStyles, item.contentStyles, item.titleStyles, item.messageStyles, item.titleOnTop)
    iRegister(item, item.id);
    if (item.titleOnTop) iAdd(item, { div: dCell, dTitle: dCell.children[0], dMessage: dCell.children[1], dContent: dCell.children[2] });
    else iAdd(item, { div: dCell, dTitle: dCell.children[2], dMessage: dCell.children[0], dContent: dCell.children[1] });
    mCenterCenterFlex(diContent(item));
    mStyle(diContent(item), { gap: 10 });
    items.push(item);
  }
  return items;
}
function testManualCircleOnG() {
  let svg = new MMS({ parent: UIS.a_d_game, type: 'svg' }).setDefaults({ bg: 'green' }).attach();
  let g = new MMS({ parent: svg, type: 'g' }).setDefaults({ bg: 'blue' }).attach();
  let circle = new MMS({ parent: g, type: 'ellipse' }).attach();
  let r = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
  r.setAttribute('rx', 35);
  r.setAttribute('ry', 45);
  r.setAttribute('cx', 0);
  r.setAttribute('cy', 0);
  r.setAttribute('fill', 'yellow');
  g.elem.appendChild(r);
}
function testMovement(filename = "test_movement", player = "Axis") {
  execOptions.output = "none";
  if (empty(filename)) {
    sendInit(player, gameloop, 5);
  } else {
    sendLoading(filename, player, gameloop);
  }
}
function testMS_fine() {
  if (activatedTests.includes('MS_fine')) {
    console.log(...arguments);
  }
}
function testMuell0() {
  dTable = makePage();
  mStyle(dTable, { display: 'flex', })
  let dGrid = mDiv(dTable, { wmin: 110, hmin: 70, bg: 'white', padding: 3, rounding: 6 });
  let d = mTitledMessageDiv('title', dGrid, 'id1',
    { bg: 'green', rounding: 6 },
    { lowerRounding: 6 },
    { bg: 'dimgray', align: 'center', 'line-height': 30, family: 'AlgerianRegular', upperRounding: 6 },
    { fg: 'yellow', padding: 10 },
    true);
}
function testMultiline() {
  let d = mDiv(mBy('table'));
  mSize(d, 200, 200);
  mColor(d, 'orange');
  let s = ' hallo\n\tdas\n   ist\n\t\tda';
  let dMulti = mMultiline(s, 2, d);
}
function testNewMSAPI() {
  initRSGData(); showGame(); initDom();
  let board = makeDrawingArea('board', 'a_d_game', true);
  let mobj = makeDrawingElement('el1', 'board');
  _makeGroundShape(mobj, 0, 25, 100, 100, 'blue', 'quad', { scaleY: 2, rot: 45 });
  mobj.attach();
  console.log(mobj)
}
function testObjectWithUiAndClasses() {
  let n = { uid: '_1' };
  let d = mCenteredNode({ a: 'HALLO', b: 'geh' });
  console.log(d, d.classList);
  mSize(d, 100, 50);
  mAppend(mBy('table'), d);
  mCenterText(d.firstChild);
  mClass(d.firstChild, 'centered')
  n.class = ['centered'];
  console.log('line2', d, d.classList);
  n.ui = d;
  let dDesc = mNodeFilter(n, { dParent: mBy('table'), lstShow: ['uid', 'class'] });
}
function testOutput(o) {
  return;
  for (const key in o) {
    const arg = o[key];
    if (isNumber(key) && key <= execOptions.outputLevel) {
      console.log(H.moveCounter + ':', ...arg);
    }
  }
}
function testPageHeader() {
  pageHeaderClearAll();
  pageHeaderSetGame();
  pageHeaderAddPlayer('username', 'playerId', 'green', true);
}
async function testPicto(n) {
  initRSGData(); showGame(); initDom();
  let board = makeDrawingArea('board', 'a_d_game', true);
  let keys = ['achievement', 'wheat', 'criminal', 'police', 'cop', 'trophy', 'victory', 'plenty', 'fruit', 'bounty', 'house', 'castle', 'building', 'settlement', 'city', 'robber', 'thief', 'street', 'road'];
  let y = -300;
  let x = -300;
  let i = 0;
  timit.showTime('************server');
  iconChars = await vidCache.load('iconChars', route_iconChars);
  timit.showTime('iconChars');
  console.log(iconChars);
  for (const k of keys) {
    addPicto('board', k, 50, x, y);
    if (y > 250) { y = -300; x += 60; } else y += 60;
    i += 1; if (i >= n) break;
  }
}
function testPicto_dep(n) {
  initRSGData(); showGame(); initDom();
  let board = makeDrawingArea('board', 'a_d_game', true);
  let keys = ['achievement', 'wheat', 'criminal', 'police', 'cop', 'trophy', 'victory', 'plenty', 'fruit', 'bounty', 'house', 'castle', 'building', 'settlement', 'city', 'robber', 'thief', 'street', 'road'];
  let y = -300;
  let x = -300;
  let i = 0;
  loadIconChars([() => {
    console.log(iconChars);
    for (const k of keys) {
      addPicto('board', k, 50, x, y);
      if (y > 250) { y = -300; x += 60; } else y += 60;
      i += 1; if (i >= n) break;
    }
  }]);
}
function testPlayerHand1() {
  G.table = cards1;
  G.playersAugmented = {
    White: {
      devcards: { _set: [{ _obj: 'c1' }, { _obj: 'c3' }] }
    }
  };
  _showHand(['c1', 'c2', 'c3'], 'a_d_game');
}
function testPos00() {
  let board = [
    ['bk', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
    ['em', 'bn', 'em', 'wr', 'em', 'wp', 'em', 'em'],
    ['br', 'em', 'bp', 'em', 'em', 'bn', 'wn', 'em'],
    ['em', 'em', 'bp', 'bp', 'bp', 'em', 'wp', 'bp'],
    ['bp', 'bp', 'em', 'bp', 'wn', 'em', 'wp', 'em'],
    ['em', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
    ['em', 'em', 'em', 'wk', 'em', 'em', 'em', 'em'],
    ['em', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
  ];
  console.log(board_to_fen(board));
}
function testPosition3() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 5;
  let x1 = mShapeR('hex', null, { w: sz, h: sz, bg: 'random' }); console.log('\nx1', x1);
  for (const p of ['tl', 'tc', 'tr', 'cl', 'cc', 'cr', 'bl', 'bc', 'br']) {
    let x2 = x1.cloneNode(); mAppend(d, x2); mPlace(x2, p, 20);
  }
}
function testPositionCardSym() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 5;
  let x1 = mSym('crow', d, { w: sz, h: sz, bg: 'random' }, 'cc'); console.log('\nx1', x1);
}
function testPositionPatterns() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 5;
  let x1 = mShapeR('hex', null, { w: sz, h: sz, bg: 'random' }); console.log('\nx1', x1);
  for (const p of ['tl', 'tc', 'tr', 'cl', 'cc', 'cr', 'bl', 'bc', 'br']) {
    let x2 = x1.cloneNode(); mAppend(d, x2);
    mPlace(x2, p, p.includes('c') ? 0 : 20);
  }
}
function testPositionPatterns1() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 5;
  let x1 = mShapeR('circle', null, { w: sz, h: sz, bg: 'random' }); console.log('\nx1', x1);
  for (const p of ['tl', 'tr', 'bl', 'br']) {
    let x2 = x1.cloneNode(); mAppend(d, x2);
    mPlace(x2, p, 20);
  }
  for (const p of ['tc', 'cl', 'cc', 'cr', 'bc']) {
    let x2 = x1.cloneNode(); mAppend(d, x2);
    mPlace(x2, p);
  }
}
function testPositionShapeR0() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = Card.sz / 4;
  let x1 = mShapeR('triup', d, { sz: sz, bg: 'random' }); console.log('\nx1', x1);
  mPlace(x1, 'tl');
  let x2 = mShapeR('hex', d, { sz: sz, bg: 'random' }); console.log('\nx1', x2);
  mPlace(x2, 'tr');
  let x3 = mShapeR('triangle', d, { sz: sz, bg: 'random' }); console.log('\nx1', x3);
  mPlace(x3, 'br');
  let x4 = mShapeR('hexFlat', d, { sz: sz, bg: 'random' }); console.log('\nx1', x4);
  mPlace(x4, 'bl');
}
function testRandomSeries(G, n, callback) {
  sender.send("init/hotseat/Axis/1", dInit => {
    testRandomSeriesRec([], dInit, G, n, callback);
  });
}
function testRandomSeries_sendInit(lst, G, n, callback) {
  sendInit(
    G.player,
    dInit => {
      lst.push();
      testRandomSeriesRec(dInit, G, n - 1, callback);
    },
    G.seed
  );
}
function testRandomSeriesRec(lst, dInit, G, n, callback) {
  sender.send("randint/" + 100, di => {
    let x = di.int;
    lst.push(x);
    if (n > 0) {
      testRandomSeriesRec(lst, dInit, G, n - 1, callback);
    } else {
      callback(dInit);
    }
  });
}
function testRectanglesTextInBoxesW0() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable, { w: Card.sz, h: Card.sz * .8 });
  let [d, sz, szTitle, gap] = [iDiv(card), Card.sz / 4, 24, 8];
  let box = mBoxFromMargins(d, szTitle, 10, sz + gap, sz + gap);
  let r = mMeasure(box);
  text = 'das ist ein sehr langer text ich hoffe er ist auf jeden fall zu lang fuer diese box. denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
  let [fz, w, h] = fitFont(text, 20, r.w, r.h);
  console.log('res', fz, w, h);
  let dText = mDiv(box, {
    w: w, h: h, fz: fz, fg: 'black',
    position: 'absolute', transform: 'translate(-50%,-50%)', top: '50%', left: '50%'
  }, null, text);
  box = mDiv(d, { w: sz, h: sz });
  mPlace(box, 'bl');
  r = mMeasure(box);
  text = 'denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
  [fz, w, h] = fitFont(text, 20, r.w, r.h);
  console.log('res', fz, w, h);
  dText = mDiv(box, {
    w: w, h: h, fz: fz, fg: 'black',
    position: 'absolute', transform: 'translate(-50%,-50%)', top: '50%', left: '50%'
  }, null, text);
  mPlaceText('hallo das ist noch ein echo!!!', [sz, sz, 'tl'], d, { fg: 'blue' }, { bg: 'orange', border: '1px dashed red', rounding: 10 });
}
function testRectanglesW1() {
  mStyle(dTable, { gap: 10 }); let card = cBlank(dTable, { w: Card.sz, h: Card.sz * .8 });
  let [d, sz, szTitle, gap] = [iDiv(card), Card.sz / 4, 24, 8];
  let text = 'das ist ein sehr langer text ich hoffe er ist auf jeden fall zu lang fuer diese box. denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
  box = mPlaceText(text, [szTitle, 10, sz + gap, sz + gap], d, { fg: 'dimgrey' }, { bg: 'beige', border: '1px solid grey', rounding: 10 });
  text = 'denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
  box = mPlaceText(text, [sz, sz, 'bl'], d, { fg: 'dimgrey', bg: 'pink', rounding: 10, border: '5px solid pink' });
  let x1 = mSym('crow', d, { w: sz, h: sz, fg: 'green' }, 'br');
  x1 = mSym('abacus', d, { w: sz, h: sz }, 'bc');
  box = mPlaceText('hallo das ist noch ein echo!!!', [sz, sz, 'tl'], d, { fg: 'blue', bg: 'orange', rounding: 10 });
}
function testRegexSplit() {
  let res = '\nfunction \nfunction hallo(){return "hallo";}\nasync function hallo1(){return "hallo1";}'
  let regex = new RegExp('\nasync function|\nfunction|\nvar|\nconst|\nclass', 'g');
  let fcode = res.split(regex);
  console.log(fcode);
}
function testRemoveBoard(R) {
  let oid = detectFirstBoardObject(R);
  console.log('testRemoveBoard: first board object detected has oid', oid);
  removeServerObject(oid, 'board');
}
function testRemoveInfluence(mapController, gObjects) {
  let data = {};
  addIf_dep("map", execOptions.activatedTests);
  data.removed = {
    "507565": {
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 507565
    },
    "531772": {
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 531772
    },
    "531773": {
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 531773
    },
    "531774": {
      value: 2,
      nation: "Norway",
      faction: "Axis",
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 531774
    },
    "531775": {
      value: 4,
      nation: "Latin_America",
      faction: "Axis",
      obj_type: "influence",
      visible: {
        xset: ["Axis", "USSR", "West"]
      },
      _id: 531775
    }
  };
  mapController.update(data, gObjects);
}
function testRemoveObject(R) {
  let data = dict2list(sData);
  data = data.filter(x => (nundef(x.fields)) && nundef(x.neighbors));
  data = data.filter(x => firstCondDict(R.rNodes, y => y.oid == x.id));
  console.log('data gefiltered:', data)
  if (isEmpty(data)) {
    console.log('no objects left in sData!!!');
    return;
  }
  let oid = chooseRandom(data).id;
  removeServerObject(oid, 'random');
}
function testRemoveOidKey(R) {
  let n = getRandomUidNodeWithAct(R);
  if (!n) {
    console.log('there is no oid to remove!!!');
    return;
  }
  let [oid, key] = [n.oid, n.key];
  let nodeInstances = lookup(R.rNodesOidKey, [oid, key]);
  console.log('_________ testRemoveOidKey', 'remove all', oid, key, nodeInstances);
  removeOidKey(oid, key, R);
  updateOutput(R);
}
function testResizeEllipse(g) {
  let el = agEllipse(g, 100, 100);
  gBg(el, 'violet');
  gPos(el, 100, 110);
  gSize(el, 50, 20);
}
function testResizeHex(g) {
  let el = agHex(g, 50, 50);
  gBg(el, 'blue');
  gPos(el, 100, 110);
  gSize(el, 20, 20, 'hex');
}
function testResizeRect(g) {
  let el = agRect(g, 100, 50);
  gBg(el, 'violet');
  gPos(el, 100, 110);
  gSize(el, 50, 20);
}
function testRunToEnd(data, player) {
  let tuples = getTuples(data);
  if (empty(tuples)) {
    let waitingSet = getSet(data, "waiting_for");
    if (empty(waitingSet)) {
      error("NO ACTIONS AND EMPTY WAITING SET... sending empty action!!!");
      sendAction(player, ["none"], d => testRunToEnd(d, player));
    } else {
      let nextPlayer = waitingSet[0];
      sendChangeToPlayer(nextPlayer, d1 => {
        testRunToEnd(d1, nextPlayer);
      });
    }
  } else {
    decider.pickTuple(tuples, t => {
      sendAction(player, t, d => testRunToEnd(d, player));
    });
  }
}
function tests0_table_drawloop() {
  dTable = mBy('dTable'); mStyle(dTable, { vpadding: 20, bg: BLUE, align: 'center' });
  G = { items: [] };
  TO.running = setInterval(drawloop, 100);
  test1ttt();
}
function tests1_canvas_vs_dom() {
  let dPage = mBy('dTable'); mCenterCenterFlex(dPage); mStyle(dPage, { gap: 4 });
  G = { items: [] };
  dHeader = mDivLine(dPage);
  mLinebreak(dPage);
  let st = { w: 300, h: 250, bg: 'randlight' };
  let c1 = new ccanvas(dPage, st);
  mLinebreak(dPage);
  dTable = mDiv(dPage, st);
  mLinebreak(dPage);
  let c2 = new ccanvas(dPage, st);
  mLinebreak(dPage);
  dFooter = mDivLine(dPage);
  mLinebreak(dPage);
}
function testSaveLoadUiTree() {
  let uiTree = jsCopyMinus(T.uiTree, 'act', 'ui', 'defParams', 'params');
  console.log(uiTree);
}
async function testsendupdate() {
  let data = {
    user: isdef(U) ? U.name : 'felix',
    game: 'paris',
    fen: dixit_setup(['mimi', 'felix']),
    turn: ['felix'],
    step: 1,
  }
  let o = { type: 'updategame', data: data };
  let ostring = JSON.stringify(o);
  mBy('inpost').value = ostring;
  let res = await route_post_form_callback_js('/singlepost', 'fRoute', data => console.log('got from serverr', data))
}
function testSetBgOnSvgInsteadOfG() {
  let g = new MMS({ parent: UIS.a_d_game, type: 'g' }).setDefaults({ bg: 'yellow' }).attach();
}
function testShapes() {
  initRSGData(); showGame(); initDom();
  let board = makeDrawingArea('board', 'a_d_game', true);
  let mobj = makeDrawingElement('el1', 'board');
  let sz = 200;
  let c = 'blue';
  let c1 = colorFrom('green', .1);
  console.log(c1);
  makeVisual(mobj, 0, 0, sz, sz, c1, 'quad');
  mobj.text({ txt: 'hallo', fill: colorDarker(c), fz: 30, y: -sz / 3 });
  mobj.ellipse({ w: sz / 2, h: sz / 2, fill: 'green', alpha: .5 })
  mobj.attach();
  mobj.addClickHandler('', () => {
    mobj.setShape('star');
  });
  let ms1 = makeDrawingElement('el2', 'board');
  makeVisual(ms1, -sz, 0, sz, sz, c1, 'triangle');
  ms1.attach();
}
async function testSolutionConverter() {
  let series = TEST_SERIES;
  let sols = await loadSolutions(series);
  console.log('solutions', sols);
  await saveSolutions(series, sols);
}
function testSorting() {
  let o = { z: [3, 2, 5, 1], d: { w: 2, r: 3 } };
  let d = mBy('spec');
  mNodeFilter(o, { dParent: d, title: 'orig' });
  mNodeFilter(o, { sort: 'all', dParent: d, title: 'sorted' });
  mNodeFilter(o, { sort: 'keys', dParent: d, title: 'justkeys' });
}
async function testSpeech() {
  await loadAssets();
  hide('floatingMenu');
  let table = mBy('table');
  let e = mEmo('red heart', table, 200);
  e.style.color = 'red';
  mFlexLinebreak(table);
  lang = 'E';
  matchingWords = ['heart'];
  if (isEnglish(lang)) {
    mInstruction('Say the word in English', table);
  } else {
    mInstruction('Sag das Wort auf Deutsch', table);
  }
  mFlexLinebreak(table);
  hintMessage = mHeading('HALLO', table, 1, 'hint');
  mFlexLinebreak(table);
  resultMessage = mText('jajaja', table);
  resultMessage.id = 'result';
  resultMessage.style.marginTop = '200px';
  resultMessage.style.fontSize = '20pt';
}
function testSplitIntoNumbersAndWords() {
  let ss = ['1k 2queen', '1 k 12 q', '12king2queen', '31 ace 2queen', '1 3 3 4', '1 10 3 8', '1J3As', '12 koenig 2 Ass'];
  for (const s of ss) {
    let x = splitIntoNumbersAndWords(s);
  }
}
function testSpotit() {
  let [rows, cols, numCards, setName] = [3, 2, 3, 'animals'];
  let infos = spotitDeal(rows, cols, numCards, setName);
  let items = [];
  for (const info of infos) {
    let item = spotitCard(info, dTable, { margin: 10 }, spotitOnClickSymbol);
    items.push(item);
  }
  return;
  for (const item of items) {
    for (const k in item.shares) {
      let other = Items[item.shares[k]];
    }
  }
}
function testStep(data, player) {
  let tuples = getTuples(data);
  if (empty(tuples)) {
    let waitingSet = getSet(data, "waiting_for");
    if (empty(waitingSet)) {
      error("NO ACTIONS AND EMPTY WAITING SET... sending empty action!!!");
      nextAction = () => sendAction(player, ["none"], d => testStep(d, player));
    } else {
      let nextPlayer = waitingSet[0];
      nextAction = () =>
        sendChangeToPlayer(nextPlayer, d1 => {
          testStep(d1, nextPlayer);
        });
    }
  } else {
    decider.pickTuple(tuples, t => {
      sendAction(player, t, d => testStep(d, player));
    });
  }
  show(bStep);
}
function testStepByStep(player = "Axis", filename = "gov_complete") {
  sendLoading(filename, player, d => testStep(d, player), "raw");
}
function testSuperGenialDivAndGBehavingTheSame() {
  let msD = new MMS({ parent: UIS.a_d_game, type: 'div' }).rect({ x: 20, y: 100, w: 50, h: 50, bg: 'blue' }).attach();
  let msG = new MMS({ parent: UIS.a_d_game, type: 'g' }).rect({ x: 20, y: 100, w: 25, h: 25, bg: 'red' }).attach();
  console.log(msD.elem, msG.elem)
}
function testSvgGRectTakesBg() {
  let svg = new MMS({ parent: UIS.a_d_game, type: 'svg' }).setDefaults().attach();
  let g = new MMS({ parent: svg, type: 'g' }).setDefaults({ bg: 'red' }).attach();
  let rect = new MMS({ parent: g, type: 'rect' }).setDefaults({ w: 50, h: 50, bg: 'yellow' }).attach();
  g.centerOrigin();
}
async function testTtt(r, c) {
  let sdata = genServerDataTtt(r, c);
  let spec = { ROOT: { cond: { obj_type: 'Board' }, type: 'grid', data: '.uid' } };
  await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
  mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}
function testVCentered() {
  let dTable = mBy('table');
  let d = mDiv(dTable);
  mSize(d, 100, 100);
  mColor(d, 'blue');
  let d1 = mText('HALLO', d);
  mCenterV(d1);
}
function textCorrectionFactor(text, styles, w, h, fz) {
  styles.fz = fz;
  let size = getSizeWithStyles(text, styles);
  if (Math.abs(size.h - h) > fz) { return size.h / h; } else return 0;
}
function ThreeFoldRep() {
  var i = 0, r = 0;
  for (i = 0; i < brd_hisPly; ++i) {
    if (brd_history[i].posKey == brd_posKey) {
      r++;
    }
  }
  return r;
}
function Tile(mapX, mapY, x, y, type) {
  this.x = x;
  this.y = y;
  this.mapX = mapX;
  this.mapY = mapY;
  this.isCollidable = false;
  this.collisionCallback = false;
  this.type = type;
  this.isAnimated = false;
  this.isCollidable = false;
  this.isClickable = false;
  this.clickCallback = false;
  this.animationPlaying = false;
  this.setCollision = function (callBack) {
    this.collisionCallback = callBack;
    this.isCollidable = true;
  }
  this.setAnimation = function () {
    this.isAnimated = true;
  }
  this.setClick = function (callBack) {
    this.isClickable = true;
    this.clickCallback = callBack;
  }
  this.checkCollision = function (sprite, w, h) {
    shw = sprite.width / 2;
    shh = sprite.height / 2;
    scx = sprite.x + shw;
    scy = sprite.y + shh;
    thw = w / 2;
    thh = h / 2;
    tcx = this.x + thw;
    tcy = this.y + thh;
    if (Math.abs(scx - tcx) < (thw + shw)) {
      if (Math.abs(scy - tcy) < (thh + shh)) {
        this.collisionCallback(this);
      }
    }
  }
}
function tileCondBelongsTo(t, pl, prop) { return t[prop] == pl.id; }
function TileMap(scene) {
  this.tileSheet = new Image();
  this.tiles = new Array();
  this.symbolImageMap = new Array();
  this.tileAnimations = new Array();
  this.specificTileAnimations = new Array();
  this.mapData = false;
  this.tileWidth = 0;
  this.tileHeight = 0;
  this.sheetWidth = 0;
  this.sheetHeight = 0;
  this.camera = new Camera(scene);
  this.loadTileSheet = function (tileWidth, tileHeight, sheetWidth, sheetHeight, tileSheet, tileSymbols) {
    this.tileSheet.src = tileSheet;
    this.tileWidth = tileWidth;
    this.tileHeight = tileHeight;
    this.SheetWidth = sheetWidth;
    this.SheetHeight = sheetHeight;
    numRows = Math.floor(this.SheetWidth / this.tileWidth);
    numCols = Math.floor(this.SheetHeight / this.tileHeight);
    for (i = 0; i < numRows; i++) {
      for (j = 0; j < numCols; j++) {
        if ((i * numCols) + j < tileSymbols.length) {
          this.symbolImageMap[(i * numCols) + j] = new Array(j * this.tileWidth, i * this.tileHeight, tileSymbols[(i * numCols) + j]);
        }
      }
    }
  }
  this.loadMapData = function (mapArray) {
    this.mapData = new Array();
    for (i = 0; i < mapArray.length; i++) {
      this.mapData.push(new Array());
      temp = new Array();
      for (j = 0; j < mapArray[i].length; j++) {
        k = 0;
        notConverted = true;
        while (notConverted && k < this.symbolImageMap.length) {
          if (mapArray[i][j] == this.symbolImageMap[k][2]) { this.mapData[i][j] = k; notConverted = false; }
          k++;
        }
        temp[j] = new Tile(j, i, j * this.tileWidth, i * this.tileHeight, k);
      }
      this.tiles.push(temp)
    }
  }
  this.drawMap = function () {
    this.camera.update();
    ctx = this.camera.context;
    for (i = 0; i < this.mapData.length; i++) {
      for (j = 0; j < this.mapData[i].length; j++) {
        drawX = this.tiles[i][j].x - this.camera.cameraOffsetX;
        drawY = this.tiles[i][j].y - this.camera.cameraOffsetY;
        if (0 < drawX < this.camera.cWidth && 0 < drawY < this.camera.cHeight) {
          ctx.save();
          sheetX = this.symbolImageMap[this.mapData[i][j]][0];
          sheetY = this.symbolImageMap[this.mapData[i][j]][1];
          ctx.translate(drawX, drawY);
          if (this.tiles[i][j].animationPlaying) { this.drawTileAnimation(this.tiles[i][j], ctx); }
          else {
            ctx.drawImage(this.tileSheet, sheetX, sheetY, this.tileWidth, this.tileHeight, 0, 0, this.tileWidth, this.tileHeight);
            ctx.restore();
          }
        }
      }
    }
  }
  this.addTileCollision = function (collisionCallback, typeOrX, y) {
    if (typeof y == "undefined") {
      for (i = 0; i < this.tiles.length; i++) {
        for (j = 0; j < this.tiles[i].length; j++) {
          if (this.tiles[i][j].type == typeOrX) {
            this.tiles[i][j].setCollision(collisionCallback);
          }
        }
      }
    }
    else {
      this.tiles[typeOrX][y].setCollision(collisionCallback);
    }
  }
  this.loadCollisionMap = function (collisionMap) {
    for (l = 0; l < collisionMap.length; l++) {
      c = 0;
      notConverted = true;
      while (c < this.symbolImageMap.length && notConverted) {
        if (this.symbolImageMap[c][2] == collisionMap[l][0]) {
          collisionMap[l][0] = c + 1;
          notConverted = false;
        }
        c++;
      }
    }
    for (i = 0; i < this.tiles.length; i++) {
      for (j = 0; j < this.tiles[i].length; j++) {
        k = 0;
        notAssigned = true;
        while (k < collisionMap.length && notAssigned) {
          if (this.tiles[i][j].type == collisionMap[k][0]) {
            this.tiles[i][j].setCollision(collisionMap[k][1]);
            notAssigned = false;
          }
          k++;
        }
      }
    }
  }
  this.mapScroll = function (dx, dy) { this.camera.moveCamera(dx, dy); }
  this.cameraFollowSprite = function (sprite, waitX, waitY) { this.camera.followSprite(sprite, waitX, waitY); }
  this.loadZOrderMap = function (zMap) { }
  this.addTileAnimation = function (imgWidth, imgHeight, cellWidth, cellHeight, tileName, animSheet) {
    animation = new Animation(animSheet, imgWidth, imgHeight, cellWidth, cellHeight);
    animation.setup();
    for (i = 0; i < this.symbolImageMap.length; i++) {
      if (this.symbolImageMap[i][2] = tileName) {
        this.tileAnimations[i] = animation;
      }
    }
  }
  this.addSpecificTileAnimation = function (imgWidth, imgHeight, cellWidth, cellHeight, tileX, tileY, animSheet) {
    animation = new Animation(animSheet, imgWidth, imgHeight, cellWidth, cellHeight);
    animation.setup();
    this.specificTileAnimations[tileX][tileY] = animation;
  }
  this.drawTileAnimation = function (tile, ctx) {
    notSpecific = true;
    if (typeof this.specificTileAnimations[tile.mapX][tile.mapY] !== 'undefined' && this.specificTileAnimations[tile.mapX][tile.mapY] !== null) {
      notSpecific = false;
      this.specificTileAnimations[tile.mapX][tile.mapY].reset();
      this.specificTileAnimations[tile.mapX][tile.mapY].drawFrame(ctx);
    }
    if (typeof this.tileAnimations[tile.type] !== 'undefined' && this.tileAnimations[tile.type] !== null && notSpecific) {
      this.tileAnimations[tile.type].reset();
      this.tileAnimations[tile.type].drawFrame(ctx);
    }
  }
  this.playTileAnimation = function (tile) { tile.animationPlaying = true; }
  this.stopTileAnimation = function (tile) { tile.animationPlaying = false; }
  this.checkCollisions = function (sprite) {
    tileCoordX = Math.floor(sprite.x / this.tileWidth);
    tileCoordY = Math.floor(sprite.y / this.tileHeight);
    checkRowsBegin = tileCoordX - 1;
    checkRowsEnd = tileCoordX + 2;
    checkColsBegin = tileCoordY - 1;
    checkColsEnd = tileCoordY + 2;
    if (tileCoordX > -1 && tileCoordY > -1 && tileCoordY < this.mapData.length && tileCoordX < this.mapData[tileCoordY].length) {
      if (tileCoordX == 0) { checkRowsBegin = 0; }
      if (tileCoordX == (this.mapData[tileCoordY].length - 1)) { checkRowsEnd = this.mapData.length; }
      if (tileCoordY == 0) { checkColsBegin = 0; }
      if (tileCoordY == (this.mapData.length - 1)) { checkColsBegin = this.mapData[tileCoordY].length; }
      for (i = checkColsBegin; i < checkColsEnd; i++) {
        for (j = checkRowsBegin; j < checkRowsEnd; j++) {
          if (this.tiles[i][j].isCollidable) {
            this.tiles[i][j].checkCollision(sprite, this.tileWidth, this.tileHeight);
          }
        }
      }
    }
  }
  this.makeSpriteMapRelative = function (sprite) { sprite.setCameraRelative(this.camera); }
  this.setPosition = function () { }
}
function timeConversion(duration, format = 'Hmsh') {
  const portions = [];
  const msInHour = 1000 * 60 * 60;
  const hours = Math.trunc(duration / msInHour);
  if (format.includes('H')) portions.push((hours < 10 ? '0' : '') + hours);
  duration = duration - (hours * msInHour);
  const msInMinute = 1000 * 60;
  const minutes = Math.trunc(duration / msInMinute);
  if (format.includes('m')) portions.push((minutes < 10 ? '0' : '') + minutes);
  duration = duration - (minutes * msInMinute);
  const msInSecond = 1000;
  const seconds = Math.trunc(duration / 1000);
  if (format.includes('s')) portions.push((seconds < 10 ? '0' : '') + seconds);
  duration = duration - (seconds * msInSecond);
  const hundreds = duration / 10;
  if (format.includes('h')) portions.push((hundreds < 10 ? '0' : '') + hundreds);
  return portions.join(':');
}
function Timer() {
  this.reset = function () {
    this.date = new Date();
    this.startTime = this.date.getTime();
    this.elapsedTime = 0;
  }
  this.getCurrentTime = function () {
    this.date = new Date();
    return this.date.getTime();
  }
  this.getElapsedTime = function () {
    current = this.getCurrentTime();
    return (current - this.startTime) / 1000;
  }
  this.start = this.reset;
  this.getTimeElapsed = this.getElapsedTime;
  this.reset();
}
function timeToMs(h, m, s) { return ((((h * 60) + m) * 60) + s) * 1000; }
function title_tableDiv_bounds(dParent, title, o) {
  let [d, t, w, h] = o_tableDiv_bounds(dParent, o);
  let ti = document.createElement('p');
  ti.innerHTML = title;
  t.prepend(ti);
  return [d, d.offsetWidth, d.offsetHeight];
}
function to_admin() {
  show('dAdminButtons');
  U = DB.users.mimi; show_user(DB.users[U.name]);
  to_games();
}
function to_aristocard(ckey, sz = 100, color = RED, w) {
  let info = jsCopy(C52Cards[ckey.substring(0, 2)]);
  info.key = ckey;
  info.cardtype = ckey[2];
  let [r, s] = [info.rank, info.suit];
  info.val = r == 'A' ? 1 : 'TJQK'.includes(r) ? 10 : Number(r);
  info.color = color;
  info.sz = info.h = sz;
  info.w = valf(w, sz * .7);
  info.irank = 'A23456789TJQK'.indexOf(r);
  info.isuit = 'SHCD'.indexOf(s);
  info.isort = info.isuit * 13 + info.irank;
  return info;
}
function to_commissioncard(ckey, sz = 40, color = GREEN, w) { return to_aristocard(ckey, sz, color); }
function to_create_table() {
  let t = create_table();
  server_send(t, 'create_table_and_start', to_table);
}
function to_games() {
  console.log('games fuer user', U.name, 'suchen');
  get_games(U.name, show_games_menu);
}
function to_lat_lng(pts = []) { return points_to_waypoints(pts); }
function to_luxurycard(ckey, sz = 100, color = 'gold', w) { return to_aristocard(ckey, sz, color); }
function to_rumorcard(ckey, sz = 40, color = GREEN, w) { return to_aristocard(ckey, sz, color); }
function to_server(req, type, to_php = true) {
  where(type);
  if (!to_php) {
    server_offline(req, type);
  } else if (is_online()) {
    server_online(req, type);
  } else {
    if (type == 'chat') { alert('no internet!'); mClassReplace(mBy("label_chat"), 'enabled', 'disabled'); }
    server_offline(req, type);
  }
}
function to_table() {
  console.log('table should be presented!')
}
function to_words(x) {
  let list = x.split('\n');
  let di = {};
  list.map(x => di[x.toLowerCase()] = x);
  return di;
}
function toBase10(s, base = 16) {
  let s1 = reverseString(s.toLowerCase());
  let res = 0;
  let mult = 1;
  for (let i = 0; i < s1.length; i++) {
    let l = s1[i];
    let hexarr = ['a', 'b', 'c', 'd', 'e', 'f'];
    let n = isNumber(l) ? Number(l) : 10 + hexarr.indexOf(l);
    res += mult * n;
    mult *= base;
  }
  return res;
}
function toBoardString(arr, rows, cols) {
  let s = '\n';
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      let item = arr[r * cols + c];
      s += '' + (nundef(item) ? '_' : item) + ' ';
    }
    s += '\n';
  }
  return s;
}
function toDegree(rad) { return Math.floor(180 * rad / Math.PI); }
function toElem(d) { return isString(d) ? mBy(d) : d; }
function toggle_apps() { if (isEmpty(mBy('dApps').innerHTML)) show_apps(); else iClear('dApps'); }
function toggle_bw_symbol(d) {
  if (nundef(d)) d = document.getElementById('tbbw');
  d = d.getElementsByTagName('i')[0];
  if (isdef(d)) {
    if (d.classList.contains('fa-car')) {
      d.classList.remove('fa-car');
      d.classList.add('fa-star');
      mStyle(d, { fg: 'silver' });
    } else {
      d.classList.remove('fa-star');
      d.classList.add('fa-car');
      mStyle(d, { fg: 'transparent' });
    }
  }
}
function toggle_face(item) { if (item.faceUp) face_down(item); else face_up(item); }
function toggle_fiddle() { if (nundef(dFiddle)) show_fiddle(); else { fiddleSave(); for (const d of [dConsole, dFiddle, dSearch, dSidebar]) { iClear(d); } dFiddle = null; } }
function toggle_games() { if (isEmpty(mBy('dGames').innerHTML)) show_games(); else iClear('dGames'); }
function toggle_games_off() { let a = mBy('aGames'); hide('dGames'); mStyle(a, { bg: 'silver' }); }
function toggle_games_on() { let a = mBy('aGames'); mStyle(a, { bg: 'skyblue' }); }
function toggle_layers_control() {
  if (DA.layers_control) { M.map.removeControl(DA.layers_control); DA.layers_control = null; }
  else {
    let baseLayers = get_layer_options();
    let overlayLayers = get_layer_options();
    DA.layers_control = L.control.layers(baseLayers, overlayLayers, { collapsed: false })
    DA.layers_control.addTo(M.map);
  }
}
function toggle_list_member(arr, el) { arrToggleMember(arr, el); }
function toggle_mini_user_info() {
  if (nundef(DA.left_panel) || DA.left_panel == 'open') close_mini_user_info(); else open_mini_user_info();
}
function toggle_polling_status() {
  if (is_polling_on()) {
    stop_polling();
    let b = mBy('b_polling');
    b.className = 'buttonClass donebutton enabled off';
    b.innerHTML = 'polling off';
  } else {
    allow_polling();
    let b = mBy('b_polling');
    b.className = 'buttonClass donebutton enabled on';
    b.innerHTML = 'polling on';
  }
  console.log('Polling Status:', is_polling_on() ? 'ON' : 'OFF');
}
function toggle_select(item, selected, selstyle = 'selected') {
  let ui = iDiv(item);
  item.isSelected = !item.isSelected;
  if (item.isSelected) {
    mStyleOrClass(ui, selstyle);
  } else if (isString(selstyle)) {
    mClassRemove(ui, selstyle);
  } else if (isdef(item.style)) {
    mStyle(ui, item.style);
  } else {
    mStyleUndo(ui, selstyle);
  }
  if (isdef(selected)) {
    if (isList(selected)) {
      if (item.isSelected) {
        console.assert(!selected.includes(item), 'UNSELECTED PIC IN PICLIST!!!!!!!!!!!!')
        selected.push(item);
      } else {
        console.assert(selected.includes(item), 'PIC NOT IN PICLIST BUT HAS BEEN SELECTED!!!!!!!!!!!!')
        removeInPlace(selected, item);
      }
    } else {
      mStyle(iDiv(selected), selected.style);
      selected.isSelected = false;
    }
  }
  return item.isSelected ? item : null;
}
function toggle_sidebar() {
  if (nundef(DA.left_panel) || DA.left_panel == 'open') close_sidebar(); else open_sidebar();
}
function toggle_sound() {
  U.settings.silent = !U.settings.silent;
  if (isdef(G)) G.silent = U.settings.silent;
  set_sound(U.settings.silent);
}
function toggle_tables_off() { let a = mBy('aTables'); hide('dTables'); mStyle(a, { bg: 'silver' }); }
function toggle_tables_on() { let a = mBy('aTables'); mStyle(a, { bg: '#afe78f' }); } //'lightgreen' }); }
function toggle_users_off() { let a = mBy('aUsers'); hide('dUsers'); mStyle(a, { bg: 'silver' }); }
function toggle_users_on() { let a = mBy('aUsers'); mStyle(a, { bg: 'coral' }); }
function toggleCollapsible(ev) {
  let b = ev.target;
  b.classList.toggle("active");
  var content = getLinkContainerId(b.id);
  if (isVisible(content)) hide(content); else show(content);
}
function toggleFace(pic) { if (pic.isFaceUp) turnFaceDown(pic); else turnFaceUp(pic); }
function toggleFaceSimple(pic) { if (pic.isFaceUp) turnFaceDownSimple(pic); else turnFaceUpSimple(pic); }
function toggleItemSelection(item, selectedItems) {
  let ui = iDiv(item);
  item.isSelected = nundef(item.isSelected) ? true : !item.isSelected;
  if (item.isSelected) mClass(ui, 'framedPicture'); else mRemoveClass(ui, 'framedPicture');
  if (isdef(selectedItems)) {
    if (item.isSelected) {
      console.assert(!selectedItems.includes(item), 'UNSELECTED PIC IN PICLIST!!!!!!!!!!!!')
      selectedItems.push(item);
    } else {
      console.assert(selectedItems.includes(item), 'PIC NOT IN PICLIST BUT HAS BEEN SELECTED!!!!!!!!!!!!')
      removeInPlace(selectedItems, item);
    }
  }
}
function togglePic(ev) {
  let id = evToClosestId(ev);
  console.log(id)
  let item = UIS[id];
  console.log(item)
  if (isdef(item.pic)) removePic(item); else addPic(item, item.key);
}
function toggleSelection(pic, selected, clSelected = 'framedPicture', clUnselected = null) {
  let ui = iDiv(pic);
  pic.isSelected = !pic.isSelected;
  if (pic.isSelected) {
    if (isdef(clUnselected)) mClassRemove(ui, clUnselected);
    mClass(ui, clSelected);
  } else {
    mClassRemove(ui, clSelected);
    if (isdef(clUnselected)) mClass(ui, clUnselected);
  }
  if (isdef(selected)) {
    if (isList(selected)) {
      if (pic.isSelected) {
        console.assert(!selected.includes(pic), 'UNSELECTED PIC IN PICLIST!!!!!!!!!!!!')
        selected.push(pic);
      } else {
        console.assert(selected.includes(pic), 'PIC NOT IN PICLIST BUT HAS BEEN SELECTED!!!!!!!!!!!!')
        removeInPlace(selected, pic);
      }
    } else {
      mClassRemove(iDiv(selected), clSelected);
      if (isdef(clUnselected)) mClass(iDiv(selected), clUnselected);
      selected.isSelected = false;
    }
  }
  return pic.isSelected ? pic : null;
}
function toggleSelectionOfPicture(pic, selectedPics, className = 'framedPicture') {
  let ui = iDiv(pic);
  pic.isSelected = !pic.isSelected;
  if (pic.isSelected) mClass(ui, className); else mClassRemove(ui, className);
  if (isdef(selectedPics)) {
    if (pic.isSelected) {
      console.assert(!selectedPics.includes(pic), 'UNSELECTED PIC IN PICLIST!!!!!!!!!!!!')
      selectedPics.push(pic);
    } else {
      console.assert(selectedPics.includes(pic), 'PIC NOT IN PICLIST BUT HAS BEEN SELECTED!!!!!!!!!!!!')
      removeInPlace(selectedPics, pic);
    }
  }
}
function toggleSettings() { if (isVisible2('dSettings')) closeSettings(); else openSettings(); }
function toggleSidebar(ev, k, key) {
  if (nundef(DA.countKey)) { DA.countKey = {}; }
  if (nundef(DA.countKey[k])) { DA.countKey[k] = 0; }
  DA.countKey[k]++;
  let isOdd = DA.countKey[k] % 2 == 1;
  if (key == 'Escape' || ev.ctrlKey && k == 122) {
    if (isOdd) {
      mBy('left_panel').style.flex = 0;
      setTimeout(() => {
        show('mini_profile_img');
        show('mini_username');
      }, 500)
      mBy('mini_menu_right').style.display = 'flex';
    } else {
      mBy('left_panel').style.flex = 1;
      hide('mini_profile_img');
      hide('mini_username');
      mBy('mini_menu_right').style.display = 'none';
    }
  }
}
function toggleSound(key) {
  if (DA.isSound == true) { pauseSound(); DA.isSound = false; return; }
  playSound(key);
  DA.isSound = true;
}
function toggleTheme() {
  let bg = colorHex(dMain.style.backgroundColor);
  let lum = getBrightness(bg);
  console.log('current:\nbg', bg, '\nbaseColor', DA.pageBaseColor, '\nlum', lum);
  if (bg != DA.pageBaseColor) setPageBackground(DA.pageBaseColor, 'white', false);
  else if (lum <= .5) setPageBackground(colorLighter(bg), 'black', false);
  else setPageBackground(colorDarker(bg, 1), 'white', false);
}
function toggleTooltips(b) {
  if (S.settings.tooltips) {
    b.textContent = 'tooltips: OFF';
    S.settings.tooltips = false;
  } else {
    b.textContent = 'tooltips: ON';
    S.settings.tooltips = true;
  }
}
function toHTMLString(msg) {
  msg = JSON.stringify(msg);
  msg = msg.replace(/(?:\r\n|\r|\n)/g, '<br>');
  msg = msg.replace('\\n', '<br>');
  msg = msg.replace(/\\n/g, '<br>');
  msg = msg.replace(/"/g, '');
  return msg.trim();
}
function toLetterArray(s) { return toLetterList(s); }
function toLetterList(s) {
  return [...s];
}
function toLetters(s) { return [...s]; }
function toList(x) { return isList(x) ? x : [x]; }
function toLocalStorage(o, name = '_all') { localStorage.setItem(name, JSON.stringify(o)); }
function toModulo(n, modul) { rem = n % modul; n = n - rem; if (n < 0) n = 0; return n; }
function toNoun(s) { return capitalize(s.toLowerCase()); }
function too_many_string_items(A) { return A.items.filter(x => nundef(x.o)).length >= 8; }
function toogle_internet_status() {
  if (is_online()) {
    go_offline();
    let b = mBy('b_internet');
    b.className = 'statusbutton enabled off';
    b.innerHTML = 'offline';
  } else {
    go_online();
    db_save();
    let b = mBy('b_internet');
    b.className = 'statusbutton enabled on';
    b.innerHTML = 'online';
  }
  console.log('InternetStatus:', is_online() ? 'online' : 'OFFLINE');
}
function toolbar_check() {
  if (isEmpty(G.selist)) { mDisable('bclear'); mDisable('bnext') } else { mEnable('bclear'); mEnable('bnext') }
  if (isEmpty(G.hist)) { mDisable('bback'); } else { mEnable('bback'); }
}
function top_card_to_hands_abwechselnd(deck, hand1, hand2) {
  DA.hand = hand1;
  deck.items.map(x => {
    mStyle(iDiv(x), { cursor: 'pointer' });
    iDiv(x).onclick = () => {
      anim_from_deck_to_handX(x, deck, DA.hand);
      DA.hand = DA.hand == hand1 ? hand2 : hand1;
    }
  });
}
function top_card_to_market(deck, market) {
  deck.items.map(x => {
    mStyle(iDiv(x), { cursor: 'pointer' });
    iDiv(x).onclick = () => {
      anim_from_deck_to_marketX(x, deck, market);
    }
  });
}
function top_elem_from_to(arr1, arr2) { arr2.push(arr1.shift()); }
function top_elem_from_to_top(arr1, arr2) { arr2.unshift(arr1.shift()); }
function topCard(deck) { return deck.cards[0]; }
function topCardShouldGoTo(deck0, deck1, faceUp) {
  let c = Deck.transferTopFromToBottom(deck0, deck1)
  if (faceUp == true) Card52.turnFaceUp(c);
  mRemoveStyle(c.div, ['cursor', 'position']);
}
function toRadian(deg) { return deg * (Math.PI / 180); }
function TOSQ(m) { return (((m) >> 7) & 0x7F); }
function tossCoin(percent) {
  let r = Math.random();
  r *= 100;
  return r < percent;
}
function totalFreeze() {
  hide('passToNextPlayerUI')
  show('freezer');
}
function toUmlaut(w) {
  if (isList(w)) {
    let res = [];
    for (const w1 of w) res.push(toUmlaut(w1));
    return res;
  } else {
    w = replaceAll(w, 'ue', 'ü');
    w = replaceAll(w, 'ae', 'ä');
    w = replaceAll(w, 'oe', 'ö');
    w = replaceAll(w, 'UE', 'Ü');
    w = replaceAll(w, 'AE', 'Ä');
    w = replaceAll(w, 'OE', 'Ö');
    return w;
  }
}
function toWords(s, allow_ = false) {
  let arr = allow_ ? s.split(/[\W]+/) : s.split(/[\W|_]+/);
  return arr.filter(x => !isEmpty(x));
}
function toWordsSpeech(s) {
  var th = ['', 'thousand', 'million', 'billion', 'trillion'];
  var dg = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
  var tn = ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen'];
  var tw = ['twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety'];
  s = s.toString();
  s = s.replace(/[\, ]/g, '');
  if (s != parseFloat(s)) return 'not a number';
  var x = s.indexOf('.');
  if (x == -1) x = s.length;
  if (x > 15) return 'too big';
  var n = s.split('');
  var str = '';
  var sk = 0;
  for (var i = 0; i < x; i++) {
    if ((x - i) % 3 == 2) {
      if (n[i] == '1') { str += tn[Number(n[i + 1])] + ' '; i++; sk = 1; }
      else if (n[i] != 0) { str += tw[n[i] - 2] + ' '; sk = 1; }
    } else if (n[i] != 0) {
      str += dg[n[i]] + ' '; if ((x - i) % 3 == 0) str += 'hundred '; sk = 1;
    } if ((x - i) % 3 == 1) {
      if (sk) str += th[(x - i - 1) / 3] + ' '; sk = 0;
    }
  }
  if (x != s.length) {
    var y = s.length;
    str += 'point ';
    str.replace(/\s+/g, ' ');
  }
  return str.trim();
}
function toYaml(o) { return jsonToYaml(o); }
function trace() { if (isTraceOn) console.log('___ ', getFunctionsNameThatCalledThisFunction(), '\n', ...arguments); }
function transColor(r, g, b, a) {
  return 'rgba(r,g,b,a)';
}
function transferElement() {
  let h = Daat.hand;
  let item = Daat.item;
  h.addTop(item.val);
  let zHand = Daat.zone;
  clearElement(zHand);
  let items = i52(h.cards());
  let handItem = Daat.iHand = iSplay(items, zHand);
}
function transformToString(k, val, refs) {
  if (val && isDict(val) && '_set' in val) { val = val._set; }
  if (k == 'visible' && !isEmpty(val) && !isDict(val[0])) { val = val.map(x => { return { _player: x } }); }
  let sval = null;
  if (isList(val) && isEmpty(val)) { sval = '{ }'; }
  else if (isList(val) && isString(val[0])) { sval = '{' + val.join(',') + '}' }
  else if (isListOf(val, '_obj')) { sval = makeRefLinkDiv4ListOf_obj(val, refs); }
  else if (isListOf(val, '_player')) { sval = makeRefLinkDiv4ListOf_player(val, refs); }
  else if (val && isDict(val) && '_obj' in val) { sval = makeRefLinkDiv4_obj(val, refs); }
  else if (val && isDict(val) && '_ndarray' in val) { sval = makeRefLinkDiv4MatrixOf_obj(val, refs) }
  else if (val && isDict(val) && '_player' in val) { sval = makeRefLinkDiv4_player(val, refs); }
  else if (isDictOrList(val)) {
    sval = tableHTMLX(val, refs);
  }
  else sval = simpleRep(val);
  return sval;
}
function transitionTo(id) {
  let delay = dCurrent ? .1 : 0;
  hideCurrent();
  setTimeout(() => setCurrent(id), delay);
}
function translateStylesToCy(styles, group) {
  let di = {};
  for (const k in styles) {
    let v = styles[k];
    let [prop, val] = translateToCssStyle(k, v, true);
    if (group == 'edge' && k == 'bg') di['line-color'] = val;
    else if (prop == 'shape' && val == 'hex') {
      di.shape = 'polygon';
      di['shape-polygon-points'] = [0, -1, 1, -0.5, 1, 0.5, 0, 1, -1, 0.5, -1, -0.5];
    }
    else di[prop] = val;
  }
  return di;
}
function translateToCssStyle(prop, val) { return mStyleTranslate(prop, val); }
function translateToGerman(w) {
  if (isNumber(w)) return w;
  else if (isdef(DD[w])) return DD[w];
  else return w;
}
function trash111() {
  let tgServer = G.serverData.tupleGroups;
  for (const tg of tgServer) {
    let desc = tg.desc.line.toString();
    let choices = tg.tuples._set;
    let tuples = choices.map(x => x._tuple);
    tupleGroups.push({ desc: desc, tuples: tuples });
  }
  return tupleGroups;
}
function tree_add() {
  let root = C.root;
  if (root.phase == 'spring') {
    C.changed = false;
    assertion(root, 'ROOT IS NULL BEI TREE_ADD!!!!!!!!!!!!!')
    if (!root.done) {
      let b = create_branch(root, root.angle, root.len * root.dlen, root.color);
      lookupAddToList(C.items, [b.t], b);
      C.changed = true;
    } else {
      for (const b of C.items.branch.filter(x => !x.done)) {
        if (b.age < root.depth) {
          let br = root.branching;
          for (const a of br) {
            let o = create_branch(b, b.angle + toRadian(a), b.len * root.dlen, colorMix(b.color, 'lime', 3)); lookupAddToList(C.items, [o.t], o);
          }
        } else {
          let o = create_leaf(b, root); lookupAddToList(C.items, [o.t], o);
        }
        C.changed = true;
        root.maxage = b.age + 1;
        b.done = true;
      }
    }
    if (!C.changed) { root.minage = 0; root.phase = 'summer'; }
  }
  else if (root.phase == 'summer') {
    let colors = ['darkgreen', 'olive', '#8B9216', '#A79F0F', '#EDA421', '#E98604', '#DF3908', '#C91E0A', '#8C584A'];
    let changed = mutate_colors('leaf', colors);
    if (!changed) root.phase = 'autumn';
    root.jitter = true;
    C.changed = true;
  }
  else if (root.phase == 'autumn') {
    root.jitter = false;
    C.changed = true;
    let falling = C.items.leaf.filter(l => l.p.y < CV.height);
    if (isEmpty(falling)) {
      C.changed = false; root.phase = 'winter';
    } else {
      for (const b of falling) { b.p = { x: b.p.x + Math.random() * .51, y: b.p.y + Math.random() * 3 }; }
    }
  }
  else if (root.phase == 'winter') {
    let colors = ['#8E2100', '#5C1306', '#371C0F', '#1C1B19'];
    let changed = mutate_colors('branch', colors);
    if (!changed) root.phase = 'over';
    C.changed = true;
  }
  else if (root.phase == 'over') { root.animated = false; }
  if (root.animated) TO.iv1 = setTimeout(tree_add, root.speed[root.phase]); else TO.iv1 = setTimeout(() => G_init('tree'), 3000);
}
function tree_clear() { G_clear(); onclick_menu_item('tree'); }
function tree_init(offx = 0, offy = 0, options = {}) {
  let root = {
    done: false,
    t: 'root',
    age: 0,
    p2: { x: offx + CV.width / 2, y: offy + CV.height },
    len: valf(options.len, 100),
    angle: toRadian(90),
    thickness: valf(options.thick, 20),
    color: valf(options.color, 'sienna'),
    depth: NATURE.depth,
    branching: NATURE.branching,
    dlen: .7,
    dthickness: .7,
    phase: 'spring',
    speed: { spring: 100, summer: 100, autumn: 25, winter: 100, over: 2000 },
    animated: false,
    jitter: false,
  };
  return root;
}
function treee(o) {
  let s = '<table class="tttable">';
  for (const k in o) {
    s += '<tr><th>' + k + '</th><td>';
    let val = o[k];
    let sval = isSet(val) ? empty(val._set) ? '{ }' : simpleRep(val) : isDict(val) ? treee(val) : simpleRep(val);
    s += sval + '</td>';
  }
  s += '</table>';
  return s;
}
function tri0() {
  let sq3 = 1.73205080757;
  let sq3b = Math.sqrt(3);
  console.log('sq3', sq3, 'sq3b', sq3b)
}
function tri1() {
  let sq3 = Math.sqrt(3);
  let a = 48;
  let wp = a / 4, hp = a / 4, h = sq3 * a / 2;
  let [xoff, dx, yoff, dy] = [h + wp / 2, 2 * h, hp / 2, a / 2];
  let [rows, maxcols] = [3, 4];
  let ys = 2 + 3 * rows;
  let xs = maxcols;
  let x = xoff, y = yoff;
  let pts = [];
  let infos = [];
  let idx = 0;
  let yEven = true;
  for (let i = 0; i < ys; i++) {
    let tcolOffset = yEven ? 1 : 0;
    let isCenterRow = i >= 2 && ((i - 2) % 3) == 0;
    for (let j = 0; j < xs + (1 - tcolOffset); j++) {
      let pt = { x: x, y: y };
      pts.push(pt);
      infos.push({ index: idx, tcol: tcolOffset + 2 * j, trow: i, x: x, y: y, pt: pt, isCenterRow: isCenterRow, isHexCenter: isCenterRow, isCenterCol: j % 2 == 1 });
      x += dx;
      idx += 1;
    }
    yEven = !yEven;
    y += dy; x = i % 2 ? xoff : wp / 2;
  }
  let byrc = {};
  for (const i of infos) {
    lookupSet(byrc, [i.trow, i.tcol], i.index);
  }
  console.log('byrc', byrc)
  let byxy = {};
  let adjList = [];
  let di = {};
  for (const info of infos) {
    let [r, c] = [info.trow, info.tcol];
    info.nodes = [
      lookup(byrc, [r - 2, c]),
      lookup(byrc, [r - 1, c + 1]),
      lookup(byrc, [r + 1, c + 1]),
      lookup(byrc, [r + 2, c]),
      lookup(byrc, [r + 1, c - 1]),
      lookup(byrc, [r + 1, c - 1]),
    ];
    for (let i = 0; i < 6; i++) {
      let n1 = info.nodes[i];
      if (n1 == null) continue;
      let n2 = info.nodes[(i + 1 % 6)];
      if (n2 == null) continue;
      if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
      lookupSet(di, [n1, n2], true);
      adjList.push([n1, n2]);
    }
    info.neighbors = [
      lookup(byrc, [r - 3, c + 1]),
      lookup(byrc, [r, c + 2]),
      lookup(byrc, [r + 3, c + 1]),
      lookup(byrc, [r + 3, c - 1]),
      lookup(byrc, [r, c - 2]),
      lookup(byrc, [r - 3, c - 1]),
    ];
  }
  let sym = chooseRandom(getAnimals());
  let items = [];
  for (const info of infos) {
    let item = info.isHexCenter ? drawBee(info.pt) : drawSym(sym, info.pt);
    items.push(item);
  }
}
function tri2() {
  let sq3 = Math.sqrt(3);
  let a = 48;
  let wp = a / 4, hp = a / 4, h = sq3 * a / 2;
  let [xoff, dx, yoff, dy] = [h + wp / 2, 2 * h, hp / 2, a / 2];
  let [rows, maxcols] = [3, 4];
  let ys = 2 + 3 * rows;
  let xs = maxcols;
  let x = xoff, y = yoff;
  let pts = [];
  let infos = [];
  let idx = 0;
  let yEven = true;
  for (let i = 0; i < ys; i++) {
    let tcolOffset = yEven ? 1 : 0;
    let isCenterRow = i >= 2 && ((i - 2) % 3) == 0;
    for (let j = 0; j < xs + (1 - tcolOffset); j++) {
      let pt = { x: x, y: y };
      pts.push(pt);
      infos.push({ index: idx, tcol: tcolOffset + 2 * j, trow: i, x: x, y: y, pt: pt, isCenterRow: isCenterRow, isHexCenter: isCenterRow, isCenterCol: j % 2 == 1 });
      x += dx;
      idx += 1;
    }
    yEven = !yEven;
    y += dy; x = i % 2 ? xoff : wp / 2;
  }
  let byrc = {};
  for (const i of infos) {
    lookupSet(byrc, [i.trow, i.tcol], i.index);
  }
  console.log('byrc', byrc)
  let byxy = {};
  let adjList = [];
  let di = {};
  for (const info of infos) {
    let [r, c] = [info.trow, info.tcol];
    info.nodes = [
      lookup(byrc, [r - 2, c]),
      lookup(byrc, [r - 1, c + 1]),
      lookup(byrc, [r + 1, c + 1]),
      lookup(byrc, [r + 2, c]),
      lookup(byrc, [r + 1, c - 1]),
      lookup(byrc, [r + 1, c - 1]),
    ];
    for (let i = 0; i < 6; i++) {
      let n1 = info.nodes[i];
      if (n1 == null) continue;
      let n2 = info.nodes[(i + 1 % 6)];
      if (n2 == null) continue;
      if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
      lookupSet(di, [n1, n2], true);
      adjList.push([n1, n2]);
    }
    info.neighbors = [
      lookup(byrc, [r - 3, c + 1]),
      lookup(byrc, [r, c + 2]),
      lookup(byrc, [r + 3, c + 1]),
      lookup(byrc, [r + 3, c - 1]),
      lookup(byrc, [r, c - 2]),
      lookup(byrc, [r - 3, c - 1]),
    ];
  }
  let sym = chooseRandom(getAnimals());
  let items = [];
  for (const info of infos) {
    let item = info.isHexCenter ? drawCenteredBee(info.pt) : drawCenteredPlainCircle(info.pt);
    items.push(item);
    let d = iDiv(item);
    if (info.isHexCenter) mClass(d, 'hexagon');
    if (info.isHexCenter) mText(info.trow + ' ' + info.tcol, d, { fz: 10 });
  }
}
function tri3() {
  let sq3 = Math.sqrt(3);
  let a = 48;
  let wp = a / 4, hp = a / 4, h = sq3 * a / 2;
  let [xoff, dx, yoff, dy] = [h + wp / 2, 2 * h, hp / 2, a / 2];
  let [rows, maxcols] = [3, 4];
  let ys = 2 + 3 * rows;
  let xs = maxcols;
  let x = xoff, y = yoff;
  let pts = [];
  let infos = [];
  let idx = 0;
  let yEven = true;
  for (let i = 0; i < ys; i++) {
    let tcolOffset = yEven ? 1 : 0;
    let isCenterRow = i >= 2 && ((i - 2) % 3) == 0;
    for (let j = 0; j < xs + (1 - tcolOffset); j++) {
      let pt = { x: x, y: y };
      pts.push(pt);
      infos.push({ index: idx, tcol: tcolOffset + 2 * j, trow: i, x: x, y: y, pt: pt, isCenterRow: isCenterRow, isHexCenter: isCenterRow, isCenterCol: j % 2 == 1 });
      x += dx;
      idx += 1;
    }
    yEven = !yEven;
    y += dy; x = i % 2 ? xoff : wp / 2;
  }
  let byrc = {};
  for (const i of infos) {
    lookupSet(byrc, [i.trow, i.tcol], i.index);
  }
  console.log('byrc', byrc)
  let byxy = {};
  let adjList = [];
  let di = {};
  for (const info of infos) {
    let [r, c] = [info.trow, info.tcol];
    info.nodes = [
      lookup(byrc, [r - 2, c]),
      lookup(byrc, [r - 1, c + 1]),
      lookup(byrc, [r + 1, c + 1]),
      lookup(byrc, [r + 2, c]),
      lookup(byrc, [r + 1, c - 1]),
      lookup(byrc, [r + 1, c - 1]),
    ];
    for (let i = 0; i < 6; i++) {
      let n1 = info.nodes[i];
      if (n1 == null) continue;
      let n2 = info.nodes[(i + 1 % 6)];
      if (n2 == null) continue;
      if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
      lookupSet(di, [n1, n2], true);
      adjList.push([n1, n2]);
    }
    info.neighbors = [
      lookup(byrc, [r - 3, c + 1]),
      lookup(byrc, [r, c + 2]),
      lookup(byrc, [r + 3, c + 1]),
      lookup(byrc, [r + 3, c - 1]),
      lookup(byrc, [r, c - 2]),
      lookup(byrc, [r - 3, c - 1]),
    ];
  }
  let sym = chooseRandom(getAnimals());
  let items = [];
  for (const info of infos) {
    let item = drawText(info.trow + ',' + info.tcol, info.pt);
    items.push(item);
  }
}
function tri4() {
  let sq3 = Math.sqrt(3);
  let a = 48;
  let wp = a / 4, hp = a / 4, h = sq3 * a / 2;
  let [xoff, dx, yoff, dy] = [h + wp / 2, 2 * h, hp / 2, a / 2];
  let [rows, maxcols] = [3, 4];
  let ys = 2 + 3 * rows;
  let xs = maxcols;
  let x = xoff, y = yoff;
  let pts = [];
  let infos = [];
  let idx = 0;
  let yEven = true;
  for (let i = 0; i < ys; i++) {
    let tcolOffset = yEven ? 1 : 0;
    let isCenterRow = i >= 2 && ((i - 2) % 3) == 0;
    for (let j = 0; j < xs + (1 - tcolOffset); j++) {
      let pt = { x: x, y: y };
      pts.push(pt);
      infos.push({ index: idx, tcol: tcolOffset + 2 * j, trow: i, x: x, y: y, pt: pt, isCenterRow: isCenterRow, isHexCenter: isCenterRow, isCenterCol: j % 2 == 1 });
      x += dx;
      idx += 1;
    }
    yEven = !yEven;
    y += dy; x = i % 2 ? xoff : wp / 2;
  }
  let byrc = {};
  for (const i of infos) {
    lookupSet(byrc, [i.trow, i.tcol], i.index);
  }
  console.log('byrc', byrc)
  let byxy = {};
  let adjList = [];
  let di = {};
  for (const info of infos) {
    let [r, c] = [info.trow, info.tcol];
    info.nodes = [
      lookup(byrc, [r - 2, c]),
      lookup(byrc, [r - 1, c + 1]),
      lookup(byrc, [r + 1, c + 1]),
      lookup(byrc, [r + 2, c]),
      lookup(byrc, [r + 1, c - 1]),
      lookup(byrc, [r + 1, c - 1]),
    ];
    for (let i = 0; i < 6; i++) {
      let n1 = info.nodes[i];
      if (n1 == null) continue;
      let n2 = info.nodes[(i + 1 % 6)];
      if (n2 == null) continue;
      if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
      lookupSet(di, [n1, n2], true);
      adjList.push([n1, n2]);
    }
    info.neighbors = [
      lookup(byrc, [r - 3, c + 1]),
      lookup(byrc, [r, c + 2]),
      lookup(byrc, [r + 3, c + 1]),
      lookup(byrc, [r + 3, c - 1]),
      lookup(byrc, [r, c - 2]),
      lookup(byrc, [r - 3, c - 1]),
    ];
  }
  let sym = chooseRandom(getAnimals());
  let items = [];
  for (const info of infos) {
    let item = drawText(info.trow + ',' + info.tcol, info.pt);
    if (info.isHexCenter) mStyle(iDiv(item), { bg: 'pink' })
    items.push(item);
  }
}
function trialPromptML() {
  let selinp = Selected.inp;
  say('try again!');
  setTimeout(() => {
    let d = selinp.div;
    d.innerHTML = '_';
    mClass(d, 'blink');
  }, skipAnimations ? 300 : 2000);
  showFleetingMessage(composeFleetingMessage(), 3000);
  return 10;
}
function trialPromptSP() {
  say(currentLanguage == 'E' ? 'try again!' : 'nochmal', 1, 1, .3, true, 'zira');
  animate(dInstruction, 'pulse800' + getSignalColor(), 900);
  return 1500;
}
function trialPromptSPA() {
  return 10;
}
function trialPromptTC() {
  say('try again');
  shortHintPic();
  return 10;
}
function trialPromptTP() {
  say('try again');
  shortHintPic();
  return 10;
}
function trialPromptWP() {
  say(currentLanguage == 'E' ? 'try again!' : 'nochmal', 1, 1, .8, true, 'zira');
  mLinebreak(dTable);
  inputBox = addNthInputElement(dTable, trialNumber);
  defaultFocusElement = inputBox.id;
  return 10;
}
function trickleDown(n, R, trickle) {
  currentSizing = trickle.sizing;
  let res = {};
  res.sizing = isdef(n.params) && isdef(n.params.sizing) ? n.params.sizing
    : isdef(currentSizing) ? currentSizing : R.defs.defaultSizing;
  return res;
}
function trim(str) {
  return str.replace(/^\s+|\s+$/gm, '');
}
function try_find_username(ev) {
  evNoBubble(ev);
  let username = findAttributeInAncestors(ev.target, 'username');
  if (nundef(Session.users_by_name[username])) { alert('ERROR username!'); return null; }
  return username;
}
function tryBegin(callback) { let route = '/begin/1'; _sendRouteJS(route, callback); }
function tryConvertToJSON(s) {
  let res = null;
  try { res = JSON.parse(s); return res; }
  catch {
    return null;
  }
}
function tsAction(x) { if ('ID' in x) return x.ID; else return x.val; }
function tsRec(x) {
  if (isList(x)) { return '[' + x.map(tsRec).join('') + ']'; }
  if (isDict(x)) {
    if ('_set' in x) {
      return '{' + tsRec(x._set) + '}';
    } else if ('_tuple' in x) {
      return '(' + tsRec(x._tuple) + ')'
    } else if ('type' in x) {
      return tsAction(x)
    } else { return 'obj unknown'; }
  } else return 'type unknown';
}
function ttBody(oid, o) {
  let sProps = '';
  let sVals = '';
  for (const p in o) {
    if (p == 'obj_type' || p == 'name' || p == 'id') continue;
    let val = o[p];
    sProps += p + '<br>';
    sVals += simpleRep(val) + '<br>';
  }
  $('div#ttipLeft').html(sProps);
  $('div#ttipRight').html(sVals);
}
function ttBody2(oid, o) {
  let s = treee(o);
  clearElement('ttipRight');
  $('div#ttipLeft').html(s);
}
function ttTitle(oid, o) {
  $('div#ttipTitle').html(('obj_type' in o ? o.obj_type : '_') + ('name' in o ? ':' + o.name : 'id' in o ? ':' + o.id : ' ' + oid));
}
function turn_create_otree(obj) {
  console.assert(isdef(obj.table), 'turn_create_otree without obj.table!!!!!!!!!!!!!!');
  let g = Session;
  let [menu, table, fen, plist, players] = [g.cur_menu, g.table, g.fen, g.plist, g.players] = ['play', obj.table, obj.table.fen, obj.playerdata, obj.table.fen.players];
  let otree = jsCopy(fen);
  let order = isdef(fen.plorder) ? fen.plorder : plist.map(x => x.name);
  otree.player_names = order;
  for (const uname of order) {
    let pl = firstCond(plist, x => x.name == uname);
    copyKeys(DB.users[uname], pl);
    copyKeys(fen.players[uname], pl);
    otree[uname] = pl;
  }
  addKeys(fen, otree);
  delete otree.players;
  return otree;
}
function turn_create_R(otree) {
  Items = {};
  let g = Session;
  R = g.R = new RSG(); R.otree = otree;
  let r_keys = R.keys = Session.game_keys.r_nodes;
  let akku = G.akku = [];
  let root = R.root = rec_create_nodes_tree_akku(R, otree, '', r_keys, akku);
  return R;
}
function turn_new_schwein_up(schwein, fenbuilding, uibuilding) {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let is_first_schwein = isEmpty(fenbuilding.schweine);
  add_schwein(schwein, fenbuilding, uibuilding);
  ari_history_list([`${uplayer} reveals a schwein!`], 'inspect');
  if (is_first_schwein) {
    console.log('unique AND first new schwein');
    show_instruction('found schwein - both players get a rumor!');
    let owner = stringAfter(uibuilding.path, '.');
    owner = stringBefore(owner, '.');
    console.log('owner', owner, 'uplayer', uplayer);
    A.owner = owner;
    ari_open_rumors(32);
  } else {
    console.log('unique new schwein (gibt schon schweine)')
    show_instruction('found schwein - you gain a rumor!');
    let rumor = fen.deck_rumors[0]; fen.deck_rumors.shift();
    fen.players[uplayer].rumors.push(rumor);
    ari_history_list([`${uplayer} inspects a schweine building!`], 'inspect');
    ari_next_action();
  }
}
function turn_package_otree(otree) {
  let keys = Session.game_keys.players;
  let fen = otree;
  fen.players = {};
  for (const plname of otree.plorder) fen.players[plname] = stripToKeys(otree[plname], keys);
  otree.plorder.map(x => delete fen[x]);
  return fen;
}
function turn_present(obj) {
  if (ITER >= Math.min(DA.iter, MAXITER)) { console.log('iter', ITER == MAXITER ? 'MAX' : 'DA.iter'); TOMan.clear(); return; } ITER++;
  let otree = turn_unpackage_fen(obj);
  let rtree = turn_create_R(otree);
  ui_table_actions_stats();
  if (G.cur_game == 'gAristo') { ari_branch(obj, otree, rtree); }
  else if (G.cur_game == 'gPreinno') { inno_branch(obj, otree, rtree); }
}
function turn_schwein_up(b) {
  let key = b.keycard.key;
  let list = b.list;
  let schwein = firstCond(list, x => x[0] != key[0]);
  assertion(isdef(schwein), 'WAS DA IST GARKEIN SCHWEIN!!!!!!!!!!', b);
  let ui = firstCond(b.items, x => x.key == schwein);
  face_up(ui);
  let obuilding = lookup(Z.fen, b.path.split('.'));
  b.schwein = obuilding.schwein = schwein;
  ari_open_rumors(32);
}
function turn_send_gameover(otree, uname) {
  let fen = turn_package_otree(otree);
  let g = Session;
  let o = { uname: uname, tid: g.table.id, fen: fen, table_status: 'over' };
  to_server(o, 'turn_update');
}
function turn_send_move_update(otree, uname) {
  let fen = turn_package_otree(otree);
  let g = Session;
  let o = { uname: uname, tid: g.table.id, fen: fen, table_status: g.table.status };
  to_server(o, 'turn_update');
}
function turn_send_reload(uname) {
  let g = Session;
  let o = { uname: uname, tid: g.table.id, table_status: g.table.status };
  to_server(o, 'turn_update');
}
function turn_set_game_assets(g) {
  if (g.cur_game == 'gPreinno') g.cards = InnoById;
  else if (g.cur_game == 'gAristo') g.cards = Aristocards;
}
function turn_set_keys(g, obj) {
  let fen = obj.table.fen;
  let di = {
    table: get_keys(fen),
    players: get_keys(fen.players[fen.plorder[0]]),
    r_nodes: [],
    ui_nodes: []
  };
  let rks = arrMinus(di.table.concat(di.players), ['splays', 'herald', 'plorder', 'coins']);
  rks = arrPlus(rks, ['green', 'purple', 'blue', 'red', 'yellow']);
  rks = rks.concat(fen.plorder);
  di.r_nodes = rks;
  di.ui_nodes = arrMinus(di.r_nodes, []);
  g.game_keys = {};
  for (const k in di) {
    let di1 = g.game_keys[k] = {};
    for (const k1 of di[k]) di1[k1] = true;
  }
}
function turn_show_gameover(otree) {
  let game = Session.cur_game;
  let table = Session.cur_table;
  let players = otree2cur_players(otree);
  let winner = otree.winner;
  if (!Session.scoring_complete) {
    console.log('======>scoring!!!!!', table.friendly);
    scoring_update(otree.plorder, [otree.winner], game);
    out1();
    Session.scoring_complete = true;
  }
  let pl = otree[winner];
  let styles = { bg: pl.color, alpha: .75, fg: 'contrast', top: 220, };
  let msg = 'GAME OVER - The ' + `winner is ${otree.winner}!!!`;
  let d = status_message(msg, styles);
  let end_scores = table.status == 'past' ? table.end_scoring : get_scores_from_cur_players();
  show_score_table(end_scores, table.friendly, d);
  mLinebreak(d);
  mButton('click to close', onclick_gameover_new, d, { fz: 20 }, ['buttonClass', 'donebutton']);
}
function turn_unpackage_fen(obj) {
  let g = Session;
  turn_set_game_assets(g);
  turn_set_keys(g, obj);
  g.obj = ServerData = obj;
  let otree = Fen = g.otree = turn_create_otree(obj);
  return otree;
}
function turnCardsAfter(secs, removeBg = false) {
  let qc = QContextCounter;
  for (const p of Pictures) { slowlyTurnFaceDown(p, secs - 1, removeBg); }
  TOMain = setTimeout(() => {
    showInstruction(Goal.label, 'click', dTitle, true);
    showMouse();
    GC.activateUi.bind(GC)();
  }, secs * 1000);
}
function turnDeckFaceUp(deck) { if (deck.isFaceDown) { deck.flip(); deck.isFaceDown = false; } }
function turnFaceDown(pic) {
  let ui = iDiv(pic);
  for (const p1 of ui.children) p1.style.opacity = 0;
  ui.style.backgroundColor = 'dimgray';
  pic.isFaceUp = false;
}
function turnFaceDownSimple(pic) {
  let ui = iDiv(pic);
  ui.style.transition = null;
  mRemoveClass(ui, 'frameOnHover');
  for (const ch of ui.children) { ch.style.transition = null; ch.style.opacity = 0; }
  pic.isFaceUp = false;
}
function turnFaceUp(pic, secTransition = 1) {
  let div = iDiv(pic);
  for (const ch of div.children) {
    ch.style.transition = `opacity ${secTransition}s ease-in-out`;
    ch.style.opacity = 1;
  }
  div.style.transition = null;
  div.style.backgroundColor = pic.bg;
  pic.isFaceUp = true;
}
function turnFaceUpSimple(pic) {
  let ui = iDiv(pic);
  mRemoveClass(ui, 'frameOnHover');
  ui.style.transition = null;
  for (const ch of ui.children) { ch.style.transition = null; ch.style.opacity = 1; }
  pic.isFaceUp = true;
}
function turtle() {
  background(51);
  stroke(255);
  translate(width / 2, height);
  for (let i = 0; i < sentence.length; i++) {
    let x = sentence.charAt(i);
    if ('ABF'.includes(x)) { line(0, 0, 0, -len); translate(0, -len); }
    else if (x == '+') rotate(angle);
    else if (x == '-') rotate(-angle);
    else if (x == '[') push();
    else if (x == ']') pop();
  }
}
function ty01() {
}
function type00flex(n, R) { return 'type00flex'; }
function typeEmpty(n, R) { return 'empty'; }
function typePanelInfo(n, R) { return isdef(n.children) ? 'panel' : 'info'; }
function ui_add_cards_to_card_container(cont, items, list) {
  if (nundef(list)) list = items.map(x => x.key);
  for (const item of items) {
    mAppend(cont, iDiv(item));
  }
}
function ui_add_cards_to_deck_container(cont, items, list) {
  if (nundef(list)) list = items.map(x => x.key);
  for (const item of items) {
    mAppend(cont, iDiv(item));
    mItemSplay(item, list, 4, Card.ovdeck);
    face_down(item);
  }
  return items[0];
}
function ui_add_cards_to_hand_container(cont, items, list) {
  if (nundef(list)) list = items.map(x => x.key);
  for (const item of items) {
    mAppend(cont, iDiv(item));
    mItemSplay(item, list, 2, Card.ovw);
  }
}
function ui_add_container_title(title, cont, items, show_if_empty) {
  if (isdef(title) && (!isEmpty(items) || show_if_empty)) {
    let st = get_containertitle_styles();
    let stmeasure = jsCopy(st); delete stmeasure.position;
    let elem = mText(title, cont, stmeasure);
    let sz = getSizeNeeded(elem);
    let offsetx = valf(st.left, 0);
    let cont_wmin = mGetStyle(cont, 'wmin');
    let my_min = sz.w + offsetx * 1.5;
    let wmin = !isNumber(cont_wmin) ? my_min : Math.max(valf(cont_wmin, 0), my_min);
    mStyle(cont, { wmin: wmin });
    mStyle(elem, st);
  }
}
function ui_from_deck_to_hand(el, deck, hand) {
  let topmost = deck.items.shift();
  console.assert(el == topmost, 'top deck elem is NOT correct!!!!')
  face_up(topmost);
  let dtop = iDiv(topmost);
  deck.list = deck.items.map(x => x.key);
  deck.topmost = deck.items[0];
  dtop.remove();
  dtop.style.position = 'static';
  hand.items.push(topmost);
  hand.list = hand.items.map(x => x.key);
  mAppend(hand.container, dtop);
  mContainerSplay(hand.container, 2, CWIDTH, CHEIGHT, hand.list.length, OVW);
  mItemSplay(topmost, hand.list, 2, OVW);
}
function ui_game_menu_item(g, g_tables = []) {
  function runderkreis(color, id) {
    return `<div id=${id} style='width:20px;height:20px;border-radius:50%;background-color:${color};color:white;position:absolute;left:0px;top:0px;'>` + '' + "</div>";
  }
  let [sym, bg, color, id] = [Syms[g.logo], g.color, null, getUID()];
  if (!isEmpty(g_tables)) {
    let t = g_tables[0];
    let have_another_move = t.player_status == 'joined';
    color = have_another_move ? 'green' : 'red';
    id = `rk_${t.id}`;
  }
  return `
  <div onclick="onclick_game_menu_item(event)" gamename=${g.id} style='cursor:pointer;border-radius:10px;margin:10px;padding:5px;padding-top:15px;width:120px;height:90px;display:inline-block;background:${bg};position:relative;'>
  ${nundef(color) ? '' : runderkreis(color, id)}
  <span style='font-size:50px;font-family:${sym.family}'>${sym.text}</span><br>${g.friendly.toString()}</div>
  `;
}
function ui_game_stats(players) {
  let d = dTitle;
  clearElement(d);
  let d1 = mDiv(d, { display: 'flex', 'justify-content': 'center', 'align-items': 'space-evenly' });
  for (const plname in players) {
    let pl = players[plname];
    let d2 = mDiv(d1, { margin: 4, align: 'center' }, null, `<img src='${pl.imgPath}' style="display:block" class='img_person' width=50 height=50>${pl.score}`);
  }
}
function ui_get_all_commission_items(uplayer) {
  let items = [], i = 0;
  let comm = UI.players[uplayer].commissions;
  for (const o of comm.items) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: comm.path, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_all_hidden_building_items(uplayer) {
  let items = [];
  for (const gb of UI.players[uplayer].buildinglist) {
    items = items.concat(ui_get_hidden_building_items(gb));
  }
  reindex_items(items);
  return items;
}
function ui_get_blackmailed_items() {
  let [fen, uplayer] = [Z.fen, Z.uplayer];
  let commands = ['accept', 'reject'];
  let rumors = fen.players[uplayer].rumors;
  let b = path2fen(fen, fen.blackmail.building_path);
  if (nundef(b.lead)) b.lead = b.list[0];
  if (isList(rumors) && firstCond(rumors, x => x[0] == b.lead[0])) {
    commands.push('defend');
  }
  return ui_get_string_items(commands);
}
function ui_get_bluff_inputs(strings) {
  let uplayer = Z.uplayer;
  let items = ui_get_string_items(uplayer, strings);
  console.log('items', items)
  return items;
}
function ui_get_build_items(uplayer, except) {
  let items = ui_get_hand_and_stall_items(uplayer);
  if (is_card(except)) items = items.filter(x => x.key != except.key);
  reindex_items(items);
  return items;
}
function ui_get_building_items(uplayer) {
  let gblist = UI.players[uplayer].buildinglist;
  let items = [], i = 0;
  for (const o of gblist) {
    let name = o.type + ' ' + (o.list[0][0] == 'T' ? '10' : o.list[0][0]);
    o.div = o.container;
    let item = { o: o, a: name, key: o.list[0], friendly: name, path: o.path, index: i, ui: o.container };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_building_items_of_type(uplayer, types = ['farm', 'estate', 'chateau']) {
  let gblist = UI.players[uplayer].buildinglist.filter(x => types.includes(x.type));
  let items = [], i = 0;
  for (const o of gblist) {
    let name = o.type + ' ' + (o.list[0][0] == 'T' ? '10' : o.list[0][0]);
    o.div = o.container;
    let item = { o: o, a: name, key: o.list[0], friendly: name, path: o.path, index: i, ui: o.container };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_buildings(gblist) {
  let items = [], i = 0;
  for (const o of gblist) {
    let name = o.type + ' ' + (o.list[0][0] == 'T' ? '10' : o.list[0][0]);
    o.div = o.container;
    let item = { o: o, a: name, key: o.list[0], friendly: name, path: o.path, index: i, ui: o.container };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_buy_or_pass_items() {
  let items = [], i = 0;
  if (!isEmpty(UI.deck_discard.items)) items.push(ui_get_deck_item(UI.deck_discard));
  items = items.concat(ui_get_string_items(['pass']));
  reindex_items(items);
  return items;
}
function ui_get_card_items(cards) {
  let items = [], i = 0;
  for (const o of cards) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: ``, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_church_items(uplayer) {
  let fen = Z.fen;
  let items = [], i = 0;
  let church = UI.church;
  for (const o of church.items) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: church.path, index: i };
    i++;
    items.push(item);
  }
  let candidates = fen.candidates = arrMinus(fen.toBeSelected, uplayer);
  if (candidates.length > 1) {
    let player_items = ui_get_string_items(candidates);
    items = items.concat(player_items);
    reindex_items(items);
  }
  return items;
}
function ui_get_coin_amounts(uplayer) {
  let items = [];
  for (let i = 0; i <= Z.fen.players[uplayer].coins; i++) {
    let cmd = '' + i;
    let item = { o: null, a: cmd, key: cmd, friendly: cmd, path: null, index: i };
    items.push(item);
  }
  return items;
}
function ui_get_commands(uplayer) {
  let avail = ari_get_actions(uplayer);
  let items = [], i = 0;
  for (const cmd of avail) {
    let item = { o: null, a: cmd, key: cmd, friendly: cmd, path: null, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_commission_items(uplayer) {
  let items = [], i = 0;
  let comm = UI.players[uplayer].commissions;
  let stall = ui_get_stall_items(uplayer);
  for (const o of comm.items) {
    let rank = o.key[0];
    let similar = firstCond(stall, x => x.key[0] == rank);
    if (!similar) continue;
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: comm.path, index: i, similar: stall.filter(x => x.key[0] == rank) };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_commission_new_items(uplayer) {
  let items = [], i = 0;
  let comm = UI.open_commissions;
  for (const o of comm.items) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: comm.path, index: i };
    i++;
    items.push(item);
  }
  let topdeck = UI.deck_commission.get_topcard();
  items.push({ o: topdeck, a: topdeck.key, key: topdeck.key, friendly: topdeck.short, path: 'deck_commission', index: i });
  return items;
}
function ui_get_commission_stall_items() {
  let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
  console.log('ui_get_commission_stall_items similar', A.commission.similar);
  let items = A.commission.similar;
  reindex_items(items);
  return items;
}
function ui_get_deck_item(uideck) {
  let topdeck = uideck.get_topcard();
  let item = { o: topdeck, a: topdeck.key, key: topdeck.key, friendly: topdeck.short, path: uideck.path, index: 0 };
  return item;
}
function ui_get_endgame(uplayer) { return ui_get_string_items(['end game', 'go on']); }
function ui_get_estates_chateaus_items(uplayer) { return ui_get_building_items_of_type(uplayer, ['estate', 'chateau']); }
function ui_get_exchange_items(uplayer) {
  let ihand = ui_get_hand_items(uplayer);
  let istall = ui_get_stall_items(uplayer);
  let irepair = ui_get_all_hidden_building_items(uplayer);
  irepair.map(x => face_up(x.o));
  let items = ihand.concat(istall).concat(irepair);
  reindex_items(items);
  return items;
}
function ui_get_farms_estates_items(uplayer) { return ui_get_building_items_of_type(uplayer, ['farm', 'estate']); }
function ui_get_ferro_items() {
  let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
  let items = ui_get_hand_items(uplayer);
  for (const plname of plorder) {
    let jlist = UI.players[plname].journeys;
    for (const jitem of jlist) {
      for (const o of jitem.items) {
        if (!is_joker(o)) { continue; }
        let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: jitem.path, index: 0 };
        items.push(item);
      }
    }
  }
  for (const plname of plorder) {
    let jlist = UI.players[plname].journeys;
    for (const jitem of jlist) {
      let o = jitem.items[0];
      let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: jitem.path, index: 0 };
      items.push(item);
    }
  }
  let cmds = ui_get_submit_items(['discard', 'auflegen', 'jolly', 'anlegen']);
  items = items.concat(cmds);
  reindex_items(items);
  return items;
}
function ui_get_hand_and_journey_items(uplayer) {
  let items = ui_get_hand_items(uplayer);
  let matching = [];
  for (const plname of Z.plorder) {
    let jitems = ui_get_journey_items(plname);
    for (const j of jitems) {
      for (const card of items) {
        if (matches_on_either_end(card, j)) { matching.push(j); break; }
      }
    }
  }
  items = items.concat(matching);
  reindex_items(items);
  return items;
}
function ui_get_hand_and_stall_items(uplayer) {
  let items = ui_get_hand_items(uplayer);
  items = items.concat(ui_get_stall_items(uplayer));
  reindex_items(items);
  return items;
}
function ui_get_hand_items(uplayer) {
  let items = [], i = 0;
  let hand = UI.players[uplayer].hand;
  for (const o of hand.items) {
    o.index = i;
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: hand.path, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_hand_items_minus(uplayer, cardlist) {
  if (!isList(cardlist)) cardlist = [cardlist];
  let items = [], i = 0;
  let hand = UI.players[uplayer].hand;
  for (const o of hand.items) {
    if (cardlist.includes(o)) continue;
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: hand.path, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_harvest_items(uplayer) {
  let items = []; let i = 0;
  for (const gb of UI.players[uplayer].buildinglist) {
    if (isdef(gb.harvest)) {
      let d = gb.harvest;
      mStyle(d, { cursor: 'pointer', opacity: 1 });
      gb.div = d;
      let name = 'H' + i + ':' + (gb.list[0][0] == 'T' ? '10' : gb.list[0][0]);
      let item = { o: gb, a: name, key: name, friendly: name, path: gb.path, index: i };
      i++;
      items.push(item);
    }
  }
  return items;
}
function ui_get_hidden_building_items(uibuilding) {
  let items = [];
  for (let i = 1; i < uibuilding.items.length; i++) {
    let o = uibuilding.items[i];
    o.index = i;
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: uibuilding.path, index: i - 1 };
    items.push(item);
  }
  return items;
}
function ui_get_journey_items(plname) {
  let gblist = UI.players[plname].journeys;
  let items = [], i = 0;
  for (const o of gblist) {
    let name = `${plname}_j${i}`;
    o.div = o.container;
    let item = { o: o, a: name, key: o.list[0], friendly: name, path: o.path, index: i, ui: o.container };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_market_items() {
  let items = [], i = 0;
  for (const o of UI.market.items) {
    o.index = i;
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: `market`, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_open_discard_items() {
  let items = [], i = 0;
  for (const o of UI.open_discard.items) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: `open_discard`, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_other_buildings(uplayer) {
  let items = [];
  for (const plname of Z.plorder) {
    if (plname == uplayer) continue;
    items = items.concat(ui_get_buildings(UI.players[plname].buildinglist));
  }
  reindex_items(items);
  return items;
}
function ui_get_other_buildings_and_rumors(uplayer) {
  let items = ui_get_other_buildings(uplayer);
  items = items.concat(ui_get_rumors_items(uplayer));
  reindex_items(items);
  return items;
}
function ui_get_other_buildings_with_rumors(uplayer) {
  let items = [];
  for (const plname of Z.plorder) {
    if (plname == uplayer) continue;
    items = items.concat(ui_get_buildings(UI.players[plname].buildinglist.filter(x => !isEmpty(x.rumors))));
  }
  reindex_items(items);
  return items;
}
function ui_get_payment_items(pay_letter) {
  let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
  let items = ui_get_hand_and_stall_items(uplayer);
  let n = items.length;
  items = items.filter(x => x.key[0] == pay_letter);
  if (n == 4 && A.command == 'build') items = [];
  if (n == 1 && A.command == 'upgrade') items = [];
  if (fen.players[uplayer].coins > 0 && fen.phase[0].toUpperCase() == pay_letter) {
    items.push({ o: null, a: 'coin', key: 'coin', friendly: 'coin', path: null });
  }
  let i = 0; items.map(x => { x.index = i; i++; });
  return items;
}
function ui_get_rumors_and_players_items(uplayer) {
  let items = [], i = 0;
  let comm = UI.players[uplayer].rumors;
  let [data, pl] = [Z.uplayer_data, Z.pl];
  assertion(isdef(data), 'no data for player ' + uplayer);
  if (!isDict(data.state)) data.state = { remaining: jsCopy(pl.rumors), receivers: [], di: {} };
  let rem = data.state.remaining;
  for (const k of rem) {
    let o = firstCond(comm.items, x => x.key == k);
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: comm.path, index: i };
    i++;
    items.push(item);
  }
  let players = [];
  let receivers = data.state.receivers;
  for (const plname in UI.players) {
    if (plname == uplayer || receivers.includes(plname)) continue;
    players.push(plname);
  }
  items = items.concat(ui_get_string_items(players));
  reindex_items(items);
  return items;
}
function ui_get_rumors_items(uplayer) {
  let items = [], i = 0;
  let rum = UI.players[uplayer].rumors;
  for (const o of rum.items) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: rum.path, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_schweine_candidates(uibuilding) {
  let items = ui_get_hidden_building_items(uibuilding);
  items = items.filter(x => x.o.key[0] != uibuilding.keycard.key[0]);
  reindex_items(items);
  return items;
}
function ui_get_stall_items(uplayer) {
  let items = [], i = 0;
  let stall = UI.players[uplayer].stall;
  for (const o of stall.items) {
    o.index = i;
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: stall.path, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_string_items(commands) {
  let items = [], i = 0;
  for (const cmd of commands) {
    let item = { o: null, a: cmd, key: cmd, friendly: cmd, path: null, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_submit_items(commands) {
  let items = [], i = 0;
  for (const cmd of commands) {
    let item = { o: null, a: cmd, key: cmd, friendly: cmd, path: null, index: i, submit_on_click: true, itemtype: 'submit' };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_top_rumors() {
  let items = [], i = 0;
  for (const o of UI.rumor_top.items) {
    let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: `rumor_top`, index: i };
    i++;
    items.push(item);
  }
  return items;
}
function ui_get_trade_items(uplayer) {
  let items = ui_get_market_items(uplayer);
  items = items.concat(ui_get_stall_items(uplayer));
  for (const plname of Z.fen.plorder) {
    if (plname != uplayer) items = items.concat(ui_get_stall_items(plname));
  }
  reindex_items(items);
  return items;
}
function ui_ground_zero() {
  STOPAUS = true;
  uiActivated = aiActivated = false;
  clearTimeouts();
  if (isdef(G) && isdef(G.clear)) G.clear();
  if (isdef(GC) && isdef(GC.clear)) GC.clear();
  TOMan.clear();
  clearMarkers();
  resetUIDs();
  Items = {};
}
function ui_make_card_container(n, dParent, styles = { bg: 'random', padding: 10 }) {
  let id = getUID('u');
  let d = mDiv(dParent, styles, id);
  return d;
}
function ui_make_container(dParent, styles = { bg: 'random', padding: 10 }) {
  let id = getUID('u');
  let d = mDiv(dParent, styles, id);
  return d;
}
function ui_make_deck_container(list, dParent, styles = { bg: 'random', padding: 10 }, get_card_func) {
  let id = getUID('u');
  let d = mDiv(dParent, styles, id);
  if (isEmpty(list)) return d;
  let c = get_card_func(list[0]);
  mContainerSplay(d, 4, c.w, c.h, n, 0);
  return d;
}
function ui_make_hand_container(items, dParent, styles = { bg: 'random', padding: 10 }) {
  let id = getUID('u');
  let d = mDiv(dParent, styles, id);
  if (!isEmpty(items)) {
    let card = items[0];
    mContainerSplay(d, 2, card.w, card.h, items.length, card.ov * card.w);
  }
  return d;
}
function ui_make_player(otree, uname, dParent) {
  let id = getUID('u');
  let bg = otree[uname].color;
  let styles = { bg: bg, fg: 'contrast', w: '100%' };
  d = mDiv(dParent, styles, id, uname);
  return d;
}
function ui_make_random_deck(n = 10) {
  let list = choose(get_keys(Aristocards), n);
  let cont = ui_make_deck_container(n, dTable, { bg: 'random', padding: 4 });
  let items = list.map(x => ari_get_card(x));
  let topmost = ui_add_cards_to_deck_container(cont, items, list);
  return {
    list: list,
    container: cont,
    items: items,
    topmost: topmost,
  };
}
function ui_make_random_hand(n = 1) {
  let list = choose(get_keys(Aristocards), n);
  let cont = ui_make_hand_container(n, dTable, { bg: 'random', padding: 4 });
  let items = list.map(x => ari_get_card(x));
  ui_add_cards_to_hand_container(cont, items, list);
  return {
    list: list,
    container: cont,
    items: items,
  };
}
function ui_make_random_market(n = 1) {
  let cont = ui_make_card_container(n, dTable, { bg: 'random', padding: 4, display: 'flex' });
  let list = choose(get_keys(Aristocards), n);
  let items = list.map(x => ari_get_card(x));
  if (n > 0) ui_add_cards_to_card_container(cont, items, list);
  return {
    list: list,
    container: cont,
    items: items,
  };
}
function ui_make_table() {
  let d = mBy('inner_left_panel'); clearElement(d);
  let dou = mDiv100(d, { display: 'flex' });
  dTable = mDiv(dou, { flex: 5, display: 'flex' });
  return dTable;
}
function ui_player_info(dParent, outerStyles = { dir: 'column' }, innerStyles = {}) {
  let fen = Z.fen;
  if (nundef(outerStyles.display)) outerStyles.display = 'flex';
  mStyle(dParent, outerStyles);
  let items = {};
  let styles = jsCopy(innerStyles); addKeys({ rounding: 10, bg: '#00000050', margin: 4, padding: 4, patop: 12, box: true, 'border-style': 'solid', 'border-width': 6 }, styles);
  let order = get_present_order();
  for (const plname of order) {
    let pl = fen.players[plname];
    let uname = pl.name;
    let imgPath = `../base/assets/users/${uname}.jpg`;
    styles['border-color'] = get_user_color(uname);
    let item = mDivItem(dParent, styles, name2id(uname));
    let d = iDiv(item);
    let picstyle = { w: 50, h: 50, box: true };
    let ucolor = get_user_color(uname);
    if (pl.playmode == 'bot') {
      copyKeys({ rounding: 0, border: `double 6px ${ucolor}` }, picstyle);
    } else {
      copyKeys({ rounding: '50%', border: `solid 2px white` }, picstyle);
    }
    let img = mImage(imgPath, d, picstyle, 'img_person');
    items[uname] = item;
  }
  if (DA.SIMSIM || is_advanced_user()) activate_playerstats(items)
  return items;
}
function ui_present_stats(otree) {
  let players = otree.player_names;
  let items = ui_player_info(players.map(x => otree[x]));
  for (const uname of players) {
    let pl = otree[uname];
    let totals = inno_calc_visible_syms(pl.board, pl.splays);
    pl.totals = totals;
    let item = items[uname];
    let d = iDiv(item); mCenterFlex(d); mLinebreak(d);
    for (const r in totals) {
      inno_stat_sym(r, totals[r], d, 20);
    }
  }
  return items;
}
function ui_present_table(r, dParent) {
  let g = Session;
  let uitree = r.uiNodes = {};
  if (g.cur_game == 'gPreinno') inno_create_ui_tree(R.root, dParent, r);
  else if (g.cur_game == 'gAristo') ari_create_ui_tree(R.root, dParent, r);
  return uitree;
}
function ui_table_actions_stats() {
  let d = mBy('inner_left_panel'); clearElement(d);
  let dou = mDiv100(d, { display: 'flex' });
  dTable = mDiv(dou, { flex: 5, display: 'flex', overflow: 'auto', position: 'relative' });
  mCenterFlex(dTable, false);
  dTable.animate([{ opacity: 0, transform: 'translateY(50px)' }, { opacity: 1, transform: 'translateY(0px)' },], { fill: 'both', duration: 1000, easing: 'ease' });
  dTop = mDiv(dTable, { bg: '#00000040', fg: 'white', w: '100%' }, 'dOben', 'hallo');
  dTop.innerHTML = '';
  dOben = mDiv(dTable, { bg: '#ffffff40', w: '100%' }, 'dOben', 'hallo');
  dOben.innerHTML = '';
  dActions = mDiv(dOben, { w: '100%' });
  for (let i = 0; i <= 5; i++) {
    window[`dActions${i}`] = mDiv(dActions, { w: '100%' });
  }
  dError = mDiv(dOben, { w: '100%', bg: 'red', fg: 'yellow' });
  dPlayerStats = dRechts = mDiv(dou, { flex: 1 }, 'dRechts', 'hallo');
}
function ui_type_building(b, dParent, styles = {}, path = 'farm', title = '', get_card_func = ari_get_card, separate_lead = false, ishidden = false) {
  let cont = ui_make_container(dParent, get_container_styles(styles));
  let cardcont = mDiv(cont);
  let list = b.list;
  let d = mDiv(dParent);
  let items = list.map(x => get_card_func(x));
  reindex_items(items);
  let d_harvest = null;
  if (isdef(b.h)) {
    let keycard = items[0];
    let d = iDiv(keycard);
    mStyle(d, { position: 'relative' });
    d_harvest = mDiv(d, { position: 'absolute', w: 20, h: 20, bg: 'orange', opacity: .5, fg: 'black', top: '45%', left: -10, rounding: '50%', align: 'center' }, null, 'H');
  }
  let d_rumors = null, rumorItems = [];
  if (!isEmpty(b.rumors)) {
    let d = cont;
    mStyle(d, { position: 'relative' });
    d_rumors = mDiv(d, { display: 'flex', gap: 2, position: 'absolute', h: 30, bottom: 0, right: 0 });
    for (const rumor of b.rumors) {
      let dr = mDiv(d_rumors, { h: 24, w: 16, vmargin: 3, align: 'center', bg: 'dimgray', rounding: 2 }, null, 'R');
      rumorItems.push({ div: dr, key: rumor });
    }
  }
  let card = isEmpty(items) ? { w: 1, h: 100, ov: 0 } : items[0];
  let [ov, splay] = separate_lead ? [card.ov * 1.5, 5] : [card.ov, 2];
  mContainerSplay(cardcont, 5, card.w, card.h, items.length, card.ov * 1.5 * card.w);
  ui_add_cards_to_hand_container(cardcont, items, list);
  ui_add_container_title(title, cont, items);
  let uischweine = [];
  for (let i = 1; i < items.length; i++) {
    let item = items[i];
    if (!b.schweine.includes(i)) face_down(item); else add_ui_schwein(item, uischweine);
  }
  return {
    ctype: 'hand',
    list: list,
    path: path,
    container: cont,
    cardcontainer: cardcont,
    items: items,
    schweine: uischweine,
    harvest: d_harvest,
    rumors: rumorItems,
    keycard: items[0],
  };
}
function ui_type_church(list, dParent, styles = {}, path = 'trick', title = '', get_card_func = ari_get_card, show_if_empty = false) {
  let cont = ui_make_container(dParent, get_container_styles(styles));
  let cardcont = mDiv(cont, { display: 'flex' });
  let items = [];
  let n = Z.plorder.length;
  let inc = 90;
  let rotation = n % 2 ? 0 : 90;
  for (const ckey of list) {
    let d = mDiv(cardcont, { origin: 'center', transform: `rotate( ${rotation}deg )`, position: 'absolute', left: 8 });
    let c = get_card_func(ckey);
    if (ckey != arrLast(list)) face_down(c);
    mAppend(d, iDiv(c));
    remove_card_shadow(c);
    let item = { card: c, div: d };
    items.push(item);
    rotation += inc;
  }
  ui_add_container_title(title, cont, items, show_if_empty);
  return {
    list: list,
    path: path,
    container: cont,
    cardcontainer: cardcont,
    items: items,
  }
}
function ui_type_deck(list, dParent, styles = {}, path = 'deck', title = 'deck', get_card_func = ari_get_card, show_if_empty = false) {
  let cont = ui_make_container(dParent, get_container_styles(styles));
  let cardcont = mDiv(cont);
  let items = [];
  ensure_ui(list, cardcont, items, get_card_func);
  ui_add_container_title(title, cont, items, show_if_empty);
  function get_topcard() { return isEmpty(list) ? null : items[0]; }
  function get_bottomcard() { return isEmpty(list) ? null : arrLast(items); }
  function ensure_ui(list, cardcont, items, get_card_func) {
    clearElement(cardcont); arrClear(items); if (isEmpty(list)) return;
    let n = Math.min(2, list.length); let ct = get_card_func(list[0]); items.push(ct); if (n > 1) { let cb = get_card_func(arrLast(list)); items.push(cb); }
    mStyle(cardcont, { position: 'relative', wmin: ct.w + 8, hmin: ct.h });
    for (let i = items.length - 1; i >= 0; i--) { let x = items[i]; face_down(x); mAppend(cardcont, iDiv(x)); mStyle(iDiv(x), { position: 'absolute', top: 0, left: 0 }) }
    mText(list.length, iDiv(ct), { position: 'absolute', left: list.length >= 100 ? '10%' : '25%', top: 10, fz: ct.h / 3 });
  }
  return {
    ctype: 'deck',
    container: cont,
    cardcontainer: cardcont,
    items: items,
    list: list,
    title: title,
    path: path,
    func: get_card_func,
    get_topcard: get_topcard,
    get_bottomcard: get_bottomcard,
    get_card_func: get_card_func,
    renew: ensure_ui,
  };
}
function ui_type_hand(list, dParent, styles = {}, path = 'hand', title = 'hand', get_card_func = ari_get_card, show_if_empty = false) {
  let cont = ui_make_container(dParent, get_container_styles(styles));
  let items = list.map(x => get_card_func(x));
  let cardcont = mDiv(cont);
  let card = isEmpty(items) ? { w: 1, h: Config.ui.card.h, ov: 0 } : items[0];
  let splay = 2;
  mContainerSplay(cardcont, splay, card.w, card.h, items.length, card.ov * card.w);
  ui_add_cards_to_hand_container(cardcont, items, list);
  ui_add_container_title(title, cont, items, show_if_empty);
  return {
    ctype: 'hand',
    list: list,
    path: path,
    container: cont,
    cardcontainer: cardcont,
    splay: splay,
    items: items,
  };
}
function ui_type_item(dParent, item, styles = {}, handler = null, show_key = null) {
  addKeys({ align: 'center', overflow: 'hidden', cursor: 'pointer', rounding: 10, margin: 10, padding: 5, w: 120, wmin: 90, display: 'inline-block', bg: 'random', fg: 'contrast' }, styles);
  let d = mDiv(dParent, styles);
  if (!isEmptyOrWhiteSpace(item.text)) mSpan(d, { family: item.family, fz: 50 }, item.text);
  if (show_key) {
    mSpan(d, { family: 'opensans' }, '<br>' + show_key);
  }
  if (isdef(handler)) d.onclick = handler;
  return d;
}
function ui_type_item_line(dParent, item, styles = {}, handler = null, props = []) {
  let d = mDiv(dParent, styles, `d_${item.key}`); mFlex(d);
  for (const p of props) {
    let family = p == 'text' ? item.family : 'arial';
    let fz = p == 'text' ? 40 : 20;
    mDiv(d, { family: family, fz: fz, bg: styles.bg, fg: styles.fg }, null, item[p]);
  }
  if (isdef(handler)) { d.onclick = handler; d.setAttribute('item', JSON.stringify(item)); }
  return d;
}
function ui_type_lead_hand(list, dParent, styles = {}, path = 'hand', title = 'hand', get_card_func = ari_get_card, show_if_empty = false) {
  let hcard = isdef(styles.h) ? styles.h - 30 : Config.ui.card.h;
  addKeys(get_container_styles(styles), styles);
  let cont = ui_make_container(dParent, styles);
  let items = list.map(x => get_card_func(x, hcard));
  let cardcont = mDiv(cont);
  let card = isEmpty(items) ? { w: 1, h: hcard, ov: 0 } : items[0];
  let splay = 5;
  mContainerSplay(cardcont, splay, card.w, card.h, items.length, card.ov * card.w);
  ui_add_cards_to_hand_container(cardcont, items, list);
  ui_add_container_title(title, cont, items, show_if_empty);
  return {
    ctype: 'hand',
    list: list,
    path: path,
    container: cont,
    cardcontainer: cardcont,
    splay: splay,
    items: items,
  };
}
function ui_type_market(list, dParent, styles = {}, path = 'market', title = 'market', get_card_func = ari_get_card, show_if_empty = false) {
  let cont = ui_make_container(dParent, get_container_styles(styles));
  let cardcont = mDiv(cont, { display: 'flex', gap: 2 });
  let items = list.map(x => get_card_func(x));
  items.map(x => mAppend(cardcont, iDiv(x)));
  ui_add_container_title(title, cont, items, show_if_empty);
  return {
    ctype: 'market',
    list: list,
    path: path,
    container: cont,
    cardcontainer: cardcont,
    items: items,
  };
}
function ui_type_rank_count(list, dParent, styles, path, title, get_card_func, show_if_empty = false) {
  let cont = ui_make_container(dParent, get_container_styles(styles));
  let cardcont = mDiv(cont, { display: 'flex' });
  let items = [];
  for (const o of list) {
    let d = mDiv(cardcont, { display: 'flex', dir: 'c', padding: 1, fz: 12, align: 'center', position: 'relative' });
    let c = get_card_func(o.key);
    mAppend(d, iDiv(c));
    remove_card_shadow(c);
    d.innerHTML += `<span style="font-weight:bold">${o.count}</span>`;
    let item = { card: c, count: o.count, div: d };
    items.push(item);
  }
  ui_add_container_title(title, cont, items, show_if_empty);
  return {
    list: list,
    path: path,
    container: cont,
    cardcontainer: cardcont,
    items: items,
  }
}
function ui_type_sym_text_line(dParent, item, styles = {}, handler = null) {
  let d = mDiv(dParent, styles, `d_${item.key}`); mFlex(d);
  let sym = valf(item.sym, Syms[item.key]);
  mDiv(d, { family: sym.family, fz: 40 }, null, sym.text);
  mDiv(d, { family: 'opensans', fz: 20 }, null, item.text);
  if (isdef(handler)) { d.onclick = handler; d.setAttribute('item', JSON.stringify(item)); }
  return d;
}
function ui_type_tile(ga, d, styles, classes) {
  let item = {};
  copyKeys(ga, item);
  let [sym, bg, id] = [Syms[ga.logo], ga.color, getUID()];
  item.id = id; item.isOpen = true;
  function open() {
    let item = Items[id];
    if (item.isOpen) return; item.isOpen = true;
    let d1 = iDiv(item); iClear(d1);
    let d2 = mDiv(d1, { position: 'absolute', top: 2, left: 2, display: 'flex', gap: 2 });
    let sz = 20;
    mDiv(d2, { fz: sz, family: sym.family, 'line-height': sz }, null, sym.text);
    mDiv(d2, { fz: sz - 5, 'line-height': sz }, null, item.friendly);
    console.log('item.name', item.name)
    let f = window[item.name + '_open']; if (isdef(f)) f(item);
  }
  function close(trigger = true) {
    let item = Items[id];
    if (!item.isOpen) return; item.isOpen = false;
    let d1 = iDiv(item); iClear(d1);
    mDiv(d1, { fz: 50, family: sym.family, 'line-height': 55 }, null, sym.text);
    mLinebreak(d1, 4);
    mDiv(d1, { fz: 18, align: 'center' }, null, item.friendly);
    if (!trigger) return;
    let f = window[item.name + '_close']; if (isdef(f)) f(item);
  }
  function toggle(ev) {
    evNoBubble(ev);
    let item = Items[id];
    if (item.isOpen) close(); else open();
  }
  let d1 = mDiv(d, { cursor: 'pointer', 'user-select': 'none', rounding: 10, margin: 10, vpadding: 15, hmin: 90, wmin: 140, bg: bg, position: 'relative' }, id, null, 'hop1');
  d1.setAttribute('name', ga.name);
  mCenterFlex(d1);
  iReg(item, { div: d1 });
  d1.onclick = toggle;
  close(false);
  return {
    item: item,
    open: open,
    close: close,
    toggle: toggle,
  }
}
function uid() {
  UID += 1;
  return 'a' + UID;
}
function uidHelpers() {
  UIDHelpers += 1;
  return 'id' + UIDHelpers;
}
function uiGetContact(row, msgs = {}) {
  let image = get_image_path(row);
  let mydata = `
      <div class='contact' style='position:relative;text-align:center;margin-bottom:18px;' username='${row.name}' onclick='start_chat(event)'>
        <img src='${image}' draggable='true' ondragstart='drag(event)' class='img_person sz100' style='margin:0;'/>
        <br>${row.name}`;
  if (isdef(msgs[row.username])) {
    mydata += `<div style='width:20px;height:20px;border-radius:50%;background-color:orange;color:white;position:absolute;left:0px;top:0px;'>` + msgs[row.username] + "</div>";
  }
  mydata += "</div>";
  return mydata;
}
function uiGetContacts(myusers, msgs) {
  mydata = '';
  for (const r of myusers) {
    row = r;
    mydata += uiGetContact(row, msgs);
  }
  return mydata;
}
function uiGetContactStylesAndStart() {
  let mydata = `
  <style>
    @keyframes appear{
      0%{opacity:0;transform: translateY(50px)}
      100%{opacity:1;transform: translateY(0px)}
     }
     .contact{
       cursor:pointer;
       transition: all .5s cubic-bezier(0.68, -2, 0.265, 1.55);
     }
     .contact:hover{
       transform: scale(1.1);
     }
  </style>
  <div style="text-align: center; animation: appear 1s ease both">
  `;
  return mydata;
}
function uiGetGame(gi, tables = []) {
  let sym = Syms[gi.logo];
  let bg = getColorDictColor(gi.color);
  let gname = gi.id;
  let uname = Session.cur_user;
  let color = null, id = getUID();
  if (!isEmpty(tables)) {
    let t = tables[0];
    let table_status = t.status;
    let my_status = t.player_status;
    let have_another_move = my_status == 'joined' || my_status == 'lamov';
    color = have_another_move ? 'green'
      : t.player_status == 'join' ? 'orange'
        : t.host == uname && t.status == 'ready' ? 'yellow'
          : table_status == 'show' || t.status == 'seen' ? 'blue'
            : t.status == 'ending' ? 'red' : 'black';
    id = `rk_${t.id}`;
  }
  return `
  <div onclick="onclick_game_in_games_menu(event)" gamename=${gi.id} style='cursor:pointer;border-radius:10px;margin:10px;padding:5px;padding-top:15px;width:120px;height:90px;display:inline-block;background:${bg};position:relative;'>
  ${nundef(color) ? '' : runderkreis(color, id)}
  <span style='font-size:50px;font-family:${sym.family}'>${sym.text}</span><br>${gi.friendly}</div>
  `;
}
function uiGetGames(mygames, tables) {
  mydata = '';
  for (const r of mygames) {
    row = r;
    mydata += uiGetGame(row, tables[r.id]);
  }
  return mydata;
}
function uiGetGamesStylesAndStart() {
  let mydata = `
  <style>
     .contact{
       cursor:pointer;
       transition: all .5s cubic-bezier(0.68, -2, 0.265, 1.55);
     }
     .contact:hover{
       transform: scale(1.1);
     }
  </style>
  <div id='game_menu' style="text-align: center; animation: appear 1s ease both">
  `;
  return mydata;
}
function uiGetLoginNew(row, msgs = {}) {
  let image = get_image_path(row);
  let mydata = `
      <div class='contact' style='position:relative;text-align:center;margin-bottom:18px;' username='${row.name}' 
        onclick='onclick_user_login_new(event)'>
        <img src='${image}' draggable='true' ondragstart='drag(event)' class='img_person sz100' style='margin:0;'/>
        <br>${row.name}`;
  if (isdef(msgs[row.username])) {
    mydata += `<div style='width:20px;height:20px;border-radius:50%;background-color:orange;color:white;position:absolute;left:0px;top:0px;'>` + msgs[row.username] + "</div>";
  }
  mydata += "</div>";
  return mydata;
}
function uiGetLoginNewList(myusers, msgs) {
  mydata = '';
  for (const r of myusers) {
    row = r;
    mydata += uiGetLoginNew(row, msgs);
  }
  return mydata;
}
function uiGetLoginNewStylesAndStart() {
  let mydata = `
  <style>
    @keyframes appear{
      0%{opacity:0;transform: translateY(50px)}
      100%{opacity:1;transform: translateY(0px)}
     }
     .contact{
       cursor:pointer;
       transition: all .5s cubic-bezier(0.68, -2, 0.265, 1.55);
     }
     .contact:hover{
       transform: scale(1.1);
     }
  </style>
  <div style="text-align: center; animation: appear 1s ease both">
  `;
  return mydata;
}
function uiNodesToUiTree(R) {
  let uiTree = {};
  for (const k in R.uiNodes) {
    let n = R.uiNodes[k];
    uiTree[k] = jsCopyMinus(n, 'act', 'ui', 'defParams', 'params');
  }
  return uiTree;
}
function unCamel(s) { return separateAtCapitals(s); }
function unCamelCase(s) { return separateAtCapitals(s); }
function uncheckAvailable(i) {
  id = getidAvailable(i); document.getElementById(id).checked = false;
}
function uncheckPlayer(i) {
  id = getidNum(i); document.getElementById(id).checked = false;
}
function uncollapseAll() {
  let coll = document.getElementsByClassName("collapsible");
  for (let i = 0; i < coll.length; i++) {
    let elem = coll[i];
    if (!isVisible(getLinkContainerId(elem.id))) fireClick(elem);
  }
}
function unfillChar(inp) { unfillCharInput(inp); }
function unfillCharInput(inp) {
  let d = iDiv(inp);
  d.innerHTML = '_';
  mClass(d, 'blink');
  inp.isBlank = true;
}
function unfillWord(winp) { winp.charInputs.map(x => unfillCharInput(x)); }
function unfocusOnEnter(ev) {
  if (ev.key === 'Enter') {
    ev.preventDefault();
    mBy('dummy').focus();
  }
}
function unfreezeUI() {
  if (!frozen) return;
  frozen = false;
  hide('tempFreezer');
}
function unhighAll(oid) { mapSafe('unhigh', getVisuals, oid); }
function unhighAux(oid) { mapSafe('unhigh', getAuxVisuals, oid); }
function unhighlightBoat() {
  if (boatHighlighted) {
    unhighlightMsAndRelatives(null, boatHighlighted);
    closeInfoboxesForBoatOids(boatHighlighted);
    boatHighlighted = null;
  }
}
function unhighlightContentIds(b) {
  let s = b.innerHTML;
  let ids = s.split(/[ ,:;]+/);
  for (const id of ids) {
    if (id == '_') continue;
    let msList = getVisuals(id);
    if (!msList) continue;
    for (const ms of msList) ms.unhigh();
  }
}
function unhighlightMsAndRelatives(ev, mobj, partName) {
  let id = mobj.id;
  mobj.unhigh(partName);
  let relativeIds = id2uids[id];
  if (nundef(relativeIds)) return;
  for (const idRel of relativeIds) {
    let msRel = UIS[idRel];
    msRel.unhigh('title');
  }
}
function unhighMain(oid) { mapSafe('unhigh', getVisual, oid); }
function unhighSelfAndRelatives(uid, R) {
  for (const oid of R.uid2oids[uid]) {
    for (const uid1 of R.oid2uids[oid]) {
      let ui = R.getUI(uid1);
      mUnhigh(ui);
    }
  }
  let n = R.uiNodes[uid];
  if (n.potentialOverlap) {
    let ui = R.getUI(uid);
    sendToBack(ui);
  }
}
function uniformSizeToContent(uid) {
  let n = R.uiNodes[uid];
  if (nundef(n.children)) return { w: 0, h: 0 }
  parentPadding = isdef(n.params.paddingAroundChildren) ? n.params.paddingAroundChildren : DEFS.defaultPadding;
  childMargin = isdef(n.params.gapBetweenChildren) ? n.params.gapBetweenChildren : DEFS.defaultGap;
  let or = n.params.orientation;
  let rows = cols = 1;
  if (or == 'w') { rows = n.params.rows; cols = n.params.cols; }
  let bl = n.params.baseline;
  let [y0, wTitle] = calcParentContentYOffsetAndWidth(n, parentPadding);
  let children = n.children.map(x => R.uiNodes[x]);
  if (or == 'w') {
    let wchi = Math.max(...children.map(x => x.size.w));
    let hchi = Math.max(...children.map(x => x.size.h));
    let wpar = 2 * parentPadding + wchi * cols + (cols - 1) * childMargin;
    let hpar = y0 + parentPadding + hchi * rows + (rows - 1) * childMargin;
    let xoff = (wTitle > wpar) ? (wTitle - wpar) / 2 : 0;
    let x = xoff + parentPadding;
    let y = y0;
    let i = 0;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        let ch = children[i];
        i += 1;
        ch.params.size = { w: wchi, h: hchi };
        ch.params.pos = { x: x, y: y };
        x += wchi + childMargin;
        setFixedSizeAndPos(ch);
      }
      x = xoff + parentPadding;
      y += hchi + childMargin;
    }
    return { w: wpar, h: hpar };
  }
  let axMain, ax2;
  if (or == 'v') { axMain = 'h'; ax2 = 'w'; }
  else if (or == 'h') { axMain = 'w'; ax2 = 'h'; }
  let ax2Max = Math.max(...children.map(x => x.size[ax2]));
  let axMainSum = children.reduce((a, b) => a + (b.size[axMain] || 0), 0);
  axMainSum += childMargin * (children.length - 1);
  let wmax = (or == 'v' ? ax2Max : axMainSum);
  let xoff = 0;
  if (wTitle > wmax) xoff = (wTitle - wmax) / 2;
  let x0 = parentPadding + xoff;
  let x = x0;
  let y = y0;
  let lastChild = R.uiNodes[n.children[n.children.length - 1]];
  for (const n1 of children) {
    if (or == 'v') {
      switch (bl) {
        case 'start': x = x0; break;
        case 'end': x = x0 + ax2Max - n1.size[ax2]; break;
        case 'centered': x = x0 + (ax2Max - n1.size[ax2]) / 2; break;
        case 'stretch':
          x = x0;
          if (n1.size.w < ax2Max) {
            n1.size.w = ax2Max;
            n1.ui.style.minWidth = n1.size.w + 'px';
          }
          break;
        default: x = x0 + (ax2Max - n1.size[ax2]) / 2; break;
      }
      n1.pos = { x: x, y: y, cx: x + n1.size.w / 2, cy: y + n1.size.h / 2 };
      y += n1.size[axMain];
      if (n1 != lastChild) y += childMargin;
    } else {
      switch (bl) {
        case 'start': y = y0; break;
        case 'end': y = y0 + ax2Max - n1.size[ax2]; break;
        case 'centered': y = y0 + (ax2Max - n1.size[ax2]) / 2; break;
        case 'stretch':
          y = y0;
          if (n1.size.h < ax2Max) {
            n1.size.h = ax2Max;
            n1.ui.style.minHeight = n1.size.h + 'px';
          }
          break;
        default: y = y0 + (ax2Max - n1.size[ax2]) / 2; break;
      }
      n1.pos = { x: x, y: y, cx: x + n1.size.w / 2, cy: y + n1.size.h / 2 };
      x += n1.size.w;
      if (n1 != lastChild) x += childMargin;
    }
    n1.ui.style.left = n1.pos.x + 'px';
    n1.ui.style.top = n1.pos.y + 'px';
  }
  let wParent, hParent;
  if (or == 'h') {
    wParent = Math.max(wTitle + parentPadding * 2, x + parentPadding);
    hParent = y0 + ax2Max + parentPadding;
  } else {
    wParent = Math.max(wTitle + parentPadding * 2, ax2Max + 2 * x0);
    hParent = y0 + axMainSum + parentPadding;
  }
  return { w: wParent, h: hParent };
}
function union(lst1, lst2) {
  return [...new Set([...lst1, ...lst2])];
}
function uniqueFirstLetters(arr) {
  let res = [];
  for (const s of arr) {
    if (s.length > 0) {
      addIf_dep(s[0], res);
    }
  }
  return res;
}
function unitTest8() {
  if (execOptions.activatedTests.includes('8699')) console.log(...arguments);
}
function unitTestAutoplay() {
  if (execOptions.activatedTests.includes('autoplay')) console.log(...arguments);
}
function unitTestBattle() {
  if (execOptions.activatedTests.includes('battle')) console.log(...arguments);
}
function unitTestBuildUnit() {
  if (execOptions.activatedTests.includes('buildUnit')) console.log(...arguments);
}
function unitTestCard() {
  if (execOptions.activatedTests.includes('card')) console.log(...arguments);
}
function unitTestCards() {
  if (execOptions.activatedTests.includes('cards')) console.log(...arguments);
}
function unitTestCardsNew() {
  if (execOptions.activatedTests.includes('cardsNew')) console.log(...arguments);
}
function unitTestChoice() {
  if (execOptions.activatedTests.includes('choice')) console.log(...arguments);
}
function unitTestChoicemin() {
  if (execOptions.activatedTests.includes('choice') || execOptions.activatedTests.includes('choicemin')) console.log(...arguments);
}
function unitTestCombat() {
  if (execOptions.activatedTests.includes('combat')) console.log(...arguments);
}
function unitTestCombatStage() {
  if (execOptions.activatedTests.includes('combatStage')) console.log(...arguments);
}
function unitTestConflict() {
  if (execOptions.activatedTests.includes('conflicts')) console.log(...arguments);
}
function unitTestControl() {
  if (execOptions.activatedTests.includes('control')) console.log(...arguments);
}
function unitTestConvoy() {
  if (execOptions.activatedTests.includes('convoy')) console.log(...arguments);
}
function unitTestDecision() {
  if (execOptions.activatedTests.includes('decision')) console.log(...arguments);
}
function unitTestDiplomacy() {
  if (execOptions.activatedTests.includes('diplomacy')) console.log(...arguments);
}
function unitTestFilter() {
  if (execOptions.activatedTests.includes('filter')) console.log(...arguments);
}
function unitTestFilterByType() {
  if (execOptions.activatedTests.includes('filterByType')) console.log(...arguments);
}
function unitTestFilterNation() {
  if (execOptions.activatedTests.includes('filterNation')) console.log(...arguments);
}
function unitTestGameloop() {
  if (execOptions.activatedTests.includes('gameloop')) console.log(...arguments);
}
function unitTestHover() {
  if (execOptions.activatedTests.includes('hover')) console.log(...arguments);
}
function unitTestInit() {
  if (execOptions.activatedTests.includes('init')) console.log(...arguments);
}
function unitTestLoad() {
  if (execOptions.activatedTests.includes('load')) console.log(...arguments);
}
function unitTestLog() {
  if (execOptions.activatedTests.includes('log')) console.log(...arguments);
}
function unitTestMap() {
  if (execOptions.activatedTests.includes('map')) console.log(...arguments);
}
function unitTestMatch() {
  if (execOptions.activatedTests.includes('match')) console.log(...arguments);
}
function unitTestMirrorBattle() {
  if (execOptions.activatedTests.includes('mirror')) console.log(...arguments);
}
function unitTestMovement() {
  if (execOptions.activatedTests.includes('movement')) console.log(...arguments);
}
function unitTestMoving() {
  if (execOptions.activatedTests.includes('moving')) console.log(...arguments);
}
function unitTestMS() {
  if (execOptions.activatedTests.includes('ms')) console.log(...arguments);
}
function unitTestPlayer() {
  if (execOptions.activatedTests.includes('player')) console.log(...arguments);
}
function unitTestRandom() {
  if (execOptions.activatedTests.includes('random')) console.log(...arguments);
}
function unitTestRemove() {
  if (execOptions.activatedTests.includes('remove')) console.log(...arguments);
}
function unitTestRemoved() {
  if (execOptions.activatedTests.includes('removed')) console.log(...arguments);
}
function unitTestRemovedCheck(data) {
  return execOptions.activatedTests.includes('removed') && 'removed' in data && !empty(Object.keys(data.removed));
}
function unitTestRequest() {
  if (execOptions.activatedTests.includes('request')) console.log(...arguments);
}
function unitTestResnail() {
  if (execOptions.activatedTests.includes('resnail')) console.log(...arguments);
}
function unitTestResponse() {
  if (execOptions.activatedTests.includes('response')) console.log(...arguments);
}
function unitTestSave() {
  if (execOptions.activatedTests.includes('save')) console.log(...arguments);
}
function unitTestScenario() {
  if (execOptions.activatedTests.includes('scenario')) console.log(...arguments);
}
function unitTestScenarioMin() {
  if (execOptions.activatedTests.includes('scenarioMin')) console.log(...arguments);
}
function unitTestScenarioWar() {
  if (execOptions.activatedTests.includes('scenarioWar')) console.log(...arguments);
}
function unitTestSeason() {
  if (execOptions.activatedTests.includes('season')) console.log(...arguments);
}
function unitTestSender() {
  if (execOptions.activatedTests.includes('sender')) console.log(...arguments);
}
function unitTestServer() {
  if (execOptions.activatedTests.includes('server')) console.log(...arguments);
}
function unitTestSkip() {
  if (execOptions.activatedTests.includes('skip')) console.log(...arguments);
}
function unitTestStage() {
  if (execOptions.activatedTests.includes('stage')) console.log(...arguments);
}
function unitTestStrategy() {
  if (execOptions.activatedTests.includes('strategy')) console.log(...arguments);
}
function unitTestUnits() {
  if (execOptions.activatedTests.includes('units')) console.log(...arguments);
}
function unitTestUnitVisibility() {
  if (execOptions.activatedTests.includes('visible')) console.log(...arguments);
}
function unitTestUpgradeUnit() {
  if (execOptions.activatedTests.includes('upgradeUnit')) console.log(...arguments);
}
function unitTimeUp() { return (Settings.minutesPerUnit * 60000 - getTimeElapsed()) <= 0; }
function unlink(id) {
  let oids = id2oids[id];
  let uids = id2uids[id];
  if (isdef(uids)) for (const uid of uids) removeInPlace(id2uids[uid], id);
  if (isdef(oids)) for (const oid of oids) removeInPlace(oid2ids[oid], id);
  delete id2uids[id];
  delete id2oids[id];
}
function unpack_table(table) {
  for (const k of ['players', 'fen', 'options', 'scoring']) {
    let val = table[k];
    if (isdef(table[k])) table[k] = if_stringified(val); if (nundef(table[k])) table[k] = {};
  }
  if (isdef(table.modified)) { table.modified = Number(table.modified); table.timestamp = new Date(table.modified); table.stime = stringBeforeLast(table.timestamp.toString(), 'G').trim(); }
  assertion(isdef(window[table.game]), 'game function for ' + table.game + ' not defined in window');
  if (isdef(table.game)) { table.func = window[table.game](); }
  if (isdef(table.options.mode)) { table.mode = table.options.mode; }
  delete table.action; delete table.expected;
  return table;
}
function untie_card(card) {
  remove_from_selection(card);
  clear_selection();
  let oldgroupid = card.groupid;
  if (isdef(oldgroupid)) delete card.owner;
  let oldgroup = Items[oldgroupid];
  let oldindex = isdef(oldgroup) ? oldgroup.ids.indexOf(card.id) : null;
  if (isdef(oldgroup)) removeInPlace(oldgroup.ids, card.id);
  return [oldgroup, oldindex];
}
function update_car(canvas, item) {
  let di = { ArrowUp: canvas.math ? 90 : 270, ArrowDown: canvas.math ? 270 : 90, ArrowLeft: 180, ArrowRight: 0 };
  for (const key in di) {
    if (is_key_down(key)) {
      item.v.a = di[key];
      update_position(item);
      return true;
    }
  }
  return false;
}
function update_cur_table(obj, color) {
  let t = Session.cur_table;
  let tnew = obj.table;
  if (isdef(obj.player_record)) copyKeys(obj.player_record, tnew);
  copyKeys(tnew, t);
  if (isdef(color)) {
    let d = mBy(`rk_${obj.table.id}`);
    if (isdef(d)) mStyle(d, { bg: color });
  }
}
function update_current_table() {
  let o = Serverdata.table;
  assertion(isdef(U), 'NO USER LOGGED IN WHEN GETTING TABLE FROM SERVER!!!!!!!!!!!!!!!!!!!!', U, o);
  if (nundef(Z) || nundef(Z.prev)) Z = { prev: {} };
  assertion(isdef(Z), 'ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ', Z);
  set_user(U.name);
  for (const wichtig of ['notes', 'uplayer', 'friendly', 'step', 'round', 'phase', 'stage', 'timestamp', 'modified', 'stime', 'mode', 'scoring']) {
    if (isdef(Z[wichtig])) Z.prev[wichtig] = jsCopy(Z[wichtig]);
  }
  Z.prev.turn = Clientdata.last_turn;
  copyKeys(o, Z, { uname: true });
  let [mode, turn, uname, plorder, fen, host] = [Z.mode, Z.turn, Z.uname, Z.plorder, Z.fen, Z.host];
  assertion(!isEmpty(turn), 'turn empty!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!', turn, fen, plorder);
  Z.role = !plorder.includes(uname) ? 'spectator' : turn.includes(uname) ? 'active' : 'inactive';
  if (Z.game == 'fritz' && Z.role == 'spectator' && isdef(Z.fen.roundorder) && Z.fen.roundorder.includes(uname)) {
    Z.role = 'inactive';
  }
  let upl = Z.role == 'active' ? uname : turn[0];
  if (mode == 'hotseat' && turn.length > 1) { let next = get_next_human_player(Z.prev.uplayer); if (next) upl = next; }
  if (mode == 'multi' && Z.role == 'inactive' && (uname != host || is_human_player(upl))) {
    upl = uname;
  }
  set_player(upl, fen);
  let [uplayer, pl] = [Z.uplayer, Z.pl];
  Z.playmode = pl.playmode;
  if (Z.playmode != 'human') Z.strategy = pl.strategy;
  let [friendly, modified] = [Z.friendly, Z.modified];
  Z.skip_presentation = !FORCE_REDRAW && friendly == Z.prev.friendly && modified <= Z.prev.modified && uplayer == Z.prev.uplayer;
  FORCE_REDRAW = false;
  if (Z.skip_presentation) {
    show_status(`nothing new in ${Z.friendly}`);
    const STOP_POLLING_AFTER = 30000;
    if (nundef(DA.noshow)) DA.noshow = 1; else DA.noshow++; if (DA.noshow >= STOP_POLLING_AFTER) onclick_stoppolling();
    autopoll();
  } else {
    DA.noshow = 0;
    delete DA.sperre;
    clear_timeouts();
  }
}
function update_db_user_from_pl_options(fen, game) {
  let parts = fen.split(',');
  for (const p of parts) {
    let [name, startlevel, lang] = p.split(':');
    startlevel = Number(startlevel);
    set_startlevel(name, game, startlevel);
    set_preferred_lang(name, lang);
  }
}
function update_draw_items() {
  for (const item of get_values(Items)) {
    if (isdef(item.update)) item.update(item);
    if (isdef(item.draw)) item.draw(item);
  }
}
function update_func(canvas, item) {
  let [cv, ctx, ia, ib, ifunc, axes] = [canvas.cv, canvas.cx, item.ia, item.ib, item.ifunc, item.axes];
  cClear(cv, ctx);
  showAxes(ctx, axes);
  let [la, lb, lf] = [[1, 2, 3, 4, 5, 5, 5, 4, 3, 2], [0, .5, 1, 1.5, 2, 2.5, 2.5, 2.5, 2, 1.5, 1, .5], ['sin', 'cos']];
  let [a, b, f] = [la[ia], lb[ib], lf[ifunc]];
  [item.ia, item.ib, item.ifunc] = [(ia + 1) % la.length, (ib + 1) % lb.length, (ifunc + 1) % lf.length];
  funGraph(ctx, axes, x => Math[f](a * x), "rgb(11,153,11)", 1);
  return false;
}
function update_game_status(players) {
  let d = dTitle;
  clearElement(d);
  let d1 = mDiv(d, { display: 'flex', 'justify-content': 'center', 'align-items': 'space-evenly' });
  for (const plname in players) {
    let pl = players[plname];
    let d2 = mDiv(d1, { margin: 4, align: 'center' }, null, `<img src='${pl.imgPath}' style="display:block" class='img_person' width=50 height=50>${pl.score}`);
  }
}
function update_game_values() {
  let game = Session.cur_game;
  let uname = Session.cur_user;
  let g = Session;
  let basevals = lookup(DB.games, [game]); if (basevals) copyKeys(basevals, g);
  for (const k in g.options) { g[k] = get_game_or_user_option(g, k); }
  let uservals = lookup(DB.users, [uname, 'games', game]); if (uservals) copyKeys(uservals, g);
  let levels = lookup(DB.games, [game, 'levels']);
  g.maxlevel = valf(get_keys(levels).length, 0) - 1;
  g.color = getColorDictColor(g.color);
  let level = g.level = nundef(g.level_setting) || g.level_setting == 'player' ? valf(g.startlevel, g.def_startlevel)
    : g.level_setting == 'min' ? 0 : g.level_setting == 'max' ? g.maxlevel : g.def_startlevel;
  if (levels) copyKeys(levels[level], g);
  delete g.levels;
  return g;
}
function update_language_choices(g) {
  let langs = g.availableLanguages;
  let language_holder = mBy('language_holder');
  clearElement(language_holder);
  let friendly = { E: 'english', D: 'german', S: 'spanish', F: 'french', C: 'mandarin' };
  if (isdef(language_holder) && isdef(langs) && langs.length > 1) {
    let avail = toLetterList(langs);
    let labels = avail.map(x => friendly[x]);
    let esel = mSelect(language_holder, avail, friendly, valf(g.lang, 'E'), (ev) => {
      let sel = ev.target;
      let val = sel.value;
      console.log('selected language', val)
      set_language(val, false);
    });
    mClass(esel.firstChild, 'statusselect');
  } else if (isdef(language_holder)) {
    mDiv(language_holder, { patop: 6 }, null, friendly[g.lang], 'statusselect');
  }
}
function update_move(canvas, item) {
  item.y += 1;
  item.y = cycle(item.y, canvas.miny, canvas.maxy);
  return true;
}
function update_my_score(inc) {
  let me = Session.cur_players[Session.cur_user];
  me.score += inc;
  return me.score;
}
function update_otree_from_ui(otree, objects) {
  for (const k in objects) {
    otree[k] = objects[k].list;
  }
  qanim();
}
function update_position(item) {
  let [a1, a2] = [item.a, item.v.a];
  let diff = Math.abs(a2 - a1);
  let inc = valf(item.turn_inc, 0);
  if (inc && diff > inc) {
    let cclock = is_turn_counter_clockwise(a1, a2);
    if (cclock) inc = -inc;
    let anew = a1 + inc;
    anew = (anew + 360) % 360;
    item.a = anew;
  } else {
    item.a = a2 % 360;
    let angle = toRadian(item.a);
    item.x += Math.cos(angle) * item.v.mag;
    item.y += Math.sin(angle) * item.v.mag;
  }
}
function update_session(obj) {
  for (const k in obj) { if (isdef(Session[k])) copyKeys(obj[k], Session[k]); else Session[k] = obj[k]; }
  if (isdef(obj.table)) {
    Session.cur_table = Session.table;
    Session.cur_funcs = window[Session.cur_game]();
    if (!isEmpty(obj.playerdata)) make_players(Session.table.players);
    console.assert(isdef(Session.cur_user) && Session.cur_game == Session.table.game && Session.cur_tid == Session.table.id, "SESSION MISMATCH IN GAME_OPEN_FOR_MOVE!!!!!!!!!!!!!!!!!!!!!");
  }
  if (isdef(obj.playerdata)) {
    let o = Session.cur_players;
    for (const rec of obj.playerdata) {
      if (rec.state == 'null') rec.state = null;
      copyKeys(rec, o[rec.name]);
    }
  }
}
function update_settings() {
  for (const k in settings) {
    let lower = k.toLowerCase();
    let inp = mBy(`i_${lower}`);
    if (isdef(inp)) {
      let value = Number(inp.innerHTML);
      if (isNumber(value)) settings[k] = value;
    }
  }
  socket.emit('settings', JSON.stringify(settings));
}
function update_table() {
  assertion(isdef(U), 'NO USER LOGGED IN WHEN GETTING TABLE FROM SERVER!!!!!!!!!!!!!!!!!!!!', U);
  if (nundef(Z) || nundef(Z.prev)) Z = { prev: {} };
  for (const wichtig of ['playerdata', 'notes', 'uplayer', 'uname', 'friendly', 'step', 'round', 'phase', 'stage', 'timestamp', 'modified', 'stime', 'mode', 'scoring']) {
    if (isdef(Z[wichtig])) Z.prev[wichtig] = jsCopy(Z[wichtig]);
  }
  Z.prev.turn = Clientdata.last_turn = Clientdata.this_turn;
  copyKeys(Serverdata, Z);
  if (isdef(Serverdata.table)) { copyKeys(Serverdata.table, Z); Z.playerlist = Z.players; copyKeys(Serverdata.table.fen, Z); }
  assertion(isdef(Z.fen), 'no fen in Z bei cmd=table or startgame!!!', Serverdata);
  Clientdata.this_turn = Z.turn;
  set_user(U.name);
  assertion(!isEmpty(Z.turn), 'turn empty!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!', Z.turn);
  let fen = Z.fen;
  Z.role = !is_playing(Z.uname, fen) ? 'spectator' : fen.turn.includes(Z.uname) ? 'active' : 'inactive';
  let [uname, turn, mode, host] = [Z.uname, fen.turn, Z.mode, Z.host];
  let upl = Z.role == 'active' ? uname : turn[0];
  if (mode == 'hotseat' && turn.length > 1) { let next = get_next_human_player(Z.prev.uplayer); if (next) upl = next; }
  if (mode == 'multi' && Z.role == 'inactive' && (uname != host || is_human_player(upl))) { upl = uname; }
  set_player(upl, fen);
  let pl = Z.pl;
  Z.playmode = pl.playmode;
  Z.strategy = uname == pl.name ? valf(Clientdata.strategy, pl.strategy) : pl.strategy;
  let [uplayer, friendly, modified] = [Z.uplayer, Z.friendly, Z.modified];
  Z.uplayer_data = firstCond(Z.playerdata, x => x.name == Z.uplayer);
  let sametable = !FORCE_REDRAW && friendly == Z.prev.friendly && modified <= Z.prev.modified && uplayer == Z.prev.uplayer;
  let sameplayerdata = isEmpty(Z.playerdata_changed_for);
  let myplayerdatachanged = Z.playerdata_changed_for.includes(Z.uplayer);
  let specialcase = !i_am_host() && !i_am_acting_host() && !i_am_trigger() && !myplayerdatachanged;
  Z.skip_presentation = sametable && (sameplayerdata || specialcase);
  if (DA.TEST0 && (!sametable || !sameplayerdata)) {
    console.log('======>Z.skip_presentation', Z.skip_presentation, '\nplayerdata_changed_for', Z.playerdata_changed_for);
    console.log('_______ *** THE END *** ___________')
  }
  FORCE_REDRAW = false;
}
function update_table_options_for_user(uname, table_options, game) {
  let lang = get_preferred_lang(uname);
  update_db_user_from_pl_options(table_options, game);
  let lang2 = get_preferred_lang(uname);
  if (lang != lang2) get_dictionary();
}
function updateBindings(supd, R) {
  for (const oid in supd) {
    for (const upd of supd[oid]) {
      let ukind = upd.ukind;
      if (ukind == 'valueChange') {
        let propUpdated = upd.prop;
        let skeys = R.getR(oid);
        let akku = [];
        recCollect(R.ROOT, x => { return x.oid == oid }, akku, true);
        for (const n of akku) {
          updateNode(n, upd, R);
        }
      }
    }
  }
}
function updateBubbleColors(e) {
  const w = window.innerWidth / 255;
  const h = window.innerHeight / 255;
  const x = parseInt(e.pageX / w, 10);
  const y = parseInt(e.pageY / h, 10);
  const r = x;
  const g = (y - 255) * -1;
  const b = x <= y ? y - x : 0;
  container.style.setProperty('--colorEnd', `rgb(${r},${g},${b})`);
}
function updateCollections() {
  S.settings.collectionTypes = { playerProps: ['hand', 'devcards'], objectProps: ['neutral'] };
  _updateCollections(G.playersUpdated, G.playersAugmented, S.settings.collectionTypes.playerProps);
  _updateCollections(G.tableUpdated, G.table, S.settings.collectionTypes.objectProps);
}
function updateColors(o) {
  let pal = S.pals[o.iPalette];
  let bg = pal[o.ipal];
  o.setBg(bg);
  if (o.strInfo && o.strInfo.ipals) {
    let ipals = o.strInfo.ipals;
    for (const id of o.ids) {
      let o = getVisual(id);
      if (o.isManual) continue;
      let info = o.memInfo;
      if (info && info.isPal) {
        let ipal = ipals[info.memType == 'field' ? 0 : info.memType == 'corner' ? 1 : 2];
        o.setBg(pal[ipal], false);
      }
    }
  }
}
function updateCreatedBindings(sCreated, R) {
  for (const oid in sCreated) {
    R.addObject(oid, o);
    for (const sp in R.getSpec()) {
    }
    for (const upd of sCreated[oid]) {
      let ukind = upd.ukind;
      if (ukind == 'valueChange') {
        let propUpdated = upd.prop;
        let skeys = R.getR(oid);
        let akku = [];
        recCollect(R.ROOT, x => { return x.oid == oid }, akku, true);
        for (const n of akku) {
          updateNode(n, upd, R);
        }
      }
    }
  }
}
function UpdateDOMStats() {
  var scoreText = "Score: " + (domUpdate_score / 100).toFixed(2);
  if (Math.abs(domUpdate_score) > MATE - MAXDEPTH) {
    scoreText = "Score: " + "Mate In " + (MATE - Math.abs(domUpdate_score)) + " moves";
  }
  $("#OrderingOut").text("Ordering: " + domUpdate_ordering + "%");
  $("#DepthOut").text("Depth: " + domUpdate_depth);
  $("#ScoreOut").text(scoreText);
  $("#NodesOut").text("Nodes: " + domUpdate_nodes);
  $("#TimeOut").text("Time: " + (($.now() - srch_start) / 1000).toFixed(1) + "s");
}
function updateGameArea() {
  var x, height, gap, minHeight, maxHeight, minGap, maxGap;
  for (i = 0; i < obstacles.length; i += 1) {
    if (meme.crashWith(obstacles[i])) {
      return;
    }
  }
  myGameArea.clear();
  myGameArea.frameNo += 1;
  if (myGameArea.frameNo == 1 || everyinterval(150)) {
    x = myGameArea.canvas.width;
    minHeight = 20;
    maxHeight = 200;
    height = Math.floor(Math.random() * (maxHeight - minHeight + 1) + minHeight);
    minGap = 50;
    maxGap = 200;
    gap = Math.floor(Math.random() * (maxGap - minGap + 1) + minGap);
    obstacles.push(new component(10, height, 'green', x, 0));
    obstacles.push(new component(10, x - height - gap, 'green', x, height + gap));
  }
  for (i = 0; i < obstacles.length; i += 1) {
    obstacles[i].x += -1;
    obstacles[i].draw();
  }
  score.text = 'SCORE: ' + myGameArea.frameNo;
  score.draw();
  meme.newPos();
  meme.draw();
}
function updateGamename(gamename) {
  currentGamename = gamename;
  let gi = allGames[gamename];
  currentPlayersById = {};
  plidByIndex = gi.player_names;
  for (const plid of gi.player_names) {
    currentPlayersById[plid] = {};
  }
  numPlayersMin = arrMin(gi.num_players);
  numPlayersMax = arrMax(gi.num_players);
}
function updateGamenameUi(id, color) {
  let uiName = 'spGame';
  let ui = mBy(uiName);
  if (nundef(ui)) {
    ui = mEditableOnEdited(uiName, dLineTopMiddle, 'game: ', '', changeGameTo, () => {
      console.log('Games', getGames());
    });
  }
  ui.innerHTML = id;
  mStyleX(ui, { fg: color });
}
function updateGameplayerCardCollections(pid, oPlayer) {
  let msPlayerArea = getPlayerArea(pid);
  for (const propName in oPlayer) {
    let plColls = getCollections(pid, propName);
    if (nundef(plColls)) continue;
    for (const key in plColls) {
      let coll = plColls[key];
      if (!coll.tbd) continue;
      let idCollection = getCollectionArea(key, msPlayerArea);
      showCollection(coll, idCollection);
      coll.tbd = null;
    }
  }
}
async function updateGroupInfo() {
  let syms20 = await route_path_yaml_dict('../assets/speech/syms2020.yaml');
  console.log(syms20);
  console.log(KeySets);
  for (const k in syms20) {
    KeySets.all.push(k);
    KeySets.huge.push(k);
    let info = syms20[k];
    if (isdef(info.ngroup)) {
      for (const n of [25, 50, 100]) {
        if (info.ngroup <= n) KeySets['best' + n].push(k);
      }
    }
    if (info.group != 'smileys-emotion') { KeySets.nemo.push(k); if (isdef(info.ngroup)) KeySets.nemo100.push(k); }
    switch (info.group) {
      case 'object': KeySets.object.push(k); KeySets.object50.push(k); KeySets.objectPlus.push(k); break;
      case 'animal': KeySets.life.push(k); KeySets.life50.push(k); KeySets.lifePlus.push(k); break;
      case 'fruit': KeySets.life.push(k); KeySets.life50.push(k); KeySets.lifePlus.push(k); break;
      case 'food': KeySets.life.push(k); KeySets.life50.push(k); KeySets.lifePlus.push(k); break;
      case 'drink': KeySets.life.push(k); KeySets.life50.push(k); KeySets.lifePlus.push(k); break;
      case 'vegetable': KeySets.life.push(k); KeySets.life50.push(k); KeySets.lifePlus.push(k); break;
      case 'smileys-emotion': KeySets.emo.push(k); break;
      case 'people-body': break;
      default: console.log('forgot group', info.group); break;
    }
  }
  addCatsToKeys();
}
function updateKeySettings(nMin) {
  if (nundef(G)) return;
  G.keys = setKeys({ nMin, lang: Settings.language, keysets: KeySets, key: Settings.vocab });
}
function updateLabelSettings() {
  console.assert(isdef(Score.labels), 'Score not set!!!!!')
  if (Settings.showLabels == 'toggle') Settings.labels = Score.labels == true;
  else Settings.labels = (Settings.showLabels == 'always');
}
function UpdateListsMaterial() {
  var piece, sq, index, colour;
  for (index = 0; index < BRD_SQ_NUM; ++index) {
    sq = index;
    piece = brd_pieces[index];
    if (piece != PIECES.OFFBOARD && piece != PIECES.EMPTY) {
      colour = PieceCol[piece];
      brd_material[colour] += PieceVal[piece];
      brd_pList[PCEINDEX(piece, brd_pceNum[piece])] = sq;
      brd_pceNum[piece]++;
    }
  }
}
function updateLoginHeader() { document.getElementById('hUsername').innerHTML = 'logged in as <b>' + clientData.name + '</b>'; }
function updateNode(n, upd, R) {
  let oid = upd.oid;
  let o = R.getO(upd.oid);
  if (upd.ukind == 'valueChange') {
    let prop = upd.prop;
    let oldval = o[prop];
    o[prop] = upd.newval;
    let f = RUPDATE[n.type];
    if (isdef(f)) {
      let ui = n.ui;
      let data = n.data;
      if (data == '.' + upd.prop) {
        n.content = calcContentFromData(oid, o, n.data, R);
      }
      f(ui, n.content);
    }
  }
}
function updateOutput(R) {
  for (const area of ['spec', 'uiTree', 'rTree', 'oidNodes', 'dicts', 'refsIds']) { //'channelsStatic', 'channelsLive' 
    clearElement(area);
  }
  if (SHOW_SPEC) { presentNodes(R.lastSpec, 'spec'); }
  if (SHOW_UITREE) {
    presentDictTree(R.uiNodes, R.tree.uid, 'uiTree', 'children', R,
      ['children'],
      null,
      ['ui', 'act', 'params', 'defParams', 'cssParams', 'typParams', 'stdParams'],
      { 'max-width': '35%', font: '14px arial' });
  }
  if (SHOW_RTREE) {
    presentDictTree(R.rNodes, R.tree.uid, 'rTree', 'children', R,
      ['children'], null, null, { 'max-width': '35%', font: '14px arial' });
  }
  if (SHOW_OIDNODES) { presentOidNodes(R, 'oidNodes'); }
  if (SHOW_DICTIONARIES) {
    mDictionary(R.rNodesOidKey, { dParent: mBy('dicts'), title: 'rNodesOidKey ' + Object.keys(R.rNodesOidKey).length });
    mDictionary(R.Locations, { dParent: mBy('dicts'), title: 'locations ' + Object.keys(R.Locations).length });
  }
  if (SHOW_IDS_REFS) {
    mDictionary(R.places, { dParent: mBy('refsIds'), title: 'places ' + Object.keys(R.places).length });
    mDictionary(R.refs, { dParent: mBy('refsIds'), title: 'refs ' + Object.keys(R.refs).length });
  }
  if (nundef(R.rNodes)) return;
  let numRTree = Object.keys(R.rNodes).length;
  let numUiNodes = nundef(R.uiNodes) ? 0 : Object.keys(R.uiNodes).length;
  let handCounted = R.ROOT.data;
  console.assert(numRTree == numUiNodes, '!!!FEHLCOUNT!!! #rtree=' + numRTree + ', #uiNodes=' + numUiNodes);
}
function updateOutput_dep(R) {
  for (const area of ['spec', 'uiTree', 'rTree', 'oidNodes', 'dicts']) {
    clearElement(area);
  }
  if (SHOW_SPEC) { presentNodes(R.lastSpec, 'spec'); }
  if (SHOW_UITREE) {
    presentDictTree(R.uiNodes, R.tree.uid, 'uiTree', 'children', R,
      ['children'],
      ['uid', 'adirty', 'type', 'data', 'content', 'uiType', 'oid', 'key', 'boardType'],
      null,
      { 'max-width': '35%', font: '14px arial' });
  }
  if (SHOW_RTREE) {
    presentDictTree(R.rNodes, R.tree.uid, 'rTree', 'children', R,
      ['children'], null, null, { 'max-width': '35%', font: '14px arial' });
  }
  if (SHOW_OIDNODES) { presentOidNodes(R, 'oidNodes'); }
  if (SHOW_DICTIONARIES) {
    mDictionary(R.rNodesOidKey, { dParent: mBy('dicts'), title: 'rNodesOidKey ' + Object.keys(R.rNodesOidKey).length });
    mDictionary(R.Locations, { dParent: mBy('dicts'), title: 'locations ' + Object.keys(R.Locations).length });
  }
  let numRTree = Object.keys(R.rNodes).length;
  let numUiNodes = nundef(R.uiNodes) ? 0 : Object.keys(R.uiNodes).length;
  let handCounted = R.ROOT.data;
  console.assert(numRTree == numUiNodes, '!!!FEHLCOUNT!!! #rtree=' + numRTree + ', #uiNodes=' + numUiNodes);
}
function updatePlayerConfig() {
  let keysPlayerColors = Object.keys(PLAYER_COLORS);
  let iColor = 0;
  for (const id in serverData.players) {
    let pl = serverData.players[id];
    let colorName = isdef(pl.color) ? pl.color : keysPlayerColors[iColor];
    colorName = colorName.toLowerCase();
    let altName = capitalize(colorName);
    let color = isdef(PLAYER_COLORS[colorName]) ? PLAYER_COLORS[colorName] : colorName;
    playerConfig[GAME].players[id].color = color;
    iColor += 1;
  }
}
function updatePlayersForGame() {
  currentNumPlayers = 0;
  for (let i = 1; i <= MAX_PLAYERS_AVAILABLE; i += 1) {
    if (i <= numPlayersMin) { currentNumPlayers += 1; showPlayer(i); checkPlayer(i); makePlayerReadOnly(i); }
    else if (i <= numPlayersMax) { showPlayer(i); uncheckPlayer(i); }
    else { hidePlayer(i); }
  }
}
function updatePlayersForMode() {
  let mode = currentPlaymode;
  let val = 'me';
  let n = MAX_PLAYERS_AVAILABLE;
  for (let i = 1; i <= n; i += 1) {
    let id = getidType(i);
    if (!isVisible(id)) continue;
    if (mode == 'solo') { populateSelect(i, soloTypes, val); val = 'AI regular'; }
    else if (mode == 'hotseat' || mode == 'passplay') { populateSelect(i, soloTypes, val); }
    else {
      populateSelect(i, allPlayerTypes, val);
      val = PLAYER_CONFIG_FOR_MULTIPLAYER.length > i ? PLAYER_CONFIG_FOR_MULTIPLAYER[i] : 'human';
    }
  }
}
function updatePlaymode(mode) {
  currentPlaymode = mode;
  makePlayermodeReadOnly('multiplayer');
}
function updatePreviewImage(dParent, file, sz = 768) {
  const url = URL.createObjectURL(file);
  dParent.innerHTML = `<img src="${url}" height=${sz}/>`;
}
function updatePreviewImages(dParent, files) {
  for (const f of files) {
    let sz = 200;
    let d = mDiv(dParent, { display: 'inline', w: sz, h: sz });
    updatePreviewImage(d, f, sz);
  }
}
function updateSettings() {
  appSpecificSettings();
  for (const k in SettingTypesCommon) {
    if (SettingTypesCommon[k]) {
      lookupSetOverride(U, ['settings', k], Settings[k]);
    } else {
      if (isdef(G.id)) lookupSetOverride(U, ['games', G.id, 'settings', k], Settings[k]);
    }
  }
}
function updateSizes(nuiBoard) {
  let szOrig = nuiBoard.params.sizes.f;
  let szNew = szOrig;
  let cSizeOrig = nuiBoard.params.sizes.c;
  let cSizeNew = cSizeOrig;
  let eSizeOrig = nuiBoard.params.sizes.e;
  let eSizeNew = eSizeOrig;
  if (nundef(nuiBoard.resizeInfo)) nuiBoard.resizeInfo = {};
  if (isdef(nuiBoard.resizeInfo.fields)) {
    szNew = nuiBoard.resizeInfo.fields;
  }
  if (isdef(nuiBoard.resizeInfo.corners)) {
    cSizeNew = nuiBoard.resizeInfo.corners;
  }
  szNew = Math.max(szNew, cSizeNew);
  if (isdef(nuiBoard.resizeInfo.edges)) {
    eSizeNew = nuiBoard.resizeInfo.edges;
  }
  szNew = Math.max(szNew, eSizeNew);
  return { sOrig: { f: szOrig, c: cSizeOrig, e: eSizeOrig }, sNew: { f: szNew, c: cSizeNew, e: eSizeNew } };
}
function updateSpeakmodeSettings() {
  if (Settings.silentMode && Settings.spokenFeedback) Settings.spokenFeedback = false;
}
function updateStartLevelForUser(game, level, msg) {
  lookupSetOverride(U.games, [game, 'startLevel'], level);
  saveUser();
}
async function updateSymbolDict() {
  let snew = await route_path_yaml_dict('../assets/syms.yaml');
  let sold = await route_path_yaml_dict('../assets/symbolDict.yaml');
  let soldlc = {};
  for (const k in sold) {
    let klc = k.toLowerCase();
    let o = soldlc[klc] = sold[k];
    o.key = klc;
  }
  for (const k in snew) {
    if (nundef(soldlc[k])) {
      soldlc[k] = snew[k];
      console.log('new key added to symbolDict', k)
    } else {
      let onew = snew[k];
      let oold = soldlc[k];
      if (onew.type != oold.type) {
        soldlc[k] = onew;
        console.log('symbolDict key updated', k)
      }
    }
  }
  downloadAsYaml(soldlc, 'symbolDict_upd');
}
async function updateSymbolDictFromDictionaries() {
  [EdDict, DeDict] = await loadGerman();
  let ekeys = Object.keys(EdDict);
  let lowerEKeys = ekeys.map(x => x.toLowerCase());
  console.log('dict e=>d', ekeys);
  ensureSymByType();
  let keys = symKeysByType['icon'];
  console.log('keys', keys);
  let inter = intersection(keys, lowerEKeys);
  console.log('intersection:', inter);
  for (const k of inter) {
    let entry = lookup(EdDict, [k, 'd']);
    if (nundef(entry)) {
      console.log('gibt es nicht!', k)
    } else {
      console.log('entry', entry)
      console.log('JA!', k, entry.join('|'));
      symbolDict[k].D = entry.join('|').toLowerCase();
      symbolDict[k].E = k;
    }
  }
  downloadAsYaml(symbolDict, 'symbolDict');
}
function updateTableCardCollections() {
  let msTableArea = getTabletopCardsArea();
  for (const oid in collections) {
    if (nundef(G.table[oid])) continue;
    let o = G.table[oid];
    for (const propName in o) {
      let colls = getCollections(oid, propName);
      if (nundef(colls)) continue;
      for (const key in colls) {
        let coll = colls[key];
        if (!coll.tbd) continue;
        let idCollection = getCollectionArea(key, msTableArea);
        showCollection(coll, idCollection);
        coll.tbd = null;
      }
    }
  }
}
function updateTableCardCollections_COPY(oid) {
  if (nundef(collections[oid])) return;
  let msArea = getTabletopCardsArea();
  if (isEmpty(collections)) {
    return;
  }
  for (const propName of G.tableUpdated[oid].summary) {
    let o = G.table[propName];
    let plColl = getTableCollections(oid, propName);
    if (isdef(plColl)) {
      for (const key in plColl) {
        let ha = plColl[key];
        let idCollection = getCollectionArea(key, msArea);
        let divHand = UIS[idCollection].elem;
        divHand.style.position = null;
        getSimpleSetElements(ha.hand)
        showPlayerHandNew(ha.name, ha.arr, key);
      }
    }
  }
}
function updateTablenameUi(id, color) {
  let uiName = 'spTable';
  let ui = mBy(uiName);
  if (nundef(ui)) {
    ui = mEditableOnEdited(uiName, dLineTopRight, 'table: ', '', changeTableTo, () => {
      console.log('Tables', getTables());
    });
  }
  ui.innerHTML = id;
  mStyleX(ui, { fg: color });
}
function updateTestInput(index) {
  let elem = mBy('iTestCase');
  if (isdef(elem)) {
    elem.max = Object.keys(testEngine.specs).length - 1;
    elem.min = 0;
    elem.value = index;
  }
}
function updateTimeSettings() {
  let timeElem = mBy('time');
  if (Settings.showTime) { show(timeElem); startTime(timeElem); }
  else hide(timeElem);
}
function updateTooltipContent(oid) {
  let pool = findPool(oid);
  let o = pool[oid];
  ttTitle(oid, o);
  ttBody(oid, o);
}
function updateTooltipContent_hallo(id) {
  let oid = getOidForMainId(id);
  let pool = findPool(id);
  let o = pool[id];
  console.log('tt', id, oid, o)
  return;
  ttTitle(id, o);
  ttBody(id, o);
}
function updateUsernameUi(id, color) {
  let uiName = 'spUser';
  let ui = mBy(uiName);
  if (nundef(ui)) {
    ui = mEditableOnEdited(uiName, dLineTopLeft, 'user: ', '', changeUserTo, () => {
      console.log('Users', getUsers());
    });
  }
  ui.innerHTML = id;
  mStyleX(ui, { fg: color });
}
function updateUserScore() {
  if (nundef(Score.nTotal) || Score.nTotal <= 0) return;
  let sc = { nTotal: Score.nTotal, nCorrect: Score.nCorrect, nCorrect1: Score.nCorrect1, nWins: Score.nWins, nLoses: Score.nLoses, nTied: Score.nTied };
  let g = G.id;
  let recOld = lookupSet(U, ['games', g], { startLevel: 0, nTotal: 0, nCorrect: 0, nCorrect1: 0, nWins: 0, nLoses: 0, nTied: 0 });
  let recSession = lookupSet(U, ['session', g], { startLevel: 0, nTotal: 0, nCorrect: 0, nCorrect1: 0, nWins: 0, nLoses: 0, nTied: 0 });
  addByKey(sc, recSession);
  let counts = DB.games[g].controllerType == 'solo' ? recSession.nWins : recSession.nCorrect;
  recSession.percentage = Math.round(100 * counts / recSession.nTotal);
  addByKey(sc, recOld);
  counts = DB.games[g].controllerType == 'solo' ? recOld.nWins : recOld.nCorrect;
  recOld.percentage = Math.round(100 * recOld.nCorrect / recOld.nTotal);
  Score.nTotal = Score.nCorrect = Score.nCorrect1 = 0;
  saveUser();
}
function upgradeToSimpleGraph(g, dParent, styles = {}) {
  g.id = nundef(dParent.id) ? getUID() : dParent.id;
  let styleDict = {
    node: { 'width': 25, 'height': 25, 'background-color': 'red', "color": "#fff", 'label': 'data(id)', "text-valign": "center", "text-halign": "center", },
    edge: { 'width': 2, 'line-color': 'silver', 'curve-style': 'haystack', },
    'node.highlight': { 'background-color': 'yellow' },
    'node.trans': { 'opacity': '0.5' },
  }
  for (const ks of ['node', 'edge', 'node.highlight', 'node.trans']) {
    if (isdef(styles[ks])) {
      for (const k in styles[ks]) {
        let [prop, val] = translateToCssStyle(k, styles[ks][k], false);
        styleDict[ks][prop] = val;
      }
    }
  }
  let cyStyle = [];
  for (const k in styleDict) { cyStyle.push({ selector: k, style: styleDict[k] }); }
  let size = getSize(dParent);
  let d1 = mDiv(dParent, { position: 'relative', bg: 'green', w: size.w - 80, left: 40, top: 0, h: size.h, align: 'left' });
  g.cy.mount(d1);
  g.cy.style(cyStyle);
  g.enablePanZoom();
  iAdd(g, { div: dParent, dCy: d1 });
}
function uploadImgData(imgFile) {
  let pack = {};
  let data = imgFile.data;
  let filename = imgFile.name; console.log('filename', filename);
  let key = stringBefore(filename, '.');
  pack[key] = { data: data, name: key, filename: filename, type: 'imageData' };
  Socket.emit('generalImages', { pack: pack });
  console.log('uploading pack', pack);
}
function user_already_loaded(name) { return isdef(name && name == Session.cur_user); }
function userUpdate(proplist, val) {
  lookupSetOverride(U, proplist, val);
  saveUser();
}
function useSymbolElemNO(key = 'Treff', h = 50, x = 0, y = 0) {
  return mCreateFrom(`<use xlink:href="#${key}" height="${h}" x="${x}" y="${y}"></use>`);
}
function utter(text, r = .5, p = .8, v = .5, voiceDesc, callback = null) {
  let [voiceKey, voice] = findSuitableVoice(text, voiceDesc);
  utterance.text = sepWords(text, voiceKey);
  utterance.rate = r;
  utterance.pitch = p;
  utterance.volume = v;
  utterance.voice = voice;
  utterance.onend = callback;
  synth.onend
  if (isdef(timeout2)) { clearTimeout(timeout2); }
  timeout2 = setTimeout(() => {
    if (!isINTERRUPT) {
      isSpeakerRunning = true;
    }
    synth.speak(utterance); focus(mBy(defaultFocusElement));
  }, 200);
}
function valf() {
  for (const arg of arguments) if (isdef(arg)) return arg;
  return null;
}
function valfi() {
  for (const arg of arguments) {
    if (isdef(arg)) return arg;
  }
  return null;
}
function valnwhite() {
  for (const arg of arguments) if (isdef(arg) && !isEmptyOrWhiteSpace(arg)) return arg;
  return null;
}
function valToString(n) { if (isFractionType(n)) return getTextForFractionX(n.n, n.d); else return n; }
function valueOfElement(id) {
  return document.getElementById(id).value;
}
function verify_min_req() {
  let [fen, uplayer] = [Z.fen, Z.uplayer];
  let pl = fen.players[uplayer];
  let jsorted = jsCopy(pl.journeys).sort((a, b) => b.length - a.length);
  let di = {
    '3': jsorted.length > 0 && is_group(jsorted[0]) && jsorted[0].length >= 3,
    '33': jsorted.length > 1 && is_group(jsorted[0]) && jsorted[0].length >= 3
      && is_group(jsorted[1]) && jsorted[1].length >= 3,
    '4': jsorted.length > 0 && is_group(jsorted[0]) && jsorted[0].length >= 4,
    '44': jsorted.length > 1 && is_group(jsorted[0]) && jsorted[0].length >= 4
      && is_group(jsorted[1]) && jsorted[1].length >= 4,
    '5': jsorted.length > 0 && is_group(jsorted[0]) && jsorted[0].length >= 5,
    '55': jsorted.length > 1 && is_group(jsorted[0]) && jsorted[0].length >= 5
      && is_group(jsorted[1]) && jsorted[1].length >= 5,
    '7R': jsorted.length > 0 && is_sequence(jsorted[0]) && jsorted[0].length >= 7,
  };
  let goals = is_fixed_goal() ? [get_round_goal()] : get_available_goals(uplayer);
  for (const g of goals) {
    if (di[g] == true) { return true; }
  }
  return false;
}
function verify_unit_test(otree) {
  if (isdef(DA.verify) && ITER == DA.iter_verify) {
    TestRunning = false;
    let res = DA.verify(otree);
    console.log('***UNIT TEST ' + TestNumber, res ? 'passed...' : 'FAILED!!!!!!!!!!!!!!!!');
    console.assert(res, '*** STOP TEST FAIL ***')
    if (TestSuiteRunning) test_engine_run_next(TestList);
  }
  return true;
}
async function verifySequence(indexFrom, indexTo, saveOnCompleted = false) {
  show('btnStop');
  console.log('______________ verify from', indexFrom, 'to', indexTo, 'save', saveOnCompleted);
  testEngine.autosave = true;
  clearElement(mBy('table'));
  let series = testEngine.series;
  let maxIndex = indexTo;
  let index = indexFrom;
  await testEngine.loadTestCase(series, index);
  await rParse(RSG_SOURCE, { defs: testEngine.defs, spec: testEngine.spec, sdata: testEngine.sdata });
  setTimeout(async () => { await verNext(series, index + 1, maxIndex, saveOnCompleted); }, 1000);
}
async function verNext(series, index, maxIndex, saveOnCompleted = false) {
  await testEngine.loadTestCase(series, index);
  await rParse(RSG_SOURCE, { defs: testEngine.defs, spec: testEngine.spec, sdata: testEngine.sdata });
  let timeOUT = 500;
  if (index < maxIndex && !STOP) setTimeout(async () => { await verNext(series, index + 1, maxIndex, saveOnCompleted); }, timeOUT);
  else {
    isTraceOn = SHOW_TRACE;
    STOP = false;
    hide('btnStop');
    if (saveOnCompleted) saveSolutions(series, testEngine.Dict[series].solutions);
  }
}
function visNumber(n, dParent, color, or = 'h', asNumber = [0]) {
  if (!isNumber(n) || asNumber.includes(n)) return zText('' + n, dParent, { fg: 'white', fz: 64 });
  return _visualizeNumber(n, dParent, color, or);
}
function visOperation(op, a, b, dParent, symResult) {
  switch (op) {
    case 'plus':
    case 'minus': return _visualizeAritOp(op, a, b, dParent, symResult); break;
    case 'mult': return _visualizeMult(a, b, dParent, symResult); break;
  }
}
function visOperator(s, dParent, styles = { fg: 'white', fz: 64 }) {
  zText(s, dParent, styles);
}
function visual(shape, { ipal, fill, x, y, w, h, sPoints, border, thickness, rounding, path, txt, fz, sz }, overlay = true, draw = true) {
  let ms = new MS(uid(), 'g');
  let options = {};
  if (ipal) fill = getpal(ipal);
  if (fill) options.fill = fill;
  if (x) options.x = x;
  if (y) options.y = y;
  if (w) options.w = w;
  if (h) options.h = h;
  if (txt) options.txt = txt;
  if (fz) options.fz = fz;
  if (sz) options.sz = sz;
  if (sPoints) options.sPoints = sPoints;
  if (border) options.border = border;
  if (thickness) options.thickness = thickness;
  if (rounding) options.rounding = rounding;
  if (path) options.path = './assets/images/transpng/' + path + '.png';
  switch (shape) {
    case 'circle':
      ms.circle(options);
      break;
    case 'hex':
      ms.hex(options);
      break;
    case 'rect':
      ms.rect(options);
      break;
    case 'poly':
      ms.poly(options);
      break;
    case 'image':
      ms.image(options);
      break;
    case 'text':
      ms.text(options);
      break;
    default:
      return null;
  }
  if (overlay) {
    overlayOptions = jsCopy(options);
    overlayOptions.className = 'overlay';
    delete overlayOptions.fill;
    delete overlayOptions.path;
    switch (shape) {
      case 'circle':
        ms.circle(overlayOptions);
        break;
      case 'hex':
        ms.hex(overlayOptions);
        break;
      case 'rect':
        ms.rect(overlayOptions);
        break;
      case 'poly':
        ms.poly(overlayOptions);
        break;
      case 'image':
        ms.rect(overlayOptions);
        break;
      case 'text':
        ms.text(overlayOptions);
        break;
      default:
        return null;
    }
  }
  if (draw) ms.draw();
  return ms;
}
function visualAttributeSetter(c) {
  let props = 'innerHTML onclick';
  for (const k of props.split(' ')) {
    propertyGiver(c, k, x => c.visual[k] = x, () => c.visual[k]);
  }
}
function visualPropertySetter(c) {
  let props = 'bg fg h w background color height width rounding padding fz font align';
  for (const k of props.split(' ')) {
    propertyGiver(c, k,
      x => { let styles = {}; styles[k] = x; mStyle(c.visual, styles); },
      () => { return mGetStyle(c.visual, k); }
    );
  }
}
function waitForLogin() {
  initDom();
  openTabTesting('Seattle');
}
async function wegMitwh() {
  let syms = await route_path_yaml_dict('../assets/syms.yaml');
  let newSyms = {};
  for (const k in syms) {
    let info = jsCopy(syms[k]);
    info.w = info.w[0];
    info.h = info.h[0];
    newSyms[k] = info;
  }
  downloadAsYaml(newSyms, 'syms');
}
function weiter_process_inspect() {
  let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
  let item = A.items[A.selected[0]];
  let uibuilding = A.uibuilding = item.o;
  let fenbuilding = A.fenbuilding = lookup(fen, uibuilding.path.split('.'));
  let key = uibuilding.keycard.key;
  let cards = uibuilding.items;
  let schweine_cand = [];
  for (let i = 1; i < cards.length; i++) {
    if (fenbuilding.schweine.includes(i)) continue;
    let card = cards[i];
    if (card.key == key) continue;
    assertion(i == card.index, 'wrong card index!!!!')
    schweine_cand.push(card);
  }
  if (schweine_cand.length > 1) {
    Z.stage = 38;
    ari_pre_action();
  } else if (schweine_cand.length == 1) {
    setTimeout(() => turn_new_schwein_up(schweine_cand[0], fenbuilding, uibuilding), 3000);
  } else if (isEmpty(fenbuilding.schweine)) {
    Z.stage = 29;
    ari_history_list([`${uplayer} inspects a correct building`], 'inspect');
    show_instruction('the building is CORRECT - You loose 1 rumor')
    setTimeout(ari_pre_action, 2000);
  } else {
    let rumor = fen.deck_rumors[0]; fen.deck_rumors.shift();
    fen.players[uplayer].rumors.push(rumor);
    show_instruction('no additional schwein has been found - you gain 1 rumor')
    ari_history_list([`${uplayer} inspects a schweine!`], 'inspect');
    setTimeout(ari_next_action, 2000);
  }
}
function whenSoundPaused() {
  _sndPlayer = null;
  _sndPlayerIdle = true;
  _loaded = false;
  if (!isEmpty(_qSound)) { _deqSound(); } else { _idleSound = true; }
}
function where(o) {
  let fname = getFunctionsNameThatCalledThisFunction();
}
function whichGame(callback) { let route = '/game/info'; _sendRouteJS(route, callback); }
function whoAmI() {
  let gc = S.gameConfig;
  return { username: USERNAME, playerOnTurn: G.player, myPlayers: [S.gameConfi] }
}
function wise() {
  function state_info(dParent) { return; }
  function setup(players, options) {
    let fen = { players: {}, plorder: jsCopy(players), history: [], num: options.num };
    let starter = fen.starter = fen.plorder[0];
    Sayings = shuffle(Sayings);
    fen.index = 0;
    fen.saying = Sayings[fen.index];
    for (const plname of players) {
      let pl = fen.players[plname] = {
        score: 0,
        name: plname,
        color: get_user_color(plname),
      };
    }
    [fen.phase, fen.stage, fen.step, fen.turn] = ['one', 'write', 0, jsCopy(fen.plorder)];
    return fen;
  }
  function check_gameover() {
    let winners = [];
    for (const plname of Z.plorder) {
      let cond = get_player_score(plname) >= Z.options.winning_score;
      if (cond) { winners.push(plname); }
    }
    if (!isEmpty(winners)) Z.fen.winners = winners;
    return isEmpty(winners) ? false : Z.fen.winners;
  }
  function post_collect() { agmove_resolve(); }
  return { post_collect, state_info, setup, present: wise_present, check_gameover, activate_ui: wise_activate };
}
function wise_activate() {
  let [pldata, stage, A, fen, phase, uplayer] = [Z.playerdata, Z.stage, Z.A, Z.fen, Z.phase, Z.uplayer];
  let donelist = Z.playerdata.filter(x => isDict(x.state));
  let complete = donelist.length == Z.plorder.length;
  let resolvable = uplayer == fen.starter && complete;
  let waiting = !resolvable && isdef(donelist.find(x => x.name == uplayer));
  console.log(uplayer, stage, 'done', donelist, 'complete', complete, 'waiting', waiting);
  Z.isWaiting = false;
  if (waiting) {
    mDiv(dTable, {}, null, 'WAITING FOR PLAYERS TO COMPLETE....');
    if (complete) {
      Z.turn = [fen.starter];
      if (Z.mode != 'multi') take_turn_waiting();
    }
    Z.isWaiting = true;
    autopoll();
  } else if (stage == 'write' && resolvable) {
    assertion(uplayer == fen.starter, 'NOT THE STARTER WHO COMPLETES THE STAGE!!!')
    let start = fen.saying.start.toLowerCase();
    let sentences = [];
    for (const pldata of Z.playerdata) {
      let plname = pldata.name;
      let text = start + ' ' + pldata.state.text;
      sentences.push({ plname: plname, text: text.toLowerCase() });
    }
    sentences.push({ plname: '', text: start + ' ' + fen.saying.end.toLowerCase() });
    fen.sentences = shuffle(sentences);
    Z.turn = jsCopy(Z.plorder);
    Z.stage = 'select';
    take_turn_fen_clear();
  } else if (stage == 'write') {
    let d = mCreate('form');
    let dt = dTable;
    mAppend(dt, d);
    d.autocomplete = "off";
    d.action = "javascript:void(0);";
    mDiv(d, { fz: 20 }, 'dForm', fen.saying.start.toLowerCase() + '...');
    Z.form = d;
    mLinebreak(d, 10);
    mInput(d, { wmin: 600 }, 'i_end', 'enter ending');
    d.onsubmit = wise_submit_text;
  } else if (stage == 'select' && resolvable) {
    assertion(uplayer == fen.starter, 'NOT THE STARTER WHO COMPLETES THE STAGE!!!')
    let d = mDiv(dTable, {});
    fen.result = {};
    for (const pldata of Z.playerdata) {
      let selecting = pldata.name;
      let selected = pldata.state.plname;
      let text = pldata.state.text;
      if (isEmpty(selected)) {
        console.log('REINGEGANGEN!!!!!!!!!!!!!!')
        fen.players[selecting].score += 1;
        selected = 'correct';
      } else if (selecting != selected) {
        fen.players[selected].score += 1;
      }
      fen.result[selecting] = { plname: selected, text: text };
    }
    delete fen.sentences;
    Z.turn = jsCopy(Z.plorder);
    Z.stage = 'round';
    take_turn_fen_clear();
  } else if (stage == 'select') {
    let d = mDiv(dTable, {});
    let i = 1;
    for (const s of fen.sentences) {
      let d1 = mDiv(d, { fz: 20, hline: 30 }, `dsent_${s.plname}`, '' + (i++) + ') ' + s.text, 'hop1');
      d1.onclick = wise_select_sentence;
    }
  } else if (stage == 'round' && resolvable) {
    assertion(uplayer == fen.starter, 'NOT THE STARTER WHO COMPLETES THE STAGE!!!')
    delete fen.result;
    Z.turn = jsCopy(Z.plorder);
    fen.index++;
    fen.saying = Sayings[fen.index];
    Z.stage = 'write';
    take_turn_fen_clear();
  } else if (stage == 'round') {
    let d = mDiv(dTable, {});
    for (const plname in fen.result) {
      let o = fen.result[plname];
      let d1 = mDiv(d, { fz: 20, hline: 30 }, null, `${plname} selected ${o.plname}: ${o.text}`);
    }
    mLinebreak(dTable, 12)
    mButton('WEITER', wise_onclick_weiter, dTable, {}, ['donebutton', 'enabled']);
  } else {
    console.log('Z', Z)
    alert('PROBLEM!!!')
  }
}
function wise_onclick_weiter() {
  Z.state = { plname: Z.uplayer };
  take_turn_multi();
}
function wise_present(dParent) {
  let [fen, ui, stage, uplayer] = [Z.fen, UI, Z.stage, Z.uplayer];
  let [dOben, dOpenTable, dMiddle, dRechts] = tableLayoutMR(dParent, 1, 0);
  let dt = dTable = dOpenTable; clearElement(dt); mCenterFlex(dt);
  wise_stats(dt);
  mLinebreak(dt, 10);
}
function wise_select_sentence(ev) {
  if (!uiActivated) return;
  let text = ev.target.innerHTML;
  let plname = stringAfter(ev.target.id, 'dsent_')
  Z.state = { plname: plname, text: text };
  take_turn_multi();
}
function wise_stats(d) {
  let players = Z.fen.players;
  let d1 = mDiv(d, { display: 'flex', 'justify-content': 'center', 'align-items': 'space-evenly' });
  for (const plname of get_present_order()) {
    let pl = players[plname];
    let onturn = Z.turn.includes(plname);
    let sz = 50;
    let bcolor = plname == Z.uplayer ? 'lime' : 'silver';
    let border = pl.playmode == 'bot' ? `double 5px ${bcolor}` : `solid 5px ${bcolor}`;
    let rounding = pl.playmode == 'bot' ? '0px' : '50%';
    let d2 = mDiv(d1, { margin: 4, align: 'center' }, null, `<img src='../base/assets/images/${plname}.jpg' style="border-radius:${rounding};display:block;border:${border};box-sizing:border-box" class='img_person' width=${sz} height=${sz}>${get_player_score(plname)}`);
  }
}
function wise_submit_text(ev) { ev.preventDefault(); let text = mBy('i_end').value; Z.state = { text: text }; take_turn_multi(); }
function without(arr, elementToRemove) {
  return arr.filter(function (el) {
    return el !== elementToRemove;
  });
}
function wlog() {
  let s = '';
  for (const a of arguments) {
    s += a + ' ';
  }
  console.log(s);
}
function wordCorrectionFactor(text, styles, w, h, fz) {
  styles.fz = fz;
  let size = getSizeWithStyles(text, styles);
  let hFactor = 1; let wFactor = 1;
  if (size.h > h - 1) { hFactor = size.h / h; }
  if (size.w > w - 1) { wFactor = size.w / w; }
  if (size.w < w && size.h < h) return 0;
  else return Math.max(hFactor, wFactor);
}
function wordsFromToText(i, n = 300) {
  let list = [];
  for (const k in symbolDict) {
    let info = symbolDict[k];
    if (nundef(info.bestE) || !isString(info.bestE) || info.bestE.length < 2) continue;
    addIf(list, info.bestE);
  }
  let sfromi = arrFromIndex(list, i);
  s300 = arrTake(sfromi, n);
  let s = s300.join('\n');
  console.log(s);
  downloadTextFile(s, 'words_' + i);
}
function wordsOfLanguage(key, language) {
  let y = symbolDict[key];
  let w = y[language];
  let wlist = w.split('|');
  return wlist.map(x => x.trim());
}
function worldMap(loc) {
  let html =
    `<div id="map_area" class="grid_div" style="width:340px;height:220px;background-color:rgba(86, 182, 222);">
      <svg width="100%" height="100%" viewBox="0 0 3400 2200" style="box-sizing:border-box;">
        <g id="mapG" >
          <image id="imgMap" href="/assets/tnt/TTmap.jpg" />
        </g>
      </svg>
    </div>`;
  let d = mBy(loc);
  d.innerHTML = html;
}
function wrapLayoutColarr(num) {
  const arr = [[0], [1], [2], [1, 2], [2, 2], [2, 3], [3, 3], [2, 3, 2], [2, 3, 3], [3, 3, 3], [3, 4, 3], [3, 4, 4], [4, 4, 4]];
  return num < arr.length ? arr[num] : [num];
}
function wrapLayoutPosition(nBoard, tile, R) {
  let margin = 2;
  let uids = tile.children;
  let colarr = wrapLayoutColarr(uids.length);
  let rows = colarr.length;
  let iNode = 0;
  let nChild = R.uiNodes[uids[0]];
  let size0 = R.uiNodes[uids[0]].size;
  let wChild = getBounds(nChild.ui).width;
  let xOffset = nBoard.size.w / 2 + tile.pos.x - size0.w / 2;
  let yOffset = nBoard.size.h / 2 + tile.pos.y - size0.h / 2;
  let x = 0;
  let y = 0;
  let dx = size0.w + margin;
  let dy = size0.h + margin;
  for (let r = 0; r < rows; r++) {
    x = 0;
    y = r * dy - (rows * dy - dy) / 2;
    let wrow = colarr[r] * dx - dx;
    for (let c = 0; c < colarr[r]; c++) {
      let robber = R.uiNodes[uids[iNode]];
      let ui = robber.ui;
      ui.style.position = 'absolute';
      ui.style.display = 'inline-block';
      ui.style.boxSizing = 'border-box'
      let xPos = x + xOffset - wrow / 2;
      let yPos = y + yOffset;
      robber.pos = { x: xPos, y: yPos };
      ui.style.left = xPos + 'px';
      ui.style.top = yPos + 'px';
      ui.style.margin = '0px';
      x += dx;
      iNode += 1;
    }
  }
}
function wrapLayoutSizeNeeded(uids, R) {
  const arr = [[0], [1], [2], [1, 2], [2, 2], [2, 3], [3, 3], [2, 3, 2], [2, 3, 3], [3, 3, 3], [3, 4, 3], [3, 4, 4], [4, 4, 4]];
  let colarr = wrapLayoutColarr(uids.length);
  let rows = colarr.length;
  let iNode = 0;
  let wmax = 0;
  let maxNumPerRow = 0;
  let htot = 0;
  for (let r = 0; r < rows; r++) {
    let hmax = 0;
    let wtot = 0;
    for (let c = 0; c < colarr[r]; c++) {
      let n = R.uiNodes[uids[iNode]];
      let h = n.size.h;
      let w = n.size.w;
      hmax = Math.max(hmax, h);
      wtot += w;
      maxNumPerRow = Math.max(maxNumPerRow, c);
    }
    wmax = Math.max(wmax, wtot);
    htot += hmax;
  }
  let margin = 2;
  let wNeeded = wmax + margin * (maxNumPerRow + 1);
  let hNeeded = htot + margin * (rows + 1);
  return { w: wNeeded, h: hNeeded };
}
function write() { if (verbose) console.log(...arguments); }
function writeComments(pre) {
  console.log('NEEEEEEEEEEEEEEEEEEEEIIIIIIIIIIIIIIIIIN', getFunctionsNameThatCalledThisFunction())
  if (ROUND_OUTPUT) {
    console.log('...' + currentGame.substring(1), pre + ' currentLevel:' + currentLevel, 'pics:' + NumPics,
      'labels:' + NumLabels,
      '\nkeys:' + currentKeys.length, 'minlen:' + MinWordLength, 'maxlen:' + MaxWordLength, 'trials#:' + MaxNumTrials);
  }
}
function writeExp() { }
function writeSound() { return; console.log('calling playSound'); }
function yesNo() { return tossCoin(50); }
function yPics(ifs, options) {
  let keys = choose(SymKeys, n);
  console.log(keys)
  showPicsS(keys);
}
function yRandomPic(ifs, options) {
}
function zoom(factor) {
  bodyZoom = factor;
  if (Math.abs(bodyZoom - 1) < .2) bodyZoom = 1;
  document.body.style.transformOrigin = '0% 0%';
  document.body.style.transform = 'scale(' + bodyZoom + ')';
  localStorage.setItem('bodyZoom', bodyZoom);
}
function zoom_on_resize(referenceDivId) {
  if (!window.onresize) {
    window.onresize = () => {
      let newBrowserZoom = Math.round(window.devicePixelRatio * 100);
      if (isdef(browserZoom) && browserZoom != newBrowserZoom) { browserZoom = newBrowserZoom; return; }
      if (nundef(browserZoom) || browserZoom == newBrowserZoom) {
        let wNeeded = document.getElementById(referenceDivId).getBoundingClientRect().width;
        let wNeededReally = wNeeded / bodyZoom;
        let wHave = window.innerWidth;
        let zn = wHave / wNeeded;
        let znr = wHave / wNeededReally;
        if (Math.abs(znr - bodyZoom) > .01) zoom(znr);
      }
      browserZoom = newBrowserZoom;
    };
  }
}
function zoom_on_wheel_alt() {
  if (!window.onwheel) {
    window.addEventListener("wheel", ev => {
      if (!ev.altKey || ev.ctrlKey) return;
      ev.preventDefault();
      if (ev.deltaY > 0) { zoomOut(); } else if (ev.deltaY < 0) zoomIn();
    }, { passive: false });
  }
}
function zoomBy(x) { if (nundef(bodyZoom)) bodyZoom = 1; zoom(bodyZoom * x); }
function zoomIn() { zoomBy(1.5); }
function zoomOut() { zoomBy(.7); }
function zPicS(item, dParent, styles = {}) {
  let w = styles.w, h = styles.h, padding = styles.padding, hpadding = styles.hpadding, wpadding = styles.wpadding;
  if (isdef(styles.sz)) {
    if (nundef(w)) w = styles.sz;
    if (nundef(h)) h = styles.sz;
  }
  let stylesNew = jsCopy(styles);
  if (isdef(w)) {
    if (isdef(padding)) { w -= 2 * padding; }
    else if (isdef(wpadding)) { w -= 2 * wpadding; }
    stylesNew.w = w;
  }
  if (isdef(h)) {
    if (isdef(padding)) { h -= 2 * padding; }
    else if (isdef(hpadding)) { h -= 2 * hpadding; }
    stylesNew.h = h;
  }
  return _zPicS(item, dParent, stylesNew);
}
function zRepeatEachItem(items, repeat, shufflePositions = false) {
  let orig = items;
  let itRepeat = items;
  for (let i = 1; i < repeat; i++) { itRepeat = itRepeat.concat(orig.map(x => registeredItemCopy(x))); }
  if (shufflePositions) { shuffle(itRepeat); }
  let labelRepeat = {};
  let idx = 0;
  for (const item of itRepeat) {
    let iRepeat = labelRepeat[item.label];
    if (nundef(iRepeat)) iRepeat = 1; else iRepeat += 1;
    item.iRepeat = iRepeat;
    item.index = idx; idx += 1;
    labelRepeat[item.label] = iRepeat;
  }
  return itRepeat;
}
function zRepeatInColorEachItem(items, colorKeys) {
  let itColors = [];
  for (let i = 0; i < colorKeys.length; i++) {
    let newItems;
    if (i > 0) { newItems = jsCopy(items); newItems.map(x => registerAsNewItem(x)); }
    else newItems = items;
    itColors = itColors.concat(newItems);
  }
  for (let i = 0; i < colorKeys.length; i++) {
    let colorKey = colorKeys[i];
    let textShadowColor = ColorDict[colorKey].c;
    for (let j = 0; j < items.length; j++) {
      let index = i * items.length + j;
      let x = itColors[index];
      x.index = index;
      x.textShadowColor = textShadowColor;
      x.color = ColorDict[colorKey];
      x.colorKey = colorKey;
    }
  }
  return itColors;
}
function zText(text, dParent, textStyles, hText, vCenter = false) {
  let tSize = getSizeWithStyles(text, textStyles);
  let extra = 0, lines = 1;
  if (isdef(hText)) {
    extra = hText - tSize.h;
    if (textStyles.fz) lines = Math.floor(tSize.h / textStyles.fz);
  }
  let dText = isdef(text) ? mText(text, dParent, textStyles) : mDiv(dParent);
  if (extra > 0 && vCenter) {
    dText.style.paddingTop = (extra / 2) + 'px';
    dText.style.paddingBottom = (extra / 2) + 'px';
  }
  return { text: text, div: dText, extra: extra, lines: lines, h: tSize.h, w: tSize.w, fz: textStyles.fz };
}
