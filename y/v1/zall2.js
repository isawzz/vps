
function test07_menu_sidebar_div() {
	let dMain = mBy('dMain');
	mStyleX(dMain, { h: '100%', w: '100%', box: true, bg: 'silver', padding: 10 });
	setRect(dMain);
	let item = iMenuSidebarDiv(dMain, options);
	let dover = mDover(dMain, { bg: 'red', alpha: .25 });
	setTimeout(() => iDelete(item.live.sidebar), 5000)
}

function test08() {
	document.body.style.height = '100vh';
	let div1 = addDivToBody(100, 50, '%', 'blue');
	let div2 = addDivToBody(100, 50, '%', 'green');
	var deck1 = makeDeck({ kind: 'deck52', N: 30, nJokers: 5 });
	let ms1 = new DeckMS('deck1', deck1);
	ms1.attachTo(div1);
	let cells = addGridTo(div2, 2, 2, '10px');
	let d = cells[0][1];
	clearElement(d);
	var deck2 = makeDeck({ kind: 'deck52', N: 30, nJokers: 5 });
	let ms2 = new DeckMS('deck2', deck2);
	ms2.attachTo(d);
}

function test08_WTF() {
	let d = mBy('dMain');
	let menu = iMenuLine(d, { bg: 'dark' });
	console.log('iDiv', iDiv(menu));
	let title = mText('hello!', iDiv(menu), { fz: 30 });
}

function test09() {
	document.body.style.height = '100vh';
	let div1 = addDivToBody(100, 50, '%', 'blue');
	let div2 = addDivToBody(100, 50, '%', 'green');
	let rows1 = 3;
	let cols1 = 3;
	let cells = addGridTo(div2, rows1, cols1, '10px');
	console.log(cells);
	for (let i = 0; i < rows1; i++) {
		for (let j = 0; j < cols1; j++) {
			let cell = cells[i][j];
			clearElement(cell);
			let mobj = new DeckMS('d' + rows1 + '_' + cols1, makeDeck({ kind: 'deck52', N: 30, nJokers: 5 }));
			mobj.attachTo(cell);
			enableFlipForDeck(mobj.o);
			enableDragForDeck(mobj.o);
		}
	}
}

function test09_WTF_das_ist_ambra() {
	let comp = qPageMST(mBy('dMain'), qOptions());
	ex00_sidebar(comp.sidebar);
}

function test09_WTF_start() {
	ex01_table(comp.dContent);
	mCenterFlex(dTable);
	let tileStyles1 = { bg: 'pink', w: 300, h: 300, margin: 20 };
	let [rows, cols] = [5, 5];
	for (let r = 0; r < rows; r++) {
		for (let c = 0; c < cols; c++) {
			let d1 = mDiv(dTable, tileStyles1);
			if (coin()) iMenuSidebarDiv(d1, qOptions());
		}
		mGap(dTable, 0);
	}
}

function test1(map) {
	var baseballIcon = L.icon({
		iconUrl: '../leaf94/baseball-marker.png',
		iconSize: [32, 37],
		iconAnchor: [16, 37],
		popupAnchor: [0, -28]
	});
	function onEachFeature(feature, layer) {
		var popupContent = '<p>I started out as a GeoJSON ' +
			feature.geometry.type + ', but now I\'m a Leaflet vector!</p>';
		if (feature.properties && feature.properties.popupContent) {
			popupContent += feature.properties.popupContent;
		}
		layer.bindPopup(popupContent);
	}
	/* global campus, bicycleRental, freeBus, coorsField */
	var bicycleRentalLayer = L.geoJSON([bicycleRental, campus], {
		style: function (feature) {
			return feature.properties && feature.properties.style;
		},
		onEachFeature: onEachFeature,
		pointToLayer: function (feature, latlng) {
			return L.circleMarker(latlng, {
				radius: 8,
				fillColor: '#ff7800',
				color: '#000',
				weight: 1,
				opacity: 1,
				fillOpacity: 0.8
			});
		}
	}).addTo(map);
	var freeBusLayer = L.geoJSON(freeBus, {
		filter: function (feature, layer) {
			if (feature.properties) {
				return feature.properties.underConstruction !== undefined ? !feature.properties.underConstruction : true;
			}
			return false;
		},
		onEachFeature: onEachFeature
	}).addTo(map);
	var coorsLayer = L.geoJSON(coorsField, {
		pointToLayer: function (feature, latlng) {
			return L.marker(latlng, { icon: baseballIcon });
		},
		onEachFeature: onEachFeature
	}).addTo(map);
}

function test1_3colHeaderFooter() {
	var dMain = document.getElementById('dMain');
	let dHeader = mDiv(dMain, { bg: '#ABC', hmin: 150 }, 'dHeader', 'header');
	let dOuter = mDiv(dMain, { bg: '#678', hmin: 500, display: 'flex', 'flex-flow': 'row wrap' }, 'dOuter');
	let dLeft = mDiv(dOuter, { bg: 'random', flex: '0 0 200px' }, 'dLeft', 'left');
	let dMiddle = mDiv(dOuter, { bg: 'random', flex: '1 0 auto' }, 'dMiddle', 'middle');
	let dRight = mDiv(dOuter, { bg: 'random', flex: '0 0 200px' }, 'dRight', 'right');
	let dFooter = mDiv(dMain, { bg: '#456', hmin: 100 }, 'dFooter', 'footer');
}

function test1_ari_10cards(otree) {
	let n = 10;
	let list = choose(get_keys(Aristocards), n);
	let items = list.map(x => ari_get_card(x));
	let cont = ui_make_deck_container(n, dTable, { bg: 'random', padding: 4 });
	let topmost = ui_add_cards_to_deck_container(cont, items, list);
	iDiv(topmost).onclick = () => anim_toggle_face(topmost);
}

function test1_basic() {
	var map = L.map('map');
	L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
		attribution: 'Â© OpenStreetMap contributors'
	}).addTo(map);
	console.log('geo', Geo)
	let [p1, p2] = [Geo.places.tuerkenschanzpark, Geo.places.vegagasse];
	map.setView(p1, 16)
	M = L.Routing.control({
		waypoints: [
			L.latLng(p1[0], p1[1]),
			L.latLng(p2[0], p2[1])
		],
		routeWhileDragging: true
	}).addTo(map);
}

function test1_bw_widget_boa() {
	let dpop = mBy('dPopup');
	show(dpop);
	mStyle(dpop, { top: 50, right: 10 });
	let prefix = 'boa';
	let d = mDiv(dpop, { wmin: 200, hmin: 200, bg: 'red' }, 'dBw');
	let d2 = mDiv(d, { bg: 'dodgerblue', fg: 'white' }, null, 'your bitwarden vault');
	let d3 = mDiv(d, { bg: '#eee', fg: 'dimgray', padding: 8 }, null, 'LOGINS');
	let d4 = mDiv(d, { bg: 'white', fg: 'black' });
	let d5 = mDiv(d4, { display: 'flex' });
	let dimg = mDiv(d5, { bg: 'white', fg: 'black' }, null, `<img src='../rechnung/images/boa.png' height=14 style="margin:8px">`);
	let dtext = mDiv(d5, { cursor: 'pointer' }, null, `<div>boa</div><div style="font-size:12px;color:gray">gleeb69</div>`);
	dtext.onclick = () => onclick_bw_symbol(prefix)
	let d6 = mDiv(d4, { display: 'flex', padding: 2 });
	let disyms = {
		bwtext: { postfix: 'userid', matop: 2, maright: 0, mabottom: 0, maleft: 0, sz: 27 },
		bwcross: { postfix: 'cross', matop: 2, maright: 0, mabottom: 0, maleft: -13, sz: 25 },
		bwkey: { postfix: 'pwd', matop: 0, maright: 0, mabottom: 0, maleft: -12, sz: 27 },
		bwclock: { postfix: 'clock', matop: 0, maright: 0, mabottom: 0, maleft: 0, sz: 25 },
	}
	for (const k of ['bwtext', 'bwcross', 'bwkey']) {
		let o = disyms[k];
		let [filename, styles] = [k, disyms[k]];
		let path = `../rechnung/images/${filename}.png`;
		let [sz, ma] = [styles.sz, `${styles.matop}px ${styles.maright}px ${styles.mabottom}px ${styles.maleft}px`];
		console.log('ma', ma);
		let img = mDiv(d6, { paright: 16 }, null, `<img src='${path}' height=${sz} style="margin:${ma}">`);
		if (k != 'bwcross') {
			mStyle(img, { cursor: 'pointer' });
			img.onclick = () => onclick_bw_symbol(prefix, o.postfix);
		}
	}
	mFlexSpacebetween(d4);
	let d7 = mDiv(d, { bg: '#eee', fg: 'dimgray', padding: 7 }, null, 'CARDS');
	let d8 = mDiv(d, { bg: 'dodgerblue', fg: 'white' }, null, `<img src='../rechnung/images/rest_bw.jpg'>`);
}

async function test1_can_I_get_new_cities(min = 25000) {
	let info = await route_path_yaml_dict('../base/assets/lists/info.yaml');
	let text = await route_path_text('../base/mapdata/cities.csv');
	let cities = M.cities = csv2list(text);
	let capitals = [];
	let new_cities = {};
	let num = 0;
	for (const o of cities) {
		let n = o.population;
		if (nundef(n)) continue;
		n = Number(n);
		if (n < min) continue;
		let w1 = o.city_ascii.toLowerCase();
		if (nundef(o.country)) {
			console.log('missing country', o);
			continue;
		}
		num += 1;
		let land1 = o.country.toLowerCase();
		for (const k of info.capital) {
			let w = k.toLowerCase();
			if (w.includes(w1) && w.includes(land1)) {
				capitals.push(o);
				o.capital = 'capital';
			}
			let name = o.name = o.city_ascii;
			if (isdef(new_cities[name]) && new_cities[name].includes('capital')) continue;
			new_cities[name] = `${o.lng},${o.lat},${o.country},${o.capital},${o.population}`;
		}
	}
	downloadAsYaml(new_cities, 'cities');
	return new_cities;
}

function test1_car_math() {
	C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc', null, true);
	C.add({ w: 30, h: 25, color: 'red', draw: draw_car, update: update_car, turn_inc: 10, v: { a: 280, mag: 5 } });
	C.add({ x: 30, y: -100, color: 'green', w: 35, h: 25, draw: draw_car, update: update_car, v: { a: 0, mag: 3 } });
	C.draw();
}

function test1_change_user() {
	setTimeout(() => {
		mStyle(mBy('user_info'), { opacity: 0 });
		setTimeout(() => {
			let name = chooseRandom(get_user_names(), x => x != Session.cur_user);
			load_user(name);
		}, 1000);
	}, 2000)
}

function test1_maxBounds() { let m1 = create_map({ zoom: 0 }); }

function test1_nerd() {
	test0_nerd();
	let fi = nerdamer(`integrate(custom(x),x)`).buildFunction();
	let y = fi(100);
	console.log('fi(100)', y)
}

function test1_open_sidebar() {
	mBy('b_test').onclick = open_sidebar;
}

function test1_p5_init() {
	dTable = mBy('dTable'); mCenterFlex(dTable);
	let o = mCanvas(dTable, { w: 600, h: 400 }, {}, startloop, pauseloop, 'cc');
	iAdd(o, {}, { draw: draw_random_walk });
}

function test1_show_users() {
	show_users();
}

function test10() {
	console.log('codebase list', list);
	let text = list.map(x => x.text).join('\n');
	let funcnames = list[0].di.func;
	let txt =
		`if (this && typeof module == "object" && module.exports && this === module.exports) {\r\n`
		+ `  module.exports = {\r\n`;
	for (const fname of funcnames) {
		txt += `    ${fname},\r\n`
	};
	txt += '  }\r\n}';
	DA.text = txt;
}

function test10_0() {
	lookupSet(DA, ['svgsym', suit, color], html);
	let color = 'orange';
	let treff = `
  <path  d="M30 150C35 385 85 400 130 500L-130 500C-85 400 -35 385 -30 150A10 10 0 0 0 -50 150A210 210 0 1 1 -124 -51A10 10 0 0 0 -110 -65A230 230 0 1 1 110 -65A10 10 0 0 0 124 -51A210 210 0 1 1 50 150A10 10 0 0 0 30 150Z"  fill="${color}"></path>
  `;
	let idsym = getUID('x');
	let sym = `
  <symbol id="Treff" viewBox="-600 -600 1200 1200" preserveAspectRatio="xMinYMid">
  `
}

function test10_autocomplete() {
	let map = M.map = create_map({ zoom: 16 });
	map.on('moveend', function (e) { calc_map_dims(); console.log("dims", M.dims); });
	let tb = M.toolbar = create_toolbar(map);
	mButton('Dummy', dummy_reaction, tb);
	mAutocomplete(tb);
}

function test10_function() {
	C = new Plotter(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc');
	let canvas = C.cv;
	C.add({ astep: .1, a: 0, bstep: .1, b: 0, func: x => Math.sin(x), update: test10_update });
}

function test10_queen_html() {
	let htmlWORKS = `
    <svg
      xmlns="http://www.w3.org/2000/svg"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      face="QS"
      height="100%"
      preserveAspectRatio="none"
      viewBox="-120 -168 240 336"
      width="100%"
      fill="#ffff00"
      stroke="green"
      >
      <defs><rect id="XSQ" width="164.8" height="260.8" x="-82.4" y="-130.4"></rect></defs>
      <symbol id="VSQ" viewBox="-500 -500 1000 1000" preserveAspectRatio="xMinYMid">
        <path
          d="M-260 100C40 100 -40 460 260 460M-175 0L-175 -285A175 175 0 0 1 175 -285L175 285A175 175 0 0 1 -175 285Z"
          stroke="green"
          stroke-width="80"
          stroke-linecap="square"
          stroke-miterlimit="1.5"
          fill="none"
        ></path>
      </symbol>
      <symbol id="SSQ" viewBox="-600 -600 1200 1200" preserveAspectRatio="xMinYMid">
        <path
          d="M0 -500C100 -250 355 -100 355 185A150 150 0 0 1 55 185A10 10 0 0 0 35 185C35 385 85 400 130 500L-130 500C-85 400 -35 385 -35 185A10 10 0 0 0 -55 185A150 150 0 0 1 -355 185C-355 -100 -100 -250 0 -500Z"
          fill="green"
        ></path>
      </symbol>
      <symbol id="SQ1" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="green"
          d="M635.39648,0 851.86719,312.33789C895.10685,299.11869 938.83136,290.34833 975,285 924.90197,188.22401 899.89439,94.153799 874.11133,0ZM295.52539,27.285156C246.27551,180.9799 142.75435,335.54042 209.25195,483.08398l-17.43359,13.44922c1.76531,151.10099 30.08527,286.57163 74.54102,398.60938 18.12594,21.287 38.56227,42.11564 61.47851,64.11523 3.61128,3.46683 7.28461,6.96262 11.33789,10.61914L901.47852,970l-0.41407,-0.51953c-0.12219,-0.138 -0.23745,-0.27418 -0.35937,-0.41211 15.27725,17.28278 32.6506,35.12574 52.3164,53.54294C1030.1434,1094.8366 1080,1150 1130,1250c52.9819,-70.6425 98.186,-110.0972 170,-152.7871v-37.6016c-68.6196,39.3343 -116.9422,76.6549 -164.5547,131.9668 -44.9491,-77.8482 -93.9175,-130.6069 -160.20897,-192.68943 -76.05982,-71.23062 -114.27421,-131.59148 -129.3711,-180.42578 -15.09688,-48.8343 -8.90849,-86.60287 7.94922,-120.96875 28.31708,-57.72677 91.51367,-102.35489 139.07032,-133.86328l-26.7793,-21.49024C896.53697,588.11019 793.22595,665.67487 806.10938,786.48828L699.86133,787.5 568.0625,939.89258 429.48438,939.86328C578.06034,763.29892 745.82856,594.02803 899.1875,455.09961l-9.56836,-10.99023c-28.86687,-3.02061 -55.64392,-10.37642 -80.51758,-21.42774 -1.77605,4.17261 -4.43372,8.02096 -7.94336,11.23438C665.11643,558.39566 525.46983,665.166 419.78906,829.43164L392.45703,811.84766C501.69344,642.05529 644.58723,533.12674 779.21875,409.9375l17.51367,6.86328c-17.74437,-8.98707 -34.48695,-19.8921 -50.29101,-32.48437 -124.71285,29.03155 -208.27492,36.48099 -267.26758,31.98242 0,0 -19.31641,14.60547 -29.31641,14.60547 -15,0 -25.58008,-5.64453 -30.58008,-5.64453 -5,0 -10,5 -25,5 -15,0 -30,-25 -40,-50 -1.51422,-2.01895 -3.01443,-4.07919 -4.23242,-5.79297l-39.21875,30.25586 10.50977,-0.54493c7.17244,138.45299 -1.25836,281.23598 43.02929,408.13477l-27.41796,17.66602c-1.32891,-2.13106 -2.43311,-4.45616 -3.26758,-6.95704C288.22851,692.7888 295.29422,552.70428 289.59766,421.09961l-69.70313,53.77344 20.20508,-16.59375C187.08454,297.85994 265.54029,182.85491 300.0957,58.960938ZM85,80c-55.000004,50 -100.000004,145 -35,145 9.343263,0 15.215964,-5.70961 19.599609,-15.58984l-0.05469,54.80664C63.116922,255.80043 55.218717,250 45,250c-34.999996,0 -39.999996,70 -5,70 24.46345,0 22.957588,-43.08208 10.8125,-44.93164 53.48157,5.0855 -15.809214,250.16385 -15.302734,296.2207 0.268193,24.38822 6.628431,48.73678 31.46289,56.20899C48.176742,632.49354 35,645.1697 35,660 35,674.30844 47.265656,686.61054 65.384766,692.25586 41.674751,699.57565 35,720.74035 35,740 35,776.24391 48.1356,836.13212 55.517578,866.33008 82.604368,846.54619 106.08392,825.42866 128.83984,800.21875 132.14826,778.91478 135,756.88968 135,740 135,720.60063 128.2285,699.26867 104.15234,691.95898 118.02756,686.75065 129.28173,676.58841 135,660c0,-14.83344 -13.18185,-27.51102 -30.78711,-32.89844 24.05654,-8.65812 30.01787,-32.21714 30.27734,-55.8125C134.99671,525.23221 65.705931,280.15386 119.1875,275.06836 107.04241,276.91792 105.53655,320 130,320c35,0 30,-70 -5,-70 -10.83425,0 -19.06007,6.52154 -25.074219,15.02148L100.25195,209.2793C104.49041,218.99863 110.42097,225 120,225 185,225 140,130 85,80Zm641.48047,287.83789c-86.62544,19.83455 -151.78802,28.17022 -200.80469,29.24219 -14.2248,6.27415 -30.07191,11.92239 -45.7793,18.95898 58.99266,4.49857 142.55438,-2.95118 267.19727,-32.03711 -7.7527,-5.20716 -14.38853,-10.76914 -20.61328,-16.16406zm-370.49024,88.29102c29.62693,11.74538 64.9141,21.55877 110.0293,25.15039 51.3028,4.08421 115.55629,0.48608 200.56445,-14.4043C568.01187,553.99998 468.15967,644.25595 384.25,765.71289 359.23837,670.90747 359.53927,564.67648 355.99023,456.12891ZM1182.5,473.75c-24.0403,0 -48.0562,17.34722 -29.8594,52.02344A45,42.5 0 0 1 1182.5,515a45,42.5 0 0 1 29.8652,10.76367C1230.552,491.09427 1206.538,473.75 1182.5,473.75Zm-54.6914,47.48047c-45.2477,0.77462 -37.6424,97.7377 22.793,66.2168A45,42.5 0 0 1 1137.5,557.5a45,42.5 0 0 1 13.1113,-29.94336c-8.6891,-4.53343 -16.2978,-6.43753 -22.8027,-6.32617zm109.3828,0c-6.5027,-0.11132 -14.1076,1.79222 -22.793,6.32226A45,42.5 0 0 1 1227.5,557.5a45,42.5 0 0 1 -13.1094,29.94336c60.4429,31.53409 68.0505,-65.43824 22.8008,-66.21289zm-24.8301,67.99414A45,42.5 0 0 1 1182.5,600 45,42.5 0 0 1 1152.6348,589.23633c-11.9875,22.85174 -5.6311,38.16959 6.9726,45.95898 -23.6821,34.46419 -48.941,66.02584 -74.9492,96.20703C1079.1653,675.69528 1058.4509,645.45798 1005,670c37.225,16.12754 38.5709,70.31699 75.9492,65.69727 -5.8664,6.76063 -11.768,13.45662 -17.6972,20.10156l15.207,1.88672c7.2551,-8.19076 14.4623,-16.46748 21.6113,-24.85352 5.1929,39.08146 35.0698,-7.57452 67.2129,-5.5 -16.4802,-41.743 -32.0495,-10.50502 -66.4785,4.63672 24.5708,-28.86629 48.4073,-59.08334 70.8027,-91.95508 26.5679,6.12811 61.7407,-10.79807 40.7539,-50.78906zM1255,655c-32.9633,38.74398 -63.8666,77.97963 -125,110 16.8191,30.21345 26.6544,60.2083 30,90 47.2312,18.32372 82.8871,51.83723 115,90 2.3419,-37.0436 -4.2974,-71.38724 -30,-100 23.3498,-4.99857 40.0029,-20.01884 50,-45 -14.5281,-24.40208 -35.9759,-32.69918 -60,-35 44.8752,-32.16719 30.2665,-71.33926 20,-110zM811.88477,817.78516c10.86486,41.66548 35.34229,88.00659 78.58593,139.42382 -4.92291,-5.82285 -9.66276,-11.58316 -14.2207,-17.2539l-286.46289,-0.0586 64.60547,-0.45703 75.1914,-86.93945 93.88282,-0.33984c-4.9028,-11.9067 -8.74345,-23.39087 -11.58203,-34.375zM377.5,842.5c4.42321,0 9.31831,2.00257 14.86719,9.24023C397.91606,858.97789 402.5,871.0223 402.5,885c0,13.9777 -4.58394,26.0221 -10.13281,33.25977C386.81831,925.49743 381.92321,927.5 377.5,927.5c-4.42321,0 -9.31831,-2.00257 -14.86719,-9.24023C357.08394,911.0221 352.5,898.9777 352.5,885c0,-13.9777 4.58394,-26.02211 10.13281,-33.25977C368.18169,844.50257 373.07679,842.5 377.5,842.5Z"
        ></path>
      </symbol>
      <symbol id="SQ2" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="red"
          d="M557.51758,0 805.9668,330.45703 851.01367,311.99805 635.36719,0Zm78.02148,0 63.76563,90.75C709.99966,65.000167 725,65 725,65 716.50651,26.779299 728.31462,17.104416 733.20117,0ZM820,265 851.86719,312.33789C877.5079,304.49903 903.31958,298.22492 927.6543,293.26562 907.75762,290.72138 885.5191,284.6565 865,270c-10,5 -30,10 -45,-5zm99.12695,216.28711C764.14521,621.01648 595.55342,787.07572 470.35547,940.01172L525,940 685,755h120.41797l-0.0547,-0.41211c6.37431,-102.76161 97.50088,-170.65811 160.41211,-212.22851zm-727.41992,15.5625 -59.86133,46.34766 -0.39648,0.30468c1.93099,12.0459 3.10803,21.69313 3.04101,27.78711 -0.25947,23.59536 -6.2208,47.15438 -30.27734,55.8125C121.81815,632.48898 135,645.16656 135,660 129.28173,676.58841 118.02756,686.75065 104.15234,691.95898 128.2285,699.26867 135,720.60063 135,740c0,16.88968 -2.85174,38.91478 -6.16016,60.21875 -1.95154,2.162 -3.90854,4.29257 -5.87304,6.39453C138.56664,789.96704 153.92711,771.43051 170,750 200.25102,810.50205 230.44886,854.59181 266.85742,895.71484 221.90196,783.10482 193.58426,647.63449 191.70703,496.84961ZM44.53125,610.36133 0,644.61523V902.7832C30.797744,884.46615 56.707359,866.73637 80.427734,846.89844 72.427991,853.57027 64.158102,860.01913 55.517578,866.33008 48.1356,836.13212 35,776.24391 35,740 35,720.74035 41.674751,699.57565 65.384766,692.25586 47.265656,686.61054 35,674.30844 35,660 35,645.1697 48.176742,632.49354 66.972656,627.49805 56.528563,624.35562 49.361734,618.22105 44.53125,610.36133Zm1190.09765,68.79687 -1.1211,1.04688c-20.0542,23.0427 -41.8711,45.665 -71.7441,65.72265 27.117,39.37142 36.6532,80.37363 27.7441,123.12891 25.4392,14.76465 47.2329,33.87001 67.875,55.8418 -10.0896,-28.95393 -26.9566,-68.05217 -64.6191,-89.36328C1229.865,829.72137 1245.3631,819.51581 1260,800c-28.5778,-21.24841 -50.4759,-15.94491 -77.3027,-15.66992 39.149,-21.89578 49.9371,-64.78262 51.9316,-105.17188zM110.74609,819.23828c-0.7889,0.78628 -1.58065,1.56702 -2.37304,2.3457 0.792,-0.77791 1.58362,-1.55961 2.37304,-2.3457zm-5.15234,5.05078c-0.76819,0.74251 -1.53476,1.48679 -2.30664,2.22266 0.77112,-0.73534 1.53841,-1.48017 2.30664,-2.22266zm-5.26172,5.00586c-2.077449,1.94603 -4.165139,3.87648 -6.273436,5.7793 2.104356,-1.90192 4.194747,-3.83083 6.273436,-5.7793zm-6.539061,6.02149c-1.467973,1.32281 -2.945132,2.63598 -4.429688,3.93945 1.482456,-1.30407 2.961518,-2.61456 4.429688,-3.93945zM377.5,862.5a11,22.5 0 0 0 -11,22.5 11,22.5 0 0 0 11,22.5 11,22.5 0 0 0 11,-22.5 11,22.5 0 0 0 -11,-22.5zm225.17578,127.46484a10,10 0 0 0 -10,10 10,10 0 0 0 10,9.99996 10,10 0 0 0 10,-9.99996 10,10 0 0 0 -10,-10zM420,990a10,10 0 0 0 -10,10 10,10 0 0 0 10,10 10,10 0 0 0 10,-10 10,10 0 0 0 -10,-10zm91.13281,0.41016a10,10 0 0 0 -10,10.00004 10,10 0 0 0 10,10 10,10 0 0 0 10,-10 10,10 0 0 0 -10,-10.00004z"
        ></path>
      </symbol>
      <symbol id="SQ3" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="#44F"
          d="M472.5,150a12.5,20 0 0 0 -12.5,20 12.5,20 0 0 0 12.5,20 12.5,20 0 0 0 12.5,-20 12.5,20 0 0 0 -12.5,-20zm-140,5a12.5,20 0 0 0 -12.5,20 12.5,20 0 0 0 12.5,20 12.5,20 0 0 0 12.5,-20 12.5,20 0 0 0 -12.5,-20zm23.49023,301.12891c3.54904,108.54757 3.24814,214.77856 28.25977,309.58398 83.90967,-121.45694 183.76187,-211.71291 282.33398,-298.83789 -85.00816,14.89038 -149.26165,18.48851 -200.56445,14.4043 -45.1152,-3.59162 -80.40237,-13.40501 -110.0293,-25.15039zm42.92579,22.92187c22.57573,0.10326 52.52779,2.34383 83.49804,6.2461 65.74558,8.28415 118.15335,21.65893 117.05469,29.87304 -1.09829,8.2139 -56.30922,5.07893 -122.05273,-3.20508 -65.73948,-8.28354 -117.1185,-18.57868 -116.02735,-26.79296 0.53448,-4.02047 14.07178,-6.22853 37.52735,-6.1211zM1117.5,492.5c2.4011,8.40385 4.2266,18.24941 5.4746,28.84375v0.36133c7.3876,-1.36391 16.4655,0.0837 27.2324,5.62304l-21.2675,-21.26757a1.50015,1.50015 0 0 1 1.0449,-2.57617 1.50015,1.50015 0 0 1 1.0761,0.45507l21.2676,21.26758c-5.5291,-10.74776 -6.9807,-19.81297 -5.6289,-27.19336 -10.7286,-1.24895 -20.7021,-3.08593 -29.1992,-5.51367zm130,0c-8.4251,2.40718 -18.2988,4.23414 -28.9238,5.48242h-0.2793c1.3613,7.38557 -0.087,16.46062 -5.6231,27.22266l21.2657,-21.26563a1.50015,1.50015 0 0 1 1.0312,-0.45312 1.50015,1.50015 0 0 1 1.0898,2.57422l-21.2675,21.26757c10.7565,-5.53399 19.8272,-6.98416 27.2109,-5.62695v-0.17187c1.2486,-10.6649 3.081,-20.57644 5.4961,-29.0293zm-853.59961,15.25781c20.38428,0.10329 47.42876,2.34386 75.39258,6.2461 59.36368,8.28422 106.68388,21.65899 105.69141,29.87304 -0.99271,8.21355 -49.91699,8.15671 -109.27735,-0.12695 -59.36371,-8.28422 -106.68391,-21.659 -105.69141,-29.87305 0.48636,-4.01928 12.70935,-6.22659 33.88477,-6.11914zm7.69531,34.67969c15.09367,-0.0753 32.61454,0.81411 50.47852,2.5625 51.50146,5.04084 94.00823,14.75226 93.67578,23.00391 -0.32891,8.2521 -42.34749,10.85536 -93.84961,5.81445C400.39893,568.77752 358.91755,558.00165 359.25,549.75c0.20345,-5.08688 15.52034,-7.17888 42.3457,-7.3125zm590.81446,21.09375c-26.28817,17.83124 -58.00395,39.71623 -85.84375,65.82227L1063.252,755.79883c5.9292,-6.64494 11.8308,-13.34093 17.6972,-20.10156C1043.5709,740.31699 1042.225,686.12754 1005,670c53.4509,-24.54202 74.1653,5.69528 79.6582,61.40234 18.288,-21.22222 36.2025,-43.13214 53.4609,-66.25 -50.4965,-31.89003 -99.3677,-65.63189 -145.70894,-101.62109zm92.24804,167.87109c-1.2353,1.43353 -2.4703,2.86748 -3.709,4.29493 1.3064,-0.16146 2.6533,-0.388 4.0508,-0.69727 -0.1038,-1.21628 -0.2241,-2.40447 -0.3418,-3.59766zm-21.4062,24.39649 1.3242,1.02344C1092.8236,758.22045 1130,765 1130,765c33.2353,-17.40792 57.5278,-36.95014 78.082,-57.38477 -19.9562,-11.65548 -39.7017,-23.55345 -59.2109,-35.71875 -15.5528,20.88792 -31.6462,40.7815 -48.0664,60.07227 34.429,-15.14174 49.9983,-46.37972 66.4785,-4.63672 -32.1431,-2.07452 -62.02,44.58146 -67.2129,5.5 -7.149,8.38604 -14.3562,16.66276 -21.6113,24.85352zM399.88477,574.98828c12.13924,-0.0753 26.23048,0.81416 40.59765,2.5625 41.42116,5.04089 74.78321,15.81675 74.51563,24.06836 -0.26463,8.25206 -34.05885,10.85531 -75.48047,5.81445 -41.42116,-5.04089 -74.78321,-15.81675 -74.51563,-24.06836 0.16364,-5.08693 13.30756,-8.24338 34.88282,-8.37695zm814.90823,12.6836 21.2675,21.26757a1.50015,1.50015 0 1 1 -2.121,2.1211l-21.2657,-21.26563c5.5369,10.76367 6.9837,19.84044 5.6211,27.22656h0.3223c10.6094,1.24816 20.4685,3.07443 28.8828,5.47852 -2.4278,-8.49731 -4.2627,-18.47029 -5.5117,-29.19922 -7.3807,1.35234 -16.4468,-0.0994 -27.1953,-5.6289zm-64.5879,0.002c-10.7501,5.53028 -19.8161,6.98044 -27.1973,5.62695v0.0723c-1.2488,10.70195 -3.0853,20.64836 -5.5078,29.12695 8.4975,-2.42785 18.4701,-4.26471 29.1992,-5.51367 -1.3518,-7.38039 0.1,-16.44561 5.6289,-27.19336l-21.2676,21.26758a1.50015,1.50015 0 1 1 -2.121,-2.1211zM399.95117,608.2207c7.75591,-0.014 16.33902,0.59569 25.04883,1.7793 30.51033,4.14665 55.19775,16.74619 55.24414,25 0.0491,8.25469 -24.64792,11.5847 -55.16016,7.4375 -30.51033,-4.14665 -55.28173,-14.19933 -55.32812,-22.45312 -0.0324,-5.62262 11.68692,-11.73096 30.19531,-11.76368zm2.94141,36.28321c3.92832,-0.0157 8.00124,0.15115 12.10742,0.49609 25.08573,2.10744 44.77796,7.02839 45.42188,14.97852 0.64298,7.94981 -19.17087,12.68576 -44.25586,10.57812 -25.08573,-2.10744 -45.94398,-10.26081 -46.5879,-18.21094 -0.52278,-6.4668 13.79255,-7.76393 33.31446,-7.84179zm-6.3711,30.78125c1.53788,10e-4 3.10151,0.0612 4.67383,0.17968 15.24356,1.1523 28.12847,7.43255 28.7793,14.02735 0.6519,6.59512 -11.17778,11.00764 -26.42188,9.85547 -15.24356,-1.1523 -28.12847,-7.43255 -28.77929,-14.02735 -0.57317,-5.81151 8.60794,-10.04793 21.74804,-10.03515zm-2.7207,30.4707c0.97501,0.002 1.96625,0.0499 2.96289,0.14453 9.66123,0.91446 17.82809,5.89851 18.24219,11.13281 0.4126,5.23472 -7.08576,8.73687 -16.74805,7.82227 -9.66123,-0.91446 -17.82809,-5.89851 -18.24219,-11.13281 -0.3645,-4.61356 5.45528,-7.97697 13.78516,-7.9668zm906.19922,0.0781 -34.2773,2.85547c0.2249,20.00253 -6.7832,39.15319 -30.7188,56.31055 24.0241,2.30082 45.4719,10.59792 60,35 -9.9971,24.98116 -26.6502,40.00143 -50,45 19.6816,21.91005 28.1768,47.18324 30.0293,74.45312l0.01,0.008 24.957,11.09375zm-167.2656,64.20508c0.2372,0.44647 0.4708,0.89347 0.7051,1.33985 -0.2343,-0.44637 -0.4679,-0.89339 -0.7051,-1.33985zm3.041,5.88282c0.083,0.16606 0.171,0.33199 0.2539,0.49804 -0.083,-0.16604 -0.1705,-0.33202 -0.2539,-0.49804zm2.6758,5.48437c0.2147,0.45253 0.425,0.90499 0.6367,1.35742 -0.2117,-0.45239 -0.4219,-0.90493 -0.6367,-1.35742zm2.455,5.32422c0.1795,0.40036 0.3641,0.80089 0.5411,1.20117 -0.177,-0.40029 -0.3615,-0.80081 -0.5411,-1.20117zm2.5958,5.98437c0.2099,0.50184 0.413,1.00415 0.6191,1.50586 -0.2062,-0.5018 -0.4092,-1.00393 -0.6191,-1.50586zm2.0703,5.11719c0.1975,0.50277 0.4,1.00516 0.5937,1.50781 -0.1937,-0.50252 -0.3962,-1.00516 -0.5937,-1.50781zm2.3418,6.1875c0.1922,0.53072 0.3764,1.06121 0.5644,1.5918 -0.188,-0.53055 -0.3722,-1.06112 -0.5644,-1.5918zm1.7324,4.96485c0.2042,0.60477 0.4106,1.20984 0.6094,1.81445 -0.1988,-0.60461 -0.4051,-1.20971 -0.6094,-1.81445zm2.0273,6.26562c0.1846,0.60177 0.3579,1.20308 0.5371,1.80469 -0.1792,-0.60139 -0.3525,-1.20313 -0.5371,-1.80469zm1.4688,5.00977c0.1799,0.63781 0.3593,1.27644 0.5332,1.91406 -0.174,-0.63786 -0.3532,-1.27602 -0.5332,-1.91406zM377.5,842.5c-4.42321,0 -9.31831,2.00257 -14.86719,9.24023C357.08394,858.97789 352.5,871.0223 352.5,885c0,13.9777 4.58394,26.0221 10.13281,33.25977 5.54888,7.23766 10.44398,9.24023 14.86719,9.24023 4.42321,0 9.31831,-2.00257 14.86719,-9.24023C397.91606,911.0221 402.5,898.9777 402.5,885c0,-13.9777 -4.58394,-26.02211 -10.13281,-33.25977C386.81831,844.50257 381.92321,842.5 377.5,842.5Zm-0.27344,4.79492c2.95574,0.0879 5.94922,5.08008 5.94922,10.70508 10.93128,-0.11104 14.67749,3.31056 5.67578,13 13.69744,3.7436 10.6454,8.69968 2.83789,14 7.80751,5.30032 10.85955,10.2564 -2.83789,14 9.00171,9.68944 5.2555,13.11104 -5.67578,13 0,10 -9.4596,18 -11.35156,0 -10.93128,0.11104 -14.67748,-3.31056 -5.67578,-13 -13.69744,-3.7436 -10.6454,-8.69968 -2.83789,-14 -7.80751,-5.30032 -10.85955,-10.2564 2.83789,-14 -9.0017,-9.68944 -5.2555,-13.11104 5.67578,-13 0.82773,-7.875 3.10344,-10.77344 5.40234,-10.70508zm352.35742,5.20508 -75.1914,86.93945 43.0039,-0.041L744.44531,885H840l-15,-32.5zm29.72266,65 -19.23047,22.23633L876.25,939.95508 860,917.5Zm-104.13476,52.41992 -315.75977,0.17969c2.43984,2.47881 4.98787,4.87423 7.56641,7.28906 15.37025,14.39437 29.32058,28.43253 41.91015,42.12693 1.06974,-4.4442 6.04965,-11.1309 16.11133,-19.5156 -30,-25 -15,-34.99999 15,-15 30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -11.06914,7.3794 -20.08451,10.6644 -25.5625,10.6289 1.31057,1.4627 2.62767,2.9262 3.90625,4.3809l256.41797,-0.1328zm-170.01172,4.44531C490.60938,974.21875 499.75,977.5 511,985c30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -30,20 -45,10 -15,-15 -18.75,-15.625 -19.92188,-25.39063 -10.83984,-25.63477zm91,0C581.60938,974.21875 590.75,977.5 602,985c30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -30,20 -45,10 -15,-15 -18.75,-15.625 -19.92188,-25.39063 -10.83984,-25.63477z"
        ></path>
      </symbol>
      <symbol id="SQ4" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="green"
          d="M499.67383,0C598.83088,212.42554 698.5156,423.78371 891.07812,444.24805L557.50781,0ZM299.89844,59.855469C265.54099,182.85387 187.08454,297.85994 240.09961,458.2793L349.875,372.94531C322.20549,333.64118 300,282.28964 300,255c0,-20 5.00324,-149.9992 5,-155 -10e-4,-2.004308 -2.41143,-19.27436 -5.10156,-40.144531zM899.91016,454.8418C746.55122,593.77022 578.78424,763.04072 429.50781,939.46875l40.84766,0.54297C595.55342,787.07576 764.14431,621.01748 918.95508,481.37891Zm65.79101,87.45703c-28.87179,19.18723 -64.12524,44.12835 -93.97851,75.52344l25.55078,20.04296c30.22964,-29.84438 65.96002,-54.59002 95.59961,-73.97851 -9.28135,-6.87909 -18.47109,-14.10656 -27.17188,-21.58789zM685,755 525.10156,939.88281 570,940 699.86133,787.5H806.65039L805,755Z"
        ></path>
      </symbol>
      <symbol id="SQ5" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          stroke="#44F"
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="6"
          fill="none"
          d="M435,885A57.5,75.000002 0 0 1 377.5,960.00001 57.5,75.000002 0 0 1 320,885 57.5,75.000002 0 0 1 377.5,810 57.5,75.000002 0 0 1 435,885v0M417.07718,940H876.02627M308.27069,940h28.75722M339.49097,970H901.47783M131.84482,543.19629 351.03451,374.58883M6.9310566e-5,644.61533 44.832165,610.1291M1138.1663,665.18229C1077.9926,627.18313 1020.1253,586.55302 965.29601,542.45758M1208.5796,707.90733c-20.1878,-11.78458 -40.1599,-23.81534 -59.8906,-36.12132M557.51806,-3.5577172e-4 965.44559,542.57786M1299.7291,1059.765c-68.4773,39.2778 -116.7334,76.5733 -164.2838,131.8131 -44.9491,-77.8482 -93.9175,-130.6069 -160.20897,-192.68943 -76.05982,-71.23062 -114.27421,-131.59148 -129.3711,-180.42578 -15.09688,-48.8343 -8.90849,-86.60287 7.94922,-120.96875 28.31708,-57.72677 91.51285,-102.35515 139.0695,-133.86354M499.68528,0.03748108C598.83742,212.45251 698.51437,423.77834 890.34164,443.851M364.36489,812.31243C320.07724,685.41364 328.50886,542.63024 321.33642,404.17725c76.71711,39.85219 163.35704,77.44074 457.8821,5.76082C644.587,533.12731 501.69292,642.05444 392.45651,811.84681M355.97656,456.125c29.62956,11.74764 64.92126,21.56216 110.04297,25.1543 51.30556,4.08443 115.56309,0.48617 200.57813,-14.40625 -98.57798,87.12824 -198.39177,177.48156 -282.2461,298.86133 -24.96545,-94.92731 -24.7974,-201.06283 -28.375,-309.60938v0M867.34252,440.4065C719.62961,574.07588 560.4386,730.57461 436.09373,879.43791M223.89186,472.86906c-0.82324,183.16931 37.98603,343.48203 98.11552,466.27071M191.49798,496.71315c2.08648,150.92196 30.40471,286.39171 75.55251,398.73891M429.507,939.46794C578.78343,763.03991 746.55158,593.76963 899.91052,454.84121M470.35494,940.01166C595.55289,787.0757 764.14488,621.01728 918.95565,481.37871M525,940 685,755h120.41872M567.92551,940.0502 699.86133,787.5h106.78892M611.46541,939.39021 714.72266,820h97.2642M654.39213,939.43943 729.58398,852.5h93.89714M697.39662,939.39902 744.44531,885h95.04566M740.07521,939.73575 759.30664,917.5H860M906.39152,629.42293 1063.7852,756.67736M871.92369,617.813 1043.2441,757.01082M459.61865,481.34795C414.86903,573.51288 406.45192,669.62669 385,765M303.65592,-0.00221915C259.09343,162.78907 138.61386,327.07777 209.42337,483.4732M240.09997,458.27954C187.0849,297.86018 265.54056,182.85405 300.09597,58.960082M805.81085,330.134c14.88787,-6.44544 30.42237,-12.16006 46.14865,-17.2138M0.09725143,902.73906C71.866196,860.06685 117.03718,820.61709 170,750c50,100 99.8567,155.1639 176.97865,227.3892 281.56105,263.6842 94.15072,409.6105 -13.08443,480.4695M377.5,842.5c4.42321,0 9.31831,2.00257 14.86719,9.24023C397.91606,858.97789 402.5,871.0223 402.5,885c0,13.9777 -4.58394,26.0221 -10.13281,33.25977C386.81831,925.49743 381.92321,927.5 377.5,927.5c-4.42321,0 -9.31831,-2.00257 -14.86719,-9.24023C357.08394,911.0221 352.5,898.9777 352.5,885c0,-13.9777 4.58394,-26.02211 10.13281,-33.25977C368.18169,844.50257 373.07679,842.5 377.5,842.5v0M1130,765c16.8191,30.21345 26.6544,60.2083 30,90 47.2312,18.32372 82.8871,51.83723 115,90 2.3419,-37.0436 -4.2974,-71.38724 -30,-100 23.3498,-4.99857 40.0029,-20.01884 50,-45 -14.5281,-24.40208 -35.9759,-32.69918 -60,-35 44.8752,-32.16719 30.2665,-71.33926 20,-110 -32.9633,38.74398 -63.8666,77.97963 -125,110v0M1300,705.83334l-34.3239,2.86032M1299.9997,930.55544l-26.1711,-11.63161M1192.7269,836.42558c37.6985,20.41997 54.5672,59.51932 65.2796,89.01033M1182.9686,784.9233c26.555,-0.86899 48.4536,-6.17171 77.0314,15.0767 -14.6369,19.51581 -30.1358,29.72065 -67.2011,34.6433M1234.6287,679.15791c-1.9945,40.38926 -12.7829,83.27561 -52.2037,104.5774M1162.3431,745.42454c26.5383,39.87481 36.0743,80.87688 26.979,123.43436M1130,765c0,0 -82.1675,-15 -95,-5 -12.8325,10 -32.9691,31.30714 -40,40 -31.97044,39.52731 3.64509,49.72935 20,30M1050,800c-59.31161,25.45028 -64.22618,120.61499 20,25M1041.1933,853.52948c-14.9444,32.29436 0.7581,60.30105 58.5,-5.24847M1062.1853,882.59071C1040.9944,921.29246 1103.755,918.14402 1160,855M1063.2524,755.79961c33.572,-37.62441 66.2866,-76.82735 96.4461,-120.73492M1078.4582,757.6865c32.4929,-36.68328 64.0954,-75.00591 93.2554,-117.82589M1085,735c-4.9523,-58.0017 -25.4042,-90.06768 -80,-65 38.526,16.69119 38.6175,74.15849 80,65v0M1005,670c37.8073,-6.25375 56.1399,40.79694 80,65M1100,732.33169c35,-15 50.6726,-47.07119 67.2824,-5 -32.2824,-2.08351 -62.2824,45 -67.2824,5v0M1100.0662,732.84533c26.3257,8.26747 52.4616,-23.9051 67.2162,-5.51364M1155.0001,585.00001C1080.0001,630 1080,484.99999 1155,530c-45,-75 100,-75 55,0 75,-45 75,100 10e-5,55 45,75.00001 -100.0001,74.99999 -55,10e-6v0M1242.5,557.5c-60,0 -60,0 -60,-60 0,60 0,60 -60,60 60,0 60,0 60,60 0,-60 0,-60 60,-60v0M1122.9743,521.34338c-1.248,-10.59434 -3.0726,-20.43952 -5.4737,-28.84337 8.5766,2.45046 18.6544,4.30045 29.4977,5.54996M1146.7554,616.97813c-10.7509,1.24908 -20.7424,3.08971 -29.255,5.52188 2.4225,-8.47859 4.2581,-18.42426 5.5069,-29.12621M1241.9485,592.9857c1.2496,10.84959 3.1002,20.93331 5.5519,29.5143 -8.4143,-2.40409 -18.2735,-4.23021 -28.8829,-5.47837M1218.5761,497.98319c10.625,-1.24828 20.4988,-3.07601 28.9239,-5.48319 -2.4151,8.45286 -4.2469,18.3639 -5.4955,29.0288M357.95908,386.26136c-4.7848,-2.30618 -9.52375,-4.6875 -14.28345,-7.12611M748.06895,383.93902C622.45119,413.08814 538.88863,420.5377 479.79194,417.07826M355.99023,456.12891c29.62693,11.74538 64.9141,21.55877 110.0293,25.15039 51.3028,4.08421 115.55629,0.48608 200.56445,-14.4043C568.01187,553.99998 468.15967,644.25595 384.25,765.71289 359.23837,670.90747 359.53927,564.67648 355.99023,456.12891v0M85,135c10.787262,31.12992 5,90 35,90 65,0 20,-95 -35,-145 -55.000004,50 -100.000004,145 -35,145 30,0 24.21273,-58.87008 35,-90v0M40,285c0,0 0,-10 10,-10 12.88094,0 15,45 -10,45 -34.999996,0 -29.999996,-70 5,-70 30,0 40,50 40,50 0,0 10,-50 40,-50 35,0 40,70 5,70 -25,0 -22.88094,-45 -10,-45 10,0 10,10 10,10M120,275c-55,2.66831 15,250 14.49097,296.289C134.16784,600.67311 125,630 85,630 45,630 35.832163,600.67311 35.509031,571.289 35,525 105,277.66831 50,275M70,264.98358V208.33333M100,265.18883V208.74384M103.20611,627.39263C121.81764,632.48836 135,645.16656 135,660c0,19.32997 -22.38576,35 -50,35 -27.614237,0 -50,-15.67003 -50,-35 0,-14.8303 13.176786,-27.50627 31.782083,-32.60414M65.931232,692.4756C41.674852,699.57662 35,720.74035 35,740c0,36.24391 13.136211,96.133 20.364326,126.34321M128.36935,800.67704C132.14739,778.91407 135,756.88968 135,740c0,-19.39937 -6.77205,-40.73054 -31.46191,-47.67672M256.89224,885h6.38602M1.1417102e-4,884.99999 28.737098,885M245.57157,870h11.90122M2.5229169e-5,870.00002 51.088175,870M233.67034,855h18.57752M4.1609595e-5,854.99999 52.539543,855M222.93022,840h24.09272M7.6084636e-5,840.00001 49.346532,840M212.77064,825h29.89819M4.2336546e-5,825.00002 46.443795,825M203.1916,810h34.54258M4.0905762e-6,810.00002 43.541058,810M194.48339,795h38.89668M129.46208,795h5.22493M-3.8457096e-5,795.00001 40.638321,795M186.06545,780h42.96051M131.78427,780h14.51368M-3.1733115e-5,780.00001 38.316131,780M178.22806,765h46.73407M133.81618,765h24.67327M10,765H36.284215M134.68701,750h86.50156M10,750H34.542573M134.97728,735h83.01828M15,735H35.12312M132.65509,720H205M15,720H37.844594M155,705h45M325,510c-11.82334,-17.57111 -24.45521,-31.94743 -45.42097,-47.16261 -21.67788,-15.73198 -32.01525,9.6364 -23.86278,22.70472M325,540c-13.68399,-15.7169 -40.72661,-39.31758 -62.25684,-51.80699 -20.39713,-11.83211 -26.52283,15.09906 -9.53546,27.99468M326.64903,572.53873c-13.68399,-15.7169 -40.42328,-39.85576 -62.25684,-51.80699 -33.04187,-18.08643 -43.83934,14.15892 -2.74316,31.80699M329.68204,632.14459c-13.68399,-15.7169 -40.42328,-39.85576 -62.25684,-51.80699 -30.81157,-16.86561 -37.65608,16.8659 -5.11631,35.80661M328.06764,597.68777c-13.86078,-13.59047 -33.31597,-27.70524 -50.77313,-39.51278 -22.07438,-14.9305 -34.10496,4.47364 -22.83565,17.22609M332.19576,659.38835c-13.77031,-13.23256 -32.62008,-26.88451 -49.58329,-38.35795 -24.04479,-16.26322 -36.17268,12.27173 -19.25152,25.31598M335.48063,686.60634C319.24375,673.64242 295.51352,659.7442 277.4252,650.3376c-31.2697,-16.26141 -36.88691,20.47944 -3.29829,37.12122M339.44241,709.94356C293.812,671.34406 241.20364,684.64228 285,715M345.57813,743.85785c-49.78299,-42.23381 -140.14002,-42.27022 -51.45386,5.50004M359.15379,797.42734C296.30783,757.35598 217.41506,767.9862 315.25691,808.08817M356.15219,815.71589c-43.41581,-18.1629 -92.79129,0.20988 -43.97099,13.65755M335.79649,833.55074c-36.46249,-11.38361 -55.92576,9.42664 -11.42381,20.21059M323.63736,467.38673c-7.1925,-7.58612 -15.51039,-14.89158 -25.85855,-22.4014 -17.52111,-12.71535 -26.71907,0.32727 -25.12324,12.4885M322.15877,428.22708c-1.31784,-1.00168 -2.67007,-2.00587 -4.05887,-3.01374 -19.41173,-14.0874 -28.60717,3.4419 -24.22651,16.36102M351.5017,769.34668c-41.8286,-32.62324 -87.13007,-22.98664 -57.82646,2.59886M396.50984,805.03398c97.55186,1.04019 65.93584,25.61549 21.19412,25.63392M410.20409,785.71584c31.87867,-11.92022 60.58013,-9.17207 74.95842,-1.62887 16.81695,8.82258 14.04006,24.2047 -26.16419,30.34906M430.54986,757.7319c58.57662,-11.0001 103.69453,13.94896 55.48459,26.1888M451.62343,729.60393c67.42086,-18.09697 125.45489,10.74224 49.42624,33.66324M469.15226,707.61747c69.25339,-23.47062 135.42699,4.47512 67.15155,28.14525M497.03474,675.73394c50.50234,-8.00778 88.6752,9.66559 55.551,28.0217M514.06286,656.56715c77.25396,-19.94453 157.95502,17.262 48.7626,27.75334M550.91529,618.31036c57.1762,-5.00205 100.00874,18.02731 40.2256,35.03407M568.89077,600.93936c75.24789,-19.79781 151.84194,14.60918 51.22446,34.33609M596.84001,574.15634c55.64482,-7.64299 102.46778,11.7471 64.24628,28.76475M620.73761,552.10789c71.56974,-16.51587 140.66537,14.62009 53.45997,34.06378M660.73433,515.56983c57.1151,-4.52529 99.00079,18.87447 36.45506,35.78648M684.38719,494.58861c73.88041,-16.89549 144.8643,16.89901 43.68109,36.08147M722.79564,460.82624c57.76542,-5.50387 101.75016,17.65976 42.02455,34.7974M748.43052,437.7647c68.01755,-11.92015 127.59071,17.4385 43.80212,36.02686M645.55164,273.86211C640.4516,285.47932 635.59316,297.26013 610,295c-14.37233,81.30224 -73.77303,98.38804 -130,120 0,0 -19.41945,15.64589 -29.41945,15.64589C435.58055,430.64589 425,425 420,425c-5,0 -10,5 -25,5 -15,0 -30,-25 -40,-50 -30,-40 -55,-96.04455 -55,-125 0,-20 5.003,-149.9992 5,-155 -0.002,-3.089335 -5.72781,-42.445846 -10.1037,-72.07356M622.93321,240.32144C616.61632,250.552 609.19352,264.74236 615,265c2.73428,0.12132 6.96971,-10.37759 10.24354,-19.90618M904.16018,494.81448l50.56379,54.17549M889.99031,508.2039l48.73454,52.21558M875.34795,521.08709l48.01937,51.44933M861.63691,534.96812l46.15447,49.45122M847.01655,547.87487l45.96336,49.24646M832.83302,561.24966l35.28817,37.80876M818.66315,574.63908l24.02599,25.74214M803.86532,587.3557l17.84203,19.11646M790.06402,601.14003l8.92784,9.56554M482.75862,925h55.41872M495.89491,910h55.00821M508.21018,895h55.82923M521.34647,880h55.41872M534.48276,865h55.41872M552.95566,845H585M790,820v32.5M765,820v32.5M740,820v32.5M703.26765,833.26765l22.578,22.578M684.08867,854.08867l23.39901,23.39901M665.93596,875.93596l22.78325,22.78325M648.19376,898.19376l22.578,22.578M629.22003,919.22003l20.73071,20.73071M791.29599,310.75526c15.62961,-6.29692 31.83381,-11.83473 48.11454,-16.69002M776.15664,290.35133c15.84539,-6.35519 32.2728,-11.93292 48.76488,-16.81275M760.82223,270.4856c16.18061,-6.50419 32.97255,-12.19625 49.8241,-17.16102M746.54814,252.22866c16.42632,-6.7965 33.54246,-12.73644 50.75899,-17.91046M739.12096,229.17409c11.71799,-4.608 23.73402,-8.79725 35.84163,-12.5995M726.54679,208.22774c8.46394,-3.2756 17.07495,-6.33535 25.75602,-9.1911M711.68624,188.33917c5.39484,-2.00758 10.85695,-3.94932 16.37032,-5.82515M900.40882,94.431781C848.5463,114.25376 796.72828,69.769511 761.4322,93.621964 715,125.00001 755,185 789.33498,165.18883 821.13528,146.84017 790,105 775,115c-9.30261,6.20174 -14.88842,18.30946 -10,25 6.18042,8.45885 10.48873,9.62814 20,5M901.46652,97.13303C861.76115,135.4564 879.34663,201.01228 842.74068,222.52055 794.42332,250.91 757.5027,188.96753 790.17065,166.51363c30.25635,-20.79631 54.6061,25.32412 39.1205,34.55428 -9.60379,5.72429 -22.93675,5.55043 -26.86936,-1.74304 -4.972,-9.22111 -4.17161,-13.61293 4.10189,-20.20332M765,180l90,-60M845,160c-10,-10 -45.467,-11.35662 -55,5 22.00764,-11.03808 34.76336,-24.75676 25,-45M795,230c25,30 50,20 75,10 24.05541,32.7653 64.66095,38.66637 105,45M725,130C715,110 740,85 755,75 749.14905,51.948962 757.70702,26.00987 766.59362,0.00490542M700,90c10,-25 25,-25 25,-25 -8.48271,-38.172217 3.28893,-47.867055 8.18679,-64.93099617M427.96416,0.01822477C445.06535,51.748024 483.31343,78.400493 539.31946,83.994433M446.67053,0.04362022C462.63103,38.843647 492.03631,61.699978 533.14043,70.683071M461.24526,0.01603427C475.22521,27.447203 496.92922,45.718691 525.58366,55.74792M476.99588,0.10806452C487.38028,16.453559 500.99836,28.964352 517.63646,37.893813M371.26432,0.04443925C356.34418,40.196712 340.91798,80.075485 304.69652,100.28589M355.60874,0.04353776C343.34293,31.804187 329.13875,61.845937 302.67098,80.298673M339.57059,0.02060224C329.73362,23.196287 317.89132,44.53011 299.71459,59.883794M325.15652,0.08430598C317.46458,14.722402 308.27692,27.964826 296.26758,38.544057M305,120c41.1016,-25.066138 61.56092,-14.28714 80,0 20,55 -15,110 -14.41945,151.6763 0.21559,15.47674 11.72696,13.44856 19.41945,13.3237 4.99934,-0.0811 15,10 15,10M305,125c29.58587,-20.97635 55.47603,-17.50669 80,-5M430,245c20,0 20,30 5,30 -40,5 -40,-10 -5,0M365,315v10l5,-5 -5,-5v0M455,320l5,-5v10l-5,-5v0M370,320c0,0 5,5 10,5 5,0 5.24415,-4.00984 12.32219,-4.4848C400,320 400,325 405,325c5,0 15,-10 20,-10 5,0 15,5 20,5h10M390,340c3.06957,28.45212 45.6136,8.68856 45,5 -5,5 -44.77199,31.85105 -45,-5v0M430,135c51.53607,-36.718861 85.86501,-16.18211 120,5 -35.40475,-25.98218 -85,-45 -120,-5v0M540,160C525,160 503.52953,134.61544 483.61398,136.45137 453.79885,139.1999 445,175 430,180 447.93464,158.59181 463.7944,151.78059 478.07024,151.93493 507.27438,152.25068 515,185 550,175M430,180c15,-10 32.80939,10.04302 45.17423,9.94542C504.08195,189.71723 519.49385,175 530,175M380,175c-20,0 -30.87367,-19.1648 -47.03192,-20.29027 -12.3413,-0.85961 -29.19452,12.61246 -29.19452,17.61246 0,7.07107 11.23734,20.70784 22.74316,23.25836C342.90794,199.21402 362.81244,175.3491 380,175v0M305,165c22.64276,-42.75014 64.95345,-9.49214 65,-5M820,265c15,15 35,10 45,5 20.5191,14.6565 42.75671,20.72048 62.68286,23.22939M851.86653 312.33707C895.10619 299.11787 938.83136 290.34833 975 285C924.90149 188.22308 899.90057 94.152754 874.11725 -0.0019513659 M851.86653,312.33707C895.10619,299.11787 938.83136,290.34833 975,285 924.90149,188.22308 899.90057,94.152754 874.11725,-0.00195137M851.01315,311.99775 635.36748,-2.4089679e-4M927.65339,293.26472C907.75671,290.72048 885.5191,284.6565 865,270c-10,5 -30,10 -45,-5"
        ></path>
      </symbol>
      <symbol id="SQ6" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          stroke="#44F"
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="3"
          fill="none"
          d="M986.60333,811.20184l17.52527,26.83701m3.5763,5.47663 14.2883,21.88014M993.49031,800.86775c12.59499,20.81314 26.36539,39.79428 40.67199,57.93996m3.6811,4.63683c6.0574,7.57938 12.2001,15.02588 18.3803,22.41378m3.5795,4.26824c4.9357,5.87225 9.8895,11.71638 14.8372,17.56998M1002.2895,791.27746c25.6547,42.89167 56.3312,77.95704 86.5273,113.77117M1011.3206,782.24417c26.5981,44.89853 58.7236,81.18275 90.1523,118.55299M1018.2105,775.40469C1045.4382,820.51985 1078.1971,857.01507 1110,895M91.990234,409.08984c5.346491,34.39969 12.364566,69.89746 17.978516,99.54297 5.61395,29.64551 9.60751,54.84672 9.52344,62.49219 -0.14502,13.18721 -2.60383,25.09508 -7.35157,32.2207C107.39289,610.47133 101.33414,615 85,615 68.665861,615 62.607113,610.47133 57.859375,603.3457M95.230469,511.42383c2.783382,14.69817 5.162021,28.28252 6.812501,38.99023 1.65048,10.70771 2.46055,19.51658 2.44922,20.54688 -0.12561,11.42229 -3.03694,21.37127 -4.833987,24.06836 -1.554361,2.33286 -1.96098,2.67133 -3.316406,3.33203C94.986371,599.02203 91.780811,600 85,600M99.244141,641.85938C113.48363,645.75807 120,654.05348 120,660c0,3.87456 -2.13436,8.18273 -8.24609,12.46094C105.64218,676.73915 95.96981,680 85,680 74.030191,680 64.357824,676.73915 58.246094,672.46094M99.476562,706.76367c8.835718,2.48582 12.847888,6.43575 15.929688,11.99805C118.48805,724.32402 120,732.04575 120,740c0,15.20071 -2.70618,36.77501 -6.41016,58.11133M102.94922,660.2832C99.903483,662.33803 92.860098,665 85,665c-7.997241,0 -15.198086,-2.76015 -18.152344,-4.82812M102.28516,726.03125C103.52282,728.2651 105,733.94656 105,740c0,13.42041 -2.56634,34.6744 -6.189453,55.54492M726.75998,368.27894C639.85431,387.67178 574.6926,396.00751 524.83867,397.57475M715.61309,356.58894C649.94086,370.7787 597.12268,378.4618 554.16847,381.63062M703.03893,344.25945c-49.76763,10.38288 -91.8849,16.91189 -127.75629,20.52287M690.7875,331.76901c-38.30305,7.6982 -71.90839,13.04175 -101.50758,16.49148M680.13806,318.87243c-30.03631,5.82677 -57.08899,10.16495 -81.51547,13.25269M670.20516,305.76564c-23.347,4.36958 -44.8345,7.81564 -64.64196,10.45774M659.57286,292.71511c-18.04772,3.23925 -34.94556,5.91034 -50.78275,8.07274M390,380c11.94547,-13.95601 27.22073,-12.69836 45,0M440,195c10,15 30,15 45,15M310,205c50,25 60,-30 70,-30M350.01995,162.05531c1.14299,3.17833 1.7863,6.76631 1.7863,10.56373 0,13.03628 -7.58139,23.60427 -16.9335,23.60427 -9.35211,0 -16.93349,-10.568 -16.93349,-23.60427 0,-5.79795 1.49965,-11.10766 3.98776,-15.21654M488.55832,153.60687c1.90775,3.81995 3.02626,8.46304 3.02626,13.4703 0,13.03628 -7.58139,23.60427 -16.9335,23.60427 -9.35211,0 -16.93349,-10.568 -16.93349,-23.60427 0,-4.03258 0.72545,-7.82898 2.00436,-11.14943"
        ></path>
        <use xlink:href="#SSQ" height="90" transform="translate(1188,935)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1194,1043)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1096,1033)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1022,947)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(918,851)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(897,726)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
      </symbol>
      <rect width="239" height="335" x="-119.5" y="-167.5" rx="12" ry="12" fill="white" stroke="green"></rect>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ1"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ1"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ2"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ2"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ3"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ3"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ4"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ4"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ5"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ5"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ6"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ6"></use>
      <use xlink:href="#VSQ" height="32" x="-114.4" y="-156"></use>
      <use xlink:href="#SSQ" height="26.769" x="-111.784" y="-119"></use>
      <use xlink:href="#SSQ" height="55.68" x="36.088" y="-132.16"></use>
      <g transform="rotate(180)">
        <use xlink:href="#VSQ" height="32" x="-114.4" y="-156"></use>
        <use xlink:href="#SSQ" height="26.769" x="-111.784" y="-119"></use>
        <use xlink:href="#SSQ" height="55.68" x="36.088" y="-132.16"></use>
      </g>
      <use xlink:href="#XSQ" stroke="#44F" fill="none"></use>
    </svg>
    `;
	let d1 = mDiv();
	d1.innerHTML = html;
	mAppend(dTable, d1);
}

function test10_update(canvas, item) {
	let [astep, a, bstep, b, func] = [item.astep, item.a, item.bstep, item.b, item.func];
	canvas.clear();
	[a, astep] = oscillate_between(a, 0, 5, astep);
	[b, bstep] = oscillate_between(b, 0, 5, bstep);
	[item.astep, item.a, item.bstep, item.b] = [astep, a, bstep, b];
	canvas.plot(x => b * func(a * x), "rgb(11,153,11)", 1);
	return false;
}

function test10_verrueckt() {
	let styles = { bg: 'yellow', fg: 'red', border: 'random', thickness: 20, shadow: 'green', rotate: 45, scale: 2 };
	let html = `
      <svg
      xmlns="http://www.w3.org/2000/svg"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      class="card"
      face="QS"
      height="100%"
      preserveAspectRatio="none"
      viewBox="-120 -168 240 336"
      width="100%"
      fill="#ffff00"
      stroke="#ff0000"
      >
      <defs><rect id="XSQ" width="164.8" height="260.8" x="-82.4" y="-130.4"></rect></defs>
      <symbol id="VSQ" viewBox="-500 -500 1000 1000" preserveAspectRatio="xMinYMid">
        <path
          d="M-260 100C40 100 -40 460 260 460M-175 0L-175 -285A175 175 0 0 1 175 -285L175 285A175 175 0 0 1 -175 285Z"
          stroke="black"
          stroke-width="80"
          stroke-linecap="square"
          stroke-miterlimit="1.5"
          fill="none"
        ></path>
      </symbol>
      <symbol id="SSQ" viewBox="-600 -600 1200 1200" preserveAspectRatio="xMinYMid">
        <path
          d="M0 -500C100 -250 355 -100 355 185A150 150 0 0 1 55 185A10 10 0 0 0 35 185C35 385 85 400 130 500L-130 500C-85 400 -35 385 -35 185A10 10 0 0 0 -55 185A150 150 0 0 1 -355 185C-355 -100 -100 -250 0 -500Z"
          fill="black"
        ></path>
      </symbol>
      <symbol id="SQ1" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="#FC4"
          d="M635.39648,0 851.86719,312.33789C895.10685,299.11869 938.83136,290.34833 975,285 924.90197,188.22401 899.89439,94.153799 874.11133,0ZM295.52539,27.285156C246.27551,180.9799 142.75435,335.54042 209.25195,483.08398l-17.43359,13.44922c1.76531,151.10099 30.08527,286.57163 74.54102,398.60938 18.12594,21.287 38.56227,42.11564 61.47851,64.11523 3.61128,3.46683 7.28461,6.96262 11.33789,10.61914L901.47852,970l-0.41407,-0.51953c-0.12219,-0.138 -0.23745,-0.27418 -0.35937,-0.41211 15.27725,17.28278 32.6506,35.12574 52.3164,53.54294C1030.1434,1094.8366 1080,1150 1130,1250c52.9819,-70.6425 98.186,-110.0972 170,-152.7871v-37.6016c-68.6196,39.3343 -116.9422,76.6549 -164.5547,131.9668 -44.9491,-77.8482 -93.9175,-130.6069 -160.20897,-192.68943 -76.05982,-71.23062 -114.27421,-131.59148 -129.3711,-180.42578 -15.09688,-48.8343 -8.90849,-86.60287 7.94922,-120.96875 28.31708,-57.72677 91.51367,-102.35489 139.07032,-133.86328l-26.7793,-21.49024C896.53697,588.11019 793.22595,665.67487 806.10938,786.48828L699.86133,787.5 568.0625,939.89258 429.48438,939.86328C578.06034,763.29892 745.82856,594.02803 899.1875,455.09961l-9.56836,-10.99023c-28.86687,-3.02061 -55.64392,-10.37642 -80.51758,-21.42774 -1.77605,4.17261 -4.43372,8.02096 -7.94336,11.23438C665.11643,558.39566 525.46983,665.166 419.78906,829.43164L392.45703,811.84766C501.69344,642.05529 644.58723,533.12674 779.21875,409.9375l17.51367,6.86328c-17.74437,-8.98707 -34.48695,-19.8921 -50.29101,-32.48437 -124.71285,29.03155 -208.27492,36.48099 -267.26758,31.98242 0,0 -19.31641,14.60547 -29.31641,14.60547 -15,0 -25.58008,-5.64453 -30.58008,-5.64453 -5,0 -10,5 -25,5 -15,0 -30,-25 -40,-50 -1.51422,-2.01895 -3.01443,-4.07919 -4.23242,-5.79297l-39.21875,30.25586 10.50977,-0.54493c7.17244,138.45299 -1.25836,281.23598 43.02929,408.13477l-27.41796,17.66602c-1.32891,-2.13106 -2.43311,-4.45616 -3.26758,-6.95704C288.22851,692.7888 295.29422,552.70428 289.59766,421.09961l-69.70313,53.77344 20.20508,-16.59375C187.08454,297.85994 265.54029,182.85491 300.0957,58.960938ZM85,80c-55.000004,50 -100.000004,145 -35,145 9.343263,0 15.215964,-5.70961 19.599609,-15.58984l-0.05469,54.80664C63.116922,255.80043 55.218717,250 45,250c-34.999996,0 -39.999996,70 -5,70 24.46345,0 22.957588,-43.08208 10.8125,-44.93164 53.48157,5.0855 -15.809214,250.16385 -15.302734,296.2207 0.268193,24.38822 6.628431,48.73678 31.46289,56.20899C48.176742,632.49354 35,645.1697 35,660 35,674.30844 47.265656,686.61054 65.384766,692.25586 41.674751,699.57565 35,720.74035 35,740 35,776.24391 48.1356,836.13212 55.517578,866.33008 82.604368,846.54619 106.08392,825.42866 128.83984,800.21875 132.14826,778.91478 135,756.88968 135,740 135,720.60063 128.2285,699.26867 104.15234,691.95898 118.02756,686.75065 129.28173,676.58841 135,660c0,-14.83344 -13.18185,-27.51102 -30.78711,-32.89844 24.05654,-8.65812 30.01787,-32.21714 30.27734,-55.8125C134.99671,525.23221 65.705931,280.15386 119.1875,275.06836 107.04241,276.91792 105.53655,320 130,320c35,0 30,-70 -5,-70 -10.83425,0 -19.06007,6.52154 -25.074219,15.02148L100.25195,209.2793C104.49041,218.99863 110.42097,225 120,225 185,225 140,130 85,80Zm641.48047,287.83789c-86.62544,19.83455 -151.78802,28.17022 -200.80469,29.24219 -14.2248,6.27415 -30.07191,11.92239 -45.7793,18.95898 58.99266,4.49857 142.55438,-2.95118 267.19727,-32.03711 -7.7527,-5.20716 -14.38853,-10.76914 -20.61328,-16.16406zm-370.49024,88.29102c29.62693,11.74538 64.9141,21.55877 110.0293,25.15039 51.3028,4.08421 115.55629,0.48608 200.56445,-14.4043C568.01187,553.99998 468.15967,644.25595 384.25,765.71289 359.23837,670.90747 359.53927,564.67648 355.99023,456.12891ZM1182.5,473.75c-24.0403,0 -48.0562,17.34722 -29.8594,52.02344A45,42.5 0 0 1 1182.5,515a45,42.5 0 0 1 29.8652,10.76367C1230.552,491.09427 1206.538,473.75 1182.5,473.75Zm-54.6914,47.48047c-45.2477,0.77462 -37.6424,97.7377 22.793,66.2168A45,42.5 0 0 1 1137.5,557.5a45,42.5 0 0 1 13.1113,-29.94336c-8.6891,-4.53343 -16.2978,-6.43753 -22.8027,-6.32617zm109.3828,0c-6.5027,-0.11132 -14.1076,1.79222 -22.793,6.32226A45,42.5 0 0 1 1227.5,557.5a45,42.5 0 0 1 -13.1094,29.94336c60.4429,31.53409 68.0505,-65.43824 22.8008,-66.21289zm-24.8301,67.99414A45,42.5 0 0 1 1182.5,600 45,42.5 0 0 1 1152.6348,589.23633c-11.9875,22.85174 -5.6311,38.16959 6.9726,45.95898 -23.6821,34.46419 -48.941,66.02584 -74.9492,96.20703C1079.1653,675.69528 1058.4509,645.45798 1005,670c37.225,16.12754 38.5709,70.31699 75.9492,65.69727 -5.8664,6.76063 -11.768,13.45662 -17.6972,20.10156l15.207,1.88672c7.2551,-8.19076 14.4623,-16.46748 21.6113,-24.85352 5.1929,39.08146 35.0698,-7.57452 67.2129,-5.5 -16.4802,-41.743 -32.0495,-10.50502 -66.4785,4.63672 24.5708,-28.86629 48.4073,-59.08334 70.8027,-91.95508 26.5679,6.12811 61.7407,-10.79807 40.7539,-50.78906zM1255,655c-32.9633,38.74398 -63.8666,77.97963 -125,110 16.8191,30.21345 26.6544,60.2083 30,90 47.2312,18.32372 82.8871,51.83723 115,90 2.3419,-37.0436 -4.2974,-71.38724 -30,-100 23.3498,-4.99857 40.0029,-20.01884 50,-45 -14.5281,-24.40208 -35.9759,-32.69918 -60,-35 44.8752,-32.16719 30.2665,-71.33926 20,-110zM811.88477,817.78516c10.86486,41.66548 35.34229,88.00659 78.58593,139.42382 -4.92291,-5.82285 -9.66276,-11.58316 -14.2207,-17.2539l-286.46289,-0.0586 64.60547,-0.45703 75.1914,-86.93945 93.88282,-0.33984c-4.9028,-11.9067 -8.74345,-23.39087 -11.58203,-34.375zM377.5,842.5c4.42321,0 9.31831,2.00257 14.86719,9.24023C397.91606,858.97789 402.5,871.0223 402.5,885c0,13.9777 -4.58394,26.0221 -10.13281,33.25977C386.81831,925.49743 381.92321,927.5 377.5,927.5c-4.42321,0 -9.31831,-2.00257 -14.86719,-9.24023C357.08394,911.0221 352.5,898.9777 352.5,885c0,-13.9777 4.58394,-26.02211 10.13281,-33.25977C368.18169,844.50257 373.07679,842.5 377.5,842.5Z"
        ></path>
      </symbol>
      <symbol id="SQ2" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="red"
          d="M557.51758,0 805.9668,330.45703 851.01367,311.99805 635.36719,0Zm78.02148,0 63.76563,90.75C709.99966,65.000167 725,65 725,65 716.50651,26.779299 728.31462,17.104416 733.20117,0ZM820,265 851.86719,312.33789C877.5079,304.49903 903.31958,298.22492 927.6543,293.26562 907.75762,290.72138 885.5191,284.6565 865,270c-10,5 -30,10 -45,-5zm99.12695,216.28711C764.14521,621.01648 595.55342,787.07572 470.35547,940.01172L525,940 685,755h120.41797l-0.0547,-0.41211c6.37431,-102.76161 97.50088,-170.65811 160.41211,-212.22851zm-727.41992,15.5625 -59.86133,46.34766 -0.39648,0.30468c1.93099,12.0459 3.10803,21.69313 3.04101,27.78711 -0.25947,23.59536 -6.2208,47.15438 -30.27734,55.8125C121.81815,632.48898 135,645.16656 135,660 129.28173,676.58841 118.02756,686.75065 104.15234,691.95898 128.2285,699.26867 135,720.60063 135,740c0,16.88968 -2.85174,38.91478 -6.16016,60.21875 -1.95154,2.162 -3.90854,4.29257 -5.87304,6.39453C138.56664,789.96704 153.92711,771.43051 170,750 200.25102,810.50205 230.44886,854.59181 266.85742,895.71484 221.90196,783.10482 193.58426,647.63449 191.70703,496.84961ZM44.53125,610.36133 0,644.61523V902.7832C30.797744,884.46615 56.707359,866.73637 80.427734,846.89844 72.427991,853.57027 64.158102,860.01913 55.517578,866.33008 48.1356,836.13212 35,776.24391 35,740 35,720.74035 41.674751,699.57565 65.384766,692.25586 47.265656,686.61054 35,674.30844 35,660 35,645.1697 48.176742,632.49354 66.972656,627.49805 56.528563,624.35562 49.361734,618.22105 44.53125,610.36133Zm1190.09765,68.79687 -1.1211,1.04688c-20.0542,23.0427 -41.8711,45.665 -71.7441,65.72265 27.117,39.37142 36.6532,80.37363 27.7441,123.12891 25.4392,14.76465 47.2329,33.87001 67.875,55.8418 -10.0896,-28.95393 -26.9566,-68.05217 -64.6191,-89.36328C1229.865,829.72137 1245.3631,819.51581 1260,800c-28.5778,-21.24841 -50.4759,-15.94491 -77.3027,-15.66992 39.149,-21.89578 49.9371,-64.78262 51.9316,-105.17188zM110.74609,819.23828c-0.7889,0.78628 -1.58065,1.56702 -2.37304,2.3457 0.792,-0.77791 1.58362,-1.55961 2.37304,-2.3457zm-5.15234,5.05078c-0.76819,0.74251 -1.53476,1.48679 -2.30664,2.22266 0.77112,-0.73534 1.53841,-1.48017 2.30664,-2.22266zm-5.26172,5.00586c-2.077449,1.94603 -4.165139,3.87648 -6.273436,5.7793 2.104356,-1.90192 4.194747,-3.83083 6.273436,-5.7793zm-6.539061,6.02149c-1.467973,1.32281 -2.945132,2.63598 -4.429688,3.93945 1.482456,-1.30407 2.961518,-2.61456 4.429688,-3.93945zM377.5,862.5a11,22.5 0 0 0 -11,22.5 11,22.5 0 0 0 11,22.5 11,22.5 0 0 0 11,-22.5 11,22.5 0 0 0 -11,-22.5zm225.17578,127.46484a10,10 0 0 0 -10,10 10,10 0 0 0 10,9.99996 10,10 0 0 0 10,-9.99996 10,10 0 0 0 -10,-10zM420,990a10,10 0 0 0 -10,10 10,10 0 0 0 10,10 10,10 0 0 0 10,-10 10,10 0 0 0 -10,-10zm91.13281,0.41016a10,10 0 0 0 -10,10.00004 10,10 0 0 0 10,10 10,10 0 0 0 10,-10 10,10 0 0 0 -10,-10.00004z"
        ></path>
      </symbol>
      <symbol id="SQ3" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="#44F"
          d="M472.5,150a12.5,20 0 0 0 -12.5,20 12.5,20 0 0 0 12.5,20 12.5,20 0 0 0 12.5,-20 12.5,20 0 0 0 -12.5,-20zm-140,5a12.5,20 0 0 0 -12.5,20 12.5,20 0 0 0 12.5,20 12.5,20 0 0 0 12.5,-20 12.5,20 0 0 0 -12.5,-20zm23.49023,301.12891c3.54904,108.54757 3.24814,214.77856 28.25977,309.58398 83.90967,-121.45694 183.76187,-211.71291 282.33398,-298.83789 -85.00816,14.89038 -149.26165,18.48851 -200.56445,14.4043 -45.1152,-3.59162 -80.40237,-13.40501 -110.0293,-25.15039zm42.92579,22.92187c22.57573,0.10326 52.52779,2.34383 83.49804,6.2461 65.74558,8.28415 118.15335,21.65893 117.05469,29.87304 -1.09829,8.2139 -56.30922,5.07893 -122.05273,-3.20508 -65.73948,-8.28354 -117.1185,-18.57868 -116.02735,-26.79296 0.53448,-4.02047 14.07178,-6.22853 37.52735,-6.1211zM1117.5,492.5c2.4011,8.40385 4.2266,18.24941 5.4746,28.84375v0.36133c7.3876,-1.36391 16.4655,0.0837 27.2324,5.62304l-21.2675,-21.26757a1.50015,1.50015 0 0 1 1.0449,-2.57617 1.50015,1.50015 0 0 1 1.0761,0.45507l21.2676,21.26758c-5.5291,-10.74776 -6.9807,-19.81297 -5.6289,-27.19336 -10.7286,-1.24895 -20.7021,-3.08593 -29.1992,-5.51367zm130,0c-8.4251,2.40718 -18.2988,4.23414 -28.9238,5.48242h-0.2793c1.3613,7.38557 -0.087,16.46062 -5.6231,27.22266l21.2657,-21.26563a1.50015,1.50015 0 0 1 1.0312,-0.45312 1.50015,1.50015 0 0 1 1.0898,2.57422l-21.2675,21.26757c10.7565,-5.53399 19.8272,-6.98416 27.2109,-5.62695v-0.17187c1.2486,-10.6649 3.081,-20.57644 5.4961,-29.0293zm-853.59961,15.25781c20.38428,0.10329 47.42876,2.34386 75.39258,6.2461 59.36368,8.28422 106.68388,21.65899 105.69141,29.87304 -0.99271,8.21355 -49.91699,8.15671 -109.27735,-0.12695 -59.36371,-8.28422 -106.68391,-21.659 -105.69141,-29.87305 0.48636,-4.01928 12.70935,-6.22659 33.88477,-6.11914zm7.69531,34.67969c15.09367,-0.0753 32.61454,0.81411 50.47852,2.5625 51.50146,5.04084 94.00823,14.75226 93.67578,23.00391 -0.32891,8.2521 -42.34749,10.85536 -93.84961,5.81445C400.39893,568.77752 358.91755,558.00165 359.25,549.75c0.20345,-5.08688 15.52034,-7.17888 42.3457,-7.3125zm590.81446,21.09375c-26.28817,17.83124 -58.00395,39.71623 -85.84375,65.82227L1063.252,755.79883c5.9292,-6.64494 11.8308,-13.34093 17.6972,-20.10156C1043.5709,740.31699 1042.225,686.12754 1005,670c53.4509,-24.54202 74.1653,5.69528 79.6582,61.40234 18.288,-21.22222 36.2025,-43.13214 53.4609,-66.25 -50.4965,-31.89003 -99.3677,-65.63189 -145.70894,-101.62109zm92.24804,167.87109c-1.2353,1.43353 -2.4703,2.86748 -3.709,4.29493 1.3064,-0.16146 2.6533,-0.388 4.0508,-0.69727 -0.1038,-1.21628 -0.2241,-2.40447 -0.3418,-3.59766zm-21.4062,24.39649 1.3242,1.02344C1092.8236,758.22045 1130,765 1130,765c33.2353,-17.40792 57.5278,-36.95014 78.082,-57.38477 -19.9562,-11.65548 -39.7017,-23.55345 -59.2109,-35.71875 -15.5528,20.88792 -31.6462,40.7815 -48.0664,60.07227 34.429,-15.14174 49.9983,-46.37972 66.4785,-4.63672 -32.1431,-2.07452 -62.02,44.58146 -67.2129,5.5 -7.149,8.38604 -14.3562,16.66276 -21.6113,24.85352zM399.88477,574.98828c12.13924,-0.0753 26.23048,0.81416 40.59765,2.5625 41.42116,5.04089 74.78321,15.81675 74.51563,24.06836 -0.26463,8.25206 -34.05885,10.85531 -75.48047,5.81445 -41.42116,-5.04089 -74.78321,-15.81675 -74.51563,-24.06836 0.16364,-5.08693 13.30756,-8.24338 34.88282,-8.37695zm814.90823,12.6836 21.2675,21.26757a1.50015,1.50015 0 1 1 -2.121,2.1211l-21.2657,-21.26563c5.5369,10.76367 6.9837,19.84044 5.6211,27.22656h0.3223c10.6094,1.24816 20.4685,3.07443 28.8828,5.47852 -2.4278,-8.49731 -4.2627,-18.47029 -5.5117,-29.19922 -7.3807,1.35234 -16.4468,-0.0994 -27.1953,-5.6289zm-64.5879,0.002c-10.7501,5.53028 -19.8161,6.98044 -27.1973,5.62695v0.0723c-1.2488,10.70195 -3.0853,20.64836 -5.5078,29.12695 8.4975,-2.42785 18.4701,-4.26471 29.1992,-5.51367 -1.3518,-7.38039 0.1,-16.44561 5.6289,-27.19336l-21.2676,21.26758a1.50015,1.50015 0 1 1 -2.121,-2.1211zM399.95117,608.2207c7.75591,-0.014 16.33902,0.59569 25.04883,1.7793 30.51033,4.14665 55.19775,16.74619 55.24414,25 0.0491,8.25469 -24.64792,11.5847 -55.16016,7.4375 -30.51033,-4.14665 -55.28173,-14.19933 -55.32812,-22.45312 -0.0324,-5.62262 11.68692,-11.73096 30.19531,-11.76368zm2.94141,36.28321c3.92832,-0.0157 8.00124,0.15115 12.10742,0.49609 25.08573,2.10744 44.77796,7.02839 45.42188,14.97852 0.64298,7.94981 -19.17087,12.68576 -44.25586,10.57812 -25.08573,-2.10744 -45.94398,-10.26081 -46.5879,-18.21094 -0.52278,-6.4668 13.79255,-7.76393 33.31446,-7.84179zm-6.3711,30.78125c1.53788,10e-4 3.10151,0.0612 4.67383,0.17968 15.24356,1.1523 28.12847,7.43255 28.7793,14.02735 0.6519,6.59512 -11.17778,11.00764 -26.42188,9.85547 -15.24356,-1.1523 -28.12847,-7.43255 -28.77929,-14.02735 -0.57317,-5.81151 8.60794,-10.04793 21.74804,-10.03515zm-2.7207,30.4707c0.97501,0.002 1.96625,0.0499 2.96289,0.14453 9.66123,0.91446 17.82809,5.89851 18.24219,11.13281 0.4126,5.23472 -7.08576,8.73687 -16.74805,7.82227 -9.66123,-0.91446 -17.82809,-5.89851 -18.24219,-11.13281 -0.3645,-4.61356 5.45528,-7.97697 13.78516,-7.9668zm906.19922,0.0781 -34.2773,2.85547c0.2249,20.00253 -6.7832,39.15319 -30.7188,56.31055 24.0241,2.30082 45.4719,10.59792 60,35 -9.9971,24.98116 -26.6502,40.00143 -50,45 19.6816,21.91005 28.1768,47.18324 30.0293,74.45312l0.01,0.008 24.957,11.09375zm-167.2656,64.20508c0.2372,0.44647 0.4708,0.89347 0.7051,1.33985 -0.2343,-0.44637 -0.4679,-0.89339 -0.7051,-1.33985zm3.041,5.88282c0.083,0.16606 0.171,0.33199 0.2539,0.49804 -0.083,-0.16604 -0.1705,-0.33202 -0.2539,-0.49804zm2.6758,5.48437c0.2147,0.45253 0.425,0.90499 0.6367,1.35742 -0.2117,-0.45239 -0.4219,-0.90493 -0.6367,-1.35742zm2.455,5.32422c0.1795,0.40036 0.3641,0.80089 0.5411,1.20117 -0.177,-0.40029 -0.3615,-0.80081 -0.5411,-1.20117zm2.5958,5.98437c0.2099,0.50184 0.413,1.00415 0.6191,1.50586 -0.2062,-0.5018 -0.4092,-1.00393 -0.6191,-1.50586zm2.0703,5.11719c0.1975,0.50277 0.4,1.00516 0.5937,1.50781 -0.1937,-0.50252 -0.3962,-1.00516 -0.5937,-1.50781zm2.3418,6.1875c0.1922,0.53072 0.3764,1.06121 0.5644,1.5918 -0.188,-0.53055 -0.3722,-1.06112 -0.5644,-1.5918zm1.7324,4.96485c0.2042,0.60477 0.4106,1.20984 0.6094,1.81445 -0.1988,-0.60461 -0.4051,-1.20971 -0.6094,-1.81445zm2.0273,6.26562c0.1846,0.60177 0.3579,1.20308 0.5371,1.80469 -0.1792,-0.60139 -0.3525,-1.20313 -0.5371,-1.80469zm1.4688,5.00977c0.1799,0.63781 0.3593,1.27644 0.5332,1.91406 -0.174,-0.63786 -0.3532,-1.27602 -0.5332,-1.91406zM377.5,842.5c-4.42321,0 -9.31831,2.00257 -14.86719,9.24023C357.08394,858.97789 352.5,871.0223 352.5,885c0,13.9777 4.58394,26.0221 10.13281,33.25977 5.54888,7.23766 10.44398,9.24023 14.86719,9.24023 4.42321,0 9.31831,-2.00257 14.86719,-9.24023C397.91606,911.0221 402.5,898.9777 402.5,885c0,-13.9777 -4.58394,-26.02211 -10.13281,-33.25977C386.81831,844.50257 381.92321,842.5 377.5,842.5Zm-0.27344,4.79492c2.95574,0.0879 5.94922,5.08008 5.94922,10.70508 10.93128,-0.11104 14.67749,3.31056 5.67578,13 13.69744,3.7436 10.6454,8.69968 2.83789,14 7.80751,5.30032 10.85955,10.2564 -2.83789,14 9.00171,9.68944 5.2555,13.11104 -5.67578,13 0,10 -9.4596,18 -11.35156,0 -10.93128,0.11104 -14.67748,-3.31056 -5.67578,-13 -13.69744,-3.7436 -10.6454,-8.69968 -2.83789,-14 -7.80751,-5.30032 -10.85955,-10.2564 2.83789,-14 -9.0017,-9.68944 -5.2555,-13.11104 5.67578,-13 0.82773,-7.875 3.10344,-10.77344 5.40234,-10.70508zm352.35742,5.20508 -75.1914,86.93945 43.0039,-0.041L744.44531,885H840l-15,-32.5zm29.72266,65 -19.23047,22.23633L876.25,939.95508 860,917.5Zm-104.13476,52.41992 -315.75977,0.17969c2.43984,2.47881 4.98787,4.87423 7.56641,7.28906 15.37025,14.39437 29.32058,28.43253 41.91015,42.12693 1.06974,-4.4442 6.04965,-11.1309 16.11133,-19.5156 -30,-25 -15,-34.99999 15,-15 30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -11.06914,7.3794 -20.08451,10.6644 -25.5625,10.6289 1.31057,1.4627 2.62767,2.9262 3.90625,4.3809l256.41797,-0.1328zm-170.01172,4.44531C490.60938,974.21875 499.75,977.5 511,985c30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -30,20 -45,10 -15,-15 -18.75,-15.625 -19.92188,-25.39063 -10.83984,-25.63477zm91,0C581.60938,974.21875 590.75,977.5 602,985c30,-19.99999 45,-10 15,15 30,25 15,35 -15,15 -30,20 -45,10 -15,-15 -18.75,-15.625 -19.92188,-25.39063 -10.83984,-25.63477z"
        ></path>
      </symbol>
      <symbol id="SQ4" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          fill="black"
          d="M499.67383,0C598.83088,212.42554 698.5156,423.78371 891.07812,444.24805L557.50781,0ZM299.89844,59.855469C265.54099,182.85387 187.08454,297.85994 240.09961,458.2793L349.875,372.94531C322.20549,333.64118 300,282.28964 300,255c0,-20 5.00324,-149.9992 5,-155 -10e-4,-2.004308 -2.41143,-19.27436 -5.10156,-40.144531zM899.91016,454.8418C746.55122,593.77022 578.78424,763.04072 429.50781,939.46875l40.84766,0.54297C595.55342,787.07576 764.14431,621.01748 918.95508,481.37891Zm65.79101,87.45703c-28.87179,19.18723 -64.12524,44.12835 -93.97851,75.52344l25.55078,20.04296c30.22964,-29.84438 65.96002,-54.59002 95.59961,-73.97851 -9.28135,-6.87909 -18.47109,-14.10656 -27.17188,-21.58789zM685,755 525.10156,939.88281 570,940 699.86133,787.5H806.65039L805,755Z"
        ></path>
      </symbol>
      <symbol id="SQ5" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          stroke="#44F"
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="6"
          fill="none"
          d="M435,885A57.5,75.000002 0 0 1 377.5,960.00001 57.5,75.000002 0 0 1 320,885 57.5,75.000002 0 0 1 377.5,810 57.5,75.000002 0 0 1 435,885v0M417.07718,940H876.02627M308.27069,940h28.75722M339.49097,970H901.47783M131.84482,543.19629 351.03451,374.58883M6.9310566e-5,644.61533 44.832165,610.1291M1138.1663,665.18229C1077.9926,627.18313 1020.1253,586.55302 965.29601,542.45758M1208.5796,707.90733c-20.1878,-11.78458 -40.1599,-23.81534 -59.8906,-36.12132M557.51806,-3.5577172e-4 965.44559,542.57786M1299.7291,1059.765c-68.4773,39.2778 -116.7334,76.5733 -164.2838,131.8131 -44.9491,-77.8482 -93.9175,-130.6069 -160.20897,-192.68943 -76.05982,-71.23062 -114.27421,-131.59148 -129.3711,-180.42578 -15.09688,-48.8343 -8.90849,-86.60287 7.94922,-120.96875 28.31708,-57.72677 91.51285,-102.35515 139.0695,-133.86354M499.68528,0.03748108C598.83742,212.45251 698.51437,423.77834 890.34164,443.851M364.36489,812.31243C320.07724,685.41364 328.50886,542.63024 321.33642,404.17725c76.71711,39.85219 163.35704,77.44074 457.8821,5.76082C644.587,533.12731 501.69292,642.05444 392.45651,811.84681M355.97656,456.125c29.62956,11.74764 64.92126,21.56216 110.04297,25.1543 51.30556,4.08443 115.56309,0.48617 200.57813,-14.40625 -98.57798,87.12824 -198.39177,177.48156 -282.2461,298.86133 -24.96545,-94.92731 -24.7974,-201.06283 -28.375,-309.60938v0M867.34252,440.4065C719.62961,574.07588 560.4386,730.57461 436.09373,879.43791M223.89186,472.86906c-0.82324,183.16931 37.98603,343.48203 98.11552,466.27071M191.49798,496.71315c2.08648,150.92196 30.40471,286.39171 75.55251,398.73891M429.507,939.46794C578.78343,763.03991 746.55158,593.76963 899.91052,454.84121M470.35494,940.01166C595.55289,787.0757 764.14488,621.01728 918.95565,481.37871M525,940 685,755h120.41872M567.92551,940.0502 699.86133,787.5h106.78892M611.46541,939.39021 714.72266,820h97.2642M654.39213,939.43943 729.58398,852.5h93.89714M697.39662,939.39902 744.44531,885h95.04566M740.07521,939.73575 759.30664,917.5H860M906.39152,629.42293 1063.7852,756.67736M871.92369,617.813 1043.2441,757.01082M459.61865,481.34795C414.86903,573.51288 406.45192,669.62669 385,765M303.65592,-0.00221915C259.09343,162.78907 138.61386,327.07777 209.42337,483.4732M240.09997,458.27954C187.0849,297.86018 265.54056,182.85405 300.09597,58.960082M805.81085,330.134c14.88787,-6.44544 30.42237,-12.16006 46.14865,-17.2138M0.09725143,902.73906C71.866196,860.06685 117.03718,820.61709 170,750c50,100 99.8567,155.1639 176.97865,227.3892 281.56105,263.6842 94.15072,409.6105 -13.08443,480.4695M377.5,842.5c4.42321,0 9.31831,2.00257 14.86719,9.24023C397.91606,858.97789 402.5,871.0223 402.5,885c0,13.9777 -4.58394,26.0221 -10.13281,33.25977C386.81831,925.49743 381.92321,927.5 377.5,927.5c-4.42321,0 -9.31831,-2.00257 -14.86719,-9.24023C357.08394,911.0221 352.5,898.9777 352.5,885c0,-13.9777 4.58394,-26.02211 10.13281,-33.25977C368.18169,844.50257 373.07679,842.5 377.5,842.5v0M1130,765c16.8191,30.21345 26.6544,60.2083 30,90 47.2312,18.32372 82.8871,51.83723 115,90 2.3419,-37.0436 -4.2974,-71.38724 -30,-100 23.3498,-4.99857 40.0029,-20.01884 50,-45 -14.5281,-24.40208 -35.9759,-32.69918 -60,-35 44.8752,-32.16719 30.2665,-71.33926 20,-110 -32.9633,38.74398 -63.8666,77.97963 -125,110v0M1300,705.83334l-34.3239,2.86032M1299.9997,930.55544l-26.1711,-11.63161M1192.7269,836.42558c37.6985,20.41997 54.5672,59.51932 65.2796,89.01033M1182.9686,784.9233c26.555,-0.86899 48.4536,-6.17171 77.0314,15.0767 -14.6369,19.51581 -30.1358,29.72065 -67.2011,34.6433M1234.6287,679.15791c-1.9945,40.38926 -12.7829,83.27561 -52.2037,104.5774M1162.3431,745.42454c26.5383,39.87481 36.0743,80.87688 26.979,123.43436M1130,765c0,0 -82.1675,-15 -95,-5 -12.8325,10 -32.9691,31.30714 -40,40 -31.97044,39.52731 3.64509,49.72935 20,30M1050,800c-59.31161,25.45028 -64.22618,120.61499 20,25M1041.1933,853.52948c-14.9444,32.29436 0.7581,60.30105 58.5,-5.24847M1062.1853,882.59071C1040.9944,921.29246 1103.755,918.14402 1160,855M1063.2524,755.79961c33.572,-37.62441 66.2866,-76.82735 96.4461,-120.73492M1078.4582,757.6865c32.4929,-36.68328 64.0954,-75.00591 93.2554,-117.82589M1085,735c-4.9523,-58.0017 -25.4042,-90.06768 -80,-65 38.526,16.69119 38.6175,74.15849 80,65v0M1005,670c37.8073,-6.25375 56.1399,40.79694 80,65M1100,732.33169c35,-15 50.6726,-47.07119 67.2824,-5 -32.2824,-2.08351 -62.2824,45 -67.2824,5v0M1100.0662,732.84533c26.3257,8.26747 52.4616,-23.9051 67.2162,-5.51364M1155.0001,585.00001C1080.0001,630 1080,484.99999 1155,530c-45,-75 100,-75 55,0 75,-45 75,100 10e-5,55 45,75.00001 -100.0001,74.99999 -55,10e-6v0M1242.5,557.5c-60,0 -60,0 -60,-60 0,60 0,60 -60,60 60,0 60,0 60,60 0,-60 0,-60 60,-60v0M1122.9743,521.34338c-1.248,-10.59434 -3.0726,-20.43952 -5.4737,-28.84337 8.5766,2.45046 18.6544,4.30045 29.4977,5.54996M1146.7554,616.97813c-10.7509,1.24908 -20.7424,3.08971 -29.255,5.52188 2.4225,-8.47859 4.2581,-18.42426 5.5069,-29.12621M1241.9485,592.9857c1.2496,10.84959 3.1002,20.93331 5.5519,29.5143 -8.4143,-2.40409 -18.2735,-4.23021 -28.8829,-5.47837M1218.5761,497.98319c10.625,-1.24828 20.4988,-3.07601 28.9239,-5.48319 -2.4151,8.45286 -4.2469,18.3639 -5.4955,29.0288M357.95908,386.26136c-4.7848,-2.30618 -9.52375,-4.6875 -14.28345,-7.12611M748.06895,383.93902C622.45119,413.08814 538.88863,420.5377 479.79194,417.07826M355.99023,456.12891c29.62693,11.74538 64.9141,21.55877 110.0293,25.15039 51.3028,4.08421 115.55629,0.48608 200.56445,-14.4043C568.01187,553.99998 468.15967,644.25595 384.25,765.71289 359.23837,670.90747 359.53927,564.67648 355.99023,456.12891v0M85,135c10.787262,31.12992 5,90 35,90 65,0 20,-95 -35,-145 -55.000004,50 -100.000004,145 -35,145 30,0 24.21273,-58.87008 35,-90v0M40,285c0,0 0,-10 10,-10 12.88094,0 15,45 -10,45 -34.999996,0 -29.999996,-70 5,-70 30,0 40,50 40,50 0,0 10,-50 40,-50 35,0 40,70 5,70 -25,0 -22.88094,-45 -10,-45 10,0 10,10 10,10M120,275c-55,2.66831 15,250 14.49097,296.289C134.16784,600.67311 125,630 85,630 45,630 35.832163,600.67311 35.509031,571.289 35,525 105,277.66831 50,275M70,264.98358V208.33333M100,265.18883V208.74384M103.20611,627.39263C121.81764,632.48836 135,645.16656 135,660c0,19.32997 -22.38576,35 -50,35 -27.614237,0 -50,-15.67003 -50,-35 0,-14.8303 13.176786,-27.50627 31.782083,-32.60414M65.931232,692.4756C41.674852,699.57662 35,720.74035 35,740c0,36.24391 13.136211,96.133 20.364326,126.34321M128.36935,800.67704C132.14739,778.91407 135,756.88968 135,740c0,-19.39937 -6.77205,-40.73054 -31.46191,-47.67672M256.89224,885h6.38602M1.1417102e-4,884.99999 28.737098,885M245.57157,870h11.90122M2.5229169e-5,870.00002 51.088175,870M233.67034,855h18.57752M4.1609595e-5,854.99999 52.539543,855M222.93022,840h24.09272M7.6084636e-5,840.00001 49.346532,840M212.77064,825h29.89819M4.2336546e-5,825.00002 46.443795,825M203.1916,810h34.54258M4.0905762e-6,810.00002 43.541058,810M194.48339,795h38.89668M129.46208,795h5.22493M-3.8457096e-5,795.00001 40.638321,795M186.06545,780h42.96051M131.78427,780h14.51368M-3.1733115e-5,780.00001 38.316131,780M178.22806,765h46.73407M133.81618,765h24.67327M10,765H36.284215M134.68701,750h86.50156M10,750H34.542573M134.97728,735h83.01828M15,735H35.12312M132.65509,720H205M15,720H37.844594M155,705h45M325,510c-11.82334,-17.57111 -24.45521,-31.94743 -45.42097,-47.16261 -21.67788,-15.73198 -32.01525,9.6364 -23.86278,22.70472M325,540c-13.68399,-15.7169 -40.72661,-39.31758 -62.25684,-51.80699 -20.39713,-11.83211 -26.52283,15.09906 -9.53546,27.99468M326.64903,572.53873c-13.68399,-15.7169 -40.42328,-39.85576 -62.25684,-51.80699 -33.04187,-18.08643 -43.83934,14.15892 -2.74316,31.80699M329.68204,632.14459c-13.68399,-15.7169 -40.42328,-39.85576 -62.25684,-51.80699 -30.81157,-16.86561 -37.65608,16.8659 -5.11631,35.80661M328.06764,597.68777c-13.86078,-13.59047 -33.31597,-27.70524 -50.77313,-39.51278 -22.07438,-14.9305 -34.10496,4.47364 -22.83565,17.22609M332.19576,659.38835c-13.77031,-13.23256 -32.62008,-26.88451 -49.58329,-38.35795 -24.04479,-16.26322 -36.17268,12.27173 -19.25152,25.31598M335.48063,686.60634C319.24375,673.64242 295.51352,659.7442 277.4252,650.3376c-31.2697,-16.26141 -36.88691,20.47944 -3.29829,37.12122M339.44241,709.94356C293.812,671.34406 241.20364,684.64228 285,715M345.57813,743.85785c-49.78299,-42.23381 -140.14002,-42.27022 -51.45386,5.50004M359.15379,797.42734C296.30783,757.35598 217.41506,767.9862 315.25691,808.08817M356.15219,815.71589c-43.41581,-18.1629 -92.79129,0.20988 -43.97099,13.65755M335.79649,833.55074c-36.46249,-11.38361 -55.92576,9.42664 -11.42381,20.21059M323.63736,467.38673c-7.1925,-7.58612 -15.51039,-14.89158 -25.85855,-22.4014 -17.52111,-12.71535 -26.71907,0.32727 -25.12324,12.4885M322.15877,428.22708c-1.31784,-1.00168 -2.67007,-2.00587 -4.05887,-3.01374 -19.41173,-14.0874 -28.60717,3.4419 -24.22651,16.36102M351.5017,769.34668c-41.8286,-32.62324 -87.13007,-22.98664 -57.82646,2.59886M396.50984,805.03398c97.55186,1.04019 65.93584,25.61549 21.19412,25.63392M410.20409,785.71584c31.87867,-11.92022 60.58013,-9.17207 74.95842,-1.62887 16.81695,8.82258 14.04006,24.2047 -26.16419,30.34906M430.54986,757.7319c58.57662,-11.0001 103.69453,13.94896 55.48459,26.1888M451.62343,729.60393c67.42086,-18.09697 125.45489,10.74224 49.42624,33.66324M469.15226,707.61747c69.25339,-23.47062 135.42699,4.47512 67.15155,28.14525M497.03474,675.73394c50.50234,-8.00778 88.6752,9.66559 55.551,28.0217M514.06286,656.56715c77.25396,-19.94453 157.95502,17.262 48.7626,27.75334M550.91529,618.31036c57.1762,-5.00205 100.00874,18.02731 40.2256,35.03407M568.89077,600.93936c75.24789,-19.79781 151.84194,14.60918 51.22446,34.33609M596.84001,574.15634c55.64482,-7.64299 102.46778,11.7471 64.24628,28.76475M620.73761,552.10789c71.56974,-16.51587 140.66537,14.62009 53.45997,34.06378M660.73433,515.56983c57.1151,-4.52529 99.00079,18.87447 36.45506,35.78648M684.38719,494.58861c73.88041,-16.89549 144.8643,16.89901 43.68109,36.08147M722.79564,460.82624c57.76542,-5.50387 101.75016,17.65976 42.02455,34.7974M748.43052,437.7647c68.01755,-11.92015 127.59071,17.4385 43.80212,36.02686M645.55164,273.86211C640.4516,285.47932 635.59316,297.26013 610,295c-14.37233,81.30224 -73.77303,98.38804 -130,120 0,0 -19.41945,15.64589 -29.41945,15.64589C435.58055,430.64589 425,425 420,425c-5,0 -10,5 -25,5 -15,0 -30,-25 -40,-50 -30,-40 -55,-96.04455 -55,-125 0,-20 5.003,-149.9992 5,-155 -0.002,-3.089335 -5.72781,-42.445846 -10.1037,-72.07356M622.93321,240.32144C616.61632,250.552 609.19352,264.74236 615,265c2.73428,0.12132 6.96971,-10.37759 10.24354,-19.90618M904.16018,494.81448l50.56379,54.17549M889.99031,508.2039l48.73454,52.21558M875.34795,521.08709l48.01937,51.44933M861.63691,534.96812l46.15447,49.45122M847.01655,547.87487l45.96336,49.24646M832.83302,561.24966l35.28817,37.80876M818.66315,574.63908l24.02599,25.74214M803.86532,587.3557l17.84203,19.11646M790.06402,601.14003l8.92784,9.56554M482.75862,925h55.41872M495.89491,910h55.00821M508.21018,895h55.82923M521.34647,880h55.41872M534.48276,865h55.41872M552.95566,845H585M790,820v32.5M765,820v32.5M740,820v32.5M703.26765,833.26765l22.578,22.578M684.08867,854.08867l23.39901,23.39901M665.93596,875.93596l22.78325,22.78325M648.19376,898.19376l22.578,22.578M629.22003,919.22003l20.73071,20.73071M791.29599,310.75526c15.62961,-6.29692 31.83381,-11.83473 48.11454,-16.69002M776.15664,290.35133c15.84539,-6.35519 32.2728,-11.93292 48.76488,-16.81275M760.82223,270.4856c16.18061,-6.50419 32.97255,-12.19625 49.8241,-17.16102M746.54814,252.22866c16.42632,-6.7965 33.54246,-12.73644 50.75899,-17.91046M739.12096,229.17409c11.71799,-4.608 23.73402,-8.79725 35.84163,-12.5995M726.54679,208.22774c8.46394,-3.2756 17.07495,-6.33535 25.75602,-9.1911M711.68624,188.33917c5.39484,-2.00758 10.85695,-3.94932 16.37032,-5.82515M900.40882,94.431781C848.5463,114.25376 796.72828,69.769511 761.4322,93.621964 715,125.00001 755,185 789.33498,165.18883 821.13528,146.84017 790,105 775,115c-9.30261,6.20174 -14.88842,18.30946 -10,25 6.18042,8.45885 10.48873,9.62814 20,5M901.46652,97.13303C861.76115,135.4564 879.34663,201.01228 842.74068,222.52055 794.42332,250.91 757.5027,188.96753 790.17065,166.51363c30.25635,-20.79631 54.6061,25.32412 39.1205,34.55428 -9.60379,5.72429 -22.93675,5.55043 -26.86936,-1.74304 -4.972,-9.22111 -4.17161,-13.61293 4.10189,-20.20332M765,180l90,-60M845,160c-10,-10 -45.467,-11.35662 -55,5 22.00764,-11.03808 34.76336,-24.75676 25,-45M795,230c25,30 50,20 75,10 24.05541,32.7653 64.66095,38.66637 105,45M725,130C715,110 740,85 755,75 749.14905,51.948962 757.70702,26.00987 766.59362,0.00490542M700,90c10,-25 25,-25 25,-25 -8.48271,-38.172217 3.28893,-47.867055 8.18679,-64.93099617M427.96416,0.01822477C445.06535,51.748024 483.31343,78.400493 539.31946,83.994433M446.67053,0.04362022C462.63103,38.843647 492.03631,61.699978 533.14043,70.683071M461.24526,0.01603427C475.22521,27.447203 496.92922,45.718691 525.58366,55.74792M476.99588,0.10806452C487.38028,16.453559 500.99836,28.964352 517.63646,37.893813M371.26432,0.04443925C356.34418,40.196712 340.91798,80.075485 304.69652,100.28589M355.60874,0.04353776C343.34293,31.804187 329.13875,61.845937 302.67098,80.298673M339.57059,0.02060224C329.73362,23.196287 317.89132,44.53011 299.71459,59.883794M325.15652,0.08430598C317.46458,14.722402 308.27692,27.964826 296.26758,38.544057M305,120c41.1016,-25.066138 61.56092,-14.28714 80,0 20,55 -15,110 -14.41945,151.6763 0.21559,15.47674 11.72696,13.44856 19.41945,13.3237 4.99934,-0.0811 15,10 15,10M305,125c29.58587,-20.97635 55.47603,-17.50669 80,-5M430,245c20,0 20,30 5,30 -40,5 -40,-10 -5,0M365,315v10l5,-5 -5,-5v0M455,320l5,-5v10l-5,-5v0M370,320c0,0 5,5 10,5 5,0 5.24415,-4.00984 12.32219,-4.4848C400,320 400,325 405,325c5,0 15,-10 20,-10 5,0 15,5 20,5h10M390,340c3.06957,28.45212 45.6136,8.68856 45,5 -5,5 -44.77199,31.85105 -45,-5v0M430,135c51.53607,-36.718861 85.86501,-16.18211 120,5 -35.40475,-25.98218 -85,-45 -120,-5v0M540,160C525,160 503.52953,134.61544 483.61398,136.45137 453.79885,139.1999 445,175 430,180 447.93464,158.59181 463.7944,151.78059 478.07024,151.93493 507.27438,152.25068 515,185 550,175M430,180c15,-10 32.80939,10.04302 45.17423,9.94542C504.08195,189.71723 519.49385,175 530,175M380,175c-20,0 -30.87367,-19.1648 -47.03192,-20.29027 -12.3413,-0.85961 -29.19452,12.61246 -29.19452,17.61246 0,7.07107 11.23734,20.70784 22.74316,23.25836C342.90794,199.21402 362.81244,175.3491 380,175v0M305,165c22.64276,-42.75014 64.95345,-9.49214 65,-5M820,265c15,15 35,10 45,5 20.5191,14.6565 42.75671,20.72048 62.68286,23.22939M851.86653 312.33707C895.10619 299.11787 938.83136 290.34833 975 285C924.90149 188.22308 899.90057 94.152754 874.11725 -0.0019513659 M851.86653,312.33707C895.10619,299.11787 938.83136,290.34833 975,285 924.90149,188.22308 899.90057,94.152754 874.11725,-0.00195137M851.01315,311.99775 635.36748,-2.4089679e-4M927.65339,293.26472C907.75671,290.72048 885.5191,284.6565 865,270c-10,5 -30,10 -45,-5"
        ></path>
      </symbol>
      <symbol id="SQ6" preserveAspectRatio="none" viewBox="0 0 1300 2000">
        <path
          stroke="#44F"
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="3"
          fill="none"
          d="M986.60333,811.20184l17.52527,26.83701m3.5763,5.47663 14.2883,21.88014M993.49031,800.86775c12.59499,20.81314 26.36539,39.79428 40.67199,57.93996m3.6811,4.63683c6.0574,7.57938 12.2001,15.02588 18.3803,22.41378m3.5795,4.26824c4.9357,5.87225 9.8895,11.71638 14.8372,17.56998M1002.2895,791.27746c25.6547,42.89167 56.3312,77.95704 86.5273,113.77117M1011.3206,782.24417c26.5981,44.89853 58.7236,81.18275 90.1523,118.55299M1018.2105,775.40469C1045.4382,820.51985 1078.1971,857.01507 1110,895M91.990234,409.08984c5.346491,34.39969 12.364566,69.89746 17.978516,99.54297 5.61395,29.64551 9.60751,54.84672 9.52344,62.49219 -0.14502,13.18721 -2.60383,25.09508 -7.35157,32.2207C107.39289,610.47133 101.33414,615 85,615 68.665861,615 62.607113,610.47133 57.859375,603.3457M95.230469,511.42383c2.783382,14.69817 5.162021,28.28252 6.812501,38.99023 1.65048,10.70771 2.46055,19.51658 2.44922,20.54688 -0.12561,11.42229 -3.03694,21.37127 -4.833987,24.06836 -1.554361,2.33286 -1.96098,2.67133 -3.316406,3.33203C94.986371,599.02203 91.780811,600 85,600M99.244141,641.85938C113.48363,645.75807 120,654.05348 120,660c0,3.87456 -2.13436,8.18273 -8.24609,12.46094C105.64218,676.73915 95.96981,680 85,680 74.030191,680 64.357824,676.73915 58.246094,672.46094M99.476562,706.76367c8.835718,2.48582 12.847888,6.43575 15.929688,11.99805C118.48805,724.32402 120,732.04575 120,740c0,15.20071 -2.70618,36.77501 -6.41016,58.11133M102.94922,660.2832C99.903483,662.33803 92.860098,665 85,665c-7.997241,0 -15.198086,-2.76015 -18.152344,-4.82812M102.28516,726.03125C103.52282,728.2651 105,733.94656 105,740c0,13.42041 -2.56634,34.6744 -6.189453,55.54492M726.75998,368.27894C639.85431,387.67178 574.6926,396.00751 524.83867,397.57475M715.61309,356.58894C649.94086,370.7787 597.12268,378.4618 554.16847,381.63062M703.03893,344.25945c-49.76763,10.38288 -91.8849,16.91189 -127.75629,20.52287M690.7875,331.76901c-38.30305,7.6982 -71.90839,13.04175 -101.50758,16.49148M680.13806,318.87243c-30.03631,5.82677 -57.08899,10.16495 -81.51547,13.25269M670.20516,305.76564c-23.347,4.36958 -44.8345,7.81564 -64.64196,10.45774M659.57286,292.71511c-18.04772,3.23925 -34.94556,5.91034 -50.78275,8.07274M390,380c11.94547,-13.95601 27.22073,-12.69836 45,0M440,195c10,15 30,15 45,15M310,205c50,25 60,-30 70,-30M350.01995,162.05531c1.14299,3.17833 1.7863,6.76631 1.7863,10.56373 0,13.03628 -7.58139,23.60427 -16.9335,23.60427 -9.35211,0 -16.93349,-10.568 -16.93349,-23.60427 0,-5.79795 1.49965,-11.10766 3.98776,-15.21654M488.55832,153.60687c1.90775,3.81995 3.02626,8.46304 3.02626,13.4703 0,13.03628 -7.58139,23.60427 -16.9335,23.60427 -9.35211,0 -16.93349,-10.568 -16.93349,-23.60427 0,-4.03258 0.72545,-7.82898 2.00436,-11.14943"
        ></path>
        <use xlink:href="#SSQ" height="90" transform="translate(1188,935)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1194,1043)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1096,1033)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(1022,947)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(918,851)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
        <use xlink:href="#SSQ" height="90" transform="translate(897,726)scale(1,0.972)rotate(-40)translate(-45,-45)"></use>
      </symbol>
      <rect width="239" height="335" x="-119.5" y="-167.5" rx="12" ry="12" fill="white" stroke="black"></rect>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ1"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ1"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ2"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ2"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ3"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ3"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ4"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ4"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ5"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ5"></use>
      <use width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ6"></use>
      <use transform="rotate(180)" width="164.8" height="260.8" x="-82.4" y="-130.4" xlink:href="#SQ6"></use>
      <use xlink:href="#VSQ" height="32" x="-114.4" y="-156"></use>
      <use xlink:href="#SSQ" height="26.769" x="-111.784" y="-119"></use>
      <use xlink:href="#SSQ" height="55.68" x="36.088" y="-132.16"></use>
      <g transform="rotate(180)">
        <use xlink:href="#VSQ" height="32" x="-114.4" y="-156"></use>
        <use xlink:href="#SSQ" height="26.769" x="-111.784" y="-119"></use>
        <use xlink:href="#SSQ" height="55.68" x="36.088" y="-132.16"></use>
      </g>
      <use xlink:href="#XSQ" stroke="#44F" fill="none"></use>
    </svg>
  `;
	html = replaceAllFast(html, 'black', 'green');
	mDiv(dTable, {}, null, html);
	return;
}

function test100_partial_sequences() {
	let hand = ['AHn', '2Hn', '3Hn', '4Hn', '5Hn', '6Hn', '7Hn', '8Hn'];
	hand = ['AHn', '2Hn', '3Hn', '4Hn', '5Hn', '7Hn', '8Hn'];
	hand = ['4Hn', '7Hn', 'AHn', '2Hn', '5Hn', '6Hn', '3Hn', '8Hn'];
	hand = ['4Hn', '7Hn', 'AHn', '2Hn', '3Hn', '8Hn'];
	hand = ['4Hn', '7Hn', 'AHn', '2Hn', '9Hn', 'THn', 'QHn', '3Hn', '8Hn'];
	hand = ['4Hn', '7Hn', 'AHn', '2Hn', 'THn', 'QHn', '3Hn', '8Hn'];
	let items = hand.map(x => ferro_get_card(x));
	console.log('items', items);
	sortCardItemsToSequence(items);
}

function test11() {
	document.body.style.height = '100vh';
	let mobj = addDeckTo(makeDeck({ kind: 'deck52', N: 30, nJokers: 5 }), document.body, 'discardPile', true, true);
	mobj.setPos(0, -300);
}

function test11_besseresColoring() {
	var dMain = document.getElementById('dMain');
	mStyle(dMain, { bg: 'indigo' });
	let [dHeaderLeft, dTitle, dHeaderRight] = std3title(dMain, 'Aristocracy', { family: 'AlgerianRegular' });
	let [dLeft, dMiddle, dRight] = std3fold(dMain);
	let dFooter = mDiv(dMain, { bg: '#00000050' }, 'dFooter', 'footer');
	let bMenuLeft = stdMenuButton(dHeaderLeft);
	stdSidebarController(bMenuLeft, 'dLeft');
	let bMenuRight = stdMenuButton(dHeaderRight);
	stdSidebarController(bMenuRight, 'dRight');
}

function test11_cardcoloring() {
	let dTable = mBy('dTable'); clearElement(dTable);
	let card = ari_get_card('KHn');
	mAppend(dTable, iDiv(card));
	let d = mDiv(dTable, {}, null, queen_html());
}

function test11_function() {
	C = new Plotter(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc');
	C.add({ astep: .1, a: 0, bstep: .1, b: 0, color: 'skyblue', thickness: 1, basefunc: x => -x * (-Math.sign(x)), func: x => Math.sin(x), update: oscillator });
}

function test11_gengraph() {
	let items = create_nodes({ x: 0, y: 0, w: 500, h: 500 }, 20, 120);
	console.log('items', items, items[120]);
	dTable = toElem('map');
	plot_on_div(dTable, items);
	adjacency_init(items);
}

function test11_oest() {
	let map = M.map = create_map({ zoom: 7, center: Geo.cities.salzburg });
	let list = get_values(Geo.cities).filter(x => x.country == 'Austria');
	console.log('list', list);
	for (const c of list) {
		create_agent(map, c);
	}
}

async function test11_say() {
	say(germanize('wie fuehlst du dich gerade?'), 'pl', test12_iconviewer, 1, .8, .8);
}

function test12() {
	document.body.style.height = '100vh';
	let deck = makeDeck({ kind: 'deck52', N: 30, nJokers: 5 });
	clearElement(document.body);
	addDeckTo(deck, document.body, 'deck1', true, true);
}

function test12_backToPresent() {
	dMenu = mMenuLine(dMain);
	dMenu.style.display = 'block';
	let bToggle = mMenuButton(dMenu);
	let d = mDiv(dMain);
	mCenterFlex(d);
	let d1 = present_structured1(d, state);
	let sb = iSidebar(mDiv(d), d1, bToggle, 40, true);
}

function test12_cyto() {
}

function test12_europe() {
	let map = M.map = create_map({ zoom: 5, center: Geo.cities.stuttgart });
	let list = get_values(Geo.cities).filter(x => x.continent == 'Europe' && x.pop >= 1000000 && x.country == 'Austria');
	console.log('list', list);
	for (const c of list) {
		let m = create_fa(map, 'helicopter', c.center);
		break;
	}
}

function test12_fop() {
	let f = fprime('x*x'); let y = f(5); console.log('math.js y', y);
}

async function test12_iconviewer() {
	let items = findKeys('face').map(x => Syms[x]);
	items = KeySets['smileys-emotion'].map(x => Syms[x]);
	items = items.map(x => ({ key: x.key, text: x.text, E: x.E, D: x.D, family: x.family }));
	let items2 = Info.emotion.map(x => ({ key: x, E: x, D: '', family: 'opensans', text: '' }));
	sortBy(items2, 'key');
	items2 = arrRemoveDuplicates(items2, 'E');
	items = items.concat(items2);
	dTable = mBy('dTable');
	for (const item of items) ui_type_item(dTable, item, {}, null, item.key);
}

function test12_try_svg() {
}

function test13_doubleDD() {
	let dParent = addDivToBody();
	dParent.id = 'dParent';
	let d = addDivPosTo(dParent, 20, 50, 200, 200, unit = 'px', bg = 'red');
	let dTarget1 = addDivPosTo(dParent, 250, 50, 300, 200, unit = 'px', bg = 'purple');
	dTarget1.id = 'dTarget1';
	let dTarget2 = addDivPosTo(dTarget1, 50, 50, 200, 120, unit = 'px', bg = 'green');
	dTarget2.id = 'dTarget2';
	let pic = addPicto(d, 'whistle');
	pic.id = 'dPic';
	posXY(pic, dParent, 10, 20);
	pic.draggable = true;
	pic.ondragstart = drag;
	pic.isPic = true;
	dTarget1.ondragover = allowDrop;
	dTarget1.ondrop = drop;
	dTarget2.draggable = true;
	dTarget2.ondragstart = drag;
	dTarget2.isPic = false;
	dParent.ondragover = allowDrop;
	dParent.ondrop = drop;
}

function test13_get_the_div() {
	let map = M.map = create_map({ zoom: 5, center: Geo.cities.stuttgart });
	let dmap = document.getElementById('map');
	let dtiles = dmap.firstChild.firstChild;
	console.log('dtiles', dtiles);
}

function test13_load_yt_in_iframe() {
	var div = document.createElement('iframe');
	div.id = 'iframe1';
	mStyle(div, { w: 500, h: 300 })
	document.getElementById("map").appendChild(div);
	div.src = "https://www.youtube.com/embed/3pNpHZ1yv3I"; //YES!
	//iDiv.src = "https://www.youtube.com/embed/3pNpHZ1yv3I?autoplay=1";
}

function test13_makeDraggableTo() {
	let dParent = addDivToBody();
	dParent.id = 'dParent';
	let d = addDivPosTo(dParent, 20, 50, 200, 200, unit = 'px', bg = 'red');
	let dTarget1 = addDivPosTo(dParent, 250, 50, 300, 200, unit = 'px', bg = 'purple');
	dTarget1.id = 'dTarget1';
	let dTarget2 = addDivPosTo(dTarget1, 50, 50, 200, 120, unit = 'px', bg = 'green');
	dTarget2.id = 'dTarget2';
	let pic = addPicto(d, 'whistle');
	pic.id = 'dPic';
	posXY(pic, dParent, 10, 20);
	makeElemDraggableTo(pic, dTarget1);
	makeElemDraggableTo(dTarget2, dParent);
}

function test13_nerdamer() {
	nerdamer.setVar('M', 'matrix([1, 5], [4, 4])');
	var x = nerdamer('invert(M)');
	console.log(x.toString(), typeof x, x);
	var r = nerdamer('polarform(b*x+x*c*i)');
	console.log(r.toString());
	var t = nerdamer('polarform(5+i)')
	console.log(t.toString());
	nerdamer.setVar('M', 'matrix([x,y],[a,b])');
	console.log(nerdamer('transpose(M)').toString());
	nerdamer.setVar('M', 'matrix([4,5],[1,7])');
	x = nerdamer('determinant(M)');
	console.log(x.toString(), Number(x), typeof x, typeof Number(x), Number(x) + 1);
	console.log('==>', parseFloat(x));
	var x = nerdamer('limit(x^x-1,x,0)');
	console.log(x.toString());
	var y = nerdamer('limit((x^2+2*x-3)/(x^6+4),x,0)');
	console.log(y.toString());
	var x = nerdamer('solve(x^3+1, x)');
	console.log(x.toString());
	x = nerdamer.solve('x^2+2*x+1', 'x');
	console.log(x.toString());
	x = nerdamer.solve('3*(x+a)*(x-b)', 'x');
	console.log(x.toString());
	x = nerdamer.solve('3*(x+a)*(x-b)', 'x');
	console.log(x.toString());
	x = nerdamer('solve(x^4=1,x)');
	console.log(x.toString());
	x = nerdamer('solve(y=m*x+c, x)');
	console.log(x.toString());
	x = nerdamer.solve('x^2-1', 'x');
	console.log(x.toString());
	x = nerdamer.max(1, 4, 3, 5);
	console.log(x.toString());
	var x = nerdamer('sqcomp(9*x^2-18*x+17)');
	console.log(x.toString());
	var y = nerdamer('sqcomp(a*x^2+b*x-11*c, x)');
	console.log(y.toString());
	var x = nerdamer('roots(x^2-3*x-10)');
	console.log(x.toString())
	var y = nerdamer('roots(x^2+1)');
	console.log(y.toString());
	var x = nerdamer('divide(x^2+2*x+1, x+1)');
	console.log(x.toString())
	var y = nerdamer('divide(-b*z-a*z+b^3+a*b^2+a*b+a^2, b+a)');
	console.log(y.toString());
	var x = nerdamer('gcd(x^2+2*x+1, x^2+6*x+5)');
	console.log(x.toString())
	var y = nerdamer('gcd(b*z+a*z+b^2+a*b, a+b)');
	console.log(y.toString());
	var z = nerdamer('gcd(24,12,552)');
	console.log(z.toString());
	var x = nerdamer('product(x+1, x, 1, 20)');
	console.log(x.toString())
	var y = nerdamer('product(x+y, x, 1, 5)');
	console.log(y.toString());
	var z = nerdamer('product(x, x, 1, 5)');
	console.log(z.toString());
	var x = nerdamer('sum(x+1, x, 1, 5)');
	console.log(x.toString())
	var y = nerdamer('sum(x+y, x, 1, 20)');
	console.log(y.toString());
	console.log('_______simplify')
	var x = nerdamer('simplify((x^2+4*x-45)/(x^2+x-30))');
	console.log(x.toString());
	var y = nerdamer('simplify((17/2)*(-10+8*i)^(-1)-5*(-10+8*i)^(-1)*i)');
	console.log(y.toString());
	var z = nerdamer('simplify(1+1+3+5+13)');
	console.log(z, typeof z, Number(z) + 1);
	console.log('_______ defint')
	var x = nerdamer('defint(e^(cos(x)), 1, 2)');
	console.log(x.text());
	var y = nerdamer('defint(x^2+2*x+1,0, 10)');
	console.log(y.text());
	var y = nerdamer('defint(log(2cos(x/2)),-Ï,Ï,x)');
	console.log(y.text());
	console.log('_______ derivative diff')
	var x = nerdamer('diff(cos(x)*sin(x), x)');
	console.log(x.toString());
	var y = nerdamer('diff([x^2, cos(x), 1], x, 2)');
	console.log(y.toString());
	var y = nerdamer('diff(x^3+a*x^3+x^2, x, 2)');
	console.log(y.toString());
	x = nerdamer.diff(nerdamer('x^2').add(1).multiply('tan(x)'), 'x')
	console.log(x.toString());
	x = nerdamer('diff(a+b*x+c*x^2, x)');
	console.log(x.toString());
	x = nerdamer('diff(x^2, x)');
	console.log(x.toString());
	var x = nerdamer('sin(9+5)');
	console.log(x.toString());
	console.log(x.evaluate().toString());
	var x = nerdamer('integrate(x*2,x)');
	console.log(x.toString());
	y = x.evaluate();
	console.log('eval:', y);
	var x = nerdamer('integrate(10*q/(4*x^2+24*x+20), x)');
	console.log(x.toString());
	var y = nerdamer('integrate(sec(x)^2, x)');
	console.log(y.toString());
	var y = nerdamer('integrate([sec(x)^2, x^2, 2], x)');
	console.log(y.toString());
	var x = nerdamer('integrate(cos(x)*x^6, x)');
	console.log(x.toString());
	console.log(x.hasIntegral());
	x = nerdamer.integrate('sinh(x)*e^x');
	console.log(x.toString());
	var e = nerdamer('x^2+2*(cos(x)+x*x)', { x: 6 }).evaluate();
	var e = nerdamer('x^2+2*(cos(x)+x*x)', { x: 6 });
	var e = nerdamer('x^2+2*(cos(x)+x*x)', { x: 6 }).evaluate();
	console.log(e.text());
	console.log(e);
	var e = nerdamer('x^2+2*(cos(x)+x*x)');
	console.log(e.text());
	console.log(e);
	var result = nerdamer('cos(x)', { x: 6 });
	console.log(result.text());
	var result = nerdamer('cos(x)', { x: 6 }, 'numer');
	console.log(result.text());
	var result = nerdamer('cos(x)', { x: 6 }).evaluate();
	console.log(result.text());
	var f = nerdamer('integrate(x,x)').buildFunction();
	console.log(f(3));
	f = nerdamer('diff(x^3,x)').buildFunction();
	console.log(f(20));
}

function test13_simpleDD() {
	document.body.style.height = '100vh';
	let dParent = addDivToBody();
	dParent.id = 'dParent';
	let d = addDivPosTo(dParent, 20, 50, 200, 200, unit = 'px', bg = 'red');
	let purpleTarget = addDivPosTo(dParent, 250, 50, 300, 200, unit = 'px', bg = 'purple');
	let greenTarget = addDivPosTo(purpleTarget, 50, 50, 200, 120, unit = 'px', bg = 'green');
	let pic = createPicto({ key: 'whistle', parent: d, bg: 'yellow', border: '1px solid green', rounding: 12 });
	pic.type = 'pic';
	makeDraggable(pic);
	makeDroppable(purpleTarget);
	dropPosition = (ev, elem, target) => { posOverlap(elem, target, 10, 5, 'type'); };
}

function test13_simpleDDMultiple() {
	let dParent = addDivToBody();
	dParent.id = 'dParent';
	let purpleTarget = addDivPosTo(dParent, 250, 50, 300, 200, unit = 'px', bg = 'purple');
	let greenTarget = addDivPosTo(purpleTarget, 50, 50, 200, 120, unit = 'px', bg = 'green');
	let d = addDivPosTo(dParent, 20, 50, 200, 200, unit = 'px', bg = 'red');
	for (let i = 0; i < 7; i++) {
		let k = getRandomKey(iconChars);
		let pic = createPicto({ key: k, parent: d, bg: 'yellow', border: '1px solid green', rounding: 12 });
		pic.type = 'pic';
		posOverlap(pic, d, 120, 0, 'type');
		makeDraggable(pic);
	}
	makeDroppable(purpleTarget);
	dropPosition = (ev, elem, target) => { posOverlap(elem, target, 10, 5, 'type'); };
}

function test14() {
	show_emos();
	say('what do you feel right now???', 'uk', null, .5, .8);
}

function test14_divPosTest() {
	let dParent = addDivToBody();
	dParent.style.setProperty('float', 'right');
	dParent.style.setProperty('margin', '10px');
	setDivBg(dParent, 'green');
	setDivSize(dParent, 300, 200);
	let d = addDivPosTo(dParent, 20, 50, 100, 100, unit = 'px', bg = 'red');
}

function test14_factory() {
	let d = mSym('frog', 'map');
}

function test14_function() {
	C = new Plotter(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc');
	C.add({ astep: .1, a: 0, bstep: .1, b: 0, color: 'skyblue', thickness: 1, basefunc: x => -x * (-Math.sign(x)), func: x => Math.sin(x), update: oscillator });
	C.play();
}

function test15_addDivU() {
	let dParent = addDivU({ dParent: document.body, bg: 'yellow', margin: 10, w: 300, h: 200, unit: 'px', float: 'right' });
	let d = addDivU({ dParent: dParent, x: 20, y: 50, w: 100, h: 100, unit: 'px', position: 'absolute', bg: 'red' });
}

function test15_fa_list() {
	dTable = mBy('map');
	let animations = ['beat', 'bounce', 'fade', 'flip', 'pulse', 'shake', 'spin'];
	let iani = 0;
	let list = Info.fa;
	for (const w of arrTake(list, 25)) {
		let an = 'pulse';
		let d = mDiv(dTable, { align: 'center', bg: 'blue', margin: 8, fg: 'white', display: 'inline-block', padding: 10 }, null, `<i class="fa fa-${w} fa-${an} fa-3x"></i><br>${w}`);
	}
}

function test15_function() {
	C = new Plotter(dTable);
	C.add({ color: 'skyblue', thickness: 1, func: x => Math.sin(x) });
	C.draw();
}

function test15_qa() {
	G = {
		i: 0,
		q: null,
		alist: null,
		selist: null,
		hist: [],
		stcont: { box: true, wmin: 600 },
		sta: { cursor: 'pointer', aitems: 'center', vpadding: 6, hpadding: 12, gap: 4, margin: 6, rounding: 12, fg: 'contrast' },
		stq: { padding: 12, weight: 'bold', family: 'opensans', fz: 28 },
	};
	q0();
}

function test16_fa_animation() {
	dTable = mBy('map');
	let fa = rChoose(Info.fa);
	mCenterCenterFlex(dTable); mStyle(dTable, { bg: 'white', position: 'relative' });
	let d0 = mDiv(dTable); mStyle(d0, { rounding: '50%', align: 'center', bg: 'blue', fg: 'white', display: 'inline-block' })
	let dfa = mDiv(d0, { padding: 40, }, null, `<i class="fa fa-${fa} fa-2x"></i>`);
}

function test16_function() {
	C = new Plotter(dTable);
	C.add({ color: 'skyblue', thickness: 1, func: nerdamer('integrate(x,x)').buildFunction() });
	C.draw();
}

function test16_g() {
	let dParent = addDivToBody();
	let g1 = addGFill('g1', dParent);
	let g2 = d3.select(g1).append('g').attr('fill', 'yellow').attr('stroke', 'black').attr('stroke-width', 5);
	g2.append('rect').attr('width', '50px').attr('height', '50px');
	let g3 = d3.select(g1).append('g').attr('fill', 'red').attr('stroke', 'white').attr('stroke-width', 5);
	let r3 = g3.append('rect').attr('width', '50%').attr('height', '50px');
	g3.node().style.transform = 'translate(-10px, -200px)';
	let g = g3.node();
	g.classList.add('green');
	g.classList.add('yellowStroke');
	let cl = g.classList;
	console.log(cl, typeof cl, cl.value, typeof cl.value);
	let cl2 = g.getAttribute('class')
	console.log(cl2, typeof cl2);
	console.log(g.getAttribute('class'))
	g.classList.remove('yellowStroke');
	let boundsG1 = getBounds(g1);
	let boundsG2 = getBounds(g2.node());
	let boundsG2_rel = getBounds(g2.node(), true);
	let boundsG3 = getBounds(g3.node());
	let boundsG3_rel = getBounds(g3.node(), true);
	let boundsDiv = getBounds(dParent);
	console.log('boundsG1', boundsG1)
	console.log('boundsG2', boundsG2)
	console.log('boundsG2_rel', boundsG2_rel)
	console.log('boundsG3', boundsG3)
	console.log('boundsG3_rel', boundsG3_rel)
	console.log('boundsDiv', boundsDiv)
	return;
	d3.select(g2).style('transform', 'translate(50%, 50%)')
	//first import d3.js: <script src="https://d3js.org/d3.v5.min.js"></script>
	let r = d3.select(g1).attr('fill', 'red').append('rect').attr('width', '100px').attr('height', '100px');
	console.log('g1', d3.select(g1).node());
	console.log('r', r.node());
	let rect = d3.select(g1.children[0]);
	console.log(rect, r);
	r.attr('stroke', 'green').attr('stroke-width', 5).attr('rx', 20).attr('ry', 20);
}

function test16_yt() {
	playt();
}

function test17_load_save_texte() {
	mStyle(dTable, { h: '100%', family: 'opensans', fz: 20, bg: ORANGE, fg: 'white', position: 'relative' }); mCenterFlex(dTable);
	let buttons = ['clear', 'magic'];
	dToolbar = mToolbar(buttons, onclick_toobar, 'dToolbar', { padding: 10, display: 'flex', gap: 10, bg: 'orange' });
	document.addEventListener('mouseleave', e => { console.log('page mouse left!!!'); save_all(); })
	document.addEventListener('visibilitychange', e => { if (document.visibilityState === 'visible') { console.log('page activated!'); } else { console.log('page deactivated!!!'); save_all(); } });
	load_all();
	onclick = open_invisible_input;
}

function test17_randomwalk() {
	C = new CCanvasNoClear(dTable, {}, {}, gameloop_start, gameloop_stop);
	C.add({ update: move_random, w: 2, h: 2 });
	C.add(new CItemWalker({ label: 'tom' }))
	C.play();
}

function test1ttt() {
	let board = new Board(dTable, 4, 4, ev => {
		let field = Items[ev.target.id];
		console.log('field', field);
		if (isdef(field.content)) return;
		let item = { field: field, container: ev.target, styles: { bg: 'red', w: 30, h: 30, rounding: '50%' } };
		game_add_item(item);
	});
}

function test2() {
}

function test2_2rows() {
	var dMain = document.getElementById('dMain');
	let dHeader = mDiv(dMain, {}, 'dHeader', 'header', ['div1']);
	let dOuter = mDiv(dMain, {}, 'dOuter', 'outer', ['div2']);
}

function test2_ari_deck_and_hand(otree) {
	let deck = ui_make_random_deck(10);
	let hand = ui_make_random_hand(1);
	let d = iDiv(deck.topmost);
	deck.items.map(x => { mStyle(iDiv(x), { cursor: 'pointer' }); iDiv(x).onclick = () => anim_from_deck_to_hand(x, deck, hand); });
}

function test2_boa_verify() {
	mAppear('dScreen', 100);
	if (FirstLoad) { FirstLoad = false; initialize_state(); }
	get_toolbar();
	onclick_location('boa');
	boaverify_start();
}

function test2_nerd() {
	var core = nerdamer.getCore();
	var _ = core.PARSER;
	core.Math2.custom = function (x) { return (100 * formula1(x)).toFixed(4); };
	_.functions.custom = [, 1];
	var x = nerdamer('custom(140)').evaluate();
	console.log(x.toString());
	let fi = nerdamer(`integrate(custom(x),x)`).buildFunction();
	let y = fi(100);
	console.log('fi(100)', y)
}

function test2_onclick_user() {
	let ms = 300;
	show_users(300);
	setTimeout(() => onclick_user('felix'), 400);
}

function test2_p5_perlin() {
	dTable = mBy('dTable'); mCenterFlex(dTable);
	let o = mCanvas(dTable, { w: 600, h: 400 }, {}, startloop, pauseloop, 'cc');
	iAdd(o, {}, { draw: draw_perlin_x });
	o.play();
}

function test2_pic_dicts() {
	create_pic_dicts(['d']);
}

function test2_point_nomath() {
	C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop);
	C.add();
	C.add({ x: -200, y: 100, color: 'pink', draw: draw_point });
	C.draw();
	C.play();
}

function test2_show_contacts() {
	get_login();
}

function test2_sit_around_table() {
	dTable = mBy('dTable');
	let r = getRect(dTable);
	let sz = 250;
	let pts = cCircle({ x: r.w / 2, y: r.h / 2 }, r.w - sz, 6, -90);
	for (const pt of pts) {
		console.log('pt', pt)
		mDiv(dTable, { round: true, x: pt.x - sz / 2, y: pt.y - sz / 2, position: 'absolute', w: sz, h: sz, bg: 'randdark' });
	}
}

async function test2_two_maps() {
	let [cities, capitals] = await get_cities_and_capitals();
	let o = { center: cities.Paris.center, zoom: 7, id: 'map' };
	let m1 = create_map(jsCopy(o));
	copyKeys({ id: 'map2', preferCanvas: true }, o);
	let m2 = create_map(o);
	let a1 = create_agent(m1);
	let a2 = create_agent(m2);
	let f1 = x => x + rFloat(-.01, .05);
	let f2 = x => x + rGaussian(-.01, .05);
	run_for_seconds(2, () => { map_moveby(a2, f2, f2); map_moveby(a1, f1, f1); })
}

function test2_waypointfallback() {
	var map = L.map('map');
	L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
		attribution: 'Â© OpenStreetMap contributors'
	}).addTo(map);
	console.log('geo', Geo)
	let [p1, p2] = [Geo.places.tuerkenschanzpark, Geo.places.vegagasse];
	map.setView(p1, 16)
	M = L.Routing.control({
		waypoints: [
			L.latLng(p1[0], p1[1]),
			L.latLng(p2[0], p2[1])
		],
		waypointNameFallback: function (latLng) {
			function zeroPad(n) {
				n = Math.round(n);
				return n < 10 ? '0' + n : n;
			}
			function sexagesimal(p, pos, neg) {
				var n = Math.abs(p),
					degs = Math.floor(n),
					mins = (n - degs) * 60,
					secs = (mins - Math.floor(mins)) * 60,
					frac = Math.round((secs - Math.floor(secs)) * 100);
				return (n >= 0 ? pos : neg) + degs + 'Â°' +
					zeroPad(mins) + '\'' +
					zeroPad(secs) + '.' + zeroPad(frac) + '"';
			}
			return sexagesimal(latLng.lat, 'N', 'S') + ' ' + sexagesimal(latLng.lng, 'E', 'W');
		},
		routeWhileDragging: true
	}).addTo(map);
}

function test20_aspect_ratio_image_card() {
	let d = mDiv(dTable, { display: 'grid', place: 'center', h: '100%' });
	let dcard = mDiv(d, { w: '50%', display: 'flex', dir: 'column', padding: '1rem' }, null, null, 'blue');
	let dtitle = mTag('h1', 'Video Title', dcard);
	let dimg = mDiv(dcard, { aspectRatio: '16 / 9' }, null, null, 'green');
	let ddesc = mTag('p', 'Descriptive Text goes here', dcard);
	return d;
}

function test20_imagePalette(dTable) {
	let pal = colorPaletteFromUrl('../base/assets/images/happy/ocean1.jpg');
	let hslist = pal.map(x => colorHSL(x, true));
	let i = 0; hslist = hslist.map(x => ({ h: x.h, s: x.s, l: x.l, color: pal[i], ipal: i++ }))
	i = 0; let byhue = sortBy(hslist, 'h').map(x => ({ color: x.color, ipal: x.ipal, ihue: i++, h: x.h, s: x.s, l: x.l }));
	i = 0; let bylum = sortBy(byhue, 'l').map(x => ({ color: x.color, ilum: i++, ihue: x.ihue, h: x.h, s: x.s, l: x.l }));
	let dmax = 0, c1max, c2max;
	let dlist = [];
	for (let i = 0; i < bylum.length - 1; i++) {
		for (let j = i + 1; j < bylum.length; j++) {
			let [c1, c2] = [bylum[i], bylum[j]];
			let d = colorDistance1(c1, c2);
			dlist.push({ c1: c1, c2: c2, d: d });
			if (d > dmax) { dmax = d; c1max = c1; c2max = c2; }
		}
	}
	sortByDescending(dlist, 'd');
	let lums = [2, 9];
	let hues = [6, 7];
	dlist = dlist.filter(x => x.d >= 30 && (lums.includes(x.c1.ilum) || hues.includes(x.c2.ihue)));
	console.log('===>result', dlist)
	let bestof = arrTake(dlist, 5);
	let crand = rChoose(bestof);
	mStyle(mBy('dAdmin'), { bg: crand.c2.color, fg: crand.c1.color });
	console.log('chosen:', crand.c1.color, crand.c2.color, crand.d);
}

function test21_centering_container() {
	let d = mDiv(dTable, { bg: 'yellow', w: '100%', h: '100%' }); mCenterCenter(d);
	let d1 = mDiv(d, { bg: 'red', 'place-content': 'center', w: '80%', display: 'grid', 'grid-template-columns': 'repeat(auto-fill, 100px)', 'grid-gap': '1rem' });
	for (let i = 0; i < 14; i++) {
		mDiv(d1, { w: rNumber(50, 150), h: 100, bg: 'random', margin: 10 });
	}
}

function test21_resizable() {
}

function test22_centering_container() {
	let d = mDiv(dTable, { bg: 'yellow', w: '100%', h: '100%', aitems: 'center' }); mCenterCenter(d);
	for (let i = 0; i < 14; i++) {
		mDiv(d, { display: 'inline-block', w: rNumber(50, 150), h: rNumber(50, 150), bg: 'random', margin: 10 });
	}
}

function test3() { test1(); }

function test3_3rows() {
	var dMain = document.getElementById('dMain');
	let dHeader = mDiv(dMain, { bg: 'random' }, 'dHeader', 'header');
	let dOuter = mDiv(dMain, { bg: 'random', flex: '1 0 auto' }, 'dOuter', 'outer');
	let dFooter = mDiv(dMain, { bg: 'random' }, 'dFooter', 'footer');
	mSize(dHeader, '100%', 50);
}

function test3_add_cities_layer(color) {
	let cities = rChoose(M.capitals, 20);
	for (const c of cities) map_add_city(M.cities[c]);
}

function test3_ari_deck_2_hands(otree) {
	let deck = ui_make_random_deck(10);
	let hand1 = ui_make_random_hand(1);
	let hand2 = ui_make_random_hand(1);
	let d = iDiv(deck.topmost);
	top_card_to_hands_abwechselnd(deck, hand1, hand2);
}

async function test3_better_agent() {
	M = create_map();
	console.log('M', M);
	let agent = new Agent(M, .0001, false);
	let c1 = create_button(M.map, 'hallo')
	let c2 = create_button(M.map, 'h2')
	let c3 = create_button(M.map, 'h3')
	console.log('buttons', c1, c2, c3)
}

function test3_boa_havecode() {
	mAppear('dScreen', 100);
	if (FirstLoad) { FirstLoad = false; initialize_state(); }
	get_toolbar();
	onclick_location('boa');
	S.boa_authorization_code = '123456';
	boahavecode_start();
}

function test3_cdf() {
	y = cumulative_distribution(85, 115, 100, 15);
	y = cumulative_distribution(105, 115, 100, 15);
	return;
	console.log('y', y); return;
	for (let x = 0; x <= 150; x += 25) {
		let y = cdf0(x);
		console.log('x', x, 'y', y)
	}
}

function test3_game_options() {
	present_game_options();
	close_sidebar();
}

async function test3_letters(l, n) {
	let text = await route_path_text(`../base/assets/words/${l}dict.txt`);
	let picdi = await route_path_yaml_dict(`../base/assets/words/${l}picdict.yaml`);
	let splitter = l == 'e' ? '\r\n' : '\n';
	let words = text.split(splitter);
	let result = words.filter(x => x.length == n);
	let result2 = result.filter(x => x in picdi);
	return { all: result, pic: result2 };
}

function test3_mapbounds() {
	var map = L.map('map');
	map.setView(Geo.places.vegagasse, 16)
	L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
		attribution: 'Â© OpenStreetMap contributors'
	}).addTo(map);
	let b = map.getBounds();
	console.log('b', b._southWest, b._northEast);
	let [p1, p2] = [[b._southWest.lat, b._southWest.lng], [b._northEast.lat, b._northEast.lng]];
	M = get_route_control(map, p1, p2);
}

function test3_p5_perlin_2d() {
	dTable = mBy('dTable'); mCenterFlex(dTable);
	let o = mCanvas(dTable, { w: 600, h: 400 }, {}, startloop, pauseloop, 'cc');
	iAdd(o, {}, { draw: draw_perlin_xy });
	o.play();
}

function test3_point_math() {
	C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc', null, true);
	C.add();
	C.add({ x: 50, y: 80, color: 'pink', draw: draw_point, update: update_move });
	C.add({ x: 50, y: -80, color: 'red', draw: draw_car, update: update_car, v: { a: 0, mag: 5 } });
	C.draw();
	C.play();
}

function test3_show_tables() {
	phpPost({ app: 'easy' }, 'tables');
}

function test3_sit_around_table(n = 4) {
	dTable = mBy('dTable');
	let r = getRect(dTable);
	let [w, h] = [r.w * .9, r.h * .9];
	let [offx, offy] = [r.w * .05, r.h * .05];
	let mindim = Math.min(w, h);
	let [szTable, szPlayer] = [mindim / 2, mindim / 4];
	let pTable = { x: offx + w / 2 - szTable / 2, y: offy + h / 2 - szTable / 2 };
	let styles = { round: true, x: pTable.x, y: pTable.y, position: 'absolute', w: szTable, h: szTable, classname: 'wood' };
	let d = mDiv(dTable, styles);
	let table = iAdd({ numplayers: n, styles: styles }, { div: d })
	let numPlayers = n;
	let sz = szPlayer;
	let pts = cCircle({ x: offx + w / 2, y: offy + h / 2 }, w - sz, numPlayers);
	console.log('pts', pts);
	let players = [];
	for (const pt of pts) {
		let [x, y] = [pt.x - sz / 2, pt.y - sz / 2];
		styles = { round: true, x: x, y: y, position: 'absolute', w: sz, h: sz, bg: colorFrom('randdark') };
		d = mDiv(dTable, styles);
		let player = iAdd({ styles: styles }, { div: d });
		players.push(player);
	}
	return [table, players];
}

function test4() { test2(); }

function test4_3rows() {
	var dMain = document.getElementById('dMain');
	let dHeader = mDiv(dMain, { bg: 'random' }, 'dHeader', 'header');
	let dOuter = mDiv(dMain, { bg: 'random', flex: '1 0 auto', display: 'flex', 'flex-flow': 'row wrap' });
	let dLeft = mDiv(dOuter, { bg: 'random', flex: '0 0 200px' }, 'dLeft', 'left');
	let dMiddle = mDiv(dOuter, { bg: 'random', flex: '1 0 auto' }, 'dMiddle', 'middle');
	let dRight = mDiv(dOuter, { bg: 'random', flex: '0 0 200px' }, 'dRight', 'right');
	let dFooter = mDiv(dMain, { bg: 'random' }, 'dFooter', 'footer');
	mSize(dHeader, '100%', 50);
}

function test4_ari_deck_2_fixed_size_hands(otree) {
	let deck = ui_make_random_deck(10);
	mLinebreak(dTable);
	let hand1 = ui_make_random_hand(1); mStyle(hand1.container, { w: '50%' });
	let hand2 = ui_make_random_hand(1); mStyle(hand2.container, { w: '50%' });
	let d = iDiv(deck.topmost);
	top_card_to_hands_abwechselnd(deck, hand1, hand2);
}

function test4_boa_main() {
	mAppear('dScreen', 100);
	if (FirstLoad) { FirstLoad = false; initialize_state(); }
	get_toolbar();
	onclick_location('boa');
	S.boa_authorization_code = '123456';
	boamain_start();
}

function test4_direct_login_onclick_user() {
	show_users();
	let uplayer = localStorage.getItem('uname');
	if (isdef(uplayer)) onclick_user(uplayer);
}

function test4_get_waypoints(mymap, p1, p2) {
	var routeData = L.Routing.control({
		waypoints: points_to_waypoints(p1, p2),
		lineOptions: { styles: [{ color: '#006a4e', opacity: 1, weight: 5 }], },
		draggableWaypoints: false,
		createMarker: function () { return false; },
		show: false,
	}).addTo(mymap);
	var routeArray = new Array();
	routeArray = routeData.getWaypoints();
	console.log(routeArray);
	return routeData;
	L.motion.polyline([[52.501737, -2.119792], [52.501267, -2.114707], [52.500313, -2.110361], [52.499243, -2.108751], [52.498596, -2.105886], [52.498812, -2.104953], [52.498798, -2.102591]], {
		color: "transparent"
	}, {
		auto: true,
		duration: 30000,
		easing: L.Motion.Ease.easeInOutQuart
	}, {
		removeOnEnd: false,
		showMarker: true,
		icon: L.icon({ iconUrl: 'marker.png', iconSize: [32, 37] })
	}).addTo(mymap);
}

function test4_intelli() {
	dTable = dTable = mSection({ position: 'relative' }, 'dTable'); mCenterFlex(dTable);
	let ta = mTextarea(10, 90, dTable, { padding: 20, position: 'relative' });
	setTimeout(() => ta.autofocus = true, 10);
	let buttons = mDiv(dTable, { w: '100%', align: 'right', maright: 4 });
	let st = { fz: 14 };
	maButton('RUN (ctl+Enter)', au_run, buttons, st);
	maButton('LINE (ctl+shft+Enter)', au_run_line, buttons, st);
	let tacon = mTextarea(3, 90, dTable, { matop: 4, padding: 20, position: 'relative' });
	ta.focus();
	AU.popup = mDiv(dTable, { position: 'absolute', wmin: 100, hmin: 100, hmax: 600, overy: 'auto', bg: 'blue', fg: 'white' });
	hide(AU.popup)
	AU.fnames = get_keys(CODE.funcs); AU.fnames.sort();
	AU.list = [];
	AU.prefix = '';
	AU.selected = null;
	AU.n = -1;
	AU.ta = ta;
	AU.tacon = tacon;
	ta.onkeydown = ev => {
		let k = ev.key;
		if (k == 'Enter' && AU.selected) ev.preventDefault();
	}
	ta.onkeyup = ev => {
		let k = ev.key;
		let fnames = AU.fnames;
		let popup = AU.popup;
		if (k == 'Enter' && ev.ctrlKey) {
			au_reset();
			let code = ev.shiftKey ? getTextAreaCurrentLine(AU.ta) : AU.ta.value;
			runcode(code);
		} else if (k == ' ' || k == ')') {
			AU.previous = AU.prefix;
			if (isdef(AU.fnames[AU.previous])) {
				let w = AU.selected = AU.previous;
				AU.uebernommen = CODE.funcs[w];
				popup.innerHTML = AU.previous + '(' + AU.uebernommen.params + ')';
			} else {
				au_reset();
			}
		} else if (k == 'Enter' && AU.selected) {
			let w = AU.selected.innerHTML;
			let s = stringAfter(w, AU.prefix);
			AU.ta.value = AU.ta.value + s;
			AU.uebernommen = CODE.funcs[w];
			popup.innerHTML = w + '(' + AU.uebernommen.params + ')';
		} else if (k == 'Backspace' && AU.prefix.length > 1) {
			AU.prefix = AU.prefix.slice(0, -1);
			au_show_list();
		} else if (k == 'ArrowDown' && !isEmpty(AU.list)) {
			if (AU.n < AU.list.length - 1) AU.n++;
			let ch = popup.children;
			if (AU.selected) mStyle(AU.selected, { bg: 'blue' });
			AU.selected = ch[AU.n];
			mStyle(AU.selected, { bg: 'green' });
		} else if (k == 'ArrowUp' && !isEmpty(AU.list)) {
			if (AU.n > 0) AU.n--;
			let ch = popup.children;
			if (AU.selected) mStyle(AU.selected, { bg: 'blue' });
			AU.selected = ch[AU.n];
			mStyle(AU.selected, { bg: 'green' });
		} else if (isLetter(k) || k == '_') {
			if (isEmpty(AU.prefix)) AU.selectionEnd = AU.ta.selectionEnd;
			AU.prefix += k;
			au_show_list();
		} else if (k != 'Shift') {
			au_reset();
		}
	}
}

function test4_load_games() {
}

async function test4_multiple_wordlists() {
	for (const l of ['e', 'd', 's', 'f']) {
		for (let i = 6; i < 15; i++) {
			let res = await test3_letters(l, i);
			let s = `${l} ${i} ${res.all.length} (davon: ${res.pic.length} ${Math.round((res.pic.length / res.all.length) * 100)}%)`;
			console.log('', s);
		}
		console.log('________');
	}
}

function test4_range_math_GEHT_NICHT() {
	C = new MathCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc', 10);
	let x = colorMix('yellow', 'red'); console.log('color', x)
	let p1 = C.point(5, 3, 'yellow');
	let p2 = C.point(25, 12, 'red');
	for (let i = 0.1; i < .9; i += .1) {
		let p3 = lerpoint(p1, p2, i);
		C.add(p3);
	}
	C.draw();
}

function test4_save() {
	let [table, players] = test3_sit_around_table(3);
	serialize_all();
}

function test4_tools() {
	let map = create_map();
	console.log('map', map);
	let d = map._controlContainer;
	console.log('control container', d);
	dMap = mDiv(d, { position: 'absolute', top: 0, left: 50, w: '100%', h: '100%' });
	dMap.style.zIndex = 12000;
	dTop = mDiv(dMap, { hmargin: 10, padding: 10, cursor: 'pointer' }, null, null, 'top'); mFlexWrap(dTop);
	let b = mButton('hallo', dummy_reaction, dTop);
	b = mButton('download', () => downloadJson({ hallo: 4343 }, '__test'), dTop);
	let a = mLink("http://duckduckgo.com", dTop, { color: 'dimgray' }, null, 'ein link');
	a = mLink("javascript:void(0)", dTop, { color: 'dimgray' }, null, 'ein link');
	a.onclick = dummy_reaction;
	b = mButton('Paris', () => map.setView(Geo.cities.Paris.center), dTop);
	b = mButton('London', () => map.flyTo(Geo.cities.London.center), dTop);
	let agent = new Agent(map, .0001, false);
	return;
	let x = create_toolbar(map); console.log('toolbar', x)
	let tb = x._container; console.log('toolbar', tb);
	mButton('click', () => console.log('clicked!'), tb, { cursor: 'pointer' })
}

function test5(map, p1, p2) {
	let control = M.control = test4_get_waypoints(map, p1, p2);
	M.coords = [];
	control.on('routeselected', function (e) {
		arrExtend(M.coords, e.route.coordinates);
		console.log('M', M)
	});
}

function test5_33mitMenuButtons() {
	let page = pageLayout33();
	let bMenuRight = stdMenuButton();
	mRight(page.dHeader, bMenuRight);
	let bMenuLeft = stdMenuButton();
	mLeft(page.dHeader, bMenuLeft);
}

function test5_ari_anim_deal_market(otree) {
	let deck = ui_make_random_deck(50);
	let market = ui_make_random_market(1);
	mLinebreak(dTable);
	let hand1 = ui_make_random_hand(7); mStyle(hand1.container, { w: '50%' });
	let hand2 = ui_make_random_hand(7); mStyle(hand2.container, { w: '50%' });
	top_card_to_market(deck, market);
}

function test5_bw_skin() {
	mAppear('dScreen', 100);
	if (FirstLoad) { FirstLoad = false; initialize_state(); }
	get_toolbar();
	bw_widget_popup('skype');
}

async function test5_letters_upto(l, n) {
	let text = await route_path_text(`../base/assets/words/${l}dict.txt`);
	let picdi = await route_path_yaml_dict(`../base/assets/words/${l}picdict.yaml`);
	let splitter = l == 'e' ? '\r\n' : '\n';
	let words = text.split(splitter);
	let result = words.filter(x => x.length >= 3 && x.length <= n);
	let result2 = result.filter(x => x in picdi);
	return { all: result, pic: result2 };
}

function test5_line_GEHT_NICHT() {
	C = new MathCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc', 10);
	let p1 = C.point(5, 3, 'yellow');
	let p2 = C.point(25, 12, 'red');
	for (let i = 0; i < 1; i += .01) {
		let p3 = lerpoint(p1, p2, i);
		C.add(p3);
	}
	C.draw();
}

function test5_load() {
	dTable = mDiv('dTable');
	load_all();
}

function test5_prelim() { }

function test5_showroute() {
	let map = M.map = create_map();
	let agent = M.agent = new Agent(map, .0001, false);
	let tb = M.toolbar = create_toolbar(map);
	let pts = [Geo.places.tuerkenschanzpark, Geo.places.vegagasse]
	let color = 'green';
	let callback = e => fit_points(map, pts);
	let control = M.router = show_route(map, pts, color, callback);
}

function test52CardsOther() {
	keys = ['spades', 'hearts', 'clubs', 'diamonds'];
	for (let i = 0; i < 4; i++) {
		let k = keys[i % keys.length];
		console.log('k', k);
		let card = Karte.random(k, 110);
		mAppend(dTable, iDiv(card));
	}
}

function test6(map, p1, p2) {
	let control = M.control = L.Routing.control({
		waypoints: points_to_waypoints(p1, p2),
		lineOptions: { styles: [{ color: '#006a4e', opacity: 1, weight: 5 }], },
		draggableWaypoints: false,
		createMarker: function () { return false; },
		show: false,
	}).addTo(map);
	M.coords = [];
	control.on('routesfound', function (e) {
		M.routes = e.routes;
		M.num_requests = e.target._requestCount;
		M.coords = arrExtend(M.coords, e.routes[0].coordinates);
		console.log('M', M)
	});
}

function test6_33mitMenuButtons() {
	let page = pageLayout33();
	let bMenuRight = stdMenuButton();
	mRight(page.dHeader, bMenuRight);
	let bMenuLeft = stdMenuButton();
	mLeft(page.dHeader, bMenuLeft);
	dLeft.style.flex = 'unset';//'1 1 200px';
	bMenuLeft.onclick = () => {
		mStyle(mBy('dLeft'), { wmin: 0, w: 0 });
	}
}

function test6_ari_anim_auto_deal(otree) {
	let deck = ui_make_random_deck(50);
	let market = ui_make_random_market(0);
	mLinebreak(dTable);
	let hand1 = ui_make_random_hand(7); mStyle(hand1.container, { w: '50%' });
	let hand2 = ui_make_random_hand(7); mStyle(hand2.container, { w: '50%' });
	top_card_to_market(deck, market);
}

function test6_click() {
	let map = M.map = create_map({ zoom: 16 });
	add_click_set_agent();
	let tb = M.toolbar = create_toolbar(map);
	mButton('route', () => {
		map.off('click');
		let pts = M.agents.map(x => x.pos);
		let color = 'red';
		let callback = e => fit_points(map, pts);
		M.router = show_route(map, pts, color, callback);
	}, tb);
	mButton('clear', () => { clear_router(); clear_agents(); add_click_set_agent(); }, tb);
}

function test6_func_GEHT_NICHT() {
	C = new MathCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc', 10);
	let f = x => Math.sqrt(x), d = .01;
	for (let x = C.minx; x < C.maxx; x += d) {
		let pt = C.point(x, f(x), 'yellow');
		C.add(pt);
	}
	C.draw();
}

function test6_generate_statement() {
	mAppear('dScreen', 100);
	if (FirstLoad) { FirstLoad = false; initialize_state(); }
	get_toolbar();
	generate_statement();
}

function test6_init() {
	let item = { styles: { bg: 'orange', w: 30, h: 30, round: true } };
	iInit(c1, item);
	iInit(c2, item);
	iInit(dTable, item);
	start_loop();
	setTimeout(() => item.styles.bg = BLUE, 2000);
}

async function test6_multiple_wordlists() {
	for (const l of ['e', 'd', 's', 'f']) {
		for (let i = 3; i < 15; i++) {
			let res = await test5_letters_upto(l, i);
			let s = `${l} ${i} ${res.all.length} (davon: ${res.pic.length} ${Math.round((res.pic.length / res.all.length) * 100)}%)`;
			console.log('', s);
		}
		console.log('________');
	}
}

function test6_sidebar() {
	show_sidebar(CODE.funcs, 'name', 'body');
}

function test7() {
	var dMain = document.getElementById('dMain');
	let dHeader = mDiv(dMain, { bg: 'random' }, 'dHeader', 'header');
	let [dLeft, dMiddle, dRight] = std3fold(dMain);
	let dFooter = mDiv(dMain, { bg: 'random' }, 'dFooter', 'footer');
	let bMenuLeft = stdMenuButton();
	mLeft(dHeader, bMenuLeft);
	stdSidebarController(bMenuLeft, 'dLeft');
	let bMenuRight = stdMenuButton();
	mRight(dHeader, bMenuRight);
	stdSidebarController(bMenuRight, 'dRight');
}

function test7_add_hand_card() {
	let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
	let card = prompt('enter card (eg. 8H');
	fen.players[uplayer].hand.push(card + 'n');
	take_turn_fen();
}

function test7_ari_anim_auto_deal(otree) {
	let deck = ui_make_random_deck(50);
	let market = ui_make_random_market(0);
	mLinebreak(dTable);
	let hand1 = ui_make_random_hand(7); mStyle(hand1.container, { w: '50%' });
	let hand2 = ui_make_random_hand(7); mStyle(hand2.container, { w: '50%' });
	DA.qanim = [
		[anim_from_deck_to_marketX, [deck, market]],
		[anim_from_deck_to_marketX, [deck, market]],
	];
	anim_from_deck_to_marketX(deck, market);
}

function test7_card() {
	dTable = mBy('dTable'); mCenterFlex(dTable);
	let x = ui_type_hand(['3Hn', '4Hn', '4Hl'], dTable); console.log('hand', x);
	iReg(x);
	let c = ari_get_card('QDn', 500); mAppend(dTable, iDiv(c));
	animatedTitle();
}

function test7_display_dims_on_moveend() {
	let map = M.map = create_map({ zoom: 16 });
	map.on('moveend', function (e) { calc_map_dims(); console.log("dims", M.dims); });
	let city = rChoose(M.capitals);
	console.log('city has been chosen:', city);
	map.flyTo(Geo.cities[city].center);
}

function test7_function() {
	C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'cc');
	let ctx = C.cx;
	let canvas = C.cv;
	let h = canvas.height;
	let w = canvas.width;
	let cw = w / 2;
	let ch = h / 2;
	let subStepCount = 10;
	let scale = 10;
	function plot(func, col, lineWidth) {
		let invScale = 1 / scale;
		let top = ch * invScale;
		let bottom = -ch * invScale;
		let subStep = invScale / subStepCount;
		let x, y, yy, xx, subX;
		let start = (-cw - 1) * invScale;
		let end = (cw + 1) * invScale;
		ctx.strokeStyle = col;
		ctx.lineWidth = lineWidth * invScale;
		ctx.beginPath();
		for (x = start; x < end; x += invScale) {
			for (subX = 0; subX < invScale; subX += subStep) {
				y = func(x + subX);
				if (yy !== undefined) {
					if (y > top || y < bottom) {
						if (yy < top && yy > bottom) {
							ctx.lineTo(x + subX, y);
						}
					} else {
						if (yy > top || yy < bottom) {
							ctx.moveTo(xx, yy);
						}
						if (subX === 0) {
							if (y > bottom && y < top) {
								if (Math.abs(yy - y) > (top - bottom) * (1 / 3)) {
									ctx.moveTo(x, y);
								} else {
									ctx.lineTo(x, y);
								}
							}
						}
					}
				} else {
					if (subX === 0) {
						ctx.moveTo(x, y);
					}
				}
				yy = y;
				xx = x + subX;
			}
		}
		ctx.stroke();
	}
	ctx.setTransform(scale, 0, 0, -scale, cw, ch);
	plot(x => 0, 'white', 2);
	plot(x => 5 * Math.sin(x), 'white', 2);
	plot(x => 5 * Math.sin(x), 'white', 2);
}

async function test7_letters_200from(l, n) {
	let text = await route_path_text(`../base/assets/words/${l}dict.txt`);
	let picdi = await route_path_yaml_dict(`../base/assets/words/${l}picdict.yaml`);
	let splitter = l == 'e' ? '\r\n' : '\n';
	let words = text.split(splitter);
	let result = words.filter(x => x.length >= n);
	let result2 = result.filter(x => x in picdi);
	result2.sort((a, b) => a.length - b.length);
	result3 = arrTake(result2, 200);
	return { all: result, pic: result2, sel: result3 };
}

function test7_uploadfile() {
	let o = { filename: 'ex', data: { text: 'jajajaaber geh jaaaa', id: 78912 } };
	route_post_json('http://localhost:3000/post/json', o, response => {
		console.log(JSON.stringify(response))
	});
}

function test8() {
	var dMain = document.getElementById('dMain');
	let dHeader = mDiv(dMain, { bg: 'random' }, 'dHeader', 'header');
	let [dLeft, dMiddle] = std2fold(dMain);
	let dFooter = mDiv(dMain, { bg: 'random' }, 'dFooter', 'footer');
	let bMenuLeft = stdMenuButton();
	mLeft(dHeader, bMenuLeft);
	stdSidebarController(bMenuLeft, 'dLeft');
}

function test8_function() {
	C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'tl');
	let canvas = C.cv;
	if (null == canvas || !canvas.getContext) return;
	var axes = {}, ctx = canvas.getContext("2d");
	axes.x0 = .5 + .5 * canvas.width;
	axes.y0 = .5 + .5 * canvas.height;
	axes.scale = 40;
	axes.doNegativeX = true;
	console.log('axes', axes)
	showAxes(ctx, axes);
	funGraph(ctx, axes, fun1, "rgb(11,153,11)", 1);
	funGraph(ctx, axes, fun2, "rgb(66,44,255)", 2);
}

function test8_load_googlemap_in_iframe() {
	var iDiv = document.createElement('iframe');
	iDiv.id = 'iframe1';
	mStyle(iDiv, { w: '100%', h: '100%' })
	document.getElementById("map").appendChild(iDiv);
	iDiv.src = 'https://maps.google.com/maps?q=48.2,16.3&output=embed';
	// iDiv.src = 'https://maps.google.com/maps?q=48.2,16.3&hl=fa;z=5&ie=UTF8&output=embed&hl=en';
}

function test8_mimi_hand_card_0_hover() {
	let hand = G.mimi.hand.items;
	let card = hand[0];
	mClass(iDiv(card), 'hoverScale');
}

async function test8_multiple_wordlists() {
	for (const l of ['e', 'd', 's', 'f']) {
		for (let i = 3; i < 15; i++) {
			let res = await test7_letters_200from(l, i);
			let s = `${l} >=${i} ${res.all.length} (davon: ${res.pic.length} ${Math.round((res.pic.length / res.all.length) * 100)}%)`;
			console.log('', s);
			console.log('result', res.sel)
		}
		console.log('________');
	}
}

function test8_simple_intellisense() {
	dTable = mBy('dTable');
	fiddleInit();
}

function test9() {
	var dMain = document.getElementById('dMain');
	let [dHeaderLeft, dTitle, dHeaderRight] = std3title(dMain, 'Aristocracy');
	let [dLeft, dMiddle] = std2fold(dMain);
	let dFooter = mDiv(dMain, { bg: 'random' }, 'dFooter', 'footer');
	let bMenuLeft = stdMenuButton(dHeaderLeft);
	stdSidebarController(bMenuLeft, 'dLeft');
}

function test9_dbSave() { DB.appdata.simple = [1, 2, 3, 4, 5]; }

function test9_function() {
	C = new CCanvas(dTable, {}, {}, gameloop_start, gameloop_stop, 'tl');
	let canvas = C.cv;
	let axes = {}, ctx = canvas.getContext("2d");
	axes.x0 = .5 + .5 * canvas.width;
	axes.y0 = .5 + .5 * canvas.height;
	axes.scale = 40;
	axes.doNegativeX = true;
	C.add({ astep: .1, a: 0, bstep: .1, b: 0, func: x => Math.sin(x), axes: axes, update: geniales_sin_ease });
}

function test9_google() {
	mBy('dTable').innerHTML = `
  <iframe class='flat' id="gmap" src="http://maps.google.com/maps?z=15&t=m&q=loc:48.25+16.3&output=embed" width="100%" height="${window.innerWidth}"></iframe>  
  `;
	let x = document.getElementById('gmap');
	console.log('x', x);
	mStyle(x, { bg: 'blue' });
}

function test9_just_1_card() {
	let dTable = mBy('dTable')
	clearElement(dTable);
	let card = ari_get_card('QSn', 200);
	mAppend(dTable, iDiv(card));
	return card;
}

async function test9_only_syms(l) {
	let text = await route_path_text(`../base/assets/words/${l}dict.txt`);
	let picdi = await route_path_yaml_dict(`../base/assets/words/${l}picdict.yaml`);
	let syms = await route_path_yaml_dict(`../base/assets/allSyms.yaml`);
	let keys = Object.keys(syms);
	let lang = l.toUpperCase();
	let res = keys.filter(x => isdef(syms[x][lang]) && nundef(picdi[syms[x][lang].toLowerCase()]));
	console.log('only syms: lang', l, res.map(x => syms[x][lang]));
}

function test98() {
	let area = mBy(table);
}

function test99() {
	console.log('ah');
	let area = mBy('board'); mPosRel(area);
	let olist = getOlist();
	let size = 50, gap = 10;
	let uis = getUis(olist, colorLabelDiv(size));
	let container = mDivPosAbs(100, 100, area);
	let [w, h] = layoutRow(uis, container, size, size, gap);
	mStyle(container, { width: w, height: h, 'background-color': 'white', 'border-radius': gap });
	colorLabelRow(o)
}

async function testAblauf00(defs, spec, sdata0) {
	await testEngine.init(defs, sdata0, TEST_SERIES);
	let [sp, defaults, sdata] = [testEngine.spec, testEngine.defs, testEngine.sdata];
	T = R = new RSG(sp, defaults);
	R.initialChannels = [];
	ensureRtree(R);
	R.baseArea = 'table';
	createStaticUi(R.baseArea, R);
	for (const oid in sdata) { R.addObject(oid, sdata[oid]); R.addRForObject(oid); }
	for (const oid in sdata) {
		let o = sdata[oid];
		if (isdef(o.loc)) { continue; }
		let topUids;
		for (const key of R.getR(oid)) {
			let specNode = R.getSpec(key);
			if (o.loc && nundef(R.Locations[key]) && nundef(specNode._ref)) {
				topUids = addOidByLocProperty(oid, key, R);
			} else if (isdef(R.Locations[key])) {
				topUids = addOidByParentKeyLocation(oid, key, R);
			}
			if (isEmpty(topUids)) { continue; }
			for (const top of topUids) {
				let uiParent = R.uiNodes[top.uidParent];
				let rParent = R.rNodes[top.uidParent];
				if (isdef(uiParent)) {
					uiParent.adirty = true;
					uiParent.children = rParent.children.map(x => x);
				}
				recUi(R.rNodes[top.uid], R, top.uidParent, oid, key);
			}
		}
	}
	sieveLocOids(R);
	recAdjustDirtyContainers(R.tree.uid, R, true);
	updateOutput(R);
	testEngine.verify(R);
}

async function testAblauf01(defs, spec, sdata0) {
	await testEngine.init(defs, sdata0, TEST_SERIES);
	let [sp, defaults, sdata] = [testEngine.spec, testEngine.defs, testEngine.sdata];
	T = R = new RSG(sp, defaults);
	R.initialChannels = [];
	ensureRtree(R);
	R.baseArea = 'table';
	createStaticUi(R.baseArea, R);
	for (const oid in sdata) { R.addObject(oid, sdata[oid]); R.addRForObject(oid); }
	for (const oid in sdata) {
		let o = sdata[oid];
		if (isdef(o.loc)) { continue; }
		let topUids;
		for (const key of R.getR(oid)) {
			let parents = R.Locations[key];
			if (nundef(parents)) continue;
			topUids = [];
			for (const uidParent of parents) {
				if (parentHasThisChildAlready(uidParent, oid)) continue;
				let n1 = instantOidKey(oid, key, uidParent, R);
				topUids.push({ uid: n1.uid, uidParent: uidParent });
			}
			if (isEmpty(topUids)) { continue; }
			for (const top of topUids) {
				let uiParent = R.uiNodes[top.uidParent];
				let rParent = R.rNodes[top.uidParent];
				if (isdef(uiParent)) {
					uiParent.adirty = true;
					uiParent.children = rParent.children.map(x => x);
				}
				recUi(R.rNodes[top.uid], R, top.uidParent, oid, key);
			}
		}
	}
	recAdjustDirtyContainers(R.tree.uid, R, true);
	updateOutput(R);
	testEngine.verify(R);
}

async function testAblauf02(defs, spec, sdata0) {
	await testEngine.init(defs, sdata0, TEST_SERIES);
	let [sp, defaults, sdata] = [testEngine.spec, testEngine.defs, testEngine.sdata];
	T = R = new RSG(sp, defaults);
	R.initialChannels = [];
	ensureRtree(R);
	R.baseArea = 'table';
	createStaticUi(R.baseArea, R);
	for (const oid in sdata) { R.addObject(oid, sdata[oid]); R.addRForObject(oid); }
	for (const oid in sdata) {
		let o = sdata[oid];
		if (isdef(o.loc)) { continue; }
		let topUids;
		for (const key of R.getR(oid)) {
			let parents = R.Locations[key];
			if (nundef(parents)) continue;
			topUids = [];
			for (const uidParent of parents) {
				if (parentHasThisChildAlready(uidParent, oid)) continue;
				let rtreeParent = R.rNodes[uidParent];
				if (nundef(rtreeParent.children)) { rtreeParent.children = []; }
				let n1 = recTree(R.lastSpec[key], rtreeParent, R, oid, key);
				R.rNodes[n1.uid] = n1;
				rtreeParent.children.push(n1.uid);
				if (rtreeParent.children.length == 2 && rtreeParent.type == 'invisible' && lookup(rtreeParent, ['params', 'bg'])) {
					let uiParent = R.uiNodes[rtreeParent.uid];
					if (isdef(uiParent)) {
						rtreeParent.type = uiParent.type = 'panel';
						decodeParams(uiParent, R, {});
						uiParent.adirty = true;
						applyCssStyles(uiParent.ui, uiParent.cssParams);
					}
				}
				topUids.push({ uid: n1.uid, uidParent: uidParent });
			}
			if (isEmpty(topUids)) { continue; }
			for (const top of topUids) {
				let uiParent = R.uiNodes[top.uidParent];
				let rParent = R.rNodes[top.uidParent];
				if (isdef(uiParent)) {
					uiParent.adirty = true;
					uiParent.children = rParent.children.map(x => x);
				}
				recUi(R.rNodes[top.uid], R, top.uidParent, oid, key);
			}
		}
	}
	recAdjustDirtyContainers(R.tree.uid, R, true);
	updateOutput(R);
	testEngine.verify(R);
}

function testActivate(R) {
	console.log('testActivate', R)
	activateUis(R);
}

function testAdd10Cards() {
	let uilist = [], ch;
	for (let i = 0; i < 10; i++) {
		if (coin()) {
			let card = Card52.getItem();
			ch = iDiv(card);
			mAppend(dTable, ch);
		} else {
			ch = mDiv(dTable, { w: 76, h: 110, bg: 'random' });
			mClass(ch, 'card');
		}
		uilist.push(ch);
	}
}

function testAddBoard(R) {
	R.initRound();
	reAddServerObject('board');
}

function testAddInfluence(mapController, gObjects) {
	let data = {};
	addIf_dep("map", execOptions.activatedTests);
	data.created = {
		"507565": {
			value: 1,
			nation: "Canada",
			faction: "Axis",
			obj_type: "influence",
			visible: {
				xset: ["Axis", "USSR", "West"]
			},
			_id: 507565
		},
		"531772": {
			value: 2,
			nation: "Ireland",
			faction: "West",
			obj_type: "influence",
			visible: {
				xset: ["Axis", "USSR", "West"]
			},
			_id: 531772
		},
		"531773": {
			value: 3,
			nation: "Portugal",
			faction: "USSR",
			obj_type: "influence",
			visible: {
				xset: ["Axis", "USSR", "West"]
			},
			_id: 531773
		},
		"531774": {
			value: 2,
			nation: "Norway",
			faction: "Axis",
			obj_type: "influence",
			visible: {
				xset: ["Axis", "USSR", "West"]
			},
			_id: 531774
		},
		"531775": {
			value: 4,
			nation: "Latin_America",
			faction: "Axis",
			obj_type: "influence",
			visible: {
				xset: ["Axis", "USSR", "West"]
			},
			_id: 531775
		}
	};
	mapController.update(data, gObjects);
}

function testAddLocObject(R) {
	R.initRound();
	let oidLoc = getRandomExistingObjectWithRep(R);
	let oid = getUID('o');
	let o = { name: 'felix' + oid, loc: oidLoc };
	addServerObject(oid, o, R);
}

function testAddObject(R) {
	R.initRound();
	let oid = getUID('o');
	let o = { obj_type: 'card' };
	o.short_name = chooseRandom(['K', 'Q', 'J', 'A', 2, 3, 4, 5, 6, 7, 8]);
	addServerObject(oid, o, R);
}

function testAddOidKey(R) {
	console.log(R.instantiable)
	let n = lastCond(R.instantiable, x => !lookup(R.rNodesOidKey, [x.oid, x.key]));
	if (!n) {
		console.log('all nodes are instantiated!!!');
		return;
	}
	let [oid, key] = [n.oid, n.key];
	let o = R.getO(oid);
	if (!o) {
		console.log('no object with oid', oid, 'found!!!');
		return;
	}
	if (o.loc) addOidByLocProperty(oid, key, R); else addOidByParentKeyLocation(oid, key, R);
	updateOutput(R);
}

function testAndSave() {
	sendRoute('/loadYML/icons', d => {
		console.log(d);
		let dictFont = JSON.parse(d);
		console.log(dictFont);
		let newDictFont = {};
		for (const key in dictFont) {
			newDictFont[key] = dictFont[key].unicode;
		}
		let json_str = JSON.stringify(newDictFont);
		saveFile("yourfilename.json", "data:application/json", new Blob([json_str], { type: "" }));
		console.log('DONE!')
	})
}

function testAndSave2() {
	let newDictFont = {};
	for (const key in faIcons) {
		newDictFont[key] = faIcons[key][3];
	}
	let json_str = JSON.stringify(newDictFont);
	saveFile("yourfilename.json", "data:application/json", new Blob([json_str], { type: "" }));
	console.log('DONE!')
}

function testanim0() {
	let [fen, phase, stage, deck, market] = [Z.fen, Z.phase, Z.stage, Z.deck, Z.market];
	let ms = 400;
	let item = deck.topmost;
	mAnimate(iDiv(item), 'transform', [`scale(1,1)`, `scale(0,1)`],
		() => {
			if (item.faceUp) face_down(item); else face_up(item);
			mAnimate(iDiv(item), 'transform', [`scale(0,1)`, `scale(1,1)`], null,
				ms / 2, 'ease-in', 0, 'both');
		}, ms / 2, 'ease-out', 100, 'both');
}

function testanim1() {
	let [fen, phase, deck, market] = [Z.fen, Z.phase, Z.deck, Z.market];
	DA.qanim = [];
	let n_market = phase == 'jack' ? 3 : 2;
	fen.stage = Z.stage = phase == 'jack' ? 12 : phase == 'queen' ? 11 : 4;
	for (let i = 0; i < n_market; i++) {
		DA.qanim = DA.qanim.concat([
			[qanim_flip_topmost, [deck]],
			[qanim_move_topmost, [deck, market]],
			[q_move_topmost, [deck, market]],
		]);
	}
	DA.qanim.push([q_mirror_fen, ['deck', 'market']]);
	DA.qanim.push([ari_pre_action, []]);
	qanim();
}

function testBirdCards() {
	let keys = SymKeys.filter(x => Syms[x].family != 'emoNoto');
	console.log('groups', ByGroupSubgroup);
	console.log('keySets', KeySets);
	keys = KeySets['animal-bird'];
	for (let i = 0; i < 40; i++) {
		let k = chooseRandom(keys);
		console.log('k', k);
		let card = Karte.get(k, 300);
		mAppend(dTable, iDiv(card));
	}
}

function testbuttons_off() {
	let buttons = arrChildren(mBy('dTestButtons'));
	for (const b of arrFromIndex(buttons, 1)) {
		mClass(b, 'disabled');
		mClassRemove(b, 'enabled');
	}
	mBy('b_delete_table').innerHTML = 'delete most recent table';
}

function testbuttons_on() {
	let buttons = arrChildren(mBy('dTestButtons'));
	for (const b of arrFromIndex(buttons, 1)) {
		mClassRemove(b, 'disabled');
		mClass(b, 'enabled');
	}
	mBy('b_delete_table').innerHTML = 'delete current table';
}

async function testCard() {
	let sdata = genServerDataCards();
	console.log('sdata', sdata)
	let spec = {
		ROOT: { cond: 'all', data: '.short_name' }
	};
	await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
	mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}

function testCard52Cards() {
	for (let i = 0; i < 20; i++) {
		let card = Card52.random();
		mAppend(dTable, iDiv(card));
	}
}

function testCardContent0(card) {
	let dCard = iDiv(card);
	mRows(dCard, spotItPattern(5, 2), { sz: CSZ / 6, fg: 'random', hmargin: 8, vmargin: 4 }, { 'justify-content': 'center' }, { 'justify-content': 'center' }); return;
	mRows(dCard, spotItPattern(5, 2), { sz: CSZ / 8, fg: 'random', margin: 6 }, { 'justify-content': 'center' }, { 'justify-content': 'center' }); return;
	mRows(dCard, cardPattern(13, 'spade suit'), { sz: CSZ / 8, fg: 'random', margin: 6 }, { 'justify-content': 'center' }, { 'justify-content': 'center' }); return;
	mRows(dCard, [['frog', 'frog', 'frog'], ['frog', 'frog'], ['frog', 'frog', 'frog']], { sz: CSZ / 6, fg: 'random' }, { 'justify-content': 'center' }, { 'justify-content': 'center' }); return;
	mRows(dCard, [['frog', 'frog', 'frog'], ['frog', 'frog'], ['frog', 'frog', 'frog']], { sz: CSZ / 5, fg: 'random' }, { 'justify-content': 'center' }, { 'justify-content': 'space-evenly' }); return;
	mSym('frog', dCard, {}, 'cc'); return;
	mRows(iDiv(card), [[['frog', 3], 'HALLO', 'bee'], ['frog', 'HALLO', 'bee'], ['frog', 'HALLO', 4, 'bee'], 'ja das ist es!']);
	return;
	let d = iDiv(dCard, { display: 'flex', dir: 'column', h: '100%', 'justify-content': 'center' }, 'dOuter');
	return;
	for (const arr of rows) {
		let dCol = mDiv(d, { display: 'flex', 'justify-content': 'space-between', 'align-items': 'center' });
		for (const c of arr) {
			let dc;
			if (isdef(Syms[c])) {
				dc = mDiv(dCol, { fg: 'black' });
				ds = mSym(dc, dCol, { sz: CSZ / 5, fg: 'random' });
			} else {
				dc = mDiv(dCol, { fg: 'black' }, null, c);
			}
		}
	}
}

async function testCardDraw52() {
	let d = mBy('table');
	let ui = cardFace({ rank: 'K' }, 70, 110);
	mAppend(d, ui);
}

async function testCardHorizontal() {
	let sdata = genServerDataCards();
	let spec = {
		ROOT: { _NODE: 'cards', params: { orientation: 'h' } },
		cards: { cond: 'all', data: '.short_name' }
	};
	await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
	mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}

async function testCardHorizontal2() {
	let sdata = genServerDataCards();
	let spec = {
		ROOT: { type: 'panel', _NODE: 'cards' },
		cards: { cond: 'all', data: '.short_name' }
	};
	await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
	mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}

function testCards() {
	initRSGData(); hideLobby(); hideLogin(); showGame(); initDom();
	testPlayerHand1();
}

function testCardsGridOverlap() {
	dTable = stdGridContainer(dMiddle);
	testAdd10Cards();
}

function testCardsNoOverlap() {
	dTable = stdContainerRowWrap(dMiddle);
	testAdd10Cards();
}

async function testCardsUni(n, spec, cardGenerator = genServerDataCards) {
	let sdata = cardGenerator(n);
	await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
	mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}

async function testCatan(r, c) {
	let sdata = genServerDataCatan(r, c);
	let spec = { ROOT: { cond: { obj_type: 'Board' }, type: 'grid', data: '.uid' } };
	await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
	mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}

function testCenteredNode() {
	let dTable = mBy('table');
	let d = mDiv(dTable);
	mSize(d, 100, 100);
	mColor(d, 'blue');
	let d1 = mNode({ a: 'HALLO', b: 'geh' }, d);
	mCenterH(d1);
}

function testColarrVersions() {
	let tests = [[2, 2], [3, 2], [4, 2], [5, 2], [6, 2], [6, 3]];
	for (let i = 0; i < 50; i++) {
		let [rows, cols] = [randomNumber(1, 10), randomNumber(1, 10)];
		let carr1 = _calc_hex_col_array(rows, cols);
		let carr2 = _calc_hex_col_arrayNew(rows, cols);
		let even = (rows % 2) == 0;
		console.log('rows', rows, (even ? 'even' : 'odd'), 'cols', cols, '\nold', carr1, '\nnew', carr2);
		console.assert(even || sameList(carr1, carr2), 'FEHLER!!!!!!!!!!!!!!!!!!');
	}
}

async function testCommonKeys() {
	initRSGData(); showGame(); initDom();
	let gaIcons = await route_rsg_asset('gameIconCodes');
	let faIcons = await route_rsg_asset('faIconCodes');
	let smallIcons = await route_rsg_asset('iconTest');
	faKeys = [];
	for (const k in gaIcons) {
		if (isdef(faIcons[k])) faKeys.push(k);
	}
	console.log('common keys:', faKeys);
	let board = makeDrawingArea('board', 'a_d_game', true);
	setAreaWidth('a_d_game', 1400);
	setAreaHeight('a_d_game', 1000);
	let keys = faKeys;
	let xStart = -600;
	let yStart = -400;
	let y = yStart;
	let x = xStart;
	for (const k of keys) {
		addPictoFromChar('board', gaIcons[k], 50, x, y);
		if (y > -yStart) { y = yStart; x += 60; } else y += 60;
	}
	y = yStart; x += 60;
	for (const k of keys) {
		addPictoFromChar('board', faIcons[k], 50, x, y);
		if (y > -yStart) { y = yStart; x += 60; } else y += 60;
	}
	// let key = chooseRandom(Object.keys(faChars));//'clock';
}

function testComposeShapesAndResize() {
	let g = gCanvas('table', 400, 300, 'skyblue');
	testResizeHex(g);
}

function testControlFlow(player = "USSR", filename = "", seed = 4) {
	execOptions.output = "none";
	addIf_dep("control", execOptions.activatedTests);
	if (empty(filename)) {
		sendInit(player, gameloop, seed);
	} else {
		sendLoading(filename, player, gameloop);
	}
}

function testCreateDivWithDivFixedSize() {
	let d = mBy('table');
	clearElement(d);
	d.style.position = 'relative';
	let root = mDiv(d);
	root.style.position = 'relative';
	root.style.width = '200px';
	root.style.height = '100px';
	let ch = mDiv(root);
	ch.style.position = 'absolute';
	ch.style.left = '20px';
	ch.style.top = '10px';
	ch.style.width = '30px';
	ch.style.height = '60px';
	ch.style.backgroundColor = 'blue';
	root.style.backgroundColor = 'red';
}

function testCreateMultipleUnitsOnSameTile() {
	execOptions.output = "none";
	addIf_dep("units", execOptions.activatedTests);
	let data = generateUnitList();
	let player = "West";
	for (const id in data.created) {
		const o = data.created[id];
		o.tile = "London";
		o.nationality = "Britain";
		units.createUnit(id, o, player);
	}
	player = "USSR";
	for (const id in data.created) {
		let idNew = id + 200;
		const o = data.created[id];
		o.tile = "Berlin";
		o.nationality = "Germany";
		o._id = idNew;
		units.createUnit(idNew, o, player);
	}
}

function testCreateNCards() {
	let cman = new ACards(assets);
	let n = 20;
	for (let i = 0; i < n; i++) {
		let c = generateCard();
		cman.createCard(c.id, c.o);
	}
}

function testCreateOneCard() {
	let c = generateCard();
	let cman = new ACards(assets);
	cman.createCard(c.id, c.o);
}

function testCreateSingleUnit() {
	execOptions.output = "none";
	addIf_dep("units", execOptions.activatedTests);
	let data = generateUnitList();
	let player = "West";
	for (const id in data.created) {
		const o = data.created[id];
		units.createUnit(id, o, player);
		break;
	}
}

function testDeactivate(R) {
	deactivateUis(R);
}

function testDeal2() {
	deck.mount(d);
	bDeal.addEventListener('click', function () { deck.pokerN(1); });
	makeTestButton('deal2', () => deck.pokerN(2), topbar1);
}

function testDec() {
	let x = hexStringToDecimal('F');
	console.log('x', x);
	console.log('x', hexStringToDecimal('FFFF'));
	console.log('x', hexStringToDecimal('1A'));
	console.log('x', hexStringToDecimal('1F499'));
	console.log('x', hexStringToDecimal('1F981'));
}

async function testDirList() {
	let x = await (await fetch('/RSG/js')).text();
	while (!isEmpty(x)) {
		word = stringBefore(x, '"');
		console.log('______________word:', word);
		x = stringAfter(x, '<a href="/');
	}
	return;
	var regexp = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?Â«Â»ââââ]))/i;
	var match, files = [];
	let max = 5;
	while ((match = regexp.exec(x)) != null) {
		files.push(match.index);
		max -= 1; if (max <= 0) break;
	}
	console.log('________________', files);
	return;
	var request = new XMLHttpRequest();
	request.open('GET', '/RSG/', true);
	let resp;
	request.onload = function () {
		if (request.status >= 200 && request.status < 400) {
			resp = request.responseText;
		}
	};
	request.send();
	let directory_listing = resp;
	var regexp = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?Â«Â»ââââ]))/i;
	var match, files = [];
	while ((match = regexp.exec(resp)) != null) {
		files.push(match.index);
	}
	console.log(files);
}

async function testDocumentFile() {
	let akku = await documentFile('/RSG/js/done/docs/docfile.js');
	let keys = Object.keys(akku);
	keys.sort();
	keys.map(x => console.log('signature:', x, '\ncomment block:\n', akku[x]));
}

async function testDocumentVault() {
	let vault = [
		"/RSG/js/R/binding.js",
		"/RSG/js/R/rsgTypes.js",
		"/RSG/js/testing/engine.js",
		"/RSG/js/testing/onClick.js",
		"/RSG/js/testing/SimpleGrid.js",
		"/RSG/js/testing/testBoard.js",
		"/RSG/js/testing/testCards.js",
		"/RSG/js/testing/testFactory.js",
		"/RSG/js/testing/testData.js",
		"/RSG/js/testing/testing.js",
		"/RSG/js/done/activator.js",
		"/C/assets.js",
		"/RSG/js/done/index.js",
		"/RSG/js/done/utils.js",
	];
	console.log(res);
}

function testEdit(origData, player = "USSR", filename = "test1", seed = 0) {
	execOptions.output = "none";
	sendInit(player, d1 => {
		freezeUI();
		let tuples = getTuples(d1);
		sendEditAction(player, ["France", "Vienna", "Fleet"], d2 => {
			gameloop(origData);
		});
	});
}

function testEditAddRandomUnit() {
	let tuple = randomUnitTuple();
}

function testEditModeCreateUnit() {
	player = "USSR";
	sendLoading("setup_complete", player, dInit => {
		sender.send("edit/" + player + "/USSR+Moscow+Infantry", dEdit => {
			let newUnit = Object.values(dEdit.created)[0];
			let newId = Object.keys(dEdit.created)[0];
			dInit.created[newId] = newUnit;
			gameloop(dInit);
		});
	});
}

function testEditModeCreateUnit_trial1() {
	sendInit(player, dInit => {
		gameloop(dInit);
	});
}

async function testFaKeysNotInGa() {
	initRSGData(); showGame(); initDom();
	let gaIcons = await route_rsg_asset('gameIconCodes');
	let faIcons = await route_rsg_asset('faIconCodes');
	let smallIcons = await route_rsg_asset('iconTest');
	faKeys = [];
	for (const k in faIcons) {
		if (nundef(gaIcons[k])) faKeys.push(k);
	}
	console.log('common keys:', faKeys);
	let board = makeDrawingArea('board', 'a_d_game', true);
	setAreaWidth('a_d_game', 2400);
	setAreaHeight('a_d_game', 1500);
	let keys = faKeys;
	let xStart = -1100;
	let yStart = -670;
	let y = yStart;
	let x = xStart;
	for (const k of keys) {
		addPictoFromChar('board', faIcons[k], 50, x, y);
		if (y > -yStart) { y = yStart; x += 60; } else y += 60;
	}
	// let key = chooseRandom(Object.keys(faChars));//'clock';
}

async function testFetchCsvAsTextAndSearch() {
	timit = new TimeIt('*timer', TIMIT_SHOW);
	await loadAssets();
	timit.show();
	mEmo('blue heart', 'table', 100);
	mFlexLinebreak('table');
	for (const k of ['cat', 'lion', 'tiger', 'leopard', 'horse', 'zebra', 'deer', 'ox', 'cow']) {
		let emo = mEmo(k, 'table', 50);
	}
}

function testFindKeys() {
}

async function testGeneralBoard(r, c, shape, hasNodes, hasEdges, { mapVariant, fieldContent, nodeContent, edgeContent } = {}) {
	let sdata = genServerDataGeneralBoard(r, c, shape, hasNodes, hasEdges, { mapVariant, fieldContent, nodeContent, edgeContent });
	console.log('sdata', sdata)
	let spec = {
		ROOT: { cond: { obj_type: 'Board' }, type: 'grid' }
	};
	if (isdef(fieldContent)) {
		spec.fields = { cond: { obj_type: 'Field' }, data: '.content' };
	}
	if (isdef(nodeContent)) {
		spec.nodes = { cond: { obj_type: 'Corner' }, data: '.content' };
	}
	if (isdef(edgeContent)) {
		spec.edges = { cond: { obj_type: 'Edge' }, data: '.content' };
	}
	await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
	mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}

function testGetElements() {
	let x = getElements([0, 1, 2]);
	console.log('x', x);
	x = getElements([[3, 2], [0, 1, 2]]);
	console.log('x', x);
}

function testGSM() {
	if (activatedTests.includes('GSM')) {
		console.log(...arguments);
	}
}

function testHelpers() {
	if (activatedTests.includes('helpers')) {
		console.log(...arguments);
	}
}

function testHexgrid() {
	if (activatedTests.includes('hexgrid')) {
		console.log(...arguments);
	}
}

function testIndenting() {
	let spc = '&nbsp;';
	let d = mDiv(mBy('table'));
	mSize(d, 200, 200);
	mColor(d, 'orange');
	let s = `
  hallo
    das ist
     ein
   string
    1
     2
      3`;
	s = s.replace('\t', '  ');
	let startLine = true;
	let lines = s.split('\n');
	let lineInfo = {};
	let html = '';
	for (let i = 0; i < lines.length; i += 1) {
		let line = lines[i];
		let n = countIndent(line, 4);
		console.log('_____________n=' + n, line);
		let x = spc.repeat(n) + line;
		html += x + '<br>';
		console.log(x)
	}
	let d1 = mText(html, d)
}

function TESTING_bar(fileName = getCurrentFileName(), myFunctionName = getFunctionsNameThatCalledThisFunction()) {
}

function TESTING_foo() {
	TESTING_bar();
}

function testingMS() {
	if (isdef(IdOwner.t)) IdOwner.t.map(x => addTestInteraction1(x));
}

function testInitToEnd(player = "USSR", seed = 0) {
	hide(bStop);
	sendInit(player, d => testRunToEnd(d, player), seed);
}

function testInno() {
}

function testInnoCardPhantasie() {
	dTable = mDiv(mBy('wrapper'), { position: 'absolute', padding: 10, w: '100vw', h: '100vh', bg: 'white' });
	mStyle(dTable, { gap: 10 }); let card = cBlank(dTable, { fg: 'black', bg: INNO.color.red, w: CSZ, h: CSZ * .65 });
	let [dCard, sz, szTitle, gap] = [iDiv(card), CSZ / 4, 24, 8];
	let [dTitle, dMain] = cTitleArea(card, 32);
	let d = mAddContent(dTitle, 'MetalWorking', { bg: INNO.sym.tower.bg, fg: 'white', h: 32, fz: 23, align: 'center', position: 'relative' });
	mAddContent(d, '5', { float: 'right', hpadding: 10 });
	let s = mSym(INNO.sym.tower.key, d, { h: 22, fg: INNO.sym.tower.fg }, 'cl');
	let margin = 20;
	innoSym('leaf', dMain, sz, 'tl', margin);
	innoSym('crown', dMain, sz, 'bl', margin);
	innoSym('leaf', dMain, sz, 'bc', margin);
	innoSym('leaf', dMain, sz, 'br', margin);
	let box = mBoxFromMargins(dMain, 0, margin, sz + margin, sz + margin);
	let text = 'I demand if you get [tower] or [crown], immediately switch to age [2]. aber ich hab ja gott sei dank zeit! denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
	let t2 = innoText(text);
	mFillText(t2, box);
	return;
	box = mDiv(dMain, { w: sz, h: sz, bg: 'dimgrey', rounding: 10 }); mPlace(box, 'tl');
	s = mSym('white-tower', box, { sz: sz * .75, fg: 'silver' }, 'cc');
	box = mDiv(dMain, { w: sz, h: sz, bg: 'dimgrey', rounding: 10 }); mPlace(box, 'bl');
	s = mSym('frog', box, { sz: sz * .75, fg: 'silver' }, 'cc');
	box = mDiv(dMain, { w: sz, h: sz, bg: 'dimgrey', rounding: 10 }); mPlace(box, 'bc');
	s = mSym('maple-leaf', box, { sz: sz * .75, fg: 'silver' }, 'cc');
	box = mDiv(dMain, { w: sz, h: sz, bg: 'grey', alpha: .5, rounding: 10 }); mPlace(box, 'br');
	text = 'denn wenn es nicht geht und ich bin muede dann halt nicht!';
	mFillText(text, box);
	box = mBoxFromMargins(dMain, 4, 4, sz + 8, sz + 10);
	text = 'das muss jetzt ein viel laenderer text sein. aber ich hab ja gott sei dank zeit! denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
	mFillText(text, box);
	return;
	text = 'das ist ein sehr langer text ich hoffe er ist auf jeden fall zu lang fuer diese box. denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
	box = mPlaceText(text, [szTitle, 10, sz + gap, sz + gap], d, { fg: 'dimgrey' }, { bg: 'beige', border: '1px solid grey', rounding: 10 });
	text = 'denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
	box = mPlaceText(text, [sz, sz, 'bl'], d, { fg: 'dimgrey', bg: 'pink', rounding: 10, border: '5px solid pink' });
	let x1 = mSym('crow', d, { w: sz, h: sz, fg: 'green' }, 'br');
	x1 = mSym('abacus', d, { w: sz, h: sz }, 'bc');
	box = mPlaceText('hallo das ist noch ein echo!!!', [sz, sz, 'tl'], d, { fg: 'blue', bg: 'orange', rounding: 10 });
}

function testInnoMain() {
	mStyle(dTable, { gap: 10, pabottom: 150 });
	for (const k in Cinno) {
		if (isdef(Cinno[k].expansion)) cardInno(dTable, k);
	}
}

function testIntegrationCards(filename = "prod_complete", player = "Axis") {
	execOptions.output = "none";
	addIf_dep("cards", execOptions.activatedTests);
	if (empty(filename)) {
		sendInit(player, gameloop, 0);
	} else {
		sendLoading(filename, player, gameloop);
	}
}

function testIntegrationMap(filename = "prod_complete", player = "Axis") {
	execOptions.output = "none";
	addIf_dep("map", execOptions.activatedTests);
	if (empty(filename)) {
		sendInit(player, gameloop, 0);
	} else {
		sendLoading(filename, player, gameloop);
	}
}

function testIntegrationUnits(filename = "", player = "USSR", seed = 4) {
	execOptions.output = "none";
	addIf_dep("units", execOptions.activatedTests);
	if (empty(filename)) {
		sendInit(player, gameloop, seed);
	} else {
		sendLoading(filename, player, gameloop);
	}
}

function testjourney0() {
	let [fen, uname] = [Z.fen, Z.uname];
	let plist = find_players_with_potential_journey(fen);
	console.log('journey players', plist);
	if (!plist.includes(uname)) {
		set_nextplayer_after_journey();
		console.log('Z.turn', Z.turn)
		take_turn_fen();
	}
}

function testJustARect() {
	let svg = new MMS({ parent: UIS.a_d_game, type: 'svg' }).setDefaults({ bg: 'green' }).attach();
	let rect = new MMS({ parent: svg, type: 'rect' }).setDefaults({ w: 50, h: 50, bg: 'red' }).attach();
}

function testKarte0() {
	mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = CSZ;
	let suit = mSuit('Pik', d, { h: 300 });
	let p = suit.firstChild;
	console.log('p', p);
	console.log('child', p.firstChild);
}

function testKarte1() {
	let card = cLandscape(dTable);
	let sz = card.sz;
	console.log('sz', sz)
	let d = iDiv(card);
	let x = mShape('triangle', d, { bg: 'blue', w: sz / 4, h: sz / 4, position: 'absolute', top: 10, left: 10 });
	x = mShape('test1', d, { bg: 'red', w: sz / 4, h: sz / 4, position: 'absolute', bottom: 10, left: 10 });
	x = mSym('bee', d, { fz: sz / 5, position: 'absolute', bottom: 10, right: 10 });
	x = mDiv(d, { bg: YELLOW, w: sz / 4, h: sz / 4, position: 'absolute', top: 10, right: 10 }, null, null, 'triangle');
	let text = 'diese karte erlaubt es dir, zu verschwinden und aufzutauchen wo immer du willst.<br><br>pass jedoch auf: wenn du auf einer ungesicherten mine landest, verlierst du 1 leben!';
	let [fz, w, h] = fitFont(text, 20, sz, sz / 2);
	let pos = { left: (card.w - w) / 2, top: (card.h - h) / 2 }
	x = mDiv(d, { align: 'left', fz: fz, fg: 'black', w: w, h: h, top: pos.top, left: pos.left, display: 'inline-block', position: 'absolute' }, null, text);
	console.log('x', x)
	let sh0 = [
		`<div class="triangle"></div>`,
		`<div class="triangle type2" style="--b:linear-gradient(red,blue);"></div>`,
		`<div class="triangle type3" style="--b:conic-gradient(green,pink,green);"></div>`,
		`<div class="triangle hex" style="--b:url(https://picsum.photos/id/1067/200/200) center/cover;"></div>`,
		`<div class="triangle hex" style="--b:url(../assets/images/felix.jpg) center/cover;"></div>`,
	];
	let sh = [
		`<div class="weired"></div>`,
		`<div class="weired" style="--b:linear-gradient(red,blue);"></div>`,
		`<div class="weired" style=
    "--b:conic-gradient(green,pink,green);
    --clip:polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    --patop:100%;
    "></div>`,
		//`<div class="triangle hex" style="--b:url(https://picsum.photos/id/1067/200/200) center/cover;"></div>`,
	];
	for (const sh1 of sh) {
		x = createElementFromHtml(sh1);
		mStyle(x, { w: 80 });
		mAppend(dTable, x);
	}
	return;
	let styles = { margin: 10, bg: 'random' };
	for (let i = 0; i < 3; i++) { let d = mShape('triangle', dTable); console.log('d', d); }
}

function testKarte2() {
	let card = cLandscape(dTable);
	let isLandscape = card.w > card.h;
	let sz = card.sz;
	console.log('sz', sz)
	let text = 'diese karte erlaubt es dir, zu verschwinden und aufzutauchen wo immer du willst.<br><br>pass jedoch auf: wenn du auf einer ungesicherten mine landest, verlierst du 1 leben!';
	let d = iDiv(card);
	let sh = [
		{ type: 'html', pos: 'TL', sz: 's', content: `<div class="weired"></div>` },
		{ type: 'html', pos: 'TR', sz: 's', content: `<div class="weired" style="--b:linear-gradient(red,blue);"></div>` },
		{
			type: 'html', pos: 'BL', sz: 's', content: `<div class="weired" style=
    "--b:conic-gradient(green,pink,green);
    --clip:polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    --patop:100%;
    "></div>`},
		{
			type: 'html', pos: 'BR', sz: 's', content: `<div class="weired" style=
    "--b:url(../assets/images/felix.jpg) center/cover;
    --clip:polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    --patop:100%;
    "></div>`},
		{ type: 'text', pos: 'CC', sz: 'l', content: 'diese karte erlaubt es dir, zu verschwinden und aufzutauchen wo immer du willst.<br><br>pass jedoch auf: wenn du auf einer ungesicherten mine landest, verlierst du 1 leben!' },
	];
	var SZ = sz;
	var GAP = SZ * .1;
	var SIZE = { xs: SZ / 8, s: SZ / 4, m: SZ / 2, l: SZ * 2 / 3, xl: SZ };
	var POS = { TL: { top: GAP, left: GAP }, TR: { top: GAP, right: GAP }, BL: { bottom: GAP, right: GAP }, BR: { bottom: GAP, right: GAP } };
	for (const sh1 of sh) {
		let t = sh1.content;
		x = isString(t) ? t[0] == '<' ? createElementFromHtml(t) : makeText(t, sz, sz / 2) : t;
		mAppend(d, x);
		let pos = sh1.pos;
		if (pos != 'CC') {
			mStyle(x, { w: 80 });
			window['mPos' + sh1.pos](x, 10);
		}
	}
}

function testKarte3_svg() {
	mStyle(dTable, { gap: 10 }); let card;
	card = cBlankSvg(dTable);
	console.log('card', card);
	let g = iG(card); console.log('g', g);
	let x = mgSuit('Pik'); console.log('x', x);
	mgSize(x, CSZ / 2);
	mgPos(card, x);
}

function testKarte4() {
	mStyle(dTable, { gap: 10 }); let card;
	card = cBlank(dTable);
	let d = iDiv(card);
	let sz = CSZ;
	let arr = [];
	let suit = mSuit('Pik');
	let triangle = mShape('triangle', null, { bg: 'red' });
	let sym = mSym('frog');
	let shape = mShape('test1');
	let x = mShapeX98(); console.log('\nx', x); mAppend(d, x);
	return;
	let h = sz / 4;
	suit.setAttribute('height', h);
	mStyle(sym, { fz: h * .75 });
	mSize(shape, h * .75);
	mSize(triangle, h * .75);
	arr = [triangle, suit, sym, shape, x];
	console.log('\nx', x);
	mAppend(d, x); return;
	for (const x of arr) { mAppend(d, x); }
	gSizeToContent(suit);
}

function testKarte5() {
	for (let i = 0; i < 10; i++) {
		let n = i * 15;
		let x = mShapeR(); console.log('\nx', x);
		mStyle(x, { w: n }); mClassReplace(x, 'weired' + (n > 120 ? 8 : n > 80 ? 5 : n > 50 ? 3 : 1));
		mAppend(dTable, x);
	}
}

function testKarte6() {
	for (let i = 0; i < 10; i++) {
		let n = i * 15;
		let x = mShapeR('triup', dTable, { sz: n, bg: 'random' }); console.log('\nx', x); mAppend(dTable, x);
	}
}

function testKarte8() {
	for (let i = 0; i < 1; i++) {
		testKarte7();
	}
}

function testKartePosition1() {
	mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = CSZ / 4;
	let s3 = mSuit('Pik', d); mSuitSize(s3, 30); mSuitTL(s3); console.log('s3', s3);
	let s4 = mSuit('Treff', d); mSuitSize(s4, 30); mSuitPos(s4, 'bottom', 'right'); console.log('s4', s4);
	let s5 = mSuit('Herz', d, { sz: 30 }); mSuitPos(s5, 'bottom', 'left'); console.log('s5', s5);
	let s6 = mSuit('Karo', d, { sz: 30 }); mSuitPos(s6, 'top', 'right'); console.log('s6', s6);
	return;
	console.log('suit', suit);
	mPos(suit, 0, 0);
	mPos(suit1, -10, CHEIGHT - sz);
	mPos(suit1, -10 * sz / 100, CHEIGHT - sz);
}

function testKartePosition2() {
	mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = CSZ / 4;
	let s1 = mSuit('Pik', d, { sz: 25 }, 'tl'); console.log('s1', s1);
	let s2 = mSuit('Karo', d, { sz: 50 }, 'tr'); console.log('s2', s2);
	let s3 = mSuit('Herz', d, { sz: 75 }, 'bl'); console.log('s3', s3);
	let s4 = mSuit('Treff', d, { sz: 100 }, 'br'); console.log('s4', s4);
}

function testKartePositionSuit() {
	let dTable = mBy('dTable'); clearElement(dTable); mStyle(dTable, { hmin: 400 })
	let card = cBlank(dTable); let d = iDiv(card); let sz = card.h / 6;
	let i = 0;
	for (let suit of ['H', 'S', 'D', 'C']) {
		let s1 = mSuit(suit, d, { w: sz, h: sz });
		mPos(s1, sz * i, 0); i++;
	}
}

function testKartePositionSuitOuterCenters() {
	mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = CSZ / 4;
	let s1 = mSuit('Pik', d, { sz: 60 }, 'tc'); console.log('s1', s1);
	let s2 = mSuit('Karo', d, { sz: 60 }, 'cr'); console.log('s2', s2);
	let s3 = mSuit('Herz', d, { sz: 60 }, 'bc'); console.log('s3', s3);
	let s4 = mSuit('Treff', d, { sz: 60 }, 'cl'); console.log('s4', s4);
}

function testKarteSizing() {
	mStyle(dTable, { gap: 10 }); let card;
	card = cBlank(dTable);
	let d = iDiv(card);
	let sz = CSZ;
	let arr = [];
	let suit = mSuit('Pik');
	let triangle = mShape('triangle', null, { bg: 'red' });
	let sym = mSym('frog');
	let shape = mShape('test1');
	let x = mShapeR();
	let h = sz / 4;
	suit.setAttribute('height', h);
	mStyle(sym, { fz: h * .75 });
	mSize(shape, h * .75);
	mSize(triangle, h * .75);
	mStyle(x, { w: h * .75 }); mClassReplace(x, 'weired1');
	arr = [triangle, suit, sym, shape, x];
	for (const x of arr) { mAppend(d, x); }
	gSizeToContent(suit);
}

function testKnight() {
	let c = makeCard(0, 'hallo');
	c.mount(d);
	c.setSide('front');
	blank(c);
	setTitle(c, 'Knight')
	setText(c, 'You can play this card whenever you want to move the robber!')
	moveTo(c, -100, -100);
}

function testLines() {
	initRSGData(); showGame(); initDom();
	let board = makeDrawingArea('board', 'a_d_game', true);
	let mobj = makeDrawingElement('el1', 'board');
	mobj.line({ thickness: 10, cap: 'round' }).setBg('red').attach();
	console.log(mobj)
	console.log(mobj.elem)
	let [x1, y1, x2, y2] = mobj.getEndPointsOfLineSegmentOfLength(40);
	let ms2 = makeDrawingElement('el2', 'board');
	ms2.line({ thickness: 15, x1: x1, y1: y1, x2: x2, y2: y2 }).setBg('blue').attach();
	[x1, y1, x2, y2] = mobj.getEndPointsOfLineSegmentOfLength(120);
	let ms3 = makeDrawingElement('el3', 'board');
	ms3.line({ thickness: 5, x1: x1, y1: y1, x2: x2, y2: y2 }).setBg('green').attach();
}

function testLoadSpring(filename = "spring_start", player = "Axis") {
	execOptions.output = "none";
	if (empty(filename)) {
		sendInit(player, gameloop, 5);
	} else {
		sendLoading(filename, player, gameloop);
	}
}

function testLoadToEnd(player = "Axis", filename = "setup_complete") {
	hide(bStop);
	sendLoading(filename, player, d => testRunToEnd(d, player), "raw");
}

function testLookupRemoveFromList() {
	let d = { a: { b: [2] } };
	let res = lookupRemoveFromList(d, ['a', 'b'], 2);
	console.log('res', res, 'd', d);
	d = { a: { b: [2] } };
	res = lookupRemoveFromList(d, ['a', 'b'], 2, true);
	console.log('res', res, 'd', d);
	d = { a: { b: [2, 3] } };
	res = lookupRemoveFromList(d, ['a', 'b'], 3, true);
	console.log('res', res, 'd', d);
	d = { a: [0, [2], { b: [] }] };
	res = lookupRemoveFromList(d, ['a', 1], 2);
	console.log('res', res, 'd', d);
}

function testMakeACanvas() {
	let dParent = mBy('table');
	let div = stage3_prepContainer(dParent);
	div.style.width = 400 + 'px';
	div.style.height = 300 + 'px';
	mColor(div, 'orange');
	let svg = gSvg();
	let style = `margin:0;padding:0;position:absolute;top:0px;left:0px;width:100%;height:100%;`
	svg.setAttribute('style', style);
	mColor(svg, 'green');
	div.appendChild(svg);
	let g = gG();
	g.style.transform = "translate(50%, 50%)";
	gBg(g, 'blue');
	svg.appendChild(g);
	return g;
}

function testMakeAreas(dParent) {
	let dGrid = mDiv(dParent, { gap: 10, bg: 'white', w: '90%', padding: 10, display: 'inline-grid', rounding: 10 }, 'dGrid');
	let layout = ['T', 'H A'];
	let x = createGridLayout(dGrid, layout);
	let areaStyles = { bg: 'green', hmin: 200, rounding: 6 };
	let contentStyles = { lowerRounding: 6 };
	let messageStyles = { fg: 'yellow' };
	let titleStyles = { bg: 'dimgray', family: 'AlgerianRegular', upperRounding: 6 };
	let areas = {
		T: { title: 'table', id: 'dTrick', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles, titleOnTop: true },
		H: { title: 'YOU', id: 'dHuman', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles, titleOnTop: false },
		A: { title: 'opponent', id: 'dAI', showTitle: true, messageArea: true, areaStyles: areaStyles, contentStyles: contentStyles, messageStyles: messageStyles, titleStyles: titleStyles, titleOnTop: false },
	};
	let items = [];
	for (const k in areas) {
		let item = areas[k];
		item.areaStyles['grid-area'] = k;
		let dCell = mTitledMessageDiv(item.title, dGrid, item.id, item.areaStyles, item.contentStyles, item.titleStyles, item.messageStyles, item.titleOnTop)
		iRegister(item, item.id);
		if (item.titleOnTop) iAdd(item, { div: dCell, dTitle: dCell.children[0], dMessage: dCell.children[1], dContent: dCell.children[2] });
		else iAdd(item, { div: dCell, dTitle: dCell.children[2], dMessage: dCell.children[0], dContent: dCell.children[1] });
		mCenterCenterFlex(diContent(item));
		mStyle(diContent(item), { gap: 10 });
		items.push(item);
	}
	return items;
}

function testManualCircleOnG() {
	let svg = new MMS({ parent: UIS.a_d_game, type: 'svg' }).setDefaults({ bg: 'green' }).attach();
	let g = new MMS({ parent: svg, type: 'g' }).setDefaults({ bg: 'blue' }).attach();
	let circle = new MMS({ parent: g, type: 'ellipse' }).attach();
	let r = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
	r.setAttribute('rx', 35);
	r.setAttribute('ry', 45);
	r.setAttribute('cx', 0);
	r.setAttribute('cy', 0);
	r.setAttribute('fill', 'yellow');
	g.elem.appendChild(r);
}

function testMovement(filename = "test_movement", player = "Axis") {
	execOptions.output = "none";
	if (empty(filename)) {
		sendInit(player, gameloop, 5);
	} else {
		sendLoading(filename, player, gameloop);
	}
}

function testMS_fine() {
	if (activatedTests.includes('MS_fine')) {
		console.log(...arguments);
	}
}

function testMuell0() {
	dTable = makePage();
	mStyle(dTable, { display: 'flex', })
	let dGrid = mDiv(dTable, { wmin: 110, hmin: 70, bg: 'white', padding: 3, rounding: 6 });
	let d = mTitledMessageDiv('title', dGrid, 'id1',
		{ bg: 'green', rounding: 6 },
		{ lowerRounding: 6 },
		{ bg: 'dimgray', align: 'center', 'line-height': 30, family: 'AlgerianRegular', upperRounding: 6 },
		{ fg: 'yellow', padding: 10 },
		true);
}

function testMultiline() {
	let d = mDiv(mBy('table'));
	mSize(d, 200, 200);
	mColor(d, 'orange');
	let s = ' hallo\n\tdas\n   ist\n\t\tda';
	let dMulti = mMultiline(s, 2, d);
}

function testNewMSAPI() {
	initRSGData(); showGame(); initDom();
	let board = makeDrawingArea('board', 'a_d_game', true);
	let mobj = makeDrawingElement('el1', 'board');
	_makeGroundShape(mobj, 0, 25, 100, 100, 'blue', 'quad', { scaleY: 2, rot: 45 });
	mobj.attach();
	console.log(mobj)
}

function testObjectWithUiAndClasses() {
	let n = { uid: '_1' };
	let d = mCenteredNode({ a: 'HALLO', b: 'geh' });
	console.log(d, d.classList);
	mSize(d, 100, 50);
	mAppend(mBy('table'), d);
	mCenterText(d.firstChild);
	mClass(d.firstChild, 'centered')
	n.class = ['centered'];
	console.log('line2', d, d.classList);
	n.ui = d;
	let dDesc = mNodeFilter(n, { dParent: mBy('table'), lstShow: ['uid', 'class'] });
}

function testOutput(o) {
	return;
	for (const key in o) {
		const arg = o[key];
		if (isNumber(key) && key <= execOptions.outputLevel) {
			console.log(H.moveCounter + ':', ...arg);
		}
	}
}

function testPageHeader() {
	pageHeaderClearAll();
	pageHeaderSetGame();
	pageHeaderAddPlayer('username', 'playerId', 'green', true);
}

async function testPicto(n) {
	initRSGData(); showGame(); initDom();
	let board = makeDrawingArea('board', 'a_d_game', true);
	let keys = ['achievement', 'wheat', 'criminal', 'police', 'cop', 'trophy', 'victory', 'plenty', 'fruit', 'bounty', 'house', 'castle', 'building', 'settlement', 'city', 'robber', 'thief', 'street', 'road'];
	let y = -300;
	let x = -300;
	let i = 0;
	timit.showTime('************server');
	iconChars = await vidCache.load('iconChars', route_iconChars);
	timit.showTime('iconChars');
	console.log(iconChars);
	for (const k of keys) {
		addPicto('board', k, 50, x, y);
		if (y > 250) { y = -300; x += 60; } else y += 60;
		i += 1; if (i >= n) break;
	}
}

function testPicto_dep(n) {
	initRSGData(); showGame(); initDom();
	let board = makeDrawingArea('board', 'a_d_game', true);
	let keys = ['achievement', 'wheat', 'criminal', 'police', 'cop', 'trophy', 'victory', 'plenty', 'fruit', 'bounty', 'house', 'castle', 'building', 'settlement', 'city', 'robber', 'thief', 'street', 'road'];
	let y = -300;
	let x = -300;
	let i = 0;
	loadIconChars([() => {
		console.log(iconChars);
		for (const k of keys) {
			addPicto('board', k, 50, x, y);
			if (y > 250) { y = -300; x += 60; } else y += 60;
			i += 1; if (i >= n) break;
		}
	}]);
}

function testPlayerHand1() {
	G.table = cards1;
	G.playersAugmented = {
		White: {
			devcards: { _set: [{ _obj: 'c1' }, { _obj: 'c3' }] }
		}
	};
	_showHand(['c1', 'c2', 'c3'], 'a_d_game');
}

function testPos00() {
	let board = [
		['bk', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
		['em', 'bn', 'em', 'wr', 'em', 'wp', 'em', 'em'],
		['br', 'em', 'bp', 'em', 'em', 'bn', 'wn', 'em'],
		['em', 'em', 'bp', 'bp', 'bp', 'em', 'wp', 'bp'],
		['bp', 'bp', 'em', 'bp', 'wn', 'em', 'wp', 'em'],
		['em', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
		['em', 'em', 'em', 'wk', 'em', 'em', 'em', 'em'],
		['em', 'em', 'em', 'em', 'em', 'em', 'em', 'em'],
	];
	console.log(board_to_fen(board));
}

function testPosition3() {
	mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = CSZ / 5;
	let x1 = mShapeR('hex', null, { w: sz, h: sz, bg: 'random' }); console.log('\nx1', x1);
	for (const p of ['tl', 'tc', 'tr', 'cl', 'cc', 'cr', 'bl', 'bc', 'br']) {
		let x2 = x1.cloneNode(); mAppend(d, x2); mPlace(x2, p, 20);
	}
}

function testPositionCardSym() {
	mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = CSZ / 5;
	let x1 = mSym('crow', d, { w: sz, h: sz, bg: 'random' }, 'cc'); console.log('\nx1', x1);
}

function testPositionPatterns() {
	mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = CSZ / 5;
	let x1 = mShapeR('hex', null, { w: sz, h: sz, bg: 'random' }); console.log('\nx1', x1);
	for (const p of ['tl', 'tc', 'tr', 'cl', 'cc', 'cr', 'bl', 'bc', 'br']) {
		let x2 = x1.cloneNode(); mAppend(d, x2);
		mPlace(x2, p, p.includes('c') ? 0 : 20);
	}
}

function testPositionPatterns1() {
	mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = CSZ / 5;
	let x1 = mShapeR('circle', null, { w: sz, h: sz, bg: 'random' }); console.log('\nx1', x1);
	for (const p of ['tl', 'tr', 'bl', 'br']) {
		let x2 = x1.cloneNode(); mAppend(d, x2);
		mPlace(x2, p, 20);
	}
	for (const p of ['tc', 'cl', 'cc', 'cr', 'bc']) {
		let x2 = x1.cloneNode(); mAppend(d, x2);
		mPlace(x2, p);
	}
}

function testPositionShapeR0() {
	mStyle(dTable, { gap: 10 }); let card = cBlank(dTable); let d = iDiv(card); let sz = CSZ / 4;
	let x1 = mShapeR('triup', d, { sz: sz, bg: 'random' }); console.log('\nx1', x1);
	mPlace(x1, 'tl');
	let x2 = mShapeR('hex', d, { sz: sz, bg: 'random' }); console.log('\nx1', x2);
	mPlace(x2, 'tr');
	let x3 = mShapeR('triangle', d, { sz: sz, bg: 'random' }); console.log('\nx1', x3);
	mPlace(x3, 'br');
	let x4 = mShapeR('hexFlat', d, { sz: sz, bg: 'random' }); console.log('\nx1', x4);
	mPlace(x4, 'bl');
}

function testRandomSeries(G, n, callback) {
	sender.send("init/hotseat/Axis/1", dInit => {
		testRandomSeriesRec([], dInit, G, n, callback);
	});
}

function testRandomSeries_sendInit(lst, G, n, callback) {
	sendInit(
		G.player,
		dInit => {
			lst.push();
			testRandomSeriesRec(dInit, G, n - 1, callback);
		},
		G.seed
	);
}

function testRandomSeriesRec(lst, dInit, G, n, callback) {
	sender.send("randint/" + 100, di => {
		let x = di.int;
		lst.push(x);
		if (n > 0) {
			testRandomSeriesRec(lst, dInit, G, n - 1, callback);
		} else {
			callback(dInit);
		}
	});
}

function testRectanglesTextInBoxesW0() {
	mStyle(dTable, { gap: 10 }); let card = cBlank(dTable, { w: CSZ, h: CSZ * .8 });
	let [d, sz, szTitle, gap] = [iDiv(card), CSZ / 4, 24, 8];
	let box = mBoxFromMargins(d, szTitle, 10, sz + gap, sz + gap);
	let r = mMeasure(box);
	text = 'das ist ein sehr langer text ich hoffe er ist auf jeden fall zu lang fuer diese box. denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
	let [fz, w, h] = fitFont(text, 20, r.w, r.h);
	console.log('res', fz, w, h);
	let dText = mDiv(box, {
		w: w, h: h, fz: fz, fg: 'black',
		position: 'absolute', transform: 'translate(-50%,-50%)', top: '50%', left: '50%'
	}, null, text);
	box = mDiv(d, { w: sz, h: sz });
	mPlace(box, 'bl');
	r = mMeasure(box);
	text = 'denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
	[fz, w, h] = fitFont(text, 20, r.w, r.h);
	console.log('res', fz, w, h);
	dText = mDiv(box, {
		w: w, h: h, fz: fz, fg: 'black',
		position: 'absolute', transform: 'translate(-50%,-50%)', top: '50%', left: '50%'
	}, null, text);
	mPlaceText('hallo das ist noch ein echo!!!', [sz, sz, 'tl'], d, { fg: 'blue' }, { bg: 'orange', border: '1px dashed red', rounding: 10 });
}

function testRectanglesW1() {
	mStyle(dTable, { gap: 10 }); let card = cBlank(dTable, { w: CSZ, h: CSZ * .8 });
	let [d, sz, szTitle, gap] = [iDiv(card), CSZ / 4, 24, 8];
	let text = 'das ist ein sehr langer text ich hoffe er ist auf jeden fall zu lang fuer diese box. denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
	box = mPlaceText(text, [szTitle, 10, sz + gap, sz + gap], d, { fg: 'dimgrey' }, { bg: 'beige', border: '1px solid grey', rounding: 10 });
	text = 'denn wenn nicht ist es ein echtes problem. dann muss ich einen anderen test machen!';
	box = mPlaceText(text, [sz, sz, 'bl'], d, { fg: 'dimgrey', bg: 'pink', rounding: 10, border: '5px solid pink' });
	let x1 = mSym('crow', d, { w: sz, h: sz, fg: 'green' }, 'br');
	x1 = mSym('abacus', d, { w: sz, h: sz }, 'bc');
	box = mPlaceText('hallo das ist noch ein echo!!!', [sz, sz, 'tl'], d, { fg: 'blue', bg: 'orange', rounding: 10 });
}

function testRegexSplit() {
	let res = '\nfunction \nfunction hallo(){return "hallo";}\nasync function hallo1(){return "hallo1";}'
	let regex = new RegExp('\nasync function|\nfunction|\nvar|\nconst|\nclass', 'g');
	let fcode = res.split(regex);
	console.log(fcode);
}

function testRemoveBoard(R) {
	let oid = detectFirstBoardObject(R);
	console.log('testRemoveBoard: first board object detected has oid', oid);
	removeServerObject(oid, 'board');
}

function testRemoveInfluence(mapController, gObjects) {
	let data = {};
	addIf_dep("map", execOptions.activatedTests);
	data.removed = {
		"507565": {
			obj_type: "influence",
			visible: {
				xset: ["Axis", "USSR", "West"]
			},
			_id: 507565
		},
		"531772": {
			obj_type: "influence",
			visible: {
				xset: ["Axis", "USSR", "West"]
			},
			_id: 531772
		},
		"531773": {
			obj_type: "influence",
			visible: {
				xset: ["Axis", "USSR", "West"]
			},
			_id: 531773
		},
		"531774": {
			value: 2,
			nation: "Norway",
			faction: "Axis",
			obj_type: "influence",
			visible: {
				xset: ["Axis", "USSR", "West"]
			},
			_id: 531774
		},
		"531775": {
			value: 4,
			nation: "Latin_America",
			faction: "Axis",
			obj_type: "influence",
			visible: {
				xset: ["Axis", "USSR", "West"]
			},
			_id: 531775
		}
	};
	mapController.update(data, gObjects);
}

function testRemoveObject(R) {
	let data = dict2list(sData);
	data = data.filter(x => (nundef(x.fields)) && nundef(x.neighbors));
	data = data.filter(x => firstCondDict(R.rNodes, y => y.oid == x.id));
	console.log('data gefiltered:', data)
	if (isEmpty(data)) {
		console.log('no objects left in sData!!!');
		return;
	}
	let oid = chooseRandom(data).id;
	removeServerObject(oid, 'random');
}

function testRemoveOidKey(R) {
	let n = getRandomUidNodeWithAct(R);
	if (!n) {
		console.log('there is no oid to remove!!!');
		return;
	}
	let [oid, key] = [n.oid, n.key];
	let nodeInstances = lookup(R.rNodesOidKey, [oid, key]);
	console.log('_________ testRemoveOidKey', 'remove all', oid, key, nodeInstances);
	removeOidKey(oid, key, R);
	updateOutput(R);
}

function testResizeEllipse(g) {
	let el = agEllipse(g, 100, 100);
	gBg(el, 'violet');
	gPos(el, 100, 110);
	gSize(el, 50, 20);
}

function testResizeHex(g) {
	let el = agHex(g, 50, 50);
	gBg(el, 'blue');
	gPos(el, 100, 110);
	gSize(el, 20, 20, 'hex');
}

function testResizeRect(g) {
	let el = agRect(g, 100, 50);
	gBg(el, 'violet');
	gPos(el, 100, 110);
	gSize(el, 50, 20);
}

function testRunToEnd(data, player) {
	let tuples = getTuples(data);
	if (empty(tuples)) {
		let waitingSet = getSet(data, "waiting_for");
		if (empty(waitingSet)) {
			error("NO ACTIONS AND EMPTY WAITING SET... sending empty action!!!");
			sendAction(player, ["none"], d => testRunToEnd(d, player));
		} else {
			let nextPlayer = waitingSet[0];
			sendChangeToPlayer(nextPlayer, d1 => {
				testRunToEnd(d1, nextPlayer);
			});
		}
	} else {
		decider.pickTuple(tuples, t => {
			sendAction(player, t, d => testRunToEnd(d, player));
		});
	}
}

function tests0_table_drawloop() {
	dTable = mBy('dTable'); mStyle(dTable, { vpadding: 20, bg: BLUE, align: 'center' });
	G = { items: [] };
	TO.running = setInterval(drawloop, 100);
	test1ttt();
}

function tests1_canvas_vs_dom() {
	let dPage = mBy('dTable'); mCenterCenterFlex(dPage); mStyle(dPage, { gap: 4 });
	G = { items: [] };
	dHeader = mDivLine(dPage);
	mLinebreak(dPage);
	let st = { w: 300, h: 250, bg: 'randlight' };
	let c1 = new ccanvas(dPage, st);
	mLinebreak(dPage);
	dTable = mDiv(dPage, st);
	mLinebreak(dPage);
	let c2 = new ccanvas(dPage, st);
	mLinebreak(dPage);
	dFooter = mDivLine(dPage);
	mLinebreak(dPage);
}

function testSaveLoadUiTree() {
	let uiTree = jsCopyMinus(T.uiTree, 'act', 'ui', 'defParams', 'params');
	console.log(uiTree);
}

async function testsendupdate() {
	let data = {
		user: isdef(U) ? U.name : 'felix',
		game: 'paris',
		fen: dixit_setup(['mimi', 'felix']),
		turn: ['felix'],
		step: 1,
	}
	let o = { type: 'updategame', data: data };
	let ostring = JSON.stringify(o);
	mBy('inpost').value = ostring;
	let res = await route_post_form_callback_js('/singlepost', 'fRoute', data => console.log('got from serverr', data))
}

function testSetBgOnSvgInsteadOfG() {
	let g = new MMS({ parent: UIS.a_d_game, type: 'g' }).setDefaults({ bg: 'yellow' }).attach();
}

function testShapes() {
	initRSGData(); showGame(); initDom();
	let board = makeDrawingArea('board', 'a_d_game', true);
	let mobj = makeDrawingElement('el1', 'board');
	let sz = 200;
	let c = 'blue';
	let c1 = anyColorToStandardString('green', .1);
	console.log(c1);
	makeVisual(mobj, 0, 0, sz, sz, c1, 'quad');
	mobj.text({ txt: 'hallo', fill: colorDarker(c), fz: 30, y: -sz / 3 });
	mobj.ellipse({ w: sz / 2, h: sz / 2, fill: 'green', alpha: .5 })
	mobj.attach();
	mobj.addClickHandler('', () => {
		mobj.setShape('star');
	});
	let ms1 = makeDrawingElement('el2', 'board');
	makeVisual(ms1, -sz, 0, sz, sz, c1, 'triangle');
	ms1.attach();
}

async function testSolutionConverter() {
	let series = TEST_SERIES;
	let sols = await loadSolutions(series);
	console.log('solutions', sols);
	await saveSolutions(series, sols);
}

function testSorting() {
	let o = { z: [3, 2, 5, 1], d: { w: 2, r: 3 } };
	let d = mBy('spec');
	mNodeFilter(o, { dParent: d, title: 'orig' });
	mNodeFilter(o, { sort: 'all', dParent: d, title: 'sorted' });
	mNodeFilter(o, { sort: 'keys', dParent: d, title: 'justkeys' });
}

async function testSpeech() {
	await loadAssets();
	hide('floatingMenu');
	let table = mBy('table');
	let e = mEmo('red heart', table, 200);
	e.style.color = 'red';
	mFlexLinebreak(table);
	lang = 'E';
	matchingWords = ['heart'];
	if (isEnglish(lang)) {
		mInstruction('Say the word in English', table);
	} else {
		mInstruction('Sag das Wort auf Deutsch', table);
	}
	mFlexLinebreak(table);
	hintMessage = mHeading('HALLO', table, 1, 'hint');
	mFlexLinebreak(table);
	resultMessage = mText('jajaja', table);
	resultMessage.id = 'result';
	resultMessage.style.marginTop = '200px';
	resultMessage.style.fontSize = '20pt';
}

function testSplitIntoNumbersAndWords() {
	let ss = ['1k 2queen', '1 k 12 q', '12king2queen', '31 ace 2queen', '1 3 3 4', '1 10 3 8', '1J3As', '12 koenig 2 Ass'];
	for (const s of ss) {
		let x = splitIntoNumbersAndWords(s);
	}
}

function testSpotit() {
	let [rows, cols, numCards, setName] = [3, 2, 3, 'animals'];
	let infos = spotitDeal(rows, cols, numCards, setName);
	let items = [];
	for (const info of infos) {
		let item = spotitCard(info, dTable, { margin: 10 }, spotitOnClickSymbol);
		items.push(item);
	}
	return;
	for (const item of items) {
		for (const k in item.shares) {
			let other = Items[item.shares[k]];
		}
	}
}

function testStep(data, player) {
	let tuples = getTuples(data);
	if (empty(tuples)) {
		let waitingSet = getSet(data, "waiting_for");
		if (empty(waitingSet)) {
			error("NO ACTIONS AND EMPTY WAITING SET... sending empty action!!!");
			nextAction = () => sendAction(player, ["none"], d => testStep(d, player));
		} else {
			let nextPlayer = waitingSet[0];
			nextAction = () =>
				sendChangeToPlayer(nextPlayer, d1 => {
					testStep(d1, nextPlayer);
				});
		}
	} else {
		decider.pickTuple(tuples, t => {
			sendAction(player, t, d => testStep(d, player));
		});
	}
	show(bStep);
}

function testStepByStep(player = "Axis", filename = "gov_complete") {
	sendLoading(filename, player, d => testStep(d, player), "raw");
}

function testSuperGenialDivAndGBehavingTheSame() {
	let msD = new MMS({ parent: UIS.a_d_game, type: 'div' }).rect({ x: 20, y: 100, w: 50, h: 50, bg: 'blue' }).attach();
	let msG = new MMS({ parent: UIS.a_d_game, type: 'g' }).rect({ x: 20, y: 100, w: 25, h: 25, bg: 'red' }).attach();
	console.log(msD.elem, msG.elem)
}

function testSvgGRectTakesBg() {
	let svg = new MMS({ parent: UIS.a_d_game, type: 'svg' }).setDefaults().attach();
	let g = new MMS({ parent: svg, type: 'g' }).setDefaults({ bg: 'red' }).attach();
	let rect = new MMS({ parent: g, type: 'rect' }).setDefaults({ w: 50, h: 50, bg: 'yellow' }).attach();
	g.centerOrigin();
}

async function testTtt(r, c) {
	let sdata = genServerDataTtt(r, c);
	let spec = { ROOT: { cond: { obj_type: 'Board' }, type: 'grid', data: '.uid' } };
	await rParse('direct', { defs: DEFS, spec: spec, sdata: sdata });
	mBy('message').innerHTML = '(direct) ' + getFunctionCallerName();
}

function testVCentered() {
	let dTable = mBy('table');
	let d = mDiv(dTable);
	mSize(d, 100, 100);
	mColor(d, 'blue');
	let d1 = mText('HALLO', d);
	mCenterV(d1);
}

function textCorrectionFactor(text, styles, w, h, fz) {
	styles.fz = fz;
	let size = getSizeWithStyles(text, styles);
	if (Math.abs(size.h - h) > fz) { return size.h / h; } else return 0;
}

function ThreeFoldRep() {
	var i = 0, r = 0;
	for (i = 0; i < brd_hisPly; ++i) {
		if (brd_history[i].posKey == brd_posKey) {
			r++;
		}
	}
	return r;
}

function Tile(mapX, mapY, x, y, type) {
	this.x = x;
	this.y = y;
	this.mapX = mapX;
	this.mapY = mapY;
	this.isCollidable = false;
	this.collisionCallback = false;
	this.type = type;
	this.isAnimated = false;
	this.isCollidable = false;
	this.isClickable = false;
	this.clickCallback = false;
	this.animationPlaying = false;
	this.setCollision = function (callBack) {
		this.collisionCallback = callBack;
		this.isCollidable = true;
	}
	this.setAnimation = function () {
		this.isAnimated = true;
	}
	this.setClick = function (callBack) {
		this.isClickable = true;
		this.clickCallback = callBack;
	}
	this.checkCollision = function (sprite, w, h) {
		shw = sprite.width / 2;
		shh = sprite.height / 2;
		scx = sprite.x + shw;
		scy = sprite.y + shh;
		thw = w / 2;
		thh = h / 2;
		tcx = this.x + thw;
		tcy = this.y + thh;
		if (Math.abs(scx - tcx) < (thw + shw)) {
			if (Math.abs(scy - tcy) < (thh + shh)) {
				this.collisionCallback(this);
			}
		}
	}
}

function tileCondBelongsTo(t, pl, prop) { return t[prop] == pl.id; }

function TileMap(scene) {
	this.tileSheet = new Image();
	this.tiles = new Array();
	this.symbolImageMap = new Array();
	this.tileAnimations = new Array();
	this.specificTileAnimations = new Array();
	this.mapData = false;
	this.tileWidth = 0;
	this.tileHeight = 0;
	this.sheetWidth = 0;
	this.sheetHeight = 0;
	this.camera = new Camera(scene);
	this.loadTileSheet = function (tileWidth, tileHeight, sheetWidth, sheetHeight, tileSheet, tileSymbols) {
		this.tileSheet.src = tileSheet;
		this.tileWidth = tileWidth;
		this.tileHeight = tileHeight;
		this.SheetWidth = sheetWidth;
		this.SheetHeight = sheetHeight;
		numRows = Math.floor(this.SheetWidth / this.tileWidth);
		numCols = Math.floor(this.SheetHeight / this.tileHeight);
		for (i = 0; i < numRows; i++) {
			for (j = 0; j < numCols; j++) {
				if ((i * numCols) + j < tileSymbols.length) {
					this.symbolImageMap[(i * numCols) + j] = new Array(j * this.tileWidth, i * this.tileHeight, tileSymbols[(i * numCols) + j]);
				}
			}
		}
	}
	this.loadMapData = function (mapArray) {
		this.mapData = new Array();
		for (i = 0; i < mapArray.length; i++) {
			this.mapData.push(new Array());
			temp = new Array();
			for (j = 0; j < mapArray[i].length; j++) {
				k = 0;
				notConverted = true;
				while (notConverted && k < this.symbolImageMap.length) {
					if (mapArray[i][j] == this.symbolImageMap[k][2]) { this.mapData[i][j] = k; notConverted = false; }
					k++;
				}
				temp[j] = new Tile(j, i, j * this.tileWidth, i * this.tileHeight, k);
			}
			this.tiles.push(temp)
		}
	}
	this.drawMap = function () {
		this.camera.update();
		ctx = this.camera.context;
		for (i = 0; i < this.mapData.length; i++) {
			for (j = 0; j < this.mapData[i].length; j++) {
				drawX = this.tiles[i][j].x - this.camera.cameraOffsetX;
				drawY = this.tiles[i][j].y - this.camera.cameraOffsetY;
				if (0 < drawX < this.camera.cWidth && 0 < drawY < this.camera.cHeight) {
					ctx.save();
					sheetX = this.symbolImageMap[this.mapData[i][j]][0];
					sheetY = this.symbolImageMap[this.mapData[i][j]][1];
					ctx.translate(drawX, drawY);
					if (this.tiles[i][j].animationPlaying) { this.drawTileAnimation(this.tiles[i][j], ctx); }
					else {
						ctx.drawImage(this.tileSheet, sheetX, sheetY, this.tileWidth, this.tileHeight, 0, 0, this.tileWidth, this.tileHeight);
						ctx.restore();
					}
				}
			}
		}
	}
	this.addTileCollision = function (collisionCallback, typeOrX, y) {
		if (typeof y == "undefined") {
			for (i = 0; i < this.tiles.length; i++) {
				for (j = 0; j < this.tiles[i].length; j++) {
					if (this.tiles[i][j].type == typeOrX) {
						this.tiles[i][j].setCollision(collisionCallback);
					}
				}
			}
		}
		else {
			this.tiles[typeOrX][y].setCollision(collisionCallback);
		}
	}
	this.loadCollisionMap = function (collisionMap) {
		for (l = 0; l < collisionMap.length; l++) {
			c = 0;
			notConverted = true;
			while (c < this.symbolImageMap.length && notConverted) {
				if (this.symbolImageMap[c][2] == collisionMap[l][0]) {
					collisionMap[l][0] = c + 1;
					notConverted = false;
				}
				c++;
			}
		}
		for (i = 0; i < this.tiles.length; i++) {
			for (j = 0; j < this.tiles[i].length; j++) {
				k = 0;
				notAssigned = true;
				while (k < collisionMap.length && notAssigned) {
					if (this.tiles[i][j].type == collisionMap[k][0]) {
						this.tiles[i][j].setCollision(collisionMap[k][1]);
						notAssigned = false;
					}
					k++;
				}
			}
		}
	}
	this.mapScroll = function (dx, dy) { this.camera.moveCamera(dx, dy); }
	this.cameraFollowSprite = function (sprite, waitX, waitY) { this.camera.followSprite(sprite, waitX, waitY); }
	this.loadZOrderMap = function (zMap) { }
	this.addTileAnimation = function (imgWidth, imgHeight, cellWidth, cellHeight, tileName, animSheet) {
		animation = new Animation(animSheet, imgWidth, imgHeight, cellWidth, cellHeight);
		animation.setup();
		for (i = 0; i < this.symbolImageMap.length; i++) {
			if (this.symbolImageMap[i][2] = tileName) {
				this.tileAnimations[i] = animation;
			}
		}
	}
	this.addSpecificTileAnimation = function (imgWidth, imgHeight, cellWidth, cellHeight, tileX, tileY, animSheet) {
		animation = new Animation(animSheet, imgWidth, imgHeight, cellWidth, cellHeight);
		animation.setup();
		this.specificTileAnimations[tileX][tileY] = animation;
	}
	this.drawTileAnimation = function (tile, ctx) {
		notSpecific = true;
		if (typeof this.specificTileAnimations[tile.mapX][tile.mapY] !== 'undefined' && this.specificTileAnimations[tile.mapX][tile.mapY] !== null) {
			notSpecific = false;
			this.specificTileAnimations[tile.mapX][tile.mapY].reset();
			this.specificTileAnimations[tile.mapX][tile.mapY].drawFrame(ctx);
		}
		if (typeof this.tileAnimations[tile.type] !== 'undefined' && this.tileAnimations[tile.type] !== null && notSpecific) {
			this.tileAnimations[tile.type].reset();
			this.tileAnimations[tile.type].drawFrame(ctx);
		}
	}
	this.playTileAnimation = function (tile) { tile.animationPlaying = true; }
	this.stopTileAnimation = function (tile) { tile.animationPlaying = false; }
	this.checkCollisions = function (sprite) {
		tileCoordX = Math.floor(sprite.x / this.tileWidth);
		tileCoordY = Math.floor(sprite.y / this.tileHeight);
		checkRowsBegin = tileCoordX - 1;
		checkRowsEnd = tileCoordX + 2;
		checkColsBegin = tileCoordY - 1;
		checkColsEnd = tileCoordY + 2;
		if (tileCoordX > -1 && tileCoordY > -1 && tileCoordY < this.mapData.length && tileCoordX < this.mapData[tileCoordY].length) {
			if (tileCoordX == 0) { checkRowsBegin = 0; }
			if (tileCoordX == (this.mapData[tileCoordY].length - 1)) { checkRowsEnd = this.mapData.length; }
			if (tileCoordY == 0) { checkColsBegin = 0; }
			if (tileCoordY == (this.mapData.length - 1)) { checkColsBegin = this.mapData[tileCoordY].length; }
			for (i = checkColsBegin; i < checkColsEnd; i++) {
				for (j = checkRowsBegin; j < checkRowsEnd; j++) {
					if (this.tiles[i][j].isCollidable) {
						this.tiles[i][j].checkCollision(sprite, this.tileWidth, this.tileHeight);
					}
				}
			}
		}
	}
	this.makeSpriteMapRelative = function (sprite) { sprite.setCameraRelative(this.camera); }
	this.setPosition = function () { }
}

function timeConversion(duration, format = 'Hmsh') {
	const portions = [];
	const msInHour = 1000 * 60 * 60;
	const hours = Math.trunc(duration / msInHour);
	if (format.includes('H')) portions.push((hours < 10 ? '0' : '') + hours);
	duration = duration - (hours * msInHour);
	const msInMinute = 1000 * 60;
	const minutes = Math.trunc(duration / msInMinute);
	if (format.includes('m')) portions.push((minutes < 10 ? '0' : '') + minutes);
	duration = duration - (minutes * msInMinute);
	const msInSecond = 1000;
	const seconds = Math.trunc(duration / 1000);
	if (format.includes('s')) portions.push((seconds < 10 ? '0' : '') + seconds);
	duration = duration - (seconds * msInSecond);
	const hundreds = duration / 10;
	if (format.includes('h')) portions.push((hundreds < 10 ? '0' : '') + hundreds);
	return portions.join(':');
}

function Timer() {
	this.reset = function () {
		this.date = new Date();
		this.startTime = this.date.getTime();
		this.elapsedTime = 0;
	}
	this.getCurrentTime = function () {
		this.date = new Date();
		return this.date.getTime();
	}
	this.getElapsedTime = function () {
		current = this.getCurrentTime();
		return (current - this.startTime) / 1000;
	}
	this.start = this.reset;
	this.getTimeElapsed = this.getElapsedTime;
	this.reset();
}

function timeToMs(h, m, s) { return ((((h * 60) + m) * 60) + s) * 1000; }

function title_tableDiv_bounds(dParent, title, o) {
	let [d, t, w, h] = o_tableDiv_bounds(dParent, o);
	let ti = document.createElement('p');
	ti.innerHTML = title;
	t.prepend(ti);
	return [d, d.offsetWidth, d.offsetHeight];
}

function to_admin() {
	show('dAdminButtons');
	U = DB.users.mimi; show_user(DB.users[U.name]);
	to_games();
}

function to_aristocard(ckey, sz = 100, color = RED, w) {
	let info = jsCopy(C52Cards[ckey.substring(0, 2)]);
	info.key = ckey;
	info.cardtype = ckey[2];
	let [r, s] = [info.rank, info.suit];
	info.val = r == 'A' ? 1 : 'TJQK'.includes(r) ? 10 : Number(r);
	info.color = color;
	info.sz = info.h = sz;
	info.w = valf(w, sz * .7);
	info.irank = 'A23456789TJQK'.indexOf(r);
	info.isuit = 'SHCD'.indexOf(s);
	info.isort = info.isuit * 13 + info.irank;
	return info;
}

function to_commissioncard(ckey, sz = 40, color = GREEN, w) { return to_aristocard(ckey, sz, color); }

function to_create_table() {
	let t = create_table();
	server_send(t, 'create_table_and_start', to_table);
}

function to_games() {
	console.log('games fuer user', U.name, 'suchen');
	get_games(U.name, show_games_menu);
}

function to_lat_lng(pts = []) { return points_to_waypoints(pts); }

function to_luxurycard(ckey, sz = 100, color = 'gold', w) { return to_aristocard(ckey, sz, color); }

function to_rumorcard(ckey, sz = 40, color = GREEN, w) { return to_aristocard(ckey, sz, color); }

function to_server(req, type, to_php = true) {
	where(type);
	if (!to_php) {
		server_offline(req, type);
	} else if (is_online()) {
		server_online(req, type);
	} else {
		if (type == 'chat') { alert('no internet!'); mClassReplace(mBy("label_chat"), 'enabled', 'disabled'); }
		server_offline(req, type);
	}
}

function to_table() {
	console.log('table should be presented!')
}

function to_words(x) {
	let list = x.split('\n');
	let di = {};
	list.map(x => di[x.toLowerCase()] = x);
	return di;
}

function toBase10(s, base = 16) {
	let s1 = reverseString(s.toLowerCase());
	let res = 0;
	let mult = 1;
	for (let i = 0; i < s1.length; i++) {
		let l = s1[i];
		let hexarr = ['a', 'b', 'c', 'd', 'e', 'f'];
		let n = isNumber(l) ? Number(l) : 10 + hexarr.indexOf(l);
		res += mult * n;
		mult *= base;
	}
	return res;
}

function toBoardString(arr, rows, cols) {
	let s = '\n';
	for (let r = 0; r < rows; r++) {
		for (let c = 0; c < cols; c++) {
			let item = arr[r * cols + c];
			s += '' + (nundef(item) ? '_' : item) + ' ';
		}
		s += '\n';
	}
	return s;
}

function toDegree(rad) { return Math.floor(180 * rad / Math.PI); }

function toElem(d) { return isString(d) ? mBy(d) : d; }

function toggle_apps() { if (isEmpty(mBy('dApps').innerHTML)) show_apps(); else iClear('dApps'); }

function toggle_bw_symbol(d) {
	if (nundef(d)) d = document.getElementById('tbbw');
	d = d.getElementsByTagName('i')[0];
	if (isdef(d)) {
		if (d.classList.contains('fa-car')) {
			d.classList.remove('fa-car');
			d.classList.add('fa-star');
			mStyle(d, { fg: 'silver' });
		} else {
			d.classList.remove('fa-star');
			d.classList.add('fa-car');
			mStyle(d, { fg: 'transparent' });
		}
	}
}

function toggle_face(item) { if (item.faceUp) face_down(item); else face_up(item); }

function toggle_fiddle() { if (nundef(dFiddle)) show_fiddle(); else { fiddleSave(); iClear(dFiddle); dFiddle = null; } }

function toggle_games() { if (isEmpty(mBy('dGames').innerHTML)) show_games(); else iClear('dGames'); }

function toggle_games_off() { let a = mBy('aGames'); hide('dGames'); mStyle(a, { bg: 'silver' }); }

function toggle_games_on() { let a = mBy('aGames'); mStyle(a, { bg: 'skyblue' }); }

function toggle_layers_control() {
	if (DA.layers_control) { M.map.removeControl(DA.layers_control); DA.layers_control = null; }
	else {
		let baseLayers = get_layer_options();
		let overlayLayers = get_layer_options();
		DA.layers_control = L.control.layers(baseLayers, overlayLayers, { collapsed: false })
		DA.layers_control.addTo(M.map);
	}
}

function toggle_list_member(arr, el) { arrToggleMember(arr, el); }

function toggle_mini_user_info() {
	if (nundef(DA.left_panel) || DA.left_panel == 'open') close_mini_user_info(); else open_mini_user_info();
}

function toggle_polling_status() {
	if (is_polling_on()) {
		stop_polling();
		let b = mBy('b_polling');
		b.className = 'buttonClass donebutton enabled off';
		b.innerHTML = 'polling off';
	} else {
		allow_polling();
		let b = mBy('b_polling');
		b.className = 'buttonClass donebutton enabled on';
		b.innerHTML = 'polling on';
	}
	console.log('Polling Status:', is_polling_on() ? 'ON' : 'OFF');
}

function toggle_select(item, selected, selstyle = 'selected') {
	let ui = iDiv(item);
	item.isSelected = !item.isSelected;
	if (item.isSelected) {
		mStyleOrClass(ui, selstyle);
	} else if (isString(selstyle)) {
		mClassRemove(ui, selstyle);
	} else if (isdef(item.style)) {
		mStyle(ui, item.style);
	} else {
		mStyleUndo(ui, selstyle);
	}
	if (isdef(selected)) {
		if (isList(selected)) {
			if (item.isSelected) {
				console.assert(!selected.includes(item), 'UNSELECTED PIC IN PICLIST!!!!!!!!!!!!')
				selected.push(item);
			} else {
				console.assert(selected.includes(item), 'PIC NOT IN PICLIST BUT HAS BEEN SELECTED!!!!!!!!!!!!')
				removeInPlace(selected, item);
			}
		} else {
			mStyle(iDiv(selected), selected.style);
			selected.isSelected = false;
		}
	}
	return item.isSelected ? item : null;
}

function toggle_sidebar() {
	if (nundef(DA.left_panel) || DA.left_panel == 'open') close_sidebar(); else open_sidebar();
}

function toggle_sound() {
	U.settings.silent = !U.settings.silent;
	if (isdef(G)) G.silent = U.settings.silent;
	set_sound(U.settings.silent);
}

function toggle_tables_off() { let a = mBy('aTables'); hide('dTables'); mStyle(a, { bg: 'silver' }); }

function toggle_tables_on() { let a = mBy('aTables'); mStyle(a, { bg: '#afe78f' }); } //'lightgreen' }); }

function toggle_users_off() { let a = mBy('aUsers'); hide('dUsers'); mStyle(a, { bg: 'silver' }); }

function toggle_users_on() { let a = mBy('aUsers'); mStyle(a, { bg: 'coral' }); }

function toggleCollapsible(ev) {
	let b = ev.target;
	b.classList.toggle("active");
	var content = getLinkContainerId(b.id);
	if (isVisible(content)) hide(content); else show(content);
}

function toggleFace(pic) { if (pic.isFaceUp) turnFaceDown(pic); else turnFaceUp(pic); }

function toggleFaceSimple(pic) { if (pic.isFaceUp) turnFaceDownSimple(pic); else turnFaceUpSimple(pic); }

function toggleItemSelection(item, selectedItems) {
	let ui = iDiv(item);
	item.isSelected = nundef(item.isSelected) ? true : !item.isSelected;
	if (item.isSelected) mClass(ui, 'framedPicture'); else mRemoveClass(ui, 'framedPicture');
	if (isdef(selectedItems)) {
		if (item.isSelected) {
			console.assert(!selectedItems.includes(item), 'UNSELECTED PIC IN PICLIST!!!!!!!!!!!!')
			selectedItems.push(item);
		} else {
			console.assert(selectedItems.includes(item), 'PIC NOT IN PICLIST BUT HAS BEEN SELECTED!!!!!!!!!!!!')
			removeInPlace(selectedItems, item);
		}
	}
}

function togglePic(ev) {
	let id = evToClosestId(ev);
	console.log(id)
	let item = UIS[id];
	console.log(item)
	if (isdef(item.pic)) removePic(item); else addPic(item, item.key);
}

function toggleSelection(pic, selected, clSelected = 'framedPicture', clUnselected = null) {
	let ui = iDiv(pic);
	pic.isSelected = !pic.isSelected;
	if (pic.isSelected) {
		if (isdef(clUnselected)) mClassRemove(ui, clUnselected);
		mClass(ui, clSelected);
	} else {
		mClassRemove(ui, clSelected);
		if (isdef(clUnselected)) mClass(ui, clUnselected);
	}
	if (isdef(selected)) {
		if (isList(selected)) {
			if (pic.isSelected) {
				console.assert(!selected.includes(pic), 'UNSELECTED PIC IN PICLIST!!!!!!!!!!!!')
				selected.push(pic);
			} else {
				console.assert(selected.includes(pic), 'PIC NOT IN PICLIST BUT HAS BEEN SELECTED!!!!!!!!!!!!')
				removeInPlace(selected, pic);
			}
		} else {
			mClassRemove(iDiv(selected), clSelected);
			if (isdef(clUnselected)) mClass(iDiv(selected), clUnselected);
			selected.isSelected = false;
		}
	}
	return pic.isSelected ? pic : null;
}

function toggleSelectionOfPicture(pic, selectedPics, className = 'framedPicture') {
	let ui = iDiv(pic);
	pic.isSelected = !pic.isSelected;
	if (pic.isSelected) mClass(ui, className); else mClassRemove(ui, className);
	if (isdef(selectedPics)) {
		if (pic.isSelected) {
			console.assert(!selectedPics.includes(pic), 'UNSELECTED PIC IN PICLIST!!!!!!!!!!!!')
			selectedPics.push(pic);
		} else {
			console.assert(selectedPics.includes(pic), 'PIC NOT IN PICLIST BUT HAS BEEN SELECTED!!!!!!!!!!!!')
			removeInPlace(selectedPics, pic);
		}
	}
}

function toggleSettings() { if (isVisible2('dSettings')) closeSettings(); else openSettings(); }

function toggleSidebar(ev, k, key) {
	if (nundef(DA.countKey)) { DA.countKey = {}; }
	if (nundef(DA.countKey[k])) { DA.countKey[k] = 0; }
	DA.countKey[k]++;
	let isOdd = DA.countKey[k] % 2 == 1;
	if (key == 'Escape' || ev.ctrlKey && k == 122) {
		if (isOdd) {
			mBy('left_panel').style.flex = 0;
			setTimeout(() => {
				show('mini_profile_img');
				show('mini_username');
			}, 500)
			mBy('mini_menu_right').style.display = 'flex';
		} else {
			mBy('left_panel').style.flex = 1;
			hide('mini_profile_img');
			hide('mini_username');
			mBy('mini_menu_right').style.display = 'none';
		}
	}
}

function toggleSound(key) {
	if (DA.isSound == true) { pauseSound(); DA.isSound = false; return; }
	playSound(key);
	DA.isSound = true;
}

function toggleTheme() {
	let bg = colorHex(dMain.style.backgroundColor);
	let lum = getBrightness(bg);
	console.log('current:\nbg', bg, '\nbaseColor', DA.pageBaseColor, '\nlum', lum);
	if (bg != DA.pageBaseColor) setPageBackground(DA.pageBaseColor, 'white', false);
	else if (lum <= .5) setPageBackground(colorLighter(bg), 'black', false);
	else setPageBackground(colorDarker(bg, 1), 'white', false);
}

function toggleTooltips(b) {
	if (S.settings.tooltips) {
		b.textContent = 'tooltips: OFF';
		S.settings.tooltips = false;
	} else {
		b.textContent = 'tooltips: ON';
		S.settings.tooltips = true;
	}
}

function toHTMLString(msg) {
	msg = JSON.stringify(msg);
	msg = msg.replace(/(?:\r\n|\r|\n)/g, '<br>');
	msg = msg.replace('\\n', '<br>');
	msg = msg.replace(/\\n/g, '<br>');
	msg = msg.replace(/"/g, '');
	return msg.trim();
}

function toLetterArray(s) { return toLetterList(s); }

function toLetterList(s) {
	return [...s];
}

function toLetters(s) { return [...s]; }

function toList(x) { return isList(x) ? x : [x]; }

function toLocalStorage(o, name = '_all') { localStorage.setItem(name, JSON.stringify(o)); }

function toModulo(n, modul) { rem = n % modul; n = n - rem; if (n < 0) n = 0; return n; }

function toNoun(s) { return capitalize(s.toLowerCase()); }

function too_many_string_items(A) { return A.items.filter(x => nundef(x.o)).length >= 8; }

function toogle_internet_status() {
	if (is_online()) {
		go_offline();
		let b = mBy('b_internet');
		b.className = 'statusbutton enabled off';
		b.innerHTML = 'offline';
	} else {
		go_online();
		db_save();
		let b = mBy('b_internet');
		b.className = 'statusbutton enabled on';
		b.innerHTML = 'online';
	}
	console.log('InternetStatus:', is_online() ? 'online' : 'OFFLINE');
}

function toolbar_check() {
	if (isEmpty(G.selist)) { mDisable('bclear'); mDisable('bnext') } else { mEnable('bclear'); mEnable('bnext') }
	if (isEmpty(G.hist)) { mDisable('bback'); } else { mEnable('bback'); }
}

function top_card_to_hands_abwechselnd(deck, hand1, hand2) {
	DA.hand = hand1;
	deck.items.map(x => {
		mStyle(iDiv(x), { cursor: 'pointer' });
		iDiv(x).onclick = () => {
			anim_from_deck_to_handX(x, deck, DA.hand);
			DA.hand = DA.hand == hand1 ? hand2 : hand1;
		}
	});
}

function top_card_to_market(deck, market) {
	deck.items.map(x => {
		mStyle(iDiv(x), { cursor: 'pointer' });
		iDiv(x).onclick = () => {
			anim_from_deck_to_marketX(x, deck, market);
		}
	});
}

function top_elem_from_to(arr1, arr2) { arr2.push(arr1.shift()); }

function top_elem_from_to_top(arr1, arr2) { arr2.unshift(arr1.shift()); }

function topCard(deck) { return deck.cards[0]; }

function topCardShouldGoTo(deck0, deck1, faceUp) {
	let c = Deck.transferTopFromToBottom(deck0, deck1)
	if (faceUp == true) Card52.turnFaceUp(c);
	mRemoveStyle(c.div, ['cursor', 'position']);
}

function toRadian(deg) { return deg * 2 * Math.PI / 360; }

function TOSQ(m) { return (((m) >> 7) & 0x7F); }

function tossCoin(percent) {
	let r = Math.random();
	r *= 100;
	return r < percent;
}

function totalFreeze() {
	hide('passToNextPlayerUI')
	show('freezer');
}

function toUmlaut(w) {
	if (isList(w)) {
		let res = [];
		for (const w1 of w) res.push(toUmlaut(w1));
		return res;
	} else {
		w = replaceAll(w, 'ue', 'Ã¼');
		w = replaceAll(w, 'ae', 'Ã¤');
		w = replaceAll(w, 'oe', 'Ã¶');
		w = replaceAll(w, 'UE', 'Ã');
		w = replaceAll(w, 'AE', 'Ã');
		w = replaceAll(w, 'OE', 'Ã');
		return w;
	}
}

function toWords(s) {
	let arr = s.split(/[\W|_]+/);
	return arr.filter(x => !isEmpty(x));
}

function toWordsSpeech(s) {
	var th = ['', 'thousand', 'million', 'billion', 'trillion'];
	var dg = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
	var tn = ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen'];
	var tw = ['twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety'];
	s = s.toString();
	s = s.replace(/[\, ]/g, '');
	if (s != parseFloat(s)) return 'not a number';
	var x = s.indexOf('.');
	if (x == -1) x = s.length;
	if (x > 15) return 'too big';
	var n = s.split('');
	var str = '';
	var sk = 0;
	for (var i = 0; i < x; i++) {
		if ((x - i) % 3 == 2) {
			if (n[i] == '1') { str += tn[Number(n[i + 1])] + ' '; i++; sk = 1; }
			else if (n[i] != 0) { str += tw[n[i] - 2] + ' '; sk = 1; }
		} else if (n[i] != 0) {
			str += dg[n[i]] + ' '; if ((x - i) % 3 == 0) str += 'hundred '; sk = 1;
		} if ((x - i) % 3 == 1) {
			if (sk) str += th[(x - i - 1) / 3] + ' '; sk = 0;
		}
	}
	if (x != s.length) {
		var y = s.length;
		str += 'point ';
		str.replace(/\s+/g, ' ');
	}
	return str.trim();
}

function toYaml(o) { return jsonToYaml(o); }

function trace() { if (isTraceOn) console.log('___ ', getFunctionsNameThatCalledThisFunction(), '\n', ...arguments); }

function transColor(r, g, b, a) {
	return 'rgba(r,g,b,a)';
}

function transferElement() {
	let h = Daat.hand;
	let item = Daat.item;
	h.addTop(item.val);
	let zHand = Daat.zone;
	clearElement(zHand);
	let items = i52(h.cards());
	let handItem = Daat.iHand = iSplay(items, zHand);
}

function transformToString(k, val, refs) {
	if (val && isDict(val) && '_set' in val) { val = val._set; }
	if (k == 'visible' && !isEmpty(val) && !isDict(val[0])) { val = val.map(x => { return { _player: x } }); }
	let sval = null;
	if (isList(val) && isEmpty(val)) { sval = '{ }'; }
	else if (isList(val) && isString(val[0])) { sval = '{' + val.join(',') + '}' }
	else if (isListOf(val, '_obj')) { sval = makeRefLinkDiv4ListOf_obj(val, refs); }
	else if (isListOf(val, '_player')) { sval = makeRefLinkDiv4ListOf_player(val, refs); }
	else if (val && isDict(val) && '_obj' in val) { sval = makeRefLinkDiv4_obj(val, refs); }
	else if (val && isDict(val) && '_ndarray' in val) { sval = makeRefLinkDiv4MatrixOf_obj(val, refs) }
	else if (val && isDict(val) && '_player' in val) { sval = makeRefLinkDiv4_player(val, refs); }
	else if (isDictOrList(val)) {
		sval = tableHTMLX(val, refs);
	}
	else sval = simpleRep(val);
	return sval;
}

function transitionTo(id) {
	let delay = dCurrent ? .1 : 0;
	hideCurrent();
	setTimeout(() => setCurrent(id), delay);
}

function translateStylesToCy(styles, group) {
	let di = {};
	for (const k in styles) {
		let v = styles[k];
		let [prop, val] = translateToCssStyle(k, v, true);
		if (group == 'edge' && k == 'bg') di['line-color'] = val;
		else if (prop == 'shape' && val == 'hex') {
			di.shape = 'polygon';
			di['shape-polygon-points'] = [0, -1, 1, -0.5, 1, 0.5, 0, 1, -1, 0.5, -1, -0.5];
		}
		else di[prop] = val;
	}
	return di;
}

function translateToCssStyle(prop, val) { return mStyleTranslate(prop, val); }

function translateToGerman(w) {
	if (isNumber(w)) return w;
	else if (isdef(DD[w])) return DD[w];
	else return w;
}

function trash111() {
	let tgServer = G.serverData.tupleGroups;
	for (const tg of tgServer) {
		let desc = tg.desc.line.toString();
		let choices = tg.tuples._set;
		let tuples = choices.map(x => x._tuple);
		tupleGroups.push({ desc: desc, tuples: tuples });
	}
	return tupleGroups;
}

function tree_add() {
	let root = C.root;
	if (root.phase == 'spring') {
		C.changed = false;
		assertion(root, 'ROOT IS NULL BEI TREE_ADD!!!!!!!!!!!!!')
		if (!root.done) {
			let b = create_branch(root, root.angle, root.len * root.dlen, root.color);
			lookupAddToList(C.items, [b.t], b);
			C.changed = true;
		} else {
			for (const b of C.items.branch.filter(x => !x.done)) {
				if (b.age < root.depth) {
					let br = root.branching;
					for (const a of br) {
						let o = create_branch(b, b.angle + toRadian(a), b.len * root.dlen, colorMix(b.color, 'lime', 3)); lookupAddToList(C.items, [o.t], o);
					}
				} else {
					let o = create_leaf(b, root); lookupAddToList(C.items, [o.t], o);
				}
				C.changed = true;
				root.maxage = b.age + 1;
				b.done = true;
			}
		}
		if (!C.changed) { root.minage = 0; root.phase = 'summer'; }
	}
	else if (root.phase == 'summer') {
		let colors = ['darkgreen', 'olive', '#8B9216', '#A79F0F', '#EDA421', '#E98604', '#DF3908', '#C91E0A', '#8C584A'];
		let changed = mutate_colors('leaf', colors);
		if (!changed) root.phase = 'autumn';
		root.jitter = true;
		C.changed = true;
	}
	else if (root.phase == 'autumn') {
		root.jitter = false;
		C.changed = true;
		let falling = C.items.leaf.filter(l => l.p.y < CV.height);
		if (isEmpty(falling)) {
			C.changed = false; root.phase = 'winter';
		} else {
			for (const b of falling) { b.p = { x: b.p.x + Math.random() * .51, y: b.p.y + Math.random() * 3 }; }
		}
	}
	else if (root.phase == 'winter') {
		let colors = ['#8E2100', '#5C1306', '#371C0F', '#1C1B19'];
		let changed = mutate_colors('branch', colors);
		if (!changed) root.phase = 'over';
		C.changed = true;
	}
	else if (root.phase == 'over') { root.animated = false; }
	if (root.animated) TO.iv1 = setTimeout(tree_add, root.speed[root.phase]); else TO.iv1 = setTimeout(() => G_init('tree'), 3000);
}

function tree_clear() { G_clear(); onclick_menu_item('tree'); }

function tree_init(offx = 0, offy = 0, options = {}) {
	let root = {
		done: false,
		t: 'root',
		age: 0,
		p2: { x: offx + CV.width / 2, y: offy + CV.height },
		len: valf(options.len, 100),
		angle: toRadian(90),
		thickness: valf(options.thick, 20),
		color: valf(options.color, 'sienna'),
		depth: NATURE.depth,
		branching: NATURE.branching,
		dlen: .7,
		dthickness: .7,
		phase: 'spring',
		speed: { spring: 100, summer: 100, autumn: 25, winter: 100, over: 2000 },
		animated: false,
		jitter: false,
	};
	return root;
}

function treee(o) {
	let s = '<table class="tttable">';
	for (const k in o) {
		s += '<tr><th>' + k + '</th><td>';
		let val = o[k];
		let sval = isSet(val) ? empty(val._set) ? '{ }' : simpleRep(val) : isDict(val) ? treee(val) : simpleRep(val);
		s += sval + '</td>';
	}
	s += '</table>';
	return s;
}

function tri0() {
	let sq3 = 1.73205080757;
	let sq3b = Math.sqrt(3);
	console.log('sq3', sq3, 'sq3b', sq3b)
}

function tri1() {
	let sq3 = Math.sqrt(3);
	let a = 48;
	let wp = a / 4, hp = a / 4, h = sq3 * a / 2;
	let [xoff, dx, yoff, dy] = [h + wp / 2, 2 * h, hp / 2, a / 2];
	let [rows, maxcols] = [3, 4];
	let ys = 2 + 3 * rows;
	let xs = maxcols;
	let x = xoff, y = yoff;
	let pts = [];
	let infos = [];
	let idx = 0;
	let yEven = true;
	for (let i = 0; i < ys; i++) {
		let tcolOffset = yEven ? 1 : 0;
		let isCenterRow = i >= 2 && ((i - 2) % 3) == 0;
		for (let j = 0; j < xs + (1 - tcolOffset); j++) {
			let pt = { x: x, y: y };
			pts.push(pt);
			infos.push({ index: idx, tcol: tcolOffset + 2 * j, trow: i, x: x, y: y, pt: pt, isCenterRow: isCenterRow, isHexCenter: isCenterRow, isCenterCol: j % 2 == 1 });
			x += dx;
			idx += 1;
		}
		yEven = !yEven;
		y += dy; x = i % 2 ? xoff : wp / 2;
	}
	let byrc = {};
	for (const i of infos) {
		lookupSet(byrc, [i.trow, i.tcol], i.index);
	}
	console.log('byrc', byrc)
	let byxy = {};
	let adjList = [];
	let di = {};
	for (const info of infos) {
		let [r, c] = [info.trow, info.tcol];
		info.nodes = [
			lookup(byrc, [r - 2, c]),
			lookup(byrc, [r - 1, c + 1]),
			lookup(byrc, [r + 1, c + 1]),
			lookup(byrc, [r + 2, c]),
			lookup(byrc, [r + 1, c - 1]),
			lookup(byrc, [r + 1, c - 1]),
		];
		for (let i = 0; i < 6; i++) {
			let n1 = info.nodes[i];
			if (n1 == null) continue;
			let n2 = info.nodes[(i + 1 % 6)];
			if (n2 == null) continue;
			if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
			lookupSet(di, [n1, n2], true);
			adjList.push([n1, n2]);
		}
		info.neighbors = [
			lookup(byrc, [r - 3, c + 1]),
			lookup(byrc, [r, c + 2]),
			lookup(byrc, [r + 3, c + 1]),
			lookup(byrc, [r + 3, c - 1]),
			lookup(byrc, [r, c - 2]),
			lookup(byrc, [r - 3, c - 1]),
		];
	}
	let sym = chooseRandom(getAnimals());
	let items = [];
	for (const info of infos) {
		let item = info.isHexCenter ? drawBee(info.pt) : drawSym(sym, info.pt);
		items.push(item);
	}
}

function tri2() {
	let sq3 = Math.sqrt(3);
	let a = 48;
	let wp = a / 4, hp = a / 4, h = sq3 * a / 2;
	let [xoff, dx, yoff, dy] = [h + wp / 2, 2 * h, hp / 2, a / 2];
	let [rows, maxcols] = [3, 4];
	let ys = 2 + 3 * rows;
	let xs = maxcols;
	let x = xoff, y = yoff;
	let pts = [];
	let infos = [];
	let idx = 0;
	let yEven = true;
	for (let i = 0; i < ys; i++) {
		let tcolOffset = yEven ? 1 : 0;
		let isCenterRow = i >= 2 && ((i - 2) % 3) == 0;
		for (let j = 0; j < xs + (1 - tcolOffset); j++) {
			let pt = { x: x, y: y };
			pts.push(pt);
			infos.push({ index: idx, tcol: tcolOffset + 2 * j, trow: i, x: x, y: y, pt: pt, isCenterRow: isCenterRow, isHexCenter: isCenterRow, isCenterCol: j % 2 == 1 });
			x += dx;
			idx += 1;
		}
		yEven = !yEven;
		y += dy; x = i % 2 ? xoff : wp / 2;
	}
	let byrc = {};
	for (const i of infos) {
		lookupSet(byrc, [i.trow, i.tcol], i.index);
	}
	console.log('byrc', byrc)
	let byxy = {};
	let adjList = [];
	let di = {};
	for (const info of infos) {
		let [r, c] = [info.trow, info.tcol];
		info.nodes = [
			lookup(byrc, [r - 2, c]),
			lookup(byrc, [r - 1, c + 1]),
			lookup(byrc, [r + 1, c + 1]),
			lookup(byrc, [r + 2, c]),
			lookup(byrc, [r + 1, c - 1]),
			lookup(byrc, [r + 1, c - 1]),
		];
		for (let i = 0; i < 6; i++) {
			let n1 = info.nodes[i];
			if (n1 == null) continue;
			let n2 = info.nodes[(i + 1 % 6)];
			if (n2 == null) continue;
			if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
			lookupSet(di, [n1, n2], true);
			adjList.push([n1, n2]);
		}
		info.neighbors = [
			lookup(byrc, [r - 3, c + 1]),
			lookup(byrc, [r, c + 2]),
			lookup(byrc, [r + 3, c + 1]),
			lookup(byrc, [r + 3, c - 1]),
			lookup(byrc, [r, c - 2]),
			lookup(byrc, [r - 3, c - 1]),
		];
	}
	let sym = chooseRandom(getAnimals());
	let items = [];
	for (const info of infos) {
		let item = info.isHexCenter ? drawCenteredBee(info.pt) : drawCenteredPlainCircle(info.pt);
		items.push(item);
		let d = iDiv(item);
		if (info.isHexCenter) mClass(d, 'hexagon');
		if (info.isHexCenter) mText(info.trow + ' ' + info.tcol, d, { fz: 10 });
	}
}

function tri3() {
	let sq3 = Math.sqrt(3);
	let a = 48;
	let wp = a / 4, hp = a / 4, h = sq3 * a / 2;
	let [xoff, dx, yoff, dy] = [h + wp / 2, 2 * h, hp / 2, a / 2];
	let [rows, maxcols] = [3, 4];
	let ys = 2 + 3 * rows;
	let xs = maxcols;
	let x = xoff, y = yoff;
	let pts = [];
	let infos = [];
	let idx = 0;
	let yEven = true;
	for (let i = 0; i < ys; i++) {
		let tcolOffset = yEven ? 1 : 0;
		let isCenterRow = i >= 2 && ((i - 2) % 3) == 0;
		for (let j = 0; j < xs + (1 - tcolOffset); j++) {
			let pt = { x: x, y: y };
			pts.push(pt);
			infos.push({ index: idx, tcol: tcolOffset + 2 * j, trow: i, x: x, y: y, pt: pt, isCenterRow: isCenterRow, isHexCenter: isCenterRow, isCenterCol: j % 2 == 1 });
			x += dx;
			idx += 1;
		}
		yEven = !yEven;
		y += dy; x = i % 2 ? xoff : wp / 2;
	}
	let byrc = {};
	for (const i of infos) {
		lookupSet(byrc, [i.trow, i.tcol], i.index);
	}
	console.log('byrc', byrc)
	let byxy = {};
	let adjList = [];
	let di = {};
	for (const info of infos) {
		let [r, c] = [info.trow, info.tcol];
		info.nodes = [
			lookup(byrc, [r - 2, c]),
			lookup(byrc, [r - 1, c + 1]),
			lookup(byrc, [r + 1, c + 1]),
			lookup(byrc, [r + 2, c]),
			lookup(byrc, [r + 1, c - 1]),
			lookup(byrc, [r + 1, c - 1]),
		];
		for (let i = 0; i < 6; i++) {
			let n1 = info.nodes[i];
			if (n1 == null) continue;
			let n2 = info.nodes[(i + 1 % 6)];
			if (n2 == null) continue;
			if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
			lookupSet(di, [n1, n2], true);
			adjList.push([n1, n2]);
		}
		info.neighbors = [
			lookup(byrc, [r - 3, c + 1]),
			lookup(byrc, [r, c + 2]),
			lookup(byrc, [r + 3, c + 1]),
			lookup(byrc, [r + 3, c - 1]),
			lookup(byrc, [r, c - 2]),
			lookup(byrc, [r - 3, c - 1]),
		];
	}
	let sym = chooseRandom(getAnimals());
	let items = [];
	for (const info of infos) {
		let item = drawText(info.trow + ',' + info.tcol, info.pt);
		items.push(item);
	}
}

function tri4() {
	let sq3 = Math.sqrt(3);
	let a = 48;
	let wp = a / 4, hp = a / 4, h = sq3 * a / 2;
	let [xoff, dx, yoff, dy] = [h + wp / 2, 2 * h, hp / 2, a / 2];
	let [rows, maxcols] = [3, 4];
	let ys = 2 + 3 * rows;
	let xs = maxcols;
	let x = xoff, y = yoff;
	let pts = [];
	let infos = [];
	let idx = 0;
	let yEven = true;
	for (let i = 0; i < ys; i++) {
		let tcolOffset = yEven ? 1 : 0;
		let isCenterRow = i >= 2 && ((i - 2) % 3) == 0;
		for (let j = 0; j < xs + (1 - tcolOffset); j++) {
			let pt = { x: x, y: y };
			pts.push(pt);
			infos.push({ index: idx, tcol: tcolOffset + 2 * j, trow: i, x: x, y: y, pt: pt, isCenterRow: isCenterRow, isHexCenter: isCenterRow, isCenterCol: j % 2 == 1 });
			x += dx;
			idx += 1;
		}
		yEven = !yEven;
		y += dy; x = i % 2 ? xoff : wp / 2;
	}
	let byrc = {};
	for (const i of infos) {
		lookupSet(byrc, [i.trow, i.tcol], i.index);
	}
	console.log('byrc', byrc)
	let byxy = {};
	let adjList = [];
	let di = {};
	for (const info of infos) {
		let [r, c] = [info.trow, info.tcol];
		info.nodes = [
			lookup(byrc, [r - 2, c]),
			lookup(byrc, [r - 1, c + 1]),
			lookup(byrc, [r + 1, c + 1]),
			lookup(byrc, [r + 2, c]),
			lookup(byrc, [r + 1, c - 1]),
			lookup(byrc, [r + 1, c - 1]),
		];
		for (let i = 0; i < 6; i++) {
			let n1 = info.nodes[i];
			if (n1 == null) continue;
			let n2 = info.nodes[(i + 1 % 6)];
			if (n2 == null) continue;
			if (lookup(di, [n1, n2]) || lookup(di, [n2, n1])) continue;
			lookupSet(di, [n1, n2], true);
			adjList.push([n1, n2]);
		}
		info.neighbors = [
			lookup(byrc, [r - 3, c + 1]),
			lookup(byrc, [r, c + 2]),
			lookup(byrc, [r + 3, c + 1]),
			lookup(byrc, [r + 3, c - 1]),
			lookup(byrc, [r, c - 2]),
			lookup(byrc, [r - 3, c - 1]),
		];
	}
	let sym = chooseRandom(getAnimals());
	let items = [];
	for (const info of infos) {
		let item = drawText(info.trow + ',' + info.tcol, info.pt);
		if (info.isHexCenter) mStyle(iDiv(item), { bg: 'pink' })
		items.push(item);
	}
}

function trialPromptML() {
	let selinp = Selected.inp;
	say('try again!');
	setTimeout(() => {
		let d = selinp.div;
		d.innerHTML = '_';
		mClass(d, 'blink');
	}, skipAnimations ? 300 : 2000);
	showFleetingMessage(composeFleetingMessage(), 3000);
	return 10;
}

function trialPromptSP() {
	say(currentLanguage == 'E' ? 'try again!' : 'nochmal', 1, 1, .3, true, 'zira');
	animate(dInstruction, 'pulse800' + getSignalColor(), 900);
	return 1500;
}

function trialPromptSPA() {
	return 10;
}

function trialPromptTC() {
	say('try again');
	shortHintPic();
	return 10;
}

function trialPromptTP() {
	say('try again');
	shortHintPic();
	return 10;
}

function trialPromptWP() {
	say(currentLanguage == 'E' ? 'try again!' : 'nochmal', 1, 1, .8, true, 'zira');
	mLinebreak(dTable);
	inputBox = addNthInputElement(dTable, trialNumber);
	defaultFocusElement = inputBox.id;
	return 10;
}

function trickleDown(n, R, trickle) {
	currentSizing = trickle.sizing;
	let res = {};
	res.sizing = isdef(n.params) && isdef(n.params.sizing) ? n.params.sizing
		: isdef(currentSizing) ? currentSizing : R.defs.defaultSizing;
	return res;
}

function trim(str) {
	return str.replace(/^\s+|\s+$/gm, '');
}

function try_find_username(ev) {
	evNoBubble(ev);
	let username = findAttributeInAncestors(ev.target, 'username');
	if (nundef(Session.users_by_name[username])) { alert('ERROR username!'); return null; }
	return username;
}

function tryBegin(callback) { let route = '/begin/1'; _sendRouteJS(route, callback); }

function tryConvertToJSON(s) {
	let res = null;
	try { res = JSON.parse(s); return res; }
	catch {
		return null;
	}
}

function tsAction(x) { if ('ID' in x) return x.ID; else return x.val; }

function tsRec(x) {
	if (isList(x)) { return '[' + x.map(tsRec).join('') + ']'; }
	if (isDict(x)) {
		if ('_set' in x) {
			return '{' + tsRec(x._set) + '}';
		} else if ('_tuple' in x) {
			return '(' + tsRec(x._tuple) + ')'
		} else if ('type' in x) {
			return tsAction(x)
		} else { return 'obj unknown'; }
	} else return 'type unknown';
}

function ttBody(oid, o) {
	let sProps = '';
	let sVals = '';
	for (const p in o) {
		if (p == 'obj_type' || p == 'name' || p == 'id') continue;
		let val = o[p];
		sProps += p + '<br>';
		sVals += simpleRep(val) + '<br>';
	}
	$('div#ttipLeft').html(sProps);
	$('div#ttipRight').html(sVals);
}

function ttBody2(oid, o) {
	let s = treee(o);
	clearElement('ttipRight');
	$('div#ttipLeft').html(s);
}

function ttTitle(oid, o) {
	$('div#ttipTitle').html(('obj_type' in o ? o.obj_type : '_') + ('name' in o ? ':' + o.name : 'id' in o ? ':' + o.id : ' ' + oid));
}

function turn_create_otree(obj) {
	console.assert(isdef(obj.table), 'turn_create_otree without obj.table!!!!!!!!!!!!!!');
	let g = Session;
	let [menu, table, fen, plist, players] = [g.cur_menu, g.table, g.fen, g.plist, g.players] = ['play', obj.table, obj.table.fen, obj.playerdata, obj.table.fen.players];
	let otree = jsCopy(fen);
	let order = isdef(fen.plorder) ? fen.plorder : plist.map(x => x.name);
	otree.player_names = order;
	for (const uname of order) {
		let pl = firstCond(plist, x => x.name == uname);
		copyKeys(DB.users[uname], pl);
		copyKeys(fen.players[uname], pl);
		otree[uname] = pl;
	}
	addKeys(fen, otree);
	delete otree.players;
	return otree;
}

function turn_create_R(otree) {
	Items = {};
	let g = Session;
	R = g.R = new RSG(); R.otree = otree;
	let r_keys = R.keys = Session.game_keys.r_nodes;
	let akku = G.akku = [];
	let root = R.root = rec_create_nodes_tree_akku(R, otree, '', r_keys, akku);
	return R;
}

function turn_new_schwein_up(schwein, fenbuilding, uibuilding) {
	let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
	let is_first_schwein = isEmpty(fenbuilding.schweine);
	add_schwein(schwein, fenbuilding, uibuilding);
	ari_history_list([`${uplayer} reveals a schwein!`], 'inspect');
	if (is_first_schwein) {
		console.log('unique AND first new schwein');
		show_instruction('found schwein - both players get a rumor!');
		let owner = stringAfter(uibuilding.path, '.');
		owner = stringBefore(owner, '.');
		console.log('owner', owner, 'uplayer', uplayer);
		A.owner = owner;
		ari_open_rumors(32);
	} else {
		console.log('unique new schwein (gibt schon schweine)')
		show_instruction('found schwein - you gain a rumor!');
		let rumor = fen.deck_rumors[0]; fen.deck_rumors.shift();
		fen.players[uplayer].rumors.push(rumor);
		ari_history_list([`${uplayer} inspects a schweine building!`], 'inspect');
		ari_next_action();
	}
}

function turn_package_otree(otree) {
	let keys = Session.game_keys.players;
	let fen = otree;
	fen.players = {};
	for (const plname of otree.plorder) fen.players[plname] = stripToKeys(otree[plname], keys);
	otree.plorder.map(x => delete fen[x]);
	return fen;
}

function turn_present(obj) {
	if (ITER >= Math.min(DA.iter, MAXITER)) { console.log('iter', ITER == MAXITER ? 'MAX' : 'DA.iter'); TOMan.clear(); return; } ITER++;
	let otree = turn_unpackage_fen(obj);
	let rtree = turn_create_R(otree);
	ui_table_actions_stats();
	if (G.cur_game == 'gAristo') { ari_branch(obj, otree, rtree); }
	else if (G.cur_game == 'gPreinno') { inno_branch(obj, otree, rtree); }
}

function turn_schwein_up(b) {
	let key = b.keycard.key;
	let list = b.list;
	let schwein = firstCond(list, x => x[0] != key[0]);
	assertion(isdef(schwein), 'WAS DA IST GARKEIN SCHWEIN!!!!!!!!!!', b);
	let ui = firstCond(b.items, x => x.key == schwein);
	face_up(ui);
	let obuilding = lookup(Z.fen, b.path.split('.'));
	b.schwein = obuilding.schwein = schwein;
	ari_open_rumors(32);
}

function turn_send_gameover(otree, uname) {
	let fen = turn_package_otree(otree);
	let g = Session;
	let o = { uname: uname, tid: g.table.id, fen: fen, table_status: 'over' };
	to_server(o, 'turn_update');
}

function turn_send_move_update(otree, uname) {
	let fen = turn_package_otree(otree);
	let g = Session;
	let o = { uname: uname, tid: g.table.id, fen: fen, table_status: g.table.status };
	to_server(o, 'turn_update');
}

function turn_send_reload(uname) {
	let g = Session;
	let o = { uname: uname, tid: g.table.id, table_status: g.table.status };
	to_server(o, 'turn_update');
}

function turn_set_game_assets(g) {
	if (g.cur_game == 'gPreinno') g.cards = InnoById;
	else if (g.cur_game == 'gAristo') g.cards = Aristocards;
}

function turn_set_keys(g, obj) {
	let fen = obj.table.fen;
	let di = {
		table: get_keys(fen),
		players: get_keys(fen.players[fen.plorder[0]]),
		r_nodes: [],
		ui_nodes: []
	};
	let rks = arrMinus(di.table.concat(di.players), ['splays', 'herald', 'plorder', 'coins']);
	rks = arrPlus(rks, ['green', 'purple', 'blue', 'red', 'yellow']);
	rks = rks.concat(fen.plorder);
	di.r_nodes = rks;
	di.ui_nodes = arrMinus(di.r_nodes, []);
	g.game_keys = {};
	for (const k in di) {
		let di1 = g.game_keys[k] = {};
		for (const k1 of di[k]) di1[k1] = true;
	}
}

function turn_show_gameover(otree) {
	let game = Session.cur_game;
	let table = Session.cur_table;
	let players = otree2cur_players(otree);
	let winner = otree.winner;
	if (!Session.scoring_complete) {
		console.log('======>scoring!!!!!', table.friendly);
		scoring_update(otree.plorder, [otree.winner], game);
		out1();
		Session.scoring_complete = true;
	}
	let pl = otree[winner];
	let styles = { bg: pl.color, alpha: .75, fg: 'contrast', top: 220, };
	let msg = 'GAME OVER - The ' + `winner is ${otree.winner}!!!`;
	let d = status_message(msg, styles);
	let end_scores = table.status == 'past' ? table.end_scoring : get_scores_from_cur_players();
	show_score_table(end_scores, table.friendly, d);
	mLinebreak(d);
	mButton('click to close', onclick_gameover_new, d, { fz: 20 }, ['buttonClass', 'donebutton']);
}

function turn_unpackage_fen(obj) {
	let g = Session;
	turn_set_game_assets(g);
	turn_set_keys(g, obj);
	g.obj = ServerData = obj;
	let otree = Fen = g.otree = turn_create_otree(obj);
	return otree;
}

function turnCardsAfter(secs, removeBg = false) {
	let qc = QContextCounter;
	for (const p of Pictures) { slowlyTurnFaceDown(p, secs - 1, removeBg); }
	TOMain = setTimeout(() => {
		showInstruction(Goal.label, 'click', dTitle, true);
		showMouse();
		GC.activateUi.bind(GC)();
	}, secs * 1000);
}

function turnDeckFaceUp(deck) { if (deck.isFaceDown) { deck.flip(); deck.isFaceDown = false; } }

function turnFaceDown(pic) {
	let ui = iDiv(pic);
	for (const p1 of ui.children) p1.style.opacity = 0;
	ui.style.backgroundColor = 'dimgray';
	pic.isFaceUp = false;
}

function turnFaceDownSimple(pic) {
	let ui = iDiv(pic);
	ui.style.transition = null;
	mRemoveClass(ui, 'frameOnHover');
	for (const ch of ui.children) { ch.style.transition = null; ch.style.opacity = 0; }
	pic.isFaceUp = false;
}

function turnFaceUp(pic, secTransition = 1) {
	let div = iDiv(pic);
	for (const ch of div.children) {
		ch.style.transition = `opacity ${secTransition}s ease-in-out`;
		ch.style.opacity = 1;
	}
	div.style.transition = null;
	div.style.backgroundColor = pic.bg;
	pic.isFaceUp = true;
}

function turnFaceUpSimple(pic) {
	let ui = iDiv(pic);
	mRemoveClass(ui, 'frameOnHover');
	ui.style.transition = null;
	for (const ch of ui.children) { ch.style.transition = null; ch.style.opacity = 1; }
	pic.isFaceUp = true;
}

function turtle() {
	background(51);
	stroke(255);
	translate(width / 2, height);
	for (let i = 0; i < sentence.length; i++) {
		let x = sentence.charAt(i);
		if ('ABF'.includes(x)) { line(0, 0, 0, -len); translate(0, -len); }
		else if (x == '+') rotate(angle);
		else if (x == '-') rotate(-angle);
		else if (x == '[') push();
		else if (x == ']') pop();
	}
}

function ty01() {
}

function type00flex(n, R) { return 'type00flex'; }

function typeEmpty(n, R) { return 'empty'; }

function typePanelInfo(n, R) { return isdef(n.children) ? 'panel' : 'info'; }

function ui_add_cards_to_card_container(cont, items, list) {
	if (nundef(list)) list = items.map(x => x.key);
	for (const item of items) {
		mAppend(cont, iDiv(item));
	}
}

function ui_add_cards_to_deck_container(cont, items, list) {
	if (nundef(list)) list = items.map(x => x.key);
	for (const item of items) {
		mAppend(cont, iDiv(item));
		mItemSplay(item, list, 4, Card.ovdeck);
		face_down(item);
	}
	return items[0];
}

function ui_add_cards_to_hand_container(cont, items, list) {
	if (nundef(list)) list = items.map(x => x.key);
	for (const item of items) {
		mAppend(cont, iDiv(item));
		mItemSplay(item, list, 2, Card.ovw);
	}
}

function ui_add_container_title(title, cont, items, show_if_empty) {
	if (isdef(title) && (!isEmpty(items) || show_if_empty)) {
		let st = get_containertitle_styles();
		let stmeasure = jsCopy(st); delete stmeasure.position;
		let elem = mText(title, cont, stmeasure);
		let sz = getSizeNeeded(elem);
		let offsetx = valf(st.left, 0);
		let cont_wmin = mGetStyle(cont, 'wmin');
		let my_min = sz.w + offsetx * 1.5;
		let wmin = !isNumber(cont_wmin) ? my_min : Math.max(valf(cont_wmin, 0), my_min);
		mStyle(cont, { wmin: wmin });
		mStyle(elem, st);
	}
}

function ui_from_deck_to_hand(el, deck, hand) {
	let topmost = deck.items.shift();
	console.assert(el == topmost, 'top deck elem is NOT correct!!!!')
	face_up(topmost);
	let dtop = iDiv(topmost);
	deck.list = deck.items.map(x => x.key);
	deck.topmost = deck.items[0];
	dtop.remove();
	dtop.style.position = 'static';
	hand.items.push(topmost);
	hand.list = hand.items.map(x => x.key);
	mAppend(hand.container, dtop);
	mContainerSplay(hand.container, 2, CWIDTH, CHEIGHT, hand.list.length, OVW);
	mItemSplay(topmost, hand.list, 2, OVW);
}

function ui_game_menu_item(g, g_tables = []) {
	function runderkreis(color, id) {
		return `<div id=${id} style='width:20px;height:20px;border-radius:50%;background-color:${color};color:white;position:absolute;left:0px;top:0px;'>` + '' + "</div>";
	}
	let [sym, bg, color, id] = [Syms[g.logo], g.color, null, getUID()];
	if (!isEmpty(g_tables)) {
		let t = g_tables[0];
		let have_another_move = t.player_status == 'joined';
		color = have_another_move ? 'green' : 'red';
		id = `rk_${t.id}`;
	}
	return `
  <div onclick="onclick_game_menu_item(event)" gamename=${g.id} style='cursor:pointer;border-radius:10px;margin:10px;padding:5px;padding-top:15px;width:120px;height:90px;display:inline-block;background:${bg};position:relative;'>
  ${nundef(color) ? '' : runderkreis(color, id)}
  <span style='font-size:50px;font-family:${sym.family}'>${sym.text}</span><br>${g.friendly.toString()}</div>
  `;
}

function ui_game_stats(players) {
	let d = dTitle;
	clearElement(d);
	let d1 = mDiv(d, { display: 'flex', 'justify-content': 'center', 'align-items': 'space-evenly' });
	for (const plname in players) {
		let pl = players[plname];
		let d2 = mDiv(d1, { margin: 4, align: 'center' }, null, `<img src='${pl.imgPath}' style="display:block" class='img_person' width=50 height=50>${pl.score}`);
	}
}

function ui_get_all_commission_items(uplayer) {
	let items = [], i = 0;
	let comm = UI.players[uplayer].commissions;
	for (const o of comm.items) {
		let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: comm.path, index: i };
		i++;
		items.push(item);
	}
	return items;
}

function ui_get_all_hidden_building_items(uplayer) {
	let items = [];
	for (const gb of UI.players[uplayer].buildinglist) {
		items = items.concat(ui_get_hidden_building_items(gb));
	}
	reindex_items(items);
	return items;
}

function ui_get_blackmailed_items() {
	let [fen, uplayer] = [Z.fen, Z.uplayer];
	let commands = ['accept', 'reject'];
	let rumors = fen.players[uplayer].rumors;
	let b = path2fen(fen, fen.blackmail.building_path);
	if (nundef(b.lead)) b.lead = b.list[0];
	if (isList(rumors) && firstCond(rumors, x => x[0] == b.lead[0])) {
		commands.push('defend');
	}
	return ui_get_string_items(commands);
}

function ui_get_bluff_inputs(strings) {
	let uplayer = Z.uplayer;
	let items = ui_get_string_items(uplayer, strings);
	console.log('items', items)
	return items;
}

function ui_get_build_items(uplayer, except) {
	let items = ui_get_hand_and_stall_items(uplayer);
	if (is_card(except)) items = items.filter(x => x.key != except.key);
	reindex_items(items);
	return items;
}

function ui_get_building_items(uplayer) {
	let gblist = UI.players[uplayer].buildinglist;
	let items = [], i = 0;
	for (const o of gblist) {
		let name = o.type + ' ' + (o.list[0][0] == 'T' ? '10' : o.list[0][0]);
		o.div = o.container;
		let item = { o: o, a: name, key: o.list[0], friendly: name, path: o.path, index: i, ui: o.container };
		i++;
		items.push(item);
	}
	return items;
}

function ui_get_building_items_of_type(uplayer, types = ['farm', 'estate', 'chateau']) {
	let gblist = UI.players[uplayer].buildinglist.filter(x => types.includes(x.type));
	let items = [], i = 0;
	for (const o of gblist) {
		let name = o.type + ' ' + (o.list[0][0] == 'T' ? '10' : o.list[0][0]);
		o.div = o.container;
		let item = { o: o, a: name, key: o.list[0], friendly: name, path: o.path, index: i, ui: o.container };
		i++;
		items.push(item);
	}
	return items;
}

function ui_get_buildings(gblist) {
	let items = [], i = 0;
	for (const o of gblist) {
		let name = o.type + ' ' + (o.list[0][0] == 'T' ? '10' : o.list[0][0]);
		o.div = o.container;
		let item = { o: o, a: name, key: o.list[0], friendly: name, path: o.path, index: i, ui: o.container };
		i++;
		items.push(item);
	}
	return items;
}

function ui_get_buy_or_pass_items() {
	let items = [], i = 0;
	if (!isEmpty(UI.deck_discard.items)) items.push(ui_get_deck_item(UI.deck_discard));
	items = items.concat(ui_get_string_items(['pass']));
	reindex_items(items);
	return items;
}

function ui_get_card_items(cards) {
	let items = [], i = 0;
	for (const o of cards) {
		let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: ``, index: i };
		i++;
		items.push(item);
	}
	return items;
}

function ui_get_church_items(uplayer) {
	let fen = Z.fen;
	let items = [], i = 0;
	let church = UI.church;
	for (const o of church.items) {
		let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: church.path, index: i };
		i++;
		items.push(item);
	}
	let candidates = fen.candidates = arrMinus(fen.toBeSelected, uplayer);
	if (candidates.length > 1) {
		let player_items = ui_get_string_items(candidates);
		items = items.concat(player_items);
		reindex_items(items);
	}
	return items;
}

function ui_get_coin_amounts(uplayer) {
	let items = [];
	for (let i = 0; i <= Z.fen.players[uplayer].coins; i++) {
		let cmd = '' + i;
		let item = { o: null, a: cmd, key: cmd, friendly: cmd, path: null, index: i };
		items.push(item);
	}
	return items;
}

function ui_get_commands(uplayer) {
	let avail = ari_get_actions(uplayer);
	let items = [], i = 0;
	for (const cmd of avail) {
		let item = { o: null, a: cmd, key: cmd, friendly: cmd, path: null, index: i };
		i++;
		items.push(item);
	}
	return items;
}

function ui_get_commission_items(uplayer) {
	let items = [], i = 0;
	let comm = UI.players[uplayer].commissions;
	let stall = ui_get_stall_items(uplayer);
	for (const o of comm.items) {
		let rank = o.key[0];
		let similar = firstCond(stall, x => x.key[0] == rank);
		if (!similar) continue;
		let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: comm.path, index: i, similar: stall.filter(x => x.key[0] == rank) };
		i++;
		items.push(item);
	}
	return items;
}

function ui_get_commission_new_items(uplayer) {
	let items = [], i = 0;
	let comm = UI.open_commissions;
	for (const o of comm.items) {
		let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: comm.path, index: i };
		i++;
		items.push(item);
	}
	let topdeck = UI.deck_commission.get_topcard();
	items.push({ o: topdeck, a: topdeck.key, key: topdeck.key, friendly: topdeck.short, path: 'deck_commission', index: i });
	return items;
}

function ui_get_commission_stall_items() {
	let [A, fen, uplayer] = [Z.A, Z.fen, Z.uplayer];
	console.log('ui_get_commission_stall_items similar', A.commission.similar);
	let items = A.commission.similar;
	reindex_items(items);
	return items;
}

function ui_get_deck_item(uideck) {
	let topdeck = uideck.get_topcard();
	let item = { o: topdeck, a: topdeck.key, key: topdeck.key, friendly: topdeck.short, path: uideck.path, index: 0 };
	return item;
}

function ui_get_endgame(uplayer) { return ui_get_string_items(['end game', 'go on']); }

function ui_get_estates_chateaus_items(uplayer) { return ui_get_building_items_of_type(uplayer, ['estate', 'chateau']); }

function ui_get_exchange_items(uplayer) {
	let ihand = ui_get_hand_items(uplayer);
	let istall = ui_get_stall_items(uplayer);
	let irepair = ui_get_all_hidden_building_items(uplayer);
	irepair.map(x => face_up(x.o));
	let items = ihand.concat(istall).concat(irepair);
	reindex_items(items);
	return items;
}

function ui_get_farms_estates_items(uplayer) { return ui_get_building_items_of_type(uplayer, ['farm', 'estate']); }

function ui_get_ferro_items() {
	let [plorder, stage, A, fen, uplayer, pl] = [Z.plorder, Z.stage, Z.A, Z.fen, Z.uplayer, Z.fen.players[Z.uplayer]];
	let items = ui_get_hand_items(uplayer);
	for (const plname of plorder) {
		let jlist = UI.players[plname].journeys;
		for (const jitem of jlist) {
			for (const o of jitem.items) {
				if (!is_joker(o)) { continue; }
				let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: jitem.path, index: 0 };
				items.push(item);
			}
		}
	}
	for (const plname of plorder) {
		let jlist = UI.players[plname].journeys;
		for (const jitem of jlist) {
			let o = jitem.items[0];
			let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: jitem.path, index: 0 };
			items.push(item);
		}
	}
	let cmds = ui_get_submit_items(['discard', 'auflegen', 'jolly', 'anlegen']);
	items = items.concat(cmds);
	reindex_items(items);
	return items;
}

function ui_get_hand_and_journey_items(uplayer) {
	let items = ui_get_hand_items(uplayer);
	let matching = [];
	for (const plname of Z.plorder) {
		let jitems = ui_get_journey_items(plname);
		for (const j of jitems) {
			for (const card of items) {
				if (matches_on_either_end(card, j)) { matching.push(j); break; }
			}
		}
	}
	items = items.concat(matching);
	reindex_items(items);
	return items;
}

function ui_get_hand_and_stall_items(uplayer) {
	let items = ui_get_hand_items(uplayer);
	items = items.concat(ui_get_stall_items(uplayer));
	reindex_items(items);
	return items;
}

function ui_get_hand_items(uplayer) {
	let items = [], i = 0;
	let hand = UI.players[uplayer].hand;
	for (const o of hand.items) {
		o.index = i;
		let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: hand.path, index: i };
		i++;
		items.push(item);
	}
	return items;
}

function ui_get_hand_items_minus(uplayer, cardlist) {
	if (!isList(cardlist)) cardlist = [cardlist];
	let items = [], i = 0;
	let hand = UI.players[uplayer].hand;
	for (const o of hand.items) {
		if (cardlist.includes(o)) continue;
		let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: hand.path, index: i };
		i++;
		items.push(item);
	}
	return items;
}

function ui_get_harvest_items(uplayer) {
	let items = []; let i = 0;
	for (const gb of UI.players[uplayer].buildinglist) {
		if (isdef(gb.harvest)) {
			let d = gb.harvest;
			mStyle(d, { cursor: 'pointer', opacity: 1 });
			gb.div = d;
			let name = 'H' + i + ':' + (gb.list[0][0] == 'T' ? '10' : gb.list[0][0]);
			let item = { o: gb, a: name, key: name, friendly: name, path: gb.path, index: i };
			i++;
			items.push(item);
		}
	}
	return items;
}

function ui_get_hidden_building_items(uibuilding) {
	let items = [];
	for (let i = 1; i < uibuilding.items.length; i++) {
		let o = uibuilding.items[i];
		o.index = i;
		let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: uibuilding.path, index: i - 1 };
		items.push(item);
	}
	return items;
}

function ui_get_journey_items(plname) {
	let gblist = UI.players[plname].journeys;
	let items = [], i = 0;
	for (const o of gblist) {
		let name = `${plname}_j${i}`;
		o.div = o.container;
		let item = { o: o, a: name, key: o.list[0], friendly: name, path: o.path, index: i, ui: o.container };
		i++;
		items.push(item);
	}
	return items;
}

function ui_get_market_items() {
	let items = [], i = 0;
	for (const o of UI.market.items) {
		o.index = i;
		let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: `market`, index: i };
		i++;
		items.push(item);
	}
	return items;
}

function ui_get_open_discard_items() {
	let items = [], i = 0;
	for (const o of UI.open_discard.items) {
		let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: `open_discard`, index: i };
		i++;
		items.push(item);
	}
	return items;
}

function ui_get_other_buildings(uplayer) {
	let items = [];
	for (const plname of Z.plorder) {
		if (plname == uplayer) continue;
		items = items.concat(ui_get_buildings(UI.players[plname].buildinglist));
	}
	reindex_items(items);
	return items;
}

function ui_get_other_buildings_and_rumors(uplayer) {
	let items = ui_get_other_buildings(uplayer);
	items = items.concat(ui_get_rumors_items(uplayer));
	reindex_items(items);
	return items;
}

function ui_get_other_buildings_with_rumors(uplayer) {
	let items = [];
	for (const plname of Z.plorder) {
		if (plname == uplayer) continue;
		items = items.concat(ui_get_buildings(UI.players[plname].buildinglist.filter(x => !isEmpty(x.rumors))));
	}
	reindex_items(items);
	return items;
}

function ui_get_payment_items(pay_letter) {
	let [fen, A, uplayer] = [Z.fen, Z.A, Z.uplayer];
	let items = ui_get_hand_and_stall_items(uplayer);
	let n = items.length;
	items = items.filter(x => x.key[0] == pay_letter);
	if (n == 4 && A.command == 'build') items = [];
	if (n == 1 && A.command == 'upgrade') items = [];
	if (fen.players[uplayer].coins > 0 && fen.phase[0].toUpperCase() == pay_letter) {
		items.push({ o: null, a: 'coin', key: 'coin', friendly: 'coin', path: null });
	}
	let i = 0; items.map(x => { x.index = i; i++; });
	return items;
}

function ui_get_rumors_and_players_items(uplayer) {
	let items = [], i = 0;
	let comm = UI.players[uplayer].rumors;
	let [data, pl] = [Z.uplayer_data, Z.pl];
	assertion(isdef(data), 'no data for player ' + uplayer);
	if (!isDict(data.state)) data.state = { remaining: jsCopy(pl.rumors), receivers: [], di: {} };
	let rem = data.state.remaining;
	for (const k of rem) {
		let o = firstCond(comm.items, x => x.key == k);
		let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: comm.path, index: i };
		i++;
		items.push(item);
	}
	let players = [];
	let receivers = data.state.receivers;
	for (const plname in UI.players) {
		if (plname == uplayer || receivers.includes(plname)) continue;
		players.push(plname);
	}
	items = items.concat(ui_get_string_items(players));
	reindex_items(items);
	return items;
}

function ui_get_rumors_items(uplayer) {
	let items = [], i = 0;
	let rum = UI.players[uplayer].rumors;
	for (const o of rum.items) {
		let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: rum.path, index: i };
		i++;
		items.push(item);
	}
	return items;
}

function ui_get_schweine_candidates(uibuilding) {
	let items = ui_get_hidden_building_items(uibuilding);
	items = items.filter(x => x.o.key[0] != uibuilding.keycard.key[0]);
	reindex_items(items);
	return items;
}

function ui_get_stall_items(uplayer) {
	let items = [], i = 0;
	let stall = UI.players[uplayer].stall;
	for (const o of stall.items) {
		o.index = i;
		let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: stall.path, index: i };
		i++;
		items.push(item);
	}
	return items;
}

function ui_get_string_items(commands) {
	let items = [], i = 0;
	for (const cmd of commands) {
		let item = { o: null, a: cmd, key: cmd, friendly: cmd, path: null, index: i };
		i++;
		items.push(item);
	}
	return items;
}

function ui_get_submit_items(commands) {
	let items = [], i = 0;
	for (const cmd of commands) {
		let item = { o: null, a: cmd, key: cmd, friendly: cmd, path: null, index: i, submit_on_click: true, itemtype: 'submit' };
		i++;
		items.push(item);
	}
	return items;
}

function ui_get_top_rumors() {
	let items = [], i = 0;
	for (const o of UI.rumor_top.items) {
		let item = { o: o, a: o.key, key: o.key, friendly: o.short, path: `rumor_top`, index: i };
		i++;
		items.push(item);
	}
	return items;
}

function ui_get_trade_items(uplayer) {
	let items = ui_get_market_items(uplayer);
	items = items.concat(ui_get_stall_items(uplayer));
	for (const plname of Z.fen.plorder) {
		if (plname != uplayer) items = items.concat(ui_get_stall_items(plname));
	}
	reindex_items(items);
	return items;
}

function ui_ground_zero() {
	STOPAUS = true;
	uiActivated = aiActivated = false;
	clearTimeouts();
	if (isdef(G) && isdef(G.clear)) G.clear();
	if (isdef(GC) && isdef(GC.clear)) GC.clear();
	TOMan.clear();
	clearMarkers();
	resetUIDs();
	Items = {};
}

function ui_make_card_container(n, dParent, styles = { bg: 'random', padding: 10 }) {
	let id = getUID('u');
	let d = mDiv(dParent, styles, id);
	return d;
}

function ui_make_container(dParent, styles = { bg: 'random', padding: 10 }) {
	let id = getUID('u');
	let d = mDiv(dParent, styles, id);
	return d;
}

function ui_make_deck_container(list, dParent, styles = { bg: 'random', padding: 10 }, get_card_func) {
	let id = getUID('u');
	let d = mDiv(dParent, styles, id);
	if (isEmpty(list)) return d;
	let c = get_card_func(list[0]);
	mContainerSplay(d, 4, c.w, c.h, n, 0);
	return d;
}

function ui_make_hand_container(items, dParent, styles = { bg: 'random', padding: 10 }) {
	let id = getUID('u');
	let d = mDiv(dParent, styles, id);
	if (!isEmpty(items)) {
		let card = items[0];
		mContainerSplay(d, 2, card.w, card.h, items.length, card.ov * card.w);
	}
	return d;
}

function ui_make_player(otree, uname, dParent) {
	let id = getUID('u');
	let bg = otree[uname].color;
	let styles = { bg: bg, fg: 'contrast', w: '100%' };
	d = mDiv(dParent, styles, id, uname);
	return d;
}

function ui_make_random_deck(n = 10) {
	let list = choose(get_keys(Aristocards), n);
	let cont = ui_make_deck_container(n, dTable, { bg: 'random', padding: 4 });
	let items = list.map(x => ari_get_card(x));
	let topmost = ui_add_cards_to_deck_container(cont, items, list);
	return {
		list: list,
		container: cont,
		items: items,
		topmost: topmost,
	};
}

function ui_make_random_hand(n = 1) {
	let list = choose(get_keys(Aristocards), n);
	let cont = ui_make_hand_container(n, dTable, { bg: 'random', padding: 4 });
	let items = list.map(x => ari_get_card(x));
	ui_add_cards_to_hand_container(cont, items, list);
	return {
		list: list,
		container: cont,
		items: items,
	};
}

function ui_make_random_market(n = 1) {
	let cont = ui_make_card_container(n, dTable, { bg: 'random', padding: 4, display: 'flex' });
	let list = choose(get_keys(Aristocards), n);
	let items = list.map(x => ari_get_card(x));
	if (n > 0) ui_add_cards_to_card_container(cont, items, list);
	return {
		list: list,
		container: cont,
		items: items,
	};
}

function ui_make_table() {
	let d = mBy('inner_left_panel'); clearElement(d);
	let dou = mDiv100(d, { display: 'flex' });
	dTable = mDiv(dou, { flex: 5, display: 'flex' });
	return dTable;
}

function ui_player_info(dParent, outerStyles = { dir: 'column' }, innerStyles = {}) {
	let fen = Z.fen;
	if (nundef(outerStyles.display)) outerStyles.display = 'flex';
	mStyle(dParent, outerStyles);
	let items = {};
	let styles = jsCopy(innerStyles); addKeys({ rounding: 10, bg: '#00000050', margin: 4, padding: 4, patop: 12, box: true, 'border-style': 'solid', 'border-width': 6 }, styles);
	let order = get_present_order();
	for (const plname of order) {
		let pl = fen.players[plname];
		let uname = pl.name;
		let imgPath = `../base/assets/users/${uname}.jpg`;
		styles['border-color'] = get_user_color(uname);
		let item = mDivItem(dParent, styles, name2id(uname));
		let d = iDiv(item);
		let picstyle = { w: 50, h: 50, box: true };
		let ucolor = get_user_color(uname);
		if (pl.playmode == 'bot') {
			copyKeys({ rounding: 0, border: `double 6px ${ucolor}` }, picstyle);
		} else {
			copyKeys({ rounding: '50%', border: `solid 2px white` }, picstyle);
		}
		let img = mImage(imgPath, d, picstyle, 'img_person');
		items[uname] = item;
	}
	if (DA.SIMSIM || is_advanced_user()) activate_playerstats(items)
	return items;
}

function ui_present_stats(otree) {
	let players = otree.player_names;
	let items = ui_player_info(players.map(x => otree[x]));
	for (const uname of players) {
		let pl = otree[uname];
		let totals = inno_calc_visible_syms(pl.board, pl.splays);
		pl.totals = totals;
		let item = items[uname];
		let d = iDiv(item); mCenterFlex(d); mLinebreak(d);
		for (const r in totals) {
			inno_stat_sym(r, totals[r], d, 20);
		}
	}
	return items;
}

function ui_present_table(r, dParent) {
	let g = Session;
	let uitree = r.uiNodes = {};
	if (g.cur_game == 'gPreinno') inno_create_ui_tree(R.root, dParent, r);
	else if (g.cur_game == 'gAristo') ari_create_ui_tree(R.root, dParent, r);
	return uitree;
}

function ui_table_actions_stats() {
	let d = mBy('inner_left_panel'); clearElement(d);
	let dou = mDiv100(d, { display: 'flex' });
	dTable = mDiv(dou, { flex: 5, display: 'flex', overflow: 'auto', position: 'relative' });
	mCenterFlex(dTable, false);
	dTable.animate([{ opacity: 0, transform: 'translateY(50px)' }, { opacity: 1, transform: 'translateY(0px)' },], { fill: 'both', duration: 1000, easing: 'ease' });
	dTop = mDiv(dTable, { bg: '#00000040', fg: 'white', w: '100%' }, 'dOben', 'hallo');
	dTop.innerHTML = '';
	dOben = mDiv(dTable, { bg: '#ffffff40', w: '100%' }, 'dOben', 'hallo');
	dOben.innerHTML = '';
	dActions = mDiv(dOben, { w: '100%' });
	for (let i = 0; i <= 5; i++) {
		window[`dActions${i}`] = mDiv(dActions, { w: '100%' });
	}
	dError = mDiv(dOben, { w: '100%', bg: 'red', fg: 'yellow' });
	dPlayerStats = dRechts = mDiv(dou, { flex: 1 }, 'dRechts', 'hallo');
}

function ui_type_building(b, dParent, styles = {}, path = 'farm', title = '', get_card_func = ari_get_card, separate_lead = false, ishidden = false) {
	let cont = ui_make_container(dParent, get_container_styles(styles));
	let cardcont = mDiv(cont);
	let list = b.list;
	let d = mDiv(dParent);
	let items = list.map(x => get_card_func(x));
	reindex_items(items);
	let d_harvest = null;
	if (isdef(b.h)) {
		let keycard = items[0];
		let d = iDiv(keycard);
		mStyle(d, { position: 'relative' });
		d_harvest = mDiv(d, { position: 'absolute', w: 20, h: 20, bg: 'orange', opacity: .5, fg: 'black', top: '45%', left: -10, rounding: '50%', align: 'center' }, null, 'H');
	}
	let d_rumors = null, rumorItems = [];
	if (!isEmpty(b.rumors)) {
		let d = cont;
		mStyle(d, { position: 'relative' });
		d_rumors = mDiv(d, { display: 'flex', gap: 2, position: 'absolute', h: 30, bottom: 0, right: 0 });
		for (const rumor of b.rumors) {
			let dr = mDiv(d_rumors, { h: 24, w: 16, vmargin: 3, align: 'center', bg: 'dimgray', rounding: 2 }, null, 'R');
			rumorItems.push({ div: dr, key: rumor });
		}
	}
	let card = isEmpty(items) ? { w: 1, h: 100, ov: 0 } : items[0];
	let [ov, splay] = separate_lead ? [card.ov * 1.5, 5] : [card.ov, 2];
	mContainerSplay(cardcont, 5, card.w, card.h, items.length, card.ov * 1.5 * card.w);
	ui_add_cards_to_hand_container(cardcont, items, list);
	ui_add_container_title(title, cont, items);
	let uischweine = [];
	for (let i = 1; i < items.length; i++) {
		let item = items[i];
		if (!b.schweine.includes(i)) face_down(item); else add_ui_schwein(item, uischweine);
	}
	return {
		ctype: 'hand',
		list: list,
		path: path,
		container: cont,
		cardcontainer: cardcont,
		items: items,
		schweine: uischweine,
		harvest: d_harvest,
		rumors: rumorItems,
		keycard: items[0],
	};
}

function ui_type_church(list, dParent, styles = {}, path = 'trick', title = '', get_card_func = ari_get_card, show_if_empty = false) {
	let cont = ui_make_container(dParent, get_container_styles(styles));
	let cardcont = mDiv(cont, { display: 'flex' });
	let items = [];
	let n = Z.plorder.length;
	let inc = 90;
	let rotation = n % 2 ? 0 : 90;
	for (const ckey of list) {
		let d = mDiv(cardcont, { origin: 'center', transform: `rotate( ${rotation}deg )`, position: 'absolute', left: 8 });
		let c = get_card_func(ckey);
		if (ckey != arrLast(list)) face_down(c);
		mAppend(d, iDiv(c));
		remove_card_shadow(c);
		let item = { card: c, div: d };
		items.push(item);
		rotation += inc;
	}
	ui_add_container_title(title, cont, items, show_if_empty);
	return {
		list: list,
		path: path,
		container: cont,
		cardcontainer: cardcont,
		items: items,
	}
}

function ui_type_deck(list, dParent, styles = {}, path = 'deck', title = 'deck', get_card_func = ari_get_card, show_if_empty = false) {
	let cont = ui_make_container(dParent, get_container_styles(styles));
	let cardcont = mDiv(cont);
	let items = [];
	ensure_ui(list, cardcont, items, get_card_func);
	ui_add_container_title(title, cont, items, show_if_empty);
	function get_topcard() { return isEmpty(list) ? null : items[0]; }
	function get_bottomcard() { return isEmpty(list) ? null : arrLast(items); }
	function ensure_ui(list, cardcont, items, get_card_func) {
		clearElement(cardcont); arrClear(items); if (isEmpty(list)) return;
		let n = Math.min(2, list.length); let ct = get_card_func(list[0]); items.push(ct); if (n > 1) { let cb = get_card_func(arrLast(list)); items.push(cb); }
		mStyle(cardcont, { position: 'relative', wmin: ct.w + 8, hmin: ct.h });
		for (let i = items.length - 1; i >= 0; i--) { let x = items[i]; face_down(x); mAppend(cardcont, iDiv(x)); mStyle(iDiv(x), { position: 'absolute', top: 0, left: 0 }) }
		mText(list.length, iDiv(ct), { position: 'absolute', left: list.length >= 100 ? '10%' : '25%', top: 10, fz: ct.h / 3 });
	}
	return {
		ctype: 'deck',
		container: cont,
		cardcontainer: cardcont,
		items: items,
		list: list,
		title: title,
		path: path,
		func: get_card_func,
		get_topcard: get_topcard,
		get_bottomcard: get_bottomcard,
		get_card_func: get_card_func,
		renew: ensure_ui,
	};
}

function ui_type_hand(list, dParent, styles = {}, path = 'hand', title = 'hand', get_card_func = ari_get_card, show_if_empty = false) {
	let cont = ui_make_container(dParent, get_container_styles(styles));
	let items = list.map(x => get_card_func(x));
	let cardcont = mDiv(cont);
	let card = isEmpty(items) ? { w: 1, h: Config.ui.card.h, ov: 0 } : items[0];
	let splay = 2;
	mContainerSplay(cardcont, splay, card.w, card.h, items.length, card.ov * card.w);
	ui_add_cards_to_hand_container(cardcont, items, list);
	ui_add_container_title(title, cont, items, show_if_empty);
	return {
		ctype: 'hand',
		list: list,
		path: path,
		container: cont,
		cardcontainer: cardcont,
		splay: splay,
		items: items,
	};
}

function ui_type_item(dParent, item, styles = {}, handler = null, show_key = null) {
	addKeys({ align: 'center', overflow: 'hidden', cursor: 'pointer', rounding: 10, margin: 10, padding: 5, w: 120, wmin: 90, display: 'inline-block', bg: 'random', fg: 'contrast' }, styles);
	let d = mDiv(dParent, styles);
	if (!isEmptyOrWhiteSpace(item.text)) mSpan(d, { family: item.family, fz: 50 }, item.text);
	if (show_key) {
		mSpan(d, { family: 'opensans' }, '<br>' + show_key);
	}
	if (isdef(handler)) d.onclick = handler;
	return d;
}

function ui_type_item_line(dParent, item, styles = {}, handler = null, props = []) {
	let d = mDiv(dParent, styles, `d_${item.key}`); mFlex(d);
	for (const p of props) {
		let family = p == 'text' ? item.family : 'arial';
		let fz = p == 'text' ? 40 : 20;
		mDiv(d, { family: family, fz: fz, bg: styles.bg, fg: styles.fg }, null, item[p]);
	}
	if (isdef(handler)) { d.onclick = handler; d.setAttribute('item', JSON.stringify(item)); }
	return d;
}

function ui_type_lead_hand(list, dParent, styles = {}, path = 'hand', title = 'hand', get_card_func = ari_get_card, show_if_empty = false) {
	let hcard = isdef(styles.h) ? styles.h - 30 : Config.ui.card.h;
	addKeys(get_container_styles(styles), styles);
	let cont = ui_make_container(dParent, styles);
	let items = list.map(x => get_card_func(x, hcard));
	let cardcont = mDiv(cont);
	let card = isEmpty(items) ? { w: 1, h: hcard, ov: 0 } : items[0];
	let splay = 5;
	mContainerSplay(cardcont, splay, card.w, card.h, items.length, card.ov * card.w);
	ui_add_cards_to_hand_container(cardcont, items, list);
	ui_add_container_title(title, cont, items, show_if_empty);
	return {
		ctype: 'hand',
		list: list,
		path: path,
		container: cont,
		cardcontainer: cardcont,
		splay: splay,
		items: items,
	};
}

function ui_type_market(list, dParent, styles = {}, path = 'market', title = 'market', get_card_func = ari_get_card, show_if_empty = false) {
	let cont = ui_make_container(dParent, get_container_styles(styles));
	let cardcont = mDiv(cont, { display: 'flex', gap: 2 });
	let items = list.map(x => get_card_func(x));
	items.map(x => mAppend(cardcont, iDiv(x)));
	ui_add_container_title(title, cont, items, show_if_empty);
	return {
		ctype: 'market',
		list: list,
		path: path,
		container: cont,
		cardcontainer: cardcont,
		items: items,
	};
}

function ui_type_rank_count(list, dParent, styles, path, title, get_card_func, show_if_empty = false) {
	let cont = ui_make_container(dParent, get_container_styles(styles));
	let cardcont = mDiv(cont, { display: 'flex' });
	let items = [];
	for (const o of list) {
		let d = mDiv(cardcont, { display: 'flex', dir: 'c', padding: 1, fz: 12, align: 'center', position: 'relative' });
		let c = get_card_func(o.key);
		mAppend(d, iDiv(c));
		remove_card_shadow(c);
		d.innerHTML += `<span style="font-weight:bold">${o.count}</span>`;
		let item = { card: c, count: o.count, div: d };
		items.push(item);
	}
	ui_add_container_title(title, cont, items, show_if_empty);
	return {
		list: list,
		path: path,
		container: cont,
		cardcontainer: cardcont,
		items: items,
	}
}

function ui_type_sym_text_line(dParent, item, styles = {}, handler = null) {
	let d = mDiv(dParent, styles, `d_${item.key}`); mFlex(d);
	let sym = valf(item.sym, Syms[item.key]);
	mDiv(d, { family: sym.family, fz: 40 }, null, sym.text);
	mDiv(d, { family: 'opensans', fz: 20 }, null, item.text);
	if (isdef(handler)) { d.onclick = handler; d.setAttribute('item', JSON.stringify(item)); }
	return d;
}

function ui_type_tile(ga, d, styles, classes) {
	let item = {};
	copyKeys(ga, item);
	let [sym, bg, id] = [Syms[ga.logo], ga.color, getUID()];
	item.id = id; item.isOpen = true;
	function open() {
		let item = Items[id];
		if (item.isOpen) return; item.isOpen = true;
		let d1 = iDiv(item); iClear(d1);
		let d2 = mDiv(d1, { position: 'absolute', top: 2, left: 2, display: 'flex', gap: 2 });
		let sz = 20;
		mDiv(d2, { fz: sz, family: sym.family, 'line-height': sz }, null, sym.text);
		mDiv(d2, { fz: sz - 5, 'line-height': sz }, null, item.friendly);
		console.log('item.name', item.name)
		let f = window[item.name + '_open']; if (isdef(f)) f(item);
	}
	function close(trigger = true) {
		let item = Items[id];
		if (!item.isOpen) return; item.isOpen = false;
		let d1 = iDiv(item); iClear(d1);
		mDiv(d1, { fz: 50, family: sym.family, 'line-height': 55 }, null, sym.text);
		mLinebreak(d1, 4);
		mDiv(d1, { fz: 18, align: 'center' }, null, item.friendly);
		if (!trigger) return;
		let f = window[item.name + '_close']; if (isdef(f)) f(item);
	}
	function toggle(ev) {
		evNoBubble(ev);
		let item = Items[id];
		if (item.isOpen) close(); else open();
	}
	let d1 = mDiv(d, { cursor: 'pointer', 'user-select': 'none', rounding: 10, margin: 10, vpadding: 15, hmin: 90, wmin: 140, bg: bg, position: 'relative' }, id, null, 'hop1');
	d1.setAttribute('name', ga.name);
	mCenterFlex(d1);
	iReg(item, { div: d1 });
	d1.onclick = toggle;
	close(false);
	return {
		item: item,
		open: open,
		close: close,
		toggle: toggle,
	}
}

function uid() {
	UID += 1;
	return 'a' + UID;
}

function uidHelpers() {
	UIDHelpers += 1;
	return 'id' + UIDHelpers;
}

function uiGetContact(row, msgs = {}) {
	let image = get_image_path(row);
	let mydata = `
      <div class='contact' style='position:relative;text-align:center;margin-bottom:18px;' username='${row.name}' onclick='start_chat(event)'>
        <img src='${image}' draggable='true' ondragstart='drag(event)' class='img_person sz100' style='margin:0;'/>
        <br>${row.name}`;
	if (isdef(msgs[row.username])) {
		mydata += `<div style='width:20px;height:20px;border-radius:50%;background-color:orange;color:white;position:absolute;left:0px;top:0px;'>` + msgs[row.username] + "</div>";
	}
	mydata += "</div>";
	return mydata;
}

function uiGetContacts(myusers, msgs) {
	mydata = '';
	for (const r of myusers) {
		row = r;
		mydata += uiGetContact(row, msgs);
	}
	return mydata;
}

function uiGetContactStylesAndStart() {
	let mydata = `
  <style>
    @keyframes appear{
      0%{opacity:0;transform: translateY(50px)}
      100%{opacity:1;transform: translateY(0px)}
     }
     .contact{
       cursor:pointer;
       transition: all .5s cubic-bezier(0.68, -2, 0.265, 1.55);
     }
     .contact:hover{
       transform: scale(1.1);
     }
  </style>
  <div style="text-align: center; animation: appear 1s ease both">
  `;
	return mydata;
}

function uiGetGame(gi, tables = []) {
	let sym = Syms[gi.logo];
	let bg = getColorDictColor(gi.color);
	let gname = gi.id;
	let uname = Session.cur_user;
	let color = null, id = getUID();
	if (!isEmpty(tables)) {
		let t = tables[0];
		let table_status = t.status;
		let my_status = t.player_status;
		let have_another_move = my_status == 'joined' || my_status == 'lamov';
		color = have_another_move ? 'green'
			: t.player_status == 'join' ? 'orange'
				: t.host == uname && t.status == 'ready' ? 'yellow'
					: table_status == 'show' || t.status == 'seen' ? 'blue'
						: t.status == 'ending' ? 'red' : 'black';
		id = `rk_${t.id}`;
	}
	return `
  <div onclick="onclick_game_in_games_menu(event)" gamename=${gi.id} style='cursor:pointer;border-radius:10px;margin:10px;padding:5px;padding-top:15px;width:120px;height:90px;display:inline-block;background:${bg};position:relative;'>
  ${nundef(color) ? '' : runderkreis(color, id)}
  <span style='font-size:50px;font-family:${sym.family}'>${sym.text}</span><br>${gi.friendly}</div>
  `;
}

function uiGetGames(mygames, tables) {
	mydata = '';
	for (const r of mygames) {
		row = r;
		mydata += uiGetGame(row, tables[r.id]);
	}
	return mydata;
}

function uiGetGamesStylesAndStart() {
	let mydata = `
  <style>
     .contact{
       cursor:pointer;
       transition: all .5s cubic-bezier(0.68, -2, 0.265, 1.55);
     }
     .contact:hover{
       transform: scale(1.1);
     }
  </style>
  <div id='game_menu' style="text-align: center; animation: appear 1s ease both">
  `;
	return mydata;
}

function uiGetLoginNew(row, msgs = {}) {
	let image = get_image_path(row);
	let mydata = `
      <div class='contact' style='position:relative;text-align:center;margin-bottom:18px;' username='${row.name}' 
        onclick='onclick_user_login_new(event)'>
        <img src='${image}' draggable='true' ondragstart='drag(event)' class='img_person sz100' style='margin:0;'/>
        <br>${row.name}`;
	if (isdef(msgs[row.username])) {
		mydata += `<div style='width:20px;height:20px;border-radius:50%;background-color:orange;color:white;position:absolute;left:0px;top:0px;'>` + msgs[row.username] + "</div>";
	}
	mydata += "</div>";
	return mydata;
}

function uiGetLoginNewList(myusers, msgs) {
	mydata = '';
	for (const r of myusers) {
		row = r;
		mydata += uiGetLoginNew(row, msgs);
	}
	return mydata;
}

function uiGetLoginNewStylesAndStart() {
	let mydata = `
  <style>
    @keyframes appear{
      0%{opacity:0;transform: translateY(50px)}
      100%{opacity:1;transform: translateY(0px)}
     }
     .contact{
       cursor:pointer;
       transition: all .5s cubic-bezier(0.68, -2, 0.265, 1.55);
     }
     .contact:hover{
       transform: scale(1.1);
     }
  </style>
  <div style="text-align: center; animation: appear 1s ease both">
  `;
	return mydata;
}

function uiNodesToUiTree(R) {
	let uiTree = {};
	for (const k in R.uiNodes) {
		let n = R.uiNodes[k];
		uiTree[k] = jsCopyMinus(n, 'act', 'ui', 'defParams', 'params');
	}
	return uiTree;
}

function unCamel(s) { return separateAtCapitals(s); }

function unCamelCase(s) { return separateAtCapitals(s); }

function uncheckAvailable(i) {
	id = getidAvailable(i); document.getElementById(id).checked = false;
}

function uncheckPlayer(i) {
	id = getidNum(i); document.getElementById(id).checked = false;
}

function uncollapseAll() {
	let coll = document.getElementsByClassName("collapsible");
	for (let i = 0; i < coll.length; i++) {
		let elem = coll[i];
		if (!isVisible(getLinkContainerId(elem.id))) fireClick(elem);
	}
}

function unfillChar(inp) { unfillCharInput(inp); }

function unfillCharInput(inp) {
	let d = iDiv(inp);
	d.innerHTML = '_';
	mClass(d, 'blink');
	inp.isBlank = true;
}

function unfillWord(winp) { winp.charInputs.map(x => unfillCharInput(x)); }

function unfocusOnEnter(ev) {
	if (ev.key === 'Enter') {
		ev.preventDefault();
		mBy('dummy').focus();
	}
}

function unfreezeUI() {
	if (!frozen) return;
	frozen = false;
	hide('tempFreezer');
}

function unhighAll(oid) { mapSafe('unhigh', getVisuals, oid); }

function unhighAux(oid) { mapSafe('unhigh', getAuxVisuals, oid); }

function unhighlightBoat() {
	if (boatHighlighted) {
		unhighlightMsAndRelatives(null, boatHighlighted);
		closeInfoboxesForBoatOids(boatHighlighted);
		boatHighlighted = null;
	}
}

function unhighlightContentIds(b) {
	let s = b.innerHTML;
	let ids = s.split(/[ ,:;]+/);
	for (const id of ids) {
		if (id == '_') continue;
		let msList = getVisuals(id);
		if (!msList) continue;
		for (const ms of msList) ms.unhigh();
	}
}

function unhighlightMsAndRelatives(ev, mobj, partName) {
	let id = mobj.id;
	mobj.unhigh(partName);
	let relativeIds = id2uids[id];
	if (nundef(relativeIds)) return;
	for (const idRel of relativeIds) {
		let msRel = UIS[idRel];
		msRel.unhigh('title');
	}
}

function unhighMain(oid) { mapSafe('unhigh', getVisual, oid); }

function unhighSelfAndRelatives(uid, R) {
	for (const oid of R.uid2oids[uid]) {
		for (const uid1 of R.oid2uids[oid]) {
			let ui = R.getUI(uid1);
			mUnhigh(ui);
		}
	}
	let n = R.uiNodes[uid];
	if (n.potentialOverlap) {
		let ui = R.getUI(uid);
		sendToBack(ui);
	}
}

function uniformSizeToContent(uid) {
	let n = R.uiNodes[uid];
	if (nundef(n.children)) return { w: 0, h: 0 }
	parentPadding = isdef(n.params.paddingAroundChildren) ? n.params.paddingAroundChildren : DEFS.defaultPadding;
	childMargin = isdef(n.params.gapBetweenChildren) ? n.params.gapBetweenChildren : DEFS.defaultGap;
	let or = n.params.orientation;
	let rows = cols = 1;
	if (or == 'w') { rows = n.params.rows; cols = n.params.cols; }
	let bl = n.params.baseline;
	let [y0, wTitle] = calcParentContentYOffsetAndWidth(n, parentPadding);
	let children = n.children.map(x => R.uiNodes[x]);
	if (or == 'w') {
		let wchi = Math.max(...children.map(x => x.size.w));
		let hchi = Math.max(...children.map(x => x.size.h));
		let wpar = 2 * parentPadding + wchi * cols + (cols - 1) * childMargin;
		let hpar = y0 + parentPadding + hchi * rows + (rows - 1) * childMargin;
		let xoff = (wTitle > wpar) ? (wTitle - wpar) / 2 : 0;
		let x = xoff + parentPadding;
		let y = y0;
		let i = 0;
		for (let r = 0; r < rows; r++) {
			for (let c = 0; c < cols; c++) {
				let ch = children[i];
				i += 1;
				ch.params.size = { w: wchi, h: hchi };
				ch.params.pos = { x: x, y: y };
				x += wchi + childMargin;
				setFixedSizeAndPos(ch);
			}
			x = xoff + parentPadding;
			y += hchi + childMargin;
		}
		return { w: wpar, h: hpar };
	}
	let axMain, ax2;
	if (or == 'v') { axMain = 'h'; ax2 = 'w'; }
	else if (or == 'h') { axMain = 'w'; ax2 = 'h'; }
	let ax2Max = Math.max(...children.map(x => x.size[ax2]));
	let axMainSum = children.reduce((a, b) => a + (b.size[axMain] || 0), 0);
	axMainSum += childMargin * (children.length - 1);
	let wmax = (or == 'v' ? ax2Max : axMainSum);
	let xoff = 0;
	if (wTitle > wmax) xoff = (wTitle - wmax) / 2;
	let x0 = parentPadding + xoff;
	let x = x0;
	let y = y0;
	let lastChild = R.uiNodes[n.children[n.children.length - 1]];
	for (const n1 of children) {
		if (or == 'v') {
			switch (bl) {
				case 'start': x = x0; break;
				case 'end': x = x0 + ax2Max - n1.size[ax2]; break;
				case 'centered': x = x0 + (ax2Max - n1.size[ax2]) / 2; break;
				case 'stretch':
					x = x0;
					if (n1.size.w < ax2Max) {
						n1.size.w = ax2Max;
						n1.ui.style.minWidth = n1.size.w + 'px';
					}
					break;
				default: x = x0 + (ax2Max - n1.size[ax2]) / 2; break;
			}
			n1.pos = { x: x, y: y, cx: x + n1.size.w / 2, cy: y + n1.size.h / 2 };
			y += n1.size[axMain];
			if (n1 != lastChild) y += childMargin;
		} else {
			switch (bl) {
				case 'start': y = y0; break;
				case 'end': y = y0 + ax2Max - n1.size[ax2]; break;
				case 'centered': y = y0 + (ax2Max - n1.size[ax2]) / 2; break;
				case 'stretch':
					y = y0;
					if (n1.size.h < ax2Max) {
						n1.size.h = ax2Max;
						n1.ui.style.minHeight = n1.size.h + 'px';
					}
					break;
				default: y = y0 + (ax2Max - n1.size[ax2]) / 2; break;
			}
			n1.pos = { x: x, y: y, cx: x + n1.size.w / 2, cy: y + n1.size.h / 2 };
			x += n1.size.w;
			if (n1 != lastChild) x += childMargin;
		}
		n1.ui.style.left = n1.pos.x + 'px';
		n1.ui.style.top = n1.pos.y + 'px';
	}
	let wParent, hParent;
	if (or == 'h') {
		wParent = Math.max(wTitle + parentPadding * 2, x + parentPadding);
		hParent = y0 + ax2Max + parentPadding;
	} else {
		wParent = Math.max(wTitle + parentPadding * 2, ax2Max + 2 * x0);
		hParent = y0 + axMainSum + parentPadding;
	}
	return { w: wParent, h: hParent };
}

function union(lst1, lst2) {
	return [...new Set([...lst1, ...lst2])];
}

function uniqueFirstLetters(arr) {
	let res = [];
	for (const s of arr) {
		if (s.length > 0) {
			addIf_dep(s[0], res);
		}
	}
	return res;
}

function unitTest8() {
	if (execOptions.activatedTests.includes('8699')) console.log(...arguments);
}

function unitTestAutoplay() {
	if (execOptions.activatedTests.includes('autoplay')) console.log(...arguments);
}

function unitTestBattle() {
	if (execOptions.activatedTests.includes('battle')) console.log(...arguments);
}

function unitTestBuildUnit() {
	if (execOptions.activatedTests.includes('buildUnit')) console.log(...arguments);
}

function unitTestCard() {
	if (execOptions.activatedTests.includes('card')) console.log(...arguments);
}

function unitTestCards() {
	if (execOptions.activatedTests.includes('cards')) console.log(...arguments);
}

function unitTestCardsNew() {
	if (execOptions.activatedTests.includes('cardsNew')) console.log(...arguments);
}

function unitTestChoice() {
	if (execOptions.activatedTests.includes('choice')) console.log(...arguments);
}

function unitTestChoicemin() {
	if (execOptions.activatedTests.includes('choice') || execOptions.activatedTests.includes('choicemin')) console.log(...arguments);
}

function unitTestCombat() {
	if (execOptions.activatedTests.includes('combat')) console.log(...arguments);
}

function unitTestCombatStage() {
	if (execOptions.activatedTests.includes('combatStage')) console.log(...arguments);
}

function unitTestConflict() {
	if (execOptions.activatedTests.includes('conflicts')) console.log(...arguments);
}

function unitTestControl() {
	if (execOptions.activatedTests.includes('control')) console.log(...arguments);
}

function unitTestConvoy() {
	if (execOptions.activatedTests.includes('convoy')) console.log(...arguments);
}

function unitTestDecision() {
	if (execOptions.activatedTests.includes('decision')) console.log(...arguments);
}

function unitTestDiplomacy() {
	if (execOptions.activatedTests.includes('diplomacy')) console.log(...arguments);
}

function unitTestFilter() {
	if (execOptions.activatedTests.includes('filter')) console.log(...arguments);
}

function unitTestFilterByType() {
	if (execOptions.activatedTests.includes('filterByType')) console.log(...arguments);
}

function unitTestFilterNation() {
	if (execOptions.activatedTests.includes('filterNation')) console.log(...arguments);
}

function unitTestGameloop() {
	if (execOptions.activatedTests.includes('gameloop')) console.log(...arguments);
}

function unitTestHover() {
	if (execOptions.activatedTests.includes('hover')) console.log(...arguments);
}

function unitTestInit() {
	if (execOptions.activatedTests.includes('init')) console.log(...arguments);
}

function unitTestLoad() {
	if (execOptions.activatedTests.includes('load')) console.log(...arguments);
}

function unitTestLog() {
	if (execOptions.activatedTests.includes('log')) console.log(...arguments);
}

function unitTestMap() {
	if (execOptions.activatedTests.includes('map')) console.log(...arguments);
}

function unitTestMatch() {
	if (execOptions.activatedTests.includes('match')) console.log(...arguments);
}

function unitTestMirrorBattle() {
	if (execOptions.activatedTests.includes('mirror')) console.log(...arguments);
}

function unitTestMovement() {
	if (execOptions.activatedTests.includes('movement')) console.log(...arguments);
}

function unitTestMoving() {
	if (execOptions.activatedTests.includes('moving')) console.log(...arguments);
}

function unitTestMS() {
	if (execOptions.activatedTests.includes('ms')) console.log(...arguments);
}

function unitTestPlayer() {
	if (execOptions.activatedTests.includes('player')) console.log(...arguments);
}

function unitTestRandom() {
	if (execOptions.activatedTests.includes('random')) console.log(...arguments);
}

function unitTestRemove() {
	if (execOptions.activatedTests.includes('remove')) console.log(...arguments);
}

function unitTestRemoved() {
	if (execOptions.activatedTests.includes('removed')) console.log(...arguments);
}

function unitTestRemovedCheck(data) {
	return execOptions.activatedTests.includes('removed') && 'removed' in data && !empty(Object.keys(data.removed));
}

function unitTestRequest() {
	if (execOptions.activatedTests.includes('request')) console.log(...arguments);
}

function unitTestResnail() {
	if (execOptions.activatedTests.includes('resnail')) console.log(...arguments);
}

function unitTestResponse() {
	if (execOptions.activatedTests.includes('response')) console.log(...arguments);
}

function unitTestSave() {
	if (execOptions.activatedTests.includes('save')) console.log(...arguments);
}

function unitTestScenario() {
	if (execOptions.activatedTests.includes('scenario')) console.log(...arguments);
}

function unitTestScenarioMin() {
	if (execOptions.activatedTests.includes('scenarioMin')) console.log(...arguments);
}

function unitTestScenarioWar() {
	if (execOptions.activatedTests.includes('scenarioWar')) console.log(...arguments);
}

function unitTestSeason() {
	if (execOptions.activatedTests.includes('season')) console.log(...arguments);
}

function unitTestSender() {
	if (execOptions.activatedTests.includes('sender')) console.log(...arguments);
}

function unitTestServer() {
	if (execOptions.activatedTests.includes('server')) console.log(...arguments);
}

function unitTestSkip() {
	if (execOptions.activatedTests.includes('skip')) console.log(...arguments);
}

function unitTestStage() {
	if (execOptions.activatedTests.includes('stage')) console.log(...arguments);
}

function unitTestStrategy() {
	if (execOptions.activatedTests.includes('strategy')) console.log(...arguments);
}

function unitTestUnits() {
	if (execOptions.activatedTests.includes('units')) console.log(...arguments);
}

function unitTestUnitVisibility() {
	if (execOptions.activatedTests.includes('visible')) console.log(...arguments);
}

function unitTestUpgradeUnit() {
	if (execOptions.activatedTests.includes('upgradeUnit')) console.log(...arguments);
}

function unitTimeUp() { return (Settings.minutesPerUnit * 60000 - getTimeElapsed()) <= 0; }

function unlink(id) {
	let oids = id2oids[id];
	let uids = id2uids[id];
	if (isdef(uids)) for (const uid of uids) removeInPlace(id2uids[uid], id);
	if (isdef(oids)) for (const oid of oids) removeInPlace(oid2ids[oid], id);
	delete id2uids[id];
	delete id2oids[id];
}

function unpack_table(table) {
	for (const k of ['players', 'fen', 'options', 'scoring']) {
		let val = table[k];
		if (isdef(table[k])) table[k] = if_stringified(val); if (nundef(table[k])) table[k] = {};
	}
	if (isdef(table.modified)) { table.modified = Number(table.modified); table.timestamp = new Date(table.modified); table.stime = stringBeforeLast(table.timestamp.toString(), 'G').trim(); }
	assertion(isdef(window[table.game]), 'game function for ' + table.game + ' not defined in window');
	if (isdef(table.game)) { table.func = window[table.game](); }
	if (isdef(table.options.mode)) { table.mode = table.options.mode; }
	delete table.action; delete table.expected;
	return table;
}

function untie_card(card) {
	remove_from_selection(card);
	clear_selection();
	let oldgroupid = card.groupid;
	if (isdef(oldgroupid)) delete card.owner;
	let oldgroup = Items[oldgroupid];
	let oldindex = isdef(oldgroup) ? oldgroup.ids.indexOf(card.id) : null;
	if (isdef(oldgroup)) removeInPlace(oldgroup.ids, card.id);
	return [oldgroup, oldindex];
}

function update(time) {
	var t = time - lastUpdate;
	lastUpdate = time;
	ball.update(t);
	ai.update();
	requestAnimationFrame(update);
}

function update_car(canvas, item) {
	let di = { ArrowUp: canvas.math ? 90 : 270, ArrowDown: canvas.math ? 270 : 90, ArrowLeft: 180, ArrowRight: 0 };
	for (const key in di) {
		if (is_key_down(key)) {
			item.v.a = di[key];
			update_position(item);
			return true;
		}
	}
	return false;
}

function update_cur_table(obj, color) {
	let t = Session.cur_table;
	let tnew = obj.table;
	if (isdef(obj.player_record)) copyKeys(obj.player_record, tnew);
	copyKeys(tnew, t);
	if (isdef(color)) {
		let d = mBy(`rk_${obj.table.id}`);
		if (isdef(d)) mStyle(d, { bg: color });
	}
}

function update_current_table() {
	let o = Serverdata.table;
	assertion(isdef(U), 'NO USER LOGGED IN WHEN GETTING TABLE FROM SERVER!!!!!!!!!!!!!!!!!!!!', U, o);
	if (nundef(Z) || nundef(Z.prev)) Z = { prev: {} };
	assertion(isdef(Z), 'ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ', Z);
	set_user(U.name);
	for (const wichtig of ['notes', 'uplayer', 'friendly', 'step', 'round', 'phase', 'stage', 'timestamp', 'modified', 'stime', 'mode', 'scoring']) {
		if (isdef(Z[wichtig])) Z.prev[wichtig] = jsCopy(Z[wichtig]);
	}
	Z.prev.turn = Clientdata.last_turn;
	copyKeys(o, Z, { uname: true });
	let [mode, turn, uname, plorder, fen, host] = [Z.mode, Z.turn, Z.uname, Z.plorder, Z.fen, Z.host];
	assertion(!isEmpty(turn), 'turn empty!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!', turn, fen, plorder);
	Z.role = !plorder.includes(uname) ? 'spectator' : turn.includes(uname) ? 'active' : 'inactive';
	if (Z.game == 'fritz' && Z.role == 'spectator' && isdef(Z.fen.roundorder) && Z.fen.roundorder.includes(uname)) {
		Z.role = 'inactive';
	}
	let upl = Z.role == 'active' ? uname : turn[0];
	if (mode == 'hotseat' && turn.length > 1) { let next = get_next_human_player(Z.prev.uplayer); if (next) upl = next; }
	if (mode == 'multi' && Z.role == 'inactive' && (uname != host || is_human_player(upl))) {
		upl = uname;
	}
	set_player(upl, fen);
	let [uplayer, pl] = [Z.uplayer, Z.pl];
	Z.playmode = pl.playmode;
	if (Z.playmode != 'human') Z.strategy = pl.strategy;
	let [friendly, modified] = [Z.friendly, Z.modified];
	Z.skip_presentation = !FORCE_REDRAW && friendly == Z.prev.friendly && modified <= Z.prev.modified && uplayer == Z.prev.uplayer;
	FORCE_REDRAW = false;
	if (Z.skip_presentation) {
		show_status(`nothing new in ${Z.friendly}`);
		const STOP_POLLING_AFTER = 30000;
		if (nundef(DA.noshow)) DA.noshow = 1; else DA.noshow++; if (DA.noshow >= STOP_POLLING_AFTER) onclick_stoppolling();
		autopoll();
	} else {
		DA.noshow = 0;
		delete DA.sperre;
		clear_timeouts();
	}
}

function update_db_user_from_pl_options(fen, game) {
	let parts = fen.split(',');
	for (const p of parts) {
		let [name, startlevel, lang] = p.split(':');
		startlevel = Number(startlevel);
		set_startlevel(name, game, startlevel);
		set_preferred_lang(name, lang);
	}
}

function update_draw_items() {
	for (const item of get_values(Items)) {
		if (isdef(item.update)) item.update(item);
		if (isdef(item.draw)) item.draw(item);
	}
}

function update_func(canvas, item) {
	let [cv, ctx, ia, ib, ifunc, axes] = [canvas.cv, canvas.cx, item.ia, item.ib, item.ifunc, item.axes];
	cClear(cv, ctx);
	showAxes(ctx, axes);
	let [la, lb, lf] = [[1, 2, 3, 4, 5, 5, 5, 4, 3, 2], [0, .5, 1, 1.5, 2, 2.5, 2.5, 2.5, 2, 1.5, 1, .5], ['sin', 'cos']];
	let [a, b, f] = [la[ia], lb[ib], lf[ifunc]];
	[item.ia, item.ib, item.ifunc] = [(ia + 1) % la.length, (ib + 1) % lb.length, (ifunc + 1) % lf.length];
	funGraph(ctx, axes, x => Math[f](a * x), "rgb(11,153,11)", 1);
	return false;
}

function update_game_status(players) {
	let d = dTitle;
	clearElement(d);
	let d1 = mDiv(d, { display: 'flex', 'justify-content': 'center', 'align-items': 'space-evenly' });
	for (const plname in players) {
		let pl = players[plname];
		let d2 = mDiv(d1, { margin: 4, align: 'center' }, null, `<img src='${pl.imgPath}' style="display:block" class='img_person' width=50 height=50>${pl.score}`);
	}
}

function update_game_values() {
	let game = Session.cur_game;
	let uname = Session.cur_user;
	let g = Session;
	let basevals = lookup(DB.games, [game]); if (basevals) copyKeys(basevals, g);
	for (const k in g.options) { g[k] = get_game_or_user_option(g, k); }
	let uservals = lookup(DB.users, [uname, 'games', game]); if (uservals) copyKeys(uservals, g);
	let levels = lookup(DB.games, [game, 'levels']);
	g.maxlevel = valf(get_keys(levels).length, 0) - 1;
	g.color = getColorDictColor(g.color);
	let level = g.level = nundef(g.level_setting) || g.level_setting == 'player' ? valf(g.startlevel, g.def_startlevel)
		: g.level_setting == 'min' ? 0 : g.level_setting == 'max' ? g.maxlevel : g.def_startlevel;
	if (levels) copyKeys(levels[level], g);
	delete g.levels;
	return g;
}

function update_language_choices(g) {
	let langs = g.availableLanguages;
	let language_holder = mBy('language_holder');
	clearElement(language_holder);
	let friendly = { E: 'english', D: 'german', S: 'spanish', F: 'french', C: 'mandarin' };
	if (isdef(language_holder) && isdef(langs) && langs.length > 1) {
		let avail = toLetterList(langs);
		let labels = avail.map(x => friendly[x]);
		let esel = mSelect(language_holder, avail, friendly, valf(g.lang, 'E'), (ev) => {
			let sel = ev.target;
			let val = sel.value;
			console.log('selected language', val)
			set_language(val, false);
		});
		mClass(esel.firstChild, 'statusselect');
	} else if (isdef(language_holder)) {
		mDiv(language_holder, { patop: 6 }, null, friendly[g.lang], 'statusselect');
	}
}

function update_move(canvas, item) {
	item.y += 1;
	item.y = cycle(item.y, canvas.miny, canvas.maxy);
	return true;
}

function update_my_score(inc) {
	let me = Session.cur_players[Session.cur_user];
	me.score += inc;
	return me.score;
}

function update_otree_from_ui(otree, objects) {
	for (const k in objects) {
		otree[k] = objects[k].list;
	}
	qanim();
}

function update_position(item) {
	let [a1, a2] = [item.a, item.v.a];
	let diff = Math.abs(a2 - a1);
	let inc = valf(item.turn_inc, 0);
	if (inc && diff > inc) {
		let cclock = is_turn_counter_clockwise(a1, a2);
		if (cclock) inc = -inc;
		let anew = a1 + inc;
		anew = (anew + 360) % 360;
		item.a = anew;
	} else {
		item.a = a2 % 360;
		let angle = toRadian(item.a);
		item.x += Math.cos(angle) * item.v.mag;
		item.y += Math.sin(angle) * item.v.mag;
	}
}

function update_session(obj) {
	for (const k in obj) { if (isdef(Session[k])) copyKeys(obj[k], Session[k]); else Session[k] = obj[k]; }
	if (isdef(obj.table)) {
		Session.cur_table = Session.table;
		Session.cur_funcs = window[Session.cur_game]();
		if (!isEmpty(obj.playerdata)) make_players(Session.table.players);
		console.assert(isdef(Session.cur_user) && Session.cur_game == Session.table.game && Session.cur_tid == Session.table.id, "SESSION MISMATCH IN GAME_OPEN_FOR_MOVE!!!!!!!!!!!!!!!!!!!!!");
	}
	if (isdef(obj.playerdata)) {
		let o = Session.cur_players;
		for (const rec of obj.playerdata) {
			if (rec.state == 'null') rec.state = null;
			copyKeys(rec, o[rec.name]);
		}
	}
}

function update_settings() {
	for (const k in settings) {
		let lower = k.toLowerCase();
		let inp = mBy(`i_${lower}`);
		if (isdef(inp)) {
			let value = Number(inp.innerHTML);
			if (isNumber(value)) settings[k] = value;
		}
	}
	socket.emit('settings', JSON.stringify(settings));
}

function update_table() {
	assertion(isdef(U), 'NO USER LOGGED IN WHEN GETTING TABLE FROM SERVER!!!!!!!!!!!!!!!!!!!!', U);
	if (nundef(Z) || nundef(Z.prev)) Z = { prev: {} };
	for (const wichtig of ['playerdata', 'notes', 'uplayer', 'uname', 'friendly', 'step', 'round', 'phase', 'stage', 'timestamp', 'modified', 'stime', 'mode', 'scoring']) {
		if (isdef(Z[wichtig])) Z.prev[wichtig] = jsCopy(Z[wichtig]);
	}
	Z.prev.turn = Clientdata.last_turn = Clientdata.this_turn;
	copyKeys(Serverdata, Z);
	if (isdef(Serverdata.table)) { copyKeys(Serverdata.table, Z); Z.playerlist = Z.players; copyKeys(Serverdata.table.fen, Z); }
	assertion(isdef(Z.fen), 'no fen in Z bei cmd=table or startgame!!!', Serverdata);
	Clientdata.this_turn = Z.turn;
	set_user(U.name);
	assertion(!isEmpty(Z.turn), 'turn empty!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!', Z.turn);
	let fen = Z.fen;
	Z.role = !is_playing(Z.uname, fen) ? 'spectator' : fen.turn.includes(Z.uname) ? 'active' : 'inactive';
	let [uname, turn, mode, host] = [Z.uname, fen.turn, Z.mode, Z.host];
	let upl = Z.role == 'active' ? uname : turn[0];
	if (mode == 'hotseat' && turn.length > 1) { let next = get_next_human_player(Z.prev.uplayer); if (next) upl = next; }
	if (mode == 'multi' && Z.role == 'inactive' && (uname != host || is_human_player(upl))) { upl = uname; }
	set_player(upl, fen);
	let pl = Z.pl;
	Z.playmode = pl.playmode;
	Z.strategy = uname == pl.name ? valf(Clientdata.strategy, pl.strategy) : pl.strategy;
	let [uplayer, friendly, modified] = [Z.uplayer, Z.friendly, Z.modified];
	Z.uplayer_data = firstCond(Z.playerdata, x => x.name == Z.uplayer);
	let sametable = !FORCE_REDRAW && friendly == Z.prev.friendly && modified <= Z.prev.modified && uplayer == Z.prev.uplayer;
	let sameplayerdata = isEmpty(Z.playerdata_changed_for);
	let myplayerdatachanged = Z.playerdata_changed_for.includes(Z.uplayer);
	let specialcase = !i_am_host() && !i_am_acting_host() && !i_am_trigger() && !myplayerdatachanged;
	Z.skip_presentation = sametable && (sameplayerdata || specialcase);
	if (DA.TEST0 && (!sametable || !sameplayerdata)) {
		console.log('======>Z.skip_presentation', Z.skip_presentation, '\nplayerdata_changed_for', Z.playerdata_changed_for);
		console.log('_______ *** THE END *** ___________')
	}
	FORCE_REDRAW = false;
}

function update_table_options_for_user(uname, table_options, game) {
	let lang = get_preferred_lang(uname);
	update_db_user_from_pl_options(table_options, game);
	let lang2 = get_preferred_lang(uname);
	if (lang != lang2) get_dictionary();
}

function updateBindings(supd, R) {
	for (const oid in supd) {
		for (const upd of supd[oid]) {
			let ukind = upd.ukind;
			if (ukind == 'valueChange') {
				let propUpdated = upd.prop;
				let skeys = R.getR(oid);
				let akku = [];
				recCollect(R.ROOT, x => { return x.oid == oid }, akku, true);
				for (const n of akku) {
					updateNode(n, upd, R);
				}
			}
		}
	}
}

function updateBubbleColors(e) {
	const w = window.innerWidth / 255;
	const h = window.innerHeight / 255;
	const x = parseInt(e.pageX / w, 10);
	const y = parseInt(e.pageY / h, 10);
	const r = x;
	const g = (y - 255) * -1;
	const b = x <= y ? y - x : 0;
	container.style.setProperty('--colorEnd', `rgb(${r},${g},${b})`);
}

function updateCollections() {
	S.settings.collectionTypes = { playerProps: ['hand', 'devcards'], objectProps: ['neutral'] };
	_updateCollections(G.playersUpdated, G.playersAugmented, S.settings.collectionTypes.playerProps);
	_updateCollections(G.tableUpdated, G.table, S.settings.collectionTypes.objectProps);
}

function updateColors(o) {
	let pal = S.pals[o.iPalette];
	let bg = pal[o.ipal];
	o.setBg(bg);
	if (o.strInfo && o.strInfo.ipals) {
		let ipals = o.strInfo.ipals;
		for (const id of o.ids) {
			let o = getVisual(id);
			if (o.isManual) continue;
			let info = o.memInfo;
			if (info && info.isPal) {
				let ipal = ipals[info.memType == 'field' ? 0 : info.memType == 'corner' ? 1 : 2];
				o.setBg(pal[ipal], false);
			}
		}
	}
}

function updateCreatedBindings(sCreated, R) {
	for (const oid in sCreated) {
		R.addObject(oid, o);
		for (const sp in R.getSpec()) {
		}
		for (const upd of sCreated[oid]) {
			let ukind = upd.ukind;
			if (ukind == 'valueChange') {
				let propUpdated = upd.prop;
				let skeys = R.getR(oid);
				let akku = [];
				recCollect(R.ROOT, x => { return x.oid == oid }, akku, true);
				for (const n of akku) {
					updateNode(n, upd, R);
				}
			}
		}
	}
}

function UpdateDOMStats() {
	var scoreText = "Score: " + (domUpdate_score / 100).toFixed(2);
	if (Math.abs(domUpdate_score) > MATE - MAXDEPTH) {
		scoreText = "Score: " + "Mate In " + (MATE - Math.abs(domUpdate_score)) + " moves";
	}
	$("#OrderingOut").text("Ordering: " + domUpdate_ordering + "%");
	$("#DepthOut").text("Depth: " + domUpdate_depth);
	$("#ScoreOut").text(scoreText);
	$("#NodesOut").text("Nodes: " + domUpdate_nodes);
	$("#TimeOut").text("Time: " + (($.now() - srch_start) / 1000).toFixed(1) + "s");
}

function updateGameArea() {
	var x, height, gap, minHeight, maxHeight, minGap, maxGap;
	for (i = 0; i < obstacles.length; i += 1) {
		if (meme.crashWith(obstacles[i])) {
			return;
		}
	}
	myGameArea.clear();
	myGameArea.frameNo += 1;
	if (myGameArea.frameNo == 1 || everyinterval(150)) {
		x = myGameArea.canvas.width;
		minHeight = 20;
		maxHeight = 200;
		height = Math.floor(Math.random() * (maxHeight - minHeight + 1) + minHeight);
		minGap = 50;
		maxGap = 200;
		gap = Math.floor(Math.random() * (maxGap - minGap + 1) + minGap);
		obstacles.push(new component(10, height, 'green', x, 0));
		obstacles.push(new component(10, x - height - gap, 'green', x, height + gap));
	}
	for (i = 0; i < obstacles.length; i += 1) {
		obstacles[i].x += -1;
		obstacles[i].draw();
	}
	score.text = 'SCORE: ' + myGameArea.frameNo;
	score.draw();
	meme.newPos();
	meme.draw();
}

function updateGamename(gamename) {
	currentGamename = gamename;
	let gi = allGames[gamename];
	currentPlayersById = {};
	plidByIndex = gi.player_names;
	for (const plid of gi.player_names) {
		currentPlayersById[plid] = {};
	}
	numPlayersMin = arrMin(gi.num_players);
	numPlayersMax = arrMax(gi.num_players);
}

function updateGamenameUi(id, color) {
	let uiName = 'spGame';
	let ui = mBy(uiName);
	if (nundef(ui)) {
		ui = mEditableOnEdited(uiName, dLineTopMiddle, 'game: ', '', changeGameTo, () => {
			console.log('Games', getGames());
		});
	}
	ui.innerHTML = id;
	mStyleX(ui, { fg: color });
}

function updateGameplayerCardCollections(pid, oPlayer) {
	let msPlayerArea = getPlayerArea(pid);
	for (const propName in oPlayer) {
		let plColls = getCollections(pid, propName);
		if (nundef(plColls)) continue;
		for (const key in plColls) {
			let coll = plColls[key];
			if (!coll.tbd) continue;
			let idCollection = getCollectionArea(key, msPlayerArea);
			showCollection(coll, idCollection);
			coll.tbd = null;
		}
	}
}

async function updateGroupInfo() {
	let syms20 = await route_path_yaml_dict('../assets/speech/syms2020.yaml');
	console.log(syms20);
	console.log(KeySets);
	for (const k in syms20) {
		KeySets.all.push(k);
		KeySets.huge.push(k);
		let info = syms20[k];
		if (isdef(info.ngroup)) {
			for (const n of [25, 50, 100]) {
				if (info.ngroup <= n) KeySets['best' + n].push(k);
			}
		}
		if (info.group != 'smileys-emotion') { KeySets.nemo.push(k); if (isdef(info.ngroup)) KeySets.nemo100.push(k); }
		switch (info.group) {
			case 'object': KeySets.object.push(k); KeySets.object50.push(k); KeySets.objectPlus.push(k); break;
			case 'animal': KeySets.life.push(k); KeySets.life50.push(k); KeySets.lifePlus.push(k); break;
			case 'fruit': KeySets.life.push(k); KeySets.life50.push(k); KeySets.lifePlus.push(k); break;
			case 'food': KeySets.life.push(k); KeySets.life50.push(k); KeySets.lifePlus.push(k); break;
			case 'drink': KeySets.life.push(k); KeySets.life50.push(k); KeySets.lifePlus.push(k); break;
			case 'vegetable': KeySets.life.push(k); KeySets.life50.push(k); KeySets.lifePlus.push(k); break;
			case 'smileys-emotion': KeySets.emo.push(k); break;
			case 'people-body': break;
			default: console.log('forgot group', info.group); break;
		}
	}
	addCatsToKeys();
}

function updateKeySettings(nMin) {
	if (nundef(G)) return;
	G.keys = setKeys({ nMin, lang: Settings.language, keysets: KeySets, key: Settings.vocab });
}

function updateLabelSettings() {
	console.assert(isdef(Score.labels), 'Score not set!!!!!')
	if (Settings.showLabels == 'toggle') Settings.labels = Score.labels == true;
	else Settings.labels = (Settings.showLabels == 'always');
}

function UpdateListsMaterial() {
	var piece, sq, index, colour;
	for (index = 0; index < BRD_SQ_NUM; ++index) {
		sq = index;
		piece = brd_pieces[index];
		if (piece != PIECES.OFFBOARD && piece != PIECES.EMPTY) {
			colour = PieceCol[piece];
			brd_material[colour] += PieceVal[piece];
			brd_pList[PCEINDEX(piece, brd_pceNum[piece])] = sq;
			brd_pceNum[piece]++;
		}
	}
}

function updateLoginHeader() { document.getElementById('hUsername').innerHTML = 'logged in as <b>' + clientData.name + '</b>'; }

function updateNode(n, upd, R) {
	let oid = upd.oid;
	let o = R.getO(upd.oid);
	if (upd.ukind == 'valueChange') {
		let prop = upd.prop;
		let oldval = o[prop];
		o[prop] = upd.newval;
		let f = RUPDATE[n.type];
		if (isdef(f)) {
			let ui = n.ui;
			let data = n.data;
			if (data == '.' + upd.prop) {
				n.content = calcContentFromData(oid, o, n.data, R);
			}
			f(ui, n.content);
		}
	}
}

function updateOutput(R) {
	for (const area of ['spec', 'uiTree', 'rTree', 'oidNodes', 'dicts', 'refsIds']) { //'channelsStatic', 'channelsLive' 
		clearElement(area);
	}
	if (SHOW_SPEC) { presentNodes(R.lastSpec, 'spec'); }
	if (SHOW_UITREE) {
		presentDictTree(R.uiNodes, R.tree.uid, 'uiTree', 'children', R,
			['children'],
			null,
			['ui', 'act', 'params', 'defParams', 'cssParams', 'typParams', 'stdParams'],
			{ 'max-width': '35%', font: '14px arial' });
	}
	if (SHOW_RTREE) {
		presentDictTree(R.rNodes, R.tree.uid, 'rTree', 'children', R,
			['children'], null, null, { 'max-width': '35%', font: '14px arial' });
	}
	if (SHOW_OIDNODES) { presentOidNodes(R, 'oidNodes'); }
	if (SHOW_DICTIONARIES) {
		mDictionary(R.rNodesOidKey, { dParent: mBy('dicts'), title: 'rNodesOidKey ' + Object.keys(R.rNodesOidKey).length });
		mDictionary(R.Locations, { dParent: mBy('dicts'), title: 'locations ' + Object.keys(R.Locations).length });
	}
	if (SHOW_IDS_REFS) {
		mDictionary(R.places, { dParent: mBy('refsIds'), title: 'places ' + Object.keys(R.places).length });
		mDictionary(R.refs, { dParent: mBy('refsIds'), title: 'refs ' + Object.keys(R.refs).length });
	}
	if (nundef(R.rNodes)) return;
	let numRTree = Object.keys(R.rNodes).length;
	let numUiNodes = nundef(R.uiNodes) ? 0 : Object.keys(R.uiNodes).length;
	let handCounted = R.ROOT.data;
	console.assert(numRTree == numUiNodes, '!!!FEHLCOUNT!!! #rtree=' + numRTree + ', #uiNodes=' + numUiNodes);
}

function updateOutput_dep(R) {
	for (const area of ['spec', 'uiTree', 'rTree', 'oidNodes', 'dicts']) {
		clearElement(area);
	}
	if (SHOW_SPEC) { presentNodes(R.lastSpec, 'spec'); }
	if (SHOW_UITREE) {
		presentDictTree(R.uiNodes, R.tree.uid, 'uiTree', 'children', R,
			['children'],
			['uid', 'adirty', 'type', 'data', 'content', 'uiType', 'oid', 'key', 'boardType'],
			null,
			{ 'max-width': '35%', font: '14px arial' });
	}
	if (SHOW_RTREE) {
		presentDictTree(R.rNodes, R.tree.uid, 'rTree', 'children', R,
			['children'], null, null, { 'max-width': '35%', font: '14px arial' });
	}
	if (SHOW_OIDNODES) { presentOidNodes(R, 'oidNodes'); }
	if (SHOW_DICTIONARIES) {
		mDictionary(R.rNodesOidKey, { dParent: mBy('dicts'), title: 'rNodesOidKey ' + Object.keys(R.rNodesOidKey).length });
		mDictionary(R.Locations, { dParent: mBy('dicts'), title: 'locations ' + Object.keys(R.Locations).length });
	}
	let numRTree = Object.keys(R.rNodes).length;
	let numUiNodes = nundef(R.uiNodes) ? 0 : Object.keys(R.uiNodes).length;
	let handCounted = R.ROOT.data;
	console.assert(numRTree == numUiNodes, '!!!FEHLCOUNT!!! #rtree=' + numRTree + ', #uiNodes=' + numUiNodes);
}

function updatePlayerConfig() {
	let keysPlayerColors = Object.keys(PLAYER_COLORS);
	let iColor = 0;
	for (const id in serverData.players) {
		let pl = serverData.players[id];
		let colorName = isdef(pl.color) ? pl.color : keysPlayerColors[iColor];
		colorName = colorName.toLowerCase();
		let altName = capitalize(colorName);
		let color = isdef(PLAYER_COLORS[colorName]) ? PLAYER_COLORS[colorName] : colorName;
		playerConfig[GAME].players[id].color = color;
		iColor += 1;
	}
}

function updatePlayersForGame() {
	currentNumPlayers = 0;
	for (let i = 1; i <= MAX_PLAYERS_AVAILABLE; i += 1) {
		if (i <= numPlayersMin) { currentNumPlayers += 1; showPlayer(i); checkPlayer(i); makePlayerReadOnly(i); }
		else if (i <= numPlayersMax) { showPlayer(i); uncheckPlayer(i); }
		else { hidePlayer(i); }
	}
}

function updatePlayersForMode() {
	let mode = currentPlaymode;
	let val = 'me';
	let n = MAX_PLAYERS_AVAILABLE;
	for (let i = 1; i <= n; i += 1) {
		let id = getidType(i);
		if (!isVisible(id)) continue;
		if (mode == 'solo') { populateSelect(i, soloTypes, val); val = 'AI regular'; }
		else if (mode == 'hotseat' || mode == 'passplay') { populateSelect(i, soloTypes, val); }
		else {
			populateSelect(i, allPlayerTypes, val);
			val = PLAYER_CONFIG_FOR_MULTIPLAYER.length > i ? PLAYER_CONFIG_FOR_MULTIPLAYER[i] : 'human';
		}
	}
}

function updatePlaymode(mode) {
	currentPlaymode = mode;
	makePlayermodeReadOnly('multiplayer');
}

function updatePreviewImage(dParent, file, sz = 768) {
	const url = URL.createObjectURL(file);
	dParent.innerHTML = `<img src="${url}" height=${sz}/>`;
}

function updatePreviewImages(dParent, files) {
	for (const f of files) {
		let sz = 200;
		let d = mDiv(dParent, { display: 'inline', w: sz, h: sz });
		updatePreviewImage(d, f, sz);
	}
}

function updateSettings() {
	appSpecificSettings();
	for (const k in SettingTypesCommon) {
		if (SettingTypesCommon[k]) {
			lookupSetOverride(U, ['settings', k], Settings[k]);
		} else {
			if (isdef(G.id)) lookupSetOverride(U, ['games', G.id, 'settings', k], Settings[k]);
		}
	}
}

function updateSizes(nuiBoard) {
	let szOrig = nuiBoard.params.sizes.f;
	let szNew = szOrig;
	let cSizeOrig = nuiBoard.params.sizes.c;
	let cSizeNew = cSizeOrig;
	let eSizeOrig = nuiBoard.params.sizes.e;
	let eSizeNew = eSizeOrig;
	if (nundef(nuiBoard.resizeInfo)) nuiBoard.resizeInfo = {};
	if (isdef(nuiBoard.resizeInfo.fields)) {
		szNew = nuiBoard.resizeInfo.fields;
	}
	if (isdef(nuiBoard.resizeInfo.corners)) {
		cSizeNew = nuiBoard.resizeInfo.corners;
	}
	szNew = Math.max(szNew, cSizeNew);
	if (isdef(nuiBoard.resizeInfo.edges)) {
		eSizeNew = nuiBoard.resizeInfo.edges;
	}
	szNew = Math.max(szNew, eSizeNew);
	return { sOrig: { f: szOrig, c: cSizeOrig, e: eSizeOrig }, sNew: { f: szNew, c: cSizeNew, e: eSizeNew } };
}

function updateSpeakmodeSettings() {
	if (Settings.silentMode && Settings.spokenFeedback) Settings.spokenFeedback = false;
}

function updateStartLevelForUser(game, level, msg) {
	lookupSetOverride(U.games, [game, 'startLevel'], level);
	saveUser();
}

async function updateSymbolDict() {
	let snew = await route_path_yaml_dict('../assets/syms.yaml');
	let sold = await route_path_yaml_dict('../assets/symbolDict.yaml');
	let soldlc = {};
	for (const k in sold) {
		let klc = k.toLowerCase();
		let o = soldlc[klc] = sold[k];
		o.key = klc;
	}
	for (const k in snew) {
		if (nundef(soldlc[k])) {
			soldlc[k] = snew[k];
			console.log('new key added to symbolDict', k)
		} else {
			let onew = snew[k];
			let oold = soldlc[k];
			if (onew.type != oold.type) {
				soldlc[k] = onew;
				console.log('symbolDict key updated', k)
			}
		}
	}
	downloadAsYaml(soldlc, 'symbolDict_upd');
}

async function updateSymbolDictFromDictionaries() {
	[EdDict, DeDict] = await loadGerman();
	let ekeys = Object.keys(EdDict);
	let lowerEKeys = ekeys.map(x => x.toLowerCase());
	console.log('dict e=>d', ekeys);
	ensureSymByType();
	let keys = symKeysByType['icon'];
	console.log('keys', keys);
	let inter = intersection(keys, lowerEKeys);
	console.log('intersection:', inter);
	for (const k of inter) {
		let entry = lookup(EdDict, [k, 'd']);
		if (nundef(entry)) {
			console.log('gibt es nicht!', k)
		} else {
			console.log('entry', entry)
			console.log('JA!', k, entry.join('|'));
			symbolDict[k].D = entry.join('|').toLowerCase();
			symbolDict[k].E = k;
		}
	}
	downloadAsYaml(symbolDict, 'symbolDict');
}

function updateTableCardCollections() {
	let msTableArea = getTabletopCardsArea();
	for (const oid in collections) {
		if (nundef(G.table[oid])) continue;
		let o = G.table[oid];
		for (const propName in o) {
			let colls = getCollections(oid, propName);
			if (nundef(colls)) continue;
			for (const key in colls) {
				let coll = colls[key];
				if (!coll.tbd) continue;
				let idCollection = getCollectionArea(key, msTableArea);
				showCollection(coll, idCollection);
				coll.tbd = null;
			}
		}
	}
}

function updateTableCardCollections_COPY(oid) {
	if (nundef(collections[oid])) return;
	let msArea = getTabletopCardsArea();
	if (isEmpty(collections)) {
		return;
	}
	for (const propName of G.tableUpdated[oid].summary) {
		let o = G.table[propName];
		let plColl = getTableCollections(oid, propName);
		if (isdef(plColl)) {
			for (const key in plColl) {
				let ha = plColl[key];
				let idCollection = getCollectionArea(key, msArea);
				let divHand = UIS[idCollection].elem;
				divHand.style.position = null;
				getSimpleSetElements(ha.hand)
				showPlayerHandNew(ha.name, ha.arr, key);
			}
		}
	}
}

function updateTablenameUi(id, color) {
	let uiName = 'spTable';
	let ui = mBy(uiName);
	if (nundef(ui)) {
		ui = mEditableOnEdited(uiName, dLineTopRight, 'table: ', '', changeTableTo, () => {
			console.log('Tables', getTables());
		});
	}
	ui.innerHTML = id;
	mStyleX(ui, { fg: color });
}

function updateTestInput(index) {
	let elem = mBy('iTestCase');
	if (isdef(elem)) {
		elem.max = Object.keys(testEngine.specs).length - 1;
		elem.min = 0;
		elem.value = index;
	}
}

function updateTimeSettings() {
	let timeElem = mBy('time');
	if (Settings.showTime) { show(timeElem); startTime(timeElem); }
	else hide(timeElem);
}

function updateTooltipContent(oid) {
	let pool = findPool(oid);
	let o = pool[oid];
	ttTitle(oid, o);
	ttBody(oid, o);
}

function updateTooltipContent_hallo(id) {
	let oid = getOidForMainId(id);
	let pool = findPool(id);
	let o = pool[id];
	console.log('tt', id, oid, o)
	return;
	ttTitle(id, o);
	ttBody(id, o);
}

function updateUsernameUi(id, color) {
	let uiName = 'spUser';
	let ui = mBy(uiName);
	if (nundef(ui)) {
		ui = mEditableOnEdited(uiName, dLineTopLeft, 'user: ', '', changeUserTo, () => {
			console.log('Users', getUsers());
		});
	}
	ui.innerHTML = id;
	mStyleX(ui, { fg: color });
}

function updateUserScore() {
	if (nundef(Score.nTotal) || Score.nTotal <= 0) return;
	let sc = { nTotal: Score.nTotal, nCorrect: Score.nCorrect, nCorrect1: Score.nCorrect1, nWins: Score.nWins, nLoses: Score.nLoses, nTied: Score.nTied };
	let g = G.id;
	let recOld = lookupSet(U, ['games', g], { startLevel: 0, nTotal: 0, nCorrect: 0, nCorrect1: 0, nWins: 0, nLoses: 0, nTied: 0 });
	let recSession = lookupSet(U, ['session', g], { startLevel: 0, nTotal: 0, nCorrect: 0, nCorrect1: 0, nWins: 0, nLoses: 0, nTied: 0 });
	addByKey(sc, recSession);
	let counts = DB.games[g].controllerType == 'solo' ? recSession.nWins : recSession.nCorrect;
	recSession.percentage = Math.round(100 * counts / recSession.nTotal);
	addByKey(sc, recOld);
	counts = DB.games[g].controllerType == 'solo' ? recOld.nWins : recOld.nCorrect;
	recOld.percentage = Math.round(100 * recOld.nCorrect / recOld.nTotal);
	Score.nTotal = Score.nCorrect = Score.nCorrect1 = 0;
	saveUser();
}

function upgradeToSimpleGraph(g, dParent, styles = {}) {
	g.id = nundef(dParent.id) ? getUID() : dParent.id;
	let styleDict = {
		node: { 'width': 25, 'height': 25, 'background-color': 'red', "color": "#fff", 'label': 'data(id)', "text-valign": "center", "text-halign": "center", },
		edge: { 'width': 2, 'line-color': 'silver', 'curve-style': 'haystack', },
		'node.highlight': { 'background-color': 'yellow' },
		'node.trans': { 'opacity': '0.5' },
	}
	for (const ks of ['node', 'edge', 'node.highlight', 'node.trans']) {
		if (isdef(styles[ks])) {
			for (const k in styles[ks]) {
				let [prop, val] = translateToCssStyle(k, styles[ks][k], false);
				styleDict[ks][prop] = val;
			}
		}
	}
	let cyStyle = [];
	for (const k in styleDict) { cyStyle.push({ selector: k, style: styleDict[k] }); }
	let size = getSize(dParent);
	let d1 = mDiv(dParent, { position: 'relative', bg: 'green', w: size.w - 80, left: 40, top: 0, h: size.h, align: 'left' });
	g.cy.mount(d1);
	g.cy.style(cyStyle);
	g.enablePanZoom();
	iAdd(g, { div: dParent, dCy: d1 });
}

function uploadImgData(imgFile) {
	let pack = {};
	let data = imgFile.data;
	let filename = imgFile.name; console.log('filename', filename);
	let key = stringBefore(filename, '.');
	pack[key] = { data: data, name: key, filename: filename, type: 'imageData' };
	Socket.emit('generalImages', { pack: pack });
	console.log('uploading pack', pack);
}

function user_already_loaded(name) { return isdef(name && name == Session.cur_user); }

function userUpdate(proplist, val) {
	lookupSetOverride(U, proplist, val);
	saveUser();
}

function useSymbolElemNO(key = 'Treff', h = 50, x = 0, y = 0) {
	return mCreateFrom(`<use xlink:href="#${key}" height="${h}" x="${x}" y="${y}"></use>`);
}

function utter(text, r = .5, p = .8, v = .5, voiceDesc, callback = null) {
	let [voiceKey, voice] = findSuitableVoice(text, voiceDesc);
	utterance.text = sepWords(text, voiceKey);
	utterance.rate = r;
	utterance.pitch = p;
	utterance.volume = v;
	utterance.voice = voice;
	utterance.onend = callback;
	synth.onend
	if (isdef(timeout2)) { clearTimeout(timeout2); }
	timeout2 = setTimeout(() => {
		if (!isINTERRUPT) {
			isSpeakerRunning = true;
		}
		synth.speak(utterance); focus(mBy(defaultFocusElement));
	}, 200);
}

function valf() {
	for (const arg of arguments) if (isdef(arg)) return arg;
	return null;
}

function valfi() {
	for (const arg of arguments) {
		if (isdef(arg)) return arg;
	}
	return null;
}

function valnwhite() {
	for (const arg of arguments) if (isdef(arg) && !isEmptyOrWhiteSpace(arg)) return arg;
	return null;
}

function valToString(n) { if (isFractionType(n)) return getTextForFractionX(n.n, n.d); else return n; }

function valueOfElement(id) {
	return document.getElementById(id).value;
}

function verify_min_req() {
	let [fen, uplayer] = [Z.fen, Z.uplayer];
	let pl = fen.players[uplayer];
	let jsorted = jsCopy(pl.journeys).sort((a, b) => b.length - a.length);
	let di = {
		'3': jsorted.length > 0 && is_group(jsorted[0]) && jsorted[0].length >= 3,
		'33': jsorted.length > 1 && is_group(jsorted[0]) && jsorted[0].length >= 3
			&& is_group(jsorted[1]) && jsorted[1].length >= 3,
		'4': jsorted.length > 0 && is_group(jsorted[0]) && jsorted[0].length >= 4,
		'44': jsorted.length > 1 && is_group(jsorted[0]) && jsorted[0].length >= 4
			&& is_group(jsorted[1]) && jsorted[1].length >= 4,
		'5': jsorted.length > 0 && is_group(jsorted[0]) && jsorted[0].length >= 5,
		'55': jsorted.length > 1 && is_group(jsorted[0]) && jsorted[0].length >= 5
			&& is_group(jsorted[1]) && jsorted[1].length >= 5,
		'7R': jsorted.length > 0 && is_sequence(jsorted[0]) && jsorted[0].length >= 7,
	};
	let goals = is_fixed_goal() ? [get_round_goal()] : get_available_goals(uplayer);
	for (const g of goals) {
		if (di[g] == true) { return true; }
	}
	return false;
}

function verify_unit_test(otree) {
	if (isdef(DA.verify) && ITER == DA.iter_verify) {
		TestRunning = false;
		let res = DA.verify(otree);
		console.log('***UNIT TEST ' + TestNumber, res ? 'passed...' : 'FAILED!!!!!!!!!!!!!!!!');
		console.assert(res, '*** STOP TEST FAIL ***')
		if (TestSuiteRunning) test_engine_run_next(TestList);
	}
	return true;
}

async function verifySequence(indexFrom, indexTo, saveOnCompleted = false) {
	show('btnStop');
	console.log('______________ verify from', indexFrom, 'to', indexTo, 'save', saveOnCompleted);
	testEngine.autosave = true;
	clearElement(mBy('table'));
	let series = testEngine.series;
	let maxIndex = indexTo;
	let index = indexFrom;
	await testEngine.loadTestCase(series, index);
	await rParse(RSG_SOURCE, { defs: testEngine.defs, spec: testEngine.spec, sdata: testEngine.sdata });
	setTimeout(async () => { await verNext(series, index + 1, maxIndex, saveOnCompleted); }, 1000);
}

async function verNext(series, index, maxIndex, saveOnCompleted = false) {
	await testEngine.loadTestCase(series, index);
	await rParse(RSG_SOURCE, { defs: testEngine.defs, spec: testEngine.spec, sdata: testEngine.sdata });
	let timeOUT = 500;
	if (index < maxIndex && !STOP) setTimeout(async () => { await verNext(series, index + 1, maxIndex, saveOnCompleted); }, timeOUT);
	else {
		isTraceOn = SHOW_TRACE;
		STOP = false;
		hide('btnStop');
		if (saveOnCompleted) saveSolutions(series, testEngine.Dict[series].solutions);
	}
}

function visNumber(n, dParent, color, or = 'h', asNumber = [0]) {
	if (!isNumber(n) || asNumber.includes(n)) return zText('' + n, dParent, { fg: 'white', fz: 64 });
	return _visualizeNumber(n, dParent, color, or);
}

function visOperation(op, a, b, dParent, symResult) {
	switch (op) {
		case 'plus':
		case 'minus': return _visualizeAritOp(op, a, b, dParent, symResult); break;
		case 'mult': return _visualizeMult(a, b, dParent, symResult); break;
	}
}

function visOperator(s, dParent, styles = { fg: 'white', fz: 64 }) {
	zText(s, dParent, styles);
}

function visual(shape, { ipal, fill, x, y, w, h, sPoints, border, thickness, rounding, path, txt, fz, sz }, overlay = true, draw = true) {
	let ms = new MS(uid(), 'g');
	let options = {};
	if (ipal) fill = getpal(ipal);
	if (fill) options.fill = fill;
	if (x) options.x = x;
	if (y) options.y = y;
	if (w) options.w = w;
	if (h) options.h = h;
	if (txt) options.txt = txt;
	if (fz) options.fz = fz;
	if (sz) options.sz = sz;
	if (sPoints) options.sPoints = sPoints;
	if (border) options.border = border;
	if (thickness) options.thickness = thickness;
	if (rounding) options.rounding = rounding;
	if (path) options.path = './assets/images/transpng/' + path + '.png';
	switch (shape) {
		case 'circle':
			ms.circle(options);
			break;
		case 'hex':
			ms.hex(options);
			break;
		case 'rect':
			ms.rect(options);
			break;
		case 'poly':
			ms.poly(options);
			break;
		case 'image':
			ms.image(options);
			break;
		case 'text':
			ms.text(options);
			break;
		default:
			return null;
	}
	if (overlay) {
		overlayOptions = jsCopy(options);
		overlayOptions.className = 'overlay';
		delete overlayOptions.fill;
		delete overlayOptions.path;
		switch (shape) {
			case 'circle':
				ms.circle(overlayOptions);
				break;
			case 'hex':
				ms.hex(overlayOptions);
				break;
			case 'rect':
				ms.rect(overlayOptions);
				break;
			case 'poly':
				ms.poly(overlayOptions);
				break;
			case 'image':
				ms.rect(overlayOptions);
				break;
			case 'text':
				ms.text(overlayOptions);
				break;
			default:
				return null;
		}
	}
	if (draw) ms.draw();
	return ms;
}

function visualAttributeSetter(c) {
	let props = 'innerHTML onclick';
	for (const k of props.split(' ')) {
		propertyGiver(c, k, x => c.visual[k] = x, () => c.visual[k]);
	}
}

function visualPropertySetter(c) {
	let props = 'bg fg h w background color height width rounding padding fz font align';
	for (const k of props.split(' ')) {
		propertyGiver(c, k,
			x => { let styles = {}; styles[k] = x; mStyle(c.visual, styles); },
			() => { return mGetStyle(c.visual, k); }
		);
	}
}

function waitForLogin() {
	initDom();
	openTabTesting('Seattle');
}

async function wegMitwh() {
	let syms = await route_path_yaml_dict('../assets/syms.yaml');
	let newSyms = {};
	for (const k in syms) {
		let info = jsCopy(syms[k]);
		info.w = info.w[0];
		info.h = info.h[0];
		newSyms[k] = info;
	}
	downloadAsYaml(newSyms, 'syms');
}

function weiter_process_inspect() {
	let [stage, A, fen, uplayer] = [Z.stage, Z.A, Z.fen, Z.uplayer];
	let item = A.items[A.selected[0]];
	let uibuilding = A.uibuilding = item.o;
	let fenbuilding = A.fenbuilding = lookup(fen, uibuilding.path.split('.'));
	let key = uibuilding.keycard.key;
	let cards = uibuilding.items;
	let schweine_cand = [];
	for (let i = 1; i < cards.length; i++) {
		if (fenbuilding.schweine.includes(i)) continue;
		let card = cards[i];
		if (card.key == key) continue;
		assertion(i == card.index, 'wrong card index!!!!')
		schweine_cand.push(card);
	}
	if (schweine_cand.length > 1) {
		Z.stage = 38;
		ari_pre_action();
	} else if (schweine_cand.length == 1) {
		setTimeout(() => turn_new_schwein_up(schweine_cand[0], fenbuilding, uibuilding), 3000);
	} else if (isEmpty(fenbuilding.schweine)) {
		Z.stage = 29;
		ari_history_list([`${uplayer} inspects a correct building`], 'inspect');
		show_instruction('the building is CORRECT - You loose 1 rumor')
		setTimeout(ari_pre_action, 2000);
	} else {
		let rumor = fen.deck_rumors[0]; fen.deck_rumors.shift();
		fen.players[uplayer].rumors.push(rumor);
		show_instruction('no additional schwein has been found - you gain 1 rumor')
		ari_history_list([`${uplayer} inspects a schweine!`], 'inspect');
		setTimeout(ari_next_action, 2000);
	}
}

function whenSoundPaused() {
	_sndPlayer = null;
	_sndPlayerIdle = true;
	_loaded = false;
	if (!isEmpty(_qSound)) { _deqSound(); } else { _idleSound = true; }
}

function where(o) {
	let fname = getFunctionsNameThatCalledThisFunction();
}

function whichGame(callback) { let route = '/game/info'; _sendRouteJS(route, callback); }

function whoAmI() {
	let gc = S.gameConfig;
	return { username: USERNAME, playerOnTurn: G.player, myPlayers: [S.gameConfi] }
}

function wise() {
	function state_info(dParent) { return; }
	function setup(players, options) {
		let fen = { players: {}, plorder: jsCopy(players), history: [], num: options.num };
		let starter = fen.starter = fen.plorder[0];
		Sayings = shuffle(Sayings);
		fen.index = 0;
		fen.saying = Sayings[fen.index];
		for (const plname of players) {
			let pl = fen.players[plname] = {
				score: 0,
				name: plname,
				color: get_user_color(plname),
			};
		}
		[fen.phase, fen.stage, fen.step, fen.turn] = ['one', 'write', 0, jsCopy(fen.plorder)];
		return fen;
	}
	function check_gameover() {
		let winners = [];
		for (const plname of Z.plorder) {
			let cond = get_player_score(plname) >= Z.options.winning_score;
			if (cond) { winners.push(plname); }
		}
		if (!isEmpty(winners)) Z.fen.winners = winners;
		return isEmpty(winners) ? false : Z.fen.winners;
	}
	function post_collect() { agmove_resolve(); }
	return { post_collect, state_info, setup, present: wise_present, check_gameover, activate_ui: wise_activate };
}

function wise_activate() {
	let [pldata, stage, A, fen, phase, uplayer] = [Z.playerdata, Z.stage, Z.A, Z.fen, Z.phase, Z.uplayer];
	let donelist = Z.playerdata.filter(x => isDict(x.state));
	let complete = donelist.length == Z.plorder.length;
	let resolvable = uplayer == fen.starter && complete;
	let waiting = !resolvable && isdef(donelist.find(x => x.name == uplayer));
	console.log(uplayer, stage, 'done', donelist, 'complete', complete, 'waiting', waiting);
	Z.isWaiting = false;
	if (waiting) {
		mDiv(dTable, {}, null, 'WAITING FOR PLAYERS TO COMPLETE....');
		if (complete) {
			Z.turn = [fen.starter];
			if (Z.mode != 'multi') take_turn_waiting();
		}
		Z.isWaiting = true;
		autopoll();
	} else if (stage == 'write' && resolvable) {
		assertion(uplayer == fen.starter, 'NOT THE STARTER WHO COMPLETES THE STAGE!!!')
		let start = fen.saying.start.toLowerCase();
		let sentences = [];
		for (const pldata of Z.playerdata) {
			let plname = pldata.name;
			let text = start + ' ' + pldata.state.text;
			sentences.push({ plname: plname, text: text.toLowerCase() });
		}
		sentences.push({ plname: '', text: start + ' ' + fen.saying.end.toLowerCase() });
		fen.sentences = shuffle(sentences);
		Z.turn = jsCopy(Z.plorder);
		Z.stage = 'select';
		take_turn_fen_clear();
	} else if (stage == 'write') {
		let d = mCreate('form');
		let dt = dTable;
		mAppend(dt, d);
		d.autocomplete = "off";
		d.action = "javascript:void(0);";
		mDiv(d, { fz: 20 }, 'dForm', fen.saying.start.toLowerCase() + '...');
		Z.form = d;
		mLinebreak(d, 10);
		mInput(d, { wmin: 600 }, 'i_end', 'enter ending');
		d.onsubmit = wise_submit_text;
	} else if (stage == 'select' && resolvable) {
		assertion(uplayer == fen.starter, 'NOT THE STARTER WHO COMPLETES THE STAGE!!!')
		let d = mDiv(dTable, {});
		fen.result = {};
		for (const pldata of Z.playerdata) {
			let selecting = pldata.name;
			let selected = pldata.state.plname;
			let text = pldata.state.text;
			if (isEmpty(selected)) {
				console.log('REINGEGANGEN!!!!!!!!!!!!!!')
				fen.players[selecting].score += 1;
				selected = 'correct';
			} else if (selecting != selected) {
				fen.players[selected].score += 1;
			}
			fen.result[selecting] = { plname: selected, text: text };
		}
		delete fen.sentences;
		Z.turn = jsCopy(Z.plorder);
		Z.stage = 'round';
		take_turn_fen_clear();
	} else if (stage == 'select') {
		let d = mDiv(dTable, {});
		let i = 1;
		for (const s of fen.sentences) {
			let d1 = mDiv(d, { fz: 20, hline: 30 }, `dsent_${s.plname}`, '' + (i++) + ') ' + s.text, 'hop1');
			d1.onclick = wise_select_sentence;
		}
	} else if (stage == 'round' && resolvable) {
		assertion(uplayer == fen.starter, 'NOT THE STARTER WHO COMPLETES THE STAGE!!!')
		delete fen.result;
		Z.turn = jsCopy(Z.plorder);
		fen.index++;
		fen.saying = Sayings[fen.index];
		Z.stage = 'write';
		take_turn_fen_clear();
	} else if (stage == 'round') {
		let d = mDiv(dTable, {});
		for (const plname in fen.result) {
			let o = fen.result[plname];
			let d1 = mDiv(d, { fz: 20, hline: 30 }, null, `${plname} selected ${o.plname}: ${o.text}`);
		}
		mLinebreak(dTable, 12)
		mButton('WEITER', wise_onclick_weiter, dTable, {}, ['donebutton', 'enabled']);
	} else {
		console.log('Z', Z)
		alert('PROBLEM!!!')
	}
}

function wise_onclick_weiter() {
	Z.state = { plname: Z.uplayer };
	take_turn_multi();
}

function wise_present(dParent) {
	let [fen, ui, stage, uplayer] = [Z.fen, UI, Z.stage, Z.uplayer];
	let [dOben, dOpenTable, dMiddle, dRechts] = tableLayoutMR(dParent, 1, 0);
	let dt = dTable = dOpenTable; clearElement(dt); mCenterFlex(dt);
	wise_stats(dt);
	mLinebreak(dt, 10);
}

function wise_select_sentence(ev) {
	if (!uiActivated) return;
	let text = ev.target.innerHTML;
	let plname = stringAfter(ev.target.id, 'dsent_')
	Z.state = { plname: plname, text: text };
	take_turn_multi();
}

function wise_stats(d) {
	let players = Z.fen.players;
	let d1 = mDiv(d, { display: 'flex', 'justify-content': 'center', 'align-items': 'space-evenly' });
	for (const plname of get_present_order()) {
		let pl = players[plname];
		let onturn = Z.turn.includes(plname);
		let sz = 50;
		let bcolor = plname == Z.uplayer ? 'lime' : 'silver';
		let border = pl.playmode == 'bot' ? `double 5px ${bcolor}` : `solid 5px ${bcolor}`;
		let rounding = pl.playmode == 'bot' ? '0px' : '50%';
		let d2 = mDiv(d1, { margin: 4, align: 'center' }, null, `<img src='../base/assets/images/${plname}.jpg' style="border-radius:${rounding};display:block;border:${border};box-sizing:border-box" class='img_person' width=${sz} height=${sz}>${get_player_score(plname)}`);
	}
}

function wise_submit_text(ev) { ev.preventDefault(); let text = mBy('i_end').value; Z.state = { text: text }; take_turn_multi(); }

function without(arr, elementToRemove) {
	return arr.filter(function (el) {
		return el !== elementToRemove;
	});
}

function wlog() {
	let s = '';
	for (const a of arguments) {
		s += a + ' ';
	}
	console.log(s);
}

function wordCorrectionFactor(text, styles, w, h, fz) {
	styles.fz = fz;
	let size = getSizeWithStyles(text, styles);
	let hFactor = 1; let wFactor = 1;
	if (size.h > h - 1) { hFactor = size.h / h; }
	if (size.w > w - 1) { wFactor = size.w / w; }
	if (size.w < w && size.h < h) return 0;
	else return Math.max(hFactor, wFactor);
}

function wordsFromToText(i, n = 300) {
	let list = [];
	for (const k in symbolDict) {
		let info = symbolDict[k];
		if (nundef(info.bestE) || !isString(info.bestE) || info.bestE.length < 2) continue;
		addIf(list, info.bestE);
	}
	let sfromi = arrFromIndex(list, i);
	s300 = arrTake(sfromi, n);
	let s = s300.join('\n');
	console.log(s);
	downloadTextFile(s, 'words_' + i);
}

function wordsOfLanguage(key, language) {
	let y = symbolDict[key];
	let w = y[language];
	let wlist = w.split('|');
	return wlist.map(x => x.trim());
}

function worldMap(loc) {
	let html =
		`<div id="map_area" class="grid_div" style="width:340px;height:220px;background-color:rgba(86, 182, 222);">
      <svg width="100%" height="100%" viewBox="0 0 3400 2200" style="box-sizing:border-box;">
        <g id="mapG" >
          <image id="imgMap" href="/assets/tnt/TTmap.jpg" />
        </g>
      </svg>
    </div>`;
	let d = mBy(loc);
	d.innerHTML = html;
}

function wrapLayoutColarr(num) {
	const arr = [[0], [1], [2], [1, 2], [2, 2], [2, 3], [3, 3], [2, 3, 2], [2, 3, 3], [3, 3, 3], [3, 4, 3], [3, 4, 4], [4, 4, 4]];
	return num < arr.length ? arr[num] : [num];
}

function wrapLayoutPosition(nBoard, tile, R) {
	let margin = 2;
	let uids = tile.children;
	let colarr = wrapLayoutColarr(uids.length);
	let rows = colarr.length;
	let iNode = 0;
	let nChild = R.uiNodes[uids[0]];
	let size0 = R.uiNodes[uids[0]].size;
	let wChild = getBounds(nChild.ui).width;
	let xOffset = nBoard.size.w / 2 + tile.pos.x - size0.w / 2;
	let yOffset = nBoard.size.h / 2 + tile.pos.y - size0.h / 2;
	let x = 0;
	let y = 0;
	let dx = size0.w + margin;
	let dy = size0.h + margin;
	for (let r = 0; r < rows; r++) {
		x = 0;
		y = r * dy - (rows * dy - dy) / 2;
		let wrow = colarr[r] * dx - dx;
		for (let c = 0; c < colarr[r]; c++) {
			let robber = R.uiNodes[uids[iNode]];
			let ui = robber.ui;
			ui.style.position = 'absolute';
			ui.style.display = 'inline-block';
			ui.style.boxSizing = 'border-box'
			let xPos = x + xOffset - wrow / 2;
			let yPos = y + yOffset;
			robber.pos = { x: xPos, y: yPos };
			ui.style.left = xPos + 'px';
			ui.style.top = yPos + 'px';
			ui.style.margin = '0px';
			x += dx;
			iNode += 1;
		}
	}
}

function wrapLayoutSizeNeeded(uids, R) {
	const arr = [[0], [1], [2], [1, 2], [2, 2], [2, 3], [3, 3], [2, 3, 2], [2, 3, 3], [3, 3, 3], [3, 4, 3], [3, 4, 4], [4, 4, 4]];
	let colarr = wrapLayoutColarr(uids.length);
	let rows = colarr.length;
	let iNode = 0;
	let wmax = 0;
	let maxNumPerRow = 0;
	let htot = 0;
	for (let r = 0; r < rows; r++) {
		let hmax = 0;
		let wtot = 0;
		for (let c = 0; c < colarr[r]; c++) {
			let n = R.uiNodes[uids[iNode]];
			let h = n.size.h;
			let w = n.size.w;
			hmax = Math.max(hmax, h);
			wtot += w;
			maxNumPerRow = Math.max(maxNumPerRow, c);
		}
		wmax = Math.max(wmax, wtot);
		htot += hmax;
	}
	let margin = 2;
	let wNeeded = wmax + margin * (maxNumPerRow + 1);
	let hNeeded = htot + margin * (rows + 1);
	return { w: wNeeded, h: hNeeded };
}

function write() { if (verbose) console.log(...arguments); }

function writeComments(pre) {
	console.log('NEEEEEEEEEEEEEEEEEEEEIIIIIIIIIIIIIIIIIN', getFunctionsNameThatCalledThisFunction())
	if (ROUND_OUTPUT) {
		console.log('...' + currentGame.substring(1), pre + ' currentLevel:' + currentLevel, 'pics:' + NumPics,
			'labels:' + NumLabels,
			'\nkeys:' + currentKeys.length, 'minlen:' + MinWordLength, 'maxlen:' + MaxWordLength, 'trials#:' + MaxNumTrials);
	}
}

function writeExp() { }

function writeSound() { return; console.log('calling playSound'); }

function yesNo() { return tossCoin(50); }

function yPics(ifs, options) {
	let keys = choose(SymKeys, n);
	console.log(keys)
	showPicsS(keys);
}

function yRandomPic(ifs, options) {
}

function zoom(factor) {
	bodyZoom = factor;
	if (Math.abs(bodyZoom - 1) < .2) bodyZoom = 1;
	document.body.style.transformOrigin = '0% 0%';
	document.body.style.transform = 'scale(' + bodyZoom + ')';
	localStorage.setItem('bodyZoom', bodyZoom);
}

function zoom_on_resize(referenceDivId) {
	if (!window.onresize) {
		window.onresize = () => {
			let newBrowserZoom = Math.round(window.devicePixelRatio * 100);
			if (isdef(browserZoom) && browserZoom != newBrowserZoom) { browserZoom = newBrowserZoom; return; }
			if (nundef(browserZoom) || browserZoom == newBrowserZoom) {
				let wNeeded = document.getElementById(referenceDivId).getBoundingClientRect().width;
				let wNeededReally = wNeeded / bodyZoom;
				let wHave = window.innerWidth;
				let zn = wHave / wNeeded;
				let znr = wHave / wNeededReally;
				if (Math.abs(znr - bodyZoom) > .01) zoom(znr);
			}
			browserZoom = newBrowserZoom;
		};
	}
}

function zoom_on_wheel_alt() {
	if (!window.onwheel) {
		window.addEventListener("wheel", ev => {
			if (!ev.altKey || ev.ctrlKey) return;
			ev.preventDefault();
			if (ev.deltaY > 0) { zoomOut(); } else if (ev.deltaY < 0) zoomIn();
		}, { passive: false });
	}
}

function zoomBy(x) { if (nundef(bodyZoom)) bodyZoom = 1; zoom(bodyZoom * x); }

function zoomIn() { zoomBy(1.5); }

function zoomOut() { zoomBy(.7); }

function zPicS(item, dParent, styles = {}) {
	let w = styles.w, h = styles.h, padding = styles.padding, hpadding = styles.hpadding, wpadding = styles.wpadding;
	if (isdef(styles.sz)) {
		if (nundef(w)) w = styles.sz;
		if (nundef(h)) h = styles.sz;
	}
	let stylesNew = jsCopy(styles);
	if (isdef(w)) {
		if (isdef(padding)) { w -= 2 * padding; }
		else if (isdef(wpadding)) { w -= 2 * wpadding; }
		stylesNew.w = w;
	}
	if (isdef(h)) {
		if (isdef(padding)) { h -= 2 * padding; }
		else if (isdef(hpadding)) { h -= 2 * hpadding; }
		stylesNew.h = h;
	}
	return _zPicS(item, dParent, stylesNew);
}

function zRepeatEachItem(items, repeat, shufflePositions = false) {
	let orig = items;
	let itRepeat = items;
	for (let i = 1; i < repeat; i++) { itRepeat = itRepeat.concat(orig.map(x => registeredItemCopy(x))); }
	if (shufflePositions) { shuffle(itRepeat); }
	let labelRepeat = {};
	let idx = 0;
	for (const item of itRepeat) {
		let iRepeat = labelRepeat[item.label];
		if (nundef(iRepeat)) iRepeat = 1; else iRepeat += 1;
		item.iRepeat = iRepeat;
		item.index = idx; idx += 1;
		labelRepeat[item.label] = iRepeat;
	}
	return itRepeat;
}

function zRepeatInColorEachItem(items, colorKeys) {
	let itColors = [];
	for (let i = 0; i < colorKeys.length; i++) {
		let newItems;
		if (i > 0) { newItems = jsCopy(items); newItems.map(x => registerAsNewItem(x)); }
		else newItems = items;
		itColors = itColors.concat(newItems);
	}
	for (let i = 0; i < colorKeys.length; i++) {
		let colorKey = colorKeys[i];
		let textShadowColor = ColorDict[colorKey].c;
		for (let j = 0; j < items.length; j++) {
			let index = i * items.length + j;
			let x = itColors[index];
			x.index = index;
			x.textShadowColor = textShadowColor;
			x.color = ColorDict[colorKey];
			x.colorKey = colorKey;
		}
	}
	return itColors;
}

function zText(text, dParent, textStyles, hText, vCenter = false) {
	let tSize = getSizeWithStyles(text, textStyles);
	let extra = 0, lines = 1;
	if (isdef(hText)) {
		extra = hText - tSize.h;
		if (textStyles.fz) lines = Math.floor(tSize.h / textStyles.fz);
	}
	let dText = isdef(text) ? mText(text, dParent, textStyles) : mDiv(dParent);
	if (extra > 0 && vCenter) {
		dText.style.paddingTop = (extra / 2) + 'px';
		dText.style.paddingBottom = (extra / 2) + 'px';
	}
	return { text: text, div: dText, extra: extra, lines: lines, h: tSize.h, w: tSize.w, fz: textStyles.fz };
}

